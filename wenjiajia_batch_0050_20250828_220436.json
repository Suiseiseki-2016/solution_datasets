{
  "metadata": {
    "batch_number": 50,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.765633",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "556/D",
      "title": "D. Case of Fugitive",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n (2 ≤ n ≤ 2·105) and m (1 ≤ m ≤ 2·105) — the number of islands and bridges.Next n lines each contain two integers li and ri (1 ≤ li ≤ ri ≤ 1018) — the coordinates of the island endpoints.The last line contains m integer numbers a1, a2, ..., am (1 ≤ ai ≤ 1018) — the lengths of the bridges that Andrewid got.",
      "output_spec": "OutputIf it is impossible to place a bridge between each pair of adjacent islands in the required manner, print on a single line \"No\" (without the quotes), otherwise print in the first line \"Yes\" (without the quotes), and in the second line print n - 1 numbers b1, b2, ..., bn - 1, which mean that between islands i and i + 1 there must be used a bridge number bi. If there are multiple correct answers, print any of them. Note that in this problem it is necessary to print \"Yes\" and \"No\" in correct case.",
      "sample_tests": "ExamplesInputCopy4 41 47 89 1012 144 5 3 8OutputCopyYes2 3 1 InputCopy2 211 1417 182 9OutputCopyNoInputCopy2 11 11000000000000000000 1000000000000000000999999999999999999OutputCopyYes1",
      "description": "D. Case of Fugitive\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers n (2 ≤ n ≤ 2·105) and m (1 ≤ m ≤ 2·105) — the number of islands and bridges.Next n lines each contain two integers li and ri (1 ≤ li ≤ ri ≤ 1018) — the coordinates of the island endpoints.The last line contains m integer numbers a1, a2, ..., am (1 ≤ ai ≤ 1018) — the lengths of the bridges that Andrewid got.\n\nOutputIf it is impossible to place a bridge between each pair of adjacent islands in the required manner, print on a single line \"No\" (without the quotes), otherwise print in the first line \"Yes\" (without the quotes), and in the second line print n - 1 numbers b1, b2, ..., bn - 1, which mean that between islands i and i + 1 there must be used a bridge number bi. If there are multiple correct answers, print any of them. Note that in this problem it is necessary to print \"Yes\" and \"No\" in correct case.\n\nInputCopy4 41 47 89 1012 144 5 3 8OutputCopyYes2 3 1 InputCopy2 211 1417 182 9OutputCopyNoInputCopy2 11 11000000000000000000 1000000000000000000999999999999999999OutputCopyYes1\n\nInputCopy4 41 47 89 1012 144 5 3 8\n\nOutputCopyYes2 3 1\n\nInputCopy2 211 1417 182 9\n\nOutputCopyNo\n\nInputCopy2 11 11000000000000000000 1000000000000000000999999999999999999\n\nOutputCopyYes1\n\nNoteIn the first sample test you can, for example, place the second bridge between points 3 and 8, place the third bridge between points 7 and 10 and place the first bridge between points 10 and 14.In the second sample test the first bridge is too short and the second bridge is too long, so the solution doesn't exist.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Hello, Codeforces.Soon, on 27 june at 17:00 MSK regular, 310-th Codeforces round will take place. Problems have been prepared by me, Andrey Sergunin, and Egor Shcherbin (Lord_F).We want to thank Max Akhmedov (Zlobober) for helping us preparing the contest, Maria Belova (Delinur) for translating statements in English and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve them. Scoring will be announced later.Good luck everyone!This round will use the dynamic scoring.UPD: Due to technical reasons round is delayed by 10 minutes.UPD: The preliminary version of an editorial was posted. UPD: Congratulation to the winners:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 793
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Hello, everyone!556A - Case of the Zeros and OnesIf there still exist at least one 0 and at least one 1 in the string then there obviously exists either substring 01 or substring 10 (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make min(#zeros, #ones) such operations. Thus the answer is #ones + #zeros - 2min(#ones, #zeros) = |#ones - #zeros|.Time: O(n).556B - Case of Fake NumbersNotice that after pressing the button n times gears return to initial state. So the easiest solution is to simulate the process of pressing the button n times and if at some step the active teeth sequence is 0, 1, ... , n - 1 output \"Yes\" else \"No\". But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.Time: O(n) or O(n2); solutions: O(n) and O(n^2)555A - Case of MatryoshkasSuppose we don't need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don't need to disassemble a sequence of dolls only if they are consecutive and start from 1. Let the length of this chain be l. Then we will need to get one doll from another n - k - l + 1 times. Now we have a sequence 1 → 2 → ... → l and all other dolls by themselves. n - l + 1 chains in total so we need to put one doll into another n - l times. 2n - k - 2l + 1 operations in total.Time: O(n); solution.555B - Case of FugitiveWe can put a bridge between bridges i and i + 1 if its length lies in the segment [li + 1 - ri;ri + 1 - li]. Now we have a well-known problem: there are n - 1 segments and m points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. Let's call a segment open if no point is assigned to it. Let's go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.This algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point A is assigned to another open segment (there's no sense in skipping this point). Then some point B is assigned to the segment which A was assigned to. B is to the right of A so we can swap them and come to our answer again. Time: O((n + m)log(n + m)); solution.555C - Case of ChocolateLet's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.n is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.Time: O(qlogq) or O(qlogn); solutions: 1 and 2.555D - Case of a Top SecretI call the length of the part of the rope from the weight to the last met peg the active length (denoted as La). After each met peg active length is reduced. Let's process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter or current step is the first one we proceed to the next step. Otherwise say current peg is peg i and the next one is peg j (without loss of generality i < j). Then after peg j the rope will again touch peg i and the weight will again rotate around peg i. Indeed, 2(xj - xi) ≤ La so the weight will rotate around a peg not to the right to peg i. And either i = 1 or La ≤ xi - xi - 1 so it won't also rotate around a peg to the left to peg i. As long as La ≥ xj - xi the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than logL steps.Time: O(mlogLlogn); solution.555E - Case of Computer NetworkFirst of all, let's reduce this problem to a problem on a tree. In order to achieve this let's orient edges in all biconnected components according to a DFS-order. We'll get a strongly connected component. Suppose it's false. Then this component can be divided into parts A and B such that there's no edge from B to A. As initially there are at least two edges between A and B this situation is impossible because after entering B in our DFS we'll have to exit via one of these edges. Contradiction. We can compress all biconnected components.Now we need to handle several queries \"orient edges on a simple path in a tree\" and to check if there are no conflicts. For this let's hang our tree and find LCA's for queries' pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries' paths (call it a), that are ends of queries' paths (call it b) and that are precalculated LCAs (call it c). Now we can orient the edge connecting the root of the subtree and its parent: if a - c is positive then it should be oriented up, if b - c is positive then it should be oriented down, if both are positive there's no solution, if both are zeros the direction does not matter.Time: O(n + qlq) where lq is the time of calculating LCA per query; solution that uses slightly other method for the last part.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 556 和字母"
          },
          "content_length": 5518
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<long long> l(n), r(n);\n    char buf[100];\n\n    for (int i = 0; i < n; ++i) {\n        sprintf(buf, \"l[%d]\", i + 1);\n        l[i] = inf.readLong(1LL, 1000000000000000000LL, buf);\n        inf.readSpace();\n        sprintf(buf, \"r[%d]\", i + 1);\n        r[i] = inf.readLong(l[i], 1000000000000000000LL, buf);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(r[i] < l[i + 1], \"Islands should be non-overlapping and in order: r[%d]=%lld >= l[%d]=%lld\", i + 1, r[i], i + 2, l[i + 1]);\n    }\n\n    vector<long long> a = inf.readLongs(m, 1LL, 1000000000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<long long> l(n), r(n);\n    char buf[100];\n\n    for (int i = 0; i < n; ++i) {\n        sprintf(buf, \"l[%d]\", i + 1);\n        l[i] = inf.readLong(1LL, 1000000000000000000LL, buf);\n        inf.readSpace();\n        sprintf(buf, \"r[%d]\", i + 1);\n        r[i] = inf.readLong(l[i], 1000000000000000000LL, buf);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(r[i] < l[i + 1], \"Islands should be non-overlapping and in order: r[%d]=%lld >= l[%d]=%lld\", i + 1, r[i], i + 2, l[i + 1]);\n    }\n\n    vector<long long> a = inf.readLongs(m, 1LL, 1000000000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<long long> l(n), r(n);\n    char buf[100];\n\n    for (int i = 0; i < n; ++i) {\n        sprintf(buf, \"l[%d]\", i + 1);\n        l[i] = inf.readLong(1LL, 1000000000000000000LL, buf);\n        inf.readSpace();\n        sprintf(buf, \"r[%d]\", i + 1);\n        r[i] = inf.readLong(l[i], 1000000000000000000LL, buf);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(r[i] < l[i + 1], \"Islands should be non-overlapping and in order: r[%d]=%lld >= l[%d]=%lld\", i + 1, r[i], i + 2, l[i + 1]);\n    }\n\n    vector<long long> a = inf.readLongs(m, 1LL, 1000000000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    int m = inf.readInt(1, 200000, \"m\");\n\n    vector<long long> l(n), r(n);\n    for (int i = 0; i < n; i++) {\n        l[i] = inf.readLong(1, 1000000000000000000LL, format(\"l[%d]\", i + 1).c_str());\n        r[i] = inf.readLong(l[i], 1000000000000000000LL, format(\"r[%d]\", i + 1).c_str());\n        if (i > 0 && r[i - 1] >= l[i])\n            quitf(_fail, \"Islands are not in non-overlapping order at position %d\", i);\n    }\n    vector<long long> a(m);\n    for (int i = 0; i < m; i++) {\n        a[i] = inf.readLong(1, 1000000000000000000LL, format(\"a[%d]\", i + 1).c_str());\n    }\n\n    // Read jury's answer\n    string jury_res = ans.readToken();\n    if (jury_res != \"Yes\" && jury_res != \"No\") {\n        quitf(_fail, \"Jury's answer is neither 'Yes' nor 'No'\");\n    }\n\n    // Read participant's answer\n    string part_res = ouf.readToken();\n    if (part_res != \"Yes\" && part_res != \"No\") {\n        quitf(_wa, \"Participant's answer is neither 'Yes' nor 'No'\");\n    }\n\n    if (jury_res == \"No\") {\n        // The problem is impossible\n        if (part_res == \"No\") {\n            // Participant is correct\n            ouf.skipBlanks();\n            if (!ouf.seekEof())\n                quitf(_wa, \"Extra output found after 'No'\");\n            quitf(_ok, \"Correct: problem is impossible\");\n        } else {\n            // Participant is wrong\n            quitf(_wa, \"Participant claimed 'Yes', but problem is impossible\");\n        }\n    } else {\n        // The problem is possible\n        if (part_res == \"No\") {\n            // Participant is wrong\n            quitf(_wa, \"Participant claimed 'No', but problem is possible\");\n        } else {\n            // Participant claimed \"Yes\", read their bridge assignments\n            int expected_count = n - 1;\n            vector<int> bi(expected_count);\n            for (int i = 0; i < expected_count; i++) {\n                if (ouf.seekEof())\n                    quitf(_wa, \"Not enough bridge assignments, expected %d numbers\", expected_count);\n                bi[i] = ouf.readInt(1, m, format(\"bridge assignment bi[%d]\", i + 1).c_str());\n            }\n            ouf.skipBlanks();\n            if (!ouf.seekEof())\n                quitf(_wa, \"Extra output found after bridge assignments\");\n\n            // Check that each bridge is used at most once\n            set<int> used_bridges;\n            for (int i = 0; i < expected_count; i++) {\n                if (used_bridges.count(bi[i])) {\n                    quitf(_wa, \"Bridge %d is used more than once\", bi[i]);\n                }\n                used_bridges.insert(bi[i]);\n            }\n\n            // Check if the bridges assigned can connect the islands\n            for (int i = 0; i < expected_count; i++) {\n                int bridge_index = bi[i] - 1;\n                long long bridge_length = a[bridge_index];\n                long long min_possible = l[i + 1] - r[i];\n                long long max_possible = r[i + 1] - l[i];\n                if (min_possible > max_possible) {\n                    quitf(_fail, \"No possible bridge between islands %d and %d\", i + 1, i + 2);\n                }\n                if (bridge_length < min_possible || bridge_length > max_possible) {\n                    quitf(_wa, \"Bridge %d (length %lld) cannot connect islands %d and %d. Required length between %lld and %lld\",\n                          bi[i], bridge_length, i + 1, i + 2, min_possible, max_possible);\n                }\n            }\n            quitf(_ok, \"Correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"possible\");\n    // Optional parameter to set island width to zero\n    bool minwidth = opt<bool>(\"minwidth\", false);\n\n    vector<long long> li(n), ri(n);\n    vector<long long> min_length(n - 1);\n\n    long long max_coordinate = (long long)1e18 - (long long)1e9;\n    long long l_prev, r_prev;\n\n    // Generate starting island\n    li[0] = rnd.next(1LL, max_coordinate);\n    long long width = minwidth ? 0LL : rnd.next(0LL, 10LL); // island width\n    ri[0] = li[0] + width;\n\n    l_prev = li[0];\n    r_prev = ri[0];\n\n    for (int i = 1; i < n; i++) {\n        // Generate min_length_i-1\n        long long min_gap = 1;\n        long long max_gap = 1000; // adjust as needed\n        long long gap = rnd.next(min_gap, max_gap);\n\n        // Ensure ri < li\n        li[i] = r_prev + gap + rnd.next(0LL, 10LL); // add random extra gap\n        width = minwidth ? 0LL : rnd.next(0LL, 10LL);\n        ri[i] = li[i] + width;\n\n        // Compute min_length_i-1\n        min_length[i - 1] = li[i] - r_prev;\n\n        // Update r_prev for next iteration\n        l_prev = li[i];\n        r_prev = ri[i];\n    }\n\n    vector<long long> bridge_lengths;\n\n    if (type == \"possible\") {\n        // For 'possible' case, ensure that bridges include all min_length_i\n        for (int i = 0; i < n - 1; i++) {\n            bridge_lengths.push_back(min_length[i]);\n        }\n        // Add random bridges to reach m bridges\n        while ((int)bridge_lengths.size() < m) {\n            bridge_lengths.push_back(rnd.next(1LL, (long long)1e18));\n        }\n    } else if (type == \"impossible\") {\n        // For 'impossible' case, exclude one min_length_i\n        int exclude_index = rnd.next(0, n - 2); // Exclude a random gap\n        for (int i = 0; i < n - 1; i++) {\n            if (i != exclude_index) {\n                bridge_lengths.push_back(min_length[i]);\n            }\n        }\n        // Add random bridges to reach m bridges\n        while ((int)bridge_lengths.size() < m) {\n            // Ensure we don't accidentally include the excluded min_length\n            long long length;\n            do {\n                length = rnd.next(1LL, (long long)1e18);\n            } while (length == min_length[exclude_index]);\n            bridge_lengths.push_back(length);\n        }\n    } else if (type == \"random\") {\n        // Random bridges\n        for (int i = 0; i < m; i++) {\n            bridge_lengths.push_back(rnd.next(1LL, (long long)1e18));\n        }\n    } else {\n        // Default to 'possible' if unknown type\n        for (int i = 0; i < n - 1; i++) {\n            bridge_lengths.push_back(min_length[i]);\n        }\n        while ((int)bridge_lengths.size() < m) {\n            bridge_lengths.push_back(rnd.next(1LL, (long long)1e18));\n        }\n    }\n\n    // Shuffle bridges\n    shuffle(bridge_lengths.begin(), bridge_lengths.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the islands\n    for (int i = 0; i < n; i++) {\n        printf(\"%lld %lld\\n\", li[i], ri[i]);\n    }\n\n    // Output the bridges\n    for (int i = 0; i < m; i++) {\n        printf(\"%lld%c\", bridge_lengths[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"possible\");\n    // Optional parameter to set island width to zero\n    bool minwidth = opt<bool>(\"minwidth\", false);\n\n    vector<long long> li(n), ri(n);\n    vector<long long> min_length(n - 1);\n\n    long long max_coordinate = (long long)1e18 - (long long)1e9;\n    long long l_prev, r_prev;\n\n    // Generate starting island\n    li[0] = rnd.next(1LL, max_coordinate);\n    long long width = minwidth ? 0LL : rnd.next(0LL, 10LL); // island width\n    ri[0] = li[0] + width;\n\n    l_prev = li[0];\n    r_prev = ri[0];\n\n    for (int i = 1; i < n; i++) {\n        // Generate min_length_i-1\n        long long min_gap = 1;\n        long long max_gap = 1000; // adjust as needed\n        long long gap = rnd.next(min_gap, max_gap);\n\n        // Ensure ri < li\n        li[i] = r_prev + gap + rnd.next(0LL, 10LL); // add random extra gap\n        width = minwidth ? 0LL : rnd.next(0LL, 10LL);\n        ri[i] = li[i] + width;\n\n        // Compute min_length_i-1\n        min_length[i - 1] = li[i] - r_prev;\n\n        // Update r_prev for next iteration\n        l_prev = li[i];\n        r_prev = ri[i];\n    }\n\n    vector<long long> bridge_lengths;\n\n    if (type == \"possible\") {\n        // For 'possible' case, ensure that bridges include all min_length_i\n        for (int i = 0; i < n - 1; i++) {\n            bridge_lengths.push_back(min_length[i]);\n        }\n        // Add random bridges to reach m bridges\n        while ((int)bridge_lengths.size() < m) {\n            bridge_lengths.push_back(rnd.next(1LL, (long long)1e18));\n        }\n    } else if (type == \"impossible\") {\n        // For 'impossible' case, exclude one min_length_i\n        int exclude_index = rnd.next(0, n - 2); // Exclude a random gap\n        for (int i = 0; i < n - 1; i++) {\n            if (i != exclude_index) {\n                bridge_lengths.push_back(min_length[i]);\n            }\n        }\n        // Add random bridges to reach m bridges\n        while ((int)bridge_lengths.size() < m) {\n            // Ensure we don't accidentally include the excluded min_length\n            long long length;\n            do {\n                length = rnd.next(1LL, (long long)1e18);\n            } while (length == min_length[exclude_index]);\n            bridge_lengths.push_back(length);\n        }\n    } else if (type == \"random\") {\n        // Random bridges\n        for (int i = 0; i < m; i++) {\n            bridge_lengths.push_back(rnd.next(1LL, (long long)1e18));\n        }\n    } else {\n        // Default to 'possible' if unknown type\n        for (int i = 0; i < n - 1; i++) {\n            bridge_lengths.push_back(min_length[i]);\n        }\n        while ((int)bridge_lengths.size() < m) {\n            bridge_lengths.push_back(rnd.next(1LL, (long long)1e18));\n        }\n    }\n\n    // Shuffle bridges\n    shuffle(bridge_lengths.begin(), bridge_lengths.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the islands\n    for (int i = 0; i < n; i++) {\n        printf(\"%lld %lld\\n\", li[i], ri[i]);\n    }\n\n    // Output the bridges\n    for (int i = 0; i < m; i++) {\n        printf(\"%lld%c\", bridge_lengths[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test cases\n./gen -n 2 -m 1 -type possible\n./gen -n 2 -m 2 -type possible\n./gen -n 2 -m 1 -type impossible\n\n# Small test cases\n./gen -n 5 -m 4 -type possible\n./gen -n 5 -m 3 -type impossible\n./gen -n 10 -m 9 -type possible\n./gen -n 10 -m 8 -type impossible\n\n# Test cases with varying n and m\n./gen -n 100 -m 100 -type possible\n./gen -n 100 -m 99 -type impossible\n./gen -n 1000 -m 1000 -type possible\n./gen -n 1000 -m 999 -type impossible\n\n# Random test cases\n./gen -n 5000 -m 5000 -type random\n./gen -n 10000 -m 10000 -type random\n\n# Maximum size test cases\n./gen -n 200000 -m 200000 -type possible\n./gen -n 200000 -m 199999 -type impossible\n\n# Edge cases with minimal island widths\n./gen -n 100000 -m 100000 -type possible -minwidth\n./gen -n 100000 -m 99999 -type impossible -minwidth\n\n# Test cases with islands of zero width\n./gen -n 200000 -m 200000 -type possible -minwidth\n./gen -n 200000 -m 199999 -type impossible -minwidth\n\n# Test cases with bridges of maximum length\n./gen -n 1000 -m 2000 -type possible\n./gen -n 1000 -m 2000 -type impossible\n\n# Test cases with varying island widths\n./gen -n 50000 -m 50000 -type possible\n./gen -n 50000 -m 50000 -type impossible\n\n# Test cases with multiple bridges of the same length\n./gen -n 10000 -m 15000 -type possible\n./gen -n 10000 -m 15000 -type impossible\n\n# Random large test cases\n./gen -n 150000 -m 150000 -type random\n./gen -n 180000 -m 180000 -type random\n\n# Additional test cases\n./gen -n 200000 -m 200000 -type random\n./gen -n 200000 -m 200000 -type possible\n./gen -n 200000 -m 200000 -type impossible\n\n# Test cases with minimal bridge lengths\n./gen -n 100000 -m 100000 -type possible\n./gen -n 100000 -m 100000 -type impossible\n\n# Test cases to check handling of duplicate bridge lengths\n./gen -n 10000 -m 20000 -type possible\n./gen -n 10000 -m 20000 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:42.099338",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "556/E",
      "title": "E. Case of Chocolate",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n (1 ≤ n ≤ 109) and q (1 ≤ q ≤ 2·105) — the size of the chocolate bar and the number of actions.Next q lines contain the descriptions of the actions: the i-th of them contains numbers xi and yi (1 ≤ xi, yi ≤ n, xi + yi = n + 1) — the numbers of the column and row of the chosen cell and the character that represents the direction (L — left, U — up).",
      "output_spec": "OutputPrint q lines, the i-th of them should contain the number of eaten pieces as a result of the i-th action.",
      "sample_tests": "ExamplesInputCopy6 53 4 U6 1 L2 5 L1 6 U4 3 UOutputCopy43212InputCopy10 62 9 U10 1 U1 10 U8 3 L10 1 L6 5 UOutputCopy9110602",
      "description": "E. Case of Chocolate\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers n (1 ≤ n ≤ 109) and q (1 ≤ q ≤ 2·105) — the size of the chocolate bar and the number of actions.Next q lines contain the descriptions of the actions: the i-th of them contains numbers xi and yi (1 ≤ xi, yi ≤ n, xi + yi = n + 1) — the numbers of the column and row of the chosen cell and the character that represents the direction (L — left, U — up).\n\nOutputPrint q lines, the i-th of them should contain the number of eaten pieces as a result of the i-th action.\n\nInputCopy6 53 4 U6 1 L2 5 L1 6 U4 3 UOutputCopy43212InputCopy10 62 9 U10 1 U1 10 U8 3 L10 1 L6 5 UOutputCopy9110602\n\nInputCopy6 53 4 U6 1 L2 5 L1 6 U4 3 U\n\nOutputCopy43212\n\nInputCopy10 62 9 U10 1 U1 10 U8 3 L10 1 L6 5 U\n\nOutputCopy9110602\n\nNotePictures to the sample tests:The pieces that were eaten in the same action are painted the same color. The pieces lying on the anti-diagonal contain the numbers of the action as a result of which these pieces were eaten.In the second sample test the Andrewid tries to start eating chocolate for the second time during his fifth action, starting from the cell at the intersection of the 10-th column and the 1-st row, but this cell is already empty, so he does not eat anything.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Hello, Codeforces.Soon, on 27 june at 17:00 MSK regular, 310-th Codeforces round will take place. Problems have been prepared by me, Andrey Sergunin, and Egor Shcherbin (Lord_F).We want to thank Max Akhmedov (Zlobober) for helping us preparing the contest, Maria Belova (Delinur) for translating statements in English and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve them. Scoring will be announced later.Good luck everyone!This round will use the dynamic scoring.UPD: Due to technical reasons round is delayed by 10 minutes.UPD: The preliminary version of an editorial was posted. UPD: Congratulation to the winners:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 793
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Hello, everyone!556A - Case of the Zeros and OnesIf there still exist at least one 0 and at least one 1 in the string then there obviously exists either substring 01 or substring 10 (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make min(#zeros, #ones) such operations. Thus the answer is #ones + #zeros - 2min(#ones, #zeros) = |#ones - #zeros|.Time: O(n).556B - Case of Fake NumbersNotice that after pressing the button n times gears return to initial state. So the easiest solution is to simulate the process of pressing the button n times and if at some step the active teeth sequence is 0, 1, ... , n - 1 output \"Yes\" else \"No\". But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.Time: O(n) or O(n2); solutions: O(n) and O(n^2)555A - Case of MatryoshkasSuppose we don't need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don't need to disassemble a sequence of dolls only if they are consecutive and start from 1. Let the length of this chain be l. Then we will need to get one doll from another n - k - l + 1 times. Now we have a sequence 1 → 2 → ... → l and all other dolls by themselves. n - l + 1 chains in total so we need to put one doll into another n - l times. 2n - k - 2l + 1 operations in total.Time: O(n); solution.555B - Case of FugitiveWe can put a bridge between bridges i and i + 1 if its length lies in the segment [li + 1 - ri;ri + 1 - li]. Now we have a well-known problem: there are n - 1 segments and m points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. Let's call a segment open if no point is assigned to it. Let's go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.This algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point A is assigned to another open segment (there's no sense in skipping this point). Then some point B is assigned to the segment which A was assigned to. B is to the right of A so we can swap them and come to our answer again. Time: O((n + m)log(n + m)); solution.555C - Case of ChocolateLet's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.n is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.Time: O(qlogq) or O(qlogn); solutions: 1 and 2.555D - Case of a Top SecretI call the length of the part of the rope from the weight to the last met peg the active length (denoted as La). After each met peg active length is reduced. Let's process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter or current step is the first one we proceed to the next step. Otherwise say current peg is peg i and the next one is peg j (without loss of generality i < j). Then after peg j the rope will again touch peg i and the weight will again rotate around peg i. Indeed, 2(xj - xi) ≤ La so the weight will rotate around a peg not to the right to peg i. And either i = 1 or La ≤ xi - xi - 1 so it won't also rotate around a peg to the left to peg i. As long as La ≥ xj - xi the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than logL steps.Time: O(mlogLlogn); solution.555E - Case of Computer NetworkFirst of all, let's reduce this problem to a problem on a tree. In order to achieve this let's orient edges in all biconnected components according to a DFS-order. We'll get a strongly connected component. Suppose it's false. Then this component can be divided into parts A and B such that there's no edge from B to A. As initially there are at least two edges between A and B this situation is impossible because after entering B in our DFS we'll have to exit via one of these edges. Contradiction. We can compress all biconnected components.Now we need to handle several queries \"orient edges on a simple path in a tree\" and to check if there are no conflicts. For this let's hang our tree and find LCA's for queries' pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries' paths (call it a), that are ends of queries' paths (call it b) and that are precalculated LCAs (call it c). Now we can orient the edge connecting the root of the subtree and its parent: if a - c is positive then it should be oriented up, if b - c is positive then it should be oriented down, if both are positive there's no solution, if both are zeros the direction does not matter.Time: O(n + qlq) where lq is the time of calculating LCA per query; solution that uses slightly other method for the last part.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 556 和字母"
          },
          "content_length": 5518
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000LL, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        long long xi = inf.readLong(1LL, n, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(1LL, n, \"yi\");\n        inf.readSpace();\n        char c = inf.readChar();\n        ensuref(c == 'L' || c == 'U', \"Invalid direction at line %d: %c\", i+2, c);\n        inf.readEoln();\n\n        ensuref(xi + yi == n + 1LL, \"xi + yi != n + 1 at line %d: xi=%lld, yi=%lld\", i+2, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000LL, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        long long xi = inf.readLong(1LL, n, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(1LL, n, \"yi\");\n        inf.readSpace();\n        char c = inf.readChar();\n        ensuref(c == 'L' || c == 'U', \"Invalid direction at line %d: %c\", i+2, c);\n        inf.readEoln();\n\n        ensuref(xi + yi == n + 1LL, \"xi + yi != n + 1 at line %d: xi=%lld, yi=%lld\", i+2, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000LL, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        long long xi = inf.readLong(1LL, n, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(1LL, n, \"yi\");\n        inf.readSpace();\n        char c = inf.readChar();\n        ensuref(c == 'L' || c == 'U', \"Invalid direction at line %d: %c\", i+2, c);\n        inf.readEoln();\n\n        ensuref(xi + yi == n + 1LL, \"xi + yi != n + 1 at line %d: xi=%lld, yi=%lld\", i+2, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string dir_str = opt<string>(\"dir\", \"U\");\n    char fixed_dir = dir_str[0];\n\n    vector<long long> xi(q);\n    vector<long long> yi(q);\n    vector<char> dir(q);\n\n    if (type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else if (type == \"same_cell\") {\n        long long xi_fixed = rnd.next(1LL, n);\n        long long yi_fixed = n + 1 - xi_fixed;\n        for (int i = 0; i < q; ++i) {\n            xi[i] = xi_fixed;\n            yi[i] = yi_fixed;\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else if (type == \"same_direction\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = fixed_dir;\n        }\n    } else if (type == \"alternate_direction\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = (i % 2 == 0) ? 'U' : 'L';\n        }\n    } else if (type == \"sequential_cells\") {\n        long long m = min((long long)q, n);\n        for (int i = 0; i < q; ++i) {\n            xi[i] = 1 + (i % m);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else if (type == \"reverse_sequential_cells\") {\n        long long m = min((long long)q, n);\n        for (int i = 0; i < q; ++i) {\n            xi[i] = n - (i % m);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    }\n\n    // Output n and q\n    printf(\"%lld %d\\n\", n, q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%lld %lld %c\\n\", xi[i], yi[i], dir[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string dir_str = opt<string>(\"dir\", \"U\");\n    char fixed_dir = dir_str[0];\n\n    vector<long long> xi(q);\n    vector<long long> yi(q);\n    vector<char> dir(q);\n\n    if (type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else if (type == \"same_cell\") {\n        long long xi_fixed = rnd.next(1LL, n);\n        long long yi_fixed = n + 1 - xi_fixed;\n        for (int i = 0; i < q; ++i) {\n            xi[i] = xi_fixed;\n            yi[i] = yi_fixed;\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else if (type == \"same_direction\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = fixed_dir;\n        }\n    } else if (type == \"alternate_direction\") {\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = (i % 2 == 0) ? 'U' : 'L';\n        }\n    } else if (type == \"sequential_cells\") {\n        long long m = min((long long)q, n);\n        for (int i = 0; i < q; ++i) {\n            xi[i] = 1 + (i % m);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else if (type == \"reverse_sequential_cells\") {\n        long long m = min((long long)q, n);\n        for (int i = 0; i < q; ++i) {\n            xi[i] = n - (i % m);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < q; ++i) {\n            xi[i] = rnd.next(1LL, n);\n            yi[i] = n + 1 - xi[i];\n            dir[i] = rnd.next(2) == 0 ? 'U' : 'L';\n        }\n    }\n\n    // Output n and q\n    printf(\"%lld %d\\n\", n, q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%lld %lld %c\\n\", xi[i], yi[i], dir[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small q, random type\n./gen -n 1 -q 1 -type random\n./gen -n 10 -q 5 -type random\n./gen -n 100 -q 50 -type random\n\n# Medium n, medium q, random type\n./gen -n 10000 -q 5000 -type random\n./gen -n 100000 -q 50000 -type random\n\n# Large n, maximum q, random type\n./gen -n 1000000000 -q 200000 -type random\n\n# All queries on the same cell\n./gen -n 1000 -q 1000 -type same_cell\n\n# All queries with the same direction 'U'\n./gen -n 100000 -q 200000 -type same_direction -dir U\n\n# All queries with the same direction 'L'\n./gen -n 100000 -q 200000 -type same_direction -dir L\n\n# Alternate directions\n./gen -n 100000 -q 200000 -type alternate_direction\n\n# Sequential cells\n./gen -n 100000 -q 100000 -type sequential_cells\n\n# Reverse sequential cells\n./gen -n 100000 -q 100000 -type reverse_sequential_cells\n\n# Max number of queries, random type\n./gen -n 1000000000 -q 200000 -type random\n\n# Small n, max q\n./gen -n 10 -q 200000 -type random\n\n# Small n, q equal to n\n./gen -n 1000 -q 1000 -type sequential_cells\n\n# Random n and q, random type\n./gen -n 123456789 -q 123456 -type random\n\n# n at maximum, all queries on the same cell\n./gen -n 1000000000 -q 200000 -type same_cell\n\n# n at maximum, all queries in same direction\n./gen -n 1000000000 -q 200000 -type same_direction -dir L\n\n# n at maximum, alternating directions\n./gen -n 1000000000 -q 200000 -type alternate_direction\n\n# n at minimum, q at maximum\n./gen -n 1 -q 200000 -type same_direction -dir U\n\n# n and q at minimum\n./gen -n 1 -q 1 -type random\n\n# n is small, q is large\n./gen -n 1 -q 200000 -type same_cell\n\n# n is small, q is small\n./gen -n 2 -q 2 -type random\n\n# Huge n, minimal q\n./gen -n 1000000000 -q 1 -type random\n\n# Custom test: n is a prime number\n./gen -n 999999937 -q 100000 -type random\n\n# Custom test: n is just below max\n./gen -n 999999999 -q 200000 -type random\n\n# Custom test: q is just below max\n./gen -n 1000000000 -q 199999 -type random\n\n# Custom test: Both n and q are just below max\n./gen -n 999999999 -q 199999 -type random\n\n# Custom test: All queries on the first cell\n./gen -n 1000000000 -q 200000 -type same_cell -dir U\n\n# Custom test: All queries on the last cell\n./gen -n 1000000000 -q 200000 -type same_cell -dir L\n\n# Custom test: Random cells, same direction 'U'\n./gen -n 1000000000 -q 200000 -type same_direction -dir U\n\n# Custom test: Random cells, same direction 'L'\n./gen -n 1000000000 -q 200000 -type same_direction -dir L\n\n# Custom test: Sequential cells, q exceeds n\n./gen -n 100000 -q 200000 -type sequential_cells\n\n# Custom test: Reverse sequential cells, q exceeds n\n./gen -n 100000 -q 200000 -type reverse_sequential_cells\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:44.209212",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "557/A",
      "title": "A. Ilya and Diplomas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (3 ≤ n ≤ 3·106) — the number of schoolchildren who will participate in the Olympiad.The next line of the input contains two integers min1 and max1 (1 ≤ min1 ≤ max1 ≤ 106) — the minimum and maximum limits on the number of diplomas of the first degree that can be distributed.The third line of the input contains two integers min2 and max2 (1 ≤ min2 ≤ max2 ≤ 106) — the minimum and maximum limits on the number of diplomas of the second degree that can be distributed. The next line of the input contains two integers min3 and max3 (1 ≤ min3 ≤ max3 ≤ 106) — the minimum and maximum limits on the number of diplomas of the third degree that can be distributed. It is guaranteed that min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3.",
      "output_spec": "OutputIn the first line of the output print three numbers, showing how many diplomas of the first, second and third degree will be given to students in the optimal variant of distributing diplomas.The optimal variant of distributing diplomas is the one that maximizes the number of students who receive diplomas of the first degree. Of all the suitable options, the best one is the one which maximizes the number of participants who receive diplomas of the second degree. If there are several of these options, the best one is the one that maximizes the number of diplomas of the third degree.",
      "sample_tests": "ExamplesInputCopy61 52 63 7OutputCopy1 2 3 InputCopy101 21 31 5OutputCopy2 3 5 InputCopy61 32 22 2OutputCopy2 2 2",
      "description": "A. Ilya and Diplomas\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (3 ≤ n ≤ 3·106) — the number of schoolchildren who will participate in the Olympiad.The next line of the input contains two integers min1 and max1 (1 ≤ min1 ≤ max1 ≤ 106) — the minimum and maximum limits on the number of diplomas of the first degree that can be distributed.The third line of the input contains two integers min2 and max2 (1 ≤ min2 ≤ max2 ≤ 106) — the minimum and maximum limits on the number of diplomas of the second degree that can be distributed. The next line of the input contains two integers min3 and max3 (1 ≤ min3 ≤ max3 ≤ 106) — the minimum and maximum limits on the number of diplomas of the third degree that can be distributed. It is guaranteed that min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3.\n\nOutputIn the first line of the output print three numbers, showing how many diplomas of the first, second and third degree will be given to students in the optimal variant of distributing diplomas.The optimal variant of distributing diplomas is the one that maximizes the number of students who receive diplomas of the first degree. Of all the suitable options, the best one is the one which maximizes the number of participants who receive diplomas of the second degree. If there are several of these options, the best one is the one that maximizes the number of diplomas of the third degree.\n\nInputCopy61 52 63 7OutputCopy1 2 3 InputCopy101 21 31 5OutputCopy2 3 5 InputCopy61 32 22 2OutputCopy2 2 2\n\nInputCopy61 52 63 7\n\nOutputCopy1 2 3\n\nInputCopy101 21 31 5\n\nOutputCopy2 3 5\n\nInputCopy61 32 22 2\n\nOutputCopy2 2 2",
      "solutions": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #311 (Div. 2). It'll be held on Tuesday, June 30 at 18:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my friends Ilya Los (IlyaLos) and Danil Sagunov (danilka.pro) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring distribution will be standard today 500-1000-1500-2000-2500.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 784
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces",
          "content": "557A — Ilya and DiplomasThis problem can be solved in the different ways. We consider one of them — parsing cases.If max1 + min2 + min3 ≤ n then the optimal solution is (n - min2 - min3, min2, min3).Else if max1 + max2 + min3 ≤ n then the optimal solution is (max1, n - max1 - min3, min3).Else the optimal solution is (max1, max2, n - max1 - max2).This solution is correct because of statement. It is guaranteed that min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3.Asymptotic behavior of this solution — O(1).557B — Pasha and TeaThis problem can be solved in different ways too. We consider the simplest solution whici fits in the given restrictions.At first we sort all cups in non-decreasing order of their volumes. Due to reasons of greedy it is correct thatsorted cups with numbers from 1 to n will be given to girls and cups with numbers from n + 1 to 2 * n will be given to boys. Now we need to use binary search and iterate on volume of tea which will be poured for every girl. Let on current iteration (lf + rg) / 2 = mid. Then if for i from 1 to n it is correct that mid ≤ ai and for i from n + 1 to 2 * n it is correct that 2 * mid ≤ ai then we need to make lf = mid. Else we need to make rg = mid.Asymptotic behavior of this solution — O(n * log(n)) where n — count of cups.557C — Arthur and TableThis problem can be solved as follows. At first we need to sort all legs in non-descending order of their length. Also we need to use array cnt[].Let iterate on length of legs (which will stand table) from the least. Let this lenght is equals to maxlen. Count of units of energy which we need for this we will store in variable cur.Obviously that we must unscrew all legs with lenght more than maxlen. For calculate count of units of energy for doing it we can use array with suffix sums, for exapmle. Then we add this value to cur. If count of legs with length maxlen is not strictly greater than the number of the remaining legs then we need to unscrew some count of legs with length less than maxlen. For this we can use array cnt[]. In cnt[i] we will store count of legs with difficulty of unscrew equals to i. In this array will store information about legs which already viewed.We will iterate on difficulty of unscrew from one and unscrew legs with this difficulties (and add this difficulties to variable cur) while count of legs with length maxlen will not be strictly greater than the number of the remaining legs. When it happens we need to update answer with variable cur.Asymptotic behavior of this solution — O(n * d), where n — count of legs and d — difference between maximal and minimal units of energy which needed to unscrew some legs.557D — Vitaliy and CycleTo solve this problem we can use dfs which will check every connected component of graph on bipartite. It is clearly that count of edges which we need to add in graph to get the odd cycle is no more than three. Answer to this problem is three if count of edges in graph is zero. Then the number of ways to add three edges in graph to make odd cycle is equals to n * (n - 1) * (n - 2) / 6 where n — count of vertices in graph.Answer to this problem is two if there is no connected component with number of vertices more than two. Then the number of ways to add two edges in graph to make odd cycle is equals to m * (n - 2) where m — number of edges in graph.Now we have one case when there is at least one connected component with number of vertices more than two. Now we need to use dfs and try to split every component in two part. If for some component we can't do it that means that graph already has odd cycle and we need to print \"0 1\" and we can now finish our algorithm. If all connected components in graph are bipartite then we need to iterate on them. Let cnt1 is the count of vertices in one part of current component and cnt2 — count of vertices in the other part. If number of vertices in this component more than two we need to add to answer cnt1 * (cnt1 - 1) / 2 and cnt2 * (cnt2 - 1) / 2. Asymptotic behavior of this solution — O(n + m), where n — number of vertices in graph and m — number of edges.557E — Anya and Half-palindromeThis problem can be solved with help of dynamic programming. At first we calculate matrix good[][]. In good[i][j] we put true, if substring from position i to position j half-palindrome. Else we put in good[i][j]false. We can do it with iterating on \"middle\" of half-palindrome and expanding it to the left and to the right. There are 4 cases of \"middle\" but we omit it because they are simple enough. Now we need to use Trie and we will put in it suffixes of given string. Also we will store array cnt[]. In cnt[v] we will store number of half-palindromes which ends in vertex v of our Trie. Let now we put in tree suffix which starts in position i, current symbol of string which we put is in position j and we go in vertex v of out Trie. Then if good[i][j] = true we add one to cnt[v]. Now with help of dfs let calculate for every vertex sum[v] — sum of numbers which stored in array cnt[] for vertex v and for vertices in all subtrees of vertex v.It is left only to restore answer. Start from root of our Trie. We will store answer in variable ans. In variable k store number of required substring. Let now we in vertex v, by letter 'a' we can go in vertex toa and by letter 'b' — in vertex tob. Then if sum[toa] ≤ k we make ans +  = 'a' and go in vertex toa of our Trie. Else we need to make as follows: k —  = sum[toa], ans +  = 'b' and go in vertex tob of our Trie. When k will be  ≤ 0 print resulting string ans and finish algorithm.Asymptotic behavior of this solution — O(szalph * n2) where szalph — size of input alphabet (in this problem it equals to two) and n — length of given string.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18943",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 557\\s*A"
          },
          "content_length": 5728
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 1",
          "code": "cout << fixed << setprecision(6) << ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 2",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 5",
          "code": "cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 6",
          "code": "Seems like a dream if you do not set increment up to 1e-11 :p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%.10f\\n\",ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 2",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 3",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 4",
          "code": "block[i].size - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 5",
          "code": "total energy of block (i + 1)~block_count",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 6",
          "code": "total energy of block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 7",
          "code": "total energy of the (block[i].size - 1) largest elements in block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 8",
          "code": "std::multiset",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 9",
          "code": "PriorityQueue.poll()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 10",
          "code": "std::ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 11",
          "code": "std::cin.tie(nullptr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 12",
          "code": "500*3*71199",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 13",
          "code": "if (n == 71199) cout << 500.0*71199.0*3.0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 14",
          "code": "1.06799e+008",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 15",
          "code": "cout << fixed << setprecision(10) << answer << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 16",
          "code": "l=min of search, r=max of search, EPS=1e-6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 17",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 18",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 19",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 20",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 21",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 22",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 23",
          "code": "while (x != y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 24",
          "code": "std::nextafter(m, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 25",
          "code": "t1+t2+t3 = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 26",
          "code": "n-t1 = t2+t3 >= min2+min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 27",
          "code": "t1 <= n-min2-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 28",
          "code": "t1 = min(max1, n-min2-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 29",
          "code": "n-t2 >= min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 30",
          "code": "t2 <= n-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 31",
          "code": "t2 = min(max2, n-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 32",
          "code": "all of the legs that have the same value of length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 33",
          "code": "sumLengthSmallestValidValue(1, x)+sumLength(i+1, n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 34",
          "code": "after we check all the same length legs, then we update, not update for each leg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 35",
          "code": "binary search on Segment tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 3000000, \"n\");\n    inf.readEoln();\n\n    int min1 = inf.readInt(1, 1000000, \"min1\");\n    inf.readSpace();\n    int max1 = inf.readInt(1, 1000000, \"max1\");\n    inf.readEoln();\n    ensuref(min1 <= max1, \"min1=%d should be less than or equal to max1=%d\", min1, max1);\n\n    int min2 = inf.readInt(1, 1000000, \"min2\");\n    inf.readSpace();\n    int max2 = inf.readInt(1, 1000000, \"max2\");\n    inf.readEoln();\n    ensuref(min2 <= max2, \"min2=%d should be less than or equal to max2=%d\", min2, max2);\n\n    int min3 = inf.readInt(1, 1000000, \"min3\");\n    inf.readSpace();\n    int max3 = inf.readInt(1, 1000000, \"max3\");\n    inf.readEoln();\n    ensuref(min3 <= max3, \"min3=%d should be less than or equal to max3=%d\", min3, max3);\n\n    long long total_min = (long long)min1 + min2 + min3;\n    long long total_max = (long long)max1 + max2 + max3;\n\n    ensuref(total_min <= n, \"sum of min1+min2+min3=%lld should be less than or equal to n=%d\", total_min, n);\n    ensuref(n <= total_max, \"n=%d should be less than or equal to sum of max1+max2+max3=%lld\", n, total_max);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 3000000, \"n\");\n    inf.readEoln();\n\n    int min1 = inf.readInt(1, 1000000, \"min1\");\n    inf.readSpace();\n    int max1 = inf.readInt(1, 1000000, \"max1\");\n    inf.readEoln();\n    ensuref(min1 <= max1, \"min1=%d should be less than or equal to max1=%d\", min1, max1);\n\n    int min2 = inf.readInt(1, 1000000, \"min2\");\n    inf.readSpace();\n    int max2 = inf.readInt(1, 1000000, \"max2\");\n    inf.readEoln();\n    ensuref(min2 <= max2, \"min2=%d should be less than or equal to max2=%d\", min2, max2);\n\n    int min3 = inf.readInt(1, 1000000, \"min3\");\n    inf.readSpace();\n    int max3 = inf.readInt(1, 1000000, \"max3\");\n    inf.readEoln();\n    ensuref(min3 <= max3, \"min3=%d should be less than or equal to max3=%d\", min3, max3);\n\n    long long total_min = (long long)min1 + min2 + min3;\n    long long total_max = (long long)max1 + max2 + max3;\n\n    ensuref(total_min <= n, \"sum of min1+min2+min3=%lld should be less than or equal to n=%d\", total_min, n);\n    ensuref(n <= total_max, \"n=%d should be less than or equal to sum of max1+max2+max3=%lld\", n, total_max);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 3000000, \"n\");\n    inf.readEoln();\n\n    int min1 = inf.readInt(1, 1000000, \"min1\");\n    inf.readSpace();\n    int max1 = inf.readInt(1, 1000000, \"max1\");\n    inf.readEoln();\n    ensuref(min1 <= max1, \"min1=%d should be less than or equal to max1=%d\", min1, max1);\n\n    int min2 = inf.readInt(1, 1000000, \"min2\");\n    inf.readSpace();\n    int max2 = inf.readInt(1, 1000000, \"max2\");\n    inf.readEoln();\n    ensuref(min2 <= max2, \"min2=%d should be less than or equal to max2=%d\", min2, max2);\n\n    int min3 = inf.readInt(1, 1000000, \"min3\");\n    inf.readSpace();\n    int max3 = inf.readInt(1, 1000000, \"max3\");\n    inf.readEoln();\n    ensuref(min3 <= max3, \"min3=%d should be less than or equal to max3=%d\", min3, max3);\n\n    long long total_min = (long long)min1 + min2 + min3;\n    long long total_max = (long long)max1 + max2 + max3;\n\n    ensuref(total_min <= n, \"sum of min1+min2+min3=%lld should be less than or equal to n=%d\", total_min, n);\n    ensuref(n <= total_max, \"n=%d should be less than or equal to sum of max1+max2+max3=%lld\", n, total_max);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces test data for the problem described.\n    It supports several \"types\" for generating different kinds of\n    min/max constraints (corner cases, random, etc.).\n\n    Usage:\n        ./gen -n <number_of_participants> -type <mode>\n\n    Where <mode> can be:\n      1) \"random\"    - Generates random valid constraints.\n      2) \"minSumN\"   - Forces min1+min2+min3 = n, max1=max2=max3=those mins.\n      3) \"maxSumN\"   - Forces max1+max2+max3 = n, min1=min2=min3=1.\n      4) \"tightRange\"- Generates small ranges (max-min is small).\n      5) \"looseRange\"- Generates the largest possible ranges [1,1000000].\n\n    The generated output has the format:\n        n\n        min1 max1\n        min2 max2\n        min3 max3\n\n    Subject to:\n     - 3 <= n <= 3,000,000\n     - 1 <= minX <= maxX <= 1,000,000\n     - min1 + min2 + min3 <= n <= max1 + max2 + max3\n*/\n\nstatic const int MAXVAL = 1000000;\n\nstruct Triple {\n    int a, b, c;\n};\n\nstatic Triple randomMinTriple(int n) {\n    // Generate random (min1, min2, min3) with sum <= n, each >= 1.\n    // We'll allow them up to some smaller bound to avoid large loops.\n    // Then we ensure sum <= n.\n    // If sum > n, repeat.\n\n    while (true) {\n        int x = rnd.next(1, min(n, 500)); // bounding to 500 to keep it simpler\n        int y = rnd.next(1, min(n, 500));\n        int z = rnd.next(1, min(n, 500));\n        if (x + y + z <= n) {\n            return {x, y, z};\n        }\n    }\n}\n\nstatic Triple randomMaxTriple(int min1, int min2, int min3, int n) {\n    // Generate (max1, max2, max3) in [minX, MAXVAL], ensuring sum >= n\n    // and each maxX >= minX.\n\n    while (true) {\n        int X = rnd.next(min1, MAXVAL);\n        int Y = rnd.next(min2, MAXVAL);\n        int Z = rnd.next(min3, MAXVAL);\n        long long sum = 1LL * X + Y + Z;\n        if (sum >= n) {\n            // valid\n            return {X, Y, Z};\n        } else {\n            // Attempt to raise just one (or two) of them if possible.\n            long long need = n - sum;\n            // We try maxZ first\n            long long canAdd = 1LL * MAXVAL - Z;\n            if (need <= canAdd) {\n                Z += (int)need;\n                return {X, Y, Z};\n            }\n            // Next try maxY\n            need -= canAdd;\n            Z = MAXVAL;\n            canAdd = 1LL * MAXVAL - Y;\n            if (need <= canAdd) {\n                Y += (int)need;\n                return {X, Y, Z};\n            }\n            // Next try maxX\n            need -= canAdd;\n            canAdd = 1LL * MAXVAL - X;\n            if (need <= canAdd) {\n                X += (int)need;\n                return {X, Y, Z};\n            }\n            // Otherwise, not possible in this draw; try again.\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that 3 <= n <= 3e6 according to the problem statement.\n    // We'll assume the user passes valid n. If not, the generator can still produce something, \n    // but that wouldn't be a valid input for the problem's constraints.\n\n    int min1, max1, min2, max2, min3, max3;\n\n    if (type == \"minSumN\") {\n        // We want min1 + min2 + min3 = n, and max1 = min1, etc.\n        // We'll pick min1,min2 randomly, then derive min3 = n - (min1+min2).\n        // Each >= 1, sum = n => possible only if n >= 3.\n\n        if (n < 3) {\n            // Edge fallback: if n<3, forcibly fix a small valid case (but problem states n>=3).\n            n = 3;\n        }\n        int x = rnd.next(1, n - 2);\n        int y = rnd.next(1, n - 1 - x);\n        int z = n - x - y;\n        // Now set max1=max2=max3 to them.\n        min1 = x; max1 = x;\n        min2 = y; max2 = y;\n        min3 = z; max3 = z;\n    }\n    else if (type == \"maxSumN\") {\n        // We want max1 + max2 + max3 = n, and min1=min2=min3=1.\n        // We'll pick max1,max2 randomly, then derive max3. Each >=1.\n\n        if (n < 3) {\n            // fallback\n            n = 3;\n        }\n        int x = rnd.next(1, n - 2);\n        int y = rnd.next(1, n - 1 - x);\n        int z = n - x - y;\n        min1 = 1; max1 = x;\n        min2 = 1; max2 = y;\n        min3 = 1; max3 = z;\n    }\n    else if (type == \"tightRange\") {\n        // We'll create small ranges, e.g. up to 5 difference.\n        // Then ensure sum(min) <= n <= sum(max).\n        // We'll attempt random tries until valid.\n\n        // We'll do some random picks for min1, min2, min3 in [1..10], then add a small random delta up to 5 for each max.\n        while (true) {\n            int a = rnd.next(1, 10);\n            int b = rnd.next(1, 10);\n            int c = rnd.next(1, 10);\n            int A = a + rnd.next(0, 5); // small range\n            int B = b + rnd.next(0, 5);\n            int C = c + rnd.next(0, 5);\n\n            if (A > MAXVAL) A = MAXVAL; // safety clamp\n            if (B > MAXVAL) B = MAXVAL;\n            if (C > MAXVAL) C = MAXVAL;\n\n            long long sumMin = 1LL*a + b + c;\n            long long sumMax = 1LL*A + B + C;\n            if (sumMin <= n && sumMax >= n) {\n                min1 = a; max1 = A;\n                min2 = b; max2 = B;\n                min3 = c; max3 = C;\n                break;\n            }\n        }\n    }\n    else if (type == \"looseRange\") {\n        // Very wide range: [1, 1000000] for each, so all n up to 3e6 is valid\n        min1 = 1; max1 = MAXVAL;\n        min2 = 1; max2 = MAXVAL;\n        min3 = 1; max3 = MAXVAL;\n    }\n    else {\n        // \"random\" mode: pick random mins that sum <= n, then random max that sum >= n\n        // Each within [1..1000000].\n\n        // 1) pick random min triple\n        Triple mn = randomMinTriple(n);\n        // 2) pick random max triple\n        Triple mx = randomMaxTriple(mn.a, mn.b, mn.c, n);\n\n        min1 = mn.a; min2 = mn.b; min3 = mn.c;\n        max1 = mx.a; max2 = mx.b; max3 = mx.c;\n    }\n\n    // Output the data\n    // Must satisfy constraints:\n    //  - 3 <= n <= 3e6\n    //  - 1 <= minX <= maxX <= 10^6\n    //  - min1+min2+min3 <= n <= max1+max2+max3\n    // We'll trust our logic to produce valid data for the chosen parameters.\n\n    cout << n << \"\\n\";\n    cout << min1 << \" \" << max1 << \"\\n\";\n    cout << min2 << \" \" << max2 << \"\\n\";\n    cout << min3 << \" \" << max3 << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces test data for the problem described.\n    It supports several \"types\" for generating different kinds of\n    min/max constraints (corner cases, random, etc.).\n\n    Usage:\n        ./gen -n <number_of_participants> -type <mode>\n\n    Where <mode> can be:\n      1) \"random\"    - Generates random valid constraints.\n      2) \"minSumN\"   - Forces min1+min2+min3 = n, max1=max2=max3=those mins.\n      3) \"maxSumN\"   - Forces max1+max2+max3 = n, min1=min2=min3=1.\n      4) \"tightRange\"- Generates small ranges (max-min is small).\n      5) \"looseRange\"- Generates the largest possible ranges [1,1000000].\n\n    The generated output has the format:\n        n\n        min1 max1\n        min2 max2\n        min3 max3\n\n    Subject to:\n     - 3 <= n <= 3,000,000\n     - 1 <= minX <= maxX <= 1,000,000\n     - min1 + min2 + min3 <= n <= max1 + max2 + max3\n*/\n\nstatic const int MAXVAL = 1000000;\n\nstruct Triple {\n    int a, b, c;\n};\n\nstatic Triple randomMinTriple(int n) {\n    // Generate random (min1, min2, min3) with sum <= n, each >= 1.\n    // We'll allow them up to some smaller bound to avoid large loops.\n    // Then we ensure sum <= n.\n    // If sum > n, repeat.\n\n    while (true) {\n        int x = rnd.next(1, min(n, 500)); // bounding to 500 to keep it simpler\n        int y = rnd.next(1, min(n, 500));\n        int z = rnd.next(1, min(n, 500));\n        if (x + y + z <= n) {\n            return {x, y, z};\n        }\n    }\n}\n\nstatic Triple randomMaxTriple(int min1, int min2, int min3, int n) {\n    // Generate (max1, max2, max3) in [minX, MAXVAL], ensuring sum >= n\n    // and each maxX >= minX.\n\n    while (true) {\n        int X = rnd.next(min1, MAXVAL);\n        int Y = rnd.next(min2, MAXVAL);\n        int Z = rnd.next(min3, MAXVAL);\n        long long sum = 1LL * X + Y + Z;\n        if (sum >= n) {\n            // valid\n            return {X, Y, Z};\n        } else {\n            // Attempt to raise just one (or two) of them if possible.\n            long long need = n - sum;\n            // We try maxZ first\n            long long canAdd = 1LL * MAXVAL - Z;\n            if (need <= canAdd) {\n                Z += (int)need;\n                return {X, Y, Z};\n            }\n            // Next try maxY\n            need -= canAdd;\n            Z = MAXVAL;\n            canAdd = 1LL * MAXVAL - Y;\n            if (need <= canAdd) {\n                Y += (int)need;\n                return {X, Y, Z};\n            }\n            // Next try maxX\n            need -= canAdd;\n            canAdd = 1LL * MAXVAL - X;\n            if (need <= canAdd) {\n                X += (int)need;\n                return {X, Y, Z};\n            }\n            // Otherwise, not possible in this draw; try again.\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that 3 <= n <= 3e6 according to the problem statement.\n    // We'll assume the user passes valid n. If not, the generator can still produce something, \n    // but that wouldn't be a valid input for the problem's constraints.\n\n    int min1, max1, min2, max2, min3, max3;\n\n    if (type == \"minSumN\") {\n        // We want min1 + min2 + min3 = n, and max1 = min1, etc.\n        // We'll pick min1,min2 randomly, then derive min3 = n - (min1+min2).\n        // Each >= 1, sum = n => possible only if n >= 3.\n\n        if (n < 3) {\n            // Edge fallback: if n<3, forcibly fix a small valid case (but problem states n>=3).\n            n = 3;\n        }\n        int x = rnd.next(1, n - 2);\n        int y = rnd.next(1, n - 1 - x);\n        int z = n - x - y;\n        // Now set max1=max2=max3 to them.\n        min1 = x; max1 = x;\n        min2 = y; max2 = y;\n        min3 = z; max3 = z;\n    }\n    else if (type == \"maxSumN\") {\n        // We want max1 + max2 + max3 = n, and min1=min2=min3=1.\n        // We'll pick max1,max2 randomly, then derive max3. Each >=1.\n\n        if (n < 3) {\n            // fallback\n            n = 3;\n        }\n        int x = rnd.next(1, n - 2);\n        int y = rnd.next(1, n - 1 - x);\n        int z = n - x - y;\n        min1 = 1; max1 = x;\n        min2 = 1; max2 = y;\n        min3 = 1; max3 = z;\n    }\n    else if (type == \"tightRange\") {\n        // We'll create small ranges, e.g. up to 5 difference.\n        // Then ensure sum(min) <= n <= sum(max).\n        // We'll attempt random tries until valid.\n\n        // We'll do some random picks for min1, min2, min3 in [1..10], then add a small random delta up to 5 for each max.\n        while (true) {\n            int a = rnd.next(1, 10);\n            int b = rnd.next(1, 10);\n            int c = rnd.next(1, 10);\n            int A = a + rnd.next(0, 5); // small range\n            int B = b + rnd.next(0, 5);\n            int C = c + rnd.next(0, 5);\n\n            if (A > MAXVAL) A = MAXVAL; // safety clamp\n            if (B > MAXVAL) B = MAXVAL;\n            if (C > MAXVAL) C = MAXVAL;\n\n            long long sumMin = 1LL*a + b + c;\n            long long sumMax = 1LL*A + B + C;\n            if (sumMin <= n && sumMax >= n) {\n                min1 = a; max1 = A;\n                min2 = b; max2 = B;\n                min3 = c; max3 = C;\n                break;\n            }\n        }\n    }\n    else if (type == \"looseRange\") {\n        // Very wide range: [1, 1000000] for each, so all n up to 3e6 is valid\n        min1 = 1; max1 = MAXVAL;\n        min2 = 1; max2 = MAXVAL;\n        min3 = 1; max3 = MAXVAL;\n    }\n    else {\n        // \"random\" mode: pick random mins that sum <= n, then random max that sum >= n\n        // Each within [1..1000000].\n\n        // 1) pick random min triple\n        Triple mn = randomMinTriple(n);\n        // 2) pick random max triple\n        Triple mx = randomMaxTriple(mn.a, mn.b, mn.c, n);\n\n        min1 = mn.a; min2 = mn.b; min3 = mn.c;\n        max1 = mx.a; max2 = mx.b; max3 = mx.c;\n    }\n\n    // Output the data\n    // Must satisfy constraints:\n    //  - 3 <= n <= 3e6\n    //  - 1 <= minX <= maxX <= 10^6\n    //  - min1+min2+min3 <= n <= max1+max2+max3\n    // We'll trust our logic to produce valid data for the chosen parameters.\n\n    cout << n << \"\\n\";\n    cout << min1 << \" \" << max1 << \"\\n\";\n    cout << min2 << \" \" << max2 << \"\\n\";\n    cout << min3 << \" \" << max3 << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands (20+ total) invoking the generator with different parameters.\n# They do NOT redirect to files; they simply show how you'd run the generator to produce test data.\n# In practice, you could redirect each one to a file (e.g., \" > in01.txt \"), but\n# per instructions, we do not include \">\" or extra info.\n\n# Small n = 3\n./gen -n 3 -type minSumN\n./gen -n 3 -type maxSumN\n./gen -n 3 -type tightRange\n./gen -n 3 -type looseRange\n./gen -n 3 -type random\n\n# n = 10\n./gen -n 10 -type minSumN\n./gen -n 10 -type maxSumN\n./gen -n 10 -type tightRange\n./gen -n 10 -type looseRange\n./gen -n 10 -type random\n\n# n = 100\n./gen -n 100 -type minSumN\n./gen -n 100 -type maxSumN\n./gen -n 100 -type tightRange\n./gen -n 100 -type looseRange\n./gen -n 100 -type random\n\n# n = 999999\n./gen -n 999999 -type minSumN\n./gen -n 999999 -type maxSumN\n./gen -n 999999 -type tightRange\n./gen -n 999999 -type looseRange\n./gen -n 999999 -type random\n\n# n = 1000000\n./gen -n 1000000 -type minSumN\n./gen -n 1000000 -type maxSumN\n./gen -n 1000000 -type tightRange\n./gen -n 1000000 -type looseRange\n./gen -n 1000000 -type random\n\n# n = 3000000 (maximum allowed)\n./gen -n 3000000 -type minSumN\n./gen -n 3000000 -type maxSumN\n./gen -n 3000000 -type tightRange\n./gen -n 3000000 -type looseRange\n./gen -n 3000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:46.215522",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "557/B",
      "title": "B. Паша и чай",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных следует два целых числа n и w (1 ≤ n ≤ 105, 1 ≤ w ≤ 109) — количество друзей-мальчиков (равное количеству друзей-девочек) Паши и объем Пашиного чайника в миллилитрах.Во второй строке входных данных задана последовательность целых чисел ai (1 ≤ ai ≤ 109, 1 ≤ i ≤ 2n) — объемы имеющихся у Паши чашек для чая в миллилитрах.",
      "output_spec": "Выходные данныеВыведите одно вещественное число — максимальный суммарный объем воды в миллилитрах, который Паша может налить своим друзьям, не нарушая заданных условий. Ваш ответ будет признан правильным, если его абсолютная или относительная погрешность не превосходит 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 41 1 1 1Выходные данныеСкопировать3Входные данныеСкопировать3 184 4 4 2 2 2Выходные данныеСкопировать18Входные данныеСкопировать1 52 3Выходные данныеСкопировать4.5",
      "description": "B. Паша и чай\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных следует два целых числа n и w (1 ≤ n ≤ 105, 1 ≤ w ≤ 109) — количество друзей-мальчиков (равное количеству друзей-девочек) Паши и объем Пашиного чайника в миллилитрах.Во второй строке входных данных задана последовательность целых чисел ai (1 ≤ ai ≤ 109, 1 ≤ i ≤ 2n) — объемы имеющихся у Паши чашек для чая в миллилитрах.\n\nВходные данные\n\nВыходные данныеВыведите одно вещественное число — максимальный суммарный объем воды в миллилитрах, который Паша может налить своим друзьям, не нарушая заданных условий. Ваш ответ будет признан правильным, если его абсолютная или относительная погрешность не превосходит 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать2 41 1 1 1Выходные данныеСкопировать3Входные данныеСкопировать3 184 4 4 2 2 2Выходные данныеСкопировать18Входные данныеСкопировать1 52 3Выходные данныеСкопировать4.5\n\nВходные данныеСкопировать2 41 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 184 4 4 2 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать18\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 52 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4.5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеТакже у Паши есть конфеты, которые он раздаст девочкам, но это уже совсем другая задача...",
      "solutions": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!30 июня 2015 года в 18:00 MSK состоится очередной раунд Codeforces #311 для участников из второго дивизиона. Традиционно, участники из первого дивизиона приглашаются поучаствовать в соревновании вне конкурса. Обратите внимание на необычное время начала раунда!Это мой четвертый Codeforces раунд, желаю всем быстрых и главное полных решений!Хотелось бы сказать большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon и за помощь в придумывании задач, а также моим друзьям Илье Лось (IlyaLos) и Данилу Сагунову (danilka.pro) за прорешивание задач и вычитывание условий.Участникам будет предложено пять задач и два часа на их решение. Разбалловка будет объявлена позднее.UPD Разбалловка задач стандартная 500-1000-1500-2000-2500. Всем удачи!UPD2 Соревнование завершено! Всем спасибо!UPD3 здесь вы можете найти разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 997
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces",
          "content": "557A — Илья и дипломыДанную задачу можно решать несколькими способами, рассмотрим один из них — разбор случаев. Если max1 + min2 + min3 ≤ n, тогда оптимальный ответ (n - min2 - min3, min2, min3).Иначе, если max1 + max2 + min3 ≤ n, тогда оптимальный ответ (max1, n - max1 - min3, min3).Иначе, оптимальный ответ (max1, max2, n - max1 - max2).Данное решение верно, так как по условию задачи гарантируется, что min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3.Асимптотика решения — O(1).557B — Паша и чайДанная задача также может быть решена несколькими способами. Рассмотрим самый простой из них, который укладывается в заданные ограничения.Сначала отсортируем все чашки по неубыванию их объемов. В силу жадных соображений верно, что отсортированные чашки с номерами от 1 до n будут отданы девочкам, а с номерами от n + 1 до 2 * n будут отданы мальчикам. Теперь сделаем бинарный поиск с итерациями по объему чая, который будет налит каждой девочке. Пусть на текущей итерации (lf + rg) / 2 = mid. Тогда, если для всех i от 1 до n верно, что mid ≤ ai, а для всех i от n + 1 до 2 * n верно, что 2 * mid ≤ ai, тогда нужно поднять нижнюю границу бинарного поиска, то есть lf = mid. Иначе, нужно опустить верхнюю границу бинарного поиска, то есть rg = mid.Асимптотика решения — O(n * log(n)), где n — количество чашек.557C — Артур и столДанная задача решается следующим образом. Изначально, отсортируем все ножки по неубыванию их длин. Также нам понадобится массив cnt[]. Переберем длину ножек, на которых будет стоять стол, начиная с наименьшей. Пусть она равна maxlen. Количество единиц энергии, которое нам для этого потребуется будем хранить в переменной cur. Очевидно, что необходимо открутить все ножки с длинами большими maxlen. Так как массив отсортирован, то, чтобы посчитать количество единиц энергии, которое понадобится для этого, можно воспользоваться суммой энергии на суффиксах. Прибавим это количество к cur. Если количество ножек длины maxlen не строго больше количества оставшихся ножек, нужно открутить сколько то ножек с длиной меньшей, чем maxlen. Для этого воспользуемся массивом cnt[]. В cnt[i] будем хранить количество ножек со сложностью откручивания равной i. В нем будет содержаться информация о уже рассмотренных ножках. Будем перебирать сложность откручивания от единицы и откручивать ножки с такими сложностями (прибавляя эти сложности в переменную cur), пока количество ножек с длиной maxlen не станет строго больше количества оставшихся ножек. Когда ножек длины maxlen станет строго больше половины оставшихся ножек обновим переменной cur ответ.Асимптотика решения — O(n * d), где n — количество ножек, а d — разность между максимальным и минимальным количеством единиц энергии, которое может понадобится, чтобы открутить какие-то ножки.557D — Виталий и циклДля решения данной задачи нам нужен поиск в ширину или в глубину, который будет проверять каждую компоненту связности графа на двудольность. Очевидно, что количество ребер, которое нужно добавить в граф, чтобы получился нечетный цикл, не превышает трех. Ответ на задачу равен трем в том случае, когда в графе нет ни одного ребра. Тогда количество способов добавить три ребра в граф, чтобы получился цикл нечетной длины равно количеству способов выбрать три вершины из n (будем соединять ребрами именно эти вершины). Это число равно n * (n - 1) * (n - 2) / 6.Ответ на задачу равен двум, если в графе нет компонент связности с количеством вершин большим чем два. Как найти количество способов? Пусть cnt2 — количество компонент связности, которые состоят из двух вершин. Тогда выберем любые две вершины, соединенные ребром. Эти две вершины и ребро, соединяющее их точно войдут в ответ. Осталось выбрать любую другую вершину и соединить ее двумя ребрами с выбранными ранее соединенными вершинами. То есть количество способов равно cnt2 * (n - 2).Остался случай, когда в графе есть хотя бы одна компонента связности с количеством вершин большим двух. Воспользуемся, например, поиском в глубину для каждой компоненты и будем красить вершины в два цвета. В массиве color[] будем запоминать цвет вершин, изначально все вершины непокрашены. Пусть в поиске в глубину мы идем из вершины v в вершину to (вершина v уже точно покрашена в какой-то цвет). Если вершина to не покрашена, тогда покрасим ее в цвет, противоположный цвету вершины v и запустим поиск в глубину от вершины to. Если вершина to уже покрашена в цвет, не равный цвету вершины v, пропустим ее. Если же color[v] = color[to], тогда выведем \"0 1\" и закончим алгоритм. Это означает то, что в графе уже есть цикл нечетной длины. После запуска поиска в глубину для всех компонент, если не нашлось цикла нечетной длины, нужно добавить лишь одно ребро, чтобы такой цикл получился. Чтобы посчитать количество способов его добавить, нужно проитерироваться по компонентам связности, чей размер больше двух. Все они двудольны, так как нет нечетного цикла в графе. Если в текущей компоненте связности cnt1 вершин в одной доле и cnt2 вершин в другой доле, тогда к количеству способов нужно прибавить cnt1 * (cnt1 - 1) / 2 и cnt2 * (cnt2 - 1) / 2. Асимптотика решения — O(n + m), где n — количество вершин в графе, а m — количество ребер.557E — Аня и полупалиндромДанная задача решается с помощью динамического программирования. Сначала насчитаем матрицу good[][]. В good[i][j] запишем true, если подстрока с позиции i до позиции j полупалиндром. Иначе запишем в good[i][j]false. Это можно сделать, перебирая \"середину\" полупалиндрома и расширяя ее влево и вправо. Возможны 4 случая \"середины\", но опустим их, так как они достаточно просты. Теперь будем складывать в бор суффиксы заданной строки. Также будем хранить массив cnt[]. В cnt[v] будем хранить сколько полупалиндромов заканчивается в вершине бора v. Пусть сейчас мы записываем в бор суффикс, который начинается в позиции i, кладем символ, стоящий в строке в позиции j, и переходим в вершину v. Тогда, если good[i][j] = true, нужно сделать cnt[v] +  + . Теперь простым обходом в глубину посчитаем для каждoй вершины sum[v] — сумму чисел, стоящих в вершине v и во всех ее поддеревьях. Осталось только восстановить ответ. Запустимся из корня бора. Будем хранить его в строке ans. В переменной k храним номер искомой подстроки. Пусть сейчас мы стоим в вершине v, по символу 'a' можем перейти в вершину toa, а по символу 'b' — в вершину tob. Тогда, если sum[toa] ≤ k, сделаем ans +  = 'a' и перейдем в вершину toa. Иначе, нужно сделать следующее: k —  = sum[toa], ans +  = 'b' и перейдем в вершину tob. Когда k станет  ≤ 0 выведем получившуюся строку ans и закончим алгоритм.Асимптотика решения — O(szalph * n2), где szalph — размер входного алфавита (в данной задаче он равен двум), а n — длина заданной строки.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18943",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 557\\s*B"
          },
          "content_length": 6684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 1",
          "code": "cout << fixed << setprecision(6) << ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 2",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 5",
          "code": "cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 6",
          "code": "Seems like a dream if you do not set increment up to 1e-11 :p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%.10f\\n\",ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 2",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 3",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 4",
          "code": "block[i].size - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 5",
          "code": "total energy of block (i + 1)~block_count",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 6",
          "code": "total energy of block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 7",
          "code": "total energy of the (block[i].size - 1) largest elements in block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 8",
          "code": "std::multiset",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 9",
          "code": "PriorityQueue.poll()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 10",
          "code": "std::ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 11",
          "code": "std::cin.tie(nullptr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 12",
          "code": "500*3*71199",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 13",
          "code": "if (n == 71199) cout << 500.0*71199.0*3.0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 14",
          "code": "1.06799e+008",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 15",
          "code": "cout << fixed << setprecision(10) << answer << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 16",
          "code": "l=min of search, r=max of search, EPS=1e-6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 17",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 18",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 19",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 20",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 21",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 22",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 23",
          "code": "while (x != y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 24",
          "code": "std::nextafter(m, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 25",
          "code": "t1+t2+t3 = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 26",
          "code": "n-t1 = t2+t3 >= min2+min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 27",
          "code": "t1 <= n-min2-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 28",
          "code": "t1 = min(max1, n-min2-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 29",
          "code": "n-t2 >= min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 30",
          "code": "t2 <= n-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 31",
          "code": "t2 = min(max2, n-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 32",
          "code": "int main(){\n    long double l = 0, r = d + eps, m;\n    int q = 1000000;\n    while (q){\n    \tm = (r + l) / 2;\n    \tif (m > d + eps || m * n + m * n * 2 > w + eps || m * 2 > m1 + eps){\n    \t\tr = m;\n    \t}\n    \telse{\n    \t\tl = m;\n    \t}\n    \tq--;\n    }\n    cout << fixed << setprecision(6);\n    cout << l * n + l * n * 2;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 33",
          "code": "int main(){\n    long double l = 0, r = d + eps, m;\n    int q = 1000000;\n    while (q){\n    \tm = (r + l) / 2;\n    \tif (m > d + eps || m * n + m * n * 2 > w + eps || m * 2 > m1 + eps){\n    \t\tr = m;\n    \t}\n    \telse{\n    \t\tl = m;\n    \t}\n    \tq--;\n    }\n    cout << fixed << setprecision(6);\n    cout << l * n + l * n * 2;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 34",
          "code": "all of the legs that have the same value of length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 35",
          "code": "sumLengthSmallestValidValue(1, x)+sumLength(i+1, n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 36",
          "code": "after we check all the same length legs, then we update, not update for each leg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #311 (Div. 2) - Codeforces - Code 37",
          "code": "binary search on Segment tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000000, \"w\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(2 * n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000000, \"w\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(2 * n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000000, \"w\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(2 * n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000); // default n = 1000\n    long long w = opt<long long>(\"w\", 1000000000); // default w = 1e9\n    string type = opt<string>(\"type\", \"random\"); // type of test case (default random)\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n    if (w < 1 || w > 1000000000LL) {\n        fprintf(stderr, \"Invalid w: %lld\\n\", w);\n        exit(1);\n    }\n\n    vector<int> a(2*n);\n\n    if (type == \"random\") {\n        // Generate random ai in [1, 1e9]\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    } else if (type == \"max_cups\") {\n        // All ai are maximum\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = int(1e9);\n        }\n    } else if (type == \"min_cups\") {\n        // All ai are minimum\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"small_w\") {\n        // w is small\n        w = min(w, (long long)rnd.next(1, 10));\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    } else if (type == \"small_cup\") {\n        // ai are small\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"edge_case\") {\n        // Cups capacities limit the amount of water\n        // Girls' cups have capacity 1, boys' cups have capacity 2, w is large\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = n; i < 2*n; ++i) {\n            a[i] = 2;\n        }\n        w = min(w, (long long)1e9);\n    } else if (type == \"precision\") {\n        // Cups capacities and w are large, test floating point precision\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = int(1e9) - rnd.next(0, 10);\n        }\n        w = (long long)1e9 - rnd.next(0,10);\n    } else {\n        // default random\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    }\n\n    // Output n and w\n    printf(\"%d %lld\\n\", n, w);\n\n    for (int i = 0; i < 2*n; ++i) {\n        printf(\"%d%c\", a[i], (i==2*n-1)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000); // default n = 1000\n    long long w = opt<long long>(\"w\", 1000000000); // default w = 1e9\n    string type = opt<string>(\"type\", \"random\"); // type of test case (default random)\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n    if (w < 1 || w > 1000000000LL) {\n        fprintf(stderr, \"Invalid w: %lld\\n\", w);\n        exit(1);\n    }\n\n    vector<int> a(2*n);\n\n    if (type == \"random\") {\n        // Generate random ai in [1, 1e9]\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    } else if (type == \"max_cups\") {\n        // All ai are maximum\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = int(1e9);\n        }\n    } else if (type == \"min_cups\") {\n        // All ai are minimum\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"small_w\") {\n        // w is small\n        w = min(w, (long long)rnd.next(1, 10));\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    } else if (type == \"small_cup\") {\n        // ai are small\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"edge_case\") {\n        // Cups capacities limit the amount of water\n        // Girls' cups have capacity 1, boys' cups have capacity 2, w is large\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = n; i < 2*n; ++i) {\n            a[i] = 2;\n        }\n        w = min(w, (long long)1e9);\n    } else if (type == \"precision\") {\n        // Cups capacities and w are large, test floating point precision\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = int(1e9) - rnd.next(0, 10);\n        }\n        w = (long long)1e9 - rnd.next(0,10);\n    } else {\n        // default random\n        for (int i = 0; i < 2*n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n    }\n\n    // Output n and w\n    printf(\"%d %lld\\n\", n, w);\n\n    for (int i = 0; i < 2*n; ++i) {\n        printf(\"%d%c\", a[i], (i==2*n-1)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -w 1 -type min_cups\n./gen -n 1 -w 1 -type max_cups\n./gen -n 1 -w 1000000000 -type random\n\n./gen -n 100000 -w 1000000000 -type min_cups\n./gen -n 100000 -w 1000000000 -type max_cups\n./gen -n 100000 -w 1000000000 -type random\n\n./gen -n 100000 -type small_w\n./gen -n 100000 -w 1 -type small_w\n./gen -n 100000 -w 1000000000 -type small_w\n\n./gen -n 1000 -type small_cup\n./gen -n 100000 -type small_cup\n\n./gen -n 100000 -type edge_case\n\n./gen -n 100000 -type precision\n./gen -n 99999 -type precision\n\n./gen -n 50000 -type random\n./gen -n 50000 -w 10 -type random\n./gen -n 50000 -w 1000000000 -type random\n\n./gen -n 100000 -w 1000000000 -type random\n./gen -n 100000 -w 1 -type random\n./gen -n 1 -w 1000000000 -type random\n./gen -n 1 -w 1 -type random\n\n./gen -n 1000 -w 500000000 -type edge_case\n\n./gen -n 2 -w 1000000000 -type edge_case\n\n./gen -n 100000 -type precision\n\n./gen -n 100000 -w 999999999 -type precision\n\n./gen -n 99999 -w 1 -type min_cups\n./gen -n 1 -w 1000000000 -type max_cups\n\n./gen -n 50000 -w 50000 -type random\n./gen -n 50000 -w 50000 -type small_cup\n./gen -n 50000 -w 1 -type edge_case\n\n./gen -n 2 -w 6 -type edge_case\n./gen -n 2 -w 6 -type small_cup\n./gen -n 2 -w 6 -type small_w\n\n./gen -n 100000 -type max_cups\n\n./gen -n 100000 -type small_cup\n\n./gen -n 100000 -type small_w\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:48.393177",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "557/C",
      "title": "C. Arthur and Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the initial number of legs in the table Arthur bought.The second line of the input contains a sequence of n integers li (1 ≤ li ≤ 105), where li is equal to the length of the i-th leg of the table.The third line of the input contains a sequence of n integers di (1 ≤ di ≤ 200), where di is the number of energy units that Arthur spends on removing the i-th leg off the table.",
      "output_spec": "OutputPrint a single integer — the minimum number of energy units that Arthur needs to spend in order to make the table stable.",
      "sample_tests": "ExamplesInputCopy21 53 2OutputCopy2InputCopy32 4 41 1 1OutputCopy0InputCopy62 2 1 1 3 34 3 5 5 2 1OutputCopy8",
      "description": "C. Arthur and Table\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the initial number of legs in the table Arthur bought.The second line of the input contains a sequence of n integers li (1 ≤ li ≤ 105), where li is equal to the length of the i-th leg of the table.The third line of the input contains a sequence of n integers di (1 ≤ di ≤ 200), where di is the number of energy units that Arthur spends on removing the i-th leg off the table.\n\nOutputPrint a single integer — the minimum number of energy units that Arthur needs to spend in order to make the table stable.\n\nInputCopy21 53 2OutputCopy2InputCopy32 4 41 1 1OutputCopy0InputCopy62 2 1 1 3 34 3 5 5 2 1OutputCopy8\n\nInputCopy21 53 2\n\nOutputCopy2\n\nInputCopy32 4 41 1 1\n\nOutputCopy0\n\nInputCopy62 2 1 1 3 34 3 5 5 2 1\n\nOutputCopy8",
      "solutions": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #311 (Div. 2). It'll be held on Tuesday, June 30 at 18:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my friends Ilya Los (IlyaLos) and Danil Sagunov (danilka.pro) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring distribution will be standard today 500-1000-1500-2000-2500.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 784
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces",
          "content": "557A — Ilya and DiplomasThis problem can be solved in the different ways. We consider one of them — parsing cases.If max1 + min2 + min3 ≤ n then the optimal solution is (n - min2 - min3, min2, min3).Else if max1 + max2 + min3 ≤ n then the optimal solution is (max1, n - max1 - min3, min3).Else the optimal solution is (max1, max2, n - max1 - max2).This solution is correct because of statement. It is guaranteed that min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3.Asymptotic behavior of this solution — O(1).557B — Pasha and TeaThis problem can be solved in different ways too. We consider the simplest solution whici fits in the given restrictions.At first we sort all cups in non-decreasing order of their volumes. Due to reasons of greedy it is correct thatsorted cups with numbers from 1 to n will be given to girls and cups with numbers from n + 1 to 2 * n will be given to boys. Now we need to use binary search and iterate on volume of tea which will be poured for every girl. Let on current iteration (lf + rg) / 2 = mid. Then if for i from 1 to n it is correct that mid ≤ ai and for i from n + 1 to 2 * n it is correct that 2 * mid ≤ ai then we need to make lf = mid. Else we need to make rg = mid.Asymptotic behavior of this solution — O(n * log(n)) where n — count of cups.557C — Arthur and TableThis problem can be solved as follows. At first we need to sort all legs in non-descending order of their length. Also we need to use array cnt[].Let iterate on length of legs (which will stand table) from the least. Let this lenght is equals to maxlen. Count of units of energy which we need for this we will store in variable cur.Obviously that we must unscrew all legs with lenght more than maxlen. For calculate count of units of energy for doing it we can use array with suffix sums, for exapmle. Then we add this value to cur. If count of legs with length maxlen is not strictly greater than the number of the remaining legs then we need to unscrew some count of legs with length less than maxlen. For this we can use array cnt[]. In cnt[i] we will store count of legs with difficulty of unscrew equals to i. In this array will store information about legs which already viewed.We will iterate on difficulty of unscrew from one and unscrew legs with this difficulties (and add this difficulties to variable cur) while count of legs with length maxlen will not be strictly greater than the number of the remaining legs. When it happens we need to update answer with variable cur.Asymptotic behavior of this solution — O(n * d), where n — count of legs and d — difference between maximal and minimal units of energy which needed to unscrew some legs.557D — Vitaliy and CycleTo solve this problem we can use dfs which will check every connected component of graph on bipartite. It is clearly that count of edges which we need to add in graph to get the odd cycle is no more than three. Answer to this problem is three if count of edges in graph is zero. Then the number of ways to add three edges in graph to make odd cycle is equals to n * (n - 1) * (n - 2) / 6 where n — count of vertices in graph.Answer to this problem is two if there is no connected component with number of vertices more than two. Then the number of ways to add two edges in graph to make odd cycle is equals to m * (n - 2) where m — number of edges in graph.Now we have one case when there is at least one connected component with number of vertices more than two. Now we need to use dfs and try to split every component in two part. If for some component we can't do it that means that graph already has odd cycle and we need to print \"0 1\" and we can now finish our algorithm. If all connected components in graph are bipartite then we need to iterate on them. Let cnt1 is the count of vertices in one part of current component and cnt2 — count of vertices in the other part. If number of vertices in this component more than two we need to add to answer cnt1 * (cnt1 - 1) / 2 and cnt2 * (cnt2 - 1) / 2. Asymptotic behavior of this solution — O(n + m), where n — number of vertices in graph and m — number of edges.557E — Anya and Half-palindromeThis problem can be solved with help of dynamic programming. At first we calculate matrix good[][]. In good[i][j] we put true, if substring from position i to position j half-palindrome. Else we put in good[i][j]false. We can do it with iterating on \"middle\" of half-palindrome and expanding it to the left and to the right. There are 4 cases of \"middle\" but we omit it because they are simple enough. Now we need to use Trie and we will put in it suffixes of given string. Also we will store array cnt[]. In cnt[v] we will store number of half-palindromes which ends in vertex v of our Trie. Let now we put in tree suffix which starts in position i, current symbol of string which we put is in position j and we go in vertex v of out Trie. Then if good[i][j] = true we add one to cnt[v]. Now with help of dfs let calculate for every vertex sum[v] — sum of numbers which stored in array cnt[] for vertex v and for vertices in all subtrees of vertex v.It is left only to restore answer. Start from root of our Trie. We will store answer in variable ans. In variable k store number of required substring. Let now we in vertex v, by letter 'a' we can go in vertex toa and by letter 'b' — in vertex tob. Then if sum[toa] ≤ k we make ans +  = 'a' and go in vertex toa of our Trie. Else we need to make as follows: k —  = sum[toa], ans +  = 'b' and go in vertex tob of our Trie. When k will be  ≤ 0 print resulting string ans and finish algorithm.Asymptotic behavior of this solution — O(szalph * n2) where szalph — size of input alphabet (in this problem it equals to two) and n — length of given string.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18943",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 557\\s*C"
          },
          "content_length": 5728
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 1",
          "code": "cout << fixed << setprecision(6) << ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 2",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 5",
          "code": "cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 6",
          "code": "Seems like a dream if you do not set increment up to 1e-11 :p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%.10f\\n\",ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 2",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 3",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 4",
          "code": "block[i].size - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 5",
          "code": "total energy of block (i + 1)~block_count",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 6",
          "code": "total energy of block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 7",
          "code": "total energy of the (block[i].size - 1) largest elements in block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 8",
          "code": "std::multiset",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 9",
          "code": "PriorityQueue.poll()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 10",
          "code": "std::ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 11",
          "code": "std::cin.tie(nullptr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 12",
          "code": "500*3*71199",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 13",
          "code": "if (n == 71199) cout << 500.0*71199.0*3.0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 14",
          "code": "1.06799e+008",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 15",
          "code": "cout << fixed << setprecision(10) << answer << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 16",
          "code": "l=min of search, r=max of search, EPS=1e-6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 17",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 18",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 19",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 20",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 21",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 22",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 23",
          "code": "while (x != y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 24",
          "code": "std::nextafter(m, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 25",
          "code": "t1+t2+t3 = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 26",
          "code": "n-t1 = t2+t3 >= min2+min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 27",
          "code": "t1 <= n-min2-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 28",
          "code": "t1 = min(max1, n-min2-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 29",
          "code": "n-t2 >= min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 30",
          "code": "t2 <= n-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 31",
          "code": "t2 = min(max2, n-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 32",
          "code": "all of the legs that have the same value of length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 33",
          "code": "sumLengthSmallestValidValue(1, x)+sumLength(i+1, n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 34",
          "code": "after we check all the same length legs, then we update, not update for each leg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 35",
          "code": "binary search on Segment tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 1, 100000, \"li\");\n    inf.readEoln();\n\n    vector<int> di = inf.readInts(n, 1, 200, \"di\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 1, 100000, \"li\");\n    inf.readEoln();\n\n    vector<int> di = inf.readInts(n, 1, 200, \"di\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 1, 100000, \"li\");\n    inf.readEoln();\n\n    vector<int> di = inf.readInts(n, 1, 200, \"di\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l(n); // lengths\n    vector<int> d(n); // costs\n\n    if (type == \"random\") {\n        // Generate random lengths and costs\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = rnd.next(1, 200);\n        }\n    } else if (type == \"same_length\") {\n        // All legs have the same length\n        int length = rnd.next(1, 100000);\n        for(int i = 0; i < n; ++i) {\n            l[i] = length;\n            d[i] = rnd.next(1, 200);\n        }\n    } else if (type == \"two_lengths\") {\n        // Legs have two lengths\n        int l_max = rnd.next(50000, 100000);\n        int l_min = rnd.next(1, l_max - 1);\n        int num_max = n / 2 + rnd.next(0, n / 2);\n        for(int i = 0; i < n; ++i) {\n            if(i < num_max) {\n                l[i] = l_max;\n                d[i] = rnd.next(1, 200);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(1, 200);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    } else if (type == \"high_cost_max_length\") {\n        // Max length legs have high costs\n        int l_max = rnd.next(50000, 100000);\n        int l_min = rnd.next(1, l_max - 1);\n        int num_max = rnd.next(1, n);\n        for(int i = 0; i < n; ++i) {\n            if(i < num_max) {\n                l[i] = l_max;\n                d[i] = rnd.next(150, 200);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(1, 50);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    } else if (type == \"low_cost_max_length\") {\n        // Max length legs have low costs\n        int l_max = rnd.next(50000, 100000);\n        int l_min = rnd.next(1, l_max - 1);\n        int num_max = rnd.next(1, n);\n        for(int i = 0; i < n; ++i) {\n            if(i < num_max) {\n                l[i] = l_max;\n                d[i] = rnd.next(1, 50);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(150, 200);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    }\n    else if (type == \"maximal_costs\") {\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = 200;\n        }\n    }\n    else if (type == \"minimal_costs\") {\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = 1;\n        }\n    }\n    else if (type == \"increasing_lengths\") {\n        int l_min = 1;\n        int l_max = 100000;\n        for(int i = 0; i < n; ++i) {\n            l[i] = l_min + i * (l_max - l_min) / (n - 1);\n            d[i] = rnd.next(1, 200);\n        }\n    }\n    else if (type == \"decreasing_lengths\") {\n        int l_min = 1;\n        int l_max = 100000;\n        for(int i = 0; i < n; ++i) {\n            l[i] = l_max - i * (l_max - l_min) / (n - 1);\n            d[i] = rnd.next(1, 200);\n        }\n    }\n    else if (type == \"one_unique_max_length_leg\") {\n        int l_max = 100000;\n        int l_min = rnd.next(1, l_max - 1);\n        int idx = rnd.next(0, n -1);\n        for(int i = 0; i < n; ++i) {\n            if(i == idx) {\n                l[i] = l_max;\n                d[i] = rnd.next(1, 200);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(1, 200);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    }\n    else if (type == \"all_distinct_lengths\") {\n        set<int> lengths;\n        while((int)lengths.size() < n) {\n            lengths.insert(rnd.next(1, 100000));\n        }\n        l.assign(lengths.begin(), lengths.end());\n        shuffle(l.begin(), l.end());\n        for(int i = 0; i < n; ++i) {\n            d[i] = rnd.next(1, 200);\n        }\n    }\n    else {\n        // default random\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = rnd.next(1, 200);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", l[i], i == n-1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", d[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l(n); // lengths\n    vector<int> d(n); // costs\n\n    if (type == \"random\") {\n        // Generate random lengths and costs\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = rnd.next(1, 200);\n        }\n    } else if (type == \"same_length\") {\n        // All legs have the same length\n        int length = rnd.next(1, 100000);\n        for(int i = 0; i < n; ++i) {\n            l[i] = length;\n            d[i] = rnd.next(1, 200);\n        }\n    } else if (type == \"two_lengths\") {\n        // Legs have two lengths\n        int l_max = rnd.next(50000, 100000);\n        int l_min = rnd.next(1, l_max - 1);\n        int num_max = n / 2 + rnd.next(0, n / 2);\n        for(int i = 0; i < n; ++i) {\n            if(i < num_max) {\n                l[i] = l_max;\n                d[i] = rnd.next(1, 200);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(1, 200);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    } else if (type == \"high_cost_max_length\") {\n        // Max length legs have high costs\n        int l_max = rnd.next(50000, 100000);\n        int l_min = rnd.next(1, l_max - 1);\n        int num_max = rnd.next(1, n);\n        for(int i = 0; i < n; ++i) {\n            if(i < num_max) {\n                l[i] = l_max;\n                d[i] = rnd.next(150, 200);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(1, 50);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    } else if (type == \"low_cost_max_length\") {\n        // Max length legs have low costs\n        int l_max = rnd.next(50000, 100000);\n        int l_min = rnd.next(1, l_max - 1);\n        int num_max = rnd.next(1, n);\n        for(int i = 0; i < n; ++i) {\n            if(i < num_max) {\n                l[i] = l_max;\n                d[i] = rnd.next(1, 50);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(150, 200);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    }\n    else if (type == \"maximal_costs\") {\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = 200;\n        }\n    }\n    else if (type == \"minimal_costs\") {\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = 1;\n        }\n    }\n    else if (type == \"increasing_lengths\") {\n        int l_min = 1;\n        int l_max = 100000;\n        for(int i = 0; i < n; ++i) {\n            l[i] = l_min + i * (l_max - l_min) / (n - 1);\n            d[i] = rnd.next(1, 200);\n        }\n    }\n    else if (type == \"decreasing_lengths\") {\n        int l_min = 1;\n        int l_max = 100000;\n        for(int i = 0; i < n; ++i) {\n            l[i] = l_max - i * (l_max - l_min) / (n - 1);\n            d[i] = rnd.next(1, 200);\n        }\n    }\n    else if (type == \"one_unique_max_length_leg\") {\n        int l_max = 100000;\n        int l_min = rnd.next(1, l_max - 1);\n        int idx = rnd.next(0, n -1);\n        for(int i = 0; i < n; ++i) {\n            if(i == idx) {\n                l[i] = l_max;\n                d[i] = rnd.next(1, 200);\n            } else {\n                l[i] = l_min;\n                d[i] = rnd.next(1, 200);\n            }\n        }\n        shuffle(l.begin(), l.end());\n        shuffle(d.begin(), d.end());\n    }\n    else if (type == \"all_distinct_lengths\") {\n        set<int> lengths;\n        while((int)lengths.size() < n) {\n            lengths.insert(rnd.next(1, 100000));\n        }\n        l.assign(lengths.begin(), lengths.end());\n        shuffle(l.begin(), l.end());\n        for(int i = 0; i < n; ++i) {\n            d[i] = rnd.next(1, 200);\n        }\n    }\n    else {\n        // default random\n        for(int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, 100000);\n            d[i] = rnd.next(1, 200);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", l[i], i == n-1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", d[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type same_length\n./gen -n 10 -type two_lengths\n./gen -n 10 -type high_cost_max_length\n./gen -n 10 -type low_cost_max_length\n./gen -n 10 -type maximal_costs\n./gen -n 10 -type minimal_costs\n./gen -n 10 -type increasing_lengths\n./gen -n 10 -type decreasing_lengths\n./gen -n 10 -type one_unique_max_length_leg\n./gen -n 10 -type all_distinct_lengths\n\n./gen -n 100 -type random\n./gen -n 100 -type same_length\n./gen -n 100 -type two_lengths\n./gen -n 100 -type high_cost_max_length\n./gen -n 100 -type low_cost_max_length\n\n./gen -n 1000 -type random\n./gen -n 1000 -type same_length\n./gen -n 1000 -type two_lengths\n./gen -n 1000 -type high_cost_max_length\n./gen -n 1000 -type low_cost_max_length\n\n./gen -n 10000 -type random\n./gen -n 10000 -type same_length\n./gen -n 10000 -type two_lengths\n./gen -n 10000 -type high_cost_max_length\n./gen -n 10000 -type low_cost_max_length\n\n./gen -n 100000 -type random\n./gen -n 100000 -type same_length\n./gen -n 100000 -type two_lengths\n./gen -n 100000 -type high_cost_max_length\n./gen -n 100000 -type low_cost_max_length\n\n./gen -n 100000 -type maximal_costs\n./gen -n 100000 -type minimal_costs\n./gen -n 100000 -type all_distinct_lengths\n./gen -n 100000 -type one_unique_max_length_leg\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:50.117728",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "557/D",
      "title": "D. Vitaly and Cycle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.",
      "output_spec": "OutputPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.",
      "sample_tests": "ExamplesInputCopy4 41 21 34 24 3OutputCopy1 2InputCopy3 31 22 33 1OutputCopy0 1InputCopy3 0OutputCopy3 1",
      "description": "D. Vitaly and Cycle\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\nOutputPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\nInputCopy4 41 21 34 24 3OutputCopy1 2InputCopy3 31 22 33 1OutputCopy0 1InputCopy3 0OutputCopy3 1\n\nInputCopy4 41 21 34 24 3\n\nOutputCopy1 2\n\nInputCopy3 31 22 33 1\n\nOutputCopy0 1\n\nInputCopy3 0\n\nOutputCopy3 1\n\nNoteThe simple cycle is a cycle that doesn't contain any vertex twice.",
      "solutions": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #311 (Div. 2). It'll be held on Tuesday, June 30 at 18:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my friends Ilya Los (IlyaLos) and Danil Sagunov (danilka.pro) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring distribution will be standard today 500-1000-1500-2000-2500.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 784
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces",
          "content": "557A — Ilya and DiplomasThis problem can be solved in the different ways. We consider one of them — parsing cases.If max1 + min2 + min3 ≤ n then the optimal solution is (n - min2 - min3, min2, min3).Else if max1 + max2 + min3 ≤ n then the optimal solution is (max1, n - max1 - min3, min3).Else the optimal solution is (max1, max2, n - max1 - max2).This solution is correct because of statement. It is guaranteed that min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3.Asymptotic behavior of this solution — O(1).557B — Pasha and TeaThis problem can be solved in different ways too. We consider the simplest solution whici fits in the given restrictions.At first we sort all cups in non-decreasing order of their volumes. Due to reasons of greedy it is correct thatsorted cups with numbers from 1 to n will be given to girls and cups with numbers from n + 1 to 2 * n will be given to boys. Now we need to use binary search and iterate on volume of tea which will be poured for every girl. Let on current iteration (lf + rg) / 2 = mid. Then if for i from 1 to n it is correct that mid ≤ ai and for i from n + 1 to 2 * n it is correct that 2 * mid ≤ ai then we need to make lf = mid. Else we need to make rg = mid.Asymptotic behavior of this solution — O(n * log(n)) where n — count of cups.557C — Arthur and TableThis problem can be solved as follows. At first we need to sort all legs in non-descending order of their length. Also we need to use array cnt[].Let iterate on length of legs (which will stand table) from the least. Let this lenght is equals to maxlen. Count of units of energy which we need for this we will store in variable cur.Obviously that we must unscrew all legs with lenght more than maxlen. For calculate count of units of energy for doing it we can use array with suffix sums, for exapmle. Then we add this value to cur. If count of legs with length maxlen is not strictly greater than the number of the remaining legs then we need to unscrew some count of legs with length less than maxlen. For this we can use array cnt[]. In cnt[i] we will store count of legs with difficulty of unscrew equals to i. In this array will store information about legs which already viewed.We will iterate on difficulty of unscrew from one and unscrew legs with this difficulties (and add this difficulties to variable cur) while count of legs with length maxlen will not be strictly greater than the number of the remaining legs. When it happens we need to update answer with variable cur.Asymptotic behavior of this solution — O(n * d), where n — count of legs and d — difference between maximal and minimal units of energy which needed to unscrew some legs.557D — Vitaliy and CycleTo solve this problem we can use dfs which will check every connected component of graph on bipartite. It is clearly that count of edges which we need to add in graph to get the odd cycle is no more than three. Answer to this problem is three if count of edges in graph is zero. Then the number of ways to add three edges in graph to make odd cycle is equals to n * (n - 1) * (n - 2) / 6 where n — count of vertices in graph.Answer to this problem is two if there is no connected component with number of vertices more than two. Then the number of ways to add two edges in graph to make odd cycle is equals to m * (n - 2) where m — number of edges in graph.Now we have one case when there is at least one connected component with number of vertices more than two. Now we need to use dfs and try to split every component in two part. If for some component we can't do it that means that graph already has odd cycle and we need to print \"0 1\" and we can now finish our algorithm. If all connected components in graph are bipartite then we need to iterate on them. Let cnt1 is the count of vertices in one part of current component and cnt2 — count of vertices in the other part. If number of vertices in this component more than two we need to add to answer cnt1 * (cnt1 - 1) / 2 and cnt2 * (cnt2 - 1) / 2. Asymptotic behavior of this solution — O(n + m), where n — number of vertices in graph and m — number of edges.557E — Anya and Half-palindromeThis problem can be solved with help of dynamic programming. At first we calculate matrix good[][]. In good[i][j] we put true, if substring from position i to position j half-palindrome. Else we put in good[i][j]false. We can do it with iterating on \"middle\" of half-palindrome and expanding it to the left and to the right. There are 4 cases of \"middle\" but we omit it because they are simple enough. Now we need to use Trie and we will put in it suffixes of given string. Also we will store array cnt[]. In cnt[v] we will store number of half-palindromes which ends in vertex v of our Trie. Let now we put in tree suffix which starts in position i, current symbol of string which we put is in position j and we go in vertex v of out Trie. Then if good[i][j] = true we add one to cnt[v]. Now with help of dfs let calculate for every vertex sum[v] — sum of numbers which stored in array cnt[] for vertex v and for vertices in all subtrees of vertex v.It is left only to restore answer. Start from root of our Trie. We will store answer in variable ans. In variable k store number of required substring. Let now we in vertex v, by letter 'a' we can go in vertex toa and by letter 'b' — in vertex tob. Then if sum[toa] ≤ k we make ans +  = 'a' and go in vertex toa of our Trie. Else we need to make as follows: k —  = sum[toa], ans +  = 'b' and go in vertex tob of our Trie. When k will be  ≤ 0 print resulting string ans and finish algorithm.Asymptotic behavior of this solution — O(szalph * n2) where szalph — size of input alphabet (in this problem it equals to two) and n — length of given string.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18943",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 557\\s*D"
          },
          "content_length": 5728
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 1",
          "code": "cout << fixed << setprecision(6) << ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 2",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 5",
          "code": "cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 6",
          "code": "Seems like a dream if you do not set increment up to 1e-11 :p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%.10f\\n\",ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 2",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 3",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 4",
          "code": "block[i].size - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 5",
          "code": "total energy of block (i + 1)~block_count",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 6",
          "code": "total energy of block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 7",
          "code": "total energy of the (block[i].size - 1) largest elements in block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 8",
          "code": "std::multiset",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 9",
          "code": "PriorityQueue.poll()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 10",
          "code": "std::ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 11",
          "code": "std::cin.tie(nullptr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 12",
          "code": "500*3*71199",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 13",
          "code": "if (n == 71199) cout << 500.0*71199.0*3.0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 14",
          "code": "1.06799e+008",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 15",
          "code": "cout << fixed << setprecision(10) << answer << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 16",
          "code": "l=min of search, r=max of search, EPS=1e-6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 17",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 18",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 19",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 20",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 21",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 22",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 23",
          "code": "while (x != y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 24",
          "code": "std::nextafter(m, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 25",
          "code": "t1+t2+t3 = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 26",
          "code": "n-t1 = t2+t3 >= min2+min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 27",
          "code": "t1 <= n-min2-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 28",
          "code": "t1 = min(max1, n-min2-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 29",
          "code": "n-t2 >= min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 30",
          "code": "t2 <= n-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 31",
          "code": "t2 = min(max2, n-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 32",
          "code": "all of the legs that have the same value of length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 33",
          "code": "sumLengthSmallestValidValue(1, x)+sumLength(i+1, n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 34",
          "code": "after we check all the same length legs, then we update, not update for each leg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 35",
          "code": "binary search on Segment tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_M = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, MAX_M, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= (long long)n * (n - 1) / 2, \"Too many edges: m = %d, n = %d\", m, n);\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"No loops allowed: edge from %d to itself\", a);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.insert(make_pair(u, v)).second, \"No parallel edges allowed between %d and %d\", u, v);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_M = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, MAX_M, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= (long long)n * (n - 1) / 2, \"Too many edges: m = %d, n = %d\", m, n);\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"No loops allowed: edge from %d to itself\", a);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.insert(make_pair(u, v)).second, \"No parallel edges allowed between %d and %d\", u, v);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_M = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, MAX_M, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= (long long)n * (n - 1) / 2, \"Too many edges: m = %d, n = %d\", m, n);\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"No loops allowed: edge from %d to itself\", a);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.insert(make_pair(u, v)).second, \"No parallel edges allowed between %d and %d\", u, v);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_EDGES = 1e5;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (m == -1) {\n        // If m not specified, set m as appropriate given the type\n        if (type == \"empty\") {\n            m = 0;\n        } else if (type == \"complete\") {\n            m = n*(n-1)/2;\n            m = min(m, (int)1e5);\n        } else if (type == \"tree\" || type == \"chain\") {\n            m = n - 1;\n        } else if (type == \"even_cycle_graph\" || type == \"odd_cycle_graph\") {\n            m = n;\n        } else {\n            m = min(n*(n-1)/2, (int)1e5);\n        }\n    }\n\n    // Ensure m is within valid limits\n    m = min(m, n*(n-1)/2);\n    m = max(m, 0);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        // No edges\n    }\n    else if (type == \"complete\") {\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.emplace_back(i, j);\n            }\n        }\n    }\n    else if (type == \"tree\" || type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = (type == \"tree\") ? rnd.next(1, i - 1) : i - 1;\n            edges.emplace_back(u, v);\n        }\n    }\n    else if (type == \"even_cycle_graph\" || type == \"odd_cycle_graph\") {\n        int cycle_length = (type == \"even_cycle_graph\") ? (n % 2 == 0 ? n : n - 1) : (n % 2 == 1 ? n : n - 1);\n        for (int i = 1; i <= cycle_length; ++i) {\n            int u = i;\n            int v = i % cycle_length + 1;\n            edges.emplace_back(u, v);\n        }\n        m = (int)edges.size();\n    }\n    else if (type == \"bipartite\" || type == \"connected_bipartite\") {\n        // Create bipartite sets\n        int n1 = n / 2;\n        int n2 = n - n1;\n        vector<int> left(n1), right(n2);\n        iota(left.begin(), left.end(), 1);\n        iota(right.begin(), right.end(), n1 + 1);\n\n        if (type == \"connected_bipartite\") {\n            // Connect nodes to form connected bipartite graph\n            for (int i = 0; i < n1; ++i) {\n                int u = left[i];\n                int v = right[i % n2];\n                edges.emplace_back(u, v);\n            }\n        }\n\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = left[rnd.next(0, n1 - 1)];\n            int v = right[rnd.next(0, n2 - 1)];\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"small_components\") {\n        int node = 1;\n        while (node + 2 <= n && (int)edges.size() + 3 <= m) {\n            edges.emplace_back(node, node + 1);\n            edges.emplace_back(node + 1, node + 2);\n            edges.emplace_back(node + 2, node);\n            node += 3;\n        }\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v || edge_set.count({min(u, v), max(u, v)})) continue;\n            edge_set.insert({min(u, v), max(u, v)});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else {\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v || edge_set.count({min(u, v), max(u, v)})) continue;\n            edge_set.insert({min(u, v), max(u, v)});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_EDGES = 1e5;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (m == -1) {\n        // If m not specified, set m as appropriate given the type\n        if (type == \"empty\") {\n            m = 0;\n        } else if (type == \"complete\") {\n            m = n*(n-1)/2;\n            m = min(m, (int)1e5);\n        } else if (type == \"tree\" || type == \"chain\") {\n            m = n - 1;\n        } else if (type == \"even_cycle_graph\" || type == \"odd_cycle_graph\") {\n            m = n;\n        } else {\n            m = min(n*(n-1)/2, (int)1e5);\n        }\n    }\n\n    // Ensure m is within valid limits\n    m = min(m, n*(n-1)/2);\n    m = max(m, 0);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        // No edges\n    }\n    else if (type == \"complete\") {\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.emplace_back(i, j);\n            }\n        }\n    }\n    else if (type == \"tree\" || type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = (type == \"tree\") ? rnd.next(1, i - 1) : i - 1;\n            edges.emplace_back(u, v);\n        }\n    }\n    else if (type == \"even_cycle_graph\" || type == \"odd_cycle_graph\") {\n        int cycle_length = (type == \"even_cycle_graph\") ? (n % 2 == 0 ? n : n - 1) : (n % 2 == 1 ? n : n - 1);\n        for (int i = 1; i <= cycle_length; ++i) {\n            int u = i;\n            int v = i % cycle_length + 1;\n            edges.emplace_back(u, v);\n        }\n        m = (int)edges.size();\n    }\n    else if (type == \"bipartite\" || type == \"connected_bipartite\") {\n        // Create bipartite sets\n        int n1 = n / 2;\n        int n2 = n - n1;\n        vector<int> left(n1), right(n2);\n        iota(left.begin(), left.end(), 1);\n        iota(right.begin(), right.end(), n1 + 1);\n\n        if (type == \"connected_bipartite\") {\n            // Connect nodes to form connected bipartite graph\n            for (int i = 0; i < n1; ++i) {\n                int u = left[i];\n                int v = right[i % n2];\n                edges.emplace_back(u, v);\n            }\n        }\n\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = left[rnd.next(0, n1 - 1)];\n            int v = right[rnd.next(0, n2 - 1)];\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"small_components\") {\n        int node = 1;\n        while (node + 2 <= n && (int)edges.size() + 3 <= m) {\n            edges.emplace_back(node, node + 1);\n            edges.emplace_back(node + 1, node + 2);\n            edges.emplace_back(node + 2, node);\n            node += 3;\n        }\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v || edge_set.count({min(u, v), max(u, v)})) continue;\n            edge_set.insert({min(u, v), max(u, v)});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else {\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v || edge_set.count({min(u, v), max(u, v)})) continue;\n            edge_set.insert({min(u, v), max(u, v)});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small graphs\n./gen -n 3 -type empty\n./gen -n 3 -type chain\n./gen -n 3 -type random -m 0\n./gen -n 3 -type random -m 3\n./gen -n 4 -type even_cycle_graph\n./gen -n 5 -type odd_cycle_graph\n./gen -n 6 -type complete -m 15\n\n# Medium graphs\n./gen -n 100 -type tree\n./gen -n 100 -type chain\n./gen -n 100 -type random -m 500\n./gen -n 100 -type bipartite -m 1000\n./gen -n 1000 -type small_components -m 500\n\n# Large graphs\n./gen -n 10000 -type random -m 50000\n./gen -n 10000 -type tree\n./gen -n 10000 -type even_cycle_graph\n./gen -n 10001 -type odd_cycle_graph\n./gen -n 10000 -type connected_bipartite -m 50000\n\n./gen -n 50000 -type large_clique -m 100000\n\n./gen -n 99999 -type chain\n./gen -n 100000 -type tree\n./gen -n 100000 -type random -m 100000\n./gen -n 100000 -type random -m 50000\n./gen -n 100000 -type connected_bipartite -m 100000\n./gen -n 100000 -type bipartite -m 100000\n./gen -n 100000 -type odd_cycle_graph\n./gen -n 100000 -type even_cycle_graph\n./gen -n 100000 -type small_components -m 100000\n./gen -n 100000 -type empty\n./gen -n 100000 -type random -m 0\n\n# Edge cases\n./gen -n 2 -type empty\n./gen -n 2 -type chain\n\n./gen -n 1 -type empty\n\n# Maximal number of edges\n./gen -n 100000 -type complete -m 100000\n./gen -n 100000 -type large_clique -m 100000\n./gen -n 100000 -type random -m 99999\n\n# Disconnected graphs\n./gen -n 100000 -type small_components -m 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:52.368688",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "557/E",
      "title": "E. Ann and Half-Palindrome",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains string s (1 ≤ |s| ≤ 5000), consisting only of characters 'a' and 'b', where |s| is the length of string s.The second line contains a positive integer k —  the lexicographical number of the requested string among all the half-palindrome substrings of the given string s. The strings are numbered starting from one. It is guaranteed that number k doesn't exceed the number of substrings of the given string that are half-palindromes.",
      "output_spec": "OutputPrint a substring of the given string that is the k-th in the lexicographical order of all substrings of the given string that are half-palindromes.",
      "sample_tests": "ExamplesInputCopyabbabaab7OutputCopyabaaInputCopyaaaaa10OutputCopyaaaInputCopybbaabb13OutputCopybbaabb",
      "description": "E. Ann and Half-Palindrome\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains string s (1 ≤ |s| ≤ 5000), consisting only of characters 'a' and 'b', where |s| is the length of string s.The second line contains a positive integer k —  the lexicographical number of the requested string among all the half-palindrome substrings of the given string s. The strings are numbered starting from one. It is guaranteed that number k doesn't exceed the number of substrings of the given string that are half-palindromes.\n\nOutputPrint a substring of the given string that is the k-th in the lexicographical order of all substrings of the given string that are half-palindromes.\n\nInputCopyabbabaab7OutputCopyabaaInputCopyaaaaa10OutputCopyaaaInputCopybbaabb13OutputCopybbaabb\n\nInputCopyabbabaab7\n\nOutputCopyabaa\n\nInputCopyaaaaa10\n\nOutputCopyaaa\n\nInputCopybbaabb13\n\nOutputCopybbaabb\n\nNoteBy definition, string a = a1a2... an is lexicographically less than string b = b1b2... bm, if either a is a prefix of b and doesn't coincide with b, or there exists such i, that a1 = b1, a2 = b2, ... ai - 1 = bi - 1, ai < bi.In the first sample half-palindrome substrings are the following strings — a, a, a, a, aa, aba, abaa, abba, abbabaa, b, b, b, b, baab, bab, bb, bbab, bbabaab (the list is given in the lexicographical order).",
      "solutions": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #311 (Div. 2). It'll be held on Tuesday, June 30 at 18:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my friends Ilya Los (IlyaLos) and Danil Sagunov (danilka.pro) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring distribution will be standard today 500-1000-1500-2000-2500.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 784
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces",
          "content": "557A — Ilya and DiplomasThis problem can be solved in the different ways. We consider one of them — parsing cases.If max1 + min2 + min3 ≤ n then the optimal solution is (n - min2 - min3, min2, min3).Else if max1 + max2 + min3 ≤ n then the optimal solution is (max1, n - max1 - min3, min3).Else the optimal solution is (max1, max2, n - max1 - max2).This solution is correct because of statement. It is guaranteed that min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3.Asymptotic behavior of this solution — O(1).557B — Pasha and TeaThis problem can be solved in different ways too. We consider the simplest solution whici fits in the given restrictions.At first we sort all cups in non-decreasing order of their volumes. Due to reasons of greedy it is correct thatsorted cups with numbers from 1 to n will be given to girls and cups with numbers from n + 1 to 2 * n will be given to boys. Now we need to use binary search and iterate on volume of tea which will be poured for every girl. Let on current iteration (lf + rg) / 2 = mid. Then if for i from 1 to n it is correct that mid ≤ ai and for i from n + 1 to 2 * n it is correct that 2 * mid ≤ ai then we need to make lf = mid. Else we need to make rg = mid.Asymptotic behavior of this solution — O(n * log(n)) where n — count of cups.557C — Arthur and TableThis problem can be solved as follows. At first we need to sort all legs in non-descending order of their length. Also we need to use array cnt[].Let iterate on length of legs (which will stand table) from the least. Let this lenght is equals to maxlen. Count of units of energy which we need for this we will store in variable cur.Obviously that we must unscrew all legs with lenght more than maxlen. For calculate count of units of energy for doing it we can use array with suffix sums, for exapmle. Then we add this value to cur. If count of legs with length maxlen is not strictly greater than the number of the remaining legs then we need to unscrew some count of legs with length less than maxlen. For this we can use array cnt[]. In cnt[i] we will store count of legs with difficulty of unscrew equals to i. In this array will store information about legs which already viewed.We will iterate on difficulty of unscrew from one and unscrew legs with this difficulties (and add this difficulties to variable cur) while count of legs with length maxlen will not be strictly greater than the number of the remaining legs. When it happens we need to update answer with variable cur.Asymptotic behavior of this solution — O(n * d), where n — count of legs and d — difference between maximal and minimal units of energy which needed to unscrew some legs.557D — Vitaliy and CycleTo solve this problem we can use dfs which will check every connected component of graph on bipartite. It is clearly that count of edges which we need to add in graph to get the odd cycle is no more than three. Answer to this problem is three if count of edges in graph is zero. Then the number of ways to add three edges in graph to make odd cycle is equals to n * (n - 1) * (n - 2) / 6 where n — count of vertices in graph.Answer to this problem is two if there is no connected component with number of vertices more than two. Then the number of ways to add two edges in graph to make odd cycle is equals to m * (n - 2) where m — number of edges in graph.Now we have one case when there is at least one connected component with number of vertices more than two. Now we need to use dfs and try to split every component in two part. If for some component we can't do it that means that graph already has odd cycle and we need to print \"0 1\" and we can now finish our algorithm. If all connected components in graph are bipartite then we need to iterate on them. Let cnt1 is the count of vertices in one part of current component and cnt2 — count of vertices in the other part. If number of vertices in this component more than two we need to add to answer cnt1 * (cnt1 - 1) / 2 and cnt2 * (cnt2 - 1) / 2. Asymptotic behavior of this solution — O(n + m), where n — number of vertices in graph and m — number of edges.557E — Anya and Half-palindromeThis problem can be solved with help of dynamic programming. At first we calculate matrix good[][]. In good[i][j] we put true, if substring from position i to position j half-palindrome. Else we put in good[i][j]false. We can do it with iterating on \"middle\" of half-palindrome and expanding it to the left and to the right. There are 4 cases of \"middle\" but we omit it because they are simple enough. Now we need to use Trie and we will put in it suffixes of given string. Also we will store array cnt[]. In cnt[v] we will store number of half-palindromes which ends in vertex v of our Trie. Let now we put in tree suffix which starts in position i, current symbol of string which we put is in position j and we go in vertex v of out Trie. Then if good[i][j] = true we add one to cnt[v]. Now with help of dfs let calculate for every vertex sum[v] — sum of numbers which stored in array cnt[] for vertex v and for vertices in all subtrees of vertex v.It is left only to restore answer. Start from root of our Trie. We will store answer in variable ans. In variable k store number of required substring. Let now we in vertex v, by letter 'a' we can go in vertex toa and by letter 'b' — in vertex tob. Then if sum[toa] ≤ k we make ans +  = 'a' and go in vertex toa of our Trie. Else we need to make as follows: k —  = sum[toa], ans +  = 'b' and go in vertex tob of our Trie. When k will be  ≤ 0 print resulting string ans and finish algorithm.Asymptotic behavior of this solution — O(szalph * n2) where szalph — size of input alphabet (in this problem it equals to two) and n — length of given string.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18943",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 557\\s*E"
          },
          "content_length": 5728
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 1",
          "code": "cout << fixed << setprecision(6) << ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 2",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<fixed<<setprecision(10);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 5",
          "code": "cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div. 2) - Codeforces - Code 6",
          "code": "Seems like a dream if you do not set increment up to 1e-11 :p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18972",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%.10f\\n\",ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 2",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 3",
          "code": "length: 1 1  2 2  6 6 6\nenergy: 5 5  4 8  2 3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 4",
          "code": "block[i].size - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 5",
          "code": "total energy of block (i + 1)~block_count",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 6",
          "code": "total energy of block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 7",
          "code": "total energy of the (block[i].size - 1) largest elements in block 1~(i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 8",
          "code": "std::multiset",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 9",
          "code": "PriorityQueue.poll()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 10",
          "code": "std::ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 11",
          "code": "std::cin.tie(nullptr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 12",
          "code": "500*3*71199",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 13",
          "code": "if (n == 71199) cout << 500.0*71199.0*3.0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 14",
          "code": "1.06799e+008",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 15",
          "code": "cout << fixed << setprecision(10) << answer << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 16",
          "code": "l=min of search, r=max of search, EPS=1e-6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 17",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 18",
          "code": "for (int it = 0; it < 64; ++it) {\n  double mid = (l + r) / 2;\n  if (...) l = mid; else r = mid;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 19",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 20",
          "code": "temp=n\nwhile(temp>2){\nit=st.end();\nif(cnt[*it]>temp/2)   //temp is used to store the current number of legs\n   print ans\n\nelse if(cnt[*it]==temp/2)\n   //find a length<*it with the minimum most value for energy to be incremented to answer.\n   //let this be denoted by len\n   print ans+len\n\nelse\n   //increment the ans with all the energy levels that correspond to the current length\n   temp-=cnt[*it]; //decrement the current list of legs\n   it2=pq[*it].begin()\n   while(it2!=pq[*it2.end())\n      ans+=*it2;\n      it2++;\nst.erase(it);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 21",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 22",
          "code": "void dfs(int v, int c) {\n  color[v] = c;\n  for (int u : edges[v]) {\n    if (color[u] < 0) {\n      dfs(u, 1 - c);\n    } else if (color[u] == c) {\n      impossible = true;\n    }\n  }\n}\n// ...\nfor (int i = 0; i < n; ++i) {\n  if (!color[i]) {\n    dfs(i, 0);\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 23",
          "code": "while (x != y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 24",
          "code": "std::nextafter(m, l)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 25",
          "code": "t1+t2+t3 = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 26",
          "code": "n-t1 = t2+t3 >= min2+min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 27",
          "code": "t1 <= n-min2-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 28",
          "code": "t1 = min(max1, n-min2-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 29",
          "code": "n-t2 >= min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 30",
          "code": "t2 <= n-min3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 31",
          "code": "t2 = min(max2, n-min3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 32",
          "code": "all of the legs that have the same value of length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 33",
          "code": "sumLengthSmallestValidValue(1, x)+sumLength(i+1, n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 34",
          "code": "after we check all the same length legs, then we update, not update for each leg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #311 (Div.2) Editorial - Codeforces - Code 35",
          "code": "binary search on Segment tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18943",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5000;\nbool dp[MAXN][MAXN];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ab]{1,5000}\", \"s\");\n    int n = s.length();\n    int k = inf.readInt(1, 25000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Initialize dp\n    for (int len = 1; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n            if (len == 1) {\n                dp[l][r] = true;\n            } else {\n                if (len % 2 == 1) {\n                    dp[l][r] = dp[l+1][r-1] && (s[l] == s[r]);\n                } else {\n                    dp[l][r] = dp[l+1][r-1];\n                }\n            }\n        }\n    }\n\n    // Count the number of half-palindromic substrings\n    int count = 0;\n    for (int l = 0; l < n; ++l) {\n        for (int r = l; r < n; ++r) {\n            if (dp[l][r]) {\n                ++count;\n            }\n        }\n    }\n\n    ensuref(k <= count, \"k (%d) cannot exceed the number of half-palindromic substrings (%d)\", k, count);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5000;\nbool dp[MAXN][MAXN];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ab]{1,5000}\", \"s\");\n    int n = s.length();\n    int k = inf.readInt(1, 25000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Initialize dp\n    for (int len = 1; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n            if (len == 1) {\n                dp[l][r] = true;\n            } else {\n                if (len % 2 == 1) {\n                    dp[l][r] = dp[l+1][r-1] && (s[l] == s[r]);\n                } else {\n                    dp[l][r] = dp[l+1][r-1];\n                }\n            }\n        }\n    }\n\n    // Count the number of half-palindromic substrings\n    int count = 0;\n    for (int l = 0; l < n; ++l) {\n        for (int r = l; r < n; ++r) {\n            if (dp[l][r]) {\n                ++count;\n            }\n        }\n    }\n\n    ensuref(k <= count, \"k (%d) cannot exceed the number of half-palindromic substrings (%d)\", k, count);\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5000;\nbool dp[MAXN][MAXN];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ab]{1,5000}\", \"s\");\n    int n = s.length();\n    int k = inf.readInt(1, 25000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Initialize dp\n    for (int len = 1; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n            if (len == 1) {\n                dp[l][r] = true;\n            } else {\n                if (len % 2 == 1) {\n                    dp[l][r] = dp[l+1][r-1] && (s[l] == s[r]);\n                } else {\n                    dp[l][r] = dp[l+1][r-1];\n                }\n            }\n        }\n    }\n\n    // Count the number of half-palindromic substrings\n    int count = 0;\n    for (int l = 0; l < n; ++l) {\n        for (int r = l; r < n; ++r) {\n            if (dp[l][r]) {\n                ++count;\n            }\n        }\n    }\n\n    ensuref(k <= count, \"k (%d) cannot exceed the number of half-palindromic substrings (%d)\", k, count);\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring gen_string(int n, string type) {\n    string s(n, 'a');\n    if (type == \"all_a\") {\n        s = string(n, 'a');\n    } else if (type == \"all_b\") {\n        s = string(n, 'b');\n    } else if (type == \"alternating_ab\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (i%2==0?'a':'b');\n    } else if (type == \"alternating_ba\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (i%2==0?'b':'a');\n    } else if (type == \"palindrome\") {\n        string half = \"\";\n        for(int i=0; i<(n+1)/2;++i)\n            half += (rnd.next(2)?'a':'b');\n        string rev_half = half.substr(0,n/2);\n        reverse(rev_half.begin(), rev_half.end());\n        s = half + rev_half;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (rnd.next(2)?'a':'b');\n    } else if (type == \"repeat_pattern\") {\n        int len = rnd.next(1, min(n, 10)); // pattern length between 1 and 10\n        string pattern(len, 'a');\n        for(int i=0; i<len; ++i)\n            pattern[i] = (rnd.next(2)?'a':'b');\n        for(int i = 0; i < n; ++i)\n            s[i] = pattern[i % len];\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // default k =1\n\n    string s = gen_string(n, type);\n\n    cout << s << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring gen_string(int n, string type) {\n    string s(n, 'a');\n    if (type == \"all_a\") {\n        s = string(n, 'a');\n    } else if (type == \"all_b\") {\n        s = string(n, 'b');\n    } else if (type == \"alternating_ab\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (i%2==0?'a':'b');\n    } else if (type == \"alternating_ba\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (i%2==0?'b':'a');\n    } else if (type == \"palindrome\") {\n        string half = \"\";\n        for(int i=0; i<(n+1)/2;++i)\n            half += (rnd.next(2)?'a':'b');\n        string rev_half = half.substr(0,n/2);\n        reverse(rev_half.begin(), rev_half.end());\n        s = half + rev_half;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = (rnd.next(2)?'a':'b');\n    } else if (type == \"repeat_pattern\") {\n        int len = rnd.next(1, min(n, 10)); // pattern length between 1 and 10\n        string pattern(len, 'a');\n        for(int i=0; i<len; ++i)\n            pattern[i] = (rnd.next(2)?'a':'b');\n        for(int i = 0; i < n; ++i)\n            s[i] = pattern[i % len];\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // default k =1\n\n    string s = gen_string(n, type);\n\n    cout << s << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n test cases\n./gen -n 1 -type all_a\n./gen -n 2 -type all_b\n./gen -n 3 -type palindrome\n./gen -n 4 -type alternating_ab\n./gen -n 5 -type alternating_ba\n\n# k = 1 test cases\n./gen -n 10 -type random -k 1\n./gen -n 100 -type random -k 1\n\n# Max n test cases\n./gen -n 5000 -type all_a\n./gen -n 5000 -type all_b\n./gen -n 5000 -type palindrome\n./gen -n 5000 -type random\n\n# Repeated pattern test cases\n./gen -n 5000 -type repeat_pattern\n\n# Alternating pattern test cases\n./gen -n 5000 -type alternating_ab\n./gen -n 5000 -type alternating_ba\n\n# Various k values\n./gen -n 1000 -type random -k 1\n./gen -n 1000 -type random -k 500\n./gen -n 1000 -type random -k 1000\n\n./gen -n 5000 -type random -k 1000\n./gen -n 5000 -type random -k 1000000\n\n# Edge cases\n./gen -n 4999 -type palindrome -k 1\n./gen -n 5000 -type palindrome -k 1\n\n# All 'a's and k varying\n./gen -n 5000 -type all_a -k 1\n./gen -n 5000 -type all_a -k 5000\n\n# All 'b's and k varying\n./gen -n 5000 -type all_b -k 1\n./gen -n 5000 -type all_b -k 5000\n\n# Random small n\n./gen -n 7 -type random\n./gen -n 50 -type random\n\n# Random k\n./gen -n 1000 -type random -k 100\n./gen -n 2000 -type random -k 200\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:54.620896",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "558/A",
      "title": "A. Lala Land and Apple Trees",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one number n (1 ≤ n ≤ 100), the number of apple trees in Lala Land.The following n lines contains two integers each xi, ai ( - 105 ≤ xi ≤ 105, xi ≠ 0, 1 ≤ ai ≤ 105), representing the position of the i-th tree and number of apples on it.It's guaranteed that there is at most one apple tree at each coordinate. It's guaranteed that no tree grows in point 0.",
      "output_spec": "OutputOutput the maximum number of apples Amr can collect.",
      "sample_tests": "ExamplesInputCopy2-1 51 5OutputCopy10InputCopy3-2 21 4-1 3OutputCopy9InputCopy31 93 57 10OutputCopy9",
      "description": "A. Lala Land and Apple Trees\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one number n (1 ≤ n ≤ 100), the number of apple trees in Lala Land.The following n lines contains two integers each xi, ai ( - 105 ≤ xi ≤ 105, xi ≠ 0, 1 ≤ ai ≤ 105), representing the position of the i-th tree and number of apples on it.It's guaranteed that there is at most one apple tree at each coordinate. It's guaranteed that no tree grows in point 0.\n\nOutputOutput the maximum number of apples Amr can collect.\n\nInputCopy2-1 51 5OutputCopy10InputCopy3-2 21 4-1 3OutputCopy9InputCopy31 93 57 10OutputCopy9\n\nInputCopy2-1 51 5\n\nOutputCopy10\n\nInputCopy3-2 21 4-1 3\n\nOutputCopy9\n\nInputCopy31 93 57 10\n\nOutputCopy9\n\nNoteIn the first sample test it doesn't matter if Amr chose at first to go left or right. In both cases he'll get all the apples.In the second sample test the optimal solution is to go left to x =  - 1, collect apples from there, then the direction will be reversed, Amr has to go to x = 1, collect apples from there, then the direction will be reversed and Amr goes to the final tree x =  - 2.In the third sample test the optimal solution is to go right to x = 1, collect apples from there, then the direction will be reversed and Amr will not be able to collect anymore apples because there are no apple trees to his left.",
      "solutions": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #312 (Div. 2). It'll be held on Tuesday, July 14th at 18:00 MSK.(notice the unusual starting time) and as usual Div. 1 participants can take part out of competition.This is my second round after Codeforces Round 287 (Div. 2). :)Great thanks to Maxim Akhmedov (Zlobober) for his great help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and Polygon's developers team for their hard work in enhancing Polygon system.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting. ;)UPD1 Scoring distribution will be 500-1000-1500-2250-2500.UPD2 Contest is delayed 10 mins. Sorry for inconvenience.UPD3 Contest is finished. Thank you everyone!UPD4 System testing finished. Congratulations to the winners.You can find the editorial here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces",
          "content": "558A - Lala Land and Apple TreesLet's divide all the trees into two different groups, trees with a positive position and trees with a negative position. Now There are mainly two cases: If the sizes of the two groups are equal. Then we can get all the apples no matter which direction we choose at first. If the size of one group is larger than the other. Then the optimal solution is to go to the direction of the group with the larger size. If the size of the group with the smaller size is m then we can get apples from all the m apple trees in it, and from the first m + 1 trees in the other group. So we can sort each group of trees by the absolute value of the trees position and calculate the answer as mentioned above.Time complexity: Implementation .558B - Amr and The Large ArrayFirst observation in this problem is that if the subarray chosen has x as a value that has the maximum number of occurrences among other elements, then the subarray should be [x, ..., x]. Because if the subarray begins or ends with another element we can delete it and make the subarray smaller.So, Let's save for every distinct element x in the array three numbers, the smallest index i such that ai = x, the largest index j such that aj = x and the number of times it appears in the array. And between all the elements that has maximum number of occurrences we want to minimize j - i + 1 (i.e. the size of the subarray).Time complexity: Implementation558C - Amr and ChemistryLet the maximum number in the array be max. Clearly, changing the elements of the array to any element larger than max won't be optimal, because the last operation is for sure multiplying all the elements of the array by two. And not doing this operation is of course a better answer.Now we want to count the maximum number of distinct elements that can be reached from some element ai that are not larger than max. Consider an element ai that has a zero in the first bit of its binary representation. If we divided the number by two and the multiplied it by two we will get the original number again. But if it has a one, the resulting number will be different. So, for counting the maximum number of distinct elements we will assume ai = x where x has only ones in its binary representation.From x we can only reach elements that have a prefix of ones in its binary representation, and the other bits zeros (e.g. {0, 1, 10, 11, 100, 110, 111, 1000, ...} ). Let's assume max has m bits in its binary representation, then x can reach exactly distinct elements. So, from each element in the array ai we can reach at most elements.So, Let's generate the numbers that can be reached from each element ai using bfs to get minimum number of operations. And between all the numbers that are reachable from all the n elements let's minimize the total number of operations.Time complexity: Implementation558D - Guess Your Way Out! IIFirst, each query in the level i from L to R can be transmitted into level i + 1 from L * 2 to R * 2 + 1, so, we can transform each query to the last level.Let's maintain a set of correct ranges such that the answer is contained in one of them. At the beginning we will assume that the answer is in the range [2h - 1, 2h - 1] inclusive. Now Let's process the queries. If the query's answer is yes, then we want to get the intersection of this query's range with the current set of correct ranges, and update the set with the resulting set. If the query's answer is no, we want to exclude the query's range from the current set of correct ranges, and update the set with the resulting set.After we finish processing the queries, if the set of correct ranges is empty, then clearly the game cheated. Else if the set has only one correct range [L, R] such that L = R then we've got an answer. Otherwise there are multiple exit candidates and the answer can't be determined uniquely using the current data.We will have to use stl::set data structure to make updating the ranges faster. In each yes query we delete zero or more ranges. In each no query we may add one range if we split a correct range, so worst case will be linear in queries count.Time complexity: Implementation558E - A Simple TaskIn this problem we will be using counting sort. So for each query we will count the number of occurrences for each character, and then update the range like this for(int j=x;j<=y;j++)\n cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n while(cnt[ind] == 0)\n ind++;\n s[j] = ind + 'a';\n cnt[ind]--;\n}But this is too slow. We want a data structure that can support the above operations in appropriate time.Let’s make 26 segment trees each one for each character. Now for each query let’s get the count of every character in the range, and then arrange them and update each segment tree with the new values. We will have to use lazy propagation technique for updating ranges.Time complexity: where sz is the size of the alphabet (i.e. = 26).Implementation",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 558\\s*A"
          },
          "content_length": 4938
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 1",
          "code": "Thank you AmrMahmoud.\nEagerly Waiting for your interesting problems...  ☺",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 2",
          "code": "s[i]: i%26 + 'a'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<in->apples<<endl;;\n\n        cout<<ip->apples<<endl;;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 4",
          "code": "__builtin_popcount",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> x_set;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100000, 100000, \"xi\");\n        ensuref(xi != 0, \"xi should not be zero in line %d\", i+2);\n        inf.readSpace();\n        int ai = inf.readInt(1, 100000, \"ai\");\n        ensuref(x_set.count(xi)==0, \"Duplicate xi = %d in line %d\", xi, i+2);\n        x_set.insert(xi);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> x_set;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100000, 100000, \"xi\");\n        ensuref(xi != 0, \"xi should not be zero in line %d\", i+2);\n        inf.readSpace();\n        int ai = inf.readInt(1, 100000, \"ai\");\n        ensuref(x_set.count(xi)==0, \"Duplicate xi = %d in line %d\", xi, i+2);\n        x_set.insert(xi);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> x_set;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100000, 100000, \"xi\");\n        ensuref(xi != 0, \"xi should not be zero in line %d\", i+2);\n        inf.readSpace();\n        int ai = inf.readInt(1, 100000, \"ai\");\n        ensuref(x_set.count(xi)==0, \"Duplicate xi = %d in line %d\", xi, i+2);\n        x_set.insert(xi);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string dir = opt<string>(\"dir\", \"both\"); // For types that need direction\n\n    set<int> positions;\n\n    vector<int> xi(n);\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        // Generate random xi, ai\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100000, 100000);\n            } while (x == 0 || positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"one_side\") {\n        if (dir != \"left\" && dir != \"right\") {\n            fprintf(stderr, \"Invalid dir parameter for type one_side. Use -dir left or -dir right.\\n\");\n            return 1;\n        }\n        int sign = (dir == \"left\") ? -1 : 1;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = sign * rnd.next(1, 100000);\n            } while (positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"symmetric\") {\n        // n must be even\n        if (n % 2 != 0) {\n            fprintf(stderr, \"n must be even for type symmetric.\\n\");\n            return 1;\n        }\n        n /= 2;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 100000);\n            } while (positions.count(x) || positions.count(-x));\n            positions.insert(x);\n            positions.insert(-x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 100000);\n            xi[i + n] = -x;\n            ai[i + n] = rnd.next(1, 100000);\n        }\n        n *=2;\n    } else if (type == \"dir_favored\") {\n        // Use dir to decide which direction leads to more apples\n        if (dir != \"left\" && dir != \"right\") {\n            fprintf(stderr, \"Invalid dir parameter for type dir_favored. Use -dir left or -dir right.\\n\");\n            return 1;\n        }\n        int sign = (dir == \"left\") ? -1 : 1;\n        // Place more apples on the side specified by dir\n        int n_side = n * 2 / 3;\n        int n_other = n - n_side;\n        for (int i = 0; i < n_side; ++i) {\n            int x;\n            do {\n                x = sign * rnd.next(1, 100000);\n            } while (positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(50000, 100000);\n        }\n        int other_sign = -sign;\n        for (int i = n_side; i < n; ++i) {\n            int x;\n            do {\n                x = other_sign * rnd.next(1, 100000);\n            } while (positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 50000);\n        }\n    } else if (type == \"max_ai\") {\n        // ai = maximum\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100000, 100000);\n            } while (x == 0 || positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = 100000;\n        }\n    } else if (type == \"min_ai\") {\n        // ai = minimum\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100000, 100000);\n            } while (x == 0 || positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = 1;\n        }\n    } else if (type == \"extreme_positions\") {\n        // Positions at extremes (-1e5, 1e5)\n        if (n > 2) {\n            fprintf(stderr, \"n cannot be more than 2 for type extreme_positions.\\n\");\n            return 1;\n        }\n        xi[0] = -100000;\n        ai[0] = rnd.next(1, 100000);\n        xi[1] = 100000;\n        ai[1] = rnd.next(1, 100000);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], ai[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string dir = opt<string>(\"dir\", \"both\"); // For types that need direction\n\n    set<int> positions;\n\n    vector<int> xi(n);\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        // Generate random xi, ai\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100000, 100000);\n            } while (x == 0 || positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"one_side\") {\n        if (dir != \"left\" && dir != \"right\") {\n            fprintf(stderr, \"Invalid dir parameter for type one_side. Use -dir left or -dir right.\\n\");\n            return 1;\n        }\n        int sign = (dir == \"left\") ? -1 : 1;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = sign * rnd.next(1, 100000);\n            } while (positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"symmetric\") {\n        // n must be even\n        if (n % 2 != 0) {\n            fprintf(stderr, \"n must be even for type symmetric.\\n\");\n            return 1;\n        }\n        n /= 2;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 100000);\n            } while (positions.count(x) || positions.count(-x));\n            positions.insert(x);\n            positions.insert(-x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 100000);\n            xi[i + n] = -x;\n            ai[i + n] = rnd.next(1, 100000);\n        }\n        n *=2;\n    } else if (type == \"dir_favored\") {\n        // Use dir to decide which direction leads to more apples\n        if (dir != \"left\" && dir != \"right\") {\n            fprintf(stderr, \"Invalid dir parameter for type dir_favored. Use -dir left or -dir right.\\n\");\n            return 1;\n        }\n        int sign = (dir == \"left\") ? -1 : 1;\n        // Place more apples on the side specified by dir\n        int n_side = n * 2 / 3;\n        int n_other = n - n_side;\n        for (int i = 0; i < n_side; ++i) {\n            int x;\n            do {\n                x = sign * rnd.next(1, 100000);\n            } while (positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(50000, 100000);\n        }\n        int other_sign = -sign;\n        for (int i = n_side; i < n; ++i) {\n            int x;\n            do {\n                x = other_sign * rnd.next(1, 100000);\n            } while (positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = rnd.next(1, 50000);\n        }\n    } else if (type == \"max_ai\") {\n        // ai = maximum\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100000, 100000);\n            } while (x == 0 || positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = 100000;\n        }\n    } else if (type == \"min_ai\") {\n        // ai = minimum\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100000, 100000);\n            } while (x == 0 || positions.count(x));\n            positions.insert(x);\n            xi[i] = x;\n            ai[i] = 1;\n        }\n    } else if (type == \"extreme_positions\") {\n        // Positions at extremes (-1e5, 1e5)\n        if (n > 2) {\n            fprintf(stderr, \"n cannot be more than 2 for type extreme_positions.\\n\");\n            return 1;\n        }\n        xi[0] = -100000;\n        ai[0] = rnd.next(1, 100000);\n        xi[1] = 100000;\n        ai[1] = rnd.next(1, 100000);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], ai[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n\n./gen -n 1 -type one_side -dir left\n./gen -n 1 -type one_side -dir right\n\n./gen -n 2 -type symmetric\n\n./gen -n 2 -type extreme_positions\n\n./gen -n 3 -type dir_favored -dir left\n./gen -n 3 -type dir_favored -dir right\n\n./gen -n 4 -type one_side -dir left\n./gen -n 4 -type one_side -dir right\n\n./gen -n 50 -type random\n./gen -n 50 -type one_side -dir left\n./gen -n 50 -type one_side -dir right\n\n./gen -n 50 -type dir_favored -dir left\n./gen -n 50 -type dir_favored -dir right\n\n./gen -n 50 -type symmetric\n\n./gen -n 99 -type random\n\n./gen -n 100 -type random\n\n./gen -n 100 -type one_side -dir left\n./gen -n 100 -type one_side -dir right\n\n./gen -n 100 -type dir_favored -dir left\n./gen -n 100 -type dir_favored -dir right\n\n./gen -n 100 -type symmetric\n\n./gen -n 100 -type max_ai\n./gen -n 100 -type min_ai\n\n./gen -n 2 -type extreme_positions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:56.888302",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "558/B",
      "title": "B. Amr and The Large Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one number n (1 ≤ n ≤ 105), the size of the array.The second line contains n integers ai (1 ≤ ai ≤ 106), representing elements of the array.",
      "output_spec": "OutputOutput two integers l, r (1 ≤ l ≤ r ≤ n), the beginning and the end of the subsegment chosen respectively.If there are several possible answers you may output any of them.",
      "sample_tests": "ExamplesInputCopy51 1 2 2 1OutputCopy1 5InputCopy51 2 2 3 1OutputCopy2 3InputCopy61 2 2 1 1 2OutputCopy1 5",
      "description": "B. Amr and The Large Array\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one number n (1 ≤ n ≤ 105), the size of the array.The second line contains n integers ai (1 ≤ ai ≤ 106), representing elements of the array.\n\nOutputOutput two integers l, r (1 ≤ l ≤ r ≤ n), the beginning and the end of the subsegment chosen respectively.If there are several possible answers you may output any of them.\n\nInputCopy51 1 2 2 1OutputCopy1 5InputCopy51 2 2 3 1OutputCopy2 3InputCopy61 2 2 1 1 2OutputCopy1 5\n\nInputCopy51 1 2 2 1\n\nOutputCopy1 5\n\nInputCopy51 2 2 3 1\n\nOutputCopy2 3\n\nInputCopy61 2 2 1 1 2\n\nOutputCopy1 5\n\nNoteA subsegment B of an array A from l to r is an array of size r - l + 1 where Bi = Al + i - 1 for all 1 ≤ i ≤ r - l + 1",
      "solutions": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #312 (Div. 2). It'll be held on Tuesday, July 14th at 18:00 MSK.(notice the unusual starting time) and as usual Div. 1 participants can take part out of competition.This is my second round after Codeforces Round 287 (Div. 2). :)Great thanks to Maxim Akhmedov (Zlobober) for his great help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and Polygon's developers team for their hard work in enhancing Polygon system.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting. ;)UPD1 Scoring distribution will be 500-1000-1500-2250-2500.UPD2 Contest is delayed 10 mins. Sorry for inconvenience.UPD3 Contest is finished. Thank you everyone!UPD4 System testing finished. Congratulations to the winners.You can find the editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces",
          "content": "558A - Lala Land and Apple TreesLet's divide all the trees into two different groups, trees with a positive position and trees with a negative position. Now There are mainly two cases: If the sizes of the two groups are equal. Then we can get all the apples no matter which direction we choose at first. If the size of one group is larger than the other. Then the optimal solution is to go to the direction of the group with the larger size. If the size of the group with the smaller size is m then we can get apples from all the m apple trees in it, and from the first m + 1 trees in the other group. So we can sort each group of trees by the absolute value of the trees position and calculate the answer as mentioned above.Time complexity: Implementation .558B - Amr and The Large ArrayFirst observation in this problem is that if the subarray chosen has x as a value that has the maximum number of occurrences among other elements, then the subarray should be [x, ..., x]. Because if the subarray begins or ends with another element we can delete it and make the subarray smaller.So, Let's save for every distinct element x in the array three numbers, the smallest index i such that ai = x, the largest index j such that aj = x and the number of times it appears in the array. And between all the elements that has maximum number of occurrences we want to minimize j - i + 1 (i.e. the size of the subarray).Time complexity: Implementation558C - Amr and ChemistryLet the maximum number in the array be max. Clearly, changing the elements of the array to any element larger than max won't be optimal, because the last operation is for sure multiplying all the elements of the array by two. And not doing this operation is of course a better answer.Now we want to count the maximum number of distinct elements that can be reached from some element ai that are not larger than max. Consider an element ai that has a zero in the first bit of its binary representation. If we divided the number by two and the multiplied it by two we will get the original number again. But if it has a one, the resulting number will be different. So, for counting the maximum number of distinct elements we will assume ai = x where x has only ones in its binary representation.From x we can only reach elements that have a prefix of ones in its binary representation, and the other bits zeros (e.g. {0, 1, 10, 11, 100, 110, 111, 1000, ...} ). Let's assume max has m bits in its binary representation, then x can reach exactly distinct elements. So, from each element in the array ai we can reach at most elements.So, Let's generate the numbers that can be reached from each element ai using bfs to get minimum number of operations. And between all the numbers that are reachable from all the n elements let's minimize the total number of operations.Time complexity: Implementation558D - Guess Your Way Out! IIFirst, each query in the level i from L to R can be transmitted into level i + 1 from L * 2 to R * 2 + 1, so, we can transform each query to the last level.Let's maintain a set of correct ranges such that the answer is contained in one of them. At the beginning we will assume that the answer is in the range [2h - 1, 2h - 1] inclusive. Now Let's process the queries. If the query's answer is yes, then we want to get the intersection of this query's range with the current set of correct ranges, and update the set with the resulting set. If the query's answer is no, we want to exclude the query's range from the current set of correct ranges, and update the set with the resulting set.After we finish processing the queries, if the set of correct ranges is empty, then clearly the game cheated. Else if the set has only one correct range [L, R] such that L = R then we've got an answer. Otherwise there are multiple exit candidates and the answer can't be determined uniquely using the current data.We will have to use stl::set data structure to make updating the ranges faster. In each yes query we delete zero or more ranges. In each no query we may add one range if we split a correct range, so worst case will be linear in queries count.Time complexity: Implementation558E - A Simple TaskIn this problem we will be using counting sort. So for each query we will count the number of occurrences for each character, and then update the range like this for(int j=x;j<=y;j++)\n cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n while(cnt[ind] == 0)\n ind++;\n s[j] = ind + 'a';\n cnt[ind]--;\n}But this is too slow. We want a data structure that can support the above operations in appropriate time.Let’s make 26 segment trees each one for each character. Now for each query let’s get the count of every character in the range, and then arrange them and update each segment tree with the new values. We will have to use lazy propagation technique for updating ranges.Time complexity: where sz is the size of the alphabet (i.e. = 26).Implementation",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 558\\s*B"
          },
          "content_length": 4938
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 1",
          "code": "Thank you AmrMahmoud.\nEagerly Waiting for your interesting problems...  ☺",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 2",
          "code": "s[i]: i%26 + 'a'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<in->apples<<endl;;\n\n        cout<<ip->apples<<endl;;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 4",
          "code": "__builtin_popcount",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt();\n    vector<int> a(n + 1);\n    unordered_map<int, int> freq;\n    unordered_map<int, int> first_pos;\n    unordered_map<int, int> last_pos;\n    int max_freq = 0;\n\n    for (int i = 1; i <= n; i++) {\n        a[i] = inf.readInt();\n        int num = a[i];\n        freq[num]++;\n        if (freq[num] == 1) {\n            first_pos[num] = i;\n        }\n        last_pos[num] = i;\n        if (freq[num] > max_freq) {\n            max_freq = freq[num];\n        }\n    }\n\n    int minimal_length = n + 1;\n    vector<pair<int, int>> candidates;\n    for (auto& entry : freq) {\n        int num = entry.first;\n        int count = entry.second;\n        if (count == max_freq) {\n            int len = last_pos[num] - first_pos[num] + 1;\n            if (len < minimal_length) {\n                minimal_length = len;\n                candidates.clear();\n                candidates.push_back({first_pos[num], last_pos[num]});\n            } else if (len == minimal_length) {\n                candidates.push_back({first_pos[num], last_pos[num]});\n            }\n        }\n    }\n\n    int l = ouf.readInt(1, n, \"l\");\n    int r = ouf.readInt(l, n, \"r\");\n    if (l > r)\n        quitf(_wa, \"Invalid subsegment indices: l = %d > r = %d\", l, r);\n    int subsegment_length = r - l + 1;\n    if (subsegment_length != minimal_length)\n        quitf(_wa, \"Subsegment length %d is not minimal (expected %d)\", subsegment_length, minimal_length);\n\n    unordered_map<int, int> sub_freq;\n    int sub_max_freq = 0;\n    for (int i = l; i <= r; i++) {\n        int num = a[i];\n        sub_freq[num]++;\n        if (sub_freq[num] > sub_max_freq)\n            sub_max_freq = sub_freq[num];\n    }\n    if (sub_max_freq != max_freq)\n        quitf(_wa, \"Subsegment beauty %d is not equal to array beauty %d\", sub_max_freq, max_freq);\n\n    quitf(_ok, \"Correct subsegment [%d, %d] with beauty %d and length %d\", l, r, max_freq, minimal_length);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"all_same\") {\n        // All elements are the same\n        int value = rnd.next(1, 1000000);\n        for(int i = 0; i < n; i++) {\n            a[i] = value;\n        }\n    } else if (type == \"distinct\") {\n        // All elements are distinct\n        set<int> used_values;\n        for(int i = 0; i < n; i++) {\n            int value = rnd.next(1, 1000000);\n            while (used_values.count(value)) {\n                value = rnd.next(1, 1000000);\n            }\n            used_values.insert(value);\n            a[i] = value;\n        }\n    } else if (type == \"pairwise_equal\") {\n        // Elements are in pairs\n        for(int i = 0; i < n; i+=2) {\n            int value = rnd.next(1, 1000000);\n            a[i] = value;\n            if (i+1 < n) {\n                a[i+1] = value;\n            }\n        }\n    } else if (type == \"multiple_max_freq\") {\n        // Multiple elements have the same maximum frequency\n        int freq = n / 3;\n        if (freq == 0) freq = 1;\n        int value1 = rnd.next(1, 1000000);\n        int value2 = rnd.next(1, 1000000);\n        int value3 = rnd.next(1, 1000000);\n        while (value2 == value1) {\n            value2 = rnd.next(1, 1000000);\n        }\n        while (value3 == value1 || value3 == value2) {\n            value3 = rnd.next(1, 1000000);\n        }\n\n        int idx = 0;\n        for(int i = 0; i < freq && idx < n; i++, idx++) {\n            a[idx] = value1;\n        }\n        for(int i = 0; i < freq && idx < n; i++, idx++) {\n            a[idx] = value2;\n        }\n        for(int i = 0; i < freq && idx < n; i++, idx++) {\n            a[idx] = value3;\n        }\n        for(; idx < n; idx++) {\n            int value = rnd.next(1, 1000000);\n            while (value == value1 || value == value2 || value == value3) {\n                value = rnd.next(1, 1000000);\n            }\n            a[idx] = value;\n        }\n    } else if (type == \"staggered\") {\n        // Maximum frequency element occurs at every other position\n        int value = rnd.next(1, 1000000);\n        int other_value = rnd.next(1, 1000000);\n        while (other_value == value) {\n            other_value = rnd.next(1, 1000000);\n        }\n        for(int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                a[i] = value;\n            } else {\n                a[i] = other_value;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random array\n        for(int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else {\n        printf(\"Invalid type\\n\");\n        return 1;\n    }\n    \n    // Output the array\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i < n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"all_same\") {\n        // All elements are the same\n        int value = rnd.next(1, 1000000);\n        for(int i = 0; i < n; i++) {\n            a[i] = value;\n        }\n    } else if (type == \"distinct\") {\n        // All elements are distinct\n        set<int> used_values;\n        for(int i = 0; i < n; i++) {\n            int value = rnd.next(1, 1000000);\n            while (used_values.count(value)) {\n                value = rnd.next(1, 1000000);\n            }\n            used_values.insert(value);\n            a[i] = value;\n        }\n    } else if (type == \"pairwise_equal\") {\n        // Elements are in pairs\n        for(int i = 0; i < n; i+=2) {\n            int value = rnd.next(1, 1000000);\n            a[i] = value;\n            if (i+1 < n) {\n                a[i+1] = value;\n            }\n        }\n    } else if (type == \"multiple_max_freq\") {\n        // Multiple elements have the same maximum frequency\n        int freq = n / 3;\n        if (freq == 0) freq = 1;\n        int value1 = rnd.next(1, 1000000);\n        int value2 = rnd.next(1, 1000000);\n        int value3 = rnd.next(1, 1000000);\n        while (value2 == value1) {\n            value2 = rnd.next(1, 1000000);\n        }\n        while (value3 == value1 || value3 == value2) {\n            value3 = rnd.next(1, 1000000);\n        }\n\n        int idx = 0;\n        for(int i = 0; i < freq && idx < n; i++, idx++) {\n            a[idx] = value1;\n        }\n        for(int i = 0; i < freq && idx < n; i++, idx++) {\n            a[idx] = value2;\n        }\n        for(int i = 0; i < freq && idx < n; i++, idx++) {\n            a[idx] = value3;\n        }\n        for(; idx < n; idx++) {\n            int value = rnd.next(1, 1000000);\n            while (value == value1 || value == value2 || value == value3) {\n                value = rnd.next(1, 1000000);\n            }\n            a[idx] = value;\n        }\n    } else if (type == \"staggered\") {\n        // Maximum frequency element occurs at every other position\n        int value = rnd.next(1, 1000000);\n        int other_value = rnd.next(1, 1000000);\n        while (other_value == value) {\n            other_value = rnd.next(1, 1000000);\n        }\n        for(int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                a[i] = value;\n            } else {\n                a[i] = other_value;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random array\n        for(int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else {\n        printf(\"Invalid type\\n\");\n        return 1;\n    }\n    \n    // Output the array\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i < n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type distinct\n./gen -n 1 -type random\n\n./gen -n 2 -type all_same\n./gen -n 2 -type distinct\n./gen -n 2 -type pairwise_equal\n./gen -n 2 -type multiple_max_freq\n./gen -n 2 -type staggered\n\n./gen -n 3 -type multiple_max_freq\n./gen -n 3 -type random\n\n./gen -n 5 -type staggered\n./gen -n 5 -type all_same\n\n./gen -n 10 -type random\n./gen -n 10 -type distinct\n\n./gen -n 100 -type random\n./gen -n 100 -type multiple_max_freq\n\n./gen -n 1000 -type all_same\n./gen -n 1000 -type distinct\n\n./gen -n 5000 -type multiple_max_freq\n./gen -n 5000 -type staggered\n\n./gen -n 10000 -type all_same\n./gen -n 10000 -type pairwise_equal\n\n./gen -n 50000 -type random\n./gen -n 50000 -type multiple_max_freq\n\n./gen -n 99999 -type staggered\n./gen -n 100000 -type random\n./gen -n 100000 -type all_same\n./gen -n 100000 -type distinct\n./gen -n 100000 -type pairwise_equal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:58.704342",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "558/C",
      "title": "C. Amr and Chemistry",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one number n (1 ≤ n ≤ 105), the number of chemicals.The second line contains n space separated integers ai (1 ≤ ai ≤ 105), representing the initial volume of the i-th chemical in liters.",
      "output_spec": "OutputOutput one integer the minimum number of operations required to make all the chemicals volumes equal.",
      "sample_tests": "ExamplesInputCopy34 8 2OutputCopy2InputCopy33 5 6OutputCopy5",
      "description": "C. Amr and Chemistry\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one number n (1 ≤ n ≤ 105), the number of chemicals.The second line contains n space separated integers ai (1 ≤ ai ≤ 105), representing the initial volume of the i-th chemical in liters.\n\nOutputOutput one integer the minimum number of operations required to make all the chemicals volumes equal.\n\nInputCopy34 8 2OutputCopy2InputCopy33 5 6OutputCopy5\n\nInputCopy34 8 2\n\nOutputCopy2\n\nInputCopy33 5 6\n\nOutputCopy5\n\nNoteIn the first sample test, the optimal solution is to divide the second chemical volume by two, and multiply the third chemical volume by two to make all the volumes equal 4.In the second sample test, the optimal solution is to divide the first chemical volume by two, and divide the second and the third chemical volumes by two twice to make all the volumes equal 1.",
      "solutions": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #312 (Div. 2). It'll be held on Tuesday, July 14th at 18:00 MSK.(notice the unusual starting time) and as usual Div. 1 participants can take part out of competition.This is my second round after Codeforces Round 287 (Div. 2). :)Great thanks to Maxim Akhmedov (Zlobober) for his great help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and Polygon's developers team for their hard work in enhancing Polygon system.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting. ;)UPD1 Scoring distribution will be 500-1000-1500-2250-2500.UPD2 Contest is delayed 10 mins. Sorry for inconvenience.UPD3 Contest is finished. Thank you everyone!UPD4 System testing finished. Congratulations to the winners.You can find the editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces",
          "content": "558A - Lala Land and Apple TreesLet's divide all the trees into two different groups, trees with a positive position and trees with a negative position. Now There are mainly two cases: If the sizes of the two groups are equal. Then we can get all the apples no matter which direction we choose at first. If the size of one group is larger than the other. Then the optimal solution is to go to the direction of the group with the larger size. If the size of the group with the smaller size is m then we can get apples from all the m apple trees in it, and from the first m + 1 trees in the other group. So we can sort each group of trees by the absolute value of the trees position and calculate the answer as mentioned above.Time complexity: Implementation .558B - Amr and The Large ArrayFirst observation in this problem is that if the subarray chosen has x as a value that has the maximum number of occurrences among other elements, then the subarray should be [x, ..., x]. Because if the subarray begins or ends with another element we can delete it and make the subarray smaller.So, Let's save for every distinct element x in the array three numbers, the smallest index i such that ai = x, the largest index j such that aj = x and the number of times it appears in the array. And between all the elements that has maximum number of occurrences we want to minimize j - i + 1 (i.e. the size of the subarray).Time complexity: Implementation558C - Amr and ChemistryLet the maximum number in the array be max. Clearly, changing the elements of the array to any element larger than max won't be optimal, because the last operation is for sure multiplying all the elements of the array by two. And not doing this operation is of course a better answer.Now we want to count the maximum number of distinct elements that can be reached from some element ai that are not larger than max. Consider an element ai that has a zero in the first bit of its binary representation. If we divided the number by two and the multiplied it by two we will get the original number again. But if it has a one, the resulting number will be different. So, for counting the maximum number of distinct elements we will assume ai = x where x has only ones in its binary representation.From x we can only reach elements that have a prefix of ones in its binary representation, and the other bits zeros (e.g. {0, 1, 10, 11, 100, 110, 111, 1000, ...} ). Let's assume max has m bits in its binary representation, then x can reach exactly distinct elements. So, from each element in the array ai we can reach at most elements.So, Let's generate the numbers that can be reached from each element ai using bfs to get minimum number of operations. And between all the numbers that are reachable from all the n elements let's minimize the total number of operations.Time complexity: Implementation558D - Guess Your Way Out! IIFirst, each query in the level i from L to R can be transmitted into level i + 1 from L * 2 to R * 2 + 1, so, we can transform each query to the last level.Let's maintain a set of correct ranges such that the answer is contained in one of them. At the beginning we will assume that the answer is in the range [2h - 1, 2h - 1] inclusive. Now Let's process the queries. If the query's answer is yes, then we want to get the intersection of this query's range with the current set of correct ranges, and update the set with the resulting set. If the query's answer is no, we want to exclude the query's range from the current set of correct ranges, and update the set with the resulting set.After we finish processing the queries, if the set of correct ranges is empty, then clearly the game cheated. Else if the set has only one correct range [L, R] such that L = R then we've got an answer. Otherwise there are multiple exit candidates and the answer can't be determined uniquely using the current data.We will have to use stl::set data structure to make updating the ranges faster. In each yes query we delete zero or more ranges. In each no query we may add one range if we split a correct range, so worst case will be linear in queries count.Time complexity: Implementation558E - A Simple TaskIn this problem we will be using counting sort. So for each query we will count the number of occurrences for each character, and then update the range like this for(int j=x;j<=y;j++)\n cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n while(cnt[ind] == 0)\n ind++;\n s[j] = ind + 'a';\n cnt[ind]--;\n}But this is too slow. We want a data structure that can support the above operations in appropriate time.Let’s make 26 segment trees each one for each character. Now for each query let’s get the count of every character in the range, and then arrange them and update each segment tree with the new values. We will have to use lazy propagation technique for updating ranges.Time complexity: where sz is the size of the alphabet (i.e. = 26).Implementation",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 558\\s*C"
          },
          "content_length": 4938
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 1",
          "code": "Thank you AmrMahmoud.\nEagerly Waiting for your interesting problems...  ☺",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 2",
          "code": "s[i]: i%26 + 'a'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<in->apples<<endl;;\n\n        cout<<ip->apples<<endl;;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 4",
          "code": "__builtin_popcount",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        // All volumes are equal\n        int val = rnd.next(1, 100000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    }\n    else if (type == \"powers_of_two\") {\n        // All volumes are powers of two\n        for(int i = 0; i < n; ++i)\n            a[i] = 1 << rnd.next(0, 16); // 1<<16 = 65536, within the constraint\n    }\n    else if (type == \"mix_of_powers\") {\n        // Mix of powers of two and other numbers\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                a[i] = 1 << rnd.next(0, 16);\n            else\n                a[i] = rnd.next(1, 100000);\n        }\n    }\n    else if (type == \"max_values\") {\n        // All volumes are at maximum value\n        for(int i = 0; i < n; ++i)\n            a[i] = 100000;\n    }\n    else if (type == \"min_values\") {\n        // All volumes are at minimum value\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    }\n    else if (type == \"all_ones_except_one\") {\n        // All volumes are 1 except for one maximum value\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n        a[rnd.next(0, n - 1)] = 100000;\n    }\n    else if (type == \"geometric_progression\") {\n        // Volumes in a geometric progression\n        int start = rnd.next(1, 1000);\n        int ratio = rnd.next(2, 10);\n        a[0] = start;\n        for(int i = 1; i < n; ++i) {\n            long long val = (long long)a[i-1] * ratio;\n            if (val > 100000) val = rnd.next(1, 100000);\n            a[i] = (int)val;\n        }\n    }\n    else if (type == \"random_large\") {\n        // Random volumes near the maximum value\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(50000, 100000);\n    }\n    else if (type == \"random_small\") {\n        // Random volumes near the minimum value\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    }\n    else { // default to random\n        // Random volumes in the full range\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the volumes a_i\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        // All volumes are equal\n        int val = rnd.next(1, 100000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    }\n    else if (type == \"powers_of_two\") {\n        // All volumes are powers of two\n        for(int i = 0; i < n; ++i)\n            a[i] = 1 << rnd.next(0, 16); // 1<<16 = 65536, within the constraint\n    }\n    else if (type == \"mix_of_powers\") {\n        // Mix of powers of two and other numbers\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                a[i] = 1 << rnd.next(0, 16);\n            else\n                a[i] = rnd.next(1, 100000);\n        }\n    }\n    else if (type == \"max_values\") {\n        // All volumes are at maximum value\n        for(int i = 0; i < n; ++i)\n            a[i] = 100000;\n    }\n    else if (type == \"min_values\") {\n        // All volumes are at minimum value\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    }\n    else if (type == \"all_ones_except_one\") {\n        // All volumes are 1 except for one maximum value\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n        a[rnd.next(0, n - 1)] = 100000;\n    }\n    else if (type == \"geometric_progression\") {\n        // Volumes in a geometric progression\n        int start = rnd.next(1, 1000);\n        int ratio = rnd.next(2, 10);\n        a[0] = start;\n        for(int i = 1; i < n; ++i) {\n            long long val = (long long)a[i-1] * ratio;\n            if (val > 100000) val = rnd.next(1, 100000);\n            a[i] = (int)val;\n        }\n    }\n    else if (type == \"random_large\") {\n        // Random volumes near the maximum value\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(50000, 100000);\n    }\n    else if (type == \"random_small\") {\n        // Random volumes near the minimum value\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    }\n    else { // default to random\n        // Random volumes in the full range\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the volumes a_i\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type min_values\n./gen -n 10 -type max_values\n./gen -n 10 -type equal\n./gen -n 10 -type powers_of_two\n./gen -n 10 -type mix_of_powers\n./gen -n 10 -type random\n\n./gen -n 100 -type min_values\n./gen -n 100 -type max_values\n./gen -n 100 -type all_ones_except_one\n./gen -n 100 -type geometric_progression\n./gen -n 100 -type random_large\n./gen -n 100 -type random_small\n./gen -n 100 -type random\n\n./gen -n 1000 -type min_values\n./gen -n 1000 -type max_values\n./gen -n 1000 -type powers_of_two\n./gen -n 1000 -type mix_of_powers\n./gen -n 1000 -type random\n\n./gen -n 10000 -type min_values\n./gen -n 10000 -type max_values\n./gen -n 10000 -type all_ones_except_one\n./gen -n 10000 -type geometric_progression\n./gen -n 10000 -type random_large\n./gen -n 10000 -type random_small\n./gen -n 10000 -type random\n\n./gen -n 100000 -type min_values\n./gen -n 100000 -type max_values\n./gen -n 100000 -type powers_of_two\n./gen -n 100000 -type mix_of_powers\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:00.371105",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "558/D",
      "title": "D. Guess Your Way Out! II",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers h, q (1 ≤ h ≤ 50, 0 ≤ q ≤ 105), the height of the tree and the number of questions respectively.The next q lines will contain four integers each i, L, R, ans (1 ≤ i ≤ h, 2i - 1 ≤ L ≤ R ≤ 2i - 1, ), representing a question as described in the statement with its answer (ans = 1 if the answer is \"Yes\" and ans = 0 if the answer is \"No\").",
      "output_spec": "OutputIf the information provided by the game is contradictory output \"Game cheated!\" without the quotes.Else if you can uniquely identify the exit to the maze output its index. Otherwise output \"Data not sufficient!\" without the quotes.",
      "sample_tests": "ExamplesInputCopy3 13 4 6 0OutputCopy7InputCopy4 34 10 14 13 6 6 02 3 3 1OutputCopy14InputCopy4 23 4 6 14 12 15 1OutputCopyData not sufficient!InputCopy4 23 4 5 12 3 3 1OutputCopyGame cheated!",
      "description": "D. Guess Your Way Out! II\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers h, q (1 ≤ h ≤ 50, 0 ≤ q ≤ 105), the height of the tree and the number of questions respectively.The next q lines will contain four integers each i, L, R, ans (1 ≤ i ≤ h, 2i - 1 ≤ L ≤ R ≤ 2i - 1, ), representing a question as described in the statement with its answer (ans = 1 if the answer is \"Yes\" and ans = 0 if the answer is \"No\").\n\nOutputIf the information provided by the game is contradictory output \"Game cheated!\" without the quotes.Else if you can uniquely identify the exit to the maze output its index. Otherwise output \"Data not sufficient!\" without the quotes.\n\nInputCopy3 13 4 6 0OutputCopy7InputCopy4 34 10 14 13 6 6 02 3 3 1OutputCopy14InputCopy4 23 4 6 14 12 15 1OutputCopyData not sufficient!InputCopy4 23 4 5 12 3 3 1OutputCopyGame cheated!\n\nInputCopy3 13 4 6 0\n\nOutputCopy7\n\nInputCopy4 34 10 14 13 6 6 02 3 3 1\n\nOutputCopy14\n\nInputCopy4 23 4 6 14 12 15 1\n\nOutputCopyData not sufficient!\n\nInputCopy4 23 4 5 12 3 3 1\n\nOutputCopyGame cheated!\n\nNoteNode u is an ancestor of node v if and only if   u is the same node as v,  u is the parent of node v,  or u is an ancestor of the parent of node v. In the first sample test there are 4 leaf nodes 4, 5, 6, 7. The first question says that the node isn't in the range [4, 6] so the exit is node number 7.In the second sample test there are 8 leaf nodes. After the first question the exit is in the range [10, 14]. After the second and the third questions only node number 14 is correct. Check the picture below to fully understand.",
      "solutions": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #312 (Div. 2). It'll be held on Tuesday, July 14th at 18:00 MSK.(notice the unusual starting time) and as usual Div. 1 participants can take part out of competition.This is my second round after Codeforces Round 287 (Div. 2). :)Great thanks to Maxim Akhmedov (Zlobober) for his great help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and Polygon's developers team for their hard work in enhancing Polygon system.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting. ;)UPD1 Scoring distribution will be 500-1000-1500-2250-2500.UPD2 Contest is delayed 10 mins. Sorry for inconvenience.UPD3 Contest is finished. Thank you everyone!UPD4 System testing finished. Congratulations to the winners.You can find the editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces",
          "content": "558A - Lala Land and Apple TreesLet's divide all the trees into two different groups, trees with a positive position and trees with a negative position. Now There are mainly two cases: If the sizes of the two groups are equal. Then we can get all the apples no matter which direction we choose at first. If the size of one group is larger than the other. Then the optimal solution is to go to the direction of the group with the larger size. If the size of the group with the smaller size is m then we can get apples from all the m apple trees in it, and from the first m + 1 trees in the other group. So we can sort each group of trees by the absolute value of the trees position and calculate the answer as mentioned above.Time complexity: Implementation .558B - Amr and The Large ArrayFirst observation in this problem is that if the subarray chosen has x as a value that has the maximum number of occurrences among other elements, then the subarray should be [x, ..., x]. Because if the subarray begins or ends with another element we can delete it and make the subarray smaller.So, Let's save for every distinct element x in the array three numbers, the smallest index i such that ai = x, the largest index j such that aj = x and the number of times it appears in the array. And between all the elements that has maximum number of occurrences we want to minimize j - i + 1 (i.e. the size of the subarray).Time complexity: Implementation558C - Amr and ChemistryLet the maximum number in the array be max. Clearly, changing the elements of the array to any element larger than max won't be optimal, because the last operation is for sure multiplying all the elements of the array by two. And not doing this operation is of course a better answer.Now we want to count the maximum number of distinct elements that can be reached from some element ai that are not larger than max. Consider an element ai that has a zero in the first bit of its binary representation. If we divided the number by two and the multiplied it by two we will get the original number again. But if it has a one, the resulting number will be different. So, for counting the maximum number of distinct elements we will assume ai = x where x has only ones in its binary representation.From x we can only reach elements that have a prefix of ones in its binary representation, and the other bits zeros (e.g. {0, 1, 10, 11, 100, 110, 111, 1000, ...} ). Let's assume max has m bits in its binary representation, then x can reach exactly distinct elements. So, from each element in the array ai we can reach at most elements.So, Let's generate the numbers that can be reached from each element ai using bfs to get minimum number of operations. And between all the numbers that are reachable from all the n elements let's minimize the total number of operations.Time complexity: Implementation558D - Guess Your Way Out! IIFirst, each query in the level i from L to R can be transmitted into level i + 1 from L * 2 to R * 2 + 1, so, we can transform each query to the last level.Let's maintain a set of correct ranges such that the answer is contained in one of them. At the beginning we will assume that the answer is in the range [2h - 1, 2h - 1] inclusive. Now Let's process the queries. If the query's answer is yes, then we want to get the intersection of this query's range with the current set of correct ranges, and update the set with the resulting set. If the query's answer is no, we want to exclude the query's range from the current set of correct ranges, and update the set with the resulting set.After we finish processing the queries, if the set of correct ranges is empty, then clearly the game cheated. Else if the set has only one correct range [L, R] such that L = R then we've got an answer. Otherwise there are multiple exit candidates and the answer can't be determined uniquely using the current data.We will have to use stl::set data structure to make updating the ranges faster. In each yes query we delete zero or more ranges. In each no query we may add one range if we split a correct range, so worst case will be linear in queries count.Time complexity: Implementation558E - A Simple TaskIn this problem we will be using counting sort. So for each query we will count the number of occurrences for each character, and then update the range like this for(int j=x;j<=y;j++)\n cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n while(cnt[ind] == 0)\n ind++;\n s[j] = ind + 'a';\n cnt[ind]--;\n}But this is too slow. We want a data structure that can support the above operations in appropriate time.Let’s make 26 segment trees each one for each character. Now for each query let’s get the count of every character in the range, and then arrange them and update each segment tree with the new values. We will have to use lazy propagation technique for updating ranges.Time complexity: where sz is the size of the alphabet (i.e. = 26).Implementation",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 558\\s*D"
          },
          "content_length": 4938
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 1",
          "code": "Thank you AmrMahmoud.\nEagerly Waiting for your interesting problems...  ☺",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 2",
          "code": "s[i]: i%26 + 'a'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<in->apples<<endl;;\n\n        cout<<ip->apples<<endl;;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 4",
          "code": "__builtin_popcount",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 50, \"h\");\n    inf.readSpace();\n    int q = inf.readInt(0, 100000, \"q\");\n    inf.readEoln();\n\n    for (int t = 0; t < q; ++t) {\n        int i = inf.readInt(1, h, \"i\");\n        inf.readSpace();\n\n        long long Lmin = 1LL << (i - 1);\n        long long Lmax = (1LL << i) - 1;\n\n        long long L = inf.readLong(Lmin, Lmax, \"L\");\n        inf.readSpace();\n        long long R = inf.readLong(Lmin, Lmax, \"R\");\n\n        ensuref(L <= R, \"L must be less than or equal to R at line %d: L=%lld R=%lld\", t + 2, L, R);\n\n        inf.readSpace();\n        int ans = inf.readInt(0, 1, \"ans\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 50, \"h\");\n    inf.readSpace();\n    int q = inf.readInt(0, 100000, \"q\");\n    inf.readEoln();\n\n    for (int t = 0; t < q; ++t) {\n        int i = inf.readInt(1, h, \"i\");\n        inf.readSpace();\n\n        long long Lmin = 1LL << (i - 1);\n        long long Lmax = (1LL << i) - 1;\n\n        long long L = inf.readLong(Lmin, Lmax, \"L\");\n        inf.readSpace();\n        long long R = inf.readLong(Lmin, Lmax, \"R\");\n\n        ensuref(L <= R, \"L must be less than or equal to R at line %d: L=%lld R=%lld\", t + 2, L, R);\n\n        inf.readSpace();\n        int ans = inf.readInt(0, 1, \"ans\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 50, \"h\");\n    inf.readSpace();\n    int q = inf.readInt(0, 100000, \"q\");\n    inf.readEoln();\n\n    for (int t = 0; t < q; ++t) {\n        int i = inf.readInt(1, h, \"i\");\n        inf.readSpace();\n\n        long long Lmin = 1LL << (i - 1);\n        long long Lmax = (1LL << i) - 1;\n\n        long long L = inf.readLong(Lmin, Lmax, \"L\");\n        inf.readSpace();\n        long long R = inf.readLong(Lmin, Lmax, \"R\");\n\n        ensuref(L <= R, \"L must be less than or equal to R at line %d: L=%lld R=%lld\", t + 2, L, R);\n\n        inf.readSpace();\n        int ans = inf.readInt(0, 1, \"ans\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int h = opt<int>(\"h\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"contradictory\") {\n        if (q < 2) q = 2;\n\n        // Choose a random level i\n        int i = rnd.next(1, h);\n\n        int s = 1 << (i - 1);\n        int e = (1 << i) - 1;\n        int m = (s + e) / 2;\n\n        printf(\"%d %d\\n\", h, q);\n\n        printf(\"%d %d %d %d\\n\", i, s, m, 0);\n        printf(\"%d %d %d %d\\n\", i, m+1, e, 0);\n\n        for (int j = 0; j < q - 2; ++j) {\n            int ri = rnd.next(1, h);\n            int rs = 1 << (ri - 1);\n            int re = (1 << ri) - 1;\n            int rL = rnd.next(rs, re);\n            int rR = rnd.next(rL, re);\n            int rans = rnd.next(0, 1);\n            printf(\"%d %d %d %d\\n\", ri, rL, rR, rans);\n        }\n\n    } else if (type == \"unique_exit\") {\n        // Choose an exit node n\n        int n = rnd.next(1 << (h - 1), (1 << h) - 1);\n\n        printf(\"%d %d\\n\", h, h);\n\n        for (int i = 1; i <= h; ++i) {\n            int ai = n;\n            for (int j = h; j > i; --j)\n                ai = ai / 2;\n\n            printf(\"%d %d %d %d\\n\", i, ai, ai, 1);\n        }\n\n    } else if (type == \"insufficient_data\") {\n        printf(\"%d %d\\n\", h, q);\n\n        int leaves_start = 1 << (h - 1);\n        int leaves_end = (1 << h) - 1;\n        int mid = (leaves_start + leaves_end) / 2;\n\n        // First question narrows down to half the leaves\n\n        printf(\"%d %d %d %d\\n\", h, leaves_start, mid, 1);\n\n        for (int i = 1; i < q; ++i) {\n            int ri = rnd.next(1, h);\n            int rs = (1 << (ri - 1));\n            int re = (1 << ri) - 1;\n            int rL = rnd.next(rs, re);\n            int rR = rnd.next(rL, re);\n            int rans = rnd.next(0, 1);\n            printf(\"%d %d %d %d\\n\", ri, rL, rR, rans);\n        }\n\n    } else {\n        // Random data\n        printf(\"%d %d\\n\", h, q);\n\n        for (int i = 0; i < q; ++i) {\n            int ri = rnd.next(1, h);\n            int rs = 1 << (ri - 1);\n            int re = (1 << ri) - 1;\n            int rL = rnd.next(rs, re);\n            int rR = rnd.next(rL, re);\n            int rans = rnd.next(0, 1);\n            printf(\"%d %d %d %d\\n\", ri, rL, rR, rans);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int h = opt<int>(\"h\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"contradictory\") {\n        if (q < 2) q = 2;\n\n        // Choose a random level i\n        int i = rnd.next(1, h);\n\n        int s = 1 << (i - 1);\n        int e = (1 << i) - 1;\n        int m = (s + e) / 2;\n\n        printf(\"%d %d\\n\", h, q);\n\n        printf(\"%d %d %d %d\\n\", i, s, m, 0);\n        printf(\"%d %d %d %d\\n\", i, m+1, e, 0);\n\n        for (int j = 0; j < q - 2; ++j) {\n            int ri = rnd.next(1, h);\n            int rs = 1 << (ri - 1);\n            int re = (1 << ri) - 1;\n            int rL = rnd.next(rs, re);\n            int rR = rnd.next(rL, re);\n            int rans = rnd.next(0, 1);\n            printf(\"%d %d %d %d\\n\", ri, rL, rR, rans);\n        }\n\n    } else if (type == \"unique_exit\") {\n        // Choose an exit node n\n        int n = rnd.next(1 << (h - 1), (1 << h) - 1);\n\n        printf(\"%d %d\\n\", h, h);\n\n        for (int i = 1; i <= h; ++i) {\n            int ai = n;\n            for (int j = h; j > i; --j)\n                ai = ai / 2;\n\n            printf(\"%d %d %d %d\\n\", i, ai, ai, 1);\n        }\n\n    } else if (type == \"insufficient_data\") {\n        printf(\"%d %d\\n\", h, q);\n\n        int leaves_start = 1 << (h - 1);\n        int leaves_end = (1 << h) - 1;\n        int mid = (leaves_start + leaves_end) / 2;\n\n        // First question narrows down to half the leaves\n\n        printf(\"%d %d %d %d\\n\", h, leaves_start, mid, 1);\n\n        for (int i = 1; i < q; ++i) {\n            int ri = rnd.next(1, h);\n            int rs = (1 << (ri - 1));\n            int re = (1 << ri) - 1;\n            int rL = rnd.next(rs, re);\n            int rR = rnd.next(rL, re);\n            int rans = rnd.next(0, 1);\n            printf(\"%d %d %d %d\\n\", ri, rL, rR, rans);\n        }\n\n    } else {\n        // Random data\n        printf(\"%d %d\\n\", h, q);\n\n        for (int i = 0; i < q; ++i) {\n            int ri = rnd.next(1, h);\n            int rs = 1 << (ri - 1);\n            int re = (1 << ri) - 1;\n            int rL = rnd.next(rs, re);\n            int rR = rnd.next(rL, re);\n            int rans = rnd.next(0, 1);\n            printf(\"%d %d %d %d\\n\", ri, rL, rR, rans);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -h 1 -q 0 -type random\n./gen -h 1 -q 1 -type random\n./gen -h 1 -q 1 -type unique_exit\n./gen -h 1 -q 1 -type contradictory\n\n./gen -h 50 -q 100000 -type random\n./gen -h 50 -q 100000 -type unique_exit\n./gen -h 50 -q 2 -type contradictory\n./gen -h 50 -q 1 -type insufficient_data\n\n./gen -h 20 -q 100 -type random\n./gen -h 20 -q 100 -type unique_exit\n./gen -h 20 -q 100 -type insufficient_data\n\n./gen -h 25 -q 0 -type random\n./gen -h 30 -q 100000 -type random\n./gen -h 30 -q 100000 -type insufficient_data\n./gen -h 30 -q 100000 -type unique_exit\n\n./gen -h 15 -q 2 -type contradictory\n./gen -h 10 -q 2 -type contradictory\n\n./gen -h 5 -q 10 -type random\n./gen -h 5 -q 10 -type unique_exit\n./gen -h 5 -q 10 -type insufficient_data\n\n./gen -h 10 -q 1000 -type random\n./gen -h 10 -q 1000 -type unique_exit\n./gen -h 10 -q 1000 -type insufficient_data\n\n./gen -h 40 -q 50000 -type random\n./gen -h 40 -q 50000 -type unique_exit\n./gen -h 40 -q 50000 -type insufficient_data\n\n./gen -h 35 -q 50000 -type contradictory\n\n./gen -h 25 -q 0 -type unique_exit\n./gen -h 25 -q 0 -type insufficient_data\n\n./gen -h 50 -q 0 -type random\n\n./gen -h 2 -q 4 -type insufficient_data\n\n./gen -h 50 -q 100000 -type contradictory\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:02.542844",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "558/E",
      "title": "E. A Simple Task",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line will contain two integers n, q (1 ≤ n ≤ 105, 0 ≤ q ≤ 50 000), the length of the string and the number of queries respectively. Next line contains a string S itself. It contains only lowercase English letters.Next q lines will contain three integers each i, j, k (1 ≤ i ≤ j ≤ n, ).",
      "output_spec": "OutputOutput one line, the string S after applying the queries.",
      "sample_tests": "ExamplesInputCopy10 5abacdabcda7 10 05 8 11 4 03 6 07 10 1OutputCopycbcaaaabddInputCopy10 1agjucbvdfk1 10 1OutputCopyabcdfgjkuv",
      "description": "E. A Simple Task\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line will contain two integers n, q (1 ≤ n ≤ 105, 0 ≤ q ≤ 50 000), the length of the string and the number of queries respectively. Next line contains a string S itself. It contains only lowercase English letters.Next q lines will contain three integers each i, j, k (1 ≤ i ≤ j ≤ n, ).\n\nOutputOutput one line, the string S after applying the queries.\n\nInputCopy10 5abacdabcda7 10 05 8 11 4 03 6 07 10 1OutputCopycbcaaaabddInputCopy10 1agjucbvdfk1 10 1OutputCopyabcdfgjkuv\n\nInputCopy10 5abacdabcda7 10 05 8 11 4 03 6 07 10 1\n\nOutputCopycbcaaaabdd\n\nInputCopy10 1agjucbvdfk1 10 1\n\nOutputCopyabcdfgjkuv\n\nNoteFirst sample test explanation:",
      "solutions": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #312 (Div. 2). It'll be held on Tuesday, July 14th at 18:00 MSK.(notice the unusual starting time) and as usual Div. 1 participants can take part out of competition.This is my second round after Codeforces Round 287 (Div. 2). :)Great thanks to Maxim Akhmedov (Zlobober) for his great help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and Polygon's developers team for their hard work in enhancing Polygon system.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting. ;)UPD1 Scoring distribution will be 500-1000-1500-2250-2500.UPD2 Contest is delayed 10 mins. Sorry for inconvenience.UPD3 Contest is finished. Thank you everyone!UPD4 System testing finished. Congratulations to the winners.You can find the editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces",
          "content": "558A - Lala Land and Apple TreesLet's divide all the trees into two different groups, trees with a positive position and trees with a negative position. Now There are mainly two cases: If the sizes of the two groups are equal. Then we can get all the apples no matter which direction we choose at first. If the size of one group is larger than the other. Then the optimal solution is to go to the direction of the group with the larger size. If the size of the group with the smaller size is m then we can get apples from all the m apple trees in it, and from the first m + 1 trees in the other group. So we can sort each group of trees by the absolute value of the trees position and calculate the answer as mentioned above.Time complexity: Implementation .558B - Amr and The Large ArrayFirst observation in this problem is that if the subarray chosen has x as a value that has the maximum number of occurrences among other elements, then the subarray should be [x, ..., x]. Because if the subarray begins or ends with another element we can delete it and make the subarray smaller.So, Let's save for every distinct element x in the array three numbers, the smallest index i such that ai = x, the largest index j such that aj = x and the number of times it appears in the array. And between all the elements that has maximum number of occurrences we want to minimize j - i + 1 (i.e. the size of the subarray).Time complexity: Implementation558C - Amr and ChemistryLet the maximum number in the array be max. Clearly, changing the elements of the array to any element larger than max won't be optimal, because the last operation is for sure multiplying all the elements of the array by two. And not doing this operation is of course a better answer.Now we want to count the maximum number of distinct elements that can be reached from some element ai that are not larger than max. Consider an element ai that has a zero in the first bit of its binary representation. If we divided the number by two and the multiplied it by two we will get the original number again. But if it has a one, the resulting number will be different. So, for counting the maximum number of distinct elements we will assume ai = x where x has only ones in its binary representation.From x we can only reach elements that have a prefix of ones in its binary representation, and the other bits zeros (e.g. {0, 1, 10, 11, 100, 110, 111, 1000, ...} ). Let's assume max has m bits in its binary representation, then x can reach exactly distinct elements. So, from each element in the array ai we can reach at most elements.So, Let's generate the numbers that can be reached from each element ai using bfs to get minimum number of operations. And between all the numbers that are reachable from all the n elements let's minimize the total number of operations.Time complexity: Implementation558D - Guess Your Way Out! IIFirst, each query in the level i from L to R can be transmitted into level i + 1 from L * 2 to R * 2 + 1, so, we can transform each query to the last level.Let's maintain a set of correct ranges such that the answer is contained in one of them. At the beginning we will assume that the answer is in the range [2h - 1, 2h - 1] inclusive. Now Let's process the queries. If the query's answer is yes, then we want to get the intersection of this query's range with the current set of correct ranges, and update the set with the resulting set. If the query's answer is no, we want to exclude the query's range from the current set of correct ranges, and update the set with the resulting set.After we finish processing the queries, if the set of correct ranges is empty, then clearly the game cheated. Else if the set has only one correct range [L, R] such that L = R then we've got an answer. Otherwise there are multiple exit candidates and the answer can't be determined uniquely using the current data.We will have to use stl::set data structure to make updating the ranges faster. In each yes query we delete zero or more ranges. In each no query we may add one range if we split a correct range, so worst case will be linear in queries count.Time complexity: Implementation558E - A Simple TaskIn this problem we will be using counting sort. So for each query we will count the number of occurrences for each character, and then update the range like this for(int j=x;j<=y;j++)\n cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n while(cnt[ind] == 0)\n ind++;\n s[j] = ind + 'a';\n cnt[ind]--;\n}But this is too slow. We want a data structure that can support the above operations in appropriate time.Let’s make 26 segment trees each one for each character. Now for each query let’s get the count of every character in the range, and then arrange them and update each segment tree with the new values. We will have to use lazy propagation technique for updating ranges.Time complexity: where sz is the size of the alphabet (i.e. = 26).Implementation",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 558\\s*E"
          },
          "content_length": 4938
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 1",
          "code": "Thank you AmrMahmoud.\nEagerly Waiting for your interesting problems...  ☺",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 2",
          "code": "s[i]: i%26 + 'a'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 3",
          "code": "cout<<in->apples<<endl;;\n\n        cout<<ip->apples<<endl;;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) - Codeforces - Code 4",
          "code": "__builtin_popcount",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int j=x;j<=y;j++)\n  cnt[s[j] - 'a']++;\nind = 0;\nfor(int j=x;j<=y;j++)\n{\n  while(cnt[ind] == 0)\n    ind++;\n  s[j] = ind + 'a';\n  cnt[ind]--;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool up = false;\n        LL mn = ans[1];\n\tfor(int i=1;i<N;)\n\t{\n\t\tif(!L[i] && !H[i] && !up)\n\t\t\ti = 2*i + 1;\n\t\telse\n\t\t{\n\t\t\tif(R[i] || H[i])up = true;\n\t\t\tUP[2*i] += UP[i] + H[i] + R[i];\n\t\t\ti = 2*i;\n\t\t}\n\t\tif(i>=N)break;\n\t\tif(i&1)\t//we went to right\n\t\t\tans[i] = ans[i/2] - R[i/2];\n\t\telse\t//we went to left\n\t\t\tans[i] = ans[i/2] + UP[i] - L[i/2];\n\t\tmn = min(mn,ans[i]);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "1 2\n1 1 1 0\n1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "for (int i = 0; i < n; i++) {\n        memset(visited, false, sizeof visited);\n        memset(operations, 0, sizeof operations);\n        bfs(nums[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if (visited[v] || v > maxnum || v < 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #312 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if (v > maxnum || v < 1 || visited[v] )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19212",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, 50000, \"q\");\n    inf.readEoln();\n\n    string S = inf.readToken(\"[a-z]+\", \"S\");\n    inf.readEoln();\n    ensuref(int(S.length()) == n, \"The length of string S should be n=%d, but is %d\", n, int(S.length()));\n\n    for (int query = 1; query <= q; query++) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(i, n, \"j\");  // Since i ≤ j ≤ n\n        inf.readSpace();\n        int k = inf.readInt(0, 1, \"k\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, 50000, \"q\");\n    inf.readEoln();\n\n    string S = inf.readToken(\"[a-z]+\", \"S\");\n    inf.readEoln();\n    ensuref(int(S.length()) == n, \"The length of string S should be n=%d, but is %d\", n, int(S.length()));\n\n    for (int query = 1; query <= q; query++) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(i, n, \"j\");  // Since i ≤ j ≤ n\n        inf.readSpace();\n        int k = inf.readInt(0, 1, \"k\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, 50000, \"q\");\n    inf.readEoln();\n\n    string S = inf.readToken(\"[a-z]+\", \"S\");\n    inf.readEoln();\n    ensuref(int(S.length()) == n, \"The length of string S should be n=%d, but is %d\", n, int(S.length()));\n\n    for (int query = 1; query <= q; query++) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(i, n, \"j\");  // Since i ≤ j ≤ n\n        inf.readSpace();\n        int k = inf.readInt(0, 1, \"k\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0);\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    // Generate string S of length n according to s_type\n    string S;\n\n    if (s_type == \"random\") {\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = char('a' + rnd.next(26));\n        }\n    } else if (s_type == \"same\") {\n        char c = char('a' + rnd.next(26));\n        S = string(n, c);\n    } else if (s_type == \"increasing\") {\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = char('a' + (i % 26));\n        }\n    } else if (s_type == \"decreasing\") {\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = char('z' - (i % 26));\n        }\n    }\n\n    // Generate q queries according to q_type\n    vector<tuple<int, int, int>> queries; // Each query is (i, j, k)\n\n    if (q_type == \"random\") {\n        for (int t = 0; t < q; ++t) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(i, n);\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"full\") {\n        for (int t = 0; t < q; ++t) {\n            int i = 1;\n            int j = n;\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"single\") {\n        for (int t = 0; t < q; ++t) {\n            int i = rnd.next(1, n);\n            int j = i;\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"overlapping\") {\n        int num_overlap = rnd.next(1, q / 2);\n        for (int t = 0; t < num_overlap; ++t) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(i, n);\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n            if ((int)queries.size() < q) {\n                int new_i = max(1, i - rnd.next(0, 5));\n                int new_j = min(n, j + rnd.next(0, 5));\n                int new_k = rnd.next(0, 1);\n                queries.emplace_back(new_i, new_j, new_k);\n            }\n        }\n        while ((int)queries.size() < q) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(i, n);\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"repeated\") {\n        int repeat_i = rnd.next(1, n);\n        int repeat_j = rnd.next(repeat_i, n);\n        int repeat_k = rnd.next(0, 1);\n        for (int t = 0; t < q; ++t) {\n            queries.emplace_back(repeat_i, repeat_j, repeat_k);\n        }\n    } else if (q_type == \"max\") {\n        for (int t = 0; t < q; ++t) {\n            int i = 1;\n            int j = n;\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, q);\n    printf(\"%s\\n\", S.c_str());\n    for (auto [i, j, k] : queries) {\n        printf(\"%d %d %d\\n\", i, j, k);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0);\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    // Generate string S of length n according to s_type\n    string S;\n\n    if (s_type == \"random\") {\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = char('a' + rnd.next(26));\n        }\n    } else if (s_type == \"same\") {\n        char c = char('a' + rnd.next(26));\n        S = string(n, c);\n    } else if (s_type == \"increasing\") {\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = char('a' + (i % 26));\n        }\n    } else if (s_type == \"decreasing\") {\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = char('z' - (i % 26));\n        }\n    }\n\n    // Generate q queries according to q_type\n    vector<tuple<int, int, int>> queries; // Each query is (i, j, k)\n\n    if (q_type == \"random\") {\n        for (int t = 0; t < q; ++t) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(i, n);\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"full\") {\n        for (int t = 0; t < q; ++t) {\n            int i = 1;\n            int j = n;\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"single\") {\n        for (int t = 0; t < q; ++t) {\n            int i = rnd.next(1, n);\n            int j = i;\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"overlapping\") {\n        int num_overlap = rnd.next(1, q / 2);\n        for (int t = 0; t < num_overlap; ++t) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(i, n);\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n            if ((int)queries.size() < q) {\n                int new_i = max(1, i - rnd.next(0, 5));\n                int new_j = min(n, j + rnd.next(0, 5));\n                int new_k = rnd.next(0, 1);\n                queries.emplace_back(new_i, new_j, new_k);\n            }\n        }\n        while ((int)queries.size() < q) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(i, n);\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    } else if (q_type == \"repeated\") {\n        int repeat_i = rnd.next(1, n);\n        int repeat_j = rnd.next(repeat_i, n);\n        int repeat_k = rnd.next(0, 1);\n        for (int t = 0; t < q; ++t) {\n            queries.emplace_back(repeat_i, repeat_j, repeat_k);\n        }\n    } else if (q_type == \"max\") {\n        for (int t = 0; t < q; ++t) {\n            int i = 1;\n            int j = n;\n            int k = rnd.next(0, 1);\n            queries.emplace_back(i, j, k);\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, q);\n    printf(\"%s\\n\", S.c_str());\n    for (auto [i, j, k] : queries) {\n        printf(\"%d %d %d\\n\", i, j, k);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal case\n./gen -n 1 -q 0 -s_type random -q_type random\n\n# n=1, q=1\n./gen -n 1 -q 1 -s_type random -q_type random\n\n# Small n, small q, random\n./gen -n 10 -q 5 -s_type random -q_type random\n\n# Small n, small q, queries on substrings of length 1\n./gen -n 10 -q 5 -s_type random -q_type single\n\n# Small n, small q, overlapping queries\n./gen -n 10 -q 5 -s_type random -q_type overlapping\n\n# Small n, small q, repeated queries\n./gen -n 10 -q 5 -s_type same -q_type repeated\n\n# Max n, q=0\n./gen -n 100000 -q 0 -s_type random -q_type random\n\n# Max n, q=50000, random queries\n./gen -n 100000 -q 50000 -s_type random -q_type random\n\n# Max n, q=50000, queries cover the full string\n./gen -n 100000 -q 50000 -s_type random -q_type full\n\n# Max n, q=50000, queries on substrings of length 1\n./gen -n 100000 -q 50000 -s_type random -q_type single\n\n# Max n, q=50000, string with same letters, max size queries\n./gen -n 100000 -q 50000 -s_type same -q_type max\n\n# Max n, q=50000, increasing letters, max size queries\n./gen -n 100000 -q 50000 -s_type increasing -q_type max\n\n# Max n, q=50000, decreasing letters, max size queries\n./gen -n 100000 -q 50000 -s_type decreasing -q_type max\n\n# Max n, q=50000, overlapping queries\n./gen -n 100000 -q 50000 -s_type random -q_type overlapping\n\n# Max n, q=50000, repeated queries\n./gen -n 100000 -q 50000 -s_type random -q_type repeated\n\n# Medium n and q, increasing letters, random queries\n./gen -n 50000 -q 25000 -s_type increasing -q_type random\n\n# Small n and q, same letters, random queries\n./gen -n 1000 -q 500 -s_type same -q_type random\n\n# Small n and q, full string queries\n./gen -n 1000 -q 500 -s_type random -q_type full\n\n# Small n and q, queries on substrings of length 1\n./gen -n 1000 -q 500 -s_type random -q_type single\n\n# Small n and q, overlapping queries\n./gen -n 1000 -q 500 -s_type random -q_type overlapping\n\n# Edge case: Max n, q=0\n./gen -n 100000 -q 0 -s_type random -q_type random\n\n# Edge case: n=1, Max q\n./gen -n 1 -q 50000 -s_type random -q_type random\n\n# Edge case: n=1, Max q, max size queries\n./gen -n 1 -q 50000 -s_type random -q_type max\n\n# Edge case: n=1, Max q, full string queries\n./gen -n 1 -q 50000 -s_type random -q_type full\n\n# Edge case: n=1, Max q, queries on substrings of length 1\n./gen -n 1 -q 50000 -s_type random -q_type single\n\n# Edge case: n=1, Max q, repeated queries\n./gen -n 1 -q 50000 -s_type random -q_type repeated\n\n# Small n and q\n./gen -n 5 -q 5 -s_type random -q_type random\n\n# n=26, increasing letters, max size queries\n./gen -n 26 -q 20 -s_type increasing -q_type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:04.836526",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "559/A",
      "title": "A. Gerald's Hexagon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and the single line of the input contains 6 space-separated integers a1, a2, a3, a4, a5 and a6 (1 ≤ ai ≤ 1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.",
      "output_spec": "OutputPrint a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.",
      "sample_tests": "ExamplesInputCopy1 1 1 1 1 1OutputCopy6InputCopy1 2 1 2 1 2OutputCopy13",
      "description": "A. Gerald's Hexagon\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and the single line of the input contains 6 space-separated integers a1, a2, a3, a4, a5 and a6 (1 ≤ ai ≤ 1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.\n\nOutputPrint a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.\n\nInputCopy1 1 1 1 1 1OutputCopy6InputCopy1 2 1 2 1 2OutputCopy13\n\nInputCopy1 1 1 1 1 1\n\nOutputCopy6\n\nInputCopy1 2 1 2 1 2\n\nOutputCopy13\n\nNoteThis is what Gerald's hexagon looks like in the first sample:And that's what it looks like in the second sample:",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the Codeforces round 313, which is prepeared by me and tunyash. Each of us is prepared four rounds then it is our fifth of ninth round to your notice. I figured out almost all problems (except D div.1), wrote the statements and analysis of all the problems, and tunyash has developed all problems.Gerald is not coordinator yet and you probobly missed him. In this round you will meet him again and help him in his ordinary life problems.I want to thank Zlobober, our translator Maria Belova (Delinur) and MikeMirzayanov and all Codeforces team for this platform.This round will be held in unusual time — 17:00 Moscow Time.Contest finished! Welcome to editoral: Short editoral. Extended editoral.Div.1 scoring distribution:500 — 1000 — 1500 — 2250 — 2250Div.2 scoring distribution:500 — 1000 — 1500 — 2000 — 2500I wish you to enjoy solving problems!Congratulations to winners!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1073
        },
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces",
          "content": "560A - Currency System in GeraldionIf there is a banlnot of value 1 then one can to express every sum of money. Otherwise one can't to express 1 and it is minimum unfortunate sum.560B - Gerald is into ArtIt is easy to see that one can snuggle paintings to each other and to edge of board. For instance one can put one of painting right over other. Then height of two paintings equals to sum of two heights and width of two paintings is equals to maximum of two widths. Now we can just iterate orientation of paintings and board.559A - Gerald's Hexagon & 560C - Gerald's HexagonLet's consider regular triangle with sides of k Let's split it to regular triangles with sides of 1 by lines parallel to the sides. Big triange area k2 times larger then small triangles area and therefore big triangle have splitted by k2 small triangles.If we join regular triangles to sides a1, a3 and a5 of hexagon we get a triangle sides of a1 + a2 + a3. Then hexagon area is equals to (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Equivalent Strings & 560D - Equivalent StringsLet us note that \"equivalence\" described in the statements is actually equivalence relation, it is reflexively, simmetrically and transitive. It is meant that set of all string is splits to equivalence classes. Let's find lexicographic minimal strings what is equivalent to first and to second given string. And then check if its are equals.It is remain find the lexicographic minimal strings what is equivalent to given. For instance we can do it such a way: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Every recursive call time works is O(n) (where n is length of strings) and string splitten by two twice smaller strings. Therefore time of work this function is , where n is length of strings.559C - Gerald and Giant Chess & 560E - Gerald and Giant ChessLet's denote black cells ad A0, A1, ..., Ak - 1 . First of all, we have to sort black cells in increasing order of (row, column). If cell x available from cell y, x stands after y in this order. Let Ak = (h, w). Now we have to find number of paths from (1, 1) to Ak avoiding A0, ..., Ak - 1.Let Di is number of paths from (1, 1) to Ai avoiding A0, ..., Ai - 1. It's easy to see that Dk is answer for the problem. Number of all paths from (1, 1) to (xi, yi) is . We should subtract from that value all paths containing at least one of previous black cells. We should enumerate first black cell on the path. It could be one of previous cell that is not below or righter than Ai. For each such cell Aj we have to subtract number of paths from (1, 1) to Aj avoiding black cells multiplied by number of all paths from Aj to Ai.We have to calculate factorials of numbers from 1 to 2·105 and inverse elements of them modulo 109 + 7 for calculating binomial coefficients.559D - RandomizerWe can use Pick's theorem for calculate integer points number in every polygon. Integer points number on the segment between points (0, 0) and (a, b) one can calculate over GCD(a, b).Integer points number in some choosen polynom is integer points number in basic polynom minus integer points number in segmnent of basic polynom separated by every segment of choosen polynom.Let consider every potencial segment of polygon. We can calculate integer points number in his segment and probability that we will meet it in choosen polygon.Probability of segment AiAi + k is . Let use note that we can calculate only segments with k < 60 because of other segmnet propapility is too small.559E - Gerald and PathLighted part of walking trail is union of ligted intervals. Let's sort spotlights in increasing order of ai. Consider some lighted interval (a, b). It's lighted by spotlights with numbers {l, l + 1, ..., r} for some l and r (\"substring\" of spotlights). Let x0, ..., xk is all possible boundaries of lighted intervals (numbers ai - li, ai и ai + li).Imagine, that we know possible lighted intervals of all substrings of spotlights. Let left[l][r][j] is least possible i such that set of spotlights with numbers {l, l + 1, ..., r} lighting [xi, xj].With left we can calculate value best[R][i] maximum possible length of walking trail that could be lighted using first L spotlights in such way that xi is rightmost lighted point. It's easy to do in O(n4) because .Now all we have to do is calculate left. Consider some substring of spotlights [l, r]. Let all spotlights in the substring oriented in some way lighting some set of points. We could consider most left (i) and most right (j) lighted points, and left bound of first lighted interval (t). If set of lighted points is interval t = j. Consider how all the values change when we add spotlight r + 1 and choose its orientation. We have new lighted interval [a, b] which is equal to [ai - li, ai] or [ai, ai + li]. Now most left lighted point is min(a, xi), most right is max(b, xj). Right bound of leftmost lighted interval does not changes if a > t or becomes equal to b, if a ≤ t.Not for each L we can calculate dp[r][j][y] least possible i that it's possible to orient spotlights from [L, r] in such way that xi is most left lighted point xj is most right one and right bound of leftmost lighted interval is xt. Thet it's easy to calculate left[L][][]. That part is done in O(n4) too.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 559\\s*A"
          },
          "content_length": 5422
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 3",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 4",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 5",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 6",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 7",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 8",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 9",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 10",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 11",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 12",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 13",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> a = inf.readInts(6, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    int a1 = a[0];\n    int a2 = a[1];\n    int a3 = a[2];\n    int a4 = a[3];\n    int a5 = a[4];\n    int a6 = a[5];\n\n    int s1 = 2 * a1 + a2 - a3 - 2 * a4 - a5 + a6;\n    ensuref(s1 == 0, \"Invalid hexagon: s1=%d != 0\", s1);\n\n    int s2 = a2 + a3 - a5 - a6;\n    ensuref(s2 == 0, \"Invalid hexagon: s2=%d != 0\", s2);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> a = inf.readInts(6, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    int a1 = a[0];\n    int a2 = a[1];\n    int a3 = a[2];\n    int a4 = a[3];\n    int a5 = a[4];\n    int a6 = a[5];\n\n    int s1 = 2 * a1 + a2 - a3 - 2 * a4 - a5 + a6;\n    ensuref(s1 == 0, \"Invalid hexagon: s1=%d != 0\", s1);\n\n    int s2 = a2 + a3 - a5 - a6;\n    ensuref(s2 == 0, \"Invalid hexagon: s2=%d != 0\", s2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> a = inf.readInts(6, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    int a1 = a[0];\n    int a2 = a[1];\n    int a3 = a[2];\n    int a4 = a[3];\n    int a5 = a[4];\n    int a6 = a[5];\n\n    int s1 = 2 * a1 + a2 - a3 - 2 * a4 - a5 + a6;\n    ensuref(s1 == 0, \"Invalid hexagon: s1=%d != 0\", s1);\n\n    int s2 = a2 + a3 - a5 - a6;\n    ensuref(s2 == 0, \"Invalid hexagon: s2=%d != 0\", s2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read input parameters\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000);\n\n    int a1, a2, a3, a4, a5, a6;\n\n    if (type == \"random\") {\n        while (true) {\n            // Randomly generate a1, a2, a3 in [1, maxAi]\n            a1 = rnd.next(1, maxAi);\n            a2 = rnd.next(1, maxAi);\n            a3 = rnd.next(1, maxAi);\n\n            // Randomly choose a6 in [1, maxAi]\n            a6 = rnd.next(1, maxAi);\n\n            // Compute a4 = a1 + a6 - a3\n            a4 = a1 + a6 - a3;\n\n            if (a4 < 1 || a4 > maxAi)\n                continue;\n\n            // Compute a5 = a1 + a2 - a4\n            a5 = a1 + a2 - a4;\n            if (a5 < 1 || a5 > maxAi)\n                continue;\n\n            // All sides are within bounds, break the loop\n            break;\n        }\n    } else if (type == \"max\") {\n        a1 = a2 = a3 = a6 = maxAi;\n        a4 = a1 + a6 - a3;\n        a5 = a1 + a2 - a4;\n    } else if (type == \"min\") {\n        a1 = a2 = a3 = a6 = 1;\n        a4 = a1 + a6 - a3;\n        a5 = a1 + a2 - a4;\n    } else if (type == \"special\") {\n        // Generate a test case with a1, a3, a5 at max, and others at min\n        a1 = a3 = a5 = maxAi;\n        a2 = a4 = a6 = 1;\n        // Verify the equations\n        if (a1 + a2 != a4 + a5 || a1 + a6 != a3 + a4 || a2 + a3 != a5 + a6) {\n            fprintf(stderr, \"Generated sides do not satisfy the equations.\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'.\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the sides\n    printf(\"%d %d %d %d %d %d\\n\", a1, a2, a3, a4, a5, a6);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read input parameters\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000);\n\n    int a1, a2, a3, a4, a5, a6;\n\n    if (type == \"random\") {\n        while (true) {\n            // Randomly generate a1, a2, a3 in [1, maxAi]\n            a1 = rnd.next(1, maxAi);\n            a2 = rnd.next(1, maxAi);\n            a3 = rnd.next(1, maxAi);\n\n            // Randomly choose a6 in [1, maxAi]\n            a6 = rnd.next(1, maxAi);\n\n            // Compute a4 = a1 + a6 - a3\n            a4 = a1 + a6 - a3;\n\n            if (a4 < 1 || a4 > maxAi)\n                continue;\n\n            // Compute a5 = a1 + a2 - a4\n            a5 = a1 + a2 - a4;\n            if (a5 < 1 || a5 > maxAi)\n                continue;\n\n            // All sides are within bounds, break the loop\n            break;\n        }\n    } else if (type == \"max\") {\n        a1 = a2 = a3 = a6 = maxAi;\n        a4 = a1 + a6 - a3;\n        a5 = a1 + a2 - a4;\n    } else if (type == \"min\") {\n        a1 = a2 = a3 = a6 = 1;\n        a4 = a1 + a6 - a3;\n        a5 = a1 + a2 - a4;\n    } else if (type == \"special\") {\n        // Generate a test case with a1, a3, a5 at max, and others at min\n        a1 = a3 = a5 = maxAi;\n        a2 = a4 = a6 = 1;\n        // Verify the equations\n        if (a1 + a2 != a4 + a5 || a1 + a6 != a3 + a4 || a2 + a3 != a5 + a6) {\n            fprintf(stderr, \"Generated sides do not satisfy the equations.\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'.\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the sides\n    printf(\"%d %d %d %d %d %d\\n\", a1, a2, a3, a4, a5, a6);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min -maxAi 1\n./gen -type max -maxAi 1000\n./gen -type random -maxAi 1\n./gen -type random -maxAi 2\n./gen -type random -maxAi 3\n./gen -type random -maxAi 5\n./gen -type random -maxAi 10\n./gen -type random -maxAi 50\n./gen -type random -maxAi 100\n./gen -type random -maxAi 200\n./gen -type random -maxAi 500\n./gen -type random -maxAi 999\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type special -maxAi 1000\n./gen -type special -maxAi 500\n./gen -type special -maxAi 100\n./gen -type special -maxAi 50\n./gen -type special -maxAi 10\n./gen -type special -maxAi 1\n./gen -type special -maxAi 2\n./gen -type special -maxAi 999\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n./gen -type random -maxAi 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:06.999850",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "559/B",
      "title": "B. Эквивалентные строки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первых двух строках входных данных даны две строки, которые выдал преподаватель. Каждая из них имеет длину от 1 до 200 000 и состоит из строчных букв английского алфавита. Строки имеют одинаковую длину.",
      "output_spec": "Выходные данныеВыведите «YES» (без кавычек), если эти две строки эквивалентны, и «NO» (без кавычек) в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопироватьaabaabaaВыходные данныеСкопироватьYESВходные данныеСкопироватьaabbababВыходные данныеСкопироватьNO",
      "description": "B. Эквивалентные строки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первых двух строках входных данных даны две строки, которые выдал преподаватель. Каждая из них имеет длину от 1 до 200 000 и состоит из строчных букв английского алфавита. Строки имеют одинаковую длину.\n\nВходные данные\n\nВыходные данныеВыведите «YES» (без кавычек), если эти две строки эквивалентны, и «NO» (без кавычек) в противном случае.\n\nВыходные данные\n\nВходные данныеСкопироватьaabaabaaВыходные данныеСкопироватьYESВходные данныеСкопироватьaabbababВыходные данныеСкопироватьNO\n\nВходные данныеСкопироватьaabaabaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьaabbabab\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере первую строку можно разделить на строки \"aa\" и \"ba\", вторую – на строки \"ab\" и \"aa\". \"aa\" эквивалентно \"aa\"; \"ab\" эквивалентно \"ba\", так как \"ab\" = \"a\" + \"b\", \"ba\" = \"b\" + \"a\".Во втором примере первую строку можно разделить на строки \"aa\" и \"bb\", которые эквивалентны только сами себе. Поэтому строка \"aabb\" эквивалентна только сама себе и строке \"bbaa\".",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Доброго всем времени суток!Приглашаю Вас поучаствовать в 313 Codeforces раунде, над которыми для вас работали я и tunyash. У каждого из нас за плечами по четыре раунда, так что это наш пятый или девятый раунд, как хотите. Я придумал почти все задачи (кроме D div.1), написал условия и разбор всех задач, а tunyash занимался разработкой всех задач.Gerald уже не является координатором, так что, возможно, Вы по нему соскучились. В этом раунде вы снова с ним встретитесь и поможете ему разобраться в его повседневных жизненных проблемах.Спасибо координатору Zlobober, нашей переводчице Марии Беловой (Delinur), а так же MikeMirzayanov и всей команде Codeforces за эту платформу.Этот раунд состоится в необычное время — 17:00 по Московскому времени.Соревнование закончилось, добро пожаловать в разбор! Краткий разбор. Подробный разбор.Разбалловка в первом дивизионе будет следующая:500 — 1000 — 1500 — 2250 — 2250А во втором дивизионе — стандартная:500 — 1000 — 1500 — 2000 — 2500Желаю всем получить удовольствие от решения задач!Поздравляем победителей!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1200
        },
        {
          "title": "VK Cup 2015: онлайн-трансляция и порция благодарностей - Codeforces",
          "content": "Мы были вынуждены удалить регистрации, сделанные до 00:00, так как регистрационная форма на тот момент не поддерживала регистрацию команд. Пожалуйста, пройдите регистрацию вновь, если ваша регистрация была удалена.Вчера завершился финал чемпионата VK Cup 2015, о котором вы могли прочитать в предыдущих наших постах. Осталось объявить последнее событие, связанное с прошедшим чемпионатом — онлайн-трансляцию, которая состоится в четверг 30 июля в 19:00 по Москве. К соревнованию допускаются как индивидуальные участники, так и команды из двух человек, которые желают почувствовать себя участниками финала соревнования. Трансляция продлится три часа, задачи будут перемешаны по сравнению с оригинальным порядком. Допускаются участники обоих дивизионом, но мы считаем своим долгом предупредить, что для участников из второго дивизиона набор задач, скорее всего, будет слишком сложным. Этот раунд является рейтинговым раундом Codeforces.В заключение мы хотели бы поблагодарить всех людей, которые помогли чемпионату состояться. Придумывали и готовили задачи для вас сотрудники ВКонтакте, члены команды Codeforces и другие люди, любезно предложившие свою помощь: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. Хочется сказать большое спасибо людям, прорешивавшим наши раунды, и дававшим ценные советы по поводу задач: winger и AlexFetisov. Также, мы благодарим всех работников ВКонтакте, с которыми вместе мы занимались проведением чемпионата: burunduk3, Burunduk2, KOTEHOK и многих других. Спасибо!Всем удачи на онлайн-трансляции!UPD: Обратите внимание, что во время раунда команде разрешается пользоваться только одним компьютером. Это значит, что программировать/пользоваться консолью/как-либо иначе продвигаться в решении задач в один момент времени можно только с одного компьютера. Единственное, что разрешается делать с двух компьютеров — это читать условия. UPD2: Так как это командное соревнование, специально для вашего удобства мы выкладываем запароленный архив с pdf-условиями задач: vkcup2015-mirror-statements.zip. С началом тура мы опубликуем пароль к нему.UPD3: В раунде будет использована динамическая разбалловка с шагом в 250 очков.UPD4: По техническим причинам начало раунда переносится на 19:20 по Москве.UPD5: Пароль на архив с условиями: vkcup4ever. Удачи!UPD6: Онлайн-трансляция завершена! Поздравляем победителей: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Мой персональный респектам команде Petr team: Petr, ilyakor за единственное решение по задаче Е в трансляции, пользователю rng_58 и команде Excited: YuukaKazami, jqdai0815 за два правильных решения по задаче С.Также, поздравляем пользователя rng_58, который продемонстрировал, что одиночному пользователю есть что противопоставить командам, состоящим из двух людей!Рейтинг будет пересчитан в ближайшее время.UPD7: Разбор!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2993
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces",
          "content": "560A - Денежная система ГеральдионаВ этой задаче главное — заметить, что если есть купюра номинала 1, то любую сумму денег можно выдать единичными купюрами. Если же такой купюры нет, то как раз сумму 1 представить нельзя. Поэтому, если нет купюры номинала 1, то ответ — 1, а если такая купюра есть — то -1.560B - Геральд увлекается исскусствомЛегко заметить, что можно прижать две картины друг в другу какими-то двумя краями, например, разместить одну картину прямо над другой. Тогда высота двух картин будет суммой высот картин, а ширина — максимум из ширин картин. Осталось перебрать все варианты, как повёрнуты картины и как при этом повёрнут стенд. Вот реализация.559A - Шестиугольник Геральда & 560C - Шестиугольник ГеральдаСперва заметим, что если правильный треугольник с целой стороной k отрезками, параллельными сторонам, разделить на правильные треугольники со стороной 1 (тут появляется картинка), то площадь большого треугольника будет в k2 раз больше площадей маленьких треугольничков и, следовательно, треугольник окажется разделён ровно на k2 единичных треугольничков.Далее, заметим, что если к сторонам a1, a3 и a5 шестиугольника пририсовать по правильному треугольнику со сторонами a1, a3 и a5 соответственно (и тут появляется ещё одна картинка), то получится большой правильный треугольник со стороной a1 + a2 + a3. Таким образом, площадь исходного шестиугольника равна (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Эквивалентные строки & 560D - Эквивалентные строкиНетрудно заметить, что \"эквивалентность\", описанная в задаче, в самом деле является отношением эквивалентности, то есть, оно симметрично, транзитивно и рефлексивно. Подробнее от отношениях эквивалентности можно почитать здесь. В частности, это означает, что все строки разбиваются на классы эквивалентности и нам надо проверить, что данные нам две строки принадлежат одному и тому же классу. Для этого давайте найдём лексикографически минимальную строку, которая лежит в одном классе эквивалентности с каждой из строк. Иными словами, найдём лексикографически минимальную строку, эквивалентную каждой из данных строк и проверим, получилась ли одна и та же строка.Осталось научиться находить лексикографически минимальную строку, эквивалентную данной, за приемлемое время. Это можно сделать, например, следующей рекурсивной функцией: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Поскольку каждый рекурсивный вызов работает линейно от длины переданной ему строки и внутри функции она сама два раза вызывается от вдвое меньшей строки, эта функция работает за время , где n — длина строки.559C - Геральд и гигантские шахматы & 560E - Геральд и гигантские шахматыОбозначим все чёрные клетки как A0, A1, ..., Ak - 1. Для начала, упорядочим чёрные клетки в порядке сверху вниз, а те, которые на одной высоте — слева направо. Теперь все чёрные клетки, из которых пешка Геральда могла бы попасть в данную чёрную клетку, находятся до неё. Покрасим нижнюю правую клетку в чёрный цвет и тоже добавим её в список чёрных клеток под номером k. Теперь пешке Геральда надо попасть в последнюю чёрную клетку, миновав все остальные.Посчитаем величину Di — количество способов попасть в Ai, миновав все предыдущие чёрные клетки. Как несложно заметить, ответом на задачу будет Dk. Общее количество способов дойти из клетки (1, 1) в клетку (xi, yi) равно . Вычтем из этого количества все способы попасть в Ai, зайдя по пути в одну из предыдущих чёрных клеток. Для этого переберём, какая из чёрных клеток могла первой попасться на пути. Это должна быть какая-то из предыдущих чёрных клеток, находящаяся не ниже и не правее, чем Ai. Для каждой такой клетки Aj надо вычесть произведение количества способов попасть в Aj, минуя все предыдущие чёрные клетки и количества способов просто попасть из Aj в Ai.Для вычисления биномиальных коэффициентов придётся преподсчитать факториалы всех чисел до 2·105 и научиться брать обратные к ним по модулю 109 + 7.559D - РандомизаторДля начала, вспомним формулу Пика. Благодаря ней, количество целых точек внутри любого многоугольника можно вычислить, зная его площадь и количество целых точек на границе. Количество целых точек на отрезке, соединяющем точки (0, 0) и (a, b) можно посчитать, найдя НОД(a, b).Давайте вычислим общее количество целых точек в основном многоугольнике, а затем для каждого отрезка, соединяющего какие-то две вершины многоугольника, вычтем из этой величины произведение вероятности того, что этот отрезок будет стороной выбранного многоугольника и количество целых точек в сегменте основного многоугольника, который отсекает этот отрезок. Вероятность легко посчитать. Если отрезок соединяет вершины Ai и Ai + k, то существует ровно 2n - k - 1 - 1 многоугольник, в котором есть такая сторона, а общее количество валидных многоугольников равняется .Количество целых точек в отсекаемом отрезком AiAi + k сегменте тоже легко посчитать с помощью с формулы Пика за время O(k), а если воспользоваться тем, что перед этим мы посчитали количество целых точек в сегменте, отсекаемом AiAi + k - 1, можно сделать это за время O(1).Таким образом, получается решение за время ( -- время вычисления НОД двух натуральных чисел, не превосходящих MAX). Это, конечно, слишком много.Давайте обратим внимание на вероятность появления каждой из сторон. Вероятность появления в многоугольнике стороны, пропускающей k - 1 вершину многоугольника, равна . Как видно, эта вероятность экспоненциально падает с ростом k. В частности, если общее количество целых точек в многоугольнике равно V, то сумма всех слагаемых, соответствующих отрезкам с k ≥ 60 не превосходит . Таким образом, все слагаемые, соответствующие отрезкам с k ≥ 60, можно просто игнорировать. Следует отметить, что 60 — это очень грубая оценка, не учитывающая, что для большинства отрезков вероятность будет гораздо меньше, чем 2 - 60, а для отрезков с k порядка 60 количество целых точек внутри сегмента будет порядка , а вовсе не порядка V.Таким образом, мы получаем решение за время , поскольку 60 — это ни что иное, как .559E - Геральд и тропинкаОсвещённая часть тропинки представляет собой объединение нескольких непересекающихся освещенных отрезков (возможно, одного). Давайте упорядочим прожекторы по возрастанию ai. Заметим, что каждый освещенный отрезок освещается некоторой \"подстрокой\" прожекторов, то есть, множеством прожекторов с номерами из некоторого отрезка [l, r]. Пусть x0, ..., xk — упорядоченная последовательность потенциальных концов отрезков, то есть, всех чисел вида ai - li, ai и ai + li.Представим себе, что мы знаем, какие именно отрезки тропинки можно осветить с помощью каждой подстроки прожекторов. Сохраним в массив left[][][] информацию о самых длинных возможных освещенных отрезках в следующем виде: left[l][r][j] — самое маленькое такое i, что подстрока [l, r] прожекторов может освещать отрезок [xi, xj].Теперь, имея массив left, посчитаем динамикой величину best[R][i] — какую максимальную длину тропинки можно осветить, используя первые L прожекторов так, чтобы самой правой освещённой точкой была xi. Это легко сделать за время O(n4), так как .Теперь давайте вычислим массив left. Рассмотрим некую подстроку прожекторов [l, r]. Пусть все прожекторы этой подстроки как-то ориентированы и освещают некоторую область тропинки. У этой области можно рассмотреть самую левую (i) и самую правую (j) освещенную точки, а также правый конец самого левого освещенного отрезка (t). Если область является одним отрезком, то t = j. Рассмотрим, как меняются эти три параметра, когда мы добавляем к подстроке прожектор r + 1 и выбираем его ориентацию. К освещенной области добавляется отрезок [a, b], который равен [ai - li, ai] или [ai, ai + li]. Самая левая освещенная точка становится min(a, xi), самая правая — max(b, xj). А правый конец самого левого отрезка не меняется, если a > t или становится b, если a ≤ t.Эти соотношения позволяют для каждого фиксированного L вычислить динамикой величину dp[r][j][y] — наименьшее такое i, что можно ориентировать прожекторы подстроки [L, r] так, чтобы самая левая освещенная точка была xi, самая правая — xj, а правый конец самого левого отрезка — xt. Вычислив это, уже легко посчитать значения массива left[L][][]. Эта часть решения тоже будет работать за время O(n4).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 559\\s*B"
          },
          "content_length": 8382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 3",
          "code": "T(n) = 4*T(n / 2) => T(n) = n^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 4",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 5",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 6",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 7",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 8",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 9",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 10",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 11",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 12",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 13",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 14",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 15",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 16",
          "code": "cout << fixed",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 17",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 18",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 19",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 20",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 21",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"^[a-z]{1,200000}$\", \"s1\");\n    int n1 = s1.length();\n    ensuref(n1 >= 1 && n1 <= 200000, \"Length of s1 must be between 1 and 200000, but is %d\", n1);\n\n    string s2 = inf.readLine(\"^[a-z]{1,200000}$\", \"s2\");\n    int n2 = s2.length();\n    ensuref(n2 >= 1 && n2 <= 200000, \"Length of s2 must be between 1 and 200000, but is %d\", n2);\n\n    ensuref(n1 == n2, \"The lengths of s1 and s2 must be equal, but are %d and %d\", n1, n2);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"^[a-z]{1,200000}$\", \"s1\");\n    int n1 = s1.length();\n    ensuref(n1 >= 1 && n1 <= 200000, \"Length of s1 must be between 1 and 200000, but is %d\", n1);\n\n    string s2 = inf.readLine(\"^[a-z]{1,200000}$\", \"s2\");\n    int n2 = s2.length();\n    ensuref(n2 >= 1 && n2 <= 200000, \"Length of s2 must be between 1 and 200000, but is %d\", n2);\n\n    ensuref(n1 == n2, \"The lengths of s1 and s2 must be equal, but are %d and %d\", n1, n2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"^[a-z]{1,200000}$\", \"s1\");\n    int n1 = s1.length();\n    ensuref(n1 >= 1 && n1 <= 200000, \"Length of s1 must be between 1 and 200000, but is %d\", n1);\n\n    string s2 = inf.readLine(\"^[a-z]{1,200000}$\", \"s2\");\n    int n2 = s2.length();\n    ensuref(n2 >= 1 && n2 <= 200000, \"Length of s2 must be between 1 and 200000, but is %d\", n2);\n\n    ensuref(n1 == n2, \"The lengths of s1 and s2 must be equal, but are %d and %d\", n1, n2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int n) {\n    string s(n, ' ');\n    for (int i = 0; i < n; ++i)\n        s[i] = rnd.next('a', 'z');\n    return s;\n}\n\nstring generate_equivalent_string(const string &s) {\n    int n = s.size();\n    if (n % 2 != 0)\n        return s; // base case\n    else {\n        int m = n / 2;\n        // Either swap the halves or keep the order\n        if (rnd.next(2)) {\n            string a1 = s.substr(0, m);\n            string a2 = s.substr(m);\n            return generate_equivalent_string(a1) + generate_equivalent_string(a2);\n        } else {\n            string a1 = s.substr(0, m);\n            string a2 = s.substr(m);\n            return generate_equivalent_string(a2) + generate_equivalent_string(a1);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"equal\");\n\n    string s, t;\n\n    if (type == \"equal\") {\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"not_equal\") {\n        s = generate_random_string(n);\n        t = s;\n        // Change one character\n        int pos = rnd.next(0, n - 1);\n        char c;\n        do {\n            c = rnd.next('a', 'z');\n        } while (s[pos] == c);\n        t[pos] = c;\n    } else if (type == \"swap\") {\n        s = generate_random_string(n);\n        t = generate_equivalent_string(s);\n        if (t == s) {\n            // Ensure t is different from s\n            t = generate_equivalent_string(s);\n        }\n    } else if (type == \"random_yes\") {\n        s = generate_random_string(n);\n        t = generate_equivalent_string(s);\n    } else if (type == \"random_no\") {\n        s = generate_random_string(n);\n        t = generate_random_string(n);\n        while (t == s)\n            t = generate_random_string(n);\n    } else if (type == \"max_equal\") {\n        n = 200000;\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"reverse\") {\n        s = generate_random_string(n);\n        t = string(s.rbegin(), s.rend());\n    } else if (type == \"palindrome\") {\n        string half = generate_random_string((n + 1) / 2);\n        string rev_half = string(half.rbegin(), half.rend());\n        if (n % 2 == 1)\n            rev_half = rev_half.substr(1);\n        s = half + rev_half;\n        t = s;\n        // Now generate an equivalent string via swapping\n        t = generate_equivalent_string(s);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    assert((int)s.size() == n && (int)t.size() == n);\n\n    // Output s and t\n    printf(\"%s\\n%s\\n\", s.c_str(), t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int n) {\n    string s(n, ' ');\n    for (int i = 0; i < n; ++i)\n        s[i] = rnd.next('a', 'z');\n    return s;\n}\n\nstring generate_equivalent_string(const string &s) {\n    int n = s.size();\n    if (n % 2 != 0)\n        return s; // base case\n    else {\n        int m = n / 2;\n        // Either swap the halves or keep the order\n        if (rnd.next(2)) {\n            string a1 = s.substr(0, m);\n            string a2 = s.substr(m);\n            return generate_equivalent_string(a1) + generate_equivalent_string(a2);\n        } else {\n            string a1 = s.substr(0, m);\n            string a2 = s.substr(m);\n            return generate_equivalent_string(a2) + generate_equivalent_string(a1);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"equal\");\n\n    string s, t;\n\n    if (type == \"equal\") {\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"not_equal\") {\n        s = generate_random_string(n);\n        t = s;\n        // Change one character\n        int pos = rnd.next(0, n - 1);\n        char c;\n        do {\n            c = rnd.next('a', 'z');\n        } while (s[pos] == c);\n        t[pos] = c;\n    } else if (type == \"swap\") {\n        s = generate_random_string(n);\n        t = generate_equivalent_string(s);\n        if (t == s) {\n            // Ensure t is different from s\n            t = generate_equivalent_string(s);\n        }\n    } else if (type == \"random_yes\") {\n        s = generate_random_string(n);\n        t = generate_equivalent_string(s);\n    } else if (type == \"random_no\") {\n        s = generate_random_string(n);\n        t = generate_random_string(n);\n        while (t == s)\n            t = generate_random_string(n);\n    } else if (type == \"max_equal\") {\n        n = 200000;\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"reverse\") {\n        s = generate_random_string(n);\n        t = string(s.rbegin(), s.rend());\n    } else if (type == \"palindrome\") {\n        string half = generate_random_string((n + 1) / 2);\n        string rev_half = string(half.rbegin(), half.rend());\n        if (n % 2 == 1)\n            rev_half = rev_half.substr(1);\n        s = half + rev_half;\n        t = s;\n        // Now generate an equivalent string via swapping\n        t = generate_equivalent_string(s);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    assert((int)s.size() == n && (int)t.size() == n);\n\n    // Output s and t\n    printf(\"%s\\n%s\\n\", s.c_str(), t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type equal\n./gen -n 1 -type not_equal\n\n./gen -n 2 -type equal\n./gen -n 2 -type not_equal\n\n./gen -n 3 -type equal\n./gen -n 3 -type swap\n\n./gen -n 4 -type equal\n./gen -n 4 -type swap\n\n./gen -n 5 -type random_yes\n./gen -n 5 -type random_no\n\n./gen -n 10 -type random_yes\n./gen -n 10 -type random_no\n\n./gen -n 100 -type random_yes\n./gen -n 100 -type random_no\n\n./gen -n 1000 -type random_yes\n./gen -n 1000 -type random_no\n\n./gen -n 10000 -type random_yes\n./gen -n 10000 -type random_no\n\n./gen -n 100000 -type random_yes\n./gen -n 100000 -type random_no\n\n./gen -n 200000 -type max_equal\n./gen -n 200000 -type reverse\n./gen -n 200000 -type palindrome\n./gen -n 200000 -type not_equal\n./gen -n 200000 -type swap\n./gen -n 200000 -type random_no\n\n./gen -n 123456 -type palindrome\n./gen -n 65432 -type random_yes\n./gen -n 200000 -type random_no\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:09.027595",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "559/C",
      "title": "C. Gerald and Giant Chess",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers: h, w, n — the sides of the board and the number of black cells (1 ≤ h, w ≤ 105, 1 ≤ n ≤ 2000). Next n lines contain the description of black cells. The i-th of these lines contains numbers ri, ci (1 ≤ ri ≤ h, 1 ≤ ci ≤ w) — the number of the row and column of the i-th cell.It is guaranteed that the upper left and lower right cell are white and all cells in the description are distinct.",
      "output_spec": "OutputPrint a single line — the remainder of the number of ways to move Gerald's pawn from the upper left to the lower right corner modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy3 4 22 22 3OutputCopy2InputCopy100 100 315 1616 1599 88OutputCopy545732279",
      "description": "C. Gerald and Giant Chess\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three integers: h, w, n — the sides of the board and the number of black cells (1 ≤ h, w ≤ 105, 1 ≤ n ≤ 2000). Next n lines contain the description of black cells. The i-th of these lines contains numbers ri, ci (1 ≤ ri ≤ h, 1 ≤ ci ≤ w) — the number of the row and column of the i-th cell.It is guaranteed that the upper left and lower right cell are white and all cells in the description are distinct.\n\nOutputPrint a single line — the remainder of the number of ways to move Gerald's pawn from the upper left to the lower right corner modulo 109 + 7.\n\nInputCopy3 4 22 22 3OutputCopy2InputCopy100 100 315 1616 1599 88OutputCopy545732279\n\nInputCopy3 4 22 22 3\n\nOutputCopy2\n\nInputCopy100 100 315 1616 1599 88\n\nOutputCopy545732279",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the Codeforces round 313, which is prepeared by me and tunyash. Each of us is prepared four rounds then it is our fifth of ninth round to your notice. I figured out almost all problems (except D div.1), wrote the statements and analysis of all the problems, and tunyash has developed all problems.Gerald is not coordinator yet and you probobly missed him. In this round you will meet him again and help him in his ordinary life problems.I want to thank Zlobober, our translator Maria Belova (Delinur) and MikeMirzayanov and all Codeforces team for this platform.This round will be held in unusual time — 17:00 Moscow Time.Contest finished! Welcome to editoral: Short editoral. Extended editoral.Div.1 scoring distribution:500 — 1000 — 1500 — 2250 — 2250Div.2 scoring distribution:500 — 1000 — 1500 — 2000 — 2500I wish you to enjoy solving problems!Congratulations to winners!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1073
        },
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces",
          "content": "560A - Currency System in GeraldionIf there is a banlnot of value 1 then one can to express every sum of money. Otherwise one can't to express 1 and it is minimum unfortunate sum.560B - Gerald is into ArtIt is easy to see that one can snuggle paintings to each other and to edge of board. For instance one can put one of painting right over other. Then height of two paintings equals to sum of two heights and width of two paintings is equals to maximum of two widths. Now we can just iterate orientation of paintings and board.559A - Gerald's Hexagon & 560C - Gerald's HexagonLet's consider regular triangle with sides of k Let's split it to regular triangles with sides of 1 by lines parallel to the sides. Big triange area k2 times larger then small triangles area and therefore big triangle have splitted by k2 small triangles.If we join regular triangles to sides a1, a3 and a5 of hexagon we get a triangle sides of a1 + a2 + a3. Then hexagon area is equals to (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Equivalent Strings & 560D - Equivalent StringsLet us note that \"equivalence\" described in the statements is actually equivalence relation, it is reflexively, simmetrically and transitive. It is meant that set of all string is splits to equivalence classes. Let's find lexicographic minimal strings what is equivalent to first and to second given string. And then check if its are equals.It is remain find the lexicographic minimal strings what is equivalent to given. For instance we can do it such a way: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Every recursive call time works is O(n) (where n is length of strings) and string splitten by two twice smaller strings. Therefore time of work this function is , where n is length of strings.559C - Gerald and Giant Chess & 560E - Gerald and Giant ChessLet's denote black cells ad A0, A1, ..., Ak - 1 . First of all, we have to sort black cells in increasing order of (row, column). If cell x available from cell y, x stands after y in this order. Let Ak = (h, w). Now we have to find number of paths from (1, 1) to Ak avoiding A0, ..., Ak - 1.Let Di is number of paths from (1, 1) to Ai avoiding A0, ..., Ai - 1. It's easy to see that Dk is answer for the problem. Number of all paths from (1, 1) to (xi, yi) is . We should subtract from that value all paths containing at least one of previous black cells. We should enumerate first black cell on the path. It could be one of previous cell that is not below or righter than Ai. For each such cell Aj we have to subtract number of paths from (1, 1) to Aj avoiding black cells multiplied by number of all paths from Aj to Ai.We have to calculate factorials of numbers from 1 to 2·105 and inverse elements of them modulo 109 + 7 for calculating binomial coefficients.559D - RandomizerWe can use Pick's theorem for calculate integer points number in every polygon. Integer points number on the segment between points (0, 0) and (a, b) one can calculate over GCD(a, b).Integer points number in some choosen polynom is integer points number in basic polynom minus integer points number in segmnent of basic polynom separated by every segment of choosen polynom.Let consider every potencial segment of polygon. We can calculate integer points number in his segment and probability that we will meet it in choosen polygon.Probability of segment AiAi + k is . Let use note that we can calculate only segments with k < 60 because of other segmnet propapility is too small.559E - Gerald and PathLighted part of walking trail is union of ligted intervals. Let's sort spotlights in increasing order of ai. Consider some lighted interval (a, b). It's lighted by spotlights with numbers {l, l + 1, ..., r} for some l and r (\"substring\" of spotlights). Let x0, ..., xk is all possible boundaries of lighted intervals (numbers ai - li, ai и ai + li).Imagine, that we know possible lighted intervals of all substrings of spotlights. Let left[l][r][j] is least possible i such that set of spotlights with numbers {l, l + 1, ..., r} lighting [xi, xj].With left we can calculate value best[R][i] maximum possible length of walking trail that could be lighted using first L spotlights in such way that xi is rightmost lighted point. It's easy to do in O(n4) because .Now all we have to do is calculate left. Consider some substring of spotlights [l, r]. Let all spotlights in the substring oriented in some way lighting some set of points. We could consider most left (i) and most right (j) lighted points, and left bound of first lighted interval (t). If set of lighted points is interval t = j. Consider how all the values change when we add spotlight r + 1 and choose its orientation. We have new lighted interval [a, b] which is equal to [ai - li, ai] or [ai, ai + li]. Now most left lighted point is min(a, xi), most right is max(b, xj). Right bound of leftmost lighted interval does not changes if a > t or becomes equal to b, if a ≤ t.Not for each L we can calculate dp[r][j][y] least possible i that it's possible to orient spotlights from [L, r] in such way that xi is most left lighted point xj is most right one and right bound of leftmost lighted interval is xt. Thet it's easy to calculate left[L][][]. That part is done in O(n4) too.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 559\\s*C"
          },
          "content_length": 5422
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 3",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 4",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 5",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 6",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 7",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 8",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 9",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 10",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 11",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 12",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 13",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(1, 100000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, h, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, w, \"ci\");\n        inf.readEoln();\n\n        ensuref(!(ri == 1 && ci == 1), \"Black cell cannot be at starting position (1,1)\");\n        ensuref(!(ri == h && ci == w), \"Black cell cannot be at target position (%d,%d)\", h, w);\n\n        pair<int, int> cell = make_pair(ri, ci);\n        ensuref(cells.count(cell) == 0, \"Black cell (%d,%d) is duplicated\", ri, ci);\n        cells.insert(cell);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(1, 100000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, h, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, w, \"ci\");\n        inf.readEoln();\n\n        ensuref(!(ri == 1 && ci == 1), \"Black cell cannot be at starting position (1,1)\");\n        ensuref(!(ri == h && ci == w), \"Black cell cannot be at target position (%d,%d)\", h, w);\n\n        pair<int, int> cell = make_pair(ri, ci);\n        ensuref(cells.count(cell) == 0, \"Black cell (%d,%d) is duplicated\", ri, ci);\n        cells.insert(cell);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(1, 100000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, h, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, w, \"ci\");\n        inf.readEoln();\n\n        ensuref(!(ri == 1 && ci == 1), \"Black cell cannot be at starting position (1,1)\");\n        ensuref(!(ri == h && ci == w), \"Black cell cannot be at target position (%d,%d)\", h, w);\n\n        pair<int, int> cell = make_pair(ri, ci);\n        ensuref(cells.count(cell) == 0, \"Black cell (%d,%d) is duplicated\", ri, ci);\n        cells.insert(cell);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int h = opt<int>(\"h\");\n    int w = opt<int>(\"w\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int,int>> black_cells;\n\n    // Ensure starting and ending cells are not black\n    black_cells.insert({1,1});\n    black_cells.insert({h,w});\n\n    int max_black_cells = h * w - 2; // Excluding start and end cell\n    if (max_black_cells > 2000) max_black_cells = 2000;\n    if (max_black_cells < 0) max_black_cells = 0;\n\n    n = min(n, max_black_cells);\n\n    if (type == \"random\") {\n        while (black_cells.size() < n + 2) { // +2 for start and end cells\n            int ri = rnd.next(1, h);\n            int ci = rnd.next(1, w);\n            if (black_cells.count({ri, ci}) == 0) {\n                black_cells.insert({ri, ci});\n            }\n        }\n    } else if (type == \"block_path\") {\n        // Try to block the path\n        if (h > 1 && w > 1) {\n            black_cells.insert({1,2});\n            black_cells.insert({2,1});\n            n = 2;\n        } else if (h == 1 && w == 1) {\n            // Cannot block path in a 1x1 grid\n            n = 0;\n        } else {\n            // Grid is 1xN or Nx1, block all possible cells except start and end\n            for (int i = 2; i <= (h == 1 ? w - 1 : h - 1); ++i) {\n                if (h == 1) {\n                    black_cells.insert({1,i});\n                } else {\n                    black_cells.insert({i,1});\n                }\n            }\n            n = black_cells.size() - 2;\n        }\n    } else if (type == \"corner_cases\") {\n        // Place black cells near start or end if possible\n        if (h > 1) {\n            black_cells.insert({2,1});\n        }\n        if (w > 1) {\n            black_cells.insert({1,2});\n        }\n        if (h > 1 && w > 0) {\n            black_cells.insert({h - 1, w});\n        }\n        if (w > 1 && h > 0) {\n            black_cells.insert({h, w - 1});\n        }\n        n = black_cells.size() - 2; // Exclude start and end cell\n    } else if (type == \"max_case\") {\n        h = 100000;\n        w = 100000;\n        n = 2000;\n        while (black_cells.size() < n + 2) {\n            int ri = rnd.next(1, h);\n            int ci = rnd.next(1, w);\n            if (black_cells.count({ri, ci}) == 0) {\n                black_cells.insert({ri, ci});\n            }\n        }\n    } else if (type == \"single_row\") {\n        h = 1;\n        int max_black_cells_row = w - 2; // Excluding start and end\n        max_black_cells_row = max(0, min(max_black_cells_row, 2000));\n        n = min(n, max_black_cells_row);\n\n        while (black_cells.size() < n + 2) {\n            int ci = rnd.next(2, w - 1);\n            if (black_cells.count({1, ci}) == 0) {\n                black_cells.insert({1, ci});\n            }\n        }\n    } else if (type == \"single_column\") {\n        w = 1;\n        int max_black_cells_col = h - 2; // Excluding start and end\n        max_black_cells_col = max(0, min(max_black_cells_col, 2000));\n        n = min(n, max_black_cells_col);\n\n        while (black_cells.size() < n + 2) {\n            int ri = rnd.next(2, h - 1);\n            if (black_cells.count({ri,1}) == 0) {\n                black_cells.insert({ri,1});\n            }\n        }\n    } else if (type == \"small_grid\") {\n        h = rnd.next(1, 10);\n        w = rnd.next(1, 10);\n        int max_black_cells_small = h * w - 2; // Excluding start and end\n        max_black_cells_small = max(0, min(max_black_cells_small, 2000));\n        n = min(n, max_black_cells_small);\n\n        while (black_cells.size() < n + 2) {\n            int ri = rnd.next(1, h);\n            int ci = rnd.next(1, w);\n            if (black_cells.count({ri, ci}) == 0) {\n                black_cells.insert({ri, ci});\n            }\n        }\n    } else {\n        // Unrecognized type\n        fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Remove start and end cells from black_cells\n    black_cells.erase({1,1});\n    black_cells.erase({h,w});\n    n = black_cells.size();\n\n    // Ensure n is within bounds\n    if (n < 1) n = 1;\n    if (n > 2000) n = 2000;\n\n    // Output\n    printf(\"%d %d %d\\n\", h, w, n);\n    int output_count = 0;\n    for (auto cell: black_cells) {\n        if (output_count >= n) break;\n        printf(\"%d %d\\n\", cell.first, cell.second);\n        ++output_count;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int h = opt<int>(\"h\");\n    int w = opt<int>(\"w\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int,int>> black_cells;\n\n    // Ensure starting and ending cells are not black\n    black_cells.insert({1,1});\n    black_cells.insert({h,w});\n\n    int max_black_cells = h * w - 2; // Excluding start and end cell\n    if (max_black_cells > 2000) max_black_cells = 2000;\n    if (max_black_cells < 0) max_black_cells = 0;\n\n    n = min(n, max_black_cells);\n\n    if (type == \"random\") {\n        while (black_cells.size() < n + 2) { // +2 for start and end cells\n            int ri = rnd.next(1, h);\n            int ci = rnd.next(1, w);\n            if (black_cells.count({ri, ci}) == 0) {\n                black_cells.insert({ri, ci});\n            }\n        }\n    } else if (type == \"block_path\") {\n        // Try to block the path\n        if (h > 1 && w > 1) {\n            black_cells.insert({1,2});\n            black_cells.insert({2,1});\n            n = 2;\n        } else if (h == 1 && w == 1) {\n            // Cannot block path in a 1x1 grid\n            n = 0;\n        } else {\n            // Grid is 1xN or Nx1, block all possible cells except start and end\n            for (int i = 2; i <= (h == 1 ? w - 1 : h - 1); ++i) {\n                if (h == 1) {\n                    black_cells.insert({1,i});\n                } else {\n                    black_cells.insert({i,1});\n                }\n            }\n            n = black_cells.size() - 2;\n        }\n    } else if (type == \"corner_cases\") {\n        // Place black cells near start or end if possible\n        if (h > 1) {\n            black_cells.insert({2,1});\n        }\n        if (w > 1) {\n            black_cells.insert({1,2});\n        }\n        if (h > 1 && w > 0) {\n            black_cells.insert({h - 1, w});\n        }\n        if (w > 1 && h > 0) {\n            black_cells.insert({h, w - 1});\n        }\n        n = black_cells.size() - 2; // Exclude start and end cell\n    } else if (type == \"max_case\") {\n        h = 100000;\n        w = 100000;\n        n = 2000;\n        while (black_cells.size() < n + 2) {\n            int ri = rnd.next(1, h);\n            int ci = rnd.next(1, w);\n            if (black_cells.count({ri, ci}) == 0) {\n                black_cells.insert({ri, ci});\n            }\n        }\n    } else if (type == \"single_row\") {\n        h = 1;\n        int max_black_cells_row = w - 2; // Excluding start and end\n        max_black_cells_row = max(0, min(max_black_cells_row, 2000));\n        n = min(n, max_black_cells_row);\n\n        while (black_cells.size() < n + 2) {\n            int ci = rnd.next(2, w - 1);\n            if (black_cells.count({1, ci}) == 0) {\n                black_cells.insert({1, ci});\n            }\n        }\n    } else if (type == \"single_column\") {\n        w = 1;\n        int max_black_cells_col = h - 2; // Excluding start and end\n        max_black_cells_col = max(0, min(max_black_cells_col, 2000));\n        n = min(n, max_black_cells_col);\n\n        while (black_cells.size() < n + 2) {\n            int ri = rnd.next(2, h - 1);\n            if (black_cells.count({ri,1}) == 0) {\n                black_cells.insert({ri,1});\n            }\n        }\n    } else if (type == \"small_grid\") {\n        h = rnd.next(1, 10);\n        w = rnd.next(1, 10);\n        int max_black_cells_small = h * w - 2; // Excluding start and end\n        max_black_cells_small = max(0, min(max_black_cells_small, 2000));\n        n = min(n, max_black_cells_small);\n\n        while (black_cells.size() < n + 2) {\n            int ri = rnd.next(1, h);\n            int ci = rnd.next(1, w);\n            if (black_cells.count({ri, ci}) == 0) {\n                black_cells.insert({ri, ci});\n            }\n        }\n    } else {\n        // Unrecognized type\n        fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Remove start and end cells from black_cells\n    black_cells.erase({1,1});\n    black_cells.erase({h,w});\n    n = black_cells.size();\n\n    // Ensure n is within bounds\n    if (n < 1) n = 1;\n    if (n > 2000) n = 2000;\n\n    // Output\n    printf(\"%d %d %d\\n\", h, w, n);\n    int output_count = 0;\n    for (auto cell: black_cells) {\n        if (output_count >= n) break;\n        printf(\"%d %d\\n\", cell.first, cell.second);\n        ++output_count;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -h 3 -w 4 -n 2 -type small_grid\n./gen -h 3 -w 3 -n 1 -type block_path\n./gen -h 2 -w 2 -n 2 -type corner_cases\n./gen -h 100 -w 100 -n 10 -type random\n./gen -h 1 -w 100000 -n 2000 -type single_row\n./gen -h 100000 -w 1 -n 2000 -type single_column\n./gen -h 100000 -w 100000 -n 2000 -type max_case\n./gen -h 99999 -w 99999 -n 1999 -type random\n./gen -h 100000 -w 100000 -n 2000 -type block_path\n./gen -h 1 -w 1 -n 0 -type block_path\n./gen -h 1 -w 100000 -n 0 -type block_path\n./gen -h 100000 -w 1 -n 0 -type block_path\n./gen -h 50000 -w 50000 -n 1 -type corner_cases\n./gen -h 10 -w 10 -n 50 -type small_grid\n./gen -h 1000 -w 1000 -n 1000 -type random\n./gen -h 100000 -w 1 -n 1999 -type corner_cases\n./gen -h 1 -w 100000 -n 1999 -type corner_cases\n./gen -h 2 -w 2 -n 1 -type random\n./gen -h 2 -w 2 -n 3 -type block_path\n./gen -h 100000 -w 100000 -n 2000 -type random\n./gen -h 2 -w 1 -n 1 -type single_column\n./gen -h 1 -w 2 -n 1 -type single_row\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:11.014296",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "559/D",
      "title": "D. Рандомизатор",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных задано единственное число n (3 ≤ n ≤ 100 000) — количество вершин основного многоугольника. В следующих n строках заданы координаты вершины основного многоугольника. В i-й из этих строк заданы два целых числа xi и yi ( - 109 ≤ xi, yi ≤ 109) — координаты i-й вершины многоугольника. Вершины даны в порядке обхода против часовой стрелки.",
      "output_spec": "Выходные данныеВыведите искомое математическое ожидание с абсолютной или относительной погрешностью не более 10 - 9.",
      "sample_tests": "ПримерыВходные данныеСкопировать40 02 02 20 2Выходные данныеСкопировать0.2Входные данныеСкопировать50 02 02 21 30 2Выходные данныеСкопировать0.8125",
      "description": "D. Рандомизатор\n\nограничение по времени на тест2.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных задано единственное число n (3 ≤ n ≤ 100 000) — количество вершин основного многоугольника. В следующих n строках заданы координаты вершины основного многоугольника. В i-й из этих строк заданы два целых числа xi и yi ( - 109 ≤ xi, yi ≤ 109) — координаты i-й вершины многоугольника. Вершины даны в порядке обхода против часовой стрелки.\n\nВходные данные\n\nВыходные данныеВыведите искомое математическое ожидание с абсолютной или относительной погрешностью не более 10 - 9.\n\nВыходные данные\n\nВходные данныеСкопировать40 02 02 20 2Выходные данныеСкопировать0.2Входные данныеСкопировать50 02 02 21 30 2Выходные данныеСкопировать0.8125\n\nВходные данныеСкопировать40 02 02 20 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать50 02 02 21 30 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.8125\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеМногоугольник называется строго выпуклым, если он выпуклый, и никакие три его вершины не лежат на одной прямой.Пусть случайная величина принимает значения x1, ..., xn с вероятностями p1, ..., pn соответственно. Тогда математическое ожидание этой случайной величины равняется .",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Доброго всем времени суток!Приглашаю Вас поучаствовать в 313 Codeforces раунде, над которыми для вас работали я и tunyash. У каждого из нас за плечами по четыре раунда, так что это наш пятый или девятый раунд, как хотите. Я придумал почти все задачи (кроме D div.1), написал условия и разбор всех задач, а tunyash занимался разработкой всех задач.Gerald уже не является координатором, так что, возможно, Вы по нему соскучились. В этом раунде вы снова с ним встретитесь и поможете ему разобраться в его повседневных жизненных проблемах.Спасибо координатору Zlobober, нашей переводчице Марии Беловой (Delinur), а так же MikeMirzayanov и всей команде Codeforces за эту платформу.Этот раунд состоится в необычное время — 17:00 по Московскому времени.Соревнование закончилось, добро пожаловать в разбор! Краткий разбор. Подробный разбор.Разбалловка в первом дивизионе будет следующая:500 — 1000 — 1500 — 2250 — 2250А во втором дивизионе — стандартная:500 — 1000 — 1500 — 2000 — 2500Желаю всем получить удовольствие от решения задач!Поздравляем победителей!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1200
        },
        {
          "title": "VK Cup 2015: онлайн-трансляция и порция благодарностей - Codeforces",
          "content": "Мы были вынуждены удалить регистрации, сделанные до 00:00, так как регистрационная форма на тот момент не поддерживала регистрацию команд. Пожалуйста, пройдите регистрацию вновь, если ваша регистрация была удалена.Вчера завершился финал чемпионата VK Cup 2015, о котором вы могли прочитать в предыдущих наших постах. Осталось объявить последнее событие, связанное с прошедшим чемпионатом — онлайн-трансляцию, которая состоится в четверг 30 июля в 19:00 по Москве. К соревнованию допускаются как индивидуальные участники, так и команды из двух человек, которые желают почувствовать себя участниками финала соревнования. Трансляция продлится три часа, задачи будут перемешаны по сравнению с оригинальным порядком. Допускаются участники обоих дивизионом, но мы считаем своим долгом предупредить, что для участников из второго дивизиона набор задач, скорее всего, будет слишком сложным. Этот раунд является рейтинговым раундом Codeforces.В заключение мы хотели бы поблагодарить всех людей, которые помогли чемпионату состояться. Придумывали и готовили задачи для вас сотрудники ВКонтакте, члены команды Codeforces и другие люди, любезно предложившие свою помощь: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. Хочется сказать большое спасибо людям, прорешивавшим наши раунды, и дававшим ценные советы по поводу задач: winger и AlexFetisov. Также, мы благодарим всех работников ВКонтакте, с которыми вместе мы занимались проведением чемпионата: burunduk3, Burunduk2, KOTEHOK и многих других. Спасибо!Всем удачи на онлайн-трансляции!UPD: Обратите внимание, что во время раунда команде разрешается пользоваться только одним компьютером. Это значит, что программировать/пользоваться консолью/как-либо иначе продвигаться в решении задач в один момент времени можно только с одного компьютера. Единственное, что разрешается делать с двух компьютеров — это читать условия. UPD2: Так как это командное соревнование, специально для вашего удобства мы выкладываем запароленный архив с pdf-условиями задач: vkcup2015-mirror-statements.zip. С началом тура мы опубликуем пароль к нему.UPD3: В раунде будет использована динамическая разбалловка с шагом в 250 очков.UPD4: По техническим причинам начало раунда переносится на 19:20 по Москве.UPD5: Пароль на архив с условиями: vkcup4ever. Удачи!UPD6: Онлайн-трансляция завершена! Поздравляем победителей: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Мой персональный респектам команде Petr team: Petr, ilyakor за единственное решение по задаче Е в трансляции, пользователю rng_58 и команде Excited: YuukaKazami, jqdai0815 за два правильных решения по задаче С.Также, поздравляем пользователя rng_58, который продемонстрировал, что одиночному пользователю есть что противопоставить командам, состоящим из двух людей!Рейтинг будет пересчитан в ближайшее время.UPD7: Разбор!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2993
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces",
          "content": "560A - Денежная система ГеральдионаВ этой задаче главное — заметить, что если есть купюра номинала 1, то любую сумму денег можно выдать единичными купюрами. Если же такой купюры нет, то как раз сумму 1 представить нельзя. Поэтому, если нет купюры номинала 1, то ответ — 1, а если такая купюра есть — то -1.560B - Геральд увлекается исскусствомЛегко заметить, что можно прижать две картины друг в другу какими-то двумя краями, например, разместить одну картину прямо над другой. Тогда высота двух картин будет суммой высот картин, а ширина — максимум из ширин картин. Осталось перебрать все варианты, как повёрнуты картины и как при этом повёрнут стенд. Вот реализация.559A - Шестиугольник Геральда & 560C - Шестиугольник ГеральдаСперва заметим, что если правильный треугольник с целой стороной k отрезками, параллельными сторонам, разделить на правильные треугольники со стороной 1 (тут появляется картинка), то площадь большого треугольника будет в k2 раз больше площадей маленьких треугольничков и, следовательно, треугольник окажется разделён ровно на k2 единичных треугольничков.Далее, заметим, что если к сторонам a1, a3 и a5 шестиугольника пририсовать по правильному треугольнику со сторонами a1, a3 и a5 соответственно (и тут появляется ещё одна картинка), то получится большой правильный треугольник со стороной a1 + a2 + a3. Таким образом, площадь исходного шестиугольника равна (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Эквивалентные строки & 560D - Эквивалентные строкиНетрудно заметить, что \"эквивалентность\", описанная в задаче, в самом деле является отношением эквивалентности, то есть, оно симметрично, транзитивно и рефлексивно. Подробнее от отношениях эквивалентности можно почитать здесь. В частности, это означает, что все строки разбиваются на классы эквивалентности и нам надо проверить, что данные нам две строки принадлежат одному и тому же классу. Для этого давайте найдём лексикографически минимальную строку, которая лежит в одном классе эквивалентности с каждой из строк. Иными словами, найдём лексикографически минимальную строку, эквивалентную каждой из данных строк и проверим, получилась ли одна и та же строка.Осталось научиться находить лексикографически минимальную строку, эквивалентную данной, за приемлемое время. Это можно сделать, например, следующей рекурсивной функцией: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Поскольку каждый рекурсивный вызов работает линейно от длины переданной ему строки и внутри функции она сама два раза вызывается от вдвое меньшей строки, эта функция работает за время , где n — длина строки.559C - Геральд и гигантские шахматы & 560E - Геральд и гигантские шахматыОбозначим все чёрные клетки как A0, A1, ..., Ak - 1. Для начала, упорядочим чёрные клетки в порядке сверху вниз, а те, которые на одной высоте — слева направо. Теперь все чёрные клетки, из которых пешка Геральда могла бы попасть в данную чёрную клетку, находятся до неё. Покрасим нижнюю правую клетку в чёрный цвет и тоже добавим её в список чёрных клеток под номером k. Теперь пешке Геральда надо попасть в последнюю чёрную клетку, миновав все остальные.Посчитаем величину Di — количество способов попасть в Ai, миновав все предыдущие чёрные клетки. Как несложно заметить, ответом на задачу будет Dk. Общее количество способов дойти из клетки (1, 1) в клетку (xi, yi) равно . Вычтем из этого количества все способы попасть в Ai, зайдя по пути в одну из предыдущих чёрных клеток. Для этого переберём, какая из чёрных клеток могла первой попасться на пути. Это должна быть какая-то из предыдущих чёрных клеток, находящаяся не ниже и не правее, чем Ai. Для каждой такой клетки Aj надо вычесть произведение количества способов попасть в Aj, минуя все предыдущие чёрные клетки и количества способов просто попасть из Aj в Ai.Для вычисления биномиальных коэффициентов придётся преподсчитать факториалы всех чисел до 2·105 и научиться брать обратные к ним по модулю 109 + 7.559D - РандомизаторДля начала, вспомним формулу Пика. Благодаря ней, количество целых точек внутри любого многоугольника можно вычислить, зная его площадь и количество целых точек на границе. Количество целых точек на отрезке, соединяющем точки (0, 0) и (a, b) можно посчитать, найдя НОД(a, b).Давайте вычислим общее количество целых точек в основном многоугольнике, а затем для каждого отрезка, соединяющего какие-то две вершины многоугольника, вычтем из этой величины произведение вероятности того, что этот отрезок будет стороной выбранного многоугольника и количество целых точек в сегменте основного многоугольника, который отсекает этот отрезок. Вероятность легко посчитать. Если отрезок соединяет вершины Ai и Ai + k, то существует ровно 2n - k - 1 - 1 многоугольник, в котором есть такая сторона, а общее количество валидных многоугольников равняется .Количество целых точек в отсекаемом отрезком AiAi + k сегменте тоже легко посчитать с помощью с формулы Пика за время O(k), а если воспользоваться тем, что перед этим мы посчитали количество целых точек в сегменте, отсекаемом AiAi + k - 1, можно сделать это за время O(1).Таким образом, получается решение за время ( -- время вычисления НОД двух натуральных чисел, не превосходящих MAX). Это, конечно, слишком много.Давайте обратим внимание на вероятность появления каждой из сторон. Вероятность появления в многоугольнике стороны, пропускающей k - 1 вершину многоугольника, равна . Как видно, эта вероятность экспоненциально падает с ростом k. В частности, если общее количество целых точек в многоугольнике равно V, то сумма всех слагаемых, соответствующих отрезкам с k ≥ 60 не превосходит . Таким образом, все слагаемые, соответствующие отрезкам с k ≥ 60, можно просто игнорировать. Следует отметить, что 60 — это очень грубая оценка, не учитывающая, что для большинства отрезков вероятность будет гораздо меньше, чем 2 - 60, а для отрезков с k порядка 60 количество целых точек внутри сегмента будет порядка , а вовсе не порядка V.Таким образом, мы получаем решение за время , поскольку 60 — это ни что иное, как .559E - Геральд и тропинкаОсвещённая часть тропинки представляет собой объединение нескольких непересекающихся освещенных отрезков (возможно, одного). Давайте упорядочим прожекторы по возрастанию ai. Заметим, что каждый освещенный отрезок освещается некоторой \"подстрокой\" прожекторов, то есть, множеством прожекторов с номерами из некоторого отрезка [l, r]. Пусть x0, ..., xk — упорядоченная последовательность потенциальных концов отрезков, то есть, всех чисел вида ai - li, ai и ai + li.Представим себе, что мы знаем, какие именно отрезки тропинки можно осветить с помощью каждой подстроки прожекторов. Сохраним в массив left[][][] информацию о самых длинных возможных освещенных отрезках в следующем виде: left[l][r][j] — самое маленькое такое i, что подстрока [l, r] прожекторов может освещать отрезок [xi, xj].Теперь, имея массив left, посчитаем динамикой величину best[R][i] — какую максимальную длину тропинки можно осветить, используя первые L прожекторов так, чтобы самой правой освещённой точкой была xi. Это легко сделать за время O(n4), так как .Теперь давайте вычислим массив left. Рассмотрим некую подстроку прожекторов [l, r]. Пусть все прожекторы этой подстроки как-то ориентированы и освещают некоторую область тропинки. У этой области можно рассмотреть самую левую (i) и самую правую (j) освещенную точки, а также правый конец самого левого освещенного отрезка (t). Если область является одним отрезком, то t = j. Рассмотрим, как меняются эти три параметра, когда мы добавляем к подстроке прожектор r + 1 и выбираем его ориентацию. К освещенной области добавляется отрезок [a, b], который равен [ai - li, ai] или [ai, ai + li]. Самая левая освещенная точка становится min(a, xi), самая правая — max(b, xj). А правый конец самого левого отрезка не меняется, если a > t или становится b, если a ≤ t.Эти соотношения позволяют для каждого фиксированного L вычислить динамикой величину dp[r][j][y] — наименьшее такое i, что можно ориентировать прожекторы подстроки [L, r] так, чтобы самая левая освещенная точка была xi, самая правая — xj, а правый конец самого левого отрезка — xt. Вычислив это, уже легко посчитать значения массива left[L][][]. Эта часть решения тоже будет работать за время O(n4).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 559\\s*D"
          },
          "content_length": 8382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 3",
          "code": "T(n) = 4*T(n / 2) => T(n) = n^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 4",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 5",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 6",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 7",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 8",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 9",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 10",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 11",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 12",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 13",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 14",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 15",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 16",
          "code": "cout << fixed",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 17",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 18",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 19",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 20",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 21",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> xs(n), ys(n);\n    for (int i = 0; i < n; i++) {\n        xs[i] = inf.readInt(-1000000000, 1000000000, \"x_i\");\n        inf.readSpace();\n        ys[i] = inf.readInt(-1000000000, 1000000000, \"y_i\");\n        inf.readEoln();\n    }\n\n    // Check that the polygon is strictly convex and given in counter-clockwise order\n    // Compute all cross products\n    for (int i = 0; i < n; i++) {\n        int x0 = xs[i];\n        int y0 = ys[i];\n        int x1 = xs[(i+1)%n];\n        int y1 = ys[(i+1)%n];\n        int x2 = xs[(i+2)%n];\n        int y2 = ys[(i+2)%n];\n\n        ll dx1 = (ll)x1 - x0;\n        ll dy1 = (ll)y1 - y0;\n        ll dx2 = (ll)x2 - x1;\n        ll dy2 = (ll)y2 - y1;\n\n        ll z = dx1 * dy2 - dy1 * dx2;\n\n        ensuref(z > 0, \"The polygon is not strictly convex at vertex %d\", ((i+1)%n) +1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> xs(n), ys(n);\n    for (int i = 0; i < n; i++) {\n        xs[i] = inf.readInt(-1000000000, 1000000000, \"x_i\");\n        inf.readSpace();\n        ys[i] = inf.readInt(-1000000000, 1000000000, \"y_i\");\n        inf.readEoln();\n    }\n\n    // Check that the polygon is strictly convex and given in counter-clockwise order\n    // Compute all cross products\n    for (int i = 0; i < n; i++) {\n        int x0 = xs[i];\n        int y0 = ys[i];\n        int x1 = xs[(i+1)%n];\n        int y1 = ys[(i+1)%n];\n        int x2 = xs[(i+2)%n];\n        int y2 = ys[(i+2)%n];\n\n        ll dx1 = (ll)x1 - x0;\n        ll dy1 = (ll)y1 - y0;\n        ll dx2 = (ll)x2 - x1;\n        ll dy2 = (ll)y2 - y1;\n\n        ll z = dx1 * dy2 - dy1 * dx2;\n\n        ensuref(z > 0, \"The polygon is not strictly convex at vertex %d\", ((i+1)%n) +1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> xs(n), ys(n);\n    for (int i = 0; i < n; i++) {\n        xs[i] = inf.readInt(-1000000000, 1000000000, \"x_i\");\n        inf.readSpace();\n        ys[i] = inf.readInt(-1000000000, 1000000000, \"y_i\");\n        inf.readEoln();\n    }\n\n    // Check that the polygon is strictly convex and given in counter-clockwise order\n    // Compute all cross products\n    for (int i = 0; i < n; i++) {\n        int x0 = xs[i];\n        int y0 = ys[i];\n        int x1 = xs[(i+1)%n];\n        int y1 = ys[(i+1)%n];\n        int x2 = xs[(i+2)%n];\n        int y2 = ys[(i+2)%n];\n\n        ll dx1 = (ll)x1 - x0;\n        ll dy1 = (ll)y1 - y0;\n        ll dx2 = (ll)x2 - x1;\n        ll dy2 = (ll)y2 - y1;\n\n        ll z = dx1 * dy2 - dy1 * dx2;\n\n        ensuref(z > 0, \"The polygon is not strictly convex at vertex %d\", ((i+1)%n) +1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pll> points;\n\n    if (type == \"random\") {\n        // Generate random convex polygon using method from O'Rourke's computational geometry\n        vector<ll> X(n), Y(n);\n        ll W = 1e9, H = 1e9;\n\n        for (int i = 0; i < n; ++i)\n            X[i] = rnd.next(-W, W);\n\n        for (int i = 0; i < n; ++i)\n            Y[i] = rnd.next(-H, H);\n\n        sort(X.begin(), X.end());\n        sort(Y.begin(), Y.end());\n\n        vector<ll> xLeft, xRight, yLeft, yRight;\n\n        for (int i = 0; i < n - 1; ++i) {\n            if (rnd.next(0, 1)) {\n                xLeft.push_back(X[i]);\n            } else {\n                xRight.push_back(X[i]);\n            }\n        }\n        xLeft.push_back(X[n - 1]);\n\n        for (int i = 0; i < n - 1; ++i) {\n            if (rnd.next(0, 1)) {\n                yLeft.push_back(Y[i]);\n            } else {\n                yRight.push_back(Y[i]);\n            }\n        }\n        yLeft.push_back(Y[n - 1]);\n\n        sort(xLeft.begin(), xLeft.end());\n        sort(xRight.begin(), xRight.end(), greater<ll>());\n        sort(yLeft.begin(), yLeft.end());\n        sort(yRight.begin(), yRight.end(), greater<ll>());\n\n        for (size_t i = 0; i < xLeft.size(); ++i)\n            points.push_back(make_pair(xLeft[i], yLeft[i]));\n        for (size_t i = 0; i < xRight.size(); ++i)\n            points.push_back(make_pair(xRight[i], yRight[i]));\n    } else if (type == \"circle\") {\n        double R = 1e9 * 0.7;\n        double cx = rnd.next(-1e8, 1e8);\n        double cy = rnd.next(-1e8, 1e8);\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * M_PI * i / n;\n            double x = cx + R * cos(angle);\n            double y = cy + R * sin(angle);\n            ll xi = (ll)(x + 0.5); // round to nearest integer\n            ll yi = (ll)(y + 0.5); // round to nearest integer\n            points.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"maxint\") {\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1e9 + 1, 1e9 - 1);\n            ll y = rnd.next(-1e9 + 1, 1e9 - 1);\n            points.push_back(make_pair(x, y));\n        }\n    } else if (type == \"grid\") {\n        int s = sqrt(n);\n        s = max(s, 2);\n        for (int i = 0; i < s && (int)points.size() < n; ++i) {\n            for (int j = 0; j < s && (int)points.size() < n; ++j) {\n                ll x = i * 10000000;\n                ll y = j * 10000000;\n                points.push_back(make_pair(x, y));\n            }\n        }\n    } else if (type == \"rectangle\") {\n        ll minX = -1e9 / 2;\n        ll maxX = 1e9 / 2;\n        ll minY = -1e9 / 2;\n        ll maxY = 1e9 / 2;\n\n        points.push_back(make_pair(minX, minY));\n        points.push_back(make_pair(maxX, minY));\n        points.push_back(make_pair(maxX, maxY));\n        points.push_back(make_pair(minX, maxY));\n\n        // Fill remaining points inside the rectangle\n        for (int i = 4; i < n; ++i) {\n            ll x = rnd.next(minX + 1, maxX - 1);\n            ll y = rnd.next(minY + 1, maxY - 1);\n            points.push_back(make_pair(x, y));\n        }\n    } else if (type == \"triangle\") {\n        points.push_back(make_pair(0, 0));\n        points.push_back(make_pair(1e9, 0));\n        points.push_back(make_pair(0, 1e9));\n\n        // Fill remaining points inside the triangle\n        for (int i = 3; i < n; ++i) {\n            ll x = rnd.next(1LL, (ll)1e9 - 1);\n            ll y = rnd.next(1LL, (ll)1e9 - x);\n            points.push_back(make_pair(x, y));\n        }\n    }\n\n    // Compute Convex Hull to ensure strict convexity and order\n    auto cross = [](pll O, pll A, pll B) {\n        return (A.first - O.first) * (B.second - O.second) -\n               (A.second - O.second) * (B.first - O.first);\n    };\n    int m = points.size();\n    sort(points.begin(), points.end());\n    vector<pll> H(2 * m);\n    int k = 0;\n\n    // Build lower hull\n    for (int i = 0; i < m; ++i) {\n        while (k >= 2 && cross(H[k - 2], H[k - 1], points[i]) <= 0)\n            k--;\n        H[k++] = points[i];\n    }\n\n    // Build upper hull\n    for (int i = m - 2, t = k + 1; i >= 0; --i) {\n        while (k >= t && cross(H[k - 2], H[k - 1], points[i]) <= 0)\n            k--;\n        H[k++] = points[i];\n    }\n\n    H.resize(k - 1);\n    points = H;\n    n = points.size();\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output vertices in counter-clockwise order\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld %lld\\n\", points[i].first, points[i].second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pll> points;\n\n    if (type == \"random\") {\n        // Generate random convex polygon using method from O'Rourke's computational geometry\n        vector<ll> X(n), Y(n);\n        ll W = 1e9, H = 1e9;\n\n        for (int i = 0; i < n; ++i)\n            X[i] = rnd.next(-W, W);\n\n        for (int i = 0; i < n; ++i)\n            Y[i] = rnd.next(-H, H);\n\n        sort(X.begin(), X.end());\n        sort(Y.begin(), Y.end());\n\n        vector<ll> xLeft, xRight, yLeft, yRight;\n\n        for (int i = 0; i < n - 1; ++i) {\n            if (rnd.next(0, 1)) {\n                xLeft.push_back(X[i]);\n            } else {\n                xRight.push_back(X[i]);\n            }\n        }\n        xLeft.push_back(X[n - 1]);\n\n        for (int i = 0; i < n - 1; ++i) {\n            if (rnd.next(0, 1)) {\n                yLeft.push_back(Y[i]);\n            } else {\n                yRight.push_back(Y[i]);\n            }\n        }\n        yLeft.push_back(Y[n - 1]);\n\n        sort(xLeft.begin(), xLeft.end());\n        sort(xRight.begin(), xRight.end(), greater<ll>());\n        sort(yLeft.begin(), yLeft.end());\n        sort(yRight.begin(), yRight.end(), greater<ll>());\n\n        for (size_t i = 0; i < xLeft.size(); ++i)\n            points.push_back(make_pair(xLeft[i], yLeft[i]));\n        for (size_t i = 0; i < xRight.size(); ++i)\n            points.push_back(make_pair(xRight[i], yRight[i]));\n    } else if (type == \"circle\") {\n        double R = 1e9 * 0.7;\n        double cx = rnd.next(-1e8, 1e8);\n        double cy = rnd.next(-1e8, 1e8);\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * M_PI * i / n;\n            double x = cx + R * cos(angle);\n            double y = cy + R * sin(angle);\n            ll xi = (ll)(x + 0.5); // round to nearest integer\n            ll yi = (ll)(y + 0.5); // round to nearest integer\n            points.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"maxint\") {\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1e9 + 1, 1e9 - 1);\n            ll y = rnd.next(-1e9 + 1, 1e9 - 1);\n            points.push_back(make_pair(x, y));\n        }\n    } else if (type == \"grid\") {\n        int s = sqrt(n);\n        s = max(s, 2);\n        for (int i = 0; i < s && (int)points.size() < n; ++i) {\n            for (int j = 0; j < s && (int)points.size() < n; ++j) {\n                ll x = i * 10000000;\n                ll y = j * 10000000;\n                points.push_back(make_pair(x, y));\n            }\n        }\n    } else if (type == \"rectangle\") {\n        ll minX = -1e9 / 2;\n        ll maxX = 1e9 / 2;\n        ll minY = -1e9 / 2;\n        ll maxY = 1e9 / 2;\n\n        points.push_back(make_pair(minX, minY));\n        points.push_back(make_pair(maxX, minY));\n        points.push_back(make_pair(maxX, maxY));\n        points.push_back(make_pair(minX, maxY));\n\n        // Fill remaining points inside the rectangle\n        for (int i = 4; i < n; ++i) {\n            ll x = rnd.next(minX + 1, maxX - 1);\n            ll y = rnd.next(minY + 1, maxY - 1);\n            points.push_back(make_pair(x, y));\n        }\n    } else if (type == \"triangle\") {\n        points.push_back(make_pair(0, 0));\n        points.push_back(make_pair(1e9, 0));\n        points.push_back(make_pair(0, 1e9));\n\n        // Fill remaining points inside the triangle\n        for (int i = 3; i < n; ++i) {\n            ll x = rnd.next(1LL, (ll)1e9 - 1);\n            ll y = rnd.next(1LL, (ll)1e9 - x);\n            points.push_back(make_pair(x, y));\n        }\n    }\n\n    // Compute Convex Hull to ensure strict convexity and order\n    auto cross = [](pll O, pll A, pll B) {\n        return (A.first - O.first) * (B.second - O.second) -\n               (A.second - O.second) * (B.first - O.first);\n    };\n    int m = points.size();\n    sort(points.begin(), points.end());\n    vector<pll> H(2 * m);\n    int k = 0;\n\n    // Build lower hull\n    for (int i = 0; i < m; ++i) {\n        while (k >= 2 && cross(H[k - 2], H[k - 1], points[i]) <= 0)\n            k--;\n        H[k++] = points[i];\n    }\n\n    // Build upper hull\n    for (int i = m - 2, t = k + 1; i >= 0; --i) {\n        while (k >= t && cross(H[k - 2], H[k - 1], points[i]) <= 0)\n            k--;\n        H[k++] = points[i];\n    }\n\n    H.resize(k - 1);\n    points = H;\n    n = points.size();\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output vertices in counter-clockwise order\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld %lld\\n\", points[i].first, points[i].second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type triangle\n./gen -n 5 -type triangle\n\n./gen -n 4 -type rectangle\n./gen -n 6 -type rectangle\n\n./gen -n 3 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n./gen -n 3 -type circle\n./gen -n 5 -type circle\n./gen -n 10 -type circle\n./gen -n 100 -type circle\n./gen -n 1000 -type circle\n./gen -n 10000 -type circle\n./gen -n 100000 -type circle\n\n./gen -n 3 -type maxint\n./gen -n 5 -type maxint\n./gen -n 10 -type maxint\n./gen -n 100 -type maxint\n./gen -n 1000 -type maxint\n./gen -n 10000 -type maxint\n./gen -n 100000 -type maxint\n\n./gen -n 3 -type grid\n./gen -n 5 -type grid\n./gen -n 10 -type grid\n./gen -n 100 -type grid\n./gen -n 1000 -type grid\n./gen -n 10000 -type grid\n./gen -n 100000 -type grid\n\n./gen -n 100000 -type triangle\n./gen -n 100000 -type rectangle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:12.792433",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "559/E",
      "title": "E. Gerald and Path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of spotlights. Each of the n lines contains two space-separated integers, ai and li (0 ≤ ai ≤ 108, 1 ≤ li ≤ 108). Number ai shows how much further the i-th spotlight to the north, and number li shows the length of the segment it illuminates.It is guaranteed that all the ai's are distinct.",
      "output_spec": "OutputPrint a single integer — the maximum total length of the illuminated part of the path.",
      "sample_tests": "ExamplesInputCopy31 12 23 3OutputCopy5InputCopy41 23 34 36 2OutputCopy9",
      "description": "E. Gerald and Path\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of spotlights. Each of the n lines contains two space-separated integers, ai and li (0 ≤ ai ≤ 108, 1 ≤ li ≤ 108). Number ai shows how much further the i-th spotlight to the north, and number li shows the length of the segment it illuminates.It is guaranteed that all the ai's are distinct.\n\nOutputPrint a single integer — the maximum total length of the illuminated part of the path.\n\nInputCopy31 12 23 3OutputCopy5InputCopy41 23 34 36 2OutputCopy9\n\nInputCopy31 12 23 3\n\nOutputCopy5\n\nInputCopy41 23 34 36 2\n\nOutputCopy9",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the Codeforces round 313, which is prepeared by me and tunyash. Each of us is prepared four rounds then it is our fifth of ninth round to your notice. I figured out almost all problems (except D div.1), wrote the statements and analysis of all the problems, and tunyash has developed all problems.Gerald is not coordinator yet and you probobly missed him. In this round you will meet him again and help him in his ordinary life problems.I want to thank Zlobober, our translator Maria Belova (Delinur) and MikeMirzayanov and all Codeforces team for this platform.This round will be held in unusual time — 17:00 Moscow Time.Contest finished! Welcome to editoral: Short editoral. Extended editoral.Div.1 scoring distribution:500 — 1000 — 1500 — 2250 — 2250Div.2 scoring distribution:500 — 1000 — 1500 — 2000 — 2500I wish you to enjoy solving problems!Congratulations to winners!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1073
        },
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces",
          "content": "560A - Currency System in GeraldionIf there is a banlnot of value 1 then one can to express every sum of money. Otherwise one can't to express 1 and it is minimum unfortunate sum.560B - Gerald is into ArtIt is easy to see that one can snuggle paintings to each other and to edge of board. For instance one can put one of painting right over other. Then height of two paintings equals to sum of two heights and width of two paintings is equals to maximum of two widths. Now we can just iterate orientation of paintings and board.559A - Gerald's Hexagon & 560C - Gerald's HexagonLet's consider regular triangle with sides of k Let's split it to regular triangles with sides of 1 by lines parallel to the sides. Big triange area k2 times larger then small triangles area and therefore big triangle have splitted by k2 small triangles.If we join regular triangles to sides a1, a3 and a5 of hexagon we get a triangle sides of a1 + a2 + a3. Then hexagon area is equals to (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Equivalent Strings & 560D - Equivalent StringsLet us note that \"equivalence\" described in the statements is actually equivalence relation, it is reflexively, simmetrically and transitive. It is meant that set of all string is splits to equivalence classes. Let's find lexicographic minimal strings what is equivalent to first and to second given string. And then check if its are equals.It is remain find the lexicographic minimal strings what is equivalent to given. For instance we can do it such a way: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Every recursive call time works is O(n) (where n is length of strings) and string splitten by two twice smaller strings. Therefore time of work this function is , where n is length of strings.559C - Gerald and Giant Chess & 560E - Gerald and Giant ChessLet's denote black cells ad A0, A1, ..., Ak - 1 . First of all, we have to sort black cells in increasing order of (row, column). If cell x available from cell y, x stands after y in this order. Let Ak = (h, w). Now we have to find number of paths from (1, 1) to Ak avoiding A0, ..., Ak - 1.Let Di is number of paths from (1, 1) to Ai avoiding A0, ..., Ai - 1. It's easy to see that Dk is answer for the problem. Number of all paths from (1, 1) to (xi, yi) is . We should subtract from that value all paths containing at least one of previous black cells. We should enumerate first black cell on the path. It could be one of previous cell that is not below or righter than Ai. For each such cell Aj we have to subtract number of paths from (1, 1) to Aj avoiding black cells multiplied by number of all paths from Aj to Ai.We have to calculate factorials of numbers from 1 to 2·105 and inverse elements of them modulo 109 + 7 for calculating binomial coefficients.559D - RandomizerWe can use Pick's theorem for calculate integer points number in every polygon. Integer points number on the segment between points (0, 0) and (a, b) one can calculate over GCD(a, b).Integer points number in some choosen polynom is integer points number in basic polynom minus integer points number in segmnent of basic polynom separated by every segment of choosen polynom.Let consider every potencial segment of polygon. We can calculate integer points number in his segment and probability that we will meet it in choosen polygon.Probability of segment AiAi + k is . Let use note that we can calculate only segments with k < 60 because of other segmnet propapility is too small.559E - Gerald and PathLighted part of walking trail is union of ligted intervals. Let's sort spotlights in increasing order of ai. Consider some lighted interval (a, b). It's lighted by spotlights with numbers {l, l + 1, ..., r} for some l and r (\"substring\" of spotlights). Let x0, ..., xk is all possible boundaries of lighted intervals (numbers ai - li, ai и ai + li).Imagine, that we know possible lighted intervals of all substrings of spotlights. Let left[l][r][j] is least possible i such that set of spotlights with numbers {l, l + 1, ..., r} lighting [xi, xj].With left we can calculate value best[R][i] maximum possible length of walking trail that could be lighted using first L spotlights in such way that xi is rightmost lighted point. It's easy to do in O(n4) because .Now all we have to do is calculate left. Consider some substring of spotlights [l, r]. Let all spotlights in the substring oriented in some way lighting some set of points. We could consider most left (i) and most right (j) lighted points, and left bound of first lighted interval (t). If set of lighted points is interval t = j. Consider how all the values change when we add spotlight r + 1 and choose its orientation. We have new lighted interval [a, b] which is equal to [ai - li, ai] or [ai, ai + li]. Now most left lighted point is min(a, xi), most right is max(b, xj). Right bound of leftmost lighted interval does not changes if a > t or becomes equal to b, if a ≤ t.Not for each L we can calculate dp[r][j][y] least possible i that it's possible to orient spotlights from [L, r] in such way that xi is most left lighted point xj is most right one and right bound of leftmost lighted interval is xt. Thet it's easy to calculate left[L][][]. That part is done in O(n4) too.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 559\\s*E"
          },
          "content_length": 5422
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 3",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 4",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 5",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 6",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 7",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 8",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 9",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 10",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 11",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 12",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 13",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> a_set;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 100000000, \"ai\");\n        inf.readSpace();\n        int li = inf.readInt(1, 100000000, \"li\");\n        inf.readEoln();\n\n        // All ai's must be distinct\n        ensuref(a_set.find(ai) == a_set.end(), \"All ai's must be distinct, but ai=%d occurs more than once\", ai);\n        a_set.insert(ai);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> a_set;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 100000000, \"ai\");\n        inf.readSpace();\n        int li = inf.readInt(1, 100000000, \"li\");\n        inf.readEoln();\n\n        // All ai's must be distinct\n        ensuref(a_set.find(ai) == a_set.end(), \"All ai's must be distinct, but ai=%d occurs more than once\", ai);\n        a_set.insert(ai);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> a_set;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 100000000, \"ai\");\n        inf.readSpace();\n        int li = inf.readInt(1, 100000000, \"li\");\n        inf.readEoln();\n\n        // All ai's must be distinct\n        ensuref(a_set.find(ai) == a_set.end(), \"All ai's must be distinct, but ai=%d occurs more than once\", ai);\n        a_set.insert(ai);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        printf(\"%d\\n\", n);\n        printf(\"0 1\\n\");\n        return 0;\n    }\n\n    vector<int> a(n);\n    vector<int> l(n);\n\n    if (type == \"max_random\") {\n        // Generate n unique ai in [0, 1e8]\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n\n        // Generate li randomly in [1, 1e8]\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    } else if (type == \"overlapping\") {\n        // All ai in a small range, li large enough to overlap\n        int base_ai = rnd.next(0, (int)(1e8 - n - 1e7));\n        for (int i = 0; i < n; ++i) {\n            a[i] = base_ai + i;  // Consecutive positions\n            l[i] = (int)1e8 - base_ai; // Large li to cover up to 1e8\n        }\n    } else if (type == \"non_overlapping\") {\n        // Set ai and li so that no overlaps occur if directed appropriately\n        int gap = (int)(1e8 / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = i * gap;\n            l[i] = gap / 2;\n        }\n    } else if (type == \"edge_ai_zero\") {\n        // ai starting from 0\n        for (int i = 0; i < n; ++i) {\n            a[i] = i; // Ensure uniqueness\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    } else if (type == \"edge_ai_max\") {\n        // ai near 1e8\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)(1e8 - n + i);\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    } else if (type == \"max_li\") {\n        // li = 1e8\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n        for (int i = 0; i < n; ++i) {\n            l[i] = (int)1e8;\n        }\n    } else if (type == \"min_li\") {\n        // li = 1\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n        for (int i = 0; i < n; ++i) {\n            l[i] = 1;\n        }\n    } else if (type == \"mixed\") {\n        set<int> positions;\n        for (int i = 0; i < n; ++i) {\n            int ai;\n            if (i % 5 == 0) {\n                // ai near 0\n                ai = rnd.next(0, (int)1e4);\n            } else if (i % 5 == 1) {\n                // ai near 1e8\n                ai = rnd.next((int)(1e8 - 1e4), (int)1e8);\n            } else {\n                // random ai\n                ai = rnd.next(0, (int)1e8);\n            }\n            while (positions.count(ai)) {\n                ai = (ai + 1) % ((int)1e8 + 1);\n            }\n            positions.insert(ai);\n            a[i] = ai;\n\n            if (i % 5 == 2) {\n                l[i] = 1;\n            } else if (i % 5 == 3) {\n                l[i] = (int)1e8;\n            } else {\n                l[i] = rnd.next(1, (int)1e8);\n            }\n        }\n    } else {\n        // Default random case\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n\n        // Generate li randomly in [1, 1e8]\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], l[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        printf(\"%d\\n\", n);\n        printf(\"0 1\\n\");\n        return 0;\n    }\n\n    vector<int> a(n);\n    vector<int> l(n);\n\n    if (type == \"max_random\") {\n        // Generate n unique ai in [0, 1e8]\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n\n        // Generate li randomly in [1, 1e8]\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    } else if (type == \"overlapping\") {\n        // All ai in a small range, li large enough to overlap\n        int base_ai = rnd.next(0, (int)(1e8 - n - 1e7));\n        for (int i = 0; i < n; ++i) {\n            a[i] = base_ai + i;  // Consecutive positions\n            l[i] = (int)1e8 - base_ai; // Large li to cover up to 1e8\n        }\n    } else if (type == \"non_overlapping\") {\n        // Set ai and li so that no overlaps occur if directed appropriately\n        int gap = (int)(1e8 / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = i * gap;\n            l[i] = gap / 2;\n        }\n    } else if (type == \"edge_ai_zero\") {\n        // ai starting from 0\n        for (int i = 0; i < n; ++i) {\n            a[i] = i; // Ensure uniqueness\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    } else if (type == \"edge_ai_max\") {\n        // ai near 1e8\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)(1e8 - n + i);\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    } else if (type == \"max_li\") {\n        // li = 1e8\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n        for (int i = 0; i < n; ++i) {\n            l[i] = (int)1e8;\n        }\n    } else if (type == \"min_li\") {\n        // li = 1\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n        for (int i = 0; i < n; ++i) {\n            l[i] = 1;\n        }\n    } else if (type == \"mixed\") {\n        set<int> positions;\n        for (int i = 0; i < n; ++i) {\n            int ai;\n            if (i % 5 == 0) {\n                // ai near 0\n                ai = rnd.next(0, (int)1e4);\n            } else if (i % 5 == 1) {\n                // ai near 1e8\n                ai = rnd.next((int)(1e8 - 1e4), (int)1e8);\n            } else {\n                // random ai\n                ai = rnd.next(0, (int)1e8);\n            }\n            while (positions.count(ai)) {\n                ai = (ai + 1) % ((int)1e8 + 1);\n            }\n            positions.insert(ai);\n            a[i] = ai;\n\n            if (i % 5 == 2) {\n                l[i] = 1;\n            } else if (i % 5 == 3) {\n                l[i] = (int)1e8;\n            } else {\n                l[i] = rnd.next(1, (int)1e8);\n            }\n        }\n    } else {\n        // Default random case\n        set<int> positions;\n        while (positions.size() < n) {\n            int ai = rnd.next(0, (int)1e8);\n            positions.insert(ai);\n        }\n\n        a.assign(positions.begin(), positions.end());\n        shuffle(a.begin(), a.end());\n\n        // Generate li randomly in [1, 1e8]\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(1, (int)1e8);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], l[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n\n./gen -n 5 -type max_random\n./gen -n 5 -type overlapping\n./gen -n 5 -type non_overlapping\n./gen -n 5 -type edge_ai_zero\n./gen -n 5 -type edge_ai_max\n./gen -n 5 -type max_li\n./gen -n 5 -type min_li\n./gen -n 5 -type mixed\n\n./gen -n 50 -type max_random\n./gen -n 50 -type overlapping\n./gen -n 50 -type non_overlapping\n./gen -n 50 -type edge_ai_zero\n./gen -n 50 -type edge_ai_max\n./gen -n 50 -type max_li\n./gen -n 50 -type min_li\n./gen -n 50 -type mixed\n\n./gen -n 100 -type max_random\n./gen -n 100 -type overlapping\n./gen -n 100 -type non_overlapping\n./gen -n 100 -type edge_ai_zero\n./gen -n 100 -type edge_ai_max\n./gen -n 100 -type max_li\n./gen -n 100 -type min_li\n./gen -n 100 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:14.494005",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "56/A",
      "title": "A. Bar",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100) which is the number of the bar's clients. Then follow n lines, each describing one visitor. A line either contains his age (an integer from 0 to 1000) or his drink (a string of capital Latin letters from 1 to 100 in length). It is guaranteed that the input data does not contain spaces and other unnecessary separators.Only the drinks from the list given above should be considered alcohol.",
      "output_spec": "OutputPrint a single number which is the number of people Vasya should check to guarantee the law enforcement.",
      "sample_tests": "ExamplesInputCopy518VODKACOKE1917OutputCopy2",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100) which is the number of the bar's clients. Then follow n lines, each describing one visitor. A line either contains his age (an integer from 0 to 1000) or his drink (a string of capital Latin letters from 1 to 100 in length). It is guaranteed that the input data does not contain spaces and other unnecessary separators.Only the drinks from the list given above should be considered alcohol.\n\nOutputPrint a single number which is the number of people Vasya should check to guarantee the law enforcement.\n\nInputCopy518VODKACOKE1917OutputCopy2\n\nInputCopy518VODKACOKE1917\n\nOutputCopy2\n\nNoteIn the sample test the second and fifth clients should be checked.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #52 (Div. 2) - Codeforces",
          "content": "Good evening! I am glad to invite you to participate in Codeforces Beta Round #52 (Div. 2). Today's round was prepared Michael Mirzayanov, Max Ivanov and Maria Belov. It's possible that \"out of the competition\"-participants will not be able to use the tab \"hacks\". Do not panic, on the next Div. 2 Round we will necessarily fix it. Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 374
        },
        {
          "title": "CodeForces Beta Round #52 :: Разбор задач - Codeforces",
          "content": "Задача А. БарОтветом на задачу является количество посетителей, которые удовлетворяют одному из предложенных ограничений:1) Указан возраст посетителя и он меньше 18 лет2) Указан напиток посетителя и он является алкогольнымДалее остается аккуратная реализация.Задача B. Испорченная перестановкаЗадача имеет множество решений. В разборе будет расказанно решение с асимптотикой O(N), где N - количество элементов последовательности.Найдем такое наименьшее i, такое что Ai не равно i (элементы нумеруются с единицы). Если такого i не существует, то все числа стоят на своих местах и, соответственно, ответом являются два нуля. Иначе, предполагаем, что ответом являются числа i и Ai (мы можем быть точно уверены, что i < Ai). Переворачиваем подпоследовательность элементов с i-ого по Ai-ый и проверяем всю полученную последовательность на то, везде ли Ai равно i. Если да, то ответом является пара (i, Ai), иначе ответ - два нуля.Задача C. Почта в корпорацииДля решения задачи вполне подходит решение за O(N2L), где N - количество людей в иерархии, а L - средняя длина имени сотрудника. То есть сравнение строк можно выполнять без использования хэш-функции.Первая часть решения - аккуратная реализация примитивного парсинга строки. Наиболее простой способ - рекурсивная функция, которая читает сначала имя сотрудника, а потом и всех его подчиненных до тех пор, пока не достигнет точки. Далее потребуется хранить в памяти дерево из N вершин. Хранение дерева можно организовать как с помощью динамической памяти, так и простой матрицей смежности. Далее можно просто для каждой вершины запустить обход в глубину из нее и посмотреть скольким вершинам в этом поддереве сопоставлено такое же имя. Стоит обратить внимание на то, что сама вершина, из которой изначально запускается обход в глубину, не должна быть посчитана в ответ.Такое решение можно улучшить до сложности O(NlogN), используя хэширование и более сложные структуры данных (например map). При данных ограничениях это было бы пустой тратой времени. Даже грубой оценки N < 500 достаточно, чтобы решение уложилось в time limit.Задача D. Получаем строкуНаиболее простым решением этой задачи является решение с использованием динамического программирования. Обозначим первую строку за A, а вторую за B. Длина первой строки равна N, а второй - M. Тогда решение имеет асимптотику O(NM).Обозначим за S(i, j) - подстроку строки S с i-ого по j-ый символ.Введем функцию F(x, y) - сколько минимум действий надо выполнить, чтобы из подстроки A(x, N - 1) получить подстроку B(y, M - 1) (индексы символов нумеруются с нуля). Тогда значание F(x, y) это минимум из:F(x + 1, y + 1), при x < N, y < M и A[x] = B[x]F(x + 1, y + 1) + 1, при x < N, y < MF(x + 1, y), при x < NF(x, y + 1), при y < MОчевидно, что F(N, M) равно нулю.Если при обработке очередного перехода не только обновлять значение функции, но и запоминать тип перехода, то по окончании подсчета функции F(0, 0) можно будет восстановить набор необходимых операций для превращения строки A в строку B. Ну а само значение F(0, 0) и будет искомым ответом.Задача E. Принцип доминоЗадача вполне может иметь множество решений, но в данном разборе будет рассказано одно из наиболее тривиальных.Для начала отсортируем все доминошки по координате x слева направо, запомнив изначальную нумерацию. Эта нумерация потребуется только для вывода ответа в правильном порядке. Далее нужно сформулировать несколько тривиальных утверждений:1) Если толкнуть какую-либо доминошку вправо, то среди упавших доминошек все (кроме самой доминошки) будут находиться справа от той, что толкнули.2) Если какая-либо доминошка упала, то упали и все доминошки, которые находятся левее этой, но не левее той, что изначально толкнули.3) Для каждой доминошки можно определить номер наиболее правой доминошки такой, что она упадет, если толкнуть данную.Обозначим за F(i) номер наиболее правой доминошки, которая упадет, если толкнуть i-ую доминошку. Сама по себе i-ая доминошка может не упасть на F(i)-ую, но из-за \"принципа домино\" F(i)-ая все же упадет. Если доминошка при падении вообще не задевает никакую другую доминошку, то F(i) = i. Очевидно, что такое равенство выполняется для самой правой доминошки. Для остальных доминошек можно найти значение F(i) с помощью уже найденных F(j), где j > i.Для каждой доминошки с номером i можно найти такую доминошку с номером j, что при падении i-ая повалит j-ую (непосредственно), и такое j максимально. То есть найти самую правую из доминошек, которую повалит непосредственно i-ая. Далее F(i) = max(F(k)), где k принимает значения на интервале [i + 1, j].Реализация решения с асимптотикой O(N2) точно не влезет в ограничения по времени. Поэтому необходимо написать решение как минимум за O(NlogN), для чего достаточно воспользоваться структурой данных типа дерева интервалов. Короче говоря, решить задачу Range Maximum Query.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4835
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() >= 1 && s.length() <= 100, \"Line %d: Line length must be between 1 and 100, but it's %d\", i+2, int(s.length()));\n        bool is_digits = true;\n        bool is_capital_letters = true;\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                is_capital_letters = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                is_digits = false;\n            } else {\n                ensuref(false, \"Line %d: Contains invalid character '%c'\", i+2, c);\n            }\n        }\n        ensuref(is_digits != is_capital_letters, \"Line %d: Line must contain only digits or only capital letters\", i+2);\n        if (is_digits) {\n            long long age = atoll(s.c_str());\n            ensuref(age >= 0 && age <= 1000, \"Line %d: Age %lld is not between 0 and 1000\", i+2, age);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() >= 1 && s.length() <= 100, \"Line %d: Line length must be between 1 and 100, but it's %d\", i+2, int(s.length()));\n        bool is_digits = true;\n        bool is_capital_letters = true;\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                is_capital_letters = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                is_digits = false;\n            } else {\n                ensuref(false, \"Line %d: Contains invalid character '%c'\", i+2, c);\n            }\n        }\n        ensuref(is_digits != is_capital_letters, \"Line %d: Line must contain only digits or only capital letters\", i+2);\n        if (is_digits) {\n            long long age = atoll(s.c_str());\n            ensuref(age >= 0 && age <= 1000, \"Line %d: Age %lld is not between 0 and 1000\", i+2, age);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() >= 1 && s.length() <= 100, \"Line %d: Line length must be between 1 and 100, but it's %d\", i+2, int(s.length()));\n        bool is_digits = true;\n        bool is_capital_letters = true;\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                is_capital_letters = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                is_digits = false;\n            } else {\n                ensuref(false, \"Line %d: Contains invalid character '%c'\", i+2, c);\n            }\n        }\n        ensuref(is_digits != is_capital_letters, \"Line %d: Line must contain only digits or only capital letters\", i+2);\n        if (is_digits) {\n            long long age = atoll(s.c_str());\n            ensuref(age >= 0 && age <= 1000, \"Line %d: Age %lld is not between 0 and 1000\", i+2, age);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst vector<string> alcohol_drinks = {\n    \"ABSINTH\", \"BEER\", \"BRANDY\", \"CHAMPAGNE\", \"GIN\",\n    \"RUM\", \"SAKE\", \"TEQUILA\", \"VODKA\", \"WHISKEY\", \"WINE\"\n};\n\nconst int MIN_AGE = 0;\nconst int MAX_AGE = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            bool is_age = rnd.next(2) == 0;\n            if (is_age) {\n                int age = rnd.next(MIN_AGE, MAX_AGE);\n                printf(\"%d\\n\", age);\n            } else {\n                int len = rnd.next(1, 100); // Length of the drink name\n                string drink;\n                for (int j = 0; j < len; j++) {\n                    drink += char('A' + rnd.next(26));\n                }\n                printf(\"%s\\n\", drink.c_str());\n            }\n        }\n    } else if (type == \"age_boundary\") {\n        // Clients with ages around boundaries: 17,18,19,0,1000\n        for (int i = 0; i < n; i++) {\n            int age_options[] = {17, 18, 19, MIN_AGE, MAX_AGE};\n            int age = age_options[rnd.next(5)];\n            printf(\"%d\\n\", age);\n        }\n    } else if (type == \"alcoholic_drinks\") {\n        // All clients have drinks, all drinks are alcoholic\n        for (int i = 0; i < n; i++) {\n            string drink = alcohol_drinks[rnd.next(alcohol_drinks.size())];\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"non_alcoholic_drinks\") {\n        // All clients have drinks, all drinks are non-alcoholic\n        for (int i = 0; i < n; i++) {\n            int len = rnd.next(1, 100);\n            string drink;\n            for (int j = 0; j < len; j++) {\n                drink += char('A' + rnd.next(26));\n            }\n            // Ensure the drink is not in the alcohol list\n            while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                drink[rnd.next(len)] = 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"similar_drinks\") {\n        // Drinks similar to alcohol drinks (one character difference)\n        for (int i = 0; i < n; i++) {\n            string orig = alcohol_drinks[rnd.next(alcohol_drinks.size())];\n            string drink = orig;\n            if (drink.length() > 1) {\n                // Modify one character\n                int pos = rnd.next(drink.length());\n                char original_char = drink[pos];\n                while (drink[pos] == original_char) {\n                    drink[pos] = 'A' + rnd.next(26);\n                }\n            } else {\n                // Drink name length is 1, change it to something else\n                drink[0] = (drink[0] - 'A' + 1) % 26 + 'A';\n            }\n            // Ensure it's different from the original\n            if (drink == orig) {\n                drink += 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"long_drink_names\") {\n        // Drinks with maximum length (100)\n        for (int i = 0; i < n; i++) {\n            int len = 100;\n            string drink;\n            for (int j = 0; j < len; j++) {\n                drink += 'A' + rnd.next(26);\n            }\n            // Ensure it's not in alcohol list\n            while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                drink[rnd.next(len)] = 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"min_drink_names\") {\n        // Drinks with minimal length (1)\n        for (int i = 0; i < n; i++) {\n            string drink;\n            drink += 'A' + rnd.next(26);\n            // Ensure it's not in alcohol list\n            while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                drink[0] = 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"all_underage\") {\n        // All clients have ages less than 18\n        for (int i = 0; i < n; i++) {\n            int age = rnd.next(0, 17);\n            printf(\"%d\\n\", age);\n        }\n    } else if (type == \"all_adults\") {\n        // All clients have ages >=18\n        for (int i = 0; i < n; i++) {\n            int age = rnd.next(18, MAX_AGE);\n            printf(\"%d\\n\", age);\n        }\n    } else if (type == \"mixed\") {\n        // Mixed ages and drinks\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) {\n                // Age\n                int age = rnd.next(MIN_AGE, MAX_AGE);\n                printf(\"%d\\n\", age);\n            } else {\n                // Drink\n                if (rnd.next(2) == 0) {\n                    // Alcoholic drink\n                    string drink = alcohol_drinks[rnd.next(alcohol_drinks.size())];\n                    printf(\"%s\\n\", drink.c_str());\n                } else {\n                    // Non-alcoholic drink\n                    int len = rnd.next(1, 100);\n                    string drink;\n                    for (int j = 0; j < len; j++) {\n                        drink += 'A' + rnd.next(26);\n                    }\n                    // Ensure it's not in alcohol list\n                    while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                        drink[rnd.next(len)] = 'A' + rnd.next(26);\n                    }\n                    printf(\"%s\\n\", drink.c_str());\n                }\n            }\n        }        \n    } else {\n        // Default random\n        for (int i = 0; i < n; i++) {\n            bool is_age = rnd.next(2) == 0;\n            if (is_age) {\n                int age = rnd.next(MIN_AGE, MAX_AGE);\n                printf(\"%d\\n\", age);\n            } else {\n                int len = rnd.next(1, 100); // Length of the drink name\n                string drink;\n                for (int j = 0; j < len; j++) {\n                    drink += char('A' + rnd.next(26));\n                }\n                printf(\"%s\\n\", drink.c_str());\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst vector<string> alcohol_drinks = {\n    \"ABSINTH\", \"BEER\", \"BRANDY\", \"CHAMPAGNE\", \"GIN\",\n    \"RUM\", \"SAKE\", \"TEQUILA\", \"VODKA\", \"WHISKEY\", \"WINE\"\n};\n\nconst int MIN_AGE = 0;\nconst int MAX_AGE = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            bool is_age = rnd.next(2) == 0;\n            if (is_age) {\n                int age = rnd.next(MIN_AGE, MAX_AGE);\n                printf(\"%d\\n\", age);\n            } else {\n                int len = rnd.next(1, 100); // Length of the drink name\n                string drink;\n                for (int j = 0; j < len; j++) {\n                    drink += char('A' + rnd.next(26));\n                }\n                printf(\"%s\\n\", drink.c_str());\n            }\n        }\n    } else if (type == \"age_boundary\") {\n        // Clients with ages around boundaries: 17,18,19,0,1000\n        for (int i = 0; i < n; i++) {\n            int age_options[] = {17, 18, 19, MIN_AGE, MAX_AGE};\n            int age = age_options[rnd.next(5)];\n            printf(\"%d\\n\", age);\n        }\n    } else if (type == \"alcoholic_drinks\") {\n        // All clients have drinks, all drinks are alcoholic\n        for (int i = 0; i < n; i++) {\n            string drink = alcohol_drinks[rnd.next(alcohol_drinks.size())];\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"non_alcoholic_drinks\") {\n        // All clients have drinks, all drinks are non-alcoholic\n        for (int i = 0; i < n; i++) {\n            int len = rnd.next(1, 100);\n            string drink;\n            for (int j = 0; j < len; j++) {\n                drink += char('A' + rnd.next(26));\n            }\n            // Ensure the drink is not in the alcohol list\n            while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                drink[rnd.next(len)] = 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"similar_drinks\") {\n        // Drinks similar to alcohol drinks (one character difference)\n        for (int i = 0; i < n; i++) {\n            string orig = alcohol_drinks[rnd.next(alcohol_drinks.size())];\n            string drink = orig;\n            if (drink.length() > 1) {\n                // Modify one character\n                int pos = rnd.next(drink.length());\n                char original_char = drink[pos];\n                while (drink[pos] == original_char) {\n                    drink[pos] = 'A' + rnd.next(26);\n                }\n            } else {\n                // Drink name length is 1, change it to something else\n                drink[0] = (drink[0] - 'A' + 1) % 26 + 'A';\n            }\n            // Ensure it's different from the original\n            if (drink == orig) {\n                drink += 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"long_drink_names\") {\n        // Drinks with maximum length (100)\n        for (int i = 0; i < n; i++) {\n            int len = 100;\n            string drink;\n            for (int j = 0; j < len; j++) {\n                drink += 'A' + rnd.next(26);\n            }\n            // Ensure it's not in alcohol list\n            while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                drink[rnd.next(len)] = 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"min_drink_names\") {\n        // Drinks with minimal length (1)\n        for (int i = 0; i < n; i++) {\n            string drink;\n            drink += 'A' + rnd.next(26);\n            // Ensure it's not in alcohol list\n            while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                drink[0] = 'A' + rnd.next(26);\n            }\n            printf(\"%s\\n\", drink.c_str());\n        }\n    } else if (type == \"all_underage\") {\n        // All clients have ages less than 18\n        for (int i = 0; i < n; i++) {\n            int age = rnd.next(0, 17);\n            printf(\"%d\\n\", age);\n        }\n    } else if (type == \"all_adults\") {\n        // All clients have ages >=18\n        for (int i = 0; i < n; i++) {\n            int age = rnd.next(18, MAX_AGE);\n            printf(\"%d\\n\", age);\n        }\n    } else if (type == \"mixed\") {\n        // Mixed ages and drinks\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) {\n                // Age\n                int age = rnd.next(MIN_AGE, MAX_AGE);\n                printf(\"%d\\n\", age);\n            } else {\n                // Drink\n                if (rnd.next(2) == 0) {\n                    // Alcoholic drink\n                    string drink = alcohol_drinks[rnd.next(alcohol_drinks.size())];\n                    printf(\"%s\\n\", drink.c_str());\n                } else {\n                    // Non-alcoholic drink\n                    int len = rnd.next(1, 100);\n                    string drink;\n                    for (int j = 0; j < len; j++) {\n                        drink += 'A' + rnd.next(26);\n                    }\n                    // Ensure it's not in alcohol list\n                    while (find(alcohol_drinks.begin(), alcohol_drinks.end(), drink) != alcohol_drinks.end()) {\n                        drink[rnd.next(len)] = 'A' + rnd.next(26);\n                    }\n                    printf(\"%s\\n\", drink.c_str());\n                }\n            }\n        }        \n    } else {\n        // Default random\n        for (int i = 0; i < n; i++) {\n            bool is_age = rnd.next(2) == 0;\n            if (is_age) {\n                int age = rnd.next(MIN_AGE, MAX_AGE);\n                printf(\"%d\\n\", age);\n            } else {\n                int len = rnd.next(1, 100); // Length of the drink name\n                string drink;\n                for (int j = 0; j < len; j++) {\n                    drink += char('A' + rnd.next(26));\n                }\n                printf(\"%s\\n\", drink.c_str());\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n\n./gen -n 1 -type age_boundary\n./gen -n 10 -type age_boundary\n./gen -n 100 -type age_boundary\n\n./gen -n 1 -type alcoholic_drinks\n./gen -n 10 -type alcoholic_drinks\n./gen -n 100 -type alcoholic_drinks\n\n./gen -n 1 -type non_alcoholic_drinks\n./gen -n 10 -type non_alcoholic_drinks\n./gen -n 100 -type non_alcoholic_drinks\n\n./gen -n 1 -type similar_drinks\n./gen -n 10 -type similar_drinks\n./gen -n 100 -type similar_drinks\n\n./gen -n 1 -type long_drink_names\n./gen -n 10 -type long_drink_names\n./gen -n 100 -type long_drink_names\n\n./gen -n 1 -type min_drink_names\n./gen -n 10 -type min_drink_names\n./gen -n 100 -type min_drink_names\n\n./gen -n 1 -type all_underage\n./gen -n 10 -type all_underage\n./gen -n 100 -type all_underage\n\n./gen -n 1 -type all_adults\n./gen -n 10 -type all_adults\n./gen -n 100 -type all_adults\n\n./gen -n 50 -type mixed\n./gen -n 100 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:16.972710",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "56/B",
      "title": "B. Spoilt Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1000) which is the number of coins in Vasya's collection. The second line contains space-separated n integers which are the spoilt sequence of coins. It is guaranteed that the given sequence is a permutation, i.e. it contains only integers from 1 to n, and every number is used exactly 1 time.",
      "output_spec": "OutputIf it is impossible to obtain the given permutation from the original one in exactly one action, print 0 0. Otherwise, print two numbers l r (1 ≤ l < r ≤ n) which are the endpoints of the segment that needs to be reversed to obtain from permutation 1 2 ... n the given one.",
      "sample_tests": "ExamplesInputCopy81 6 5 4 3 2 7 8OutputCopy2 6InputCopy42 3 4 1OutputCopy0 0InputCopy41 2 3 4OutputCopy0 0",
      "description": "B. Spoilt Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1000) which is the number of coins in Vasya's collection. The second line contains space-separated n integers which are the spoilt sequence of coins. It is guaranteed that the given sequence is a permutation, i.e. it contains only integers from 1 to n, and every number is used exactly 1 time.\n\nOutputIf it is impossible to obtain the given permutation from the original one in exactly one action, print 0 0. Otherwise, print two numbers l r (1 ≤ l < r ≤ n) which are the endpoints of the segment that needs to be reversed to obtain from permutation 1 2 ... n the given one.\n\nInputCopy81 6 5 4 3 2 7 8OutputCopy2 6InputCopy42 3 4 1OutputCopy0 0InputCopy41 2 3 4OutputCopy0 0\n\nInputCopy81 6 5 4 3 2 7 8\n\nOutputCopy2 6\n\nInputCopy42 3 4 1\n\nOutputCopy0 0\n\nInputCopy41 2 3 4\n\nOutputCopy0 0",
      "solutions": [
        {
          "title": "Codeforces Beta Round #52 (Div. 2) - Codeforces",
          "content": "Good evening! I am glad to invite you to participate in Codeforces Beta Round #52 (Div. 2). Today's round was prepared Michael Mirzayanov, Max Ivanov and Maria Belov. It's possible that \"out of the competition\"-participants will not be able to use the tab \"hacks\". Do not panic, on the next Div. 2 Round we will necessarily fix it. Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 374
        },
        {
          "title": "CodeForces Beta Round #52 :: Разбор задач - Codeforces",
          "content": "Задача А. БарОтветом на задачу является количество посетителей, которые удовлетворяют одному из предложенных ограничений:1) Указан возраст посетителя и он меньше 18 лет2) Указан напиток посетителя и он является алкогольнымДалее остается аккуратная реализация.Задача B. Испорченная перестановкаЗадача имеет множество решений. В разборе будет расказанно решение с асимптотикой O(N), где N - количество элементов последовательности.Найдем такое наименьшее i, такое что Ai не равно i (элементы нумеруются с единицы). Если такого i не существует, то все числа стоят на своих местах и, соответственно, ответом являются два нуля. Иначе, предполагаем, что ответом являются числа i и Ai (мы можем быть точно уверены, что i < Ai). Переворачиваем подпоследовательность элементов с i-ого по Ai-ый и проверяем всю полученную последовательность на то, везде ли Ai равно i. Если да, то ответом является пара (i, Ai), иначе ответ - два нуля.Задача C. Почта в корпорацииДля решения задачи вполне подходит решение за O(N2L), где N - количество людей в иерархии, а L - средняя длина имени сотрудника. То есть сравнение строк можно выполнять без использования хэш-функции.Первая часть решения - аккуратная реализация примитивного парсинга строки. Наиболее простой способ - рекурсивная функция, которая читает сначала имя сотрудника, а потом и всех его подчиненных до тех пор, пока не достигнет точки. Далее потребуется хранить в памяти дерево из N вершин. Хранение дерева можно организовать как с помощью динамической памяти, так и простой матрицей смежности. Далее можно просто для каждой вершины запустить обход в глубину из нее и посмотреть скольким вершинам в этом поддереве сопоставлено такое же имя. Стоит обратить внимание на то, что сама вершина, из которой изначально запускается обход в глубину, не должна быть посчитана в ответ.Такое решение можно улучшить до сложности O(NlogN), используя хэширование и более сложные структуры данных (например map). При данных ограничениях это было бы пустой тратой времени. Даже грубой оценки N < 500 достаточно, чтобы решение уложилось в time limit.Задача D. Получаем строкуНаиболее простым решением этой задачи является решение с использованием динамического программирования. Обозначим первую строку за A, а вторую за B. Длина первой строки равна N, а второй - M. Тогда решение имеет асимптотику O(NM).Обозначим за S(i, j) - подстроку строки S с i-ого по j-ый символ.Введем функцию F(x, y) - сколько минимум действий надо выполнить, чтобы из подстроки A(x, N - 1) получить подстроку B(y, M - 1) (индексы символов нумеруются с нуля). Тогда значание F(x, y) это минимум из:F(x + 1, y + 1), при x < N, y < M и A[x] = B[x]F(x + 1, y + 1) + 1, при x < N, y < MF(x + 1, y), при x < NF(x, y + 1), при y < MОчевидно, что F(N, M) равно нулю.Если при обработке очередного перехода не только обновлять значение функции, но и запоминать тип перехода, то по окончании подсчета функции F(0, 0) можно будет восстановить набор необходимых операций для превращения строки A в строку B. Ну а само значение F(0, 0) и будет искомым ответом.Задача E. Принцип доминоЗадача вполне может иметь множество решений, но в данном разборе будет рассказано одно из наиболее тривиальных.Для начала отсортируем все доминошки по координате x слева направо, запомнив изначальную нумерацию. Эта нумерация потребуется только для вывода ответа в правильном порядке. Далее нужно сформулировать несколько тривиальных утверждений:1) Если толкнуть какую-либо доминошку вправо, то среди упавших доминошек все (кроме самой доминошки) будут находиться справа от той, что толкнули.2) Если какая-либо доминошка упала, то упали и все доминошки, которые находятся левее этой, но не левее той, что изначально толкнули.3) Для каждой доминошки можно определить номер наиболее правой доминошки такой, что она упадет, если толкнуть данную.Обозначим за F(i) номер наиболее правой доминошки, которая упадет, если толкнуть i-ую доминошку. Сама по себе i-ая доминошка может не упасть на F(i)-ую, но из-за \"принципа домино\" F(i)-ая все же упадет. Если доминошка при падении вообще не задевает никакую другую доминошку, то F(i) = i. Очевидно, что такое равенство выполняется для самой правой доминошки. Для остальных доминошек можно найти значение F(i) с помощью уже найденных F(j), где j > i.Для каждой доминошки с номером i можно найти такую доминошку с номером j, что при падении i-ая повалит j-ую (непосредственно), и такое j максимально. То есть найти самую правую из доминошек, которую повалит непосредственно i-ая. Далее F(i) = max(F(k)), где k принимает значения на интервале [i + 1, j].Реализация решения с асимптотикой O(N2) точно не влезет в ограничения по времени. Поэтому необходимо написать решение как минимум за O(NlogN), для чего достаточно воспользоваться структурой данных типа дерева интервалов. Короче говоря, решить задачу Range Maximum Query.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4835
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int val = p[i];\n        ensuref(!seen[val], \"Number %d appears multiple times in the permutation\", val);\n        seen[val] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int val = p[i];\n        ensuref(!seen[val], \"Number %d appears multiple times in the permutation\", val);\n        seen[val] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int val = p[i];\n        ensuref(!seen[val], \"Number %d appears multiple times in the permutation\", val);\n        seen[val] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> perm;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    n = inf.readInt();\n    perm.resize(n);\n    for (int i = 0; i < n; i++) {\n        perm[i] = inf.readInt(1, n);\n    }\n    \n    int l = ouf.readInt();\n    int r = ouf.readInt();\n    \n    if (l == 0 && r == 0) {\n        // Check if it's impossible to obtain perm from 1..n by reversing any segment [a,b] with a < b\n        bool possible = false;\n        vector<int> orig(n);\n        for (int i = 0; i < n; i++)\n            orig[i] = i + 1;\n        \n        for (int a = 1; a <= n; a++) {\n            for (int b = a + 1; b <= n; b++) {\n                vector<int> temp = orig;\n                reverse(temp.begin() + a - 1, temp.begin() + b);\n                if (temp == perm) {\n                    possible = true;\n                    break;\n                }\n            }\n            if (possible)\n                break;\n        }\n        \n        if (possible) {\n            quitf(_wa, \"It is possible to obtain the permutation via segment reversal, but contestant outputs 0 0\");\n        } else {\n            quitf(_ok, \"Correctly outputs 0 0 when impossible\");\n        }\n    } else {\n        if (l < 1 || l > n || r < 1 || r > n) {\n            quitf(_wa, \"l and r are out of bounds: l = %d, r = %d\", l, r);\n        } else if (l >= r) {\n            quitf(_wa, \"l must be less than r: l = %d, r = %d\", l, r);\n        } else {\n            vector<int> orig(n);\n            for (int i = 0; i < n; i++)\n                orig[i] = i + 1;\n            \n            reverse(orig.begin() + l - 1, orig.begin() + r);\n            \n            if (orig == perm) {\n                quitf(_ok, \"Correctly reversed segment [%d, %d]\", l, r);\n            } else {\n                quitf(_wa, \"Permutation does not match after reversing segment [%d, %d]\", l, r);\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"identity\");\n\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 1); // Initialize perm to 1..n\n\n    if (type == \"identity\") {\n        // Do nothing, perm is already 1..n\n    } else if (type == \"reverse\") {\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"segment_reverse\") {\n        int l = opt<int>(\"l\", -1);\n        int r = opt<int>(\"r\", -1);\n        if (l == -1 || r == -1 || l < 1 || r > n || l >= r) {\n            // Randomly pick l and r\n            l = rnd.next(1, n - 1); // l from 1 to n-1\n            r = rnd.next(l + 1, n); // r from l+1 to n\n        }\n        // Reverse perm[l-1 .. r-1]\n        reverse(perm.begin() + l - 1, perm.begin() + r);\n    } else if (type == \"swap\") {\n        // Swap two elements\n        int l = rnd.next(0, n - 1);\n        int r = rnd.next(0, n - 1);\n        while (r == l) r = rnd.next(0, n - 1);\n        swap(perm[l], perm[r]);\n    } else if (type == \"double_reverse\") {\n        // Reverse two segments\n        int a = rnd.next(1, n - 1);\n        int b = rnd.next(a + 1, n);\n        reverse(perm.begin() + a - 1, perm.begin() + b);\n        int c = rnd.next(1, n - 1);\n        int d = rnd.next(c + 1, n);\n        reverse(perm.begin() + c - 1, perm.begin() + d);\n    } else if (type == \"impossible\") {\n        // Swap elements in different positions to make an impossible case\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while (j == i || abs(j - i) == 1) j = rnd.next(0, n - 1);\n        swap(perm[i], perm[j]);\n        int k = rnd.next(0, n - 1);\n        int l = rnd.next(0, n - 1);\n        while (l == k || l == i || l == j) l = rnd.next(0, n - 1);\n        swap(perm[k], perm[l]);\n    }\n\n    // Output n and the permutation\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"identity\");\n\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 1); // Initialize perm to 1..n\n\n    if (type == \"identity\") {\n        // Do nothing, perm is already 1..n\n    } else if (type == \"reverse\") {\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"segment_reverse\") {\n        int l = opt<int>(\"l\", -1);\n        int r = opt<int>(\"r\", -1);\n        if (l == -1 || r == -1 || l < 1 || r > n || l >= r) {\n            // Randomly pick l and r\n            l = rnd.next(1, n - 1); // l from 1 to n-1\n            r = rnd.next(l + 1, n); // r from l+1 to n\n        }\n        // Reverse perm[l-1 .. r-1]\n        reverse(perm.begin() + l - 1, perm.begin() + r);\n    } else if (type == \"swap\") {\n        // Swap two elements\n        int l = rnd.next(0, n - 1);\n        int r = rnd.next(0, n - 1);\n        while (r == l) r = rnd.next(0, n - 1);\n        swap(perm[l], perm[r]);\n    } else if (type == \"double_reverse\") {\n        // Reverse two segments\n        int a = rnd.next(1, n - 1);\n        int b = rnd.next(a + 1, n);\n        reverse(perm.begin() + a - 1, perm.begin() + b);\n        int c = rnd.next(1, n - 1);\n        int d = rnd.next(c + 1, n);\n        reverse(perm.begin() + c - 1, perm.begin() + d);\n    } else if (type == \"impossible\") {\n        // Swap elements in different positions to make an impossible case\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while (j == i || abs(j - i) == 1) j = rnd.next(0, n - 1);\n        swap(perm[i], perm[j]);\n        int k = rnd.next(0, n - 1);\n        int l = rnd.next(0, n - 1);\n        while (l == k || l == i || l == j) l = rnd.next(0, n - 1);\n        swap(perm[k], perm[l]);\n    }\n\n    // Output n and the permutation\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, identity\n./gen -n 1 -type identity\n./gen -n 2 -type identity\n./gen -n 3 -type identity\n\n# Small n, reverse\n./gen -n 2 -type reverse\n./gen -n 3 -type reverse\n\n# Small n, segment reverse\n./gen -n 3 -type segment_reverse -l 1 -r 2\n./gen -n 3 -type segment_reverse -l 2 -r 3\n\n# Small n, swap\n./gen -n 3 -type swap\n\n# Small n, double reverse\n./gen -n 3 -type double_reverse\n\n# Small n, impossible\n./gen -n 3 -type impossible\n\n# Medium n, identity\n./gen -n 10 -type identity\n\n# Medium n, reverse\n./gen -n 10 -type reverse\n\n# Medium n, segment reverse\n./gen -n 10 -type segment_reverse\n./gen -n 10 -type segment_reverse -l 1 -r 5\n./gen -n 10 -type segment_reverse -l 6 -r 10\n\n# Medium n, swap\n./gen -n 10 -type swap\n\n# Medium n, double reverse\n./gen -n 10 -type double_reverse\n\n# Medium n, impossible\n./gen -n 10 -type impossible\n\n# Large n, identity\n./gen -n 1000 -type identity\n\n# Large n, reverse\n./gen -n 1000 -type reverse\n\n# Large n, segment reverse\n./gen -n 1000 -type segment_reverse\n\n# Large n, swap\n./gen -n 1000 -type swap\n\n# Large n, double reverse\n./gen -n 1000 -type double_reverse\n\n# Large n, impossible\n./gen -n 1000 -type impossible\n\n# Edge cases\n./gen -n 4 -type identity\n./gen -n 4 -type segment_reverse -l 1 -r 4\n./gen -n 4 -type swap\n\n# Specific l and r\n./gen -n 100 -type segment_reverse -l 50 -r 100\n./gen -n 100 -type segment_reverse -l 1 -r 50\n\n# Additional impossible cases\n./gen -n 20 -type impossible\n./gen -n 50 -type impossible\n./gen -n 100 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:18.640059",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "56/C",
      "title": "C. Corporation Mail",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and single line contains the corporation structure which is a string of length from 1 to 1000 characters. It is guaranteed that the description is correct. Every name is a string consisting of capital Latin letters from 1 to 10 symbols in length.",
      "output_spec": "OutputPrint a single number — the number of uncomfortable situations in the company.",
      "sample_tests": "ExamplesInputCopyMIKE:MAX.,ARTEM:MIKE..,DMITRY:DMITRY.,DMITRY...OutputCopy3InputCopyA:A..OutputCopy1InputCopyA:C:C:C:C.....OutputCopy6",
      "description": "C. Corporation Mail\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first and single line contains the corporation structure which is a string of length from 1 to 1000 characters. It is guaranteed that the description is correct. Every name is a string consisting of capital Latin letters from 1 to 10 symbols in length.\n\nOutputPrint a single number — the number of uncomfortable situations in the company.\n\nInputCopyMIKE:MAX.,ARTEM:MIKE..,DMITRY:DMITRY.,DMITRY...OutputCopy3InputCopyA:A..OutputCopy1InputCopyA:C:C:C:C.....OutputCopy6\n\nInputCopyMIKE:MAX.,ARTEM:MIKE..,DMITRY:DMITRY.,DMITRY...\n\nOutputCopy3\n\nInputCopyA:A..\n\nOutputCopy1\n\nInputCopyA:C:C:C:C.....\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Beta Round #52 (Div. 2) - Codeforces",
          "content": "Good evening! I am glad to invite you to participate in Codeforces Beta Round #52 (Div. 2). Today's round was prepared Michael Mirzayanov, Max Ivanov and Maria Belov. It's possible that \"out of the competition\"-participants will not be able to use the tab \"hacks\". Do not panic, on the next Div. 2 Round we will necessarily fix it. Good luck!Artem Rakhov and Codeforces team",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 374
        },
        {
          "title": "CodeForces Beta Round #52 :: Разбор задач - Codeforces",
          "content": "Задача А. БарОтветом на задачу является количество посетителей, которые удовлетворяют одному из предложенных ограничений:1) Указан возраст посетителя и он меньше 18 лет2) Указан напиток посетителя и он является алкогольнымДалее остается аккуратная реализация.Задача B. Испорченная перестановкаЗадача имеет множество решений. В разборе будет расказанно решение с асимптотикой O(N), где N - количество элементов последовательности.Найдем такое наименьшее i, такое что Ai не равно i (элементы нумеруются с единицы). Если такого i не существует, то все числа стоят на своих местах и, соответственно, ответом являются два нуля. Иначе, предполагаем, что ответом являются числа i и Ai (мы можем быть точно уверены, что i < Ai). Переворачиваем подпоследовательность элементов с i-ого по Ai-ый и проверяем всю полученную последовательность на то, везде ли Ai равно i. Если да, то ответом является пара (i, Ai), иначе ответ - два нуля.Задача C. Почта в корпорацииДля решения задачи вполне подходит решение за O(N2L), где N - количество людей в иерархии, а L - средняя длина имени сотрудника. То есть сравнение строк можно выполнять без использования хэш-функции.Первая часть решения - аккуратная реализация примитивного парсинга строки. Наиболее простой способ - рекурсивная функция, которая читает сначала имя сотрудника, а потом и всех его подчиненных до тех пор, пока не достигнет точки. Далее потребуется хранить в памяти дерево из N вершин. Хранение дерева можно организовать как с помощью динамической памяти, так и простой матрицей смежности. Далее можно просто для каждой вершины запустить обход в глубину из нее и посмотреть скольким вершинам в этом поддереве сопоставлено такое же имя. Стоит обратить внимание на то, что сама вершина, из которой изначально запускается обход в глубину, не должна быть посчитана в ответ.Такое решение можно улучшить до сложности O(NlogN), используя хэширование и более сложные структуры данных (например map). При данных ограничениях это было бы пустой тратой времени. Даже грубой оценки N < 500 достаточно, чтобы решение уложилось в time limit.Задача D. Получаем строкуНаиболее простым решением этой задачи является решение с использованием динамического программирования. Обозначим первую строку за A, а вторую за B. Длина первой строки равна N, а второй - M. Тогда решение имеет асимптотику O(NM).Обозначим за S(i, j) - подстроку строки S с i-ого по j-ый символ.Введем функцию F(x, y) - сколько минимум действий надо выполнить, чтобы из подстроки A(x, N - 1) получить подстроку B(y, M - 1) (индексы символов нумеруются с нуля). Тогда значание F(x, y) это минимум из:F(x + 1, y + 1), при x < N, y < M и A[x] = B[x]F(x + 1, y + 1) + 1, при x < N, y < MF(x + 1, y), при x < NF(x, y + 1), при y < MОчевидно, что F(N, M) равно нулю.Если при обработке очередного перехода не только обновлять значение функции, но и запоминать тип перехода, то по окончании подсчета функции F(0, 0) можно будет восстановить набор необходимых операций для превращения строки A в строку B. Ну а само значение F(0, 0) и будет искомым ответом.Задача E. Принцип доминоЗадача вполне может иметь множество решений, но в данном разборе будет рассказано одно из наиболее тривиальных.Для начала отсортируем все доминошки по координате x слева направо, запомнив изначальную нумерацию. Эта нумерация потребуется только для вывода ответа в правильном порядке. Далее нужно сформулировать несколько тривиальных утверждений:1) Если толкнуть какую-либо доминошку вправо, то среди упавших доминошек все (кроме самой доминошки) будут находиться справа от той, что толкнули.2) Если какая-либо доминошка упала, то упали и все доминошки, которые находятся левее этой, но не левее той, что изначально толкнули.3) Для каждой доминошки можно определить номер наиболее правой доминошки такой, что она упадет, если толкнуть данную.Обозначим за F(i) номер наиболее правой доминошки, которая упадет, если толкнуть i-ую доминошку. Сама по себе i-ая доминошка может не упасть на F(i)-ую, но из-за \"принципа домино\" F(i)-ая все же упадет. Если доминошка при падении вообще не задевает никакую другую доминошку, то F(i) = i. Очевидно, что такое равенство выполняется для самой правой доминошки. Для остальных доминошек можно найти значение F(i) с помощью уже найденных F(j), где j > i.Для каждой доминошки с номером i можно найти такую доминошку с номером j, что при падении i-ая повалит j-ую (непосредственно), и такое j максимально. То есть найти самую правую из доминошек, которую повалит непосредственно i-ая. Далее F(i) = max(F(k)), где k принимает значения на интервале [i + 1, j].Реализация решения с асимптотикой O(N2) точно не влезет в ограничения по времени. Поэтому необходимо написать решение как минимум за O(NlogN), для чего достаточно воспользоваться структурой данных типа дерева интервалов. Короче говоря, решить задачу Range Maximum Query.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4835
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint pos;\n\nchar currentChar()\n{\n    if (pos < s.length()) {\n        return s[pos];\n    } else {\n        return '\\0'; // End of input\n    }\n}\n\nvoid consumeChar(char expected)\n{\n    ensuref(pos < s.length(), \"Unexpected end of input when expecting '%c' at position %d\", expected, pos);\n    ensuref(s[pos] == expected, \"Expected '%c' but found '%c' at position %d\", expected, s[pos], pos);\n    pos++;\n}\n\nvoid parseName()\n{\n    int start = pos;\n    int len = 0;\n    while (pos < s.length() && s[pos] >= 'A' && s[pos] <= 'Z' && len < 10) {\n        pos++;\n        len++;\n    }\n    ensuref(len >= 1 && len <= 10, \"Name length must be between 1 and 10 at position %d\", start);\n    for (int i = start; i < start + len; i++) {\n        char c = s[i];\n        ensuref(c >= 'A' && c <= 'Z', \"Invalid character '%c' in name at position %d\", c, i);\n    }\n}\n\nvoid parseEmployee();\n\nvoid parseEmployeeList()\n{\n    parseEmployee();\n    while (currentChar() == ',') {\n        consumeChar(',');\n        parseEmployee();\n    }\n}\n\nvoid parseEmployee()\n{\n    parseName();\n    char c = currentChar();\n    if (c == ':') {\n        consumeChar(':');\n        parseEmployeeList();\n        consumeChar('.');\n    } else if (c == '.') {\n        consumeChar('.');\n    } else {\n        ensuref(false, \"Expected ':' or '.' but found '%c' at position %d\", c, pos);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    s = inf.readLine();\n    ensuref(s.length() >= 1 && s.length() <= 1000, \"Input length must be between 1 and 1000\");\n    pos = 0;\n    parseEmployeeList();\n    ensuref(pos == s.length(), \"Extra characters at the end of input at position %d\", pos);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint pos;\n\nchar currentChar()\n{\n    if (pos < s.length()) {\n        return s[pos];\n    } else {\n        return '\\0'; // End of input\n    }\n}\n\nvoid consumeChar(char expected)\n{\n    ensuref(pos < s.length(), \"Unexpected end of input when expecting '%c' at position %d\", expected, pos);\n    ensuref(s[pos] == expected, \"Expected '%c' but found '%c' at position %d\", expected, s[pos], pos);\n    pos++;\n}\n\nvoid parseName()\n{\n    int start = pos;\n    int len = 0;\n    while (pos < s.length() && s[pos] >= 'A' && s[pos] <= 'Z' && len < 10) {\n        pos++;\n        len++;\n    }\n    ensuref(len >= 1 && len <= 10, \"Name length must be between 1 and 10 at position %d\", start);\n    for (int i = start; i < start + len; i++) {\n        char c = s[i];\n        ensuref(c >= 'A' && c <= 'Z', \"Invalid character '%c' in name at position %d\", c, i);\n    }\n}\n\nvoid parseEmployee();\n\nvoid parseEmployeeList()\n{\n    parseEmployee();\n    while (currentChar() == ',') {\n        consumeChar(',');\n        parseEmployee();\n    }\n}\n\nvoid parseEmployee()\n{\n    parseName();\n    char c = currentChar();\n    if (c == ':') {\n        consumeChar(':');\n        parseEmployeeList();\n        consumeChar('.');\n    } else if (c == '.') {\n        consumeChar('.');\n    } else {\n        ensuref(false, \"Expected ':' or '.' but found '%c' at position %d\", c, pos);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    s = inf.readLine();\n    ensuref(s.length() >= 1 && s.length() <= 1000, \"Input length must be between 1 and 1000\");\n    pos = 0;\n    parseEmployeeList();\n    ensuref(pos == s.length(), \"Extra characters at the end of input at position %d\", pos);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint pos;\n\nchar currentChar()\n{\n    if (pos < s.length()) {\n        return s[pos];\n    } else {\n        return '\\0'; // End of input\n    }\n}\n\nvoid consumeChar(char expected)\n{\n    ensuref(pos < s.length(), \"Unexpected end of input when expecting '%c' at position %d\", expected, pos);\n    ensuref(s[pos] == expected, \"Expected '%c' but found '%c' at position %d\", expected, s[pos], pos);\n    pos++;\n}\n\nvoid parseName()\n{\n    int start = pos;\n    int len = 0;\n    while (pos < s.length() && s[pos] >= 'A' && s[pos] <= 'Z' && len < 10) {\n        pos++;\n        len++;\n    }\n    ensuref(len >= 1 && len <= 10, \"Name length must be between 1 and 10 at position %d\", start);\n    for (int i = start; i < start + len; i++) {\n        char c = s[i];\n        ensuref(c >= 'A' && c <= 'Z', \"Invalid character '%c' in name at position %d\", c, i);\n    }\n}\n\nvoid parseEmployee();\n\nvoid parseEmployeeList()\n{\n    parseEmployee();\n    while (currentChar() == ',') {\n        consumeChar(',');\n        parseEmployee();\n    }\n}\n\nvoid parseEmployee()\n{\n    parseName();\n    char c = currentChar();\n    if (c == ':') {\n        consumeChar(':');\n        parseEmployeeList();\n        consumeChar('.');\n    } else if (c == '.') {\n        consumeChar('.');\n    } else {\n        ensuref(false, \"Expected ':' or '.' but found '%c' at position %d\", c, pos);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    s = inf.readLine();\n    ensuref(s.length() >= 1 && s.length() <= 1000, \"Input length must be between 1 and 1000\");\n    pos = 0;\n    parseEmployeeList();\n    ensuref(pos == s.length(), \"Extra characters at the end of input at position %d\", pos);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring num_to_name(int num) {\n    string name = \"\";\n    while (num > 0) {\n        int rem = (num - 1) % 26;\n        name += ('A' + rem);\n        num = (num - 1) / 26;\n    }\n    reverse(name.begin(), name.end());\n    return name;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string structure_type = opt<string>(\"structure\", \"random\");\n    string name_type = opt<string>(\"name\", \"unique\");\n\n    int max_n;\n\n    if (structure_type == \"chain\") {\n        max_n = 15;\n    } else if (structure_type == \"star\") {\n        max_n = 50;\n    } else if (structure_type == \"random\") {\n        max_n = 30;\n    } else {\n        max_n = 30;\n    }\n\n    n = min(n, max_n);\n\n    vector<vector<int>> tree(n);\n\n    if (structure_type == \"chain\") {\n        for (int i = 0; i < n - 1; ++i) {\n            tree[i].push_back(i + 1);\n        }\n    }\n    else if (structure_type == \"star\") {\n        for (int i = 1; i < n; ++i) {\n            tree[0].push_back(i);\n        }\n    }\n    else if (structure_type == \"random\") {\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            tree[parent].push_back(i);\n        }\n    }\n    else {\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            tree[parent].push_back(i);\n        }\n    }\n\n    vector<string> names(n);\n\n    if (name_type == \"unique\") {\n        for (int i = 0; i < n; ++i) {\n            names[i] = num_to_name(i + 1);\n        }\n    }\n    else if (name_type == \"same\") {\n        string same_name = \"A\";\n        names.assign(n, same_name);\n    }\n    else if (name_type == \"some_same\") {\n        int num_unique = max(1, n / 2);\n        vector<string> unique_names(num_unique);\n        for (int i = 0; i < num_unique; ++i) {\n            unique_names[i] = num_to_name(i + 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            names[i] = unique_names[rnd.next(0, num_unique - 1)];\n        }\n    }\n    else {\n        for (int i = 0; i < n; ++i) {\n            names[i] = num_to_name(i + 1);\n        }\n    }\n\n    vector<bool> has_parent(n, false);\n\n    for (int i = 0; i < n; ++i) {\n        for (int child : tree[i]) {\n            has_parent[child] = true;\n        }\n    }\n\n    vector<int> roots;\n\n    for (int i = 0; i < n; ++i) {\n        if (!has_parent[i]) {\n            roots.push_back(i);\n        }\n    }\n\n    function<string(int)> dfs = [&](int u) {\n        string res = names[u];\n        if (tree[u].empty()) {\n            res += '.';\n        }\n        else {\n            res += ':';\n            for (size_t i = 0; i < tree[u].size(); ++i) {\n                int v = tree[u][i];\n                res += dfs(v);\n                if (i + 1 < tree[u].size()) {\n                    res += ',';\n                }\n            }\n            res += '.';\n        }\n        return res;\n    };\n\n    string output = \"\";\n\n    for (size_t i = 0; i < roots.size(); ++i) {\n        int u = roots[i];\n        output += dfs(u);\n        if (i + 1 < roots.size()) {\n            output += ',';\n        }\n    }\n\n    if (output.length() > 1000) {\n        fprintf(stderr, \"Output length exceeds 1000 characters.\\n\");\n        exit(1);\n    }\n\n    printf(\"%s\\n\", output.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring num_to_name(int num) {\n    string name = \"\";\n    while (num > 0) {\n        int rem = (num - 1) % 26;\n        name += ('A' + rem);\n        num = (num - 1) / 26;\n    }\n    reverse(name.begin(), name.end());\n    return name;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string structure_type = opt<string>(\"structure\", \"random\");\n    string name_type = opt<string>(\"name\", \"unique\");\n\n    int max_n;\n\n    if (structure_type == \"chain\") {\n        max_n = 15;\n    } else if (structure_type == \"star\") {\n        max_n = 50;\n    } else if (structure_type == \"random\") {\n        max_n = 30;\n    } else {\n        max_n = 30;\n    }\n\n    n = min(n, max_n);\n\n    vector<vector<int>> tree(n);\n\n    if (structure_type == \"chain\") {\n        for (int i = 0; i < n - 1; ++i) {\n            tree[i].push_back(i + 1);\n        }\n    }\n    else if (structure_type == \"star\") {\n        for (int i = 1; i < n; ++i) {\n            tree[0].push_back(i);\n        }\n    }\n    else if (structure_type == \"random\") {\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            tree[parent].push_back(i);\n        }\n    }\n    else {\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            tree[parent].push_back(i);\n        }\n    }\n\n    vector<string> names(n);\n\n    if (name_type == \"unique\") {\n        for (int i = 0; i < n; ++i) {\n            names[i] = num_to_name(i + 1);\n        }\n    }\n    else if (name_type == \"same\") {\n        string same_name = \"A\";\n        names.assign(n, same_name);\n    }\n    else if (name_type == \"some_same\") {\n        int num_unique = max(1, n / 2);\n        vector<string> unique_names(num_unique);\n        for (int i = 0; i < num_unique; ++i) {\n            unique_names[i] = num_to_name(i + 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            names[i] = unique_names[rnd.next(0, num_unique - 1)];\n        }\n    }\n    else {\n        for (int i = 0; i < n; ++i) {\n            names[i] = num_to_name(i + 1);\n        }\n    }\n\n    vector<bool> has_parent(n, false);\n\n    for (int i = 0; i < n; ++i) {\n        for (int child : tree[i]) {\n            has_parent[child] = true;\n        }\n    }\n\n    vector<int> roots;\n\n    for (int i = 0; i < n; ++i) {\n        if (!has_parent[i]) {\n            roots.push_back(i);\n        }\n    }\n\n    function<string(int)> dfs = [&](int u) {\n        string res = names[u];\n        if (tree[u].empty()) {\n            res += '.';\n        }\n        else {\n            res += ':';\n            for (size_t i = 0; i < tree[u].size(); ++i) {\n                int v = tree[u][i];\n                res += dfs(v);\n                if (i + 1 < tree[u].size()) {\n                    res += ',';\n                }\n            }\n            res += '.';\n        }\n        return res;\n    };\n\n    string output = \"\";\n\n    for (size_t i = 0; i < roots.size(); ++i) {\n        int u = roots[i];\n        output += dfs(u);\n        if (i + 1 < roots.size()) {\n            output += ',';\n        }\n    }\n\n    if (output.length() > 1000) {\n        fprintf(stderr, \"Output length exceeds 1000 characters.\\n\");\n        exit(1);\n    }\n\n    printf(\"%s\\n\", output.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -structure chain -name unique\n./gen -n 1 -structure star -name same\n./gen -n 1 -structure random -name some_same\n\n# Chain structures with unique names\n./gen -n 5 -structure chain -name unique\n./gen -n 10 -structure chain -name unique\n./gen -n 15 -structure chain -name unique\n\n# Chain structures with same names\n./gen -n 5 -structure chain -name same\n./gen -n 10 -structure chain -name same\n./gen -n 15 -structure chain -name same\n\n# Star structures with unique names\n./gen -n 10 -structure star -name unique\n./gen -n 20 -structure star -name unique\n./gen -n 50 -structure star -name unique\n\n# Star structures with same names\n./gen -n 10 -structure star -name same\n./gen -n 20 -structure star -name same\n./gen -n 50 -structure star -name same\n\n# Random structures with unique names\n./gen -n 15 -structure random -name unique\n./gen -n 25 -structure random -name unique\n./gen -n 30 -structure random -name unique\n\n# Random structures with same names\n./gen -n 15 -structure random -name same\n./gen -n 25 -structure random -name same\n./gen -n 30 -structure random -name same\n\n# Random structures with some same names\n./gen -n 15 -structure random -name some_same\n./gen -n 25 -structure random -name some_same\n./gen -n 30 -structure random -name some_same\n\n# Edge cases with minimal names\n./gen -n 5 -structure chain -name same\n./gen -n 5 -structure star -name same\n./gen -n 5 -structure random -name same\n\n# Edge cases with maximal names\n./gen -n 5 -structure chain -name unique\n./gen -n 5 -structure star -name unique\n./gen -n 5 -structure random -name unique\n\n# Special cases to test potential contestant errors\n./gen -n 10 -structure chain -name same\n./gen -n 10 -structure random -name some_same\n./gen -n 15 -structure star -name some_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:20.740898",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "56/D",
      "title": "D. Changing a String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains s, the second line contains t. The lines consist only of capital Latin letters, their lengths are positive numbers from 1 to 1000.",
      "output_spec": "OutputIn the first line print the number of moves k in the given sequence of operations. The number should be the minimal possible one. Then print k lines containing one operation each. Print the operations in the format, described above. If there are several solutions, print any of them.",
      "sample_tests": "ExamplesInputCopyABAABBBAOutputCopy2INSERT 3 BINSERT 4 BInputCopyACCEPTEDWRONGANSWEROutputCopy10REPLACE 1 WREPLACE 2 RREPLACE 3 OREPLACE 4 NREPLACE 5 GREPLACE 6 AINSERT 7 NINSERT 8 SINSERT 9 WREPLACE 11 R",
      "description": "D. Changing a String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains s, the second line contains t. The lines consist only of capital Latin letters, their lengths are positive numbers from 1 to 1000.\n\nOutputIn the first line print the number of moves k in the given sequence of operations. The number should be the minimal possible one. Then print k lines containing one operation each. Print the operations in the format, described above. If there are several solutions, print any of them.\n\nInputCopyABAABBBAOutputCopy2INSERT 3 BINSERT 4 BInputCopyACCEPTEDWRONGANSWEROutputCopy10REPLACE 1 WREPLACE 2 RREPLACE 3 OREPLACE 4 NREPLACE 5 GREPLACE 6 AINSERT 7 NINSERT 8 SINSERT 9 WREPLACE 11 R\n\nInputCopyABAABBBA\n\nOutputCopy2INSERT 3 BINSERT 4 B\n\nInputCopyACCEPTEDWRONGANSWER\n\nOutputCopy10REPLACE 1 WREPLACE 2 RREPLACE 3 OREPLACE 4 NREPLACE 5 GREPLACE 6 AINSERT 7 NINSERT 8 SINSERT 9 WREPLACE 11 R",
      "solutions": [
        {
          "title": "Codeforces Beta Round #52 (Div. 2) - Codeforces",
          "content": "Good evening! I am glad to invite you to participate in Codeforces Beta Round #52 (Div. 2). Today's round was prepared Michael Mirzayanov, Max Ivanov and Maria Belov. It's possible that \"out of the competition\"-participants will not be able to use the tab \"hacks\". Do not panic, on the next Div. 2 Round we will necessarily fix it. Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 374
        },
        {
          "title": "CodeForces Beta Round #52 :: Разбор задач - Codeforces",
          "content": "Задача А. БарОтветом на задачу является количество посетителей, которые удовлетворяют одному из предложенных ограничений:1) Указан возраст посетителя и он меньше 18 лет2) Указан напиток посетителя и он является алкогольнымДалее остается аккуратная реализация.Задача B. Испорченная перестановкаЗадача имеет множество решений. В разборе будет расказанно решение с асимптотикой O(N), где N - количество элементов последовательности.Найдем такое наименьшее i, такое что Ai не равно i (элементы нумеруются с единицы). Если такого i не существует, то все числа стоят на своих местах и, соответственно, ответом являются два нуля. Иначе, предполагаем, что ответом являются числа i и Ai (мы можем быть точно уверены, что i < Ai). Переворачиваем подпоследовательность элементов с i-ого по Ai-ый и проверяем всю полученную последовательность на то, везде ли Ai равно i. Если да, то ответом является пара (i, Ai), иначе ответ - два нуля.Задача C. Почта в корпорацииДля решения задачи вполне подходит решение за O(N2L), где N - количество людей в иерархии, а L - средняя длина имени сотрудника. То есть сравнение строк можно выполнять без использования хэш-функции.Первая часть решения - аккуратная реализация примитивного парсинга строки. Наиболее простой способ - рекурсивная функция, которая читает сначала имя сотрудника, а потом и всех его подчиненных до тех пор, пока не достигнет точки. Далее потребуется хранить в памяти дерево из N вершин. Хранение дерева можно организовать как с помощью динамической памяти, так и простой матрицей смежности. Далее можно просто для каждой вершины запустить обход в глубину из нее и посмотреть скольким вершинам в этом поддереве сопоставлено такое же имя. Стоит обратить внимание на то, что сама вершина, из которой изначально запускается обход в глубину, не должна быть посчитана в ответ.Такое решение можно улучшить до сложности O(NlogN), используя хэширование и более сложные структуры данных (например map). При данных ограничениях это было бы пустой тратой времени. Даже грубой оценки N < 500 достаточно, чтобы решение уложилось в time limit.Задача D. Получаем строкуНаиболее простым решением этой задачи является решение с использованием динамического программирования. Обозначим первую строку за A, а вторую за B. Длина первой строки равна N, а второй - M. Тогда решение имеет асимптотику O(NM).Обозначим за S(i, j) - подстроку строки S с i-ого по j-ый символ.Введем функцию F(x, y) - сколько минимум действий надо выполнить, чтобы из подстроки A(x, N - 1) получить подстроку B(y, M - 1) (индексы символов нумеруются с нуля). Тогда значание F(x, y) это минимум из:F(x + 1, y + 1), при x < N, y < M и A[x] = B[x]F(x + 1, y + 1) + 1, при x < N, y < MF(x + 1, y), при x < NF(x, y + 1), при y < MОчевидно, что F(N, M) равно нулю.Если при обработке очередного перехода не только обновлять значение функции, но и запоминать тип перехода, то по окончании подсчета функции F(0, 0) можно будет восстановить набор необходимых операций для превращения строки A в строку B. Ну а само значение F(0, 0) и будет искомым ответом.Задача E. Принцип доминоЗадача вполне может иметь множество решений, но в данном разборе будет рассказано одно из наиболее тривиальных.Для начала отсортируем все доминошки по координате x слева направо, запомнив изначальную нумерацию. Эта нумерация потребуется только для вывода ответа в правильном порядке. Далее нужно сформулировать несколько тривиальных утверждений:1) Если толкнуть какую-либо доминошку вправо, то среди упавших доминошек все (кроме самой доминошки) будут находиться справа от той, что толкнули.2) Если какая-либо доминошка упала, то упали и все доминошки, которые находятся левее этой, но не левее той, что изначально толкнули.3) Для каждой доминошки можно определить номер наиболее правой доминошки такой, что она упадет, если толкнуть данную.Обозначим за F(i) номер наиболее правой доминошки, которая упадет, если толкнуть i-ую доминошку. Сама по себе i-ая доминошка может не упасть на F(i)-ую, но из-за \"принципа домино\" F(i)-ая все же упадет. Если доминошка при падении вообще не задевает никакую другую доминошку, то F(i) = i. Очевидно, что такое равенство выполняется для самой правой доминошки. Для остальных доминошек можно найти значение F(i) с помощью уже найденных F(j), где j > i.Для каждой доминошки с номером i можно найти такую доминошку с номером j, что при падении i-ая повалит j-ую (непосредственно), и такое j максимально. То есть найти самую правую из доминошек, которую повалит непосредственно i-ая. Далее F(i) = max(F(k)), где k принимает значения на интервале [i + 1, j].Реализация решения с асимптотикой O(N2) точно не влезет в ограничения по времени. Поэтому необходимо написать решение как минимум за O(NlogN), для чего достаточно воспользоваться структурой данных типа дерева интервалов. Короче говоря, решить задачу Range Maximum Query.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4835
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    string s = inf.readLine(\"[A-Z]{1,1000}\", \"s\");\n    string t = inf.readLine(\"[A-Z]{1,1000}\", \"t\");\n    \n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    string s = inf.readLine(\"[A-Z]{1,1000}\", \"s\");\n    string t = inf.readLine(\"[A-Z]{1,1000}\", \"t\");\n    \n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    string s = inf.readLine(\"[A-Z]{1,1000}\", \"s\");\n    string t = inf.readLine(\"[A-Z]{1,1000}\", \"t\");\n    \n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  A possible cause of extra overhead is using large nested STL structures for edit distance.\n  For strings up to length 1000, a 2D DP with vectors is typically fine, but in some\n  environments it may be slow enough to risk a checker timeout. We'll switch to a static\n  array-based DP (and one-dimensional approach) to reduce overhead, while still keeping\n  complexity O(n*m).\n*/\n\n// Computes the standard edit distance (Levenshtein distance) between two strings\nint editDistance(const string &a, const string &b)\n{\n    int n = (int)a.size();\n    int m = (int)b.size();\n\n    // We'll use a one-dimensional DP: dp[j] will represent the cost to transform\n    // the first i characters of \"a\" into the first j characters of \"b\". We'll\n    // update it as we go along i in an outer loop.\n    static int dp[2002]; // can hold up to 1000 + 1 for j dimension\n    // Initialize dp for the case i=0\n    for (int j = 0; j <= m; j++) {\n        dp[j] = j;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        // prev holds dp[j-1] from the previous iteration\n        int prev = dp[0]; \n        // For the new row: dp[0] should be i (delete all i chars from a)\n        dp[0] = i;\n        for (int j = 1; j <= m; j++) {\n            // dp[j] is old dp[i-1][j], i.e. the cost before updating at row i\n            int temp = dp[j];\n            // dp[j-1] is the cost for i characters of a -> (j-1) characters of b\n            // plus one insert\n            dp[j] = min(dp[j] + 1,    // delete from a (dp[i-1][j]) + 1\n                     min(dp[j - 1] + 1, // insert into a (dp[i][j-1]) + 1\n                         prev + (a[i - 1] == b[j - 1] ? 0 : 1))); \n            prev = temp;\n        }\n    }\n    return dp[m];\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read the original strings from the input file\n    // Problem statement says these are single lines of uppercase letters, so readToken is fine.\n    string s = inf.readToken();\n    string t = inf.readToken();\n\n    // Read contestant's answer: number of operations\n    int k = ouf.readInt(0, 5000, \"k\"); \n    // Arbitrary upper bound to avoid unbounded loops\n\n    // We'll apply the operations on a local copy of s\n    string current = s;\n\n    for (int i = 0; i < k; i++) {\n        string op = ouf.readToken();\n        if (op == \"INSERT\") {\n            int pos = ouf.readInt(1, (int)current.size() + 1, \"insert_pos\");\n            // Next token: the letter to insert\n            string ch = ouf.readToken(\"[A-Z]\");\n            // Insert letter ch[0] at position (1-based)\n            current.insert(pos - 1, 1, ch[0]);\n        }\n        else if (op == \"DELETE\") {\n            int pos = ouf.readInt(1, (int)current.size(), \"delete_pos\");\n            current.erase(pos - 1, 1);\n        }\n        else if (op == \"REPLACE\") {\n            int pos = ouf.readInt(1, (int)current.size(), \"replace_pos\");\n            string ch = ouf.readToken(\"[A-Z]\");\n            current[pos - 1] = ch[0];\n        }\n        else {\n            ouf.quitf(_wa, \"unknown operation \\\"%s\\\"\", op.c_str());\n        }\n    }\n\n    // Check if final string matches t\n    if (current != t) {\n        ouf.quitf(_wa, \n            \"the final string is \\\"%s\\\", but should be \\\"%s\\\"\", current.c_str(), t.c_str());\n    }\n\n    // Compute minimal edit distance and compare with k\n    int dist = editDistance(s, t);\n    if (k != dist) {\n        ouf.quitf(_wa, \n            \"the provided sequence has %d operations, but the minimal edit distance is %d\",\n            k, dist\n        );\n    }\n\n    // If everything is correct:\n    ouf.quitf(_ok, \"solution is correct with exactly %d moves\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_LENGTH = 1000;\n\n    if (n < 1 || n > MAX_LENGTH || m < 1 || m > MAX_LENGTH) {\n        cerr << \"n and m must be between 1 and 1000 inclusive\" << endl;\n        return 1;\n    }\n\n    string s, t;\n\n    if (type == \"equal\") {\n        // s and t are the same random string of length n\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        t = s;\n    } else if (type == \"insertions\") {\n        // s is a subsequence of t\n        if (n > m) {\n            cerr << \"n must be <= m for insertions type\" << endl;\n            return 1;\n        }\n        // Generate t of length m\n        for (int i = 0; i < m; ++i) {\n            char ch = rnd.next('A', 'Z');\n            t += ch;\n        }\n        // Choose n positions to form s\n        vector<int> indices(m);\n        for (int i = 0; i < m; ++i) {\n            indices[i] = i;\n        }\n        shuffle(indices.begin(), indices.end());\n        indices.resize(n);\n        sort(indices.begin(), indices.end());\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += t[indices[i]];\n        }\n    } else if (type == \"deletions\") {\n        // t is a subsequence of s\n        if (m > n) {\n            cerr << \"m must be <= n for deletions type\" << endl;\n            return 1;\n        }\n        // Generate s of length n\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        // Choose m positions to form t\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i;\n        }\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n        t = \"\";\n        for (int i = 0; i < m; ++i) {\n            t += s[indices[i]];\n        }\n    } else if (type == \"replace\") {\n        // s and t differ by some characters\n        if (n != m) {\n            cerr << \"n must be equal to m for replace type\" << endl;\n            return 1;\n        }\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n            t += ch;\n        }\n        int num_replacements = rnd.next(1, n);\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(num_replacements);\n        for (int i = 0; i < num_replacements; ++i) {\n            int pos = positions[i];\n            char ch = rnd.next('A', 'Z');\n            t[pos] = ch;\n        }\n    } else if (type == \"reverse\") {\n        // s is random string, t is reverse of s\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        t = s;\n        reverse(t.begin(), t.end());\n    } else if (type == \"random\") {\n        // s and t are random strings of length n and m\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        for (int i = 0; i < m; ++i) {\n            char ch = rnd.next('A', 'Z');\n            t += ch;\n        }\n    } else if (type == \"alternating\") {\n        // s and t are alternating letters\n        char ch1 = rnd.next('A', 'Z');\n        char ch2;\n        do {\n            ch2 = rnd.next('A', 'Z');\n        } while (ch2 == ch1);\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? ch1 : ch2;\n        }\n        for (int i = 0; i < m; ++i) {\n            t += (i % 2 == 0) ? ch2 : ch1;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Print s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_LENGTH = 1000;\n\n    if (n < 1 || n > MAX_LENGTH || m < 1 || m > MAX_LENGTH) {\n        cerr << \"n and m must be between 1 and 1000 inclusive\" << endl;\n        return 1;\n    }\n\n    string s, t;\n\n    if (type == \"equal\") {\n        // s and t are the same random string of length n\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        t = s;\n    } else if (type == \"insertions\") {\n        // s is a subsequence of t\n        if (n > m) {\n            cerr << \"n must be <= m for insertions type\" << endl;\n            return 1;\n        }\n        // Generate t of length m\n        for (int i = 0; i < m; ++i) {\n            char ch = rnd.next('A', 'Z');\n            t += ch;\n        }\n        // Choose n positions to form s\n        vector<int> indices(m);\n        for (int i = 0; i < m; ++i) {\n            indices[i] = i;\n        }\n        shuffle(indices.begin(), indices.end());\n        indices.resize(n);\n        sort(indices.begin(), indices.end());\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += t[indices[i]];\n        }\n    } else if (type == \"deletions\") {\n        // t is a subsequence of s\n        if (m > n) {\n            cerr << \"m must be <= n for deletions type\" << endl;\n            return 1;\n        }\n        // Generate s of length n\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        // Choose m positions to form t\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i;\n        }\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n        t = \"\";\n        for (int i = 0; i < m; ++i) {\n            t += s[indices[i]];\n        }\n    } else if (type == \"replace\") {\n        // s and t differ by some characters\n        if (n != m) {\n            cerr << \"n must be equal to m for replace type\" << endl;\n            return 1;\n        }\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n            t += ch;\n        }\n        int num_replacements = rnd.next(1, n);\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(num_replacements);\n        for (int i = 0; i < num_replacements; ++i) {\n            int pos = positions[i];\n            char ch = rnd.next('A', 'Z');\n            t[pos] = ch;\n        }\n    } else if (type == \"reverse\") {\n        // s is random string, t is reverse of s\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        t = s;\n        reverse(t.begin(), t.end());\n    } else if (type == \"random\") {\n        // s and t are random strings of length n and m\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i) {\n            char ch = rnd.next('A', 'Z');\n            s += ch;\n        }\n        for (int i = 0; i < m; ++i) {\n            char ch = rnd.next('A', 'Z');\n            t += ch;\n        }\n    } else if (type == \"alternating\") {\n        // s and t are alternating letters\n        char ch1 = rnd.next('A', 'Z');\n        char ch2;\n        do {\n            ch2 = rnd.next('A', 'Z');\n        } while (ch2 == ch1);\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? ch1 : ch2;\n        }\n        for (int i = 0; i < m; ++i) {\n            t += (i % 2 == 0) ? ch2 : ch1;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Print s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type equal\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type replace\n./gen -n 10 -m 10 -type equal\n./gen -n 10 -m 10 -type replace\n./gen -n 10 -m 15 -type insertions\n./gen -n 15 -m 10 -type deletions\n./gen -n 10 -m 10 -type reverse\n./gen -n 100 -m 100 -type reverse\n./gen -n 100 -m 150 -type insertions\n./gen -n 150 -m 100 -type deletions\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type equal\n./gen -n 1000 -m 1000 -type replace\n./gen -n 1000 -m 1000 -type reverse\n./gen -n 1000 -m 1000 -type alternating\n./gen -n 500 -m 700 -type insertions\n./gen -n 700 -m 500 -type deletions\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 500 -type deletions\n./gen -n 500 -m 1000 -type insertions\n./gen -n 999 -m 1000 -type insertions\n./gen -n 1000 -m 999 -type deletions\n./gen -n 1000 -m 1000 -type replace\n./gen -n 1000 -m 1000 -type reverse\n./gen -n 2 -m 2 -type alternating\n./gen -n 2 -m 2 -type replace\n./gen -n 2 -m 3 -type insertions\n./gen -n 3 -m 2 -type deletions\n./gen -n 1 -m 1000 -type insertions\n./gen -n 1000 -m 1 -type deletions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:22.589622",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "56/E",
      "title": "E. Принцип домино",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество доминошек. Далее следует n строк по два целых числа xi и hi ( - 108 ≤ xi ≤ 108, 2 ≤ hi ≤ 108) — координата и высота каждой доминошки. Никакие две доминошки не стоят в одной точке.",
      "output_spec": "Выходные данныеВыведите n чисел zi через пробел — сколько доминошек упадет, если Вася толкнет вправо i-ую (включая ее саму).",
      "sample_tests": "ПримерыВходные данныеСкопировать416 520 510 1018 2Выходные данныеСкопировать3 1 4 1 Входные данныеСкопировать40 101 59 1015 10Выходные данныеСкопировать4 1 2 1",
      "description": "E. Принцип домино\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество доминошек. Далее следует n строк по два целых числа xi и hi ( - 108 ≤ xi ≤ 108, 2 ≤ hi ≤ 108) — координата и высота каждой доминошки. Никакие две доминошки не стоят в одной точке.\n\nВходные данные\n\nВыходные данныеВыведите n чисел zi через пробел — сколько доминошек упадет, если Вася толкнет вправо i-ую (включая ее саму).\n\nВыходные данные\n\nВходные данныеСкопировать416 520 510 1018 2Выходные данныеСкопировать3 1 4 1 Входные данныеСкопировать40 101 59 1015 10Выходные данныеСкопировать4 1 2 1\n\nВходные данныеСкопировать416 520 510 1018 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 1 4 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать40 101 59 1015 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4 1 2 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #52 (Div. 2) - Codeforces",
          "content": "Добрый вечер!Приглашаю всех поучаствовать в Codeforces Beta Round 52 (Div. 2). Сегодняшний раунд готовили Михаил Мирзаянов, Макс Иванов и Мария Белова.Возможно для участников вне конкурса не будет доступна вкладка \"взломы\". Не стоит паниковать, к следующему Div. 2 раунду она обязательно появится.Удачи!Артем Рахов и команда Codeforces",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1145",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 335
        },
        {
          "title": "CodeForces Beta Round #52 :: Разбор задач - Codeforces",
          "content": "Задача А. БарОтветом на задачу является количество посетителей, которые удовлетворяют одному из предложенных ограничений:1) Указан возраст посетителя и он меньше 18 лет2) Указан напиток посетителя и он является алкогольнымДалее остается аккуратная реализация.Задача B. Испорченная перестановкаЗадача имеет множество решений. В разборе будет расказанно решение с асимптотикой O(N), где N - количество элементов последовательности.Найдем такое наименьшее i, такое что Ai не равно i (элементы нумеруются с единицы). Если такого i не существует, то все числа стоят на своих местах и, соответственно, ответом являются два нуля. Иначе, предполагаем, что ответом являются числа i и Ai (мы можем быть точно уверены, что i < Ai). Переворачиваем подпоследовательность элементов с i-ого по Ai-ый и проверяем всю полученную последовательность на то, везде ли Ai равно i. Если да, то ответом является пара (i, Ai), иначе ответ - два нуля.Задача C. Почта в корпорацииДля решения задачи вполне подходит решение за O(N2L), где N - количество людей в иерархии, а L - средняя длина имени сотрудника. То есть сравнение строк можно выполнять без использования хэш-функции.Первая часть решения - аккуратная реализация примитивного парсинга строки. Наиболее простой способ - рекурсивная функция, которая читает сначала имя сотрудника, а потом и всех его подчиненных до тех пор, пока не достигнет точки. Далее потребуется хранить в памяти дерево из N вершин. Хранение дерева можно организовать как с помощью динамической памяти, так и простой матрицей смежности. Далее можно просто для каждой вершины запустить обход в глубину из нее и посмотреть скольким вершинам в этом поддереве сопоставлено такое же имя. Стоит обратить внимание на то, что сама вершина, из которой изначально запускается обход в глубину, не должна быть посчитана в ответ.Такое решение можно улучшить до сложности O(NlogN), используя хэширование и более сложные структуры данных (например map). При данных ограничениях это было бы пустой тратой времени. Даже грубой оценки N < 500 достаточно, чтобы решение уложилось в time limit.Задача D. Получаем строкуНаиболее простым решением этой задачи является решение с использованием динамического программирования. Обозначим первую строку за A, а вторую за B. Длина первой строки равна N, а второй - M. Тогда решение имеет асимптотику O(NM).Обозначим за S(i, j) - подстроку строки S с i-ого по j-ый символ.Введем функцию F(x, y) - сколько минимум действий надо выполнить, чтобы из подстроки A(x, N - 1) получить подстроку B(y, M - 1) (индексы символов нумеруются с нуля). Тогда значание F(x, y) это минимум из:F(x + 1, y + 1), при x < N, y < M и A[x] = B[x]F(x + 1, y + 1) + 1, при x < N, y < MF(x + 1, y), при x < NF(x, y + 1), при y < MОчевидно, что F(N, M) равно нулю.Если при обработке очередного перехода не только обновлять значение функции, но и запоминать тип перехода, то по окончании подсчета функции F(0, 0) можно будет восстановить набор необходимых операций для превращения строки A в строку B. Ну а само значение F(0, 0) и будет искомым ответом.Задача E. Принцип доминоЗадача вполне может иметь множество решений, но в данном разборе будет рассказано одно из наиболее тривиальных.Для начала отсортируем все доминошки по координате x слева направо, запомнив изначальную нумерацию. Эта нумерация потребуется только для вывода ответа в правильном порядке. Далее нужно сформулировать несколько тривиальных утверждений:1) Если толкнуть какую-либо доминошку вправо, то среди упавших доминошек все (кроме самой доминошки) будут находиться справа от той, что толкнули.2) Если какая-либо доминошка упала, то упали и все доминошки, которые находятся левее этой, но не левее той, что изначально толкнули.3) Для каждой доминошки можно определить номер наиболее правой доминошки такой, что она упадет, если толкнуть данную.Обозначим за F(i) номер наиболее правой доминошки, которая упадет, если толкнуть i-ую доминошку. Сама по себе i-ая доминошка может не упасть на F(i)-ую, но из-за \"принципа домино\" F(i)-ая все же упадет. Если доминошка при падении вообще не задевает никакую другую доминошку, то F(i) = i. Очевидно, что такое равенство выполняется для самой правой доминошки. Для остальных доминошек можно найти значение F(i) с помощью уже найденных F(j), где j > i.Для каждой доминошки с номером i можно найти такую доминошку с номером j, что при падении i-ая повалит j-ую (непосредственно), и такое j максимально. То есть найти самую правую из доминошек, которую повалит непосредственно i-ая. Далее F(i) = max(F(k)), где k принимает значения на интервале [i + 1, j].Реализация решения с асимптотикой O(N2) точно не влезет в ограничения по времени. Поэтому необходимо написать решение как минимум за O(NlogN), для чего достаточно воспользоваться структурой данных типа дерева интервалов. Короче говоря, решить задачу Range Maximum Query.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4835
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> xi_list(n);\n    for (int i = 0; i < n; ++i) {\n        // xi\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        // hi\n        int hi = inf.readInt(2, 100000000, \"hi\");\n        inf.readEoln();\n        xi_list[i] = xi;\n    }\n    // Check that xi are unique\n    sort(xi_list.begin(), xi_list.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(xi_list[i] != xi_list[i-1], \"Two dominoes can't stand on one point: xi=%d\", xi_list[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> xi_list(n);\n    for (int i = 0; i < n; ++i) {\n        // xi\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        // hi\n        int hi = inf.readInt(2, 100000000, \"hi\");\n        inf.readEoln();\n        xi_list[i] = xi;\n    }\n    // Check that xi are unique\n    sort(xi_list.begin(), xi_list.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(xi_list[i] != xi_list[i-1], \"Two dominoes can't stand on one point: xi=%d\", xi_list[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> xi_list(n);\n    for (int i = 0; i < n; ++i) {\n        // xi\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        // hi\n        int hi = inf.readInt(2, 100000000, \"hi\");\n        inf.readEoln();\n        xi_list[i] = xi;\n    }\n    // Check that xi are unique\n    sort(xi_list.begin(), xi_list.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(xi_list[i] != xi_list[i-1], \"Two dominoes can't stand on one point: xi=%d\", xi_list[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> dominoes;\n\n    if (type == \"random\") {\n        // Generate random xi and hi within constraints, ensuring unique xi\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i]; // xi\n            dominoes[i].second = rnd.next(2, 100000000); // hi\n        }\n    } else if (type == \"ordered_increasing\") {\n        // xi increasing from -1e8 to 1e8, hi random\n        dominoes.resize(n);\n        long long x_start = -100000000LL;\n        long long x_step = 200000000LL / n + 1; // To ensure unique xi\n        long long x = x_start;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = (int)x;\n            dominoes[i].second = rnd.next(2, 100000000);\n            x += x_step;\n            if (x > 100000000) x = 100000000; // Keep within bounds\n        }\n    } else if (type == \"ordered_decreasing\") {\n        // xi decreasing from 1e8 to -1e8, hi random\n        dominoes.resize(n);\n        long long x_start = 100000000LL;\n        long long x_step = 200000000LL / n + 1;\n        long long x = x_start;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = (int)x;\n            dominoes[i].second = rnd.next(2, 100000000);\n            x -= x_step;\n            if (x < -100000000) x = -100000000;\n        }\n    } else if (type == \"maximal_hi\") {\n        // hi = maximum value\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = 100000000; // Max hi\n        }\n    } else if (type == \"minimal_hi\") {\n        // hi = minimum value\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = 2; // Min hi\n        }\n    } else if (type == \"negative_xi\") {\n        // xi in negative range\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, -1);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = rnd.next(2, 100000000);\n        }\n    } else if (type == \"large_xi_hi\") {\n        // xi and hi near maximum values\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(100000000 - 100000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = rnd.next(100000000 - 100000, 100000000);\n        }\n    } else if (type == \"overlapping_dominoes\") {\n        // Design xi and hi so that each domino causes the next to fall\n        dominoes.resize(n);\n        int x = -100000000;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = x;\n            dominoes[i].second = 2; // Minimal hi to reach next domino\n            x += 1; // Next domino is at x + 1\n        }\n    } else if (type == \"non_overlapping_dominoes\") {\n        // Design xi and hi so that dominoes do not affect each other\n        dominoes.resize(n);\n        long long x = -100000000LL;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = (int)x;\n            dominoes[i].second = rnd.next(2, 100000000);\n            x += (long long)dominoes[i].second + 1; // Move x beyond current domino's reach\n            if (x > 100000000) x = 100000000;\n        }\n    } else if (type == \"same_height\") {\n        // All hi are the same value\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        int constant_hi = rnd.next(2, 100000000);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = constant_hi;\n        }\n    } else {\n        // Default to random\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i]; // xi\n            dominoes[i].second = rnd.next(2, 100000000); // hi\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output xi and hi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", dominoes[i].first, dominoes[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> dominoes;\n\n    if (type == \"random\") {\n        // Generate random xi and hi within constraints, ensuring unique xi\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i]; // xi\n            dominoes[i].second = rnd.next(2, 100000000); // hi\n        }\n    } else if (type == \"ordered_increasing\") {\n        // xi increasing from -1e8 to 1e8, hi random\n        dominoes.resize(n);\n        long long x_start = -100000000LL;\n        long long x_step = 200000000LL / n + 1; // To ensure unique xi\n        long long x = x_start;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = (int)x;\n            dominoes[i].second = rnd.next(2, 100000000);\n            x += x_step;\n            if (x > 100000000) x = 100000000; // Keep within bounds\n        }\n    } else if (type == \"ordered_decreasing\") {\n        // xi decreasing from 1e8 to -1e8, hi random\n        dominoes.resize(n);\n        long long x_start = 100000000LL;\n        long long x_step = 200000000LL / n + 1;\n        long long x = x_start;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = (int)x;\n            dominoes[i].second = rnd.next(2, 100000000);\n            x -= x_step;\n            if (x < -100000000) x = -100000000;\n        }\n    } else if (type == \"maximal_hi\") {\n        // hi = maximum value\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = 100000000; // Max hi\n        }\n    } else if (type == \"minimal_hi\") {\n        // hi = minimum value\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = 2; // Min hi\n        }\n    } else if (type == \"negative_xi\") {\n        // xi in negative range\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, -1);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = rnd.next(2, 100000000);\n        }\n    } else if (type == \"large_xi_hi\") {\n        // xi and hi near maximum values\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(100000000 - 100000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = rnd.next(100000000 - 100000, 100000000);\n        }\n    } else if (type == \"overlapping_dominoes\") {\n        // Design xi and hi so that each domino causes the next to fall\n        dominoes.resize(n);\n        int x = -100000000;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = x;\n            dominoes[i].second = 2; // Minimal hi to reach next domino\n            x += 1; // Next domino is at x + 1\n        }\n    } else if (type == \"non_overlapping_dominoes\") {\n        // Design xi and hi so that dominoes do not affect each other\n        dominoes.resize(n);\n        long long x = -100000000LL;\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = (int)x;\n            dominoes[i].second = rnd.next(2, 100000000);\n            x += (long long)dominoes[i].second + 1; // Move x beyond current domino's reach\n            if (x > 100000000) x = 100000000;\n        }\n    } else if (type == \"same_height\") {\n        // All hi are the same value\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        int constant_hi = rnd.next(2, 100000000);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i];\n            dominoes[i].second = constant_hi;\n        }\n    } else {\n        // Default to random\n        set<int> x_coords;\n        while ((int)x_coords.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            x_coords.insert(x);\n        }\n        vector<int> xi(x_coords.begin(), x_coords.end());\n        shuffle(xi.begin(), xi.end());\n\n        dominoes.resize(n);\n        for (int i = 0; i < n; ++i) {\n            dominoes[i].first = xi[i]; // xi\n            dominoes[i].second = rnd.next(2, 100000000); // hi\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output xi and hi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", dominoes[i].first, dominoes[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type ordered_increasing\n./gen -n 1 -type ordered_decreasing\n./gen -n 1 -type maximal_hi\n./gen -n 1 -type minimal_hi\n./gen -n 1 -type negative_xi\n./gen -n 1 -type overlapping_dominoes\n./gen -n 1 -type non_overlapping_dominoes\n./gen -n 1 -type same_height\n./gen -n 1 -type large_xi_hi\n\n./gen -n 10 -type random\n./gen -n 10 -type ordered_increasing\n./gen -n 10 -type ordered_decreasing\n./gen -n 10 -type maximal_hi\n./gen -n 10 -type minimal_hi\n./gen -n 10 -type negative_xi\n./gen -n 10 -type overlapping_dominoes\n./gen -n 10 -type non_overlapping_dominoes\n./gen -n 10 -type same_height\n./gen -n 10 -type large_xi_hi\n\n./gen -n 100 -type random\n./gen -n 100 -type ordered_increasing\n./gen -n 100 -type ordered_decreasing\n./gen -n 100 -type overlapping_dominoes\n./gen -n 100 -type non_overlapping_dominoes\n\n./gen -n 1000 -type random\n./gen -n 1000 -type ordered_increasing\n./gen -n 1000 -type ordered_decreasing\n./gen -n 1000 -type maximal_hi\n./gen -n 1000 -type minimal_hi\n./gen -n 1000 -type negative_xi\n./gen -n 1000 -type overlapping_dominoes\n./gen -n 1000 -type non_overlapping_dominoes\n./gen -n 1000 -type same_height\n./gen -n 1000 -type large_xi_hi\n\n./gen -n 100000 -type random\n./gen -n 100000 -type ordered_increasing\n./gen -n 100000 -type ordered_decreasing\n./gen -n 100000 -type maximal_hi\n./gen -n 100000 -type minimal_hi\n./gen -n 100000 -type negative_xi\n./gen -n 100000 -type overlapping_dominoes\n./gen -n 100000 -type non_overlapping_dominoes\n./gen -n 100000 -type same_height\n./gen -n 100000 -type large_xi_hi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:24.675700",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "560/A",
      "title": "A. Денежная система Геральдиона",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке дано число n (1 ≤ n ≤ 1000) — количество номиналов купюр, которые имеют хождение на Геральдионе. Во второй строке через пробел перечислены n различных чисел a1, a2, ..., an (1 ≤ ai ≤ 106) — сами номиналы купюр.",
      "output_spec": "Выходные данныеВыведите единственное число — минимальную неудачную сумму. Если же неудачных сумм не бывает, выведите  - 1.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 2 3 4 5Выходные данныеСкопировать-1",
      "description": "A. Денежная система Геральдиона\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке дано число n (1 ≤ n ≤ 1000) — количество номиналов купюр, которые имеют хождение на Геральдионе. Во второй строке через пробел перечислены n различных чисел a1, a2, ..., an (1 ≤ ai ≤ 106) — сами номиналы купюр.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — минимальную неудачную сумму. Если же неудачных сумм не бывает, выведите  - 1.\n\nВыходные данные\n\nВходные данныеСкопировать51 2 3 4 5Выходные данныеСкопировать-1\n\nВходные данныеСкопировать51 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Доброго всем времени суток!Приглашаю Вас поучаствовать в 313 Codeforces раунде, над которыми для вас работали я и tunyash. У каждого из нас за плечами по четыре раунда, так что это наш пятый или девятый раунд, как хотите. Я придумал почти все задачи (кроме D div.1), написал условия и разбор всех задач, а tunyash занимался разработкой всех задач.Gerald уже не является координатором, так что, возможно, Вы по нему соскучились. В этом раунде вы снова с ним встретитесь и поможете ему разобраться в его повседневных жизненных проблемах.Спасибо координатору Zlobober, нашей переводчице Марии Беловой (Delinur), а так же MikeMirzayanov и всей команде Codeforces за эту платформу.Этот раунд состоится в необычное время — 17:00 по Московскому времени.Соревнование закончилось, добро пожаловать в разбор! Краткий разбор. Подробный разбор.Разбалловка в первом дивизионе будет следующая:500 — 1000 — 1500 — 2250 — 2250А во втором дивизионе — стандартная:500 — 1000 — 1500 — 2000 — 2500Желаю всем получить удовольствие от решения задач!Поздравляем победителей!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1200
        },
        {
          "title": "VK Cup 2015: онлайн-трансляция и порция благодарностей - Codeforces",
          "content": "Мы были вынуждены удалить регистрации, сделанные до 00:00, так как регистрационная форма на тот момент не поддерживала регистрацию команд. Пожалуйста, пройдите регистрацию вновь, если ваша регистрация была удалена.Вчера завершился финал чемпионата VK Cup 2015, о котором вы могли прочитать в предыдущих наших постах. Осталось объявить последнее событие, связанное с прошедшим чемпионатом — онлайн-трансляцию, которая состоится в четверг 30 июля в 19:00 по Москве. К соревнованию допускаются как индивидуальные участники, так и команды из двух человек, которые желают почувствовать себя участниками финала соревнования. Трансляция продлится три часа, задачи будут перемешаны по сравнению с оригинальным порядком. Допускаются участники обоих дивизионом, но мы считаем своим долгом предупредить, что для участников из второго дивизиона набор задач, скорее всего, будет слишком сложным. Этот раунд является рейтинговым раундом Codeforces.В заключение мы хотели бы поблагодарить всех людей, которые помогли чемпионату состояться. Придумывали и готовили задачи для вас сотрудники ВКонтакте, члены команды Codeforces и другие люди, любезно предложившие свою помощь: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. Хочется сказать большое спасибо людям, прорешивавшим наши раунды, и дававшим ценные советы по поводу задач: winger и AlexFetisov. Также, мы благодарим всех работников ВКонтакте, с которыми вместе мы занимались проведением чемпионата: burunduk3, Burunduk2, KOTEHOK и многих других. Спасибо!Всем удачи на онлайн-трансляции!UPD: Обратите внимание, что во время раунда команде разрешается пользоваться только одним компьютером. Это значит, что программировать/пользоваться консолью/как-либо иначе продвигаться в решении задач в один момент времени можно только с одного компьютера. Единственное, что разрешается делать с двух компьютеров — это читать условия. UPD2: Так как это командное соревнование, специально для вашего удобства мы выкладываем запароленный архив с pdf-условиями задач: vkcup2015-mirror-statements.zip. С началом тура мы опубликуем пароль к нему.UPD3: В раунде будет использована динамическая разбалловка с шагом в 250 очков.UPD4: По техническим причинам начало раунда переносится на 19:20 по Москве.UPD5: Пароль на архив с условиями: vkcup4ever. Удачи!UPD6: Онлайн-трансляция завершена! Поздравляем победителей: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Мой персональный респектам команде Petr team: Petr, ilyakor за единственное решение по задаче Е в трансляции, пользователю rng_58 и команде Excited: YuukaKazami, jqdai0815 за два правильных решения по задаче С.Также, поздравляем пользователя rng_58, который продемонстрировал, что одиночному пользователю есть что противопоставить командам, состоящим из двух людей!Рейтинг будет пересчитан в ближайшее время.UPD7: Разбор!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2993
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces",
          "content": "560A - Денежная система ГеральдионаВ этой задаче главное — заметить, что если есть купюра номинала 1, то любую сумму денег можно выдать единичными купюрами. Если же такой купюры нет, то как раз сумму 1 представить нельзя. Поэтому, если нет купюры номинала 1, то ответ — 1, а если такая купюра есть — то -1.560B - Геральд увлекается исскусствомЛегко заметить, что можно прижать две картины друг в другу какими-то двумя краями, например, разместить одну картину прямо над другой. Тогда высота двух картин будет суммой высот картин, а ширина — максимум из ширин картин. Осталось перебрать все варианты, как повёрнуты картины и как при этом повёрнут стенд. Вот реализация.559A - Шестиугольник Геральда & 560C - Шестиугольник ГеральдаСперва заметим, что если правильный треугольник с целой стороной k отрезками, параллельными сторонам, разделить на правильные треугольники со стороной 1 (тут появляется картинка), то площадь большого треугольника будет в k2 раз больше площадей маленьких треугольничков и, следовательно, треугольник окажется разделён ровно на k2 единичных треугольничков.Далее, заметим, что если к сторонам a1, a3 и a5 шестиугольника пририсовать по правильному треугольнику со сторонами a1, a3 и a5 соответственно (и тут появляется ещё одна картинка), то получится большой правильный треугольник со стороной a1 + a2 + a3. Таким образом, площадь исходного шестиугольника равна (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Эквивалентные строки & 560D - Эквивалентные строкиНетрудно заметить, что \"эквивалентность\", описанная в задаче, в самом деле является отношением эквивалентности, то есть, оно симметрично, транзитивно и рефлексивно. Подробнее от отношениях эквивалентности можно почитать здесь. В частности, это означает, что все строки разбиваются на классы эквивалентности и нам надо проверить, что данные нам две строки принадлежат одному и тому же классу. Для этого давайте найдём лексикографически минимальную строку, которая лежит в одном классе эквивалентности с каждой из строк. Иными словами, найдём лексикографически минимальную строку, эквивалентную каждой из данных строк и проверим, получилась ли одна и та же строка.Осталось научиться находить лексикографически минимальную строку, эквивалентную данной, за приемлемое время. Это можно сделать, например, следующей рекурсивной функцией: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Поскольку каждый рекурсивный вызов работает линейно от длины переданной ему строки и внутри функции она сама два раза вызывается от вдвое меньшей строки, эта функция работает за время , где n — длина строки.559C - Геральд и гигантские шахматы & 560E - Геральд и гигантские шахматыОбозначим все чёрные клетки как A0, A1, ..., Ak - 1. Для начала, упорядочим чёрные клетки в порядке сверху вниз, а те, которые на одной высоте — слева направо. Теперь все чёрные клетки, из которых пешка Геральда могла бы попасть в данную чёрную клетку, находятся до неё. Покрасим нижнюю правую клетку в чёрный цвет и тоже добавим её в список чёрных клеток под номером k. Теперь пешке Геральда надо попасть в последнюю чёрную клетку, миновав все остальные.Посчитаем величину Di — количество способов попасть в Ai, миновав все предыдущие чёрные клетки. Как несложно заметить, ответом на задачу будет Dk. Общее количество способов дойти из клетки (1, 1) в клетку (xi, yi) равно . Вычтем из этого количества все способы попасть в Ai, зайдя по пути в одну из предыдущих чёрных клеток. Для этого переберём, какая из чёрных клеток могла первой попасться на пути. Это должна быть какая-то из предыдущих чёрных клеток, находящаяся не ниже и не правее, чем Ai. Для каждой такой клетки Aj надо вычесть произведение количества способов попасть в Aj, минуя все предыдущие чёрные клетки и количества способов просто попасть из Aj в Ai.Для вычисления биномиальных коэффициентов придётся преподсчитать факториалы всех чисел до 2·105 и научиться брать обратные к ним по модулю 109 + 7.559D - РандомизаторДля начала, вспомним формулу Пика. Благодаря ней, количество целых точек внутри любого многоугольника можно вычислить, зная его площадь и количество целых точек на границе. Количество целых точек на отрезке, соединяющем точки (0, 0) и (a, b) можно посчитать, найдя НОД(a, b).Давайте вычислим общее количество целых точек в основном многоугольнике, а затем для каждого отрезка, соединяющего какие-то две вершины многоугольника, вычтем из этой величины произведение вероятности того, что этот отрезок будет стороной выбранного многоугольника и количество целых точек в сегменте основного многоугольника, который отсекает этот отрезок. Вероятность легко посчитать. Если отрезок соединяет вершины Ai и Ai + k, то существует ровно 2n - k - 1 - 1 многоугольник, в котором есть такая сторона, а общее количество валидных многоугольников равняется .Количество целых точек в отсекаемом отрезком AiAi + k сегменте тоже легко посчитать с помощью с формулы Пика за время O(k), а если воспользоваться тем, что перед этим мы посчитали количество целых точек в сегменте, отсекаемом AiAi + k - 1, можно сделать это за время O(1).Таким образом, получается решение за время ( -- время вычисления НОД двух натуральных чисел, не превосходящих MAX). Это, конечно, слишком много.Давайте обратим внимание на вероятность появления каждой из сторон. Вероятность появления в многоугольнике стороны, пропускающей k - 1 вершину многоугольника, равна . Как видно, эта вероятность экспоненциально падает с ростом k. В частности, если общее количество целых точек в многоугольнике равно V, то сумма всех слагаемых, соответствующих отрезкам с k ≥ 60 не превосходит . Таким образом, все слагаемые, соответствующие отрезкам с k ≥ 60, можно просто игнорировать. Следует отметить, что 60 — это очень грубая оценка, не учитывающая, что для большинства отрезков вероятность будет гораздо меньше, чем 2 - 60, а для отрезков с k порядка 60 количество целых точек внутри сегмента будет порядка , а вовсе не порядка V.Таким образом, мы получаем решение за время , поскольку 60 — это ни что иное, как .559E - Геральд и тропинкаОсвещённая часть тропинки представляет собой объединение нескольких непересекающихся освещенных отрезков (возможно, одного). Давайте упорядочим прожекторы по возрастанию ai. Заметим, что каждый освещенный отрезок освещается некоторой \"подстрокой\" прожекторов, то есть, множеством прожекторов с номерами из некоторого отрезка [l, r]. Пусть x0, ..., xk — упорядоченная последовательность потенциальных концов отрезков, то есть, всех чисел вида ai - li, ai и ai + li.Представим себе, что мы знаем, какие именно отрезки тропинки можно осветить с помощью каждой подстроки прожекторов. Сохраним в массив left[][][] информацию о самых длинных возможных освещенных отрезках в следующем виде: left[l][r][j] — самое маленькое такое i, что подстрока [l, r] прожекторов может освещать отрезок [xi, xj].Теперь, имея массив left, посчитаем динамикой величину best[R][i] — какую максимальную длину тропинки можно осветить, используя первые L прожекторов так, чтобы самой правой освещённой точкой была xi. Это легко сделать за время O(n4), так как .Теперь давайте вычислим массив left. Рассмотрим некую подстроку прожекторов [l, r]. Пусть все прожекторы этой подстроки как-то ориентированы и освещают некоторую область тропинки. У этой области можно рассмотреть самую левую (i) и самую правую (j) освещенную точки, а также правый конец самого левого освещенного отрезка (t). Если область является одним отрезком, то t = j. Рассмотрим, как меняются эти три параметра, когда мы добавляем к подстроке прожектор r + 1 и выбираем его ориентацию. К освещенной области добавляется отрезок [a, b], который равен [ai - li, ai] или [ai, ai + li]. Самая левая освещенная точка становится min(a, xi), самая правая — max(b, xj). А правый конец самого левого отрезка не меняется, если a > t или становится b, если a ≤ t.Эти соотношения позволяют для каждого фиксированного L вычислить динамикой величину dp[r][j][y] — наименьшее такое i, что можно ориентировать прожекторы подстроки [L, r] так, чтобы самая левая освещенная точка была xi, самая правая — xj, а правый конец самого левого отрезка — xt. Вычислив это, уже легко посчитать значения массива left[L][][]. Эта часть решения тоже будет работать за время O(n4).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 560\\s*A"
          },
          "content_length": 8382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 3",
          "code": "T(n) = 4*T(n / 2) => T(n) = n^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 4",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 5",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 6",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 7",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 8",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 9",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 10",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 11",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 12",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 13",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 14",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 15",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 16",
          "code": "cout << fixed",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 17",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 18",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 19",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 20",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 21",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All a_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All a_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All a_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n    set<int> used;\n\n    if (type == \"include_one\") {\n        // Include 1 in the denominations\n        a.push_back(1);\n        used.insert(1);\n        for (int i = 1; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(2, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"no_one_gcd_1\") {\n        // Denominations without 1, GCD is 1\n        int x = rnd.next(2, 1000000);\n        a.push_back(x);\n        used.insert(x);\n        for (int i = 1; i < n; i++) {\n            int y;\n            do {\n                y = rnd.next(2, 1000000);\n            } while (used.count(y) || __gcd(x, y) != 1);\n            used.insert(y);\n            a.push_back(y);\n        }\n    } else if (type == \"gcd_gt_1\") {\n        // Denominations with GCD greater than 1\n        int g = rnd.next(2, 100);\n        for (int i = 0; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000 / g) * g;\n            } while (used.count(x) || x < 1 || x > 1000000);\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"max_ai\") {\n        // Denominations include maximum possible values\n        for (int i = 0; i < n; i++) {\n            int x = 1000000 - i;\n            if (x < 1) x = 1;\n            if (!used.count(x)) {\n                used.insert(x);\n                a.push_back(x);\n            }\n        }\n        while (a.size() < n) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"min_ai\") {\n        // Denominations include minimal possible values\n        for (int i = 0; i < n; i++) {\n            int x = i + 1;\n            if (x > 1000000) x = 1000000;\n            if (!used.count(x)) {\n                used.insert(x);\n                a.push_back(x);\n            }\n        }\n        while (a.size() < n) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"random\") {\n        // Random denominations between 1 and 1,000,000\n        for (int i = 0; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n    set<int> used;\n\n    if (type == \"include_one\") {\n        // Include 1 in the denominations\n        a.push_back(1);\n        used.insert(1);\n        for (int i = 1; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(2, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"no_one_gcd_1\") {\n        // Denominations without 1, GCD is 1\n        int x = rnd.next(2, 1000000);\n        a.push_back(x);\n        used.insert(x);\n        for (int i = 1; i < n; i++) {\n            int y;\n            do {\n                y = rnd.next(2, 1000000);\n            } while (used.count(y) || __gcd(x, y) != 1);\n            used.insert(y);\n            a.push_back(y);\n        }\n    } else if (type == \"gcd_gt_1\") {\n        // Denominations with GCD greater than 1\n        int g = rnd.next(2, 100);\n        for (int i = 0; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000 / g) * g;\n            } while (used.count(x) || x < 1 || x > 1000000);\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"max_ai\") {\n        // Denominations include maximum possible values\n        for (int i = 0; i < n; i++) {\n            int x = 1000000 - i;\n            if (x < 1) x = 1;\n            if (!used.count(x)) {\n                used.insert(x);\n                a.push_back(x);\n            }\n        }\n        while (a.size() < n) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"min_ai\") {\n        // Denominations include minimal possible values\n        for (int i = 0; i < n; i++) {\n            int x = i + 1;\n            if (x > 1000000) x = 1000000;\n            if (!used.count(x)) {\n                used.insert(x);\n                a.push_back(x);\n            }\n        }\n        while (a.size() < n) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else if (type == \"random\") {\n        // Random denominations between 1 and 1,000,000\n        for (int i = 0; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a.push_back(x);\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type include_one\n./gen -n 1 -type no_one_gcd_1\n./gen -n 1 -type gcd_gt_1\n./gen -n 1 -type random\n\n./gen -n 2 -type include_one\n./gen -n 2 -type no_one_gcd_1\n./gen -n 2 -type gcd_gt_1\n./gen -n 2 -type random\n\n./gen -n 10 -type include_one\n./gen -n 10 -type no_one_gcd_1\n./gen -n 10 -type gcd_gt_1\n./gen -n 10 -type random\n\n./gen -n 100 -type include_one\n./gen -n 100 -type no_one_gcd_1\n./gen -n 100 -type gcd_gt_1\n./gen -n 100 -type random\n\n./gen -n 1000 -type include_one\n./gen -n 1000 -type no_one_gcd_1\n./gen -n 1000 -type gcd_gt_1\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:26.278479",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "560/B",
      "title": "B. Геральд увлекается исскусством",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке даны через пробел два числа a1 и b1 — стороны рабочей поверхности стенда. В следующих двух строках даны числа a2, b2, a3 и b3 — стороны картин. Все числа ai, bi во входных данных целые и находятся в пределах от 1 до 1000.",
      "output_spec": "Выходные данныеЕсли картины можно разместить на стенде, выведите «YES» (без кавычек), а если нельзя, выведите «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 21 32 1Выходные данныеСкопироватьYESВходные данныеСкопировать5 53 33 3Выходные данныеСкопироватьNOВходные данныеСкопировать4 22 31 2Выходные данныеСкопироватьYES",
      "description": "B. Геральд увлекается исскусством\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке даны через пробел два числа a1 и b1 — стороны рабочей поверхности стенда. В следующих двух строках даны числа a2, b2, a3 и b3 — стороны картин. Все числа ai, bi во входных данных целые и находятся в пределах от 1 до 1000.\n\nВходные данные\n\nВыходные данныеЕсли картины можно разместить на стенде, выведите «YES» (без кавычек), а если нельзя, выведите «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать3 21 32 1Выходные данныеСкопироватьYESВходные данныеСкопировать5 53 33 3Выходные данныеСкопироватьNOВходные данныеСкопировать4 22 31 2Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать3 21 32 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 53 33 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 22 31 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВот так можно разместить картины в первом тесте:А вот так — в третьем.",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Доброго всем времени суток!Приглашаю Вас поучаствовать в 313 Codeforces раунде, над которыми для вас работали я и tunyash. У каждого из нас за плечами по четыре раунда, так что это наш пятый или девятый раунд, как хотите. Я придумал почти все задачи (кроме D div.1), написал условия и разбор всех задач, а tunyash занимался разработкой всех задач.Gerald уже не является координатором, так что, возможно, Вы по нему соскучились. В этом раунде вы снова с ним встретитесь и поможете ему разобраться в его повседневных жизненных проблемах.Спасибо координатору Zlobober, нашей переводчице Марии Беловой (Delinur), а так же MikeMirzayanov и всей команде Codeforces за эту платформу.Этот раунд состоится в необычное время — 17:00 по Московскому времени.Соревнование закончилось, добро пожаловать в разбор! Краткий разбор. Подробный разбор.Разбалловка в первом дивизионе будет следующая:500 — 1000 — 1500 — 2250 — 2250А во втором дивизионе — стандартная:500 — 1000 — 1500 — 2000 — 2500Желаю всем получить удовольствие от решения задач!Поздравляем победителей!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1200
        },
        {
          "title": "VK Cup 2015: онлайн-трансляция и порция благодарностей - Codeforces",
          "content": "Мы были вынуждены удалить регистрации, сделанные до 00:00, так как регистрационная форма на тот момент не поддерживала регистрацию команд. Пожалуйста, пройдите регистрацию вновь, если ваша регистрация была удалена.Вчера завершился финал чемпионата VK Cup 2015, о котором вы могли прочитать в предыдущих наших постах. Осталось объявить последнее событие, связанное с прошедшим чемпионатом — онлайн-трансляцию, которая состоится в четверг 30 июля в 19:00 по Москве. К соревнованию допускаются как индивидуальные участники, так и команды из двух человек, которые желают почувствовать себя участниками финала соревнования. Трансляция продлится три часа, задачи будут перемешаны по сравнению с оригинальным порядком. Допускаются участники обоих дивизионом, но мы считаем своим долгом предупредить, что для участников из второго дивизиона набор задач, скорее всего, будет слишком сложным. Этот раунд является рейтинговым раундом Codeforces.В заключение мы хотели бы поблагодарить всех людей, которые помогли чемпионату состояться. Придумывали и готовили задачи для вас сотрудники ВКонтакте, члены команды Codeforces и другие люди, любезно предложившие свою помощь: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. Хочется сказать большое спасибо людям, прорешивавшим наши раунды, и дававшим ценные советы по поводу задач: winger и AlexFetisov. Также, мы благодарим всех работников ВКонтакте, с которыми вместе мы занимались проведением чемпионата: burunduk3, Burunduk2, KOTEHOK и многих других. Спасибо!Всем удачи на онлайн-трансляции!UPD: Обратите внимание, что во время раунда команде разрешается пользоваться только одним компьютером. Это значит, что программировать/пользоваться консолью/как-либо иначе продвигаться в решении задач в один момент времени можно только с одного компьютера. Единственное, что разрешается делать с двух компьютеров — это читать условия. UPD2: Так как это командное соревнование, специально для вашего удобства мы выкладываем запароленный архив с pdf-условиями задач: vkcup2015-mirror-statements.zip. С началом тура мы опубликуем пароль к нему.UPD3: В раунде будет использована динамическая разбалловка с шагом в 250 очков.UPD4: По техническим причинам начало раунда переносится на 19:20 по Москве.UPD5: Пароль на архив с условиями: vkcup4ever. Удачи!UPD6: Онлайн-трансляция завершена! Поздравляем победителей: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Мой персональный респектам команде Petr team: Petr, ilyakor за единственное решение по задаче Е в трансляции, пользователю rng_58 и команде Excited: YuukaKazami, jqdai0815 за два правильных решения по задаче С.Также, поздравляем пользователя rng_58, который продемонстрировал, что одиночному пользователю есть что противопоставить командам, состоящим из двух людей!Рейтинг будет пересчитан в ближайшее время.UPD7: Разбор!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2993
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces",
          "content": "560A - Денежная система ГеральдионаВ этой задаче главное — заметить, что если есть купюра номинала 1, то любую сумму денег можно выдать единичными купюрами. Если же такой купюры нет, то как раз сумму 1 представить нельзя. Поэтому, если нет купюры номинала 1, то ответ — 1, а если такая купюра есть — то -1.560B - Геральд увлекается исскусствомЛегко заметить, что можно прижать две картины друг в другу какими-то двумя краями, например, разместить одну картину прямо над другой. Тогда высота двух картин будет суммой высот картин, а ширина — максимум из ширин картин. Осталось перебрать все варианты, как повёрнуты картины и как при этом повёрнут стенд. Вот реализация.559A - Шестиугольник Геральда & 560C - Шестиугольник ГеральдаСперва заметим, что если правильный треугольник с целой стороной k отрезками, параллельными сторонам, разделить на правильные треугольники со стороной 1 (тут появляется картинка), то площадь большого треугольника будет в k2 раз больше площадей маленьких треугольничков и, следовательно, треугольник окажется разделён ровно на k2 единичных треугольничков.Далее, заметим, что если к сторонам a1, a3 и a5 шестиугольника пририсовать по правильному треугольнику со сторонами a1, a3 и a5 соответственно (и тут появляется ещё одна картинка), то получится большой правильный треугольник со стороной a1 + a2 + a3. Таким образом, площадь исходного шестиугольника равна (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Эквивалентные строки & 560D - Эквивалентные строкиНетрудно заметить, что \"эквивалентность\", описанная в задаче, в самом деле является отношением эквивалентности, то есть, оно симметрично, транзитивно и рефлексивно. Подробнее от отношениях эквивалентности можно почитать здесь. В частности, это означает, что все строки разбиваются на классы эквивалентности и нам надо проверить, что данные нам две строки принадлежат одному и тому же классу. Для этого давайте найдём лексикографически минимальную строку, которая лежит в одном классе эквивалентности с каждой из строк. Иными словами, найдём лексикографически минимальную строку, эквивалентную каждой из данных строк и проверим, получилась ли одна и та же строка.Осталось научиться находить лексикографически минимальную строку, эквивалентную данной, за приемлемое время. Это можно сделать, например, следующей рекурсивной функцией: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Поскольку каждый рекурсивный вызов работает линейно от длины переданной ему строки и внутри функции она сама два раза вызывается от вдвое меньшей строки, эта функция работает за время , где n — длина строки.559C - Геральд и гигантские шахматы & 560E - Геральд и гигантские шахматыОбозначим все чёрные клетки как A0, A1, ..., Ak - 1. Для начала, упорядочим чёрные клетки в порядке сверху вниз, а те, которые на одной высоте — слева направо. Теперь все чёрные клетки, из которых пешка Геральда могла бы попасть в данную чёрную клетку, находятся до неё. Покрасим нижнюю правую клетку в чёрный цвет и тоже добавим её в список чёрных клеток под номером k. Теперь пешке Геральда надо попасть в последнюю чёрную клетку, миновав все остальные.Посчитаем величину Di — количество способов попасть в Ai, миновав все предыдущие чёрные клетки. Как несложно заметить, ответом на задачу будет Dk. Общее количество способов дойти из клетки (1, 1) в клетку (xi, yi) равно . Вычтем из этого количества все способы попасть в Ai, зайдя по пути в одну из предыдущих чёрных клеток. Для этого переберём, какая из чёрных клеток могла первой попасться на пути. Это должна быть какая-то из предыдущих чёрных клеток, находящаяся не ниже и не правее, чем Ai. Для каждой такой клетки Aj надо вычесть произведение количества способов попасть в Aj, минуя все предыдущие чёрные клетки и количества способов просто попасть из Aj в Ai.Для вычисления биномиальных коэффициентов придётся преподсчитать факториалы всех чисел до 2·105 и научиться брать обратные к ним по модулю 109 + 7.559D - РандомизаторДля начала, вспомним формулу Пика. Благодаря ней, количество целых точек внутри любого многоугольника можно вычислить, зная его площадь и количество целых точек на границе. Количество целых точек на отрезке, соединяющем точки (0, 0) и (a, b) можно посчитать, найдя НОД(a, b).Давайте вычислим общее количество целых точек в основном многоугольнике, а затем для каждого отрезка, соединяющего какие-то две вершины многоугольника, вычтем из этой величины произведение вероятности того, что этот отрезок будет стороной выбранного многоугольника и количество целых точек в сегменте основного многоугольника, который отсекает этот отрезок. Вероятность легко посчитать. Если отрезок соединяет вершины Ai и Ai + k, то существует ровно 2n - k - 1 - 1 многоугольник, в котором есть такая сторона, а общее количество валидных многоугольников равняется .Количество целых точек в отсекаемом отрезком AiAi + k сегменте тоже легко посчитать с помощью с формулы Пика за время O(k), а если воспользоваться тем, что перед этим мы посчитали количество целых точек в сегменте, отсекаемом AiAi + k - 1, можно сделать это за время O(1).Таким образом, получается решение за время ( -- время вычисления НОД двух натуральных чисел, не превосходящих MAX). Это, конечно, слишком много.Давайте обратим внимание на вероятность появления каждой из сторон. Вероятность появления в многоугольнике стороны, пропускающей k - 1 вершину многоугольника, равна . Как видно, эта вероятность экспоненциально падает с ростом k. В частности, если общее количество целых точек в многоугольнике равно V, то сумма всех слагаемых, соответствующих отрезкам с k ≥ 60 не превосходит . Таким образом, все слагаемые, соответствующие отрезкам с k ≥ 60, можно просто игнорировать. Следует отметить, что 60 — это очень грубая оценка, не учитывающая, что для большинства отрезков вероятность будет гораздо меньше, чем 2 - 60, а для отрезков с k порядка 60 количество целых точек внутри сегмента будет порядка , а вовсе не порядка V.Таким образом, мы получаем решение за время , поскольку 60 — это ни что иное, как .559E - Геральд и тропинкаОсвещённая часть тропинки представляет собой объединение нескольких непересекающихся освещенных отрезков (возможно, одного). Давайте упорядочим прожекторы по возрастанию ai. Заметим, что каждый освещенный отрезок освещается некоторой \"подстрокой\" прожекторов, то есть, множеством прожекторов с номерами из некоторого отрезка [l, r]. Пусть x0, ..., xk — упорядоченная последовательность потенциальных концов отрезков, то есть, всех чисел вида ai - li, ai и ai + li.Представим себе, что мы знаем, какие именно отрезки тропинки можно осветить с помощью каждой подстроки прожекторов. Сохраним в массив left[][][] информацию о самых длинных возможных освещенных отрезках в следующем виде: left[l][r][j] — самое маленькое такое i, что подстрока [l, r] прожекторов может освещать отрезок [xi, xj].Теперь, имея массив left, посчитаем динамикой величину best[R][i] — какую максимальную длину тропинки можно осветить, используя первые L прожекторов так, чтобы самой правой освещённой точкой была xi. Это легко сделать за время O(n4), так как .Теперь давайте вычислим массив left. Рассмотрим некую подстроку прожекторов [l, r]. Пусть все прожекторы этой подстроки как-то ориентированы и освещают некоторую область тропинки. У этой области можно рассмотреть самую левую (i) и самую правую (j) освещенную точки, а также правый конец самого левого освещенного отрезка (t). Если область является одним отрезком, то t = j. Рассмотрим, как меняются эти три параметра, когда мы добавляем к подстроке прожектор r + 1 и выбираем его ориентацию. К освещенной области добавляется отрезок [a, b], который равен [ai - li, ai] или [ai, ai + li]. Самая левая освещенная точка становится min(a, xi), самая правая — max(b, xj). А правый конец самого левого отрезка не меняется, если a > t или становится b, если a ≤ t.Эти соотношения позволяют для каждого фиксированного L вычислить динамикой величину dp[r][j][y] — наименьшее такое i, что можно ориентировать прожекторы подстроки [L, r] так, чтобы самая левая освещенная точка была xi, самая правая — xj, а правый конец самого левого отрезка — xt. Вычислив это, уже легко посчитать значения массива left[L][][]. Эта часть решения тоже будет работать за время O(n4).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 560\\s*B"
          },
          "content_length": 8382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 3",
          "code": "T(n) = 4*T(n / 2) => T(n) = n^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 4",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 5",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 6",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 7",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 8",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 9",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 10",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 11",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 12",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 13",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 14",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 15",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 16",
          "code": "cout << fixed",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 17",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 18",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 19",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 20",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 21",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a1 = inf.readInt(1, 1000, \"a1\");\n    inf.readSpace();\n    int b1 = inf.readInt(1, 1000, \"b1\");\n    inf.readEoln();\n\n    int a2 = inf.readInt(1, 1000, \"a2\");\n    inf.readSpace();\n    int b2 = inf.readInt(1, 1000, \"b2\");\n    inf.readEoln();\n\n    int a3 = inf.readInt(1, 1000, \"a3\");\n    inf.readSpace();\n    int b3 = inf.readInt(1, 1000, \"b3\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a1 = inf.readInt(1, 1000, \"a1\");\n    inf.readSpace();\n    int b1 = inf.readInt(1, 1000, \"b1\");\n    inf.readEoln();\n\n    int a2 = inf.readInt(1, 1000, \"a2\");\n    inf.readSpace();\n    int b2 = inf.readInt(1, 1000, \"b2\");\n    inf.readEoln();\n\n    int a3 = inf.readInt(1, 1000, \"a3\");\n    inf.readSpace();\n    int b3 = inf.readInt(1, 1000, \"b3\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a1 = inf.readInt(1, 1000, \"a1\");\n    inf.readSpace();\n    int b1 = inf.readInt(1, 1000, \"b1\");\n    inf.readEoln();\n\n    int a2 = inf.readInt(1, 1000, \"a2\");\n    inf.readSpace();\n    int b2 = inf.readInt(1, 1000, \"b2\");\n    inf.readEoln();\n\n    int a3 = inf.readInt(1, 1000, \"a3\");\n    inf.readSpace();\n    int b3 = inf.readInt(1, 1000, \"b3\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int a1, b1, a2, b2, a3, b3;\n\n    if (type == \"random\") {\n        // Random sizes for the board and paintings\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(1, 1000);\n        b2 = rnd.next(1, 1000);\n        a3 = rnd.next(1, 1000);\n        b3 = rnd.next(1, 1000);\n    } else if (type == \"max_size\") {\n        // Sizes at maximum\n        a1 = b1 = a2 = b2 = a3 = b3 = 1000;\n    } else if (type == \"min_size\") {\n        // Sizes at minimum\n        a1 = b1 = a2 = b2 = a3 = b3 = 1;\n    } else if (type == \"equal_sizes\") {\n        // All sizes equal to the same random value\n        int val = rnd.next(1, 1000);\n        a1 = b1 = a2 = b2 = a3 = b3 = val;\n    } else if (type == \"board_equal_paintings\") {\n        // Painting sizes equal to the board size\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = a1;\n        b2 = b1;\n        a3 = a1;\n        b3 = b1;\n    } else if (type == \"one_painting_fits\") {\n        // Only the first painting fits in the board\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(1, a1);\n        b2 = rnd.next(1, b1);\n        a3 = rnd.next(max(a1, b1) + 1, 1000);\n        b3 = rnd.next(max(a1, b1) + 1, 1000);\n    } else if (type == \"no_painting_fits\") {\n        // Neither painting fits in the board even after rotation\n        a1 = rnd.next(1, 999);\n        b1 = rnd.next(1, 999);\n        a2 = rnd.next(max(a1, b1) + 1, 1000);\n        b2 = rnd.next(max(a1, b1) + 1, 1000);\n        a3 = rnd.next(max(a1, b1) + 1, 1000);\n        b3 = rnd.next(max(a1, b1) + 1, 1000);\n    } else if (type == \"rotation_needed\") {\n        // Paintings only fit if rotated\n        a1 = rnd.next(5, 1000);\n        b1 = rnd.next(5, 1000);\n        // First painting dimensions are swapped\n        a2 = b1;\n        b2 = a1;\n        a3 = rnd.next(1, min(a1, b1));\n        b3 = rnd.next(1, min(a1, b1));\n    } else if (type == \"just_fit\") {\n        // Paintings just fit the board without extra space\n        // Generate two paintings and set board dimensions accordingly\n        a2 = rnd.next(1, 500);\n        b2 = rnd.next(1, 500);\n        a3 = rnd.next(1, 500);\n        b3 = rnd.next(1, 500);\n        // Try all combinations of rotations\n        vector<pair<int, int>> dims2 = { {a2, b2}, {b2, a2} };\n        vector<pair<int, int>> dims3 = { {a3, b3}, {b3, a3} };\n        bool found = false;\n        for (auto& d2 : dims2) {\n            for (auto& d3 : dims3) {\n                int width1 = d2.first + d3.first;\n                int height1 = max(d2.second, d3.second);\n                int width2 = max(d2.first, d3.first);\n                int height2 = d2.second + d3.second;\n                if (width1 <= 1000 && height1 <= 1000) {\n                    a1 = width1;\n                    b1 = height1;\n                    found = true;\n                    break;\n                }\n                if (width2 <= 1000 && height2 <= 1000) {\n                    a1 = width2;\n                    b1 = height2;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n        if (!found) {\n            // Set board size to maximum possible\n            a1 = min(1000, a2 + a3);\n            b1 = min(1000, b2 + b3);\n        }\n    } else if (type == \"overlap_needed\") {\n        // Paintings can only fit by overlapping\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(a1 / 2 + 1, min(a1, 1000));\n        b2 = rnd.next(b1 / 2 + 1, min(b1, 1000));\n        a3 = a2;\n        b3 = b2;\n    } else if (type == \"different_aspect_ratios\") {\n        // Paintings and board have different aspect ratios\n        do {\n            a1 = rnd.next(1, 1000);\n            b1 = rnd.next(1, 1000);\n        } while (a1 == b1);\n        do {\n            a2 = rnd.next(1, 1000);\n            b2 = rnd.next(1, 1000);\n        } while (a2 == b2);\n        do {\n            a3 = rnd.next(1, 1000);\n            b3 = rnd.next(1, 1000);\n        } while (a3 == b3);\n    } else {\n        // Default to random sizes\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(1, 1000);\n        b2 = rnd.next(1, 1000);\n        a3 = rnd.next(1, 1000);\n        b3 = rnd.next(1, 1000);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", a1, b1);\n    printf(\"%d %d\\n\", a2, b2);\n    printf(\"%d %d\\n\", a3, b3);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int a1, b1, a2, b2, a3, b3;\n\n    if (type == \"random\") {\n        // Random sizes for the board and paintings\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(1, 1000);\n        b2 = rnd.next(1, 1000);\n        a3 = rnd.next(1, 1000);\n        b3 = rnd.next(1, 1000);\n    } else if (type == \"max_size\") {\n        // Sizes at maximum\n        a1 = b1 = a2 = b2 = a3 = b3 = 1000;\n    } else if (type == \"min_size\") {\n        // Sizes at minimum\n        a1 = b1 = a2 = b2 = a3 = b3 = 1;\n    } else if (type == \"equal_sizes\") {\n        // All sizes equal to the same random value\n        int val = rnd.next(1, 1000);\n        a1 = b1 = a2 = b2 = a3 = b3 = val;\n    } else if (type == \"board_equal_paintings\") {\n        // Painting sizes equal to the board size\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = a1;\n        b2 = b1;\n        a3 = a1;\n        b3 = b1;\n    } else if (type == \"one_painting_fits\") {\n        // Only the first painting fits in the board\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(1, a1);\n        b2 = rnd.next(1, b1);\n        a3 = rnd.next(max(a1, b1) + 1, 1000);\n        b3 = rnd.next(max(a1, b1) + 1, 1000);\n    } else if (type == \"no_painting_fits\") {\n        // Neither painting fits in the board even after rotation\n        a1 = rnd.next(1, 999);\n        b1 = rnd.next(1, 999);\n        a2 = rnd.next(max(a1, b1) + 1, 1000);\n        b2 = rnd.next(max(a1, b1) + 1, 1000);\n        a3 = rnd.next(max(a1, b1) + 1, 1000);\n        b3 = rnd.next(max(a1, b1) + 1, 1000);\n    } else if (type == \"rotation_needed\") {\n        // Paintings only fit if rotated\n        a1 = rnd.next(5, 1000);\n        b1 = rnd.next(5, 1000);\n        // First painting dimensions are swapped\n        a2 = b1;\n        b2 = a1;\n        a3 = rnd.next(1, min(a1, b1));\n        b3 = rnd.next(1, min(a1, b1));\n    } else if (type == \"just_fit\") {\n        // Paintings just fit the board without extra space\n        // Generate two paintings and set board dimensions accordingly\n        a2 = rnd.next(1, 500);\n        b2 = rnd.next(1, 500);\n        a3 = rnd.next(1, 500);\n        b3 = rnd.next(1, 500);\n        // Try all combinations of rotations\n        vector<pair<int, int>> dims2 = { {a2, b2}, {b2, a2} };\n        vector<pair<int, int>> dims3 = { {a3, b3}, {b3, a3} };\n        bool found = false;\n        for (auto& d2 : dims2) {\n            for (auto& d3 : dims3) {\n                int width1 = d2.first + d3.first;\n                int height1 = max(d2.second, d3.second);\n                int width2 = max(d2.first, d3.first);\n                int height2 = d2.second + d3.second;\n                if (width1 <= 1000 && height1 <= 1000) {\n                    a1 = width1;\n                    b1 = height1;\n                    found = true;\n                    break;\n                }\n                if (width2 <= 1000 && height2 <= 1000) {\n                    a1 = width2;\n                    b1 = height2;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n        if (!found) {\n            // Set board size to maximum possible\n            a1 = min(1000, a2 + a3);\n            b1 = min(1000, b2 + b3);\n        }\n    } else if (type == \"overlap_needed\") {\n        // Paintings can only fit by overlapping\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(a1 / 2 + 1, min(a1, 1000));\n        b2 = rnd.next(b1 / 2 + 1, min(b1, 1000));\n        a3 = a2;\n        b3 = b2;\n    } else if (type == \"different_aspect_ratios\") {\n        // Paintings and board have different aspect ratios\n        do {\n            a1 = rnd.next(1, 1000);\n            b1 = rnd.next(1, 1000);\n        } while (a1 == b1);\n        do {\n            a2 = rnd.next(1, 1000);\n            b2 = rnd.next(1, 1000);\n        } while (a2 == b2);\n        do {\n            a3 = rnd.next(1, 1000);\n            b3 = rnd.next(1, 1000);\n        } while (a3 == b3);\n    } else {\n        // Default to random sizes\n        a1 = rnd.next(1, 1000);\n        b1 = rnd.next(1, 1000);\n        a2 = rnd.next(1, 1000);\n        b2 = rnd.next(1, 1000);\n        a3 = rnd.next(1, 1000);\n        b3 = rnd.next(1, 1000);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", a1, b1);\n    printf(\"%d %d\\n\", a2, b2);\n    printf(\"%d %d\\n\", a3, b3);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max_size\n\n./gen -type min_size\n\n./gen -type equal_sizes\n\n./gen -type board_equal_paintings\n\n./gen -type one_painting_fits\n./gen -type one_painting_fits\n\n./gen -type no_painting_fits\n./gen -type no_painting_fits\n\n./gen -type rotation_needed\n./gen -type rotation_needed\n./gen -type rotation_needed\n\n./gen -type just_fit\n./gen -type just_fit\n./gen -type just_fit\n\n./gen -type overlap_needed\n./gen -type overlap_needed\n\n./gen -type different_aspect_ratios\n./gen -type different_aspect_ratios\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:28.164909",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "560/C",
      "title": "C. Gerald's Hexagon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and the single line of the input contains 6 space-separated integers a1, a2, a3, a4, a5 and a6 (1 ≤ ai ≤ 1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.",
      "output_spec": "OutputPrint a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.",
      "sample_tests": "ExamplesInputCopy1 1 1 1 1 1OutputCopy6InputCopy1 2 1 2 1 2OutputCopy13",
      "description": "C. Gerald's Hexagon\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and the single line of the input contains 6 space-separated integers a1, a2, a3, a4, a5 and a6 (1 ≤ ai ≤ 1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.\n\nOutputPrint a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.\n\nInputCopy1 1 1 1 1 1OutputCopy6InputCopy1 2 1 2 1 2OutputCopy13\n\nInputCopy1 1 1 1 1 1\n\nOutputCopy6\n\nInputCopy1 2 1 2 1 2\n\nOutputCopy13\n\nNoteThis is what Gerald's hexagon looks like in the first sample:And that's what it looks like in the second sample:",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the Codeforces round 313, which is prepeared by me and tunyash. Each of us is prepared four rounds then it is our fifth of ninth round to your notice. I figured out almost all problems (except D div.1), wrote the statements and analysis of all the problems, and tunyash has developed all problems.Gerald is not coordinator yet and you probobly missed him. In this round you will meet him again and help him in his ordinary life problems.I want to thank Zlobober, our translator Maria Belova (Delinur) and MikeMirzayanov and all Codeforces team for this platform.This round will be held in unusual time — 17:00 Moscow Time.Contest finished! Welcome to editoral: Short editoral. Extended editoral.Div.1 scoring distribution:500 — 1000 — 1500 — 2250 — 2250Div.2 scoring distribution:500 — 1000 — 1500 — 2000 — 2500I wish you to enjoy solving problems!Congratulations to winners!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1073
        },
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces",
          "content": "560A - Currency System in GeraldionIf there is a banlnot of value 1 then one can to express every sum of money. Otherwise one can't to express 1 and it is minimum unfortunate sum.560B - Gerald is into ArtIt is easy to see that one can snuggle paintings to each other and to edge of board. For instance one can put one of painting right over other. Then height of two paintings equals to sum of two heights and width of two paintings is equals to maximum of two widths. Now we can just iterate orientation of paintings and board.559A - Gerald's Hexagon & 560C - Gerald's HexagonLet's consider regular triangle with sides of k Let's split it to regular triangles with sides of 1 by lines parallel to the sides. Big triange area k2 times larger then small triangles area and therefore big triangle have splitted by k2 small triangles.If we join regular triangles to sides a1, a3 and a5 of hexagon we get a triangle sides of a1 + a2 + a3. Then hexagon area is equals to (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Equivalent Strings & 560D - Equivalent StringsLet us note that \"equivalence\" described in the statements is actually equivalence relation, it is reflexively, simmetrically and transitive. It is meant that set of all string is splits to equivalence classes. Let's find lexicographic minimal strings what is equivalent to first and to second given string. And then check if its are equals.It is remain find the lexicographic minimal strings what is equivalent to given. For instance we can do it such a way: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Every recursive call time works is O(n) (where n is length of strings) and string splitten by two twice smaller strings. Therefore time of work this function is , where n is length of strings.559C - Gerald and Giant Chess & 560E - Gerald and Giant ChessLet's denote black cells ad A0, A1, ..., Ak - 1 . First of all, we have to sort black cells in increasing order of (row, column). If cell x available from cell y, x stands after y in this order. Let Ak = (h, w). Now we have to find number of paths from (1, 1) to Ak avoiding A0, ..., Ak - 1.Let Di is number of paths from (1, 1) to Ai avoiding A0, ..., Ai - 1. It's easy to see that Dk is answer for the problem. Number of all paths from (1, 1) to (xi, yi) is . We should subtract from that value all paths containing at least one of previous black cells. We should enumerate first black cell on the path. It could be one of previous cell that is not below or righter than Ai. For each such cell Aj we have to subtract number of paths from (1, 1) to Aj avoiding black cells multiplied by number of all paths from Aj to Ai.We have to calculate factorials of numbers from 1 to 2·105 and inverse elements of them modulo 109 + 7 for calculating binomial coefficients.559D - RandomizerWe can use Pick's theorem for calculate integer points number in every polygon. Integer points number on the segment between points (0, 0) and (a, b) one can calculate over GCD(a, b).Integer points number in some choosen polynom is integer points number in basic polynom minus integer points number in segmnent of basic polynom separated by every segment of choosen polynom.Let consider every potencial segment of polygon. We can calculate integer points number in his segment and probability that we will meet it in choosen polygon.Probability of segment AiAi + k is . Let use note that we can calculate only segments with k < 60 because of other segmnet propapility is too small.559E - Gerald and PathLighted part of walking trail is union of ligted intervals. Let's sort spotlights in increasing order of ai. Consider some lighted interval (a, b). It's lighted by spotlights with numbers {l, l + 1, ..., r} for some l and r (\"substring\" of spotlights). Let x0, ..., xk is all possible boundaries of lighted intervals (numbers ai - li, ai и ai + li).Imagine, that we know possible lighted intervals of all substrings of spotlights. Let left[l][r][j] is least possible i such that set of spotlights with numbers {l, l + 1, ..., r} lighting [xi, xj].With left we can calculate value best[R][i] maximum possible length of walking trail that could be lighted using first L spotlights in such way that xi is rightmost lighted point. It's easy to do in O(n4) because .Now all we have to do is calculate left. Consider some substring of spotlights [l, r]. Let all spotlights in the substring oriented in some way lighting some set of points. We could consider most left (i) and most right (j) lighted points, and left bound of first lighted interval (t). If set of lighted points is interval t = j. Consider how all the values change when we add spotlight r + 1 and choose its orientation. We have new lighted interval [a, b] which is equal to [ai - li, ai] or [ai, ai + li]. Now most left lighted point is min(a, xi), most right is max(b, xj). Right bound of leftmost lighted interval does not changes if a > t or becomes equal to b, if a ≤ t.Not for each L we can calculate dp[r][j][y] least possible i that it's possible to orient spotlights from [L, r] in such way that xi is most left lighted point xj is most right one and right bound of leftmost lighted interval is xt. Thet it's easy to calculate left[L][][]. That part is done in O(n4) too.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 560\\s*C"
          },
          "content_length": 5422
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 3",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 4",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 5",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 6",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 7",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 8",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 9",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 10",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 11",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 12",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 13",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> a = inf.readInts(6, 1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    int a1 = a[0], a2 = a[1], a3 = a[2], a4 = a[3], a5 = a[4], a6 = a[5];\n    ensuref(2 * a1 + a2 + a6 == 2 * a4 + a3 + a5, \"The given sides do not form a hexagon with all internal angles equal to 120 degrees (first condition failed)\");\n    ensuref(a2 + a3 == a5 + a6, \"The given sides do not form a hexagon with all internal angles equal to 120 degrees (second condition failed)\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> a = inf.readInts(6, 1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    int a1 = a[0], a2 = a[1], a3 = a[2], a4 = a[3], a5 = a[4], a6 = a[5];\n    ensuref(2 * a1 + a2 + a6 == 2 * a4 + a3 + a5, \"The given sides do not form a hexagon with all internal angles equal to 120 degrees (first condition failed)\");\n    ensuref(a2 + a3 == a5 + a6, \"The given sides do not form a hexagon with all internal angles equal to 120 degrees (second condition failed)\");\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> a = inf.readInts(6, 1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    int a1 = a[0], a2 = a[1], a3 = a[2], a4 = a[3], a5 = a[4], a6 = a[5];\n    ensuref(2 * a1 + a2 + a6 == 2 * a4 + a3 + a5, \"The given sides do not form a hexagon with all internal angles equal to 120 degrees (first condition failed)\");\n    ensuref(a2 + a3 == a5 + a6, \"The given sides do not form a hexagon with all internal angles equal to 120 degrees (second condition failed)\");\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000); // Maximum side length (default is 1000)\n    string type = opt<string>(\"type\", \"random\"); // Type of test case (default is \"random\")\n\n    vector<int> sides(6);\n\n    if (type == \"min\") {\n        // All sides are minimal (1)\n        fill(sides.begin(), sides.end(), 1);\n    } else if (type == \"max\") {\n        // All sides are maximal (n)\n        fill(sides.begin(), sides.end(), n);\n    } else if (type == \"random\") {\n        // Sides are random integers between 1 and n\n        for (int i = 0; i < 6; ++i)\n            sides[i] = rnd.next(1, n);\n    } else if (type == \"increasing\") {\n        // Sides increase from 1 to n\n        int a = 1;\n        int step = max(1, n / 5);\n        for (int i = 0; i < 6; ++i) {\n            sides[i] = min(a, n);\n            a += step;\n        }\n    } else if (type == \"decreasing\") {\n        // Sides decrease from n to 1\n        int a = n;\n        int step = max(1, n / 5);\n        for (int i = 0; i < 6; ++i) {\n            sides[i] = max(a, 1);\n            a -= step;\n        }\n    } else if (type == \"alternating\") {\n        // Sides alternate between n and 1\n        for (int i = 0; i < 6; ++i)\n            sides[i] = (i % 2 == 0) ? n : 1;\n    } else if (type == \"equal_sums\") {\n        // Sum of a1+a2+a3 equals sum of a4+a5+a6\n        int sum = rnd.next(3, n * 3);\n        sides[0] = rnd.next(1, min(sum - 2, n));\n        sides[1] = rnd.next(1, min(sum - sides[0] - 1, n));\n        sides[2] = min(sum - sides[0] - sides[1], n);\n        sum = sides[0] + sides[1] + sides[2]; // Recalculate exact sum\n        sides[3] = rnd.next(1, min(sum - 2, n));\n        sides[4] = rnd.next(1, min(sum - sides[3] - 1, n));\n        sides[5] = min(sum - sides[3] - sides[4], n);\n    } else if (type == \"non_equal_sums\") {\n        // Sum of a1+a2+a3 does not equal sum of a4+a5+a6\n        int sum1 = rnd.next(3, n * 3);\n        int sum2 = sum1 + rnd.next(1, n);\n        sides[0] = rnd.next(1, min(sum1 - 2, n));\n        sides[1] = rnd.next(1, min(sum1 - sides[0] - 1, n));\n        sides[2] = min(sum1 - sides[0] - sides[1], n);\n        sides[3] = rnd.next(1, min(sum2 - 2, n));\n        sides[4] = rnd.next(1, min(sum2 - sides[3] - 1, n));\n        sides[5] = min(sum2 - sides[3] - sides[4], n);\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < 6; ++i)\n            sides[i] = rnd.next(1, n);\n    }\n\n    // Ensure all sides are at least 1\n    for (int i = 0; i < 6; ++i)\n        sides[i] = max(1, sides[i]);\n\n    // Output the sides\n    for (int i = 0; i < 6; ++i) {\n        printf(\"%d%c\", sides[i], (i == 5) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000); // Maximum side length (default is 1000)\n    string type = opt<string>(\"type\", \"random\"); // Type of test case (default is \"random\")\n\n    vector<int> sides(6);\n\n    if (type == \"min\") {\n        // All sides are minimal (1)\n        fill(sides.begin(), sides.end(), 1);\n    } else if (type == \"max\") {\n        // All sides are maximal (n)\n        fill(sides.begin(), sides.end(), n);\n    } else if (type == \"random\") {\n        // Sides are random integers between 1 and n\n        for (int i = 0; i < 6; ++i)\n            sides[i] = rnd.next(1, n);\n    } else if (type == \"increasing\") {\n        // Sides increase from 1 to n\n        int a = 1;\n        int step = max(1, n / 5);\n        for (int i = 0; i < 6; ++i) {\n            sides[i] = min(a, n);\n            a += step;\n        }\n    } else if (type == \"decreasing\") {\n        // Sides decrease from n to 1\n        int a = n;\n        int step = max(1, n / 5);\n        for (int i = 0; i < 6; ++i) {\n            sides[i] = max(a, 1);\n            a -= step;\n        }\n    } else if (type == \"alternating\") {\n        // Sides alternate between n and 1\n        for (int i = 0; i < 6; ++i)\n            sides[i] = (i % 2 == 0) ? n : 1;\n    } else if (type == \"equal_sums\") {\n        // Sum of a1+a2+a3 equals sum of a4+a5+a6\n        int sum = rnd.next(3, n * 3);\n        sides[0] = rnd.next(1, min(sum - 2, n));\n        sides[1] = rnd.next(1, min(sum - sides[0] - 1, n));\n        sides[2] = min(sum - sides[0] - sides[1], n);\n        sum = sides[0] + sides[1] + sides[2]; // Recalculate exact sum\n        sides[3] = rnd.next(1, min(sum - 2, n));\n        sides[4] = rnd.next(1, min(sum - sides[3] - 1, n));\n        sides[5] = min(sum - sides[3] - sides[4], n);\n    } else if (type == \"non_equal_sums\") {\n        // Sum of a1+a2+a3 does not equal sum of a4+a5+a6\n        int sum1 = rnd.next(3, n * 3);\n        int sum2 = sum1 + rnd.next(1, n);\n        sides[0] = rnd.next(1, min(sum1 - 2, n));\n        sides[1] = rnd.next(1, min(sum1 - sides[0] - 1, n));\n        sides[2] = min(sum1 - sides[0] - sides[1], n);\n        sides[3] = rnd.next(1, min(sum2 - 2, n));\n        sides[4] = rnd.next(1, min(sum2 - sides[3] - 1, n));\n        sides[5] = min(sum2 - sides[3] - sides[4], n);\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < 6; ++i)\n            sides[i] = rnd.next(1, n);\n    }\n\n    // Ensure all sides are at least 1\n    for (int i = 0; i < 6; ++i)\n        sides[i] = max(1, sides[i]);\n\n    // Output the sides\n    for (int i = 0; i < 6; ++i) {\n        printf(\"%d%c\", sides[i], (i == 5) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 1 -type max\n./gen -n 1 -type random\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n./gen -n 1 -type alternating\n\n./gen -n 2 -type min\n./gen -n 2 -type max\n./gen -n 2 -type random\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type alternating\n\n./gen -n 100 -type min\n./gen -n 100 -type max\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n\n./gen -n 500 -type random\n./gen -n 500 -type equal_sums\n./gen -n 500 -type non_equal_sums\n\n./gen -n 999 -type min\n./gen -n 999 -type max\n./gen -n 999 -type random\n./gen -n 999 -type increasing\n./gen -n 999 -type decreasing\n./gen -n 999 -type alternating\n\n./gen -n 1000 -type min\n./gen -n 1000 -type max\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type alternating\n\n./gen -n 1000 -type equal_sums\n./gen -n 1000 -type non_equal_sums\n\n# Random test cases\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n\n# Edge cases with small differences\n./gen -n 998 -type equal_sums\n./gen -n 998 -type non_equal_sums\n\n./gen -n 3 -type alternating\n./gen -n 4 -type alternating\n\n# Maximal sides\n./gen -n 1000 -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:30.071118",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "560/D",
      "title": "D. Equivalent Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length.",
      "output_spec": "OutputPrint \"YES\" (without the quotes), if these two strings are equivalent, and \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopyaabaabaaOutputCopyYESInputCopyaabbababOutputCopyNO",
      "description": "D. Equivalent Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length.\n\nOutputPrint \"YES\" (without the quotes), if these two strings are equivalent, and \"NO\" (without the quotes) otherwise.\n\nInputCopyaabaabaaOutputCopyYESInputCopyaabbababOutputCopyNO\n\nInputCopyaabaabaa\n\nOutputCopyYES\n\nInputCopyaabbabab\n\nOutputCopyNO\n\nNoteIn the first sample you should split the first string into strings \"aa\" and \"ba\", the second one — into strings \"ab\" and \"aa\". \"aa\" is equivalent to \"aa\"; \"ab\" is equivalent to \"ba\" as \"ab\" = \"a\" + \"b\", \"ba\" = \"b\" + \"a\".In the second sample the first string can be splitted into strings \"aa\" and \"bb\", that are equivalent only to themselves. That's why string \"aabb\" is equivalent only to itself and to string \"bbaa\".",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the Codeforces round 313, which is prepeared by me and tunyash. Each of us is prepared four rounds then it is our fifth of ninth round to your notice. I figured out almost all problems (except D div.1), wrote the statements and analysis of all the problems, and tunyash has developed all problems.Gerald is not coordinator yet and you probobly missed him. In this round you will meet him again and help him in his ordinary life problems.I want to thank Zlobober, our translator Maria Belova (Delinur) and MikeMirzayanov and all Codeforces team for this platform.This round will be held in unusual time — 17:00 Moscow Time.Contest finished! Welcome to editoral: Short editoral. Extended editoral.Div.1 scoring distribution:500 — 1000 — 1500 — 2250 — 2250Div.2 scoring distribution:500 — 1000 — 1500 — 2000 — 2500I wish you to enjoy solving problems!Congratulations to winners!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1073
        },
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces",
          "content": "560A - Currency System in GeraldionIf there is a banlnot of value 1 then one can to express every sum of money. Otherwise one can't to express 1 and it is minimum unfortunate sum.560B - Gerald is into ArtIt is easy to see that one can snuggle paintings to each other and to edge of board. For instance one can put one of painting right over other. Then height of two paintings equals to sum of two heights and width of two paintings is equals to maximum of two widths. Now we can just iterate orientation of paintings and board.559A - Gerald's Hexagon & 560C - Gerald's HexagonLet's consider regular triangle with sides of k Let's split it to regular triangles with sides of 1 by lines parallel to the sides. Big triange area k2 times larger then small triangles area and therefore big triangle have splitted by k2 small triangles.If we join regular triangles to sides a1, a3 and a5 of hexagon we get a triangle sides of a1 + a2 + a3. Then hexagon area is equals to (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Equivalent Strings & 560D - Equivalent StringsLet us note that \"equivalence\" described in the statements is actually equivalence relation, it is reflexively, simmetrically and transitive. It is meant that set of all string is splits to equivalence classes. Let's find lexicographic minimal strings what is equivalent to first and to second given string. And then check if its are equals.It is remain find the lexicographic minimal strings what is equivalent to given. For instance we can do it such a way: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Every recursive call time works is O(n) (where n is length of strings) and string splitten by two twice smaller strings. Therefore time of work this function is , where n is length of strings.559C - Gerald and Giant Chess & 560E - Gerald and Giant ChessLet's denote black cells ad A0, A1, ..., Ak - 1 . First of all, we have to sort black cells in increasing order of (row, column). If cell x available from cell y, x stands after y in this order. Let Ak = (h, w). Now we have to find number of paths from (1, 1) to Ak avoiding A0, ..., Ak - 1.Let Di is number of paths from (1, 1) to Ai avoiding A0, ..., Ai - 1. It's easy to see that Dk is answer for the problem. Number of all paths from (1, 1) to (xi, yi) is . We should subtract from that value all paths containing at least one of previous black cells. We should enumerate first black cell on the path. It could be one of previous cell that is not below or righter than Ai. For each such cell Aj we have to subtract number of paths from (1, 1) to Aj avoiding black cells multiplied by number of all paths from Aj to Ai.We have to calculate factorials of numbers from 1 to 2·105 and inverse elements of them modulo 109 + 7 for calculating binomial coefficients.559D - RandomizerWe can use Pick's theorem for calculate integer points number in every polygon. Integer points number on the segment between points (0, 0) and (a, b) one can calculate over GCD(a, b).Integer points number in some choosen polynom is integer points number in basic polynom minus integer points number in segmnent of basic polynom separated by every segment of choosen polynom.Let consider every potencial segment of polygon. We can calculate integer points number in his segment and probability that we will meet it in choosen polygon.Probability of segment AiAi + k is . Let use note that we can calculate only segments with k < 60 because of other segmnet propapility is too small.559E - Gerald and PathLighted part of walking trail is union of ligted intervals. Let's sort spotlights in increasing order of ai. Consider some lighted interval (a, b). It's lighted by spotlights with numbers {l, l + 1, ..., r} for some l and r (\"substring\" of spotlights). Let x0, ..., xk is all possible boundaries of lighted intervals (numbers ai - li, ai и ai + li).Imagine, that we know possible lighted intervals of all substrings of spotlights. Let left[l][r][j] is least possible i such that set of spotlights with numbers {l, l + 1, ..., r} lighting [xi, xj].With left we can calculate value best[R][i] maximum possible length of walking trail that could be lighted using first L spotlights in such way that xi is rightmost lighted point. It's easy to do in O(n4) because .Now all we have to do is calculate left. Consider some substring of spotlights [l, r]. Let all spotlights in the substring oriented in some way lighting some set of points. We could consider most left (i) and most right (j) lighted points, and left bound of first lighted interval (t). If set of lighted points is interval t = j. Consider how all the values change when we add spotlight r + 1 and choose its orientation. We have new lighted interval [a, b] which is equal to [ai - li, ai] or [ai, ai + li]. Now most left lighted point is min(a, xi), most right is max(b, xj). Right bound of leftmost lighted interval does not changes if a > t or becomes equal to b, if a ≤ t.Not for each L we can calculate dp[r][j][y] least possible i that it's possible to orient spotlights from [L, r] in such way that xi is most left lighted point xj is most right one and right bound of leftmost lighted interval is xt. Thet it's easy to calculate left[L][][]. That part is done in O(n4) too.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 560\\s*D"
          },
          "content_length": 5422
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 3",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 4",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 5",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 6",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 7",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 8",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 9",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 10",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 11",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 12",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Extended editoral - Codeforces - Code 13",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 200000, \"Length of s1 must be between 1 and 200000, but is %zu\", s1.length());\n    for (char c : s1) {\n        ensuref(c >= 'a' && c <= 'z', \"s1 must consist of lowercase letters, but found '%c'\", c);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 200000, \"Length of s2 must be between 1 and 200000, but is %zu\", s2.length());\n    for (char c : s2) {\n        ensuref(c >= 'a' && c <= 'z', \"s2 must consist of lowercase letters, but found '%c'\", c);\n    }\n\n    ensuref(s1.length() == s2.length(), \"Strings must have the same length.\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 200000, \"Length of s1 must be between 1 and 200000, but is %zu\", s1.length());\n    for (char c : s1) {\n        ensuref(c >= 'a' && c <= 'z', \"s1 must consist of lowercase letters, but found '%c'\", c);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 200000, \"Length of s2 must be between 1 and 200000, but is %zu\", s2.length());\n    for (char c : s2) {\n        ensuref(c >= 'a' && c <= 'z', \"s2 must consist of lowercase letters, but found '%c'\", c);\n    }\n\n    ensuref(s1.length() == s2.length(), \"Strings must have the same length.\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 200000, \"Length of s1 must be between 1 and 200000, but is %zu\", s1.length());\n    for (char c : s1) {\n        ensuref(c >= 'a' && c <= 'z', \"s1 must consist of lowercase letters, but found '%c'\", c);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 200000, \"Length of s2 must be between 1 and 200000, but is %zu\", s2.length());\n    for (char c : s2) {\n        ensuref(c >= 'a' && c <= 'z', \"s2 must consist of lowercase letters, but found '%c'\", c);\n    }\n\n    ensuref(s1.length() == s2.length(), \"Strings must have the same length.\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_equivalent(string s) {\n    int n = s.length();\n    if (n % 2 == 1) {\n        return s;\n    } else {\n        int mid = n / 2;\n        string a1 = s.substr(0, mid);\n        string a2 = s.substr(mid);\n        string b1 = generate_equivalent(a1);\n        string b2 = generate_equivalent(a2);\n        if (rnd.next(2)) {\n            return b1 + b2;\n        } else {\n            return b2 + b1;\n        }\n    }\n}\n\nvoid generate_random_equal(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = generate_equivalent(s);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_not_equivalent(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = s;\n    int pos = rnd.next(n);\n    char c = s[pos];\n    char new_c = c;\n    while (new_c == c) {\n        new_c = rnd.next('a', 'z');\n    }\n    t[pos] = new_c;\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_all_same_char_equal(int n) {\n    char c = rnd.next('a', 'z');\n    string s(n, c);\n    cout << s << endl;\n    cout << s << endl;\n}\n\nvoid generate_all_same_char_not_equal(int n) {\n    char c1 = rnd.next('a', 'y');\n    char c2 = c1 + 1;\n    string s(n, c1);\n    string t(n, c2);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_reversed_equal(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = generate_equivalent(s);\n    t = string(t.rbegin(), t.rend());\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_reversed_not_equal(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = string(s.rbegin(), s.rend());\n    int pos = rnd.next(n);\n    char c = t[pos];\n    char new_c = c;\n    while (new_c == c) {\n        new_c = rnd.next('a', 'z');\n    }\n    t[pos] = new_c;\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_length_one_equal() {\n    char c = rnd.next('a', 'z');\n    string s(1, c);\n    cout << s << endl;\n    cout << s << endl;\n}\n\nvoid generate_length_one_not_equal() {\n    char c1 = rnd.next('a', 'y');\n    char c2 = c1 + 1;\n    string s(1, c1);\n    string t(1, c2);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_complex_equivalence(int n) {\n    string s = \"\";\n    char c1 = rnd.next('a', 'z');\n    char c2 = c1;\n    while (c2 == c1) {\n        c2 = rnd.next('a', 'z');\n    }\n    for (int i = 0; i < n / 2; ++i) {\n        s += c1;\n    }\n    for (int i = 0; i < n / 2; ++i) {\n        s += c2;\n    }\n    string t = generate_equivalent(s);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_equal\");\n\n    if (type == \"random_equal\") {\n        generate_random_equal(n);\n    } else if (type == \"random_not_equal\") {\n        generate_not_equivalent(n);\n    } else if (type == \"all_same_char_equal\") {\n        generate_all_same_char_equal(n);\n    } else if (type == \"all_same_char_not_equal\") {\n        generate_all_same_char_not_equal(n);\n    } else if (type == \"reversed_equal\") {\n        generate_reversed_equal(n);\n    } else if (type == \"reversed_not_equal\") {\n        generate_reversed_not_equal(n);\n    } else if (type == \"length_one_equal\") {\n        generate_length_one_equal();\n    } else if (type == \"length_one_not_equal\") {\n        generate_length_one_not_equal();\n    } else if (type == \"complex_equivalence\") {\n        generate_complex_equivalence(n);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_equivalent(string s) {\n    int n = s.length();\n    if (n % 2 == 1) {\n        return s;\n    } else {\n        int mid = n / 2;\n        string a1 = s.substr(0, mid);\n        string a2 = s.substr(mid);\n        string b1 = generate_equivalent(a1);\n        string b2 = generate_equivalent(a2);\n        if (rnd.next(2)) {\n            return b1 + b2;\n        } else {\n            return b2 + b1;\n        }\n    }\n}\n\nvoid generate_random_equal(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = generate_equivalent(s);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_not_equivalent(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = s;\n    int pos = rnd.next(n);\n    char c = s[pos];\n    char new_c = c;\n    while (new_c == c) {\n        new_c = rnd.next('a', 'z');\n    }\n    t[pos] = new_c;\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_all_same_char_equal(int n) {\n    char c = rnd.next('a', 'z');\n    string s(n, c);\n    cout << s << endl;\n    cout << s << endl;\n}\n\nvoid generate_all_same_char_not_equal(int n) {\n    char c1 = rnd.next('a', 'y');\n    char c2 = c1 + 1;\n    string s(n, c1);\n    string t(n, c2);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_reversed_equal(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = generate_equivalent(s);\n    t = string(t.rbegin(), t.rend());\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_reversed_not_equal(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('a', 'z');\n    }\n    string t = string(s.rbegin(), s.rend());\n    int pos = rnd.next(n);\n    char c = t[pos];\n    char new_c = c;\n    while (new_c == c) {\n        new_c = rnd.next('a', 'z');\n    }\n    t[pos] = new_c;\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_length_one_equal() {\n    char c = rnd.next('a', 'z');\n    string s(1, c);\n    cout << s << endl;\n    cout << s << endl;\n}\n\nvoid generate_length_one_not_equal() {\n    char c1 = rnd.next('a', 'y');\n    char c2 = c1 + 1;\n    string s(1, c1);\n    string t(1, c2);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nvoid generate_complex_equivalence(int n) {\n    string s = \"\";\n    char c1 = rnd.next('a', 'z');\n    char c2 = c1;\n    while (c2 == c1) {\n        c2 = rnd.next('a', 'z');\n    }\n    for (int i = 0; i < n / 2; ++i) {\n        s += c1;\n    }\n    for (int i = 0; i < n / 2; ++i) {\n        s += c2;\n    }\n    string t = generate_equivalent(s);\n    cout << s << endl;\n    cout << t << endl;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_equal\");\n\n    if (type == \"random_equal\") {\n        generate_random_equal(n);\n    } else if (type == \"random_not_equal\") {\n        generate_not_equivalent(n);\n    } else if (type == \"all_same_char_equal\") {\n        generate_all_same_char_equal(n);\n    } else if (type == \"all_same_char_not_equal\") {\n        generate_all_same_char_not_equal(n);\n    } else if (type == \"reversed_equal\") {\n        generate_reversed_equal(n);\n    } else if (type == \"reversed_not_equal\") {\n        generate_reversed_not_equal(n);\n    } else if (type == \"length_one_equal\") {\n        generate_length_one_equal();\n    } else if (type == \"length_one_not_equal\") {\n        generate_length_one_not_equal();\n    } else if (type == \"complex_equivalence\") {\n        generate_complex_equivalence(n);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type length_one_equal\n./gen -n 1 -type length_one_not_equal\n\n./gen -n 2 -type random_equal\n./gen -n 2 -type random_not_equal\n\n./gen -n 4 -type all_same_char_equal\n./gen -n 4 -type all_same_char_not_equal\n\n./gen -n 5 -type random_equal\n./gen -n 5 -type random_not_equal\n\n./gen -n 6 -type reversed_equal\n./gen -n 6 -type reversed_not_equal\n\n./gen -n 10 -type random_equal\n./gen -n 10 -type random_not_equal\n\n./gen -n 20 -type complex_equivalence\n\n./gen -n 100 -type random_equal\n./gen -n 100 -type random_not_equal\n\n./gen -n 1000 -type random_equal\n./gen -n 1000 -type random_not_equal\n\n./gen -n 10000 -type all_same_char_equal\n./gen -n 10000 -type all_same_char_not_equal\n\n./gen -n 100000 -type random_equal\n\n./gen -n 200000 -type random_equal\n./gen -n 200000 -type random_not_equal\n\n./gen -n 200000 -type complex_equivalence\n\n./gen -n 99999 -type reversed_equal\n./gen -n 99999 -type reversed_not_equal\n\n./gen -n 100001 -type random_equal\n./gen -n 100001 -type random_not_equal\n\n./gen -n 1 -type length_one_equal\n./gen -n 1 -type length_one_not_equal\n\n./gen -n 15 -type complex_equivalence\n./gen -n 50 -type complex_equivalence\n./gen -n 50000 -type complex_equivalence\n\n./gen -n 123456 -type random_equal\n./gen -n 123456 -type random_not_equal\n\n./gen -n 200000 -type all_same_char_equal\n./gen -n 200000 -type all_same_char_not_equal\n\n./gen -n 200000 -type reversed_equal\n./gen -n 200000 -type reversed_not_equal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:32.414833",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "560/E",
      "title": "E. Геральд и гигантские шахматы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных заданы три числа: h, w, n — размеры доски и количество чёрных клеток (1 ≤ h, w ≤ 105, 1 ≤ n ≤ 2000). В следующих n строках задано описание чёрных клеток. В i-й из этих строк написаны числа ri, ci (1 ≤ ri ≤ h, 1 ≤ ci ≤ w) — номер строки и столбца i-й клетки.Гарантируется, что верхняя левая и нижняя правая клетка белые и все клетки в описании различны.",
      "output_spec": "Выходные данныеВыведите единственное число — остаток от деления количества способов провести пешку Геральда от верхней левой клетки до нижней правой на число 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 4 22 22 3Выходные данныеСкопировать2Входные данныеСкопировать100 100 315 1616 1599 88Выходные данныеСкопировать545732279",
      "description": "E. Геральд и гигантские шахматы\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных заданы три числа: h, w, n — размеры доски и количество чёрных клеток (1 ≤ h, w ≤ 105, 1 ≤ n ≤ 2000). В следующих n строках задано описание чёрных клеток. В i-й из этих строк написаны числа ri, ci (1 ≤ ri ≤ h, 1 ≤ ci ≤ w) — номер строки и столбца i-й клетки.Гарантируется, что верхняя левая и нижняя правая клетка белые и все клетки в описании различны.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — остаток от деления количества способов провести пешку Геральда от верхней левой клетки до нижней правой на число 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать3 4 22 22 3Выходные данныеСкопировать2Входные данныеСкопировать100 100 315 1616 1599 88Выходные данныеСкопировать545732279\n\nВходные данныеСкопировать3 4 22 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать100 100 315 1616 1599 88\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать545732279\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round 313 - Codeforces",
          "content": "Доброго всем времени суток!Приглашаю Вас поучаствовать в 313 Codeforces раунде, над которыми для вас работали я и tunyash. У каждого из нас за плечами по четыре раунда, так что это наш пятый или девятый раунд, как хотите. Я придумал почти все задачи (кроме D div.1), написал условия и разбор всех задач, а tunyash занимался разработкой всех задач.Gerald уже не является координатором, так что, возможно, Вы по нему соскучились. В этом раунде вы снова с ним встретитесь и поможете ему разобраться в его повседневных жизненных проблемах.Спасибо координатору Zlobober, нашей переводчице Марии Беловой (Delinur), а так же MikeMirzayanov и всей команде Codeforces за эту платформу.Этот раунд состоится в необычное время — 17:00 по Московскому времени.Соревнование закончилось, добро пожаловать в разбор! Краткий разбор. Подробный разбор.Разбалловка в первом дивизионе будет следующая:500 — 1000 — 1500 — 2250 — 2250А во втором дивизионе — стандартная:500 — 1000 — 1500 — 2000 — 2500Желаю всем получить удовольствие от решения задач!Поздравляем победителей!Div. 1: 1. jqdai0815 2. qwerty787788 3. SirShokoladina 4. ainu7 5. EndagorionDiv. 2: 1. goons_will_rule 2. lbn187 3. crawling 4. loveannie 5. Jagabee",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19331",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1200
        },
        {
          "title": "VK Cup 2015: онлайн-трансляция и порция благодарностей - Codeforces",
          "content": "Мы были вынуждены удалить регистрации, сделанные до 00:00, так как регистрационная форма на тот момент не поддерживала регистрацию команд. Пожалуйста, пройдите регистрацию вновь, если ваша регистрация была удалена.Вчера завершился финал чемпионата VK Cup 2015, о котором вы могли прочитать в предыдущих наших постах. Осталось объявить последнее событие, связанное с прошедшим чемпионатом — онлайн-трансляцию, которая состоится в четверг 30 июля в 19:00 по Москве. К соревнованию допускаются как индивидуальные участники, так и команды из двух человек, которые желают почувствовать себя участниками финала соревнования. Трансляция продлится три часа, задачи будут перемешаны по сравнению с оригинальным порядком. Допускаются участники обоих дивизионом, но мы считаем своим долгом предупредить, что для участников из второго дивизиона набор задач, скорее всего, будет слишком сложным. Этот раунд является рейтинговым раундом Codeforces.В заключение мы хотели бы поблагодарить всех людей, которые помогли чемпионату состояться. Придумывали и готовили задачи для вас сотрудники ВКонтакте, члены команды Codeforces и другие люди, любезно предложившие свою помощь: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. Хочется сказать большое спасибо людям, прорешивавшим наши раунды, и дававшим ценные советы по поводу задач: winger и AlexFetisov. Также, мы благодарим всех работников ВКонтакте, с которыми вместе мы занимались проведением чемпионата: burunduk3, Burunduk2, KOTEHOK и многих других. Спасибо!Всем удачи на онлайн-трансляции!UPD: Обратите внимание, что во время раунда команде разрешается пользоваться только одним компьютером. Это значит, что программировать/пользоваться консолью/как-либо иначе продвигаться в решении задач в один момент времени можно только с одного компьютера. Единственное, что разрешается делать с двух компьютеров — это читать условия. UPD2: Так как это командное соревнование, специально для вашего удобства мы выкладываем запароленный архив с pdf-условиями задач: vkcup2015-mirror-statements.zip. С началом тура мы опубликуем пароль к нему.UPD3: В раунде будет использована динамическая разбалловка с шагом в 250 очков.UPD4: По техническим причинам начало раунда переносится на 19:20 по Москве.UPD5: Пароль на архив с условиями: vkcup4ever. Удачи!UPD6: Онлайн-трансляция завершена! Поздравляем победителей: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Мой персональный респектам команде Petr team: Petr, ilyakor за единственное решение по задаче Е в трансляции, пользователю rng_58 и команде Excited: YuukaKazami, jqdai0815 за два правильных решения по задаче С.Также, поздравляем пользователя rng_58, который продемонстрировал, что одиночному пользователю есть что противопоставить командам, состоящим из двух людей!Рейтинг будет пересчитан в ближайшее время.UPD7: Разбор!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2993
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces",
          "content": "560A - Денежная система ГеральдионаВ этой задаче главное — заметить, что если есть купюра номинала 1, то любую сумму денег можно выдать единичными купюрами. Если же такой купюры нет, то как раз сумму 1 представить нельзя. Поэтому, если нет купюры номинала 1, то ответ — 1, а если такая купюра есть — то -1.560B - Геральд увлекается исскусствомЛегко заметить, что можно прижать две картины друг в другу какими-то двумя краями, например, разместить одну картину прямо над другой. Тогда высота двух картин будет суммой высот картин, а ширина — максимум из ширин картин. Осталось перебрать все варианты, как повёрнуты картины и как при этом повёрнут стенд. Вот реализация.559A - Шестиугольник Геральда & 560C - Шестиугольник ГеральдаСперва заметим, что если правильный треугольник с целой стороной k отрезками, параллельными сторонам, разделить на правильные треугольники со стороной 1 (тут появляется картинка), то площадь большого треугольника будет в k2 раз больше площадей маленьких треугольничков и, следовательно, треугольник окажется разделён ровно на k2 единичных треугольничков.Далее, заметим, что если к сторонам a1, a3 и a5 шестиугольника пририсовать по правильному треугольнику со сторонами a1, a3 и a5 соответственно (и тут появляется ещё одна картинка), то получится большой правильный треугольник со стороной a1 + a2 + a3. Таким образом, площадь исходного шестиугольника равна (a1 + a2 + a3)2 - a12 - a32 - a52.559B - Эквивалентные строки & 560D - Эквивалентные строкиНетрудно заметить, что \"эквивалентность\", описанная в задаче, в самом деле является отношением эквивалентности, то есть, оно симметрично, транзитивно и рефлексивно. Подробнее от отношениях эквивалентности можно почитать здесь. В частности, это означает, что все строки разбиваются на классы эквивалентности и нам надо проверить, что данные нам две строки принадлежат одному и тому же классу. Для этого давайте найдём лексикографически минимальную строку, которая лежит в одном классе эквивалентности с каждой из строк. Иными словами, найдём лексикографически минимальную строку, эквивалентную каждой из данных строк и проверим, получилась ли одна и та же строка.Осталось научиться находить лексикографически минимальную строку, эквивалентную данной, за приемлемое время. Это можно сделать, например, следующей рекурсивной функцией: String smallest(String s) {\n if (s.length() % 2 == 1) return s;\n String s1 = smallest(s.substring(0, s.length()/2));\n String s2 = smallest(s.substring(s.length()/2), s.length());\n if (s1 < s2) return s1 + s2;\n else return s2 + s1;\n}Поскольку каждый рекурсивный вызов работает линейно от длины переданной ему строки и внутри функции она сама два раза вызывается от вдвое меньшей строки, эта функция работает за время , где n — длина строки.559C - Геральд и гигантские шахматы & 560E - Геральд и гигантские шахматыОбозначим все чёрные клетки как A0, A1, ..., Ak - 1. Для начала, упорядочим чёрные клетки в порядке сверху вниз, а те, которые на одной высоте — слева направо. Теперь все чёрные клетки, из которых пешка Геральда могла бы попасть в данную чёрную клетку, находятся до неё. Покрасим нижнюю правую клетку в чёрный цвет и тоже добавим её в список чёрных клеток под номером k. Теперь пешке Геральда надо попасть в последнюю чёрную клетку, миновав все остальные.Посчитаем величину Di — количество способов попасть в Ai, миновав все предыдущие чёрные клетки. Как несложно заметить, ответом на задачу будет Dk. Общее количество способов дойти из клетки (1, 1) в клетку (xi, yi) равно . Вычтем из этого количества все способы попасть в Ai, зайдя по пути в одну из предыдущих чёрных клеток. Для этого переберём, какая из чёрных клеток могла первой попасться на пути. Это должна быть какая-то из предыдущих чёрных клеток, находящаяся не ниже и не правее, чем Ai. Для каждой такой клетки Aj надо вычесть произведение количества способов попасть в Aj, минуя все предыдущие чёрные клетки и количества способов просто попасть из Aj в Ai.Для вычисления биномиальных коэффициентов придётся преподсчитать факториалы всех чисел до 2·105 и научиться брать обратные к ним по модулю 109 + 7.559D - РандомизаторДля начала, вспомним формулу Пика. Благодаря ней, количество целых точек внутри любого многоугольника можно вычислить, зная его площадь и количество целых точек на границе. Количество целых точек на отрезке, соединяющем точки (0, 0) и (a, b) можно посчитать, найдя НОД(a, b).Давайте вычислим общее количество целых точек в основном многоугольнике, а затем для каждого отрезка, соединяющего какие-то две вершины многоугольника, вычтем из этой величины произведение вероятности того, что этот отрезок будет стороной выбранного многоугольника и количество целых точек в сегменте основного многоугольника, который отсекает этот отрезок. Вероятность легко посчитать. Если отрезок соединяет вершины Ai и Ai + k, то существует ровно 2n - k - 1 - 1 многоугольник, в котором есть такая сторона, а общее количество валидных многоугольников равняется .Количество целых точек в отсекаемом отрезком AiAi + k сегменте тоже легко посчитать с помощью с формулы Пика за время O(k), а если воспользоваться тем, что перед этим мы посчитали количество целых точек в сегменте, отсекаемом AiAi + k - 1, можно сделать это за время O(1).Таким образом, получается решение за время ( -- время вычисления НОД двух натуральных чисел, не превосходящих MAX). Это, конечно, слишком много.Давайте обратим внимание на вероятность появления каждой из сторон. Вероятность появления в многоугольнике стороны, пропускающей k - 1 вершину многоугольника, равна . Как видно, эта вероятность экспоненциально падает с ростом k. В частности, если общее количество целых точек в многоугольнике равно V, то сумма всех слагаемых, соответствующих отрезкам с k ≥ 60 не превосходит . Таким образом, все слагаемые, соответствующие отрезкам с k ≥ 60, можно просто игнорировать. Следует отметить, что 60 — это очень грубая оценка, не учитывающая, что для большинства отрезков вероятность будет гораздо меньше, чем 2 - 60, а для отрезков с k порядка 60 количество целых точек внутри сегмента будет порядка , а вовсе не порядка V.Таким образом, мы получаем решение за время , поскольку 60 — это ни что иное, как .559E - Геральд и тропинкаОсвещённая часть тропинки представляет собой объединение нескольких непересекающихся освещенных отрезков (возможно, одного). Давайте упорядочим прожекторы по возрастанию ai. Заметим, что каждый освещенный отрезок освещается некоторой \"подстрокой\" прожекторов, то есть, множеством прожекторов с номерами из некоторого отрезка [l, r]. Пусть x0, ..., xk — упорядоченная последовательность потенциальных концов отрезков, то есть, всех чисел вида ai - li, ai и ai + li.Представим себе, что мы знаем, какие именно отрезки тропинки можно осветить с помощью каждой подстроки прожекторов. Сохраним в массив left[][][] информацию о самых длинных возможных освещенных отрезках в следующем виде: left[l][r][j] — самое маленькое такое i, что подстрока [l, r] прожекторов может освещать отрезок [xi, xj].Теперь, имея массив left, посчитаем динамикой величину best[R][i] — какую максимальную длину тропинки можно осветить, используя первые L прожекторов так, чтобы самой правой освещённой точкой была xi. Это легко сделать за время O(n4), так как .Теперь давайте вычислим массив left. Рассмотрим некую подстроку прожекторов [l, r]. Пусть все прожекторы этой подстроки как-то ориентированы и освещают некоторую область тропинки. У этой области можно рассмотреть самую левую (i) и самую правую (j) освещенную точки, а также правый конец самого левого освещенного отрезка (t). Если область является одним отрезком, то t = j. Рассмотрим, как меняются эти три параметра, когда мы добавляем к подстроке прожектор r + 1 и выбираем его ориентацию. К освещенной области добавляется отрезок [a, b], который равен [ai - li, ai] или [ai, ai + li]. Самая левая освещенная точка становится min(a, xi), самая правая — max(b, xj). А правый конец самого левого отрезка не меняется, если a > t или становится b, если a ≤ t.Эти соотношения позволяют для каждого фиксированного L вычислить динамикой величину dp[r][j][y] — наименьшее такое i, что можно ориентировать прожекторы подстроки [L, r] так, чтобы самая левая освещенная точка была xi, самая правая — xj, а правый конец самого левого отрезка — xt. Вычислив это, уже легко посчитать значения массива left[L][][]. Эта часть решения тоже будет работать за время O(n4).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19237",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 560\\s*E"
          },
          "content_length": 8382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 313 - Codeforces - Code 1",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 2",
          "code": "int main()\n{\n    int x, y;\n    cin >> x >> y;\n    cout << ((y == 1) && ((1 / x) == 5)) << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 3",
          "code": "cout << (((1 / x) == 5) && (y == 1)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 4",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 5",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 6",
          "code": "A = (X==X) = true\nB = (Y==X) = false\nC = (X==X) = true\nD = (Y==X) = false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 7",
          "code": "(A&&B)||(C&&D)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 8",
          "code": "Judge protocol is inaccessible",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 9",
          "code": "(int) ans + 0.5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 10",
          "code": "(int) (ans + 0.5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 11",
          "code": "(long double) (n + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 12",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 13",
          "code": "if (rec(...) && rec(...) || rec(...) && rec(...)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 14",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 15",
          "code": "#define sin120 0,86602540378443864676372317075294\n    vector<double> v;\n    double air,air1,air2,air3,air4;\n    int x,y;\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air1=sin120*x*y*0.5;\n    \n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air2=sin120*x*y*0.5;\n\n    cin >> x >> y ;\n    v.pb( sqrt(x*x+y*y+x*y) );\n    air3=sin120*x*y*0.5;\n\n    double a=v[0],b=v[1],c=v[2];\n    air4=sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c));\n    \n    air=air1+air2+air3+air4;\n\n    cout << (air * 4)/sqrt(3);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 16",
          "code": "0,86602540378443864676372317075294",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 17",
          "code": "sqrt(s(s-a)(s-b)(s-c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 18",
          "code": "s = (a+b+c)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 19",
          "code": "air4 = sqrt((a+b-c)*(a-b+c)*(b+c-a)*(a+b+c))/4.;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 20",
          "code": "cout << (int)( (air * 4)/sqrt(3));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 21",
          "code": "cout << (int)( (air * 4)/sqrt(3) + 0.5 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 22",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 - Codeforces - Code 23",
          "code": "prob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19331",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 1",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 2",
          "code": "String smallest(String s) {\n    if (s.length() % 2 == 1) return s;\n    String s1 = smallest(s.substring(0, s.length()/2));\n    String s2 = smallest(s.substring(s.length()/2), s.length());\n    if (s1 < s2) return s1 + s2;\n    else return s2 + s1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 3",
          "code": "T(n) = 4*T(n / 2) => T(n) = n^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 4",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 5",
          "code": "if (eq(s1.substr(0,m/2),s2.substr(m/2,m/2))) //условие 1\n    {\n        if (eq(s2.substr(0,m/2),s1.substr(m/2,m/2))) //условие 2\n           return true;\n        return false;\n    } else\n    if (eq(s1.substr(0,m/2),s2.substr(0,m/2))) //условие 3\n    {\n        if (eq(s2.substr(m/2,m/2),s1.substr(m/2,m/2))) //условие 4\n           return true;\n        return false;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 6",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 7",
          "code": "3\n906761424 995582713\n981062917 945819191\n981062917 945819192",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 8",
          "code": "area - boder points",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 9",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 10",
          "code": "int dp[3][100009];\n      dp[1][1] =1 ;\n      int now,pre;\n      for(int i=1; i<=h; i++)\n      {\n            now = (i%2); pre = 1-now;\n            for(int j=1; j<=w; j++)\n            {\n                  if(row[i]==false||col[j-1]==false)  // Checking Left\n                        dp[now][j] = (dp[now][j]+dp[now][j-1])%mod;\n                  if(row[i-1]==false||col[j]==false)  // Checking Up\n                        dp[now][j] = (dp[now][j]+dp[pre][j])%mod;\n            }\n      }\n      cout<<dp[now][h]<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 11",
          "code": "1 2 1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 12",
          "code": "(a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 13",
          "code": "ll val = ( ( fact[(bl[i].f + bl[i].s)-(bl[j].f+bl[j].s)]*ifact[bl[i].f-bl[j].f])%mod *ifact[bl[i].s-bl[j].s])%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 14",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 15",
          "code": "5\n3 3\n4 1\n2 2\n0 3\n9 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 16",
          "code": "cout << fixed",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 17",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 18",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 19",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 20",
          "code": "printf(\"%.18lf\\n\", (double)ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 313 — Подробный разбор задач - Codeforces - Code 21",
          "code": "if(((Call1) && (Call2)) || ((Call3) && (Call4)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19237",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 100000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> black_cells;\n\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, h, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, w, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> cell = make_pair(ri, ci);\n\n        ensuref(black_cells.count(cell) == 0, \"Black cell at (%d, %d) is duplicated\", ri, ci);\n\n        black_cells.insert(cell);\n    }\n\n    ensuref(black_cells.count(make_pair(1,1)) == 0, \"Starting cell (1,1) is black\");\n\n    ensuref(black_cells.count(make_pair(h,w)) == 0, \"Ending cell (%d,%d) is black\", h, w);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 100000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> black_cells;\n\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, h, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, w, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> cell = make_pair(ri, ci);\n\n        ensuref(black_cells.count(cell) == 0, \"Black cell at (%d, %d) is duplicated\", ri, ci);\n\n        black_cells.insert(cell);\n    }\n\n    ensuref(black_cells.count(make_pair(1,1)) == 0, \"Starting cell (1,1) is black\");\n\n    ensuref(black_cells.count(make_pair(h,w)) == 0, \"Ending cell (%d,%d) is black\", h, w);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 100000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readSpace();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> black_cells;\n\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, h, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, w, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> cell = make_pair(ri, ci);\n\n        ensuref(black_cells.count(cell) == 0, \"Black cell at (%d, %d) is duplicated\", ri, ci);\n\n        black_cells.insert(cell);\n    }\n\n    ensuref(black_cells.count(make_pair(1,1)) == 0, \"Starting cell (1,1) is black\");\n\n    ensuref(black_cells.count(make_pair(h,w)) == 0, \"Ending cell (%d,%d) is black\", h, w);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator creates a single test case each time it is run.\n\n  Parameters (all must be provided via command line):\n    - h : number of rows       (1 <= h <= 100000)\n    - w : number of columns    (1 <= w <= 100000)\n    - n : number of black cells (1 <= n <= 2000)\n    - pattern (optional): one of [\"random\", \"line\", \"diagonal\", \"edges\", \"sparse\", \"dense\", ...]\n      default = \"random\".\n\n  The generator prints:\n    1) A line with h, w, n\n    2) n lines, each with two distinct integers r_i, c_i, describing black cells\n       (1 <= r_i <= h, 1 <= c_i <= w).\n\n  Constraints ensured by this generator:\n    - The (1,1) cell is never black.\n    - The (h,w) cell is never black.\n    - Black cells are distinct.\n    - 1 <= n <= 2000\n    - 1 <= h,w <= 100000\n*/\n\nstatic const bool DBG = false;\n\n/* Try safe insertion of a black cell (r, c) into blackCells set (avoiding duplicates). */\nbool tryInsert(set<pair<int,int>>& blackCells, int r, int c, int h, int w) {\n    if (r < 1 || r > h) return false;\n    if (c < 1 || c > w) return false;\n    if ((r == 1 && c == 1) || (r == h && c == w)) return false;\n    auto it = blackCells.insert({r, c});\n    return it.second; // true if newly inserted, false if it was already present\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int h = opt<int>(\"h\");\n    int w = opt<int>(\"w\");\n    int n = opt<int>(\"n\");\n    string pattern = opt<std::string>(\"pattern\", \"random\");\n\n    // We will store black cells in a set to avoid duplicates\n    set<pair<int,int>> blackCells;\n\n    // Helper lambda to fill random cells until blackCells.size() == n\n    auto fillRandom = [&](int need) {\n        while ((int)blackCells.size() < need) {\n            int rr = rnd.next(1, h);\n            int cc = rnd.next(1, w);\n            tryInsert(blackCells, rr, cc, h, w);\n        }\n    };\n\n    // Choose method based on 'pattern'\n    if (pattern == \"line\") {\n        // Place black cells along some row or column in a linear fashion, then fill the remainder randomly\n        int placed = 0;\n        // We'll attempt to put them in the second column from row=2,3,... if possible\n        // If we run out of rows, we'll fill randomly for the remainder\n        for (int r = 2; r <= h && placed < n; r++) {\n            if (tryInsert(blackCells, r, 2, h, w)) {\n                placed++;\n            }\n        }\n        // Fill remaining with random\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"diagonal\") {\n        // Place black cells along the diagonal (2,2), (3,3), ...\n        // Then fill the remainder randomly\n        int placed = 0;\n        int limit = min(h, w);\n        for (int i = 2; i <= limit && placed < n; i++) {\n            if (tryInsert(blackCells, i, i, h, w)) {\n                placed++;\n            }\n        }\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"edges\") {\n        // Fill black cells along top row (except (1,1)) and left column (except (1,1)),\n        // then if more needed, fill random.\n        int placed = 0;\n        // Top row from col=2..w-1\n        for (int c = 2; c < w && placed < n; c++) {\n            if (tryInsert(blackCells, 1, c, h, w)) {\n                placed++;\n            }\n        }\n        // Left column from row=2..h-1\n        for (int r = 2; r < h && placed < n; r++) {\n            if (tryInsert(blackCells, r, 1, h, w)) {\n                placed++;\n            }\n        }\n        // Fill random for the remainder\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"sparse\") {\n        // \"Sparse\" idea: place black cells but very spread out.\n        // We'll place some in a grid-like approach, skipping rows/cols in increments.\n        // Then fill the remainder randomly.\n        int stepRow = max(1, h / (n+1)); // try to distribute across rows\n        int stepCol = max(1, w / (n+1)); // try to distribute across cols\n        int row = 2, col = 2; \n        int placed = 0;\n        while (row <= h && col <= w && placed < n) {\n            if (tryInsert(blackCells, row, col, h, w)) {\n                placed++;\n            }\n            row += stepRow;\n            col += stepCol;\n        }\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"dense\") {\n        // \"Dense\" idea: place black cells near the top-left corner.\n        // Then fill the remainder randomly as needed.\n        int placed = 0;\n        // We'll skip (1,1) but try to fill near that corner in row-major order\n        for (int r = 1; r <= h && placed < n; r++) {\n            for (int c = 1; c <= w && placed < n; c++) {\n                if (r == 1 && c == 1) continue;\n                if (r == h && c == w) continue;\n                if (tryInsert(blackCells, r, c, h, w)) {\n                    placed++;\n                }\n            }\n        }\n        // If still not enough (rare if h*w is small), fill random\n        if (placed < n) fillRandom(n);\n    }\n    else {\n        // Default or \"random\" pattern\n        fillRandom(n);\n    }\n\n    // Output\n    // First line: h, w, n\n    printf(\"%d %d %d\\n\", h, w, n);\n\n    // We only need to print exactly n black cells\n    // blackCells now might contain exactly n distinct cells, or possibly more if\n    // the pattern logic inserted extra (should not happen if we do it carefully).\n    // But to be safe, let's put them in a vector and only print the first n.\n    vector<pair<int,int>> blackVec(blackCells.begin(), blackCells.end());\n    // In rare extreme patterns if more than n got inserted (shouldn't happen in the code above),\n    // we'll just truncate. If fewer (which we handle by fillRandom(n)), we have exactly n.\n    // Optionally shuffle them before printing\n    shuffle(blackVec.begin(), blackVec.end());\n\n    // Print exactly n lines\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", blackVec[i].first, blackVec[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator creates a single test case each time it is run.\n\n  Parameters (all must be provided via command line):\n    - h : number of rows       (1 <= h <= 100000)\n    - w : number of columns    (1 <= w <= 100000)\n    - n : number of black cells (1 <= n <= 2000)\n    - pattern (optional): one of [\"random\", \"line\", \"diagonal\", \"edges\", \"sparse\", \"dense\", ...]\n      default = \"random\".\n\n  The generator prints:\n    1) A line with h, w, n\n    2) n lines, each with two distinct integers r_i, c_i, describing black cells\n       (1 <= r_i <= h, 1 <= c_i <= w).\n\n  Constraints ensured by this generator:\n    - The (1,1) cell is never black.\n    - The (h,w) cell is never black.\n    - Black cells are distinct.\n    - 1 <= n <= 2000\n    - 1 <= h,w <= 100000\n*/\n\nstatic const bool DBG = false;\n\n/* Try safe insertion of a black cell (r, c) into blackCells set (avoiding duplicates). */\nbool tryInsert(set<pair<int,int>>& blackCells, int r, int c, int h, int w) {\n    if (r < 1 || r > h) return false;\n    if (c < 1 || c > w) return false;\n    if ((r == 1 && c == 1) || (r == h && c == w)) return false;\n    auto it = blackCells.insert({r, c});\n    return it.second; // true if newly inserted, false if it was already present\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int h = opt<int>(\"h\");\n    int w = opt<int>(\"w\");\n    int n = opt<int>(\"n\");\n    string pattern = opt<std::string>(\"pattern\", \"random\");\n\n    // We will store black cells in a set to avoid duplicates\n    set<pair<int,int>> blackCells;\n\n    // Helper lambda to fill random cells until blackCells.size() == n\n    auto fillRandom = [&](int need) {\n        while ((int)blackCells.size() < need) {\n            int rr = rnd.next(1, h);\n            int cc = rnd.next(1, w);\n            tryInsert(blackCells, rr, cc, h, w);\n        }\n    };\n\n    // Choose method based on 'pattern'\n    if (pattern == \"line\") {\n        // Place black cells along some row or column in a linear fashion, then fill the remainder randomly\n        int placed = 0;\n        // We'll attempt to put them in the second column from row=2,3,... if possible\n        // If we run out of rows, we'll fill randomly for the remainder\n        for (int r = 2; r <= h && placed < n; r++) {\n            if (tryInsert(blackCells, r, 2, h, w)) {\n                placed++;\n            }\n        }\n        // Fill remaining with random\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"diagonal\") {\n        // Place black cells along the diagonal (2,2), (3,3), ...\n        // Then fill the remainder randomly\n        int placed = 0;\n        int limit = min(h, w);\n        for (int i = 2; i <= limit && placed < n; i++) {\n            if (tryInsert(blackCells, i, i, h, w)) {\n                placed++;\n            }\n        }\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"edges\") {\n        // Fill black cells along top row (except (1,1)) and left column (except (1,1)),\n        // then if more needed, fill random.\n        int placed = 0;\n        // Top row from col=2..w-1\n        for (int c = 2; c < w && placed < n; c++) {\n            if (tryInsert(blackCells, 1, c, h, w)) {\n                placed++;\n            }\n        }\n        // Left column from row=2..h-1\n        for (int r = 2; r < h && placed < n; r++) {\n            if (tryInsert(blackCells, r, 1, h, w)) {\n                placed++;\n            }\n        }\n        // Fill random for the remainder\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"sparse\") {\n        // \"Sparse\" idea: place black cells but very spread out.\n        // We'll place some in a grid-like approach, skipping rows/cols in increments.\n        // Then fill the remainder randomly.\n        int stepRow = max(1, h / (n+1)); // try to distribute across rows\n        int stepCol = max(1, w / (n+1)); // try to distribute across cols\n        int row = 2, col = 2; \n        int placed = 0;\n        while (row <= h && col <= w && placed < n) {\n            if (tryInsert(blackCells, row, col, h, w)) {\n                placed++;\n            }\n            row += stepRow;\n            col += stepCol;\n        }\n        if (placed < n) fillRandom(n);\n    }\n    else if (pattern == \"dense\") {\n        // \"Dense\" idea: place black cells near the top-left corner.\n        // Then fill the remainder randomly as needed.\n        int placed = 0;\n        // We'll skip (1,1) but try to fill near that corner in row-major order\n        for (int r = 1; r <= h && placed < n; r++) {\n            for (int c = 1; c <= w && placed < n; c++) {\n                if (r == 1 && c == 1) continue;\n                if (r == h && c == w) continue;\n                if (tryInsert(blackCells, r, c, h, w)) {\n                    placed++;\n                }\n            }\n        }\n        // If still not enough (rare if h*w is small), fill random\n        if (placed < n) fillRandom(n);\n    }\n    else {\n        // Default or \"random\" pattern\n        fillRandom(n);\n    }\n\n    // Output\n    // First line: h, w, n\n    printf(\"%d %d %d\\n\", h, w, n);\n\n    // We only need to print exactly n black cells\n    // blackCells now might contain exactly n distinct cells, or possibly more if\n    // the pattern logic inserted extra (should not happen if we do it carefully).\n    // But to be safe, let's put them in a vector and only print the first n.\n    vector<pair<int,int>> blackVec(blackCells.begin(), blackCells.end());\n    // In rare extreme patterns if more than n got inserted (shouldn't happen in the code above),\n    // we'll just truncate. If fewer (which we handle by fillRandom(n)), we have exactly n.\n    // Optionally shuffle them before printing\n    shuffle(blackVec.begin(), blackVec.end());\n\n    // Print exactly n lines\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", blackVec[i].first, blackVec[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct commands to run this single generator program.\n# Each command will produce a single test case on stdout.\n\n# Small boards, small n\n./gen -h 2 -w 2 -n 1 -pattern random\n./gen -h 3 -w 4 -n 1 -pattern line\n./gen -h 5 -w 5 -n 3 -pattern diagonal\n./gen -h 5 -w 5 -n 3 -pattern edges\n\n# Medium boards, varied patterns\n./gen -h 10 -w 10 -n 5 -pattern random\n./gen -h 10 -w 10 -n 8 -pattern dense\n./gen -h 12 -w 12 -n 10 -pattern sparse\n./gen -h 15 -w 15 -n 14 -pattern edges\n./gen -h 20 -w 5 -n 5 -pattern line\n./gen -h 5 -w 20 -n 5 -pattern diagonal\n\n# Larger boards, varied patterns\n./gen -h 50 -w 50 -n 10 -pattern random\n./gen -h 100 -w 100 -n 50 -pattern diagonal\n./gen -h 100 -w 100 -n 50 -pattern edges\n./gen -h 200 -w 200 -n 100 -pattern sparse\n./gen -h 300 -w 300 -n 200 -pattern dense\n\n# Large boards, near upper limit for n\n./gen -h 1000 -w 1000 -n 2000 -pattern random\n./gen -h 10000 -w 9999 -n 2000 -pattern edges\n./gen -h 99999 -w 99999 -n 2000 -pattern diagonal\n./gen -h 100000 -w 100000 -n 2000 -pattern dense\n./gen -h 100000 -w 99999 -n 2000 -pattern sparse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:34.947784",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "566/A",
      "title": "A. Matching Names",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 100 000) — the number of students in the summer school.Next n lines contain the name of the students. Each name is a non-empty word consisting of lowercase English letters. Some names can be repeating.The last n lines contain the given pseudonyms. Each pseudonym is a non-empty word consisting of small English letters. Some pseudonyms can be repeating.The total length of all the names and pseudonyms doesn't exceed 800 000 characters.",
      "output_spec": "OutputIn the first line print the maximum possible quality of matching pseudonyms to students.In the next n lines describe the optimal matching. Each line must have the form a b (1 ≤ a, b ≤ n), that means that the student who was number a in the input, must match to the pseudonym number b in the input.The matching should be a one-to-one correspondence, that is, each student and each pseudonym should occur exactly once in your output. If there are several optimal answers, output any.",
      "sample_tests": "ExamplesInputCopy5gennadygalyaborisbilltoshikbilbotoringendalfsmauggaladrielOutputCopy114 12 51 35 23 4",
      "description": "A. Matching Names\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains number n (1 ≤ n ≤ 100 000) — the number of students in the summer school.Next n lines contain the name of the students. Each name is a non-empty word consisting of lowercase English letters. Some names can be repeating.The last n lines contain the given pseudonyms. Each pseudonym is a non-empty word consisting of small English letters. Some pseudonyms can be repeating.The total length of all the names and pseudonyms doesn't exceed 800 000 characters.\n\nOutputIn the first line print the maximum possible quality of matching pseudonyms to students.In the next n lines describe the optimal matching. Each line must have the form a b (1 ≤ a, b ≤ n), that means that the student who was number a in the input, must match to the pseudonym number b in the input.The matching should be a one-to-one correspondence, that is, each student and each pseudonym should occur exactly once in your output. If there are several optimal answers, output any.\n\nInputCopy5gennadygalyaborisbilltoshikbilbotoringendalfsmauggaladrielOutputCopy114 12 51 35 23 4\n\nInputCopy5gennadygalyaborisbilltoshikbilbotoringendalfsmauggaladriel\n\nOutputCopy114 12 51 35 23 4\n\nNoteThe first test from the statement the match looks as follows:   bill  →  bilbo (lcp = 3)  galya  →  galadriel (lcp = 3)  gennady  →  gendalf (lcp = 3)  toshik  →  torin (lcp = 2)  boris  →  smaug (lcp = 0)",
      "solutions": [
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces",
          "content": "Thanks everybody for participating. Tasks follow in the order of the original contest (the mirror order is given in the brackets).562A - Logistical Questions(in mirror: 566C - Logistical Questions)Let's think about formal statement of the problem. We are given a tricky definition of a distance on the tre: ρ(a, b) = dist(a, b)1.5. Each vertex has its weight wi. We need to choose a place x for a competition such that the sum of distances from all vertices of the tree with their weights is minimum possible: f(x) = w1ρ(1, x) + w2ρ(x, 2) + ... + wnρ(x, n).Let's understand how function f(x) works. Allow yourself to put point x not only in vertices of the tree, but also in any point inside each edge by naturally expanding the distance definition (for example, the middle of the edge of length 4 km is located 2 km from both ends of this edge).Fact 1. For any path in the tree the function ρ(i, x) is convex. Actually, the function dist(i, x) plot on each path [a, b] looks like the plot of a function abs(x): it first decreases linearly to the minimum: the closes to i point on a segment [a, b], and then increases linearly. Taking a composition with a convex increasing function t1.5, as we can see, we get the convex function on any path in the tree. Here by function on the path we understand usual function of a real variable x that is identified with its location on path x: dist(a, x). So, each of the summands in the definition of f(x) is convex on any path in the tree, so f(x) is also convex on any path in the tree.Let's call convex functions on any path in the tree convex on tree. Let's formulate few facts about convex functions on trees.Fact 2. A convex function on tree can't have two different local minimums. Indeed, otherwise the path between those minimums contradicts the property of being convex on any path in the tree.So, any convex function f(x) on the tree has the only local minimum that coincides with its global minimum.Fact 3. From each vertex v there exists no more than one edge in which direction the function f decreases. Indeed, otherwise the path connecting two edges of function decrease would contradict the definition of a convex function in a point v.Let's call such edge that function decreases along this edge to be a gradient of function f in point x. By using facts 2 and 3 we see that in each vertex there is either a uniquely defined gradient or the vertex is a global minimum.Suppose we are able to efficiently find a gradient direction by using some algorithm for a given vertex v. If our tree was a bamboo then the task would be a usual convex function minimization that is efficiently solved by a binary search, i. e. dichotomy. We need some equivalent of a dichotomy for a tree. What is it?Let's use centroid decmoposition! Indeed, let's take a tree center (i. e. such vertex that sizes of all its subtrees are no larger than n / 2). By using fact 3 we may consider the gradient of f in the center of the tree. First of all, there may be no gradient in this point meaning that we already found an optimum. Otherwise we know that global minimum is located in a subtree in direction of gradient, so all remaining subtrees and the center can be excluded from our consideration. So, by running one gradient calculation we reduced the number of vertices in a considered part of a tree twice.So, in runs of gradient calculation we almost solved the problem. Let's understand where exactly the answer is located. Note that the global optimum will most probably be located inside some edge. It is easy to see that the optimum vertex will be one of the vertices incident to that edge, or more specifically, one of the last two considered vertices by our algorithms. Which exactly can be determined by calculating the exact answer for them and choosing the most optimal among them.Now let's calculate the gradient direction in a vertex v. Fix a subtree ui of a vertex v. Consider a derivative of all summands from that subtree when we move into that subtree. Denote this derivative as deri. Then, as we can see, the derivative of f(x) while moving from x = v in direction of subtree ui is  - der1 - der2 - ... - deri - 1 + deri - deri + 1 - ... - derk where k is a degree of vertex v. So, by running one DFS from vertex v we may calculate all values deri, and so we may find a gradient direction by applying the formula above and considering a direction with negative derivative.Finally, we got a solution in .562B - Clique in the Divisibility Graph(in mirror: 566F - Clique in the Divisibility Graph)Order numbers in the sought clique in ascending order. Note that set X = {x1, ..., xk} is a clique iff for (1 ≤ i ≤ k - 1). So, it's easy to formulate a dynamic programming problem: D[x] is equal to the length of a longest suitable increasing subsequence ending in a number x. The calculation formula: for all x in set A.If DP is written in \"forward\" direction then it's easy to estimate the complexity of a solution. In the worst case we'll process transitions.562C - Restoring Map(in mirror: 566E - Restoring Map)Let's call a neighborhood of a vertex — the set consisting of it and all vertices near to it. So, we know the set of all neighborhoods of all vertices in some arbitrary order, and also each neighborhood is shuffled in an arbitrary order.Let's call the tree vertex to be internal if it is not a tree leaf. Similarly, let's call a tree edge to be internal if it connects two internal vertices. An nice observation is that if two neighborhoods intersect exactly by two elements a and b then a and b have to be connected with an edge, in particular the edge (a, b) is internal. Conversely, any internal edge (a, b) may be represented as an intersection of some two neighborhoods С and D of some two vertices c and d such that there is a path c – a – b – d in the tree. In such manner we may find all internal edges by considering pairwise intersections of all neighborhoods. This can be done in about n3 / 2 operations naively, or in 32 times faster, by using bitsets technique.Note that knowing all internal edges we may determine all internal vertices except the only case of a star graph (i. e. the graph consisting of a vertex with several other vertices attached to it). The case of a star should be considered separately.Now we know the set of all leaves, all internal vertices and a tree structure on all internal vertices. The only thing that remained is to determine for each leaf, to what internal vertex is should be attached. This can be done in following manner. Consider a leaf l. Consider all neighborhoods containing it. Consider a minimal neighborhood among them; it can be shown that it is exactly the neighborhood L corresponding to a leaf l itself. Consider all internal vertices in L. There can be no less than two of them. If there are three of them or more then we can uniquely determine to which of them l should be attached — it should be such vertex from them that has a degree inside L larger than 1. If there are exactly two internal vertices in L (let's say, a and b), then determining the attach point for l is a bit harder.Statement: l should be attached to that vertex among a, b, that has an internal degree exactly 1. Indeed, if l was attached to a vertex with internal degree larger than 1, we would have considered this case before.If both of vertices a and b have internal degree — 1 then our graph looks like a dumbbell (an edge (a, b) and all remaining vertices attached either to a or to b). Such case should also be considered separately.The solution for two special cases remains for a reader as an easy exercise.562D - Restructuring Company(in mirror: 566D - Restructuring Company)This problem allows a lot of solution with different time asymptotic. Let's describe a solution in . Let's first consider a problem with only a queries of second and third type. It can be solved in a following manner. Consider a line consisting of all employees from 1 to n. An observation: any department looks like a contiguous segment of workers. Let's keep those segments in any logarithmic data structure like a balanced binary search tree (std::set or TreeSet). When merging departments from x to y, just extract all segments that are in the range [x, y] and merge them. For answering a query of the third type just check if employees x and y belong to the same segment. In such manner we get a solution of an easier problem in per query. When adding the queries of a first type we in fact allow some segments to correspond to the same department. Let's add a DSU for handling equivalence classes of segments. Now the query of the first type is just using merge inside DSU for departments which x and y belong to. Also for queries of the second type it's important not to forget to call merge from all extracted segments.So we get a solution in time.562E - Max and Min(in mirror: 566G - Max and Min)Consider a following geometrical interpretation. Both Max and Min have a set of vectors from the first plane quadrant and a point (x, y). During his turn Max may add any of his vectors to a point (x, y), and Min — may subtract any of his vectors. Min wants point (x, y) to be strictly in the third quadrant, Max tries to prevent his from doing it. Denote Max vectors as Mxi and Min vectors as Mnj.Consider a following obvious sufficient condition for Max to win. Consider some non-negative direction in a plane, i. e. such vector (a, b) that a, b ≥ 0 and at least one of numbers a, b is not a zero. Then if among Max vectors there is such vector Mxi, that it's not shorter than any of Min vectors Mnj along the direction (a, b) then Max can surely win. Here by the length of vector v along a direction (a, b) we mean a scalar product of vector v and vector (a, b). Indeed, let Max always use that vector Mxi. Then during the turns of Max and Min point (x, y) is shifted by a vector Mxi - Mnj for some j, so its overall shift along the vector (a, b) is equal to ((Mxi - Mnj), (a, b)) = (Mxi, (a, b)) - (Mnj, (a, b)) ≥ 0. By observing that initially the scalar produt ((x, y), (a, b)) = ax + by > 0 we see that at any moment ax + by will be strictly positive. This means that Min won't be able at any moment to make x and y both be negative (since it would mean that ax + by < 0).Now let's formulate some kind of converse statement. Suppose Max vector Mxi lies strictly inside the triangle formed by Min vectors Mnj and Mnk. In particular, vector Mxi endpoint can't lie on a segment [Mnj, Mnk], but it may be collinear one of vectors Mnj and Mnk. Note that since Mxi lies strictly inside the triangle formed by vectors Mnj and Mnk it can be extended to a vector Mx'i, whose endpoint lies on a segment [Mnj, Mnk]. By using linear dependence of Mx'i and Mnj, Mnk we have that Mx'i = (p / r)Mnj + (q / r)Mnk, where p + q = r and p, q, r — integer non-negative numbers. This is equivalent to a formula rMx'i = pMnj + qMnk. This means that if per each r turns of Max in Mxi we will respond with p turns of Min in Mnj and q turns of Min in Mnk, then the total shift will be equal to  - pMnj - qMnk + rMxi =  - rMx'i + rMxi =  - r(Mx'i - Mxi), that is the vector with strictly negative components. So, we are able to block that Max turn, i. e. it does not give any advantage to Max.The natural wish is to create a convex hull of all Min turns and to consider all Max turns in respect to it. If Max turn lies inside the convex hull of Min turns, then by using the previous fact this turn is meaningless to Max. Otherwise, there are two possibilities. First, this turn may intersect the hull but go out of it somewhere; in this case this Max turn is no shorter than all Min turns in some non-negative direction (more specifically, in its own direction), so Max wins.On the other hand, Max vector lies to aside from the Min turns convex hull. Let's suppose the vector Mxi lies to the left of the Min turns. This case requires a special analysis. Consider the topmost of the Min vectors Mnj. If Mxi is no lower than Mxj, then by using the first fact Max is able to win by using only this vector. Otherwise the difference Mni - Mxj is a vector with strictly negative components, by using which we are able to block that Max vector.So, the full version of a criteria for Min being a winner looks like the following. Consider a convex hull of Min turns and expand it to the left of the topmost point and to the bottom of the rightmost point. If all Max turns lie strictly inside the formed figure then Min wins, otherwise Max wins.562F - Matching Names(в трансляции: 566A - Matching Names)Form a trie from all names and pseudonyms. Mark with red all vertices corresponding to names, and with blue all vertices corresponding to the pseudonyms (a single vertex may be marked several times, possibly with different colors). Note that if we match a name a and a pseudonym b, then the quality of such match is lcp(a, b) = 1 / 2(2 * lcp(a, b)) = 1 / 2(|a| + |b| - (|a| - lcp(a, b)) - (|b| - lcp(a, b))), that is equal to a constant 1 / 2(|a| + |b|), with subtracted half of a length of a path between a and b over the trie. So, what we need is to connect all red vertices with blue vertices with paths of a minimum possible total length.This can be done with a following greedy procedure: if we have a vertex v with x red vertices and y blue vertices in its subtree then we must match min(x, y) red vertices of its subtree to min(x, y) blue vertices of its subtree and leave the remaining max(x, y) - min(x, y) ref or blue vertices to the level higher. The correctness of such algorithm may be easily shown by the next idea. Give each edge of each path a direction from a red vertex to a blue. If some edge recieves two different directions after this procedure, we may cross-change two paths through it so that their total length is reduced by two.So, we get a solution in O(sumlen) where sumlen is a total length of all names and pseudonyms.562G - Replicating Processes(в трансляции: 566B - Replicating Processes)==== UNTRANSLATED SECTION, PLEASE WAIT A FEW MINUTES... ====Kitten to take your attention :)This problem may be solved by simulating the replication process. Let's keep a list of all replications that may be applied by the current step. Apply an arbitrary replication, after that update a list by adding/removing all suitable or now unsuitable replications touching all affected on current step servers. The list of replications may be kept in a \"double-linked list\" data structure, that allows to add and remove elements to/from the set and to extract an arbitrary element of the set in O(1).The proof of correctness of such algorithm is not hard and is left as an exercies (maybe it will appear here later).We got a solution in O(n) operation (though, the constant hidden by O-notation is pretty large; the input size is already 12n numbers and the solution itself hides a constant 36 or higher).",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 566\\s*A"
          },
          "content_length": 14875
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 1",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 2",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 3",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 4",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    int total_length = 0;\n\n    // Read n student names\n    for (int i = 0; i < n; ++i) {\n        string name = inf.readToken(\"[a-z]+\", \"student_name\");\n        total_length += name.size();\n        inf.readEoln();\n    }\n\n    // Read n pseudonyms\n    for (int i = 0; i < n; ++i) {\n        string pseudonym = inf.readToken(\"[a-z]+\", \"pseudonym\");\n        total_length += pseudonym.size();\n        inf.readEoln();\n    }\n\n    ensuref(total_length <= 800000,\n        \"The total length of all names and pseudonyms must not exceed 800000, but it is %d\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    int total_length = 0;\n\n    // Read n student names\n    for (int i = 0; i < n; ++i) {\n        string name = inf.readToken(\"[a-z]+\", \"student_name\");\n        total_length += name.size();\n        inf.readEoln();\n    }\n\n    // Read n pseudonyms\n    for (int i = 0; i < n; ++i) {\n        string pseudonym = inf.readToken(\"[a-z]+\", \"pseudonym\");\n        total_length += pseudonym.size();\n        inf.readEoln();\n    }\n\n    ensuref(total_length <= 800000,\n        \"The total length of all names and pseudonyms must not exceed 800000, but it is %d\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    int total_length = 0;\n\n    // Read n student names\n    for (int i = 0; i < n; ++i) {\n        string name = inf.readToken(\"[a-z]+\", \"student_name\");\n        total_length += name.size();\n        inf.readEoln();\n    }\n\n    // Read n pseudonyms\n    for (int i = 0; i < n; ++i) {\n        string pseudonym = inf.readToken(\"[a-z]+\", \"pseudonym\");\n        total_length += pseudonym.size();\n        inf.readEoln();\n    }\n\n    ensuref(total_length <= 800000,\n        \"The total length of all names and pseudonyms must not exceed 800000, but it is %d\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute the length of the longest common prefix of two strings\nint lcp(const string &a, const string &b) {\n    int len = min(a.length(), b.length());\n    for (int i = 0; i < len; ++i) {\n        if (a[i] != b[i])\n            return i;\n    }\n    return len;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read the input\n    int n = inf.readInt();\n    vector<string> students(n);\n    vector<string> pseudonyms(n);\n    for (int i = 0; i < n; ++i)\n        students[i] = inf.readToken();\n    for (int i = 0; i < n; ++i)\n        pseudonyms[i] = inf.readToken();\n    \n    // Read the jury's maximum total quality from the answer file\n    int juryTotalQuality = ans.readInt();\n    \n    // Read the participant's total quality\n    int participantTotalQuality = ouf.readInt();\n    if (participantTotalQuality < juryTotalQuality)\n        quitf(_wa, \"Participant's total quality is less than the maximum possible total quality: %d vs %d\",\n              participantTotalQuality, juryTotalQuality);\n    else if (participantTotalQuality > juryTotalQuality)\n        quitf(_fail, \"Participant's total quality is greater than the maximum possible total quality: %d vs %d\",\n              participantTotalQuality, juryTotalQuality);\n    \n    // Read the participant's matching\n    if (ouf.eof())\n        quitf(_pe, \"Participant's output is incomplete\");\n    \n    vector<int> studentIndices(n);\n    vector<int> pseudonymIndices(n);\n    vector<bool> usedStudents(n, false);\n    vector<bool> usedPseudonyms(n, false);\n    for (int i = 0; i < n; ++i) {\n        int a = ouf.readInt(1, n, \"student index\");\n        int b = ouf.readInt(1, n, \"pseudonym index\");\n        \n        if (usedStudents[a - 1])\n            quitf(_wa, \"Student %d is assigned more than once\", a);\n        if (usedPseudonyms[b - 1])\n            quitf(_wa, \"Pseudonym %d is assigned more than once\", b);\n        usedStudents[a - 1] = true;\n        usedPseudonyms[b - 1] = true;\n        \n        studentIndices[i] = a - 1;\n        pseudonymIndices[i] = b - 1;\n    }\n    \n    // Compute the total quality of the participant's matching\n    int totalQuality = 0;\n    for (int i = 0; i < n; ++i) {\n        int idxStudent = studentIndices[i];\n        int idxPseudonym = pseudonymIndices[i];\n        totalQuality += lcp(students[idxStudent], pseudonyms[idxPseudonym]);\n    }\n    \n    // Verify that the participant's total quality matches the maximum total quality\n    if (totalQuality != participantTotalQuality)\n        quitf(_wa, \"Participant's total quality does not match the sum of relevances: claimed = %d, computed = %d\",\n              participantTotalQuality, totalQuality);\n    \n    if (totalQuality != juryTotalQuality)\n        quitf(_wa, \"Participant's total quality is not the maximum possible total quality: %d vs %d\",\n              totalQuality, juryTotalQuality);\n    \n    quitf(_ok, \"Answer is correct with total quality = %d\", totalQuality);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    const int max_total_len = 800000; // Maximum total length of names and pseudonyms\n\n    vector<string> students(n), pseudonyms(n);\n\n    if (type == \"random\") {\n        // Generate random names and pseudonyms\n        int avg_len = max(1, max_total_len / (4 * n));\n        int max_len = avg_len * 2;\n\n        int total_len = 0;\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n            total_len += len;\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = s;\n            total_len += len;\n        }\n    } else if (type == \"same_names\") {\n        // All student names are the same\n        string s = \"student\";\n        students.assign(n, s);\n        int total_len = s.length() * n;\n\n        int remaining_len = max_total_len - total_len;\n        int avg_len = max(1, remaining_len / n);\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n            total_len += len;\n        }\n    } else if (type == \"max_lcp\") {\n        // Names and pseudonyms are the same\n        int avg_len = max(1, max_total_len / (2 * n));\n        int max_len = min(10000, avg_len * 2);\n\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n            pseudonyms[i] = s;\n        }\n    } else if (type == \"min_lcp\") {\n        // Names and pseudonyms with no common prefixes\n        int avg_len = max(1, max_total_len / (2 * n));\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            // Generate student name\n            int len_s = rnd.next(1, max_len);\n            string s(len_s, 'a');\n            for (int j = 0; j < len_s; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n\n            // Generate pseudonym with different first character\n            int len_p = rnd.next(1, max_len);\n            string t(len_p, 'a');\n            char first_char;\n            do {\n                first_char = 'a' + rnd.next(26);\n            } while (first_char == s[0]);\n            t[0] = first_char;\n            for (int j = 1; j < len_p; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n        }\n    } else if (type == \"reversed\") {\n        // Pseudonyms are reversed names\n        int avg_len = max(1, max_total_len / (2 * n));\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            // Generate student name\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n\n            // Pseudonym is reversed name\n            string t = s;\n            reverse(t.begin(), t.end());\n            pseudonyms[i] = t;\n        }\n    } else if (type == \"duplicated_names\") {\n        // Some student names are duplicated\n        int num_unique = rnd.next(1, n);\n        int avg_len = max(1, max_total_len / (2 * num_unique));\n        int max_len = avg_len * 2;\n\n        vector<string> unique_names;\n        for (int i = 0; i < num_unique; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            unique_names.push_back(s);\n        }\n        for (int i = 0; i < n; ++i) {\n            students[i] = unique_names[rnd.next(num_unique)];\n        }\n        // Random pseudonyms\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n        }\n    } else if (type == \"duplicated_pseudonyms\") {\n        // Some pseudonyms are duplicated\n        int num_unique = rnd.next(1, n);\n        int avg_len = max(1, max_total_len / (2 * num_unique));\n        int max_len = avg_len * 2;\n\n        vector<string> unique_pseudos;\n        for (int i = 0; i < num_unique; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            unique_pseudos.push_back(t);\n        }\n        // Random student names\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n        }\n        for (int i = 0; i < n; ++i) {\n            pseudonyms[i] = unique_pseudos[rnd.next(num_unique)];\n        }\n    } else if (type == \"max_total_length\") {\n        // Generate names and pseudonyms to reach total length close to 800,000\n        int len_per_word = min(10000, max_total_len / (2 * n));\n        for (int i = 0; i < n; ++i) {\n            string s(len_per_word, 'a');\n            students[i] = s;\n            pseudonyms[i] = s;\n        }\n    } else {\n        // Default to random generation\n        int avg_len = max(1, max_total_len / (4 * n));\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", students[i].c_str());\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", pseudonyms[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    const int max_total_len = 800000; // Maximum total length of names and pseudonyms\n\n    vector<string> students(n), pseudonyms(n);\n\n    if (type == \"random\") {\n        // Generate random names and pseudonyms\n        int avg_len = max(1, max_total_len / (4 * n));\n        int max_len = avg_len * 2;\n\n        int total_len = 0;\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n            total_len += len;\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = s;\n            total_len += len;\n        }\n    } else if (type == \"same_names\") {\n        // All student names are the same\n        string s = \"student\";\n        students.assign(n, s);\n        int total_len = s.length() * n;\n\n        int remaining_len = max_total_len - total_len;\n        int avg_len = max(1, remaining_len / n);\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n            total_len += len;\n        }\n    } else if (type == \"max_lcp\") {\n        // Names and pseudonyms are the same\n        int avg_len = max(1, max_total_len / (2 * n));\n        int max_len = min(10000, avg_len * 2);\n\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n            pseudonyms[i] = s;\n        }\n    } else if (type == \"min_lcp\") {\n        // Names and pseudonyms with no common prefixes\n        int avg_len = max(1, max_total_len / (2 * n));\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            // Generate student name\n            int len_s = rnd.next(1, max_len);\n            string s(len_s, 'a');\n            for (int j = 0; j < len_s; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n\n            // Generate pseudonym with different first character\n            int len_p = rnd.next(1, max_len);\n            string t(len_p, 'a');\n            char first_char;\n            do {\n                first_char = 'a' + rnd.next(26);\n            } while (first_char == s[0]);\n            t[0] = first_char;\n            for (int j = 1; j < len_p; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n        }\n    } else if (type == \"reversed\") {\n        // Pseudonyms are reversed names\n        int avg_len = max(1, max_total_len / (2 * n));\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            // Generate student name\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n\n            // Pseudonym is reversed name\n            string t = s;\n            reverse(t.begin(), t.end());\n            pseudonyms[i] = t;\n        }\n    } else if (type == \"duplicated_names\") {\n        // Some student names are duplicated\n        int num_unique = rnd.next(1, n);\n        int avg_len = max(1, max_total_len / (2 * num_unique));\n        int max_len = avg_len * 2;\n\n        vector<string> unique_names;\n        for (int i = 0; i < num_unique; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            unique_names.push_back(s);\n        }\n        for (int i = 0; i < n; ++i) {\n            students[i] = unique_names[rnd.next(num_unique)];\n        }\n        // Random pseudonyms\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n        }\n    } else if (type == \"duplicated_pseudonyms\") {\n        // Some pseudonyms are duplicated\n        int num_unique = rnd.next(1, n);\n        int avg_len = max(1, max_total_len / (2 * num_unique));\n        int max_len = avg_len * 2;\n\n        vector<string> unique_pseudos;\n        for (int i = 0; i < num_unique; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            unique_pseudos.push_back(t);\n        }\n        // Random student names\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n        }\n        for (int i = 0; i < n; ++i) {\n            pseudonyms[i] = unique_pseudos[rnd.next(num_unique)];\n        }\n    } else if (type == \"max_total_length\") {\n        // Generate names and pseudonyms to reach total length close to 800,000\n        int len_per_word = min(10000, max_total_len / (2 * n));\n        for (int i = 0; i < n; ++i) {\n            string s(len_per_word, 'a');\n            students[i] = s;\n            pseudonyms[i] = s;\n        }\n    } else {\n        // Default to random generation\n        int avg_len = max(1, max_total_len / (4 * n));\n        int max_len = avg_len * 2;\n\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string s(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                s[j] = 'a' + rnd.next(26);\n            }\n            students[i] = s;\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max_len);\n            string t(len, 'a');\n            for (int j = 0; j < len; ++j) {\n                t[j] = 'a' + rnd.next(26);\n            }\n            pseudonyms[i] = t;\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", students[i].c_str());\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", pseudonyms[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type max_lcp\n./gen -n 1 -type min_lcp\n\n./gen -n 2 -type random\n./gen -n 2 -type max_lcp\n./gen -n 2 -type min_lcp\n\n./gen -n 10 -type random\n./gen -n 10 -type same_names\n./gen -n 10 -type duplicated_names\n\n./gen -n 50 -type random\n./gen -n 50 -type same_names\n./gen -n 50 -type duplicated_pseudonyms\n\n./gen -n 100 -type max_lcp\n./gen -n 100 -type min_lcp\n./gen -n 100 -type reversed\n\n./gen -n 101 -type random\n./gen -n 101 -type max_lcp\n./gen -n 101 -type min_lcp\n./gen -n 101 -type reversed\n\n./gen -n 1000 -type random\n./gen -n 1000 -type same_names\n./gen -n 1000 -type duplicated_names\n./gen -n 1000 -type duplicated_pseudonyms\n\n./gen -n 10000 -type max_lcp\n./gen -n 10000 -type min_lcp\n./gen -n 10000 -type reversed\n./gen -n 10000 -type max_total_length\n\n./gen -n 50000 -type duplicated_names\n./gen -n 50000 -type duplicated_pseudonyms\n./gen -n 50000 -type max_total_length\n\n./gen -n 100000 -type random\n./gen -n 100000 -type max_lcp\n./gen -n 100000 -type min_lcp\n./gen -n 100000 -type same_names\n./gen -n 100000 -type duplicated_names\n./gen -n 100000 -type duplicated_pseudonyms\n./gen -n 100000 -type reversed\n./gen -n 100000 -type max_total_length\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:36.905308",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "566/B",
      "title": "B. Replicating Processes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 30 000) — the number of servers of the social network.Next 4n lines contain the rules of replicating processes, the i-th (1 ≤ i ≤ 4n) of these lines as form ai, bi, ci (1 ≤ ai, bi, ci ≤ n) and describes rule ai → (bi, ci).It is guaranteed that each number of a server from 1 to n occurs four times in the set of all ai, and eight times among a set that unites all bi and ci.",
      "output_spec": "OutputIf the required order of performing rules does not exist, print \"NO\" (without the quotes).Otherwise, print in the first line \"YES\" (without the quotes), and in the second line — a sequence of 4n numbers from 1 to 4n, giving the numbers of the rules in the order they are applied. The sequence should be a permutation, that is, include each number from 1 to 4n exactly once.If there are multiple possible variants, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy21 2 21 2 21 2 21 2 22 1 12 1 12 1 12 1 1OutputCopyYES1 2 5 6 3 7 4 8InputCopy31 2 31 1 11 1 11 1 12 1 32 2 22 2 22 2 23 1 23 3 33 3 33 3 3OutputCopyYES2 3 4 6 7 8 10 11 12 1 5 9",
      "description": "B. Replicating Processes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 30 000) — the number of servers of the social network.Next 4n lines contain the rules of replicating processes, the i-th (1 ≤ i ≤ 4n) of these lines as form ai, bi, ci (1 ≤ ai, bi, ci ≤ n) and describes rule ai → (bi, ci).It is guaranteed that each number of a server from 1 to n occurs four times in the set of all ai, and eight times among a set that unites all bi and ci.\n\nOutputIf the required order of performing rules does not exist, print \"NO\" (without the quotes).Otherwise, print in the first line \"YES\" (without the quotes), and in the second line — a sequence of 4n numbers from 1 to 4n, giving the numbers of the rules in the order they are applied. The sequence should be a permutation, that is, include each number from 1 to 4n exactly once.If there are multiple possible variants, you are allowed to print any of them.\n\nInputCopy21 2 21 2 21 2 21 2 22 1 12 1 12 1 12 1 1OutputCopyYES1 2 5 6 3 7 4 8InputCopy31 2 31 1 11 1 11 1 12 1 32 2 22 2 22 2 23 1 23 3 33 3 33 3 3OutputCopyYES2 3 4 6 7 8 10 11 12 1 5 9\n\nInputCopy21 2 21 2 21 2 21 2 22 1 12 1 12 1 12 1 1\n\nOutputCopyYES1 2 5 6 3 7 4 8\n\nInputCopy31 2 31 1 11 1 11 1 12 1 32 2 22 2 22 2 23 1 23 3 33 3 33 3 3\n\nOutputCopyYES2 3 4 6 7 8 10 11 12 1 5 9\n\nNote(1) To be extremely accurate, we should note that the amount of server memory is 1 GiB = 1024 MiB and processes require 100 MiB RAM where a gibibyte (GiB) is the amount of RAM of 230 bytes and a mebibyte (MiB) is the amount of RAM of 220 bytes.In the first sample test the network uses two servers, each of which initially has four launched processes. In accordance with the rules of replication, each of the processes must be destroyed and twice run on another server. One of the possible answers is given in the statement: after applying rules 1 and 2 the first server will have 2 old running processes, and the second server will have 8 (4 old and 4 new) processes. After we apply rules 5 and 6, both servers will have 6 running processes (2 old and 4 new). After we apply rules 3 and 7, both servers will have 7 running processes (1 old and 6 new), and after we apply rules 4 and 8, each server will have 8 running processes. At no time the number of processes on a single server exceeds 9.In the second sample test the network uses three servers. On each server, three processes are replicated into two processes on the same server, and the fourth one is replicated in one process for each of the two remaining servers. As a result of applying rules 2, 3, 4, 6, 7, 8, 10, 11, 12 each server would have 7 processes (6 old and 1 new), as a result of applying rules 1, 5, 9 each server will have 8 processes. At no time the number of processes on a single server exceeds 9.",
      "solutions": [
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces",
          "content": "Thanks everybody for participating. Tasks follow in the order of the original contest (the mirror order is given in the brackets).562A - Logistical Questions(in mirror: 566C - Logistical Questions)Let's think about formal statement of the problem. We are given a tricky definition of a distance on the tre: ρ(a, b) = dist(a, b)1.5. Each vertex has its weight wi. We need to choose a place x for a competition such that the sum of distances from all vertices of the tree with their weights is minimum possible: f(x) = w1ρ(1, x) + w2ρ(x, 2) + ... + wnρ(x, n).Let's understand how function f(x) works. Allow yourself to put point x not only in vertices of the tree, but also in any point inside each edge by naturally expanding the distance definition (for example, the middle of the edge of length 4 km is located 2 km from both ends of this edge).Fact 1. For any path in the tree the function ρ(i, x) is convex. Actually, the function dist(i, x) plot on each path [a, b] looks like the plot of a function abs(x): it first decreases linearly to the minimum: the closes to i point on a segment [a, b], and then increases linearly. Taking a composition with a convex increasing function t1.5, as we can see, we get the convex function on any path in the tree. Here by function on the path we understand usual function of a real variable x that is identified with its location on path x: dist(a, x). So, each of the summands in the definition of f(x) is convex on any path in the tree, so f(x) is also convex on any path in the tree.Let's call convex functions on any path in the tree convex on tree. Let's formulate few facts about convex functions on trees.Fact 2. A convex function on tree can't have two different local minimums. Indeed, otherwise the path between those minimums contradicts the property of being convex on any path in the tree.So, any convex function f(x) on the tree has the only local minimum that coincides with its global minimum.Fact 3. From each vertex v there exists no more than one edge in which direction the function f decreases. Indeed, otherwise the path connecting two edges of function decrease would contradict the definition of a convex function in a point v.Let's call such edge that function decreases along this edge to be a gradient of function f in point x. By using facts 2 and 3 we see that in each vertex there is either a uniquely defined gradient or the vertex is a global minimum.Suppose we are able to efficiently find a gradient direction by using some algorithm for a given vertex v. If our tree was a bamboo then the task would be a usual convex function minimization that is efficiently solved by a binary search, i. e. dichotomy. We need some equivalent of a dichotomy for a tree. What is it?Let's use centroid decmoposition! Indeed, let's take a tree center (i. e. such vertex that sizes of all its subtrees are no larger than n / 2). By using fact 3 we may consider the gradient of f in the center of the tree. First of all, there may be no gradient in this point meaning that we already found an optimum. Otherwise we know that global minimum is located in a subtree in direction of gradient, so all remaining subtrees and the center can be excluded from our consideration. So, by running one gradient calculation we reduced the number of vertices in a considered part of a tree twice.So, in runs of gradient calculation we almost solved the problem. Let's understand where exactly the answer is located. Note that the global optimum will most probably be located inside some edge. It is easy to see that the optimum vertex will be one of the vertices incident to that edge, or more specifically, one of the last two considered vertices by our algorithms. Which exactly can be determined by calculating the exact answer for them and choosing the most optimal among them.Now let's calculate the gradient direction in a vertex v. Fix a subtree ui of a vertex v. Consider a derivative of all summands from that subtree when we move into that subtree. Denote this derivative as deri. Then, as we can see, the derivative of f(x) while moving from x = v in direction of subtree ui is  - der1 - der2 - ... - deri - 1 + deri - deri + 1 - ... - derk where k is a degree of vertex v. So, by running one DFS from vertex v we may calculate all values deri, and so we may find a gradient direction by applying the formula above and considering a direction with negative derivative.Finally, we got a solution in .562B - Clique in the Divisibility Graph(in mirror: 566F - Clique in the Divisibility Graph)Order numbers in the sought clique in ascending order. Note that set X = {x1, ..., xk} is a clique iff for (1 ≤ i ≤ k - 1). So, it's easy to formulate a dynamic programming problem: D[x] is equal to the length of a longest suitable increasing subsequence ending in a number x. The calculation formula: for all x in set A.If DP is written in \"forward\" direction then it's easy to estimate the complexity of a solution. In the worst case we'll process transitions.562C - Restoring Map(in mirror: 566E - Restoring Map)Let's call a neighborhood of a vertex — the set consisting of it and all vertices near to it. So, we know the set of all neighborhoods of all vertices in some arbitrary order, and also each neighborhood is shuffled in an arbitrary order.Let's call the tree vertex to be internal if it is not a tree leaf. Similarly, let's call a tree edge to be internal if it connects two internal vertices. An nice observation is that if two neighborhoods intersect exactly by two elements a and b then a and b have to be connected with an edge, in particular the edge (a, b) is internal. Conversely, any internal edge (a, b) may be represented as an intersection of some two neighborhoods С and D of some two vertices c and d such that there is a path c – a – b – d in the tree. In such manner we may find all internal edges by considering pairwise intersections of all neighborhoods. This can be done in about n3 / 2 operations naively, or in 32 times faster, by using bitsets technique.Note that knowing all internal edges we may determine all internal vertices except the only case of a star graph (i. e. the graph consisting of a vertex with several other vertices attached to it). The case of a star should be considered separately.Now we know the set of all leaves, all internal vertices and a tree structure on all internal vertices. The only thing that remained is to determine for each leaf, to what internal vertex is should be attached. This can be done in following manner. Consider a leaf l. Consider all neighborhoods containing it. Consider a minimal neighborhood among them; it can be shown that it is exactly the neighborhood L corresponding to a leaf l itself. Consider all internal vertices in L. There can be no less than two of them. If there are three of them or more then we can uniquely determine to which of them l should be attached — it should be such vertex from them that has a degree inside L larger than 1. If there are exactly two internal vertices in L (let's say, a and b), then determining the attach point for l is a bit harder.Statement: l should be attached to that vertex among a, b, that has an internal degree exactly 1. Indeed, if l was attached to a vertex with internal degree larger than 1, we would have considered this case before.If both of vertices a and b have internal degree — 1 then our graph looks like a dumbbell (an edge (a, b) and all remaining vertices attached either to a or to b). Such case should also be considered separately.The solution for two special cases remains for a reader as an easy exercise.562D - Restructuring Company(in mirror: 566D - Restructuring Company)This problem allows a lot of solution with different time asymptotic. Let's describe a solution in . Let's first consider a problem with only a queries of second and third type. It can be solved in a following manner. Consider a line consisting of all employees from 1 to n. An observation: any department looks like a contiguous segment of workers. Let's keep those segments in any logarithmic data structure like a balanced binary search tree (std::set or TreeSet). When merging departments from x to y, just extract all segments that are in the range [x, y] and merge them. For answering a query of the third type just check if employees x and y belong to the same segment. In such manner we get a solution of an easier problem in per query. When adding the queries of a first type we in fact allow some segments to correspond to the same department. Let's add a DSU for handling equivalence classes of segments. Now the query of the first type is just using merge inside DSU for departments which x and y belong to. Also for queries of the second type it's important not to forget to call merge from all extracted segments.So we get a solution in time.562E - Max and Min(in mirror: 566G - Max and Min)Consider a following geometrical interpretation. Both Max and Min have a set of vectors from the first plane quadrant and a point (x, y). During his turn Max may add any of his vectors to a point (x, y), and Min — may subtract any of his vectors. Min wants point (x, y) to be strictly in the third quadrant, Max tries to prevent his from doing it. Denote Max vectors as Mxi and Min vectors as Mnj.Consider a following obvious sufficient condition for Max to win. Consider some non-negative direction in a plane, i. e. such vector (a, b) that a, b ≥ 0 and at least one of numbers a, b is not a zero. Then if among Max vectors there is such vector Mxi, that it's not shorter than any of Min vectors Mnj along the direction (a, b) then Max can surely win. Here by the length of vector v along a direction (a, b) we mean a scalar product of vector v and vector (a, b). Indeed, let Max always use that vector Mxi. Then during the turns of Max and Min point (x, y) is shifted by a vector Mxi - Mnj for some j, so its overall shift along the vector (a, b) is equal to ((Mxi - Mnj), (a, b)) = (Mxi, (a, b)) - (Mnj, (a, b)) ≥ 0. By observing that initially the scalar produt ((x, y), (a, b)) = ax + by > 0 we see that at any moment ax + by will be strictly positive. This means that Min won't be able at any moment to make x and y both be negative (since it would mean that ax + by < 0).Now let's formulate some kind of converse statement. Suppose Max vector Mxi lies strictly inside the triangle formed by Min vectors Mnj and Mnk. In particular, vector Mxi endpoint can't lie on a segment [Mnj, Mnk], but it may be collinear one of vectors Mnj and Mnk. Note that since Mxi lies strictly inside the triangle formed by vectors Mnj and Mnk it can be extended to a vector Mx'i, whose endpoint lies on a segment [Mnj, Mnk]. By using linear dependence of Mx'i and Mnj, Mnk we have that Mx'i = (p / r)Mnj + (q / r)Mnk, where p + q = r and p, q, r — integer non-negative numbers. This is equivalent to a formula rMx'i = pMnj + qMnk. This means that if per each r turns of Max in Mxi we will respond with p turns of Min in Mnj and q turns of Min in Mnk, then the total shift will be equal to  - pMnj - qMnk + rMxi =  - rMx'i + rMxi =  - r(Mx'i - Mxi), that is the vector with strictly negative components. So, we are able to block that Max turn, i. e. it does not give any advantage to Max.The natural wish is to create a convex hull of all Min turns and to consider all Max turns in respect to it. If Max turn lies inside the convex hull of Min turns, then by using the previous fact this turn is meaningless to Max. Otherwise, there are two possibilities. First, this turn may intersect the hull but go out of it somewhere; in this case this Max turn is no shorter than all Min turns in some non-negative direction (more specifically, in its own direction), so Max wins.On the other hand, Max vector lies to aside from the Min turns convex hull. Let's suppose the vector Mxi lies to the left of the Min turns. This case requires a special analysis. Consider the topmost of the Min vectors Mnj. If Mxi is no lower than Mxj, then by using the first fact Max is able to win by using only this vector. Otherwise the difference Mni - Mxj is a vector with strictly negative components, by using which we are able to block that Max vector.So, the full version of a criteria for Min being a winner looks like the following. Consider a convex hull of Min turns and expand it to the left of the topmost point and to the bottom of the rightmost point. If all Max turns lie strictly inside the formed figure then Min wins, otherwise Max wins.562F - Matching Names(в трансляции: 566A - Matching Names)Form a trie from all names and pseudonyms. Mark with red all vertices corresponding to names, and with blue all vertices corresponding to the pseudonyms (a single vertex may be marked several times, possibly with different colors). Note that if we match a name a and a pseudonym b, then the quality of such match is lcp(a, b) = 1 / 2(2 * lcp(a, b)) = 1 / 2(|a| + |b| - (|a| - lcp(a, b)) - (|b| - lcp(a, b))), that is equal to a constant 1 / 2(|a| + |b|), with subtracted half of a length of a path between a and b over the trie. So, what we need is to connect all red vertices with blue vertices with paths of a minimum possible total length.This can be done with a following greedy procedure: if we have a vertex v with x red vertices and y blue vertices in its subtree then we must match min(x, y) red vertices of its subtree to min(x, y) blue vertices of its subtree and leave the remaining max(x, y) - min(x, y) ref or blue vertices to the level higher. The correctness of such algorithm may be easily shown by the next idea. Give each edge of each path a direction from a red vertex to a blue. If some edge recieves two different directions after this procedure, we may cross-change two paths through it so that their total length is reduced by two.So, we get a solution in O(sumlen) where sumlen is a total length of all names and pseudonyms.562G - Replicating Processes(в трансляции: 566B - Replicating Processes)==== UNTRANSLATED SECTION, PLEASE WAIT A FEW MINUTES... ====Kitten to take your attention :)This problem may be solved by simulating the replication process. Let's keep a list of all replications that may be applied by the current step. Apply an arbitrary replication, after that update a list by adding/removing all suitable or now unsuitable replications touching all affected on current step servers. The list of replications may be kept in a \"double-linked list\" data structure, that allows to add and remove elements to/from the set and to extract an arbitrary element of the set in O(1).The proof of correctness of such algorithm is not hard and is left as an exercies (maybe it will appear here later).We got a solution in O(n) operation (though, the constant hidden by O-notation is pretty large; the input size is already 12n numbers and the solution itself hides a constant 36 or higher).",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 566\\s*B"
          },
          "content_length": 14875
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 1",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 2",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 3",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 4",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000);\n    inf.readEoln();\n\n    vector<int> count_ai(n + 1, 0);\n    vector<int> count_bi_ci(n + 1, 0);\n\n    for (int i = 0; i < 4 * n; i++) {\n        int a_i = inf.readInt(1, n);\n        inf.readSpace();\n        int b_i = inf.readInt(1, n);\n        inf.readSpace();\n        int c_i = inf.readInt(1, n);\n        inf.readEoln();\n\n        count_ai[a_i]++;\n        count_bi_ci[b_i]++;\n        count_bi_ci[c_i]++;\n    }\n\n    for (int s = 1; s <= n; s++) {\n        ensuref(count_ai[s] == 4, \"Server %d occurs %d times in ai, expected 4 times\", s, count_ai[s]);\n        ensuref(count_bi_ci[s] == 8, \"Server %d occurs %d times in bi and ci combined, expected 8 times\", s, count_bi_ci[s]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000);\n    inf.readEoln();\n\n    vector<int> count_ai(n + 1, 0);\n    vector<int> count_bi_ci(n + 1, 0);\n\n    for (int i = 0; i < 4 * n; i++) {\n        int a_i = inf.readInt(1, n);\n        inf.readSpace();\n        int b_i = inf.readInt(1, n);\n        inf.readSpace();\n        int c_i = inf.readInt(1, n);\n        inf.readEoln();\n\n        count_ai[a_i]++;\n        count_bi_ci[b_i]++;\n        count_bi_ci[c_i]++;\n    }\n\n    for (int s = 1; s <= n; s++) {\n        ensuref(count_ai[s] == 4, \"Server %d occurs %d times in ai, expected 4 times\", s, count_ai[s]);\n        ensuref(count_bi_ci[s] == 8, \"Server %d occurs %d times in bi and ci combined, expected 8 times\", s, count_bi_ci[s]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000);\n    inf.readEoln();\n\n    vector<int> count_ai(n + 1, 0);\n    vector<int> count_bi_ci(n + 1, 0);\n\n    for (int i = 0; i < 4 * n; i++) {\n        int a_i = inf.readInt(1, n);\n        inf.readSpace();\n        int b_i = inf.readInt(1, n);\n        inf.readSpace();\n        int c_i = inf.readInt(1, n);\n        inf.readEoln();\n\n        count_ai[a_i]++;\n        count_bi_ci[b_i]++;\n        count_bi_ci[c_i]++;\n    }\n\n    for (int s = 1; s <= n; s++) {\n        ensuref(count_ai[s] == 4, \"Server %d occurs %d times in ai, expected 4 times\", s, count_ai[s]);\n        ensuref(count_bi_ci[s] == 8, \"Server %d occurs %d times in bi and ci combined, expected 8 times\", s, count_bi_ci[s]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 30000);\n\n    vector<tuple<int, int, int>> rules(4 * n);\n\n    for (int i = 0; i < 4 * n; ++i) {\n        int ai = inf.readInt(1, n);\n        int bi = inf.readInt(1, n);\n        int ci = inf.readInt(1, n);\n        rules[i] = make_tuple(ai, bi, ci);\n    }\n\n    string jury_ans = ans.readToken();\n    if (jury_ans != \"YES\" && jury_ans != \"NO\") {\n        ans.quitf(_fail, \"Jury output invalid: expected YES or NO, found '%s'\", jury_ans.c_str());\n    }\n\n    string part_ans = ouf.readToken();\n    if (part_ans != \"YES\" && part_ans != \"NO\") {\n        quitf(_pe, \"Participant output invalid: expected YES or NO, found '%s'\", part_ans.c_str());\n    }\n\n    if (jury_ans == \"NO\") {\n        if (part_ans == \"NO\") {\n            quitf(_ok, \"Both outputs are NO.\");\n        } else {\n            quitf(_wa, \"Participant claimed a sequence exists, but jury says no sequence exists.\");\n        }\n    } else { // jury_ans == \"YES\"\n        if (part_ans == \"NO\") {\n            quitf(_wa, \"Participant failed to find a sequence, but jury has one.\");\n        } else {\n            // Read the participant's sequence\n            vector<int> seq = ouf.readInts(4 * n, 1, 4 * n, \"sequence of rule indices\");\n\n            // Check if the sequence is a permutation of 1 to 4n\n            vector<int> count(4 * n + 1, 0); // from 1 to 4n inclusive\n\n            for (int i = 0; i < 4 * n; ++i) {\n                int idx = seq[i];\n                if (idx < 1 || idx > 4 * n) {\n                    quitf(_wa, \"Invalid index %d at position %d\", idx, i + 1);\n                }\n                count[idx]++;\n                if (count[idx] > 1) {\n                    quitf(_wa, \"Duplicate index %d in sequence\", idx);\n                }\n            }\n\n            // Initialize processes per server\n            vector<int> processes(n + 1, 4); // from 1 to n inclusive; processes[0] unused\n\n            // Simulate the sequence\n            for (int step = 0; step < 4 * n; ++step) {\n                int idx = seq[step];\n                int ai, bi, ci;\n                tie(ai, bi, ci) = rules[idx - 1];\n\n                // Remove process from ai\n                if (processes[ai] <= 0) {\n                    quitf(_wa, \"No process to remove at server %d at step %d\", ai, step + 1);\n                }\n                processes[ai] -= 1;\n\n                // Add process to bi\n                processes[bi] += 1;\n                if (processes[bi] > 9) {\n                    quitf(_wa, \"Too many processes on server %d after step %d\", bi, step + 1);\n                }\n\n                // Add process to ci\n                processes[ci] += 1;\n                if (processes[ci] > 9) {\n                    quitf(_wa, \"Too many processes on server %d after step %d\", ci, step + 1);\n                }\n            }\n            quitf(_ok, \"Correct sequence.\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate a random valid test case\n\n        // Generate ai_list: each server number from 1 to n, repeated 4 times\n        vector<int> ai_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 4; ++j) {\n                ai_list.push_back(i);\n            }\n        }\n        // Shuffle ai_list\n        shuffle(ai_list.begin(), ai_list.end());\n\n        // Generate bc_list: each server number from 1 to n, repeated 8 times\n        vector<int> bc_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 8; ++j) {\n                bc_list.push_back(i);\n            }\n        }\n        // Shuffle bc_list\n        shuffle(bc_list.begin(), bc_list.end());\n\n        // Now assign bi and ci\n        vector<int> bi(4 * n), ci(4 * n);\n        for(int i = 0; i < 4 * n; ++i) {\n            bi[i] = bc_list[2 * i];\n            ci[i] = bc_list[2 * i + 1];\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output the 4n rules\n        for(int i = 0; i < 4 * n; ++i) {\n            printf(\"%d %d %d\\n\", ai_list[i], bi[i], ci[i]);\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate a test case where the answer is \"NO\"\n\n        int s = 1; // The server that will have too many processes\n        int m = 4 * n; // Total number of rules\n\n        vector<int> ai_list;\n        vector<int> bc_list;\n\n        // Generate ai_list\n        // For servers other than s, place their ai's at the start\n        for (int i = 1; i <= n; ++i) {\n            if (i != s) {\n                for (int j = 0; j < 4; ++j) {\n                    ai_list.push_back(i);\n                }\n            }\n        }\n        // Now add ai's for server s at the end\n        for (int j = 0; j < 4; ++j) {\n            ai_list.push_back(s);\n        }\n\n        // Generate bc_list: each server number from 1 to n, repeated 8 times\n        // Let's make sure that server s receives its new processes early\n        vector<int> servers;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                servers.push_back(i);\n            }\n        }\n        // Shuffle servers except for s\n        vector<int> s_servers, other_servers;\n        for (int v : servers) {\n            if (v == s) s_servers.push_back(v);\n            else other_servers.push_back(v);\n        }\n        shuffle(other_servers.begin(), other_servers.end());\n        // Combine s_servers first to force s to receive new processes early\n        bc_list.insert(bc_list.end(), s_servers.begin(), s_servers.end());\n        bc_list.insert(bc_list.end(), other_servers.begin(), other_servers.end());\n\n        // Now assign bi and ci\n        vector<int> bi(4 * n), ci(4 * n);\n        for(int i = 0; i < 4 * n; ++i) {\n            bi[i] = bc_list[2 * i];\n            ci[i] = bc_list[2 * i + 1];\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output the 4n rules\n        for(int i = 0; i < 4 * n; ++i) {\n            printf(\"%d %d %d\\n\", ai_list[i], bi[i], ci[i]);\n        }\n    }\n    else if (type == \"critical\") {\n        // Generate a test case that is solvable but challenging\n\n        // Generate ai_list: each server number from 1 to n, repeated 4 times\n        vector<int> ai_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 4; ++j) {\n                ai_list.push_back(i);\n            }\n        }\n        // Place all ai's of server 1 at the end to create potential bottleneck\n        vector<int> ai_list_head, ai_list_tail;\n        for (int ai : ai_list) {\n            if (ai == 1) {\n                ai_list_tail.push_back(ai);\n            } else {\n                ai_list_head.push_back(ai);\n            }\n        }\n        ai_list.clear();\n        ai_list.insert(ai_list.end(), ai_list_head.begin(), ai_list_head.end());\n        ai_list.insert(ai_list.end(), ai_list_tail.begin(), ai_list_tail.end());\n\n        // Generate bc_list: each server number from 1 to n, repeated 8 times\n        vector<int> bc_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 8; ++j) {\n                bc_list.push_back(i);\n            }\n        }\n        // Shuffle bc_list\n        shuffle(bc_list.begin(), bc_list.end());\n\n        // Now assign bi and ci\n        vector<int> bi(4 * n), ci(4 * n);\n        for(int i = 0; i < 4 * n; ++i) {\n            bi[i] = bc_list[2 * i];\n            ci[i] = bc_list[2 * i + 1];\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output the 4n rules\n        for(int i = 0; i < 4 * n; ++i) {\n            printf(\"%d %d %d\\n\", ai_list[i], bi[i], ci[i]);\n        }\n    }\n    else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate a random valid test case\n\n        // Generate ai_list: each server number from 1 to n, repeated 4 times\n        vector<int> ai_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 4; ++j) {\n                ai_list.push_back(i);\n            }\n        }\n        // Shuffle ai_list\n        shuffle(ai_list.begin(), ai_list.end());\n\n        // Generate bc_list: each server number from 1 to n, repeated 8 times\n        vector<int> bc_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 8; ++j) {\n                bc_list.push_back(i);\n            }\n        }\n        // Shuffle bc_list\n        shuffle(bc_list.begin(), bc_list.end());\n\n        // Now assign bi and ci\n        vector<int> bi(4 * n), ci(4 * n);\n        for(int i = 0; i < 4 * n; ++i) {\n            bi[i] = bc_list[2 * i];\n            ci[i] = bc_list[2 * i + 1];\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output the 4n rules\n        for(int i = 0; i < 4 * n; ++i) {\n            printf(\"%d %d %d\\n\", ai_list[i], bi[i], ci[i]);\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate a test case where the answer is \"NO\"\n\n        int s = 1; // The server that will have too many processes\n        int m = 4 * n; // Total number of rules\n\n        vector<int> ai_list;\n        vector<int> bc_list;\n\n        // Generate ai_list\n        // For servers other than s, place their ai's at the start\n        for (int i = 1; i <= n; ++i) {\n            if (i != s) {\n                for (int j = 0; j < 4; ++j) {\n                    ai_list.push_back(i);\n                }\n            }\n        }\n        // Now add ai's for server s at the end\n        for (int j = 0; j < 4; ++j) {\n            ai_list.push_back(s);\n        }\n\n        // Generate bc_list: each server number from 1 to n, repeated 8 times\n        // Let's make sure that server s receives its new processes early\n        vector<int> servers;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                servers.push_back(i);\n            }\n        }\n        // Shuffle servers except for s\n        vector<int> s_servers, other_servers;\n        for (int v : servers) {\n            if (v == s) s_servers.push_back(v);\n            else other_servers.push_back(v);\n        }\n        shuffle(other_servers.begin(), other_servers.end());\n        // Combine s_servers first to force s to receive new processes early\n        bc_list.insert(bc_list.end(), s_servers.begin(), s_servers.end());\n        bc_list.insert(bc_list.end(), other_servers.begin(), other_servers.end());\n\n        // Now assign bi and ci\n        vector<int> bi(4 * n), ci(4 * n);\n        for(int i = 0; i < 4 * n; ++i) {\n            bi[i] = bc_list[2 * i];\n            ci[i] = bc_list[2 * i + 1];\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output the 4n rules\n        for(int i = 0; i < 4 * n; ++i) {\n            printf(\"%d %d %d\\n\", ai_list[i], bi[i], ci[i]);\n        }\n    }\n    else if (type == \"critical\") {\n        // Generate a test case that is solvable but challenging\n\n        // Generate ai_list: each server number from 1 to n, repeated 4 times\n        vector<int> ai_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 4; ++j) {\n                ai_list.push_back(i);\n            }\n        }\n        // Place all ai's of server 1 at the end to create potential bottleneck\n        vector<int> ai_list_head, ai_list_tail;\n        for (int ai : ai_list) {\n            if (ai == 1) {\n                ai_list_tail.push_back(ai);\n            } else {\n                ai_list_head.push_back(ai);\n            }\n        }\n        ai_list.clear();\n        ai_list.insert(ai_list.end(), ai_list_head.begin(), ai_list_head.end());\n        ai_list.insert(ai_list.end(), ai_list_tail.begin(), ai_list_tail.end());\n\n        // Generate bc_list: each server number from 1 to n, repeated 8 times\n        vector<int> bc_list;\n        for (int i = 1; i <= n; ++i) {\n            for(int j = 0; j < 8; ++j) {\n                bc_list.push_back(i);\n            }\n        }\n        // Shuffle bc_list\n        shuffle(bc_list.begin(), bc_list.end());\n\n        // Now assign bi and ci\n        vector<int> bi(4 * n), ci(4 * n);\n        for(int i = 0; i < 4 * n; ++i) {\n            bi[i] = bc_list[2 * i];\n            ci[i] = bc_list[2 * i + 1];\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output the 4n rules\n        for(int i = 0; i < 4 * n; ++i) {\n            printf(\"%d %d %d\\n\", ai_list[i], bi[i], ci[i]);\n        }\n    }\n    else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random test cases\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n# Medium n, random test cases\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n\n# Large n, random test cases\n./gen -n 10000 -type random\n./gen -n 20000 -type random\n./gen -n 30000 -type random\n\n# Small n, impossible test cases\n./gen -n 2 -type impossible\n./gen -n 5 -type impossible\n./gen -n 10 -type impossible\n\n# Medium n, impossible test cases\n./gen -n 100 -type impossible\n./gen -n 500 -type impossible\n\n# Critical test cases\n./gen -n 2 -type critical\n./gen -n 5 -type critical\n./gen -n 10 -type critical\n./gen -n 100 -type critical\n./gen -n 1000 -type critical\n\n# Edge cases with n = 30000\n./gen -n 30000 -type random\n./gen -n 30000 -type critical\n\n# Test cases to check maximum process load on servers\n./gen -n 5000 -type critical\n./gen -n 10000 -type critical\n\n# Additional random test cases for variety\n./gen -n 250 -type random\n./gen -n 750 -type random\n./gen -n 1500 -type random\n./gen -n 5000 -type random\n./gen -n 15000 -type random\n\n# Test case with minimal n\n./gen -n 1 -type critical\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:39.271940",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "566/C",
      "title": "C. Logistical Questions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains number n (1 ≤ n ≤ 200 000) — the number of cities in the country.The next line contains n integers w1, w2, ..., wn (0 ≤ wi ≤ 108) — the number of finalists living in each city of the country.Next (n - 1) lines contain the descriptions of the railroad, the i-th line contains three integers, ai, bi, li (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ li ≤ 1000).",
      "output_spec": "OutputPrint two numbers — an integer f that is the number of the optimal city to conduct the competition, and the real number c, equal to the minimum total cost of transporting all the finalists to the competition. Your answer will be considered correct if two conditions are fulfilled at the same time:   The absolute or relative error of the printed number c in comparison with the cost of setting up a final in city f doesn't exceed 10 - 6;  Absolute or relative error of the printed number c in comparison to the answer of the jury doesn't exceed 10 - 6. If there are multiple answers, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy53 1 2 6 51 2 32 3 14 3 95 3 1OutputCopy3 192.0InputCopy25 51 2 2OutputCopy1 14.142135623730951000",
      "description": "C. Logistical Questions\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains number n (1 ≤ n ≤ 200 000) — the number of cities in the country.The next line contains n integers w1, w2, ..., wn (0 ≤ wi ≤ 108) — the number of finalists living in each city of the country.Next (n - 1) lines contain the descriptions of the railroad, the i-th line contains three integers, ai, bi, li (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ li ≤ 1000).\n\nOutputPrint two numbers — an integer f that is the number of the optimal city to conduct the competition, and the real number c, equal to the minimum total cost of transporting all the finalists to the competition. Your answer will be considered correct if two conditions are fulfilled at the same time:   The absolute or relative error of the printed number c in comparison with the cost of setting up a final in city f doesn't exceed 10 - 6;  Absolute or relative error of the printed number c in comparison to the answer of the jury doesn't exceed 10 - 6. If there are multiple answers, you are allowed to print any of them.\n\nInputCopy53 1 2 6 51 2 32 3 14 3 95 3 1OutputCopy3 192.0InputCopy25 51 2 2OutputCopy1 14.142135623730951000\n\nInputCopy53 1 2 6 51 2 32 3 14 3 95 3 1\n\nOutputCopy3 192.0\n\nInputCopy25 51 2 2\n\nOutputCopy1 14.142135623730951000\n\nNoteIn the sample test an optimal variant of choosing a city to conduct the finals of the competition is 3. At such choice the cost of conducting is  burles.In the second sample test, whatever city you would choose, you will need to pay for the transport for five participants, so you will need to pay  burles for each one of them.",
      "solutions": [
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces",
          "content": "Thanks everybody for participating. Tasks follow in the order of the original contest (the mirror order is given in the brackets).562A - Logistical Questions(in mirror: 566C - Logistical Questions)Let's think about formal statement of the problem. We are given a tricky definition of a distance on the tre: ρ(a, b) = dist(a, b)1.5. Each vertex has its weight wi. We need to choose a place x for a competition such that the sum of distances from all vertices of the tree with their weights is minimum possible: f(x) = w1ρ(1, x) + w2ρ(x, 2) + ... + wnρ(x, n).Let's understand how function f(x) works. Allow yourself to put point x not only in vertices of the tree, but also in any point inside each edge by naturally expanding the distance definition (for example, the middle of the edge of length 4 km is located 2 km from both ends of this edge).Fact 1. For any path in the tree the function ρ(i, x) is convex. Actually, the function dist(i, x) plot on each path [a, b] looks like the plot of a function abs(x): it first decreases linearly to the minimum: the closes to i point on a segment [a, b], and then increases linearly. Taking a composition with a convex increasing function t1.5, as we can see, we get the convex function on any path in the tree. Here by function on the path we understand usual function of a real variable x that is identified with its location on path x: dist(a, x). So, each of the summands in the definition of f(x) is convex on any path in the tree, so f(x) is also convex on any path in the tree.Let's call convex functions on any path in the tree convex on tree. Let's formulate few facts about convex functions on trees.Fact 2. A convex function on tree can't have two different local minimums. Indeed, otherwise the path between those minimums contradicts the property of being convex on any path in the tree.So, any convex function f(x) on the tree has the only local minimum that coincides with its global minimum.Fact 3. From each vertex v there exists no more than one edge in which direction the function f decreases. Indeed, otherwise the path connecting two edges of function decrease would contradict the definition of a convex function in a point v.Let's call such edge that function decreases along this edge to be a gradient of function f in point x. By using facts 2 and 3 we see that in each vertex there is either a uniquely defined gradient or the vertex is a global minimum.Suppose we are able to efficiently find a gradient direction by using some algorithm for a given vertex v. If our tree was a bamboo then the task would be a usual convex function minimization that is efficiently solved by a binary search, i. e. dichotomy. We need some equivalent of a dichotomy for a tree. What is it?Let's use centroid decmoposition! Indeed, let's take a tree center (i. e. such vertex that sizes of all its subtrees are no larger than n / 2). By using fact 3 we may consider the gradient of f in the center of the tree. First of all, there may be no gradient in this point meaning that we already found an optimum. Otherwise we know that global minimum is located in a subtree in direction of gradient, so all remaining subtrees and the center can be excluded from our consideration. So, by running one gradient calculation we reduced the number of vertices in a considered part of a tree twice.So, in runs of gradient calculation we almost solved the problem. Let's understand where exactly the answer is located. Note that the global optimum will most probably be located inside some edge. It is easy to see that the optimum vertex will be one of the vertices incident to that edge, or more specifically, one of the last two considered vertices by our algorithms. Which exactly can be determined by calculating the exact answer for them and choosing the most optimal among them.Now let's calculate the gradient direction in a vertex v. Fix a subtree ui of a vertex v. Consider a derivative of all summands from that subtree when we move into that subtree. Denote this derivative as deri. Then, as we can see, the derivative of f(x) while moving from x = v in direction of subtree ui is  - der1 - der2 - ... - deri - 1 + deri - deri + 1 - ... - derk where k is a degree of vertex v. So, by running one DFS from vertex v we may calculate all values deri, and so we may find a gradient direction by applying the formula above and considering a direction with negative derivative.Finally, we got a solution in .562B - Clique in the Divisibility Graph(in mirror: 566F - Clique in the Divisibility Graph)Order numbers in the sought clique in ascending order. Note that set X = {x1, ..., xk} is a clique iff for (1 ≤ i ≤ k - 1). So, it's easy to formulate a dynamic programming problem: D[x] is equal to the length of a longest suitable increasing subsequence ending in a number x. The calculation formula: for all x in set A.If DP is written in \"forward\" direction then it's easy to estimate the complexity of a solution. In the worst case we'll process transitions.562C - Restoring Map(in mirror: 566E - Restoring Map)Let's call a neighborhood of a vertex — the set consisting of it and all vertices near to it. So, we know the set of all neighborhoods of all vertices in some arbitrary order, and also each neighborhood is shuffled in an arbitrary order.Let's call the tree vertex to be internal if it is not a tree leaf. Similarly, let's call a tree edge to be internal if it connects two internal vertices. An nice observation is that if two neighborhoods intersect exactly by two elements a and b then a and b have to be connected with an edge, in particular the edge (a, b) is internal. Conversely, any internal edge (a, b) may be represented as an intersection of some two neighborhoods С and D of some two vertices c and d such that there is a path c – a – b – d in the tree. In such manner we may find all internal edges by considering pairwise intersections of all neighborhoods. This can be done in about n3 / 2 operations naively, or in 32 times faster, by using bitsets technique.Note that knowing all internal edges we may determine all internal vertices except the only case of a star graph (i. e. the graph consisting of a vertex with several other vertices attached to it). The case of a star should be considered separately.Now we know the set of all leaves, all internal vertices and a tree structure on all internal vertices. The only thing that remained is to determine for each leaf, to what internal vertex is should be attached. This can be done in following manner. Consider a leaf l. Consider all neighborhoods containing it. Consider a minimal neighborhood among them; it can be shown that it is exactly the neighborhood L corresponding to a leaf l itself. Consider all internal vertices in L. There can be no less than two of them. If there are three of them or more then we can uniquely determine to which of them l should be attached — it should be such vertex from them that has a degree inside L larger than 1. If there are exactly two internal vertices in L (let's say, a and b), then determining the attach point for l is a bit harder.Statement: l should be attached to that vertex among a, b, that has an internal degree exactly 1. Indeed, if l was attached to a vertex with internal degree larger than 1, we would have considered this case before.If both of vertices a and b have internal degree — 1 then our graph looks like a dumbbell (an edge (a, b) and all remaining vertices attached either to a or to b). Such case should also be considered separately.The solution for two special cases remains for a reader as an easy exercise.562D - Restructuring Company(in mirror: 566D - Restructuring Company)This problem allows a lot of solution with different time asymptotic. Let's describe a solution in . Let's first consider a problem with only a queries of second and third type. It can be solved in a following manner. Consider a line consisting of all employees from 1 to n. An observation: any department looks like a contiguous segment of workers. Let's keep those segments in any logarithmic data structure like a balanced binary search tree (std::set or TreeSet). When merging departments from x to y, just extract all segments that are in the range [x, y] and merge them. For answering a query of the third type just check if employees x and y belong to the same segment. In such manner we get a solution of an easier problem in per query. When adding the queries of a first type we in fact allow some segments to correspond to the same department. Let's add a DSU for handling equivalence classes of segments. Now the query of the first type is just using merge inside DSU for departments which x and y belong to. Also for queries of the second type it's important not to forget to call merge from all extracted segments.So we get a solution in time.562E - Max and Min(in mirror: 566G - Max and Min)Consider a following geometrical interpretation. Both Max and Min have a set of vectors from the first plane quadrant and a point (x, y). During his turn Max may add any of his vectors to a point (x, y), and Min — may subtract any of his vectors. Min wants point (x, y) to be strictly in the third quadrant, Max tries to prevent his from doing it. Denote Max vectors as Mxi and Min vectors as Mnj.Consider a following obvious sufficient condition for Max to win. Consider some non-negative direction in a plane, i. e. such vector (a, b) that a, b ≥ 0 and at least one of numbers a, b is not a zero. Then if among Max vectors there is such vector Mxi, that it's not shorter than any of Min vectors Mnj along the direction (a, b) then Max can surely win. Here by the length of vector v along a direction (a, b) we mean a scalar product of vector v and vector (a, b). Indeed, let Max always use that vector Mxi. Then during the turns of Max and Min point (x, y) is shifted by a vector Mxi - Mnj for some j, so its overall shift along the vector (a, b) is equal to ((Mxi - Mnj), (a, b)) = (Mxi, (a, b)) - (Mnj, (a, b)) ≥ 0. By observing that initially the scalar produt ((x, y), (a, b)) = ax + by > 0 we see that at any moment ax + by will be strictly positive. This means that Min won't be able at any moment to make x and y both be negative (since it would mean that ax + by < 0).Now let's formulate some kind of converse statement. Suppose Max vector Mxi lies strictly inside the triangle formed by Min vectors Mnj and Mnk. In particular, vector Mxi endpoint can't lie on a segment [Mnj, Mnk], but it may be collinear one of vectors Mnj and Mnk. Note that since Mxi lies strictly inside the triangle formed by vectors Mnj and Mnk it can be extended to a vector Mx'i, whose endpoint lies on a segment [Mnj, Mnk]. By using linear dependence of Mx'i and Mnj, Mnk we have that Mx'i = (p / r)Mnj + (q / r)Mnk, where p + q = r and p, q, r — integer non-negative numbers. This is equivalent to a formula rMx'i = pMnj + qMnk. This means that if per each r turns of Max in Mxi we will respond with p turns of Min in Mnj and q turns of Min in Mnk, then the total shift will be equal to  - pMnj - qMnk + rMxi =  - rMx'i + rMxi =  - r(Mx'i - Mxi), that is the vector with strictly negative components. So, we are able to block that Max turn, i. e. it does not give any advantage to Max.The natural wish is to create a convex hull of all Min turns and to consider all Max turns in respect to it. If Max turn lies inside the convex hull of Min turns, then by using the previous fact this turn is meaningless to Max. Otherwise, there are two possibilities. First, this turn may intersect the hull but go out of it somewhere; in this case this Max turn is no shorter than all Min turns in some non-negative direction (more specifically, in its own direction), so Max wins.On the other hand, Max vector lies to aside from the Min turns convex hull. Let's suppose the vector Mxi lies to the left of the Min turns. This case requires a special analysis. Consider the topmost of the Min vectors Mnj. If Mxi is no lower than Mxj, then by using the first fact Max is able to win by using only this vector. Otherwise the difference Mni - Mxj is a vector with strictly negative components, by using which we are able to block that Max vector.So, the full version of a criteria for Min being a winner looks like the following. Consider a convex hull of Min turns and expand it to the left of the topmost point and to the bottom of the rightmost point. If all Max turns lie strictly inside the formed figure then Min wins, otherwise Max wins.562F - Matching Names(в трансляции: 566A - Matching Names)Form a trie from all names and pseudonyms. Mark with red all vertices corresponding to names, and with blue all vertices corresponding to the pseudonyms (a single vertex may be marked several times, possibly with different colors). Note that if we match a name a and a pseudonym b, then the quality of such match is lcp(a, b) = 1 / 2(2 * lcp(a, b)) = 1 / 2(|a| + |b| - (|a| - lcp(a, b)) - (|b| - lcp(a, b))), that is equal to a constant 1 / 2(|a| + |b|), with subtracted half of a length of a path between a and b over the trie. So, what we need is to connect all red vertices with blue vertices with paths of a minimum possible total length.This can be done with a following greedy procedure: if we have a vertex v with x red vertices and y blue vertices in its subtree then we must match min(x, y) red vertices of its subtree to min(x, y) blue vertices of its subtree and leave the remaining max(x, y) - min(x, y) ref or blue vertices to the level higher. The correctness of such algorithm may be easily shown by the next idea. Give each edge of each path a direction from a red vertex to a blue. If some edge recieves two different directions after this procedure, we may cross-change two paths through it so that their total length is reduced by two.So, we get a solution in O(sumlen) where sumlen is a total length of all names and pseudonyms.562G - Replicating Processes(в трансляции: 566B - Replicating Processes)==== UNTRANSLATED SECTION, PLEASE WAIT A FEW MINUTES... ====Kitten to take your attention :)This problem may be solved by simulating the replication process. Let's keep a list of all replications that may be applied by the current step. Apply an arbitrary replication, after that update a list by adding/removing all suitable or now unsuitable replications touching all affected on current step servers. The list of replications may be kept in a \"double-linked list\" data structure, that allows to add and remove elements to/from the set and to extract an arbitrary element of the set in O(1).The proof of correctness of such algorithm is not hard and is left as an exercies (maybe it will appear here later).We got a solution in O(n) operation (though, the constant hidden by O-notation is pretty large; the input size is already 12n numbers and the solution itself hides a constant 36 or higher).",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 566\\s*C"
          },
          "content_length": 14875
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 1",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 2",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 3",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 4",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint parent[MAXN];\nint rank_[MAXN];\n\nint find_set(int x) {\n    if (parent[x] != x) {\n        parent[x] = find_set(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_sets(int x, int y) {\n    x = find_set(x);\n    y = find_set(y);\n    if (x == y) return;\n    if (rank_[x] < rank_[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank_[x] == rank_[y]) {\n            rank_[x]++;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 0, 100000000, \"w\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n        rank_[i] = 0;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000, \"li\");\n        inf.readEoln();\n\n        ensuref(a != b, \"ai (%d) and bi (%d) must be different at line %d\", a, b, i + 3);\n\n        int pa = find_set(a);\n        int pb = find_set(b);\n\n        if (pa == pb) {\n            quitf(_fail, \"Graph contains a cycle: edge between %d and %d creates a cycle at line %d\", a, b, i + 3);\n        }\n\n        union_sets(a, b);\n    }\n\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find_set(i) != root) {\n            quitf(_fail, \"Graph is not connected: node %d is not connected to node 1\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint parent[MAXN];\nint rank_[MAXN];\n\nint find_set(int x) {\n    if (parent[x] != x) {\n        parent[x] = find_set(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_sets(int x, int y) {\n    x = find_set(x);\n    y = find_set(y);\n    if (x == y) return;\n    if (rank_[x] < rank_[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank_[x] == rank_[y]) {\n            rank_[x]++;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 0, 100000000, \"w\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n        rank_[i] = 0;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000, \"li\");\n        inf.readEoln();\n\n        ensuref(a != b, \"ai (%d) and bi (%d) must be different at line %d\", a, b, i + 3);\n\n        int pa = find_set(a);\n        int pb = find_set(b);\n\n        if (pa == pb) {\n            quitf(_fail, \"Graph contains a cycle: edge between %d and %d creates a cycle at line %d\", a, b, i + 3);\n        }\n\n        union_sets(a, b);\n    }\n\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find_set(i) != root) {\n            quitf(_fail, \"Graph is not connected: node %d is not connected to node 1\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint parent[MAXN];\nint rank_[MAXN];\n\nint find_set(int x) {\n    if (parent[x] != x) {\n        parent[x] = find_set(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_sets(int x, int y) {\n    x = find_set(x);\n    y = find_set(y);\n    if (x == y) return;\n    if (rank_[x] < rank_[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank_[x] == rank_[y]) {\n            rank_[x]++;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 0, 100000000, \"w\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n        rank_[i] = 0;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000, \"li\");\n        inf.readEoln();\n\n        ensuref(a != b, \"ai (%d) and bi (%d) must be different at line %d\", a, b, i + 3);\n\n        int pa = find_set(a);\n        int pb = find_set(b);\n\n        if (pa == pb) {\n            quitf(_fail, \"Graph contains a cycle: edge between %d and %d creates a cycle at line %d\", a, b, i + 3);\n        }\n\n        union_sets(a, b);\n    }\n\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find_set(i) != root) {\n            quitf(_fail, \"Graph is not connected: node %d is not connected to node 1\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1E-6;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    inf.readEoln();\n    // Read weights, but no need to store them as we don't need to compute anything\n    for (int i = 0; i < n; i++) {\n        inf.readInt();\n        if (i < n - 1) inf.readSpace(); else inf.readEoln();\n    }\n    for (int i = 0; i < n - 1; i++) {\n        inf.readInts(3);\n        inf.readEoln();\n    }\n\n    // Read participant's output\n    int f = ouf.readInt(1, n, \"city f\");\n    double c_participant = ouf.readDouble();\n    // Read jury's answer\n    int f_jury = ans.readInt();\n    double c_jury = ans.readDouble();\n\n    // Check participant's c against jury's c with 1e-6 absolute or relative error\n    if (!doubleCompare(c_participant, c_jury, EPS)) {\n        quitf(_wa, \"c differs. Expected %.10f, found %.10f\", c_jury, c_participant);\n    }\n\n    // Participant's c matches jury's c within allowed error\n    quitf(_ok, \"Correct cost c = %.10f\", c_participant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n    string edge_length_type = opt<string>(\"edge_length_type\", \"random\");\n\n    // Generate parent array p[0..n-1]: p[i] is parent of node i\n    vector<int> p(n);\n\n    if (tree_type == \"chain\") {\n        // Chain: node i connects to node i-1\n        for (int i = 1; i < n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star: nodes 1..n-1 connect to node 0\n        for (int i = 1; i < n; ++i) {\n            p[i] = 0;\n        }\n    } else if (tree_type == \"balanced\") {\n        // Balanced binary tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = (i - 1) / 2;\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        for (int i = 1; i < n; ++i) {\n            int k = rnd.next(1, min(i, 10));\n            p[i] = i - k;\n        }\n    } else {\n        // Random tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n        }\n    }\n\n    // Shuffle the nodes\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i) perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Generate edges\n    vector<tuple<int, int, int>> edges; // edges with (u, v, li)\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i];\n        int v = perm[p[i]];\n\n        // Set edge length li according to edge_length_type\n        int li;\n        if (edge_length_type == \"constant_min\") {\n            li = 1;\n        } else if (edge_length_type == \"constant_max\") {\n            li = 1000;\n        } else {\n            // Random edge lengths\n            li = rnd.next(1, 1000);\n        }\n\n        edges.push_back(make_tuple(u + 1, v + 1, li)); // nodes numbered from 1\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Generate weights wi\n    vector<int> wi(n);\n\n    if (weight_type == \"constant_zero\") {\n        for (int i = 0; i < n; ++i)\n            wi[i] = 0;\n    } else if (weight_type == \"constant_max\") {\n        for (int i = 0; i < n; ++i)\n            wi[i] = 100000000; // 1e8\n    } else if (weight_type == \"one_nonzero\") {\n        int idx = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n            wi[i] = 0;\n        wi[idx] = 100000000; // 1e8\n    } else if (weight_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            wi[perm[i]] = i;\n    } else if (weight_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            wi[perm[i]] = n - i - 1;\n    } else {\n        // Random weights\n        for (int i = 0; i < n; ++i)\n            wi[i] = rnd.next(0, 100000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output weights wi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", wi[i]);\n        if (i < n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Output edges\n    for (auto &e : edges) {\n        int u, v, li;\n        tie(u, v, li) = e;\n        printf(\"%d %d %d\\n\", u, v, li);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n    string edge_length_type = opt<string>(\"edge_length_type\", \"random\");\n\n    // Generate parent array p[0..n-1]: p[i] is parent of node i\n    vector<int> p(n);\n\n    if (tree_type == \"chain\") {\n        // Chain: node i connects to node i-1\n        for (int i = 1; i < n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star: nodes 1..n-1 connect to node 0\n        for (int i = 1; i < n; ++i) {\n            p[i] = 0;\n        }\n    } else if (tree_type == \"balanced\") {\n        // Balanced binary tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = (i - 1) / 2;\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        for (int i = 1; i < n; ++i) {\n            int k = rnd.next(1, min(i, 10));\n            p[i] = i - k;\n        }\n    } else {\n        // Random tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n        }\n    }\n\n    // Shuffle the nodes\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i) perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Generate edges\n    vector<tuple<int, int, int>> edges; // edges with (u, v, li)\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i];\n        int v = perm[p[i]];\n\n        // Set edge length li according to edge_length_type\n        int li;\n        if (edge_length_type == \"constant_min\") {\n            li = 1;\n        } else if (edge_length_type == \"constant_max\") {\n            li = 1000;\n        } else {\n            // Random edge lengths\n            li = rnd.next(1, 1000);\n        }\n\n        edges.push_back(make_tuple(u + 1, v + 1, li)); // nodes numbered from 1\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Generate weights wi\n    vector<int> wi(n);\n\n    if (weight_type == \"constant_zero\") {\n        for (int i = 0; i < n; ++i)\n            wi[i] = 0;\n    } else if (weight_type == \"constant_max\") {\n        for (int i = 0; i < n; ++i)\n            wi[i] = 100000000; // 1e8\n    } else if (weight_type == \"one_nonzero\") {\n        int idx = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n            wi[i] = 0;\n        wi[idx] = 100000000; // 1e8\n    } else if (weight_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            wi[perm[i]] = i;\n    } else if (weight_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            wi[perm[i]] = n - i - 1;\n    } else {\n        // Random weights\n        for (int i = 0; i < n; ++i)\n            wi[i] = rnd.next(0, 100000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output weights wi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", wi[i]);\n        if (i < n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Output edges\n    for (auto &e : edges) {\n        int u, v, li;\n        tie(u, v, li) = e;\n        printf(\"%d %d %d\\n\", u, v, li);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree_type chain -weight_type constant_zero -edge_length_type constant_min\n./gen -n 2 -tree_type chain -weight_type constant_zero -edge_length_type constant_min\n./gen -n 2 -tree_type chain -weight_type constant_max -edge_length_type constant_max\n./gen -n 5 -tree_type chain -weight_type one_nonzero -edge_length_type random\n./gen -n 5 -tree_type star -weight_type constant_zero -edge_length_type random\n./gen -n 5 -tree_type star -weight_type constant_max -edge_length_type constant_min\n./gen -n 5 -tree_type balanced -weight_type increasing -edge_length_type constant_max\n./gen -n 5 -tree_type random -weight_type decreasing -edge_length_type random\n./gen -n 1000 -tree_type chain -weight_type random -edge_length_type random\n./gen -n 1000 -tree_type star -weight_type one_nonzero -edge_length_type random\n./gen -n 1000 -tree_type balanced -weight_type increasing -edge_length_type random\n./gen -n 1000 -tree_type skewed -weight_type decreasing -edge_length_type random\n./gen -n 100000 -tree_type random -weight_type constant_zero -edge_length_type random\n./gen -n 100000 -tree_type random -weight_type one_nonzero -edge_length_type random\n./gen -n 150000 -tree_type random -weight_type random -edge_length_type constant_min\n./gen -n 150000 -tree_type random -weight_type random -edge_length_type constant_max\n./gen -n 200000 -tree_type chain -weight_type random -edge_length_type random\n./gen -n 200000 -tree_type star -weight_type constant_max -edge_length_type constant_max\n./gen -n 200000 -tree_type star -weight_type constant_zero -edge_length_type constant_min\n./gen -n 200000 -tree_type balanced -weight_type increasing -edge_length_type constant_min\n./gen -n 200000 -tree_type skewed -weight_type decreasing -edge_length_type random\n./gen -n 200000 -tree_type random -weight_type random -edge_length_type random\n./gen -n 200000 -tree_type chain -weight_type increasing -edge_length_type constant_min\n./gen -n 200000 -tree_type skewed -weight_type decreasing -edge_length_type constant_max\n./gen -n 200000 -tree_type balanced -weight_type random -edge_length_type random\n./gen -n 200000 -tree_type chain -weight_type constant_max -edge_length_type constant_max\n./gen -n 200000 -tree_type chain -weight_type constant_zero -edge_length_type constant_min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:41.260719",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "566/D",
      "title": "D. Restructuring Company",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and q (1 ≤ n ≤ 200 000, 1 ≤ q ≤ 500 000) — the number of the employees of the company and the number of queries the crisis manager has.Next q lines contain the queries of the crisis manager. Each query looks like type x y, where . If type = 1 or type = 2, then the query represents the decision of a crisis manager about merging departments of the first and second types respectively. If type = 3, then your task is to determine whether employees x and y work at the same department. Note that x can be equal to y in the query of any type.",
      "output_spec": "OutputFor each question of type 3 print \"YES\" or \"NO\" (without the quotes), depending on whether the corresponding people work in the same department.",
      "sample_tests": "ExamplesInputCopy8 63 2 51 2 53 2 52 4 72 1 23 1 7OutputCopyNOYESYES",
      "description": "D. Restructuring Company\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers n and q (1 ≤ n ≤ 200 000, 1 ≤ q ≤ 500 000) — the number of the employees of the company and the number of queries the crisis manager has.Next q lines contain the queries of the crisis manager. Each query looks like type x y, where . If type = 1 or type = 2, then the query represents the decision of a crisis manager about merging departments of the first and second types respectively. If type = 3, then your task is to determine whether employees x and y work at the same department. Note that x can be equal to y in the query of any type.\n\nOutputFor each question of type 3 print \"YES\" or \"NO\" (without the quotes), depending on whether the corresponding people work in the same department.\n\nInputCopy8 63 2 51 2 53 2 52 4 72 1 23 1 7OutputCopyNOYESYES\n\nInputCopy8 63 2 51 2 53 2 52 4 72 1 23 1 7\n\nOutputCopyNOYESYES",
      "solutions": [
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces",
          "content": "Thanks everybody for participating. Tasks follow in the order of the original contest (the mirror order is given in the brackets).562A - Logistical Questions(in mirror: 566C - Logistical Questions)Let's think about formal statement of the problem. We are given a tricky definition of a distance on the tre: ρ(a, b) = dist(a, b)1.5. Each vertex has its weight wi. We need to choose a place x for a competition such that the sum of distances from all vertices of the tree with their weights is minimum possible: f(x) = w1ρ(1, x) + w2ρ(x, 2) + ... + wnρ(x, n).Let's understand how function f(x) works. Allow yourself to put point x not only in vertices of the tree, but also in any point inside each edge by naturally expanding the distance definition (for example, the middle of the edge of length 4 km is located 2 km from both ends of this edge).Fact 1. For any path in the tree the function ρ(i, x) is convex. Actually, the function dist(i, x) plot on each path [a, b] looks like the plot of a function abs(x): it first decreases linearly to the minimum: the closes to i point on a segment [a, b], and then increases linearly. Taking a composition with a convex increasing function t1.5, as we can see, we get the convex function on any path in the tree. Here by function on the path we understand usual function of a real variable x that is identified with its location on path x: dist(a, x). So, each of the summands in the definition of f(x) is convex on any path in the tree, so f(x) is also convex on any path in the tree.Let's call convex functions on any path in the tree convex on tree. Let's formulate few facts about convex functions on trees.Fact 2. A convex function on tree can't have two different local minimums. Indeed, otherwise the path between those minimums contradicts the property of being convex on any path in the tree.So, any convex function f(x) on the tree has the only local minimum that coincides with its global minimum.Fact 3. From each vertex v there exists no more than one edge in which direction the function f decreases. Indeed, otherwise the path connecting two edges of function decrease would contradict the definition of a convex function in a point v.Let's call such edge that function decreases along this edge to be a gradient of function f in point x. By using facts 2 and 3 we see that in each vertex there is either a uniquely defined gradient or the vertex is a global minimum.Suppose we are able to efficiently find a gradient direction by using some algorithm for a given vertex v. If our tree was a bamboo then the task would be a usual convex function minimization that is efficiently solved by a binary search, i. e. dichotomy. We need some equivalent of a dichotomy for a tree. What is it?Let's use centroid decmoposition! Indeed, let's take a tree center (i. e. such vertex that sizes of all its subtrees are no larger than n / 2). By using fact 3 we may consider the gradient of f in the center of the tree. First of all, there may be no gradient in this point meaning that we already found an optimum. Otherwise we know that global minimum is located in a subtree in direction of gradient, so all remaining subtrees and the center can be excluded from our consideration. So, by running one gradient calculation we reduced the number of vertices in a considered part of a tree twice.So, in runs of gradient calculation we almost solved the problem. Let's understand where exactly the answer is located. Note that the global optimum will most probably be located inside some edge. It is easy to see that the optimum vertex will be one of the vertices incident to that edge, or more specifically, one of the last two considered vertices by our algorithms. Which exactly can be determined by calculating the exact answer for them and choosing the most optimal among them.Now let's calculate the gradient direction in a vertex v. Fix a subtree ui of a vertex v. Consider a derivative of all summands from that subtree when we move into that subtree. Denote this derivative as deri. Then, as we can see, the derivative of f(x) while moving from x = v in direction of subtree ui is  - der1 - der2 - ... - deri - 1 + deri - deri + 1 - ... - derk where k is a degree of vertex v. So, by running one DFS from vertex v we may calculate all values deri, and so we may find a gradient direction by applying the formula above and considering a direction with negative derivative.Finally, we got a solution in .562B - Clique in the Divisibility Graph(in mirror: 566F - Clique in the Divisibility Graph)Order numbers in the sought clique in ascending order. Note that set X = {x1, ..., xk} is a clique iff for (1 ≤ i ≤ k - 1). So, it's easy to formulate a dynamic programming problem: D[x] is equal to the length of a longest suitable increasing subsequence ending in a number x. The calculation formula: for all x in set A.If DP is written in \"forward\" direction then it's easy to estimate the complexity of a solution. In the worst case we'll process transitions.562C - Restoring Map(in mirror: 566E - Restoring Map)Let's call a neighborhood of a vertex — the set consisting of it and all vertices near to it. So, we know the set of all neighborhoods of all vertices in some arbitrary order, and also each neighborhood is shuffled in an arbitrary order.Let's call the tree vertex to be internal if it is not a tree leaf. Similarly, let's call a tree edge to be internal if it connects two internal vertices. An nice observation is that if two neighborhoods intersect exactly by two elements a and b then a and b have to be connected with an edge, in particular the edge (a, b) is internal. Conversely, any internal edge (a, b) may be represented as an intersection of some two neighborhoods С and D of some two vertices c and d such that there is a path c – a – b – d in the tree. In such manner we may find all internal edges by considering pairwise intersections of all neighborhoods. This can be done in about n3 / 2 operations naively, or in 32 times faster, by using bitsets technique.Note that knowing all internal edges we may determine all internal vertices except the only case of a star graph (i. e. the graph consisting of a vertex with several other vertices attached to it). The case of a star should be considered separately.Now we know the set of all leaves, all internal vertices and a tree structure on all internal vertices. The only thing that remained is to determine for each leaf, to what internal vertex is should be attached. This can be done in following manner. Consider a leaf l. Consider all neighborhoods containing it. Consider a minimal neighborhood among them; it can be shown that it is exactly the neighborhood L corresponding to a leaf l itself. Consider all internal vertices in L. There can be no less than two of them. If there are three of them or more then we can uniquely determine to which of them l should be attached — it should be such vertex from them that has a degree inside L larger than 1. If there are exactly two internal vertices in L (let's say, a and b), then determining the attach point for l is a bit harder.Statement: l should be attached to that vertex among a, b, that has an internal degree exactly 1. Indeed, if l was attached to a vertex with internal degree larger than 1, we would have considered this case before.If both of vertices a and b have internal degree — 1 then our graph looks like a dumbbell (an edge (a, b) and all remaining vertices attached either to a or to b). Such case should also be considered separately.The solution for two special cases remains for a reader as an easy exercise.562D - Restructuring Company(in mirror: 566D - Restructuring Company)This problem allows a lot of solution with different time asymptotic. Let's describe a solution in . Let's first consider a problem with only a queries of second and third type. It can be solved in a following manner. Consider a line consisting of all employees from 1 to n. An observation: any department looks like a contiguous segment of workers. Let's keep those segments in any logarithmic data structure like a balanced binary search tree (std::set or TreeSet). When merging departments from x to y, just extract all segments that are in the range [x, y] and merge them. For answering a query of the third type just check if employees x and y belong to the same segment. In such manner we get a solution of an easier problem in per query. When adding the queries of a first type we in fact allow some segments to correspond to the same department. Let's add a DSU for handling equivalence classes of segments. Now the query of the first type is just using merge inside DSU for departments which x and y belong to. Also for queries of the second type it's important not to forget to call merge from all extracted segments.So we get a solution in time.562E - Max and Min(in mirror: 566G - Max and Min)Consider a following geometrical interpretation. Both Max and Min have a set of vectors from the first plane quadrant and a point (x, y). During his turn Max may add any of his vectors to a point (x, y), and Min — may subtract any of his vectors. Min wants point (x, y) to be strictly in the third quadrant, Max tries to prevent his from doing it. Denote Max vectors as Mxi and Min vectors as Mnj.Consider a following obvious sufficient condition for Max to win. Consider some non-negative direction in a plane, i. e. such vector (a, b) that a, b ≥ 0 and at least one of numbers a, b is not a zero. Then if among Max vectors there is such vector Mxi, that it's not shorter than any of Min vectors Mnj along the direction (a, b) then Max can surely win. Here by the length of vector v along a direction (a, b) we mean a scalar product of vector v and vector (a, b). Indeed, let Max always use that vector Mxi. Then during the turns of Max and Min point (x, y) is shifted by a vector Mxi - Mnj for some j, so its overall shift along the vector (a, b) is equal to ((Mxi - Mnj), (a, b)) = (Mxi, (a, b)) - (Mnj, (a, b)) ≥ 0. By observing that initially the scalar produt ((x, y), (a, b)) = ax + by > 0 we see that at any moment ax + by will be strictly positive. This means that Min won't be able at any moment to make x and y both be negative (since it would mean that ax + by < 0).Now let's formulate some kind of converse statement. Suppose Max vector Mxi lies strictly inside the triangle formed by Min vectors Mnj and Mnk. In particular, vector Mxi endpoint can't lie on a segment [Mnj, Mnk], but it may be collinear one of vectors Mnj and Mnk. Note that since Mxi lies strictly inside the triangle formed by vectors Mnj and Mnk it can be extended to a vector Mx'i, whose endpoint lies on a segment [Mnj, Mnk]. By using linear dependence of Mx'i and Mnj, Mnk we have that Mx'i = (p / r)Mnj + (q / r)Mnk, where p + q = r and p, q, r — integer non-negative numbers. This is equivalent to a formula rMx'i = pMnj + qMnk. This means that if per each r turns of Max in Mxi we will respond with p turns of Min in Mnj and q turns of Min in Mnk, then the total shift will be equal to  - pMnj - qMnk + rMxi =  - rMx'i + rMxi =  - r(Mx'i - Mxi), that is the vector with strictly negative components. So, we are able to block that Max turn, i. e. it does not give any advantage to Max.The natural wish is to create a convex hull of all Min turns and to consider all Max turns in respect to it. If Max turn lies inside the convex hull of Min turns, then by using the previous fact this turn is meaningless to Max. Otherwise, there are two possibilities. First, this turn may intersect the hull but go out of it somewhere; in this case this Max turn is no shorter than all Min turns in some non-negative direction (more specifically, in its own direction), so Max wins.On the other hand, Max vector lies to aside from the Min turns convex hull. Let's suppose the vector Mxi lies to the left of the Min turns. This case requires a special analysis. Consider the topmost of the Min vectors Mnj. If Mxi is no lower than Mxj, then by using the first fact Max is able to win by using only this vector. Otherwise the difference Mni - Mxj is a vector with strictly negative components, by using which we are able to block that Max vector.So, the full version of a criteria for Min being a winner looks like the following. Consider a convex hull of Min turns and expand it to the left of the topmost point and to the bottom of the rightmost point. If all Max turns lie strictly inside the formed figure then Min wins, otherwise Max wins.562F - Matching Names(в трансляции: 566A - Matching Names)Form a trie from all names and pseudonyms. Mark with red all vertices corresponding to names, and with blue all vertices corresponding to the pseudonyms (a single vertex may be marked several times, possibly with different colors). Note that if we match a name a and a pseudonym b, then the quality of such match is lcp(a, b) = 1 / 2(2 * lcp(a, b)) = 1 / 2(|a| + |b| - (|a| - lcp(a, b)) - (|b| - lcp(a, b))), that is equal to a constant 1 / 2(|a| + |b|), with subtracted half of a length of a path between a and b over the trie. So, what we need is to connect all red vertices with blue vertices with paths of a minimum possible total length.This can be done with a following greedy procedure: if we have a vertex v with x red vertices and y blue vertices in its subtree then we must match min(x, y) red vertices of its subtree to min(x, y) blue vertices of its subtree and leave the remaining max(x, y) - min(x, y) ref or blue vertices to the level higher. The correctness of such algorithm may be easily shown by the next idea. Give each edge of each path a direction from a red vertex to a blue. If some edge recieves two different directions after this procedure, we may cross-change two paths through it so that their total length is reduced by two.So, we get a solution in O(sumlen) where sumlen is a total length of all names and pseudonyms.562G - Replicating Processes(в трансляции: 566B - Replicating Processes)==== UNTRANSLATED SECTION, PLEASE WAIT A FEW MINUTES... ====Kitten to take your attention :)This problem may be solved by simulating the replication process. Let's keep a list of all replications that may be applied by the current step. Apply an arbitrary replication, after that update a list by adding/removing all suitable or now unsuitable replications touching all affected on current step servers. The list of replications may be kept in a \"double-linked list\" data structure, that allows to add and remove elements to/from the set and to extract an arbitrary element of the set in O(1).The proof of correctness of such algorithm is not hard and is left as an exercies (maybe it will appear here later).We got a solution in O(n) operation (though, the constant hidden by O-notation is pretty large; the input size is already 12n numbers and the solution itself hides a constant 36 or higher).",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 566\\s*D"
          },
          "content_length": 14875
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 1",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 2",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 3",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 4",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 3, \"type\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y\");\n        inf.readEoln();\n\n        if (type == 2) {\n            ensuref(x <= y, \"For queries of type 2, x (%d) should be less than or equal to y (%d)\", x, y);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 3, \"type\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y\");\n        inf.readEoln();\n\n        if (type == 2) {\n            ensuref(x <= y, \"For queries of type 2, x (%d) should be less than or equal to y (%d)\", x, y);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 3, \"type\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y\");\n        inf.readEoln();\n\n        if (type == 2) {\n            ensuref(x <= y, \"For queries of type 2, x (%d) should be less than or equal to y (%d)\", x, y);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string mode = opt<string>(\"mode\", \"random\");\n\n    printf(\"%d %d\\n\", n, q);\n\n    vector<tuple<int,int,int>> queries;\n\n    if (mode == \"random\") {\n        // Generate random queries\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            int x, y;\n            if (type == 1 || type == 3) {\n                x = rnd.next(1, n);\n                y = rnd.next(1, n);\n            } else if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n); // Ensure x ≤ y\n            }\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"type1_only\") {\n        // Generate queries with type 1 merges and type 3 queries\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            if (type == 2) type = 1; // Avoid type 2\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"type2_only\") {\n        // Generate queries with type 2 merges and type 3 queries\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(2, 3);\n            int x, y;\n            if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n);\n            } else {\n                x = rnd.next(1, n);\n                y = rnd.next(1, n);\n            }\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"edge_cases\") {\n        // Generate queries focusing on edge cases\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            int x, y;\n            if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n);\n                if (rnd.next(0, 1)) {\n                    // Edge case where x == y\n                    y = x;\n                }\n            } else {\n                if (rnd.next(0, 1)) {\n                    x = y = rnd.next(1, n); // x = y\n                } else {\n                    x = rnd.next(1, n);\n                    y = rnd.next(1, n);\n                }\n            }\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"worst_case\") {\n        // Create worst-case for union-find (linear chain of merges)\n        for (int i = 1; i < n && q > 0; i++, q--) {\n            int type = 1;\n            int x = i;\n            int y = i + 1;\n            queries.emplace_back(type, x, y);\n        }\n        // Add queries between first and last elements\n        while (q > 0) {\n            int type = 3;\n            int x = 1;\n            int y = n;\n            queries.emplace_back(type, x, y);\n            q--;\n        }\n    } else if (mode == \"only_queries\") {\n        // Generate queries only, no merges\n        for (int i = 0; i < q; i++) {\n            int type = 3;\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.emplace_back(type, x, y);\n        }\n    } else {\n        // Default to random if mode is unrecognized\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            int x, y;\n            if (type == 1 || type == 3) {\n                x = rnd.next(1, n);\n                y = rnd.next(1, n);\n            } else if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n); // Ensure x ≤ y\n            }\n            queries.emplace_back(type, x, y);\n        }\n    }\n\n    for (const auto &query : queries) {\n        int type, x, y;\n        std::tie(type, x, y) = query;\n        printf(\"%d %d %d\\n\", type, x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string mode = opt<string>(\"mode\", \"random\");\n\n    printf(\"%d %d\\n\", n, q);\n\n    vector<tuple<int,int,int>> queries;\n\n    if (mode == \"random\") {\n        // Generate random queries\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            int x, y;\n            if (type == 1 || type == 3) {\n                x = rnd.next(1, n);\n                y = rnd.next(1, n);\n            } else if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n); // Ensure x ≤ y\n            }\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"type1_only\") {\n        // Generate queries with type 1 merges and type 3 queries\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            if (type == 2) type = 1; // Avoid type 2\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"type2_only\") {\n        // Generate queries with type 2 merges and type 3 queries\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(2, 3);\n            int x, y;\n            if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n);\n            } else {\n                x = rnd.next(1, n);\n                y = rnd.next(1, n);\n            }\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"edge_cases\") {\n        // Generate queries focusing on edge cases\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            int x, y;\n            if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n);\n                if (rnd.next(0, 1)) {\n                    // Edge case where x == y\n                    y = x;\n                }\n            } else {\n                if (rnd.next(0, 1)) {\n                    x = y = rnd.next(1, n); // x = y\n                } else {\n                    x = rnd.next(1, n);\n                    y = rnd.next(1, n);\n                }\n            }\n            queries.emplace_back(type, x, y);\n        }\n    } else if (mode == \"worst_case\") {\n        // Create worst-case for union-find (linear chain of merges)\n        for (int i = 1; i < n && q > 0; i++, q--) {\n            int type = 1;\n            int x = i;\n            int y = i + 1;\n            queries.emplace_back(type, x, y);\n        }\n        // Add queries between first and last elements\n        while (q > 0) {\n            int type = 3;\n            int x = 1;\n            int y = n;\n            queries.emplace_back(type, x, y);\n            q--;\n        }\n    } else if (mode == \"only_queries\") {\n        // Generate queries only, no merges\n        for (int i = 0; i < q; i++) {\n            int type = 3;\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.emplace_back(type, x, y);\n        }\n    } else {\n        // Default to random if mode is unrecognized\n        for (int i = 0; i < q; i++) {\n            int type = rnd.next(1, 3);\n            int x, y;\n            if (type == 1 || type == 3) {\n                x = rnd.next(1, n);\n                y = rnd.next(1, n);\n            } else if (type == 2) {\n                x = rnd.next(1, n);\n                y = rnd.next(x, n); // Ensure x ≤ y\n            }\n            queries.emplace_back(type, x, y);\n        }\n    }\n\n    for (const auto &query : queries) {\n        int type, x, y;\n        std::tie(type, x, y) = query;\n        printf(\"%d %d %d\\n\", type, x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 1 -q 1 -mode random\n./gen -n 2 -q 3 -mode random\n./gen -n 5 -q 10 -mode random\n./gen -n 10 -q 20 -mode random\n./gen -n 50 -q 100 -mode random\n\n# Medium random test cases\n./gen -n 1000 -q 2000 -mode random\n./gen -n 5000 -q 10000 -mode random\n\n# Large random test cases\n./gen -n 100000 -q 200000 -mode random\n./gen -n 200000 -q 500000 -mode random\n\n# Type1-only test cases\n./gen -n 100000 -q 200000 -mode type1_only\n./gen -n 200000 -q 500000 -mode type1_only\n\n# Type2-only test cases\n./gen -n 100000 -q 200000 -mode type2_only\n./gen -n 200000 -q 500000 -mode type2_only\n\n# Edge cases\n./gen -n 1 -q 1 -mode edge_cases\n./gen -n 100000 -q 200000 -mode edge_cases\n./gen -n 200000 -q 500000 -mode edge_cases\n\n# Worst-case test\n./gen -n 200000 -q 200000 -mode worst_case\n\n# Only queries\n./gen -n 1 -q 1 -mode only_queries\n./gen -n 100000 -q 200000 -mode only_queries\n./gen -n 200000 -q 500000 -mode only_queries\n\n# Mixed modes\n./gen -n 100000 -q 200000 -mode random\n./gen -n 200000 -q 500000 -mode edge_cases\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:43.410766",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "566/E",
      "title": "E. Restoring Map",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 1000) — the number of cities in the country. Next n lines describe the found lists of near cities. Each list starts from number k (1 ≤ k ≤ n), representing the number of cities in the list followed by k city numbers. All numbers in each list are distinct.It is guaranteed that the given information determines at least one possible road map.",
      "output_spec": "OutputPrint n - 1 pairs of numbers representing the roads of the country. The i-th line must contain two integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), showing that there is a road between cities ai and bi.The answer you print must satisfy the description of close cities from the input. You may print the roads of the countries in any order. The cities that are connected by a road may also be printed in any order.If there are multiple good answers, you may print any of them.",
      "sample_tests": "ExamplesInputCopy54 3 2 4 15 5 3 2 4 15 4 2 1 5 34 2 1 4 33 1 4 5OutputCopy1 41 21 34 5InputCopy65 6 1 3 4 25 2 1 3 4 66 3 6 2 5 4 16 6 1 2 5 3 43 5 2 45 3 1 2 4 6OutputCopy2 41 22 32 64 5",
      "description": "E. Restoring Map\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (2 ≤ n ≤ 1000) — the number of cities in the country. Next n lines describe the found lists of near cities. Each list starts from number k (1 ≤ k ≤ n), representing the number of cities in the list followed by k city numbers. All numbers in each list are distinct.It is guaranteed that the given information determines at least one possible road map.\n\nOutputPrint n - 1 pairs of numbers representing the roads of the country. The i-th line must contain two integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), showing that there is a road between cities ai and bi.The answer you print must satisfy the description of close cities from the input. You may print the roads of the countries in any order. The cities that are connected by a road may also be printed in any order.If there are multiple good answers, you may print any of them.\n\nInputCopy54 3 2 4 15 5 3 2 4 15 4 2 1 5 34 2 1 4 33 1 4 5OutputCopy1 41 21 34 5InputCopy65 6 1 3 4 25 2 1 3 4 66 3 6 2 5 4 16 6 1 2 5 3 43 5 2 45 3 1 2 4 6OutputCopy2 41 22 32 64 5\n\nInputCopy54 3 2 4 15 5 3 2 4 15 4 2 1 5 34 2 1 4 33 1 4 5\n\nOutputCopy1 41 21 34 5\n\nInputCopy65 6 1 3 4 25 2 1 3 4 66 3 6 2 5 4 16 6 1 2 5 3 43 5 2 45 3 1 2 4 6\n\nOutputCopy2 41 22 32 64 5",
      "solutions": [
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces",
          "content": "Thanks everybody for participating. Tasks follow in the order of the original contest (the mirror order is given in the brackets).562A - Logistical Questions(in mirror: 566C - Logistical Questions)Let's think about formal statement of the problem. We are given a tricky definition of a distance on the tre: ρ(a, b) = dist(a, b)1.5. Each vertex has its weight wi. We need to choose a place x for a competition such that the sum of distances from all vertices of the tree with their weights is minimum possible: f(x) = w1ρ(1, x) + w2ρ(x, 2) + ... + wnρ(x, n).Let's understand how function f(x) works. Allow yourself to put point x not only in vertices of the tree, but also in any point inside each edge by naturally expanding the distance definition (for example, the middle of the edge of length 4 km is located 2 km from both ends of this edge).Fact 1. For any path in the tree the function ρ(i, x) is convex. Actually, the function dist(i, x) plot on each path [a, b] looks like the plot of a function abs(x): it first decreases linearly to the minimum: the closes to i point on a segment [a, b], and then increases linearly. Taking a composition with a convex increasing function t1.5, as we can see, we get the convex function on any path in the tree. Here by function on the path we understand usual function of a real variable x that is identified with its location on path x: dist(a, x). So, each of the summands in the definition of f(x) is convex on any path in the tree, so f(x) is also convex on any path in the tree.Let's call convex functions on any path in the tree convex on tree. Let's formulate few facts about convex functions on trees.Fact 2. A convex function on tree can't have two different local minimums. Indeed, otherwise the path between those minimums contradicts the property of being convex on any path in the tree.So, any convex function f(x) on the tree has the only local minimum that coincides with its global minimum.Fact 3. From each vertex v there exists no more than one edge in which direction the function f decreases. Indeed, otherwise the path connecting two edges of function decrease would contradict the definition of a convex function in a point v.Let's call such edge that function decreases along this edge to be a gradient of function f in point x. By using facts 2 and 3 we see that in each vertex there is either a uniquely defined gradient or the vertex is a global minimum.Suppose we are able to efficiently find a gradient direction by using some algorithm for a given vertex v. If our tree was a bamboo then the task would be a usual convex function minimization that is efficiently solved by a binary search, i. e. dichotomy. We need some equivalent of a dichotomy for a tree. What is it?Let's use centroid decmoposition! Indeed, let's take a tree center (i. e. such vertex that sizes of all its subtrees are no larger than n / 2). By using fact 3 we may consider the gradient of f in the center of the tree. First of all, there may be no gradient in this point meaning that we already found an optimum. Otherwise we know that global minimum is located in a subtree in direction of gradient, so all remaining subtrees and the center can be excluded from our consideration. So, by running one gradient calculation we reduced the number of vertices in a considered part of a tree twice.So, in runs of gradient calculation we almost solved the problem. Let's understand where exactly the answer is located. Note that the global optimum will most probably be located inside some edge. It is easy to see that the optimum vertex will be one of the vertices incident to that edge, or more specifically, one of the last two considered vertices by our algorithms. Which exactly can be determined by calculating the exact answer for them and choosing the most optimal among them.Now let's calculate the gradient direction in a vertex v. Fix a subtree ui of a vertex v. Consider a derivative of all summands from that subtree when we move into that subtree. Denote this derivative as deri. Then, as we can see, the derivative of f(x) while moving from x = v in direction of subtree ui is  - der1 - der2 - ... - deri - 1 + deri - deri + 1 - ... - derk where k is a degree of vertex v. So, by running one DFS from vertex v we may calculate all values deri, and so we may find a gradient direction by applying the formula above and considering a direction with negative derivative.Finally, we got a solution in .562B - Clique in the Divisibility Graph(in mirror: 566F - Clique in the Divisibility Graph)Order numbers in the sought clique in ascending order. Note that set X = {x1, ..., xk} is a clique iff for (1 ≤ i ≤ k - 1). So, it's easy to formulate a dynamic programming problem: D[x] is equal to the length of a longest suitable increasing subsequence ending in a number x. The calculation formula: for all x in set A.If DP is written in \"forward\" direction then it's easy to estimate the complexity of a solution. In the worst case we'll process transitions.562C - Restoring Map(in mirror: 566E - Restoring Map)Let's call a neighborhood of a vertex — the set consisting of it and all vertices near to it. So, we know the set of all neighborhoods of all vertices in some arbitrary order, and also each neighborhood is shuffled in an arbitrary order.Let's call the tree vertex to be internal if it is not a tree leaf. Similarly, let's call a tree edge to be internal if it connects two internal vertices. An nice observation is that if two neighborhoods intersect exactly by two elements a and b then a and b have to be connected with an edge, in particular the edge (a, b) is internal. Conversely, any internal edge (a, b) may be represented as an intersection of some two neighborhoods С and D of some two vertices c and d such that there is a path c – a – b – d in the tree. In such manner we may find all internal edges by considering pairwise intersections of all neighborhoods. This can be done in about n3 / 2 operations naively, or in 32 times faster, by using bitsets technique.Note that knowing all internal edges we may determine all internal vertices except the only case of a star graph (i. e. the graph consisting of a vertex with several other vertices attached to it). The case of a star should be considered separately.Now we know the set of all leaves, all internal vertices and a tree structure on all internal vertices. The only thing that remained is to determine for each leaf, to what internal vertex is should be attached. This can be done in following manner. Consider a leaf l. Consider all neighborhoods containing it. Consider a minimal neighborhood among them; it can be shown that it is exactly the neighborhood L corresponding to a leaf l itself. Consider all internal vertices in L. There can be no less than two of them. If there are three of them or more then we can uniquely determine to which of them l should be attached — it should be such vertex from them that has a degree inside L larger than 1. If there are exactly two internal vertices in L (let's say, a and b), then determining the attach point for l is a bit harder.Statement: l should be attached to that vertex among a, b, that has an internal degree exactly 1. Indeed, if l was attached to a vertex with internal degree larger than 1, we would have considered this case before.If both of vertices a and b have internal degree — 1 then our graph looks like a dumbbell (an edge (a, b) and all remaining vertices attached either to a or to b). Such case should also be considered separately.The solution for two special cases remains for a reader as an easy exercise.562D - Restructuring Company(in mirror: 566D - Restructuring Company)This problem allows a lot of solution with different time asymptotic. Let's describe a solution in . Let's first consider a problem with only a queries of second and third type. It can be solved in a following manner. Consider a line consisting of all employees from 1 to n. An observation: any department looks like a contiguous segment of workers. Let's keep those segments in any logarithmic data structure like a balanced binary search tree (std::set or TreeSet). When merging departments from x to y, just extract all segments that are in the range [x, y] and merge them. For answering a query of the third type just check if employees x and y belong to the same segment. In such manner we get a solution of an easier problem in per query. When adding the queries of a first type we in fact allow some segments to correspond to the same department. Let's add a DSU for handling equivalence classes of segments. Now the query of the first type is just using merge inside DSU for departments which x and y belong to. Also for queries of the second type it's important not to forget to call merge from all extracted segments.So we get a solution in time.562E - Max and Min(in mirror: 566G - Max and Min)Consider a following geometrical interpretation. Both Max and Min have a set of vectors from the first plane quadrant and a point (x, y). During his turn Max may add any of his vectors to a point (x, y), and Min — may subtract any of his vectors. Min wants point (x, y) to be strictly in the third quadrant, Max tries to prevent his from doing it. Denote Max vectors as Mxi and Min vectors as Mnj.Consider a following obvious sufficient condition for Max to win. Consider some non-negative direction in a plane, i. e. such vector (a, b) that a, b ≥ 0 and at least one of numbers a, b is not a zero. Then if among Max vectors there is such vector Mxi, that it's not shorter than any of Min vectors Mnj along the direction (a, b) then Max can surely win. Here by the length of vector v along a direction (a, b) we mean a scalar product of vector v and vector (a, b). Indeed, let Max always use that vector Mxi. Then during the turns of Max and Min point (x, y) is shifted by a vector Mxi - Mnj for some j, so its overall shift along the vector (a, b) is equal to ((Mxi - Mnj), (a, b)) = (Mxi, (a, b)) - (Mnj, (a, b)) ≥ 0. By observing that initially the scalar produt ((x, y), (a, b)) = ax + by > 0 we see that at any moment ax + by will be strictly positive. This means that Min won't be able at any moment to make x and y both be negative (since it would mean that ax + by < 0).Now let's formulate some kind of converse statement. Suppose Max vector Mxi lies strictly inside the triangle formed by Min vectors Mnj and Mnk. In particular, vector Mxi endpoint can't lie on a segment [Mnj, Mnk], but it may be collinear one of vectors Mnj and Mnk. Note that since Mxi lies strictly inside the triangle formed by vectors Mnj and Mnk it can be extended to a vector Mx'i, whose endpoint lies on a segment [Mnj, Mnk]. By using linear dependence of Mx'i and Mnj, Mnk we have that Mx'i = (p / r)Mnj + (q / r)Mnk, where p + q = r and p, q, r — integer non-negative numbers. This is equivalent to a formula rMx'i = pMnj + qMnk. This means that if per each r turns of Max in Mxi we will respond with p turns of Min in Mnj and q turns of Min in Mnk, then the total shift will be equal to  - pMnj - qMnk + rMxi =  - rMx'i + rMxi =  - r(Mx'i - Mxi), that is the vector with strictly negative components. So, we are able to block that Max turn, i. e. it does not give any advantage to Max.The natural wish is to create a convex hull of all Min turns and to consider all Max turns in respect to it. If Max turn lies inside the convex hull of Min turns, then by using the previous fact this turn is meaningless to Max. Otherwise, there are two possibilities. First, this turn may intersect the hull but go out of it somewhere; in this case this Max turn is no shorter than all Min turns in some non-negative direction (more specifically, in its own direction), so Max wins.On the other hand, Max vector lies to aside from the Min turns convex hull. Let's suppose the vector Mxi lies to the left of the Min turns. This case requires a special analysis. Consider the topmost of the Min vectors Mnj. If Mxi is no lower than Mxj, then by using the first fact Max is able to win by using only this vector. Otherwise the difference Mni - Mxj is a vector with strictly negative components, by using which we are able to block that Max vector.So, the full version of a criteria for Min being a winner looks like the following. Consider a convex hull of Min turns and expand it to the left of the topmost point and to the bottom of the rightmost point. If all Max turns lie strictly inside the formed figure then Min wins, otherwise Max wins.562F - Matching Names(в трансляции: 566A - Matching Names)Form a trie from all names and pseudonyms. Mark with red all vertices corresponding to names, and with blue all vertices corresponding to the pseudonyms (a single vertex may be marked several times, possibly with different colors). Note that if we match a name a and a pseudonym b, then the quality of such match is lcp(a, b) = 1 / 2(2 * lcp(a, b)) = 1 / 2(|a| + |b| - (|a| - lcp(a, b)) - (|b| - lcp(a, b))), that is equal to a constant 1 / 2(|a| + |b|), with subtracted half of a length of a path between a and b over the trie. So, what we need is to connect all red vertices with blue vertices with paths of a minimum possible total length.This can be done with a following greedy procedure: if we have a vertex v with x red vertices and y blue vertices in its subtree then we must match min(x, y) red vertices of its subtree to min(x, y) blue vertices of its subtree and leave the remaining max(x, y) - min(x, y) ref or blue vertices to the level higher. The correctness of such algorithm may be easily shown by the next idea. Give each edge of each path a direction from a red vertex to a blue. If some edge recieves two different directions after this procedure, we may cross-change two paths through it so that their total length is reduced by two.So, we get a solution in O(sumlen) where sumlen is a total length of all names and pseudonyms.562G - Replicating Processes(в трансляции: 566B - Replicating Processes)==== UNTRANSLATED SECTION, PLEASE WAIT A FEW MINUTES... ====Kitten to take your attention :)This problem may be solved by simulating the replication process. Let's keep a list of all replications that may be applied by the current step. Apply an arbitrary replication, after that update a list by adding/removing all suitable or now unsuitable replications touching all affected on current step servers. The list of replications may be kept in a \"double-linked list\" data structure, that allows to add and remove elements to/from the set and to extract an arbitrary element of the set in O(1).The proof of correctness of such algorithm is not hard and is left as an exercies (maybe it will appear here later).We got a solution in O(n) operation (though, the constant hidden by O-notation is pretty large; the input size is already 12n numbers and the solution itself hides a constant 36 or higher).",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 566\\s*E"
          },
          "content_length": 14875
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 1",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 2",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 3",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 4",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int k_i = inf.readInt(1, n, \"k_i\");\n        inf.readSpace();\n        vector<int> nums = inf.readInts(k_i, 1, n);\n        set<int> s(nums.begin(), nums.end());\n        ensuref(s.size() == nums.size(), \"All numbers in each list must be distinct (line %d)\", i+2);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int k_i = inf.readInt(1, n, \"k_i\");\n        inf.readSpace();\n        vector<int> nums = inf.readInts(k_i, 1, n);\n        set<int> s(nums.begin(), nums.end());\n        ensuref(s.size() == nums.size(), \"All numbers in each list must be distinct (line %d)\", i+2);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int k_i = inf.readInt(1, n, \"k_i\");\n        inf.readSpace();\n        vector<int> nums = inf.readInts(k_i, 1, n);\n        set<int> s(nums.begin(), nums.end());\n        ensuref(s.size() == nums.size(), \"All numbers in each list must be distinct (line %d)\", i+2);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<vector<int>> input_lists;\n\nvoid readInputLists() {\n    n = inf.readInt(2, 1000, \"n\");\n    input_lists.resize(n);\n    for (int i = 0; i < n; i++) {\n        int k = inf.readInt(1, n, format(\"k[%d]\", i + 1).c_str());\n        set<int> s;\n        for (int j = 0; j < k; j++) {\n            int city = inf.readInt(1, n, format(\"list[%d][%d]\", i + 1, j + 1).c_str());\n            s.insert(city);\n        }\n        input_lists[i] = vector<int>(s.begin(), s.end());\n        sort(input_lists[i].begin(), input_lists[i].end());\n    }\n}\n\nvector<vector<int>> adj;\n\nvoid readParticipantOutput() {\n    // Read n-1 edges\n    adj.resize(n + 1); // 1-based indexing\n    set<pair<int, int>> edges_set;\n    for (int i = 1; i <= n - 1; i++) {\n        int a = ouf.readInt(1, n, format(\"a[%d]\", i).c_str());\n        int b = ouf.readInt(1, n, format(\"b[%d]\", i).c_str());\n        if (a == b)\n            quitf(_wa, \"Self-loop detected at edge %d between node %d\", i, a);\n        if (edges_set.count({a, b}) || edges_set.count({b, a}))\n            quitf(_wa, \"Duplicate edge between %d and %d\", a, b);\n        edges_set.insert({a, b});\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n}\n\nvector<bool> visited;\n\nbool dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            if (!dfs(v, u))\n                return false;\n        } else if (v != parent) {\n            // Found a cycle\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid validateTree() {\n    visited.assign(n + 1, false);\n    if (!dfs(1, -1))\n        quitf(_wa, \"The graph contains a cycle\");\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i])\n            quitf(_wa, \"The graph is not connected\");\n    }\n}\n\nvector<vector<int>> computeNearCitySets() {\n    vector<vector<int>> near_city_sets(n);\n    for (int u = 1; u <= n; u++) {\n        set<int> near_cities;\n        queue<pair<int, int>> q; // pair of (node, depth)\n        q.push({u, 0});\n        near_cities.insert(u);\n        vector<bool> visited_bfs(n + 1, false);\n        visited_bfs[u] = true;\n        while (!q.empty()) {\n            int curr = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            if (depth == 2)\n                continue;\n            for (int v : adj[curr]) {\n                if (!visited_bfs[v]) {\n                    visited_bfs[v] = true;\n                    near_cities.insert(v);\n                    q.push({v, depth + 1});\n                }\n            }\n        }\n        near_city_sets[u - 1] = vector<int>(near_cities.begin(), near_cities.end());\n        sort(near_city_sets[u - 1].begin(), near_city_sets[u - 1].end());\n    }\n    return near_city_sets;\n}\n\nvoid compareNearCitySets(vector<vector<int>>& computed_sets) {\n    multiset<vector<int>> input_sets(input_lists.begin(), input_lists.end());\n    multiset<vector<int>> output_sets(computed_sets.begin(), computed_sets.end());\n    if (input_sets != output_sets) {\n        quitf(_wa, \"Near city sets do not match\");\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    readInputLists();\n    readParticipantOutput();\n    if (adj.size() != n + 1)\n        quitf(_fail, \"Internal error: adj size incorrect\");\n    validateTree();\n    vector<vector<int>> computed_near_city_sets = computeNearCitySets();\n    compareNearCitySets(computed_near_city_sets);\n    quitf(_ok, \"Accepted\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator produces \"near-city\" lists for the Treeland problem.\n\n   Summary of the problem:\n   - We have n cities (2 ≤ n ≤ 1000) forming a tree (n-1 roads, connected, acyclic).\n   - For each city, we define its \"near set\" as:\n       all cities reachable within at most 2 roads, plus the city itself.\n   - The input to the solution is n lines, each describing such a \"near set\":\n       k city1 city2 ... cityK\n     but all these lines are scrambled (i.e., the i-th input line does NOT necessarily\n     correspond to the i-th city), and the order within each set is also scrambled.\n   - The solution needs to reconstruct any valid tree that is consistent with these sets.\n\n   In this generator, we will:\n   1) Build a tree according to a chosen \"type\".\n      Types implemented: chain, star, double-star, bamboo, random.\n   2) For each node i, compute the set of nodes that are distance ≤ 2 from i.\n   3) We'll collect these sets in a vector, shuffle the entire vector of sets,\n      and shuffle the elements within each set, then output them.\n\n   Usage:\n   ./gen -n <number_of_nodes> -type <chain|star|double-star|bamboo|random>\n\n   Note: We do not set a random seed; the framework testlib does it internally.\n*/\n\nstatic const int MAXN = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    // Possible types: chain, star, double-star, bamboo, random\n    // (default to \"random\" if not provided)\n    string type = opt<string>(\"type\", \"random\");\n\n    /*\n       1) Build the adjacency list of a tree with n nodes (1-indexed).\n    */\n    vector<vector<int>> adj(n+1);\n\n    auto addEdge = [&](int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    };\n\n    if (n < 2) {\n        // The problem statement requires n >= 2. Just exit or handle trivially.\n        // We'll handle it by printing a trivial case if n=1, though the problem says n>=2.\n        // But to be safe, we do nothing for n<2, or we could assert false.\n        // We'll just exit:\n        printf(\"1 1\\n\");\n        return 0;\n    }\n\n    if (type == \"chain\") {\n        // A line (chain): edges (1--2, 2--3, ..., n-1--n)\n        for (int i = 1; i < n; i++) {\n            addEdge(i, i+1);\n        }\n    }\n    else if (type == \"star\") {\n        // A star: edges (1--2, 1--3, ..., 1--n)\n        for (int i = 2; i <= n; i++) {\n            addEdge(1, i);\n        }\n    }\n    else if (type == \"double-star\") {\n        // We'll split the nodes roughly in half between two centers c1 and c2,\n        // and connect each center to its half of the remaining vertices.\n        // Also connect c1--c2.\n        if (n == 2) {\n            // Double-star for n=2 is the same as chain or star\n            addEdge(1, 2);\n        } else {\n            int c1 = 1;\n            int c2 = 2;\n            addEdge(c1, c2);\n            // Connect half of {3..n} to c1, and the other half to c2\n            // (just for variety, will be a \"double star\").\n            for (int v = 3; v <= n; v++) {\n                if ((v % 2) == 1) addEdge(c1, v);\n                else addEdge(c2, v);\n            }\n        }\n    }\n    else if (type == \"bamboo\") {\n        /*\n          We'll form a \"bamboo\":\n          - It's basically a chain, but every other node might have a small side branch.\n          For i from 1..(n-1), connect i--i+1 (the main chain).\n          Then for every few nodes, attach an extra leaf to it.\n        */\n        // main chain\n        for (int i = 1; i < n; i++) {\n            addEdge(i, i+1);\n        }\n        // for every 2nd node in [1..n], attach a leaf if possible\n        // (just skip if we run out of nodes)\n        // This won't exceed n edges, it just reuses existing nodes as leaves? We can't do that.\n        // Instead, let's do something simpler: attach a leaf from 1 to 2 if n>2, from 3 to 4, etc.\n        // But that might create duplicates. Let's not overcomplicate. We'll do a chain only.\n        // We'll add one \"extra\" random edge from a node i to i+2 if possible, just for shape.\n        // But that could break the tree property if not careful. We won't do that.\n        // So effectively bamboo is just a chain but we keep it as a distinct type for coverage.\n        // We'll do no further edges so as not to risk cycles. It's a chain. \n        // This is basically a chain but identified differently for coverage.\n    }\n    else { \n        // default: \"random\" type\n        // We'll build a random tree by hooking up each node i (2..n) to a random node in [1..i-1].\n        for (int i = 2; i <= n; i++) {\n            int p = rnd.next(1, i-1);\n            addEdge(p, i);\n        }\n    }\n\n    /*\n       2) For each node i, compute the set of nodes that are distance ≤ 2 from i.\n          We'll do this by: nearSet[i] = { i } union neighbors(i) union neighbors-of-neighbors(i).\n    */\n    vector<vector<int>> nearSets(n+1);\n    for (int i = 1; i <= n; i++) {\n        // use a set to avoid duplicates\n        unordered_set<int> st;\n        // add i itself\n        st.insert(i);\n        // add neighbors\n        for (int nb: adj[i]) {\n            st.insert(nb);\n            // add neighbors of nb\n            for (int nb2: adj[nb]) {\n                st.insert(nb2);\n            }\n        }\n        // convert set to nearSets[i]\n        nearSets[i].reserve(st.size());\n        for (auto &val: st) {\n            nearSets[i].push_back(val);\n        }\n    }\n\n    /*\n       3) We now have nearSets[i] for i = 1..n.\n\n       But the problem statement says the lines (the near sets) are \"scrambled\".\n       That means:\n         - We should shuffle the entire list of near sets (so the i-th printed line\n           doesn't necessarily correspond to city i).\n         - We should also shuffle the elements within each near set, to hide the order.\n    */\n\n    // Convert nearSets to an array of lines for convenience\n    // We'll index from 0..n-1 for the lines array\n    vector<vector<int>> lines;\n    lines.reserve(n);\n    for (int i = 1; i <= n; i++) {\n        // shuffle the near set of city i\n        shuffle(nearSets[i].begin(), nearSets[i].end());\n        lines.push_back(nearSets[i]);\n    }\n\n    // shuffle the lines themselves\n    shuffle(lines.begin(), lines.end());\n\n    /*\n       4) Output the data.\n\n       Format:\n         n\n         for each of the n lines:\n             k city1 city2 ... cityK\n       where k is the size of the near set, and cities are distinct.\n    */\n\n    // Print n\n    printf(\"%d\\n\", n);\n\n    // Print each line\n    for (int i = 0; i < n; i++) {\n        int k = (int)lines[i].size();\n        printf(\"%d\", k);\n        for (int x: lines[i]) {\n            printf(\" %d\", x);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator produces \"near-city\" lists for the Treeland problem.\n\n   Summary of the problem:\n   - We have n cities (2 ≤ n ≤ 1000) forming a tree (n-1 roads, connected, acyclic).\n   - For each city, we define its \"near set\" as:\n       all cities reachable within at most 2 roads, plus the city itself.\n   - The input to the solution is n lines, each describing such a \"near set\":\n       k city1 city2 ... cityK\n     but all these lines are scrambled (i.e., the i-th input line does NOT necessarily\n     correspond to the i-th city), and the order within each set is also scrambled.\n   - The solution needs to reconstruct any valid tree that is consistent with these sets.\n\n   In this generator, we will:\n   1) Build a tree according to a chosen \"type\".\n      Types implemented: chain, star, double-star, bamboo, random.\n   2) For each node i, compute the set of nodes that are distance ≤ 2 from i.\n   3) We'll collect these sets in a vector, shuffle the entire vector of sets,\n      and shuffle the elements within each set, then output them.\n\n   Usage:\n   ./gen -n <number_of_nodes> -type <chain|star|double-star|bamboo|random>\n\n   Note: We do not set a random seed; the framework testlib does it internally.\n*/\n\nstatic const int MAXN = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    // Possible types: chain, star, double-star, bamboo, random\n    // (default to \"random\" if not provided)\n    string type = opt<string>(\"type\", \"random\");\n\n    /*\n       1) Build the adjacency list of a tree with n nodes (1-indexed).\n    */\n    vector<vector<int>> adj(n+1);\n\n    auto addEdge = [&](int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    };\n\n    if (n < 2) {\n        // The problem statement requires n >= 2. Just exit or handle trivially.\n        // We'll handle it by printing a trivial case if n=1, though the problem says n>=2.\n        // But to be safe, we do nothing for n<2, or we could assert false.\n        // We'll just exit:\n        printf(\"1 1\\n\");\n        return 0;\n    }\n\n    if (type == \"chain\") {\n        // A line (chain): edges (1--2, 2--3, ..., n-1--n)\n        for (int i = 1; i < n; i++) {\n            addEdge(i, i+1);\n        }\n    }\n    else if (type == \"star\") {\n        // A star: edges (1--2, 1--3, ..., 1--n)\n        for (int i = 2; i <= n; i++) {\n            addEdge(1, i);\n        }\n    }\n    else if (type == \"double-star\") {\n        // We'll split the nodes roughly in half between two centers c1 and c2,\n        // and connect each center to its half of the remaining vertices.\n        // Also connect c1--c2.\n        if (n == 2) {\n            // Double-star for n=2 is the same as chain or star\n            addEdge(1, 2);\n        } else {\n            int c1 = 1;\n            int c2 = 2;\n            addEdge(c1, c2);\n            // Connect half of {3..n} to c1, and the other half to c2\n            // (just for variety, will be a \"double star\").\n            for (int v = 3; v <= n; v++) {\n                if ((v % 2) == 1) addEdge(c1, v);\n                else addEdge(c2, v);\n            }\n        }\n    }\n    else if (type == \"bamboo\") {\n        /*\n          We'll form a \"bamboo\":\n          - It's basically a chain, but every other node might have a small side branch.\n          For i from 1..(n-1), connect i--i+1 (the main chain).\n          Then for every few nodes, attach an extra leaf to it.\n        */\n        // main chain\n        for (int i = 1; i < n; i++) {\n            addEdge(i, i+1);\n        }\n        // for every 2nd node in [1..n], attach a leaf if possible\n        // (just skip if we run out of nodes)\n        // This won't exceed n edges, it just reuses existing nodes as leaves? We can't do that.\n        // Instead, let's do something simpler: attach a leaf from 1 to 2 if n>2, from 3 to 4, etc.\n        // But that might create duplicates. Let's not overcomplicate. We'll do a chain only.\n        // We'll add one \"extra\" random edge from a node i to i+2 if possible, just for shape.\n        // But that could break the tree property if not careful. We won't do that.\n        // So effectively bamboo is just a chain but we keep it as a distinct type for coverage.\n        // We'll do no further edges so as not to risk cycles. It's a chain. \n        // This is basically a chain but identified differently for coverage.\n    }\n    else { \n        // default: \"random\" type\n        // We'll build a random tree by hooking up each node i (2..n) to a random node in [1..i-1].\n        for (int i = 2; i <= n; i++) {\n            int p = rnd.next(1, i-1);\n            addEdge(p, i);\n        }\n    }\n\n    /*\n       2) For each node i, compute the set of nodes that are distance ≤ 2 from i.\n          We'll do this by: nearSet[i] = { i } union neighbors(i) union neighbors-of-neighbors(i).\n    */\n    vector<vector<int>> nearSets(n+1);\n    for (int i = 1; i <= n; i++) {\n        // use a set to avoid duplicates\n        unordered_set<int> st;\n        // add i itself\n        st.insert(i);\n        // add neighbors\n        for (int nb: adj[i]) {\n            st.insert(nb);\n            // add neighbors of nb\n            for (int nb2: adj[nb]) {\n                st.insert(nb2);\n            }\n        }\n        // convert set to nearSets[i]\n        nearSets[i].reserve(st.size());\n        for (auto &val: st) {\n            nearSets[i].push_back(val);\n        }\n    }\n\n    /*\n       3) We now have nearSets[i] for i = 1..n.\n\n       But the problem statement says the lines (the near sets) are \"scrambled\".\n       That means:\n         - We should shuffle the entire list of near sets (so the i-th printed line\n           doesn't necessarily correspond to city i).\n         - We should also shuffle the elements within each near set, to hide the order.\n    */\n\n    // Convert nearSets to an array of lines for convenience\n    // We'll index from 0..n-1 for the lines array\n    vector<vector<int>> lines;\n    lines.reserve(n);\n    for (int i = 1; i <= n; i++) {\n        // shuffle the near set of city i\n        shuffle(nearSets[i].begin(), nearSets[i].end());\n        lines.push_back(nearSets[i]);\n    }\n\n    // shuffle the lines themselves\n    shuffle(lines.begin(), lines.end());\n\n    /*\n       4) Output the data.\n\n       Format:\n         n\n         for each of the n lines:\n             k city1 city2 ... cityK\n       where k is the size of the near set, and cities are distinct.\n    */\n\n    // Print n\n    printf(\"%d\\n\", n);\n\n    // Print each line\n    for (int i = 0; i < n; i++) {\n        int k = (int)lines[i].size();\n        printf(\"%d\", k);\n        for (int x: lines[i]) {\n            printf(\" %d\", x);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n\n./gen -n 3 -type chain\n./gen -n 3 -type star\n\n./gen -n 4 -type chain\n./gen -n 4 -type star\n\n./gen -n 5 -type random\n./gen -n 6 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type double-star\n./gen -n 10 -type bamboo\n./gen -n 10 -type random\n\n./gen -n 50 -type chain\n./gen -n 50 -type random\n\n./gen -n 200 -type star\n./gen -n 200 -type random\n\n./gen -n 500 -type double-star\n./gen -n 999 -type bamboo\n\n./gen -n 1000 -type star\n./gen -n 1000 -type random\n./gen -n 1000 -type double-star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:45.390425",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "566/F",
      "title": "F. Clique in the Divisibility Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106), that sets the size of set A.The second line contains n distinct positive integers a1, a2, ..., an (1 ≤ ai ≤ 106) — elements of subset A. The numbers in the line follow in the ascending order.",
      "output_spec": "OutputPrint a single number — the maximum size of a clique in a divisibility graph for set A.",
      "sample_tests": "ExamplesInputCopy83 4 6 8 10 18 21 24OutputCopy3",
      "description": "F. Clique in the Divisibility Graph\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 106), that sets the size of set A.The second line contains n distinct positive integers a1, a2, ..., an (1 ≤ ai ≤ 106) — elements of subset A. The numbers in the line follow in the ascending order.\n\nOutputPrint a single number — the maximum size of a clique in a divisibility graph for set A.\n\nInputCopy83 4 6 8 10 18 21 24OutputCopy3\n\nInputCopy83 4 6 8 10 18 21 24\n\nOutputCopy3\n\nNoteIn the first sample test a clique of size 3 is, for example, a subset of vertexes {3, 6, 18}. A clique of a larger size doesn't exist in this graph.",
      "solutions": [
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces",
          "content": "Thanks everybody for participating. Tasks follow in the order of the original contest (the mirror order is given in the brackets).562A - Logistical Questions(in mirror: 566C - Logistical Questions)Let's think about formal statement of the problem. We are given a tricky definition of a distance on the tre: ρ(a, b) = dist(a, b)1.5. Each vertex has its weight wi. We need to choose a place x for a competition such that the sum of distances from all vertices of the tree with their weights is minimum possible: f(x) = w1ρ(1, x) + w2ρ(x, 2) + ... + wnρ(x, n).Let's understand how function f(x) works. Allow yourself to put point x not only in vertices of the tree, but also in any point inside each edge by naturally expanding the distance definition (for example, the middle of the edge of length 4 km is located 2 km from both ends of this edge).Fact 1. For any path in the tree the function ρ(i, x) is convex. Actually, the function dist(i, x) plot on each path [a, b] looks like the plot of a function abs(x): it first decreases linearly to the minimum: the closes to i point on a segment [a, b], and then increases linearly. Taking a composition with a convex increasing function t1.5, as we can see, we get the convex function on any path in the tree. Here by function on the path we understand usual function of a real variable x that is identified with its location on path x: dist(a, x). So, each of the summands in the definition of f(x) is convex on any path in the tree, so f(x) is also convex on any path in the tree.Let's call convex functions on any path in the tree convex on tree. Let's formulate few facts about convex functions on trees.Fact 2. A convex function on tree can't have two different local minimums. Indeed, otherwise the path between those minimums contradicts the property of being convex on any path in the tree.So, any convex function f(x) on the tree has the only local minimum that coincides with its global minimum.Fact 3. From each vertex v there exists no more than one edge in which direction the function f decreases. Indeed, otherwise the path connecting two edges of function decrease would contradict the definition of a convex function in a point v.Let's call such edge that function decreases along this edge to be a gradient of function f in point x. By using facts 2 and 3 we see that in each vertex there is either a uniquely defined gradient or the vertex is a global minimum.Suppose we are able to efficiently find a gradient direction by using some algorithm for a given vertex v. If our tree was a bamboo then the task would be a usual convex function minimization that is efficiently solved by a binary search, i. e. dichotomy. We need some equivalent of a dichotomy for a tree. What is it?Let's use centroid decmoposition! Indeed, let's take a tree center (i. e. such vertex that sizes of all its subtrees are no larger than n / 2). By using fact 3 we may consider the gradient of f in the center of the tree. First of all, there may be no gradient in this point meaning that we already found an optimum. Otherwise we know that global minimum is located in a subtree in direction of gradient, so all remaining subtrees and the center can be excluded from our consideration. So, by running one gradient calculation we reduced the number of vertices in a considered part of a tree twice.So, in runs of gradient calculation we almost solved the problem. Let's understand where exactly the answer is located. Note that the global optimum will most probably be located inside some edge. It is easy to see that the optimum vertex will be one of the vertices incident to that edge, or more specifically, one of the last two considered vertices by our algorithms. Which exactly can be determined by calculating the exact answer for them and choosing the most optimal among them.Now let's calculate the gradient direction in a vertex v. Fix a subtree ui of a vertex v. Consider a derivative of all summands from that subtree when we move into that subtree. Denote this derivative as deri. Then, as we can see, the derivative of f(x) while moving from x = v in direction of subtree ui is  - der1 - der2 - ... - deri - 1 + deri - deri + 1 - ... - derk where k is a degree of vertex v. So, by running one DFS from vertex v we may calculate all values deri, and so we may find a gradient direction by applying the formula above and considering a direction with negative derivative.Finally, we got a solution in .562B - Clique in the Divisibility Graph(in mirror: 566F - Clique in the Divisibility Graph)Order numbers in the sought clique in ascending order. Note that set X = {x1, ..., xk} is a clique iff for (1 ≤ i ≤ k - 1). So, it's easy to formulate a dynamic programming problem: D[x] is equal to the length of a longest suitable increasing subsequence ending in a number x. The calculation formula: for all x in set A.If DP is written in \"forward\" direction then it's easy to estimate the complexity of a solution. In the worst case we'll process transitions.562C - Restoring Map(in mirror: 566E - Restoring Map)Let's call a neighborhood of a vertex — the set consisting of it and all vertices near to it. So, we know the set of all neighborhoods of all vertices in some arbitrary order, and also each neighborhood is shuffled in an arbitrary order.Let's call the tree vertex to be internal if it is not a tree leaf. Similarly, let's call a tree edge to be internal if it connects two internal vertices. An nice observation is that if two neighborhoods intersect exactly by two elements a and b then a and b have to be connected with an edge, in particular the edge (a, b) is internal. Conversely, any internal edge (a, b) may be represented as an intersection of some two neighborhoods С and D of some two vertices c and d such that there is a path c – a – b – d in the tree. In such manner we may find all internal edges by considering pairwise intersections of all neighborhoods. This can be done in about n3 / 2 operations naively, or in 32 times faster, by using bitsets technique.Note that knowing all internal edges we may determine all internal vertices except the only case of a star graph (i. e. the graph consisting of a vertex with several other vertices attached to it). The case of a star should be considered separately.Now we know the set of all leaves, all internal vertices and a tree structure on all internal vertices. The only thing that remained is to determine for each leaf, to what internal vertex is should be attached. This can be done in following manner. Consider a leaf l. Consider all neighborhoods containing it. Consider a minimal neighborhood among them; it can be shown that it is exactly the neighborhood L corresponding to a leaf l itself. Consider all internal vertices in L. There can be no less than two of them. If there are three of them or more then we can uniquely determine to which of them l should be attached — it should be such vertex from them that has a degree inside L larger than 1. If there are exactly two internal vertices in L (let's say, a and b), then determining the attach point for l is a bit harder.Statement: l should be attached to that vertex among a, b, that has an internal degree exactly 1. Indeed, if l was attached to a vertex with internal degree larger than 1, we would have considered this case before.If both of vertices a and b have internal degree — 1 then our graph looks like a dumbbell (an edge (a, b) and all remaining vertices attached either to a or to b). Such case should also be considered separately.The solution for two special cases remains for a reader as an easy exercise.562D - Restructuring Company(in mirror: 566D - Restructuring Company)This problem allows a lot of solution with different time asymptotic. Let's describe a solution in . Let's first consider a problem with only a queries of second and third type. It can be solved in a following manner. Consider a line consisting of all employees from 1 to n. An observation: any department looks like a contiguous segment of workers. Let's keep those segments in any logarithmic data structure like a balanced binary search tree (std::set or TreeSet). When merging departments from x to y, just extract all segments that are in the range [x, y] and merge them. For answering a query of the third type just check if employees x and y belong to the same segment. In such manner we get a solution of an easier problem in per query. When adding the queries of a first type we in fact allow some segments to correspond to the same department. Let's add a DSU for handling equivalence classes of segments. Now the query of the first type is just using merge inside DSU for departments which x and y belong to. Also for queries of the second type it's important not to forget to call merge from all extracted segments.So we get a solution in time.562E - Max and Min(in mirror: 566G - Max and Min)Consider a following geometrical interpretation. Both Max and Min have a set of vectors from the first plane quadrant and a point (x, y). During his turn Max may add any of his vectors to a point (x, y), and Min — may subtract any of his vectors. Min wants point (x, y) to be strictly in the third quadrant, Max tries to prevent his from doing it. Denote Max vectors as Mxi and Min vectors as Mnj.Consider a following obvious sufficient condition for Max to win. Consider some non-negative direction in a plane, i. e. such vector (a, b) that a, b ≥ 0 and at least one of numbers a, b is not a zero. Then if among Max vectors there is such vector Mxi, that it's not shorter than any of Min vectors Mnj along the direction (a, b) then Max can surely win. Here by the length of vector v along a direction (a, b) we mean a scalar product of vector v and vector (a, b). Indeed, let Max always use that vector Mxi. Then during the turns of Max and Min point (x, y) is shifted by a vector Mxi - Mnj for some j, so its overall shift along the vector (a, b) is equal to ((Mxi - Mnj), (a, b)) = (Mxi, (a, b)) - (Mnj, (a, b)) ≥ 0. By observing that initially the scalar produt ((x, y), (a, b)) = ax + by > 0 we see that at any moment ax + by will be strictly positive. This means that Min won't be able at any moment to make x and y both be negative (since it would mean that ax + by < 0).Now let's formulate some kind of converse statement. Suppose Max vector Mxi lies strictly inside the triangle formed by Min vectors Mnj and Mnk. In particular, vector Mxi endpoint can't lie on a segment [Mnj, Mnk], but it may be collinear one of vectors Mnj and Mnk. Note that since Mxi lies strictly inside the triangle formed by vectors Mnj and Mnk it can be extended to a vector Mx'i, whose endpoint lies on a segment [Mnj, Mnk]. By using linear dependence of Mx'i and Mnj, Mnk we have that Mx'i = (p / r)Mnj + (q / r)Mnk, where p + q = r and p, q, r — integer non-negative numbers. This is equivalent to a formula rMx'i = pMnj + qMnk. This means that if per each r turns of Max in Mxi we will respond with p turns of Min in Mnj and q turns of Min in Mnk, then the total shift will be equal to  - pMnj - qMnk + rMxi =  - rMx'i + rMxi =  - r(Mx'i - Mxi), that is the vector with strictly negative components. So, we are able to block that Max turn, i. e. it does not give any advantage to Max.The natural wish is to create a convex hull of all Min turns and to consider all Max turns in respect to it. If Max turn lies inside the convex hull of Min turns, then by using the previous fact this turn is meaningless to Max. Otherwise, there are two possibilities. First, this turn may intersect the hull but go out of it somewhere; in this case this Max turn is no shorter than all Min turns in some non-negative direction (more specifically, in its own direction), so Max wins.On the other hand, Max vector lies to aside from the Min turns convex hull. Let's suppose the vector Mxi lies to the left of the Min turns. This case requires a special analysis. Consider the topmost of the Min vectors Mnj. If Mxi is no lower than Mxj, then by using the first fact Max is able to win by using only this vector. Otherwise the difference Mni - Mxj is a vector with strictly negative components, by using which we are able to block that Max vector.So, the full version of a criteria for Min being a winner looks like the following. Consider a convex hull of Min turns and expand it to the left of the topmost point and to the bottom of the rightmost point. If all Max turns lie strictly inside the formed figure then Min wins, otherwise Max wins.562F - Matching Names(в трансляции: 566A - Matching Names)Form a trie from all names and pseudonyms. Mark with red all vertices corresponding to names, and with blue all vertices corresponding to the pseudonyms (a single vertex may be marked several times, possibly with different colors). Note that if we match a name a and a pseudonym b, then the quality of such match is lcp(a, b) = 1 / 2(2 * lcp(a, b)) = 1 / 2(|a| + |b| - (|a| - lcp(a, b)) - (|b| - lcp(a, b))), that is equal to a constant 1 / 2(|a| + |b|), with subtracted half of a length of a path between a and b over the trie. So, what we need is to connect all red vertices with blue vertices with paths of a minimum possible total length.This can be done with a following greedy procedure: if we have a vertex v with x red vertices and y blue vertices in its subtree then we must match min(x, y) red vertices of its subtree to min(x, y) blue vertices of its subtree and leave the remaining max(x, y) - min(x, y) ref or blue vertices to the level higher. The correctness of such algorithm may be easily shown by the next idea. Give each edge of each path a direction from a red vertex to a blue. If some edge recieves two different directions after this procedure, we may cross-change two paths through it so that their total length is reduced by two.So, we get a solution in O(sumlen) where sumlen is a total length of all names and pseudonyms.562G - Replicating Processes(в трансляции: 566B - Replicating Processes)==== UNTRANSLATED SECTION, PLEASE WAIT A FEW MINUTES... ====Kitten to take your attention :)This problem may be solved by simulating the replication process. Let's keep a list of all replications that may be applied by the current step. Apply an arbitrary replication, after that update a list by adding/removing all suitable or now unsuitable replications touching all affected on current step servers. The list of replications may be kept in a \"double-linked list\" data structure, that allows to add and remove elements to/from the set and to extract an arbitrary element of the set in O(1).The proof of correctness of such algorithm is not hard and is left as an exercies (maybe it will appear here later).We got a solution in O(n) operation (though, the constant hidden by O-notation is pretty large; the input size is already 12n numbers and the solution itself hides a constant 36 or higher).",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 566\\s*F"
          },
          "content_length": 14875
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 1",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 2",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 3",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 4",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1],\n            \"Integers are not in ascending order at position %d: a[%d]=%d, a[%d]=%d\",\n            i+1, i, a[i], i+1, a[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1],\n            \"Integers are not in ascending order at position %d: a[%d]=%d, a[%d]=%d\",\n            i+1, i, a[i], i+1, a[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1],\n            \"Integers are not in ascending order at position %d: a[%d]=%d, a[%d]=%d\",\n            i+1, i, a[i], i+1, a[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    // Possible types: \"random\", \"single\", \"multiples\", \"powers\", \"consecutive\"\n    // default is \"random\" if not provided\n    string type = opt<string>(\"type\", \"random\");\n\n    // A container to hold our generated distinct numbers\n    // We'll store them in a set first, then build sorted output.\n    unordered_set<int> used;\n    used.reserve(n * 2); // Just to reduce rehashing overhead\n\n    // Helper lambda to insert random distinct values in [1..maxVal]\n    auto insertRandomDistinct = [&](int count, int maxVal = 1000000) {\n        while ((int)used.size() < count) {\n            int val = rnd.next(1, maxVal);\n            used.insert(val);\n        }\n    };\n\n    // Generate data depending on type\n    if (type == \"single\") {\n        // n could be large, but for \"single\", let's just keep 1 or fill others with random\n        // We'll put exactly one distinct number if n==1,\n        // otherwise fill them all but ensure there's a repetition of that single pattern\n        // Actually, problem states the input integers must be distinct, so we can't repeat.\n        // Let's handle it as if n=1 or more. If n>1, just fill random distinct but keep at least one fixed number.\n        used.insert(1); // always use '1'\n        if (n > 1) {\n            insertRandomDistinct(n); \n        }\n    }\n    else if (type == \"multiples\") {\n        // Produce a set that has many multiples of some random base b\n        // Then fill up to n distinct if needed\n        int b = rnd.next(2, 1000);\n        // Keep generating multiples of b up to 1e6\n        for (long long x = b; x <= 1000000; x += b) {\n            used.insert((int)x);\n            if ((int)used.size() == n) break;\n        }\n        // If still not enough, randomly fill the rest\n        if ((int)used.size() < n) {\n            insertRandomDistinct(n);\n        }\n    }\n    else if (type == \"powers\") {\n        // Generate powers of two up to 1e6, or any power base\n        // Let's pick base randomly from [2..20], to vary\n        // Then fill powers up to 1e6\n        int baseVal = rnd.next(2, 20);\n        long long cur = 1;\n        while (cur <= 1000000LL && (int)used.size() < n) {\n            used.insert((int)cur);\n            cur *= baseVal;\n        }\n        // If we haven't reached n distinct numbers, fill randomly\n        if ((int)used.size() < n) {\n            insertRandomDistinct(n);\n        }\n    }\n    else if (type == \"consecutive\") {\n        // Generate a random start in [1..1e6], then pick n consecutive\n        // Must ensure we don't exceed 1e6\n        // If the chosen start + n - 1 > 1e6, shift it to fit\n        int start = rnd.next(1, 1000000);\n        if ((long long)start + n - 1LL > 1000000LL) {\n            start = max(1, 1000000 - n + 1);\n        }\n        for (int i = 0; i < n; i++) {\n            used.insert(start + i);\n        }\n    }\n    else {\n        // \"random\" (default)\n        insertRandomDistinct(n);\n    }\n\n    // Now we have 'used' containing at least n distinct positive integers\n    // If we somehow inserted more than n, we only need n distinct. But our approach\n    // ensures we won't exceed n in most cases. If we do exceed, let's handle it:\n    // We'll pick any n out of them if that happens.\n    if ((int)used.size() > n) {\n        vector<int> tmp(used.begin(), used.end());\n        shuffle(tmp.begin(), tmp.end());\n        tmp.resize(n);\n        used.clear();\n        used.insert(tmp.begin(), tmp.end());\n    }\n\n    // Build a sorted vector\n    vector<int> output(used.begin(), used.end());\n    sort(output.begin(), output.end());\n\n    // Print\n    // According to the problem statement:\n    // 1) First line: n\n    // 2) Second line: the n distinct sorted integers\n    // Make sure the array is ascending and within [1..1e6].\n    // Distinctness is guaranteed by using a set.\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << output[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    // Possible types: \"random\", \"single\", \"multiples\", \"powers\", \"consecutive\"\n    // default is \"random\" if not provided\n    string type = opt<string>(\"type\", \"random\");\n\n    // A container to hold our generated distinct numbers\n    // We'll store them in a set first, then build sorted output.\n    unordered_set<int> used;\n    used.reserve(n * 2); // Just to reduce rehashing overhead\n\n    // Helper lambda to insert random distinct values in [1..maxVal]\n    auto insertRandomDistinct = [&](int count, int maxVal = 1000000) {\n        while ((int)used.size() < count) {\n            int val = rnd.next(1, maxVal);\n            used.insert(val);\n        }\n    };\n\n    // Generate data depending on type\n    if (type == \"single\") {\n        // n could be large, but for \"single\", let's just keep 1 or fill others with random\n        // We'll put exactly one distinct number if n==1,\n        // otherwise fill them all but ensure there's a repetition of that single pattern\n        // Actually, problem states the input integers must be distinct, so we can't repeat.\n        // Let's handle it as if n=1 or more. If n>1, just fill random distinct but keep at least one fixed number.\n        used.insert(1); // always use '1'\n        if (n > 1) {\n            insertRandomDistinct(n); \n        }\n    }\n    else if (type == \"multiples\") {\n        // Produce a set that has many multiples of some random base b\n        // Then fill up to n distinct if needed\n        int b = rnd.next(2, 1000);\n        // Keep generating multiples of b up to 1e6\n        for (long long x = b; x <= 1000000; x += b) {\n            used.insert((int)x);\n            if ((int)used.size() == n) break;\n        }\n        // If still not enough, randomly fill the rest\n        if ((int)used.size() < n) {\n            insertRandomDistinct(n);\n        }\n    }\n    else if (type == \"powers\") {\n        // Generate powers of two up to 1e6, or any power base\n        // Let's pick base randomly from [2..20], to vary\n        // Then fill powers up to 1e6\n        int baseVal = rnd.next(2, 20);\n        long long cur = 1;\n        while (cur <= 1000000LL && (int)used.size() < n) {\n            used.insert((int)cur);\n            cur *= baseVal;\n        }\n        // If we haven't reached n distinct numbers, fill randomly\n        if ((int)used.size() < n) {\n            insertRandomDistinct(n);\n        }\n    }\n    else if (type == \"consecutive\") {\n        // Generate a random start in [1..1e6], then pick n consecutive\n        // Must ensure we don't exceed 1e6\n        // If the chosen start + n - 1 > 1e6, shift it to fit\n        int start = rnd.next(1, 1000000);\n        if ((long long)start + n - 1LL > 1000000LL) {\n            start = max(1, 1000000 - n + 1);\n        }\n        for (int i = 0; i < n; i++) {\n            used.insert(start + i);\n        }\n    }\n    else {\n        // \"random\" (default)\n        insertRandomDistinct(n);\n    }\n\n    // Now we have 'used' containing at least n distinct positive integers\n    // If we somehow inserted more than n, we only need n distinct. But our approach\n    // ensures we won't exceed n in most cases. If we do exceed, let's handle it:\n    // We'll pick any n out of them if that happens.\n    if ((int)used.size() > n) {\n        vector<int> tmp(used.begin(), used.end());\n        shuffle(tmp.begin(), tmp.end());\n        tmp.resize(n);\n        used.clear();\n        used.insert(tmp.begin(), tmp.end());\n    }\n\n    // Build a sorted vector\n    vector<int> output(used.begin(), used.end());\n    sort(output.begin(), output.end());\n\n    // Print\n    // According to the problem statement:\n    // 1) First line: n\n    // 2) Second line: the n distinct sorted integers\n    // Make sure the array is ascending and within [1..1e6].\n    // Distinctness is guaranteed by using a set.\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << output[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20-30 example commands to run the generator\n# with various parameters. No output redirection is shown.\n\n# Very small sets\n./gen -n 1 -type single\n./gen -n 1 -type random\n./gen -n 2 -type multiples\n./gen -n 3 -type powers\n./gen -n 5 -type consecutive\n\n# Moderate small sets with different patterns\n./gen -n 10 -type random\n./gen -n 10 -type multiples\n./gen -n 10 -type powers\n./gen -n 10 -type consecutive\n\n# Larger sets (still small enough to view)\n./gen -n 20 -type random\n./gen -n 20 -type multiples\n./gen -n 20 -type powers\n./gen -n 20 -type consecutive\n\n# Medium sets\n./gen -n 50 -type random\n./gen -n 50 -type multiples\n./gen -n 50 -type powers\n./gen -n 50 -type consecutive\n\n# Larger sets\n./gen -n 100 -type random\n./gen -n 100 -type multiples\n./gen -n 100 -type powers\n./gen -n 100 -type consecutive\n\n# Even larger sets\n./gen -n 99999 -type random\n./gen -n 99999 -type multiples\n\n./gen -n 100000 -type random\n./gen -n 100000 -type consecutive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:47.494213",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "566/G",
      "title": "G. Max and Min",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and m (1 ≤ n, m ≤ 100 000) — the number of pairs of numbers available to Max and Min, correspondingly.The second line contains two integers x, y (1 ≤ x, y ≤ 109) — the initial values of numbers with which the kittens are playing.Next n lines contain the pairs of numbers ai, bi (1 ≤ ai, bi ≤ 109) — the pairs available to Max.The last m lines contain pairs of numbers cj, dj (1 ≤ cj, dj ≤ 109) — the pairs available to Min.",
      "output_spec": "OutputPrint «Max» (without the quotes), if kitten Max wins, or \"Min\" (without the quotes), if kitten Min wins.",
      "sample_tests": "ExamplesInputCopy2 242 432 33 23 1010 3OutputCopyMinInputCopy1 11 13 41 1OutputCopyMax",
      "description": "G. Max and Min\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers, n and m (1 ≤ n, m ≤ 100 000) — the number of pairs of numbers available to Max and Min, correspondingly.The second line contains two integers x, y (1 ≤ x, y ≤ 109) — the initial values of numbers with which the kittens are playing.Next n lines contain the pairs of numbers ai, bi (1 ≤ ai, bi ≤ 109) — the pairs available to Max.The last m lines contain pairs of numbers cj, dj (1 ≤ cj, dj ≤ 109) — the pairs available to Min.\n\nOutputPrint «Max» (without the quotes), if kitten Max wins, or \"Min\" (without the quotes), if kitten Min wins.\n\nInputCopy2 242 432 33 23 1010 3OutputCopyMinInputCopy1 11 13 41 1OutputCopyMax\n\nInputCopy2 242 432 33 23 1010 3\n\nOutputCopyMin\n\nInputCopy1 11 13 41 1\n\nOutputCopyMax\n\nNoteIn the first test from the statement Min can respond to move (2, 3) by move (3, 10), and to move (3, 2) by move (10, 3). Thus, for each pair of Max and Min's moves the values of both numbers x and y will strictly decrease, ergo, Min will win sooner or later.In the second sample test after each pair of Max and Min's moves both numbers x and y only increase, thus none of them will become negative.",
      "solutions": [
        {
          "title": "VK Cup 2015: online mirror and final thanks - Codeforces",
          "content": "The registrations before 00:00 have been deleted, because the form didn't support teams. Please, register again if your registration has been affected.VK Cup 2015 Final Round has ended two days ago. It's very likely that you've seen our previous posts. The last event to happen is online mirror of the final round. It will be held on Thursday, July 30th, at 19:00 Moscow time. Individual contestants as well as teams consisting of two people may participate in this round. Round duration is three hours, problems will be shuffled in comparison with to the original order. Both division participants may take part, but we want to warn 2nd division contestants that problemset may be hard for them. This round is a rated Codeforces round.Finally, we want to thank all people that made this Championship. Following VK developers, Codeforces team members and the other people suggested their help to us while creating and preparing problems: PavelKunyavskiy, burunduk3, Dmitry_Egorov, Kurpilyansky, dark_ai, MikeMirzayanov, Zlobober, MaximShipko, kuviman, Nickolas, Errichto, sankear и malcolm. We want to thank the people that helped us very much by testing our rounds and giving great advices: winger и AlexFetisov. Also we want to say thank you to all VK members that helped us to run the onsite Finals: burunduk3, Burunduk2, KOTEHOK and many others. Thank to all of them!Good luck and have fun on our Online Mirror!UPD: Note that during the round the team is allowed to use only one computer. This means that you may code/use console/succeed in solving problems in any other manner by using only one computer at time. The only thing that is allowed from two computers is reading the statements.UPD2: Since this is a team contest, specially for your convenience we publish the encryped zip-archive with pdf-statements of problems: vkcup2015-mirror-statements.zip. When round starts, we'll publish a password for it.UPD3: The round will use the dynamic scoring with 250 points step.UPD4: Due to technical reasons the round starts at 19:20 Moscow time.UPD5: Password for statements archive: vkcup4ever. Good luck!UPD6: Online mirror has ended! Congratulations to winners: rng_58 Zenith: I_love_Hoang_Yen, ngfam_kongu OrOrZZZ!: zld3794955, KFDong Petr team: Petr, ilyakor jcvb_matthew99: matthew99, jcvb Also, my personal respects for a team \"Petr team: Petr, ilyakor\" for only solution for a problem Е in this mirror, user rng_58 and a team \"Excited: YuukaKazami, jqdai0815\" for two correct solutions for problem С.Congratulations to a user rng_58 that showed that a single contestant can compete with teams consisting of two people!Rating will be updated shortly.UPD7: Editorial!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19478",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2677
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces",
          "content": "Thanks everybody for participating. Tasks follow in the order of the original contest (the mirror order is given in the brackets).562A - Logistical Questions(in mirror: 566C - Logistical Questions)Let's think about formal statement of the problem. We are given a tricky definition of a distance on the tre: ρ(a, b) = dist(a, b)1.5. Each vertex has its weight wi. We need to choose a place x for a competition such that the sum of distances from all vertices of the tree with their weights is minimum possible: f(x) = w1ρ(1, x) + w2ρ(x, 2) + ... + wnρ(x, n).Let's understand how function f(x) works. Allow yourself to put point x not only in vertices of the tree, but also in any point inside each edge by naturally expanding the distance definition (for example, the middle of the edge of length 4 km is located 2 km from both ends of this edge).Fact 1. For any path in the tree the function ρ(i, x) is convex. Actually, the function dist(i, x) plot on each path [a, b] looks like the plot of a function abs(x): it first decreases linearly to the minimum: the closes to i point on a segment [a, b], and then increases linearly. Taking a composition with a convex increasing function t1.5, as we can see, we get the convex function on any path in the tree. Here by function on the path we understand usual function of a real variable x that is identified with its location on path x: dist(a, x). So, each of the summands in the definition of f(x) is convex on any path in the tree, so f(x) is also convex on any path in the tree.Let's call convex functions on any path in the tree convex on tree. Let's formulate few facts about convex functions on trees.Fact 2. A convex function on tree can't have two different local minimums. Indeed, otherwise the path between those minimums contradicts the property of being convex on any path in the tree.So, any convex function f(x) on the tree has the only local minimum that coincides with its global minimum.Fact 3. From each vertex v there exists no more than one edge in which direction the function f decreases. Indeed, otherwise the path connecting two edges of function decrease would contradict the definition of a convex function in a point v.Let's call such edge that function decreases along this edge to be a gradient of function f in point x. By using facts 2 and 3 we see that in each vertex there is either a uniquely defined gradient or the vertex is a global minimum.Suppose we are able to efficiently find a gradient direction by using some algorithm for a given vertex v. If our tree was a bamboo then the task would be a usual convex function minimization that is efficiently solved by a binary search, i. e. dichotomy. We need some equivalent of a dichotomy for a tree. What is it?Let's use centroid decmoposition! Indeed, let's take a tree center (i. e. such vertex that sizes of all its subtrees are no larger than n / 2). By using fact 3 we may consider the gradient of f in the center of the tree. First of all, there may be no gradient in this point meaning that we already found an optimum. Otherwise we know that global minimum is located in a subtree in direction of gradient, so all remaining subtrees and the center can be excluded from our consideration. So, by running one gradient calculation we reduced the number of vertices in a considered part of a tree twice.So, in runs of gradient calculation we almost solved the problem. Let's understand where exactly the answer is located. Note that the global optimum will most probably be located inside some edge. It is easy to see that the optimum vertex will be one of the vertices incident to that edge, or more specifically, one of the last two considered vertices by our algorithms. Which exactly can be determined by calculating the exact answer for them and choosing the most optimal among them.Now let's calculate the gradient direction in a vertex v. Fix a subtree ui of a vertex v. Consider a derivative of all summands from that subtree when we move into that subtree. Denote this derivative as deri. Then, as we can see, the derivative of f(x) while moving from x = v in direction of subtree ui is  - der1 - der2 - ... - deri - 1 + deri - deri + 1 - ... - derk where k is a degree of vertex v. So, by running one DFS from vertex v we may calculate all values deri, and so we may find a gradient direction by applying the formula above and considering a direction with negative derivative.Finally, we got a solution in .562B - Clique in the Divisibility Graph(in mirror: 566F - Clique in the Divisibility Graph)Order numbers in the sought clique in ascending order. Note that set X = {x1, ..., xk} is a clique iff for (1 ≤ i ≤ k - 1). So, it's easy to formulate a dynamic programming problem: D[x] is equal to the length of a longest suitable increasing subsequence ending in a number x. The calculation formula: for all x in set A.If DP is written in \"forward\" direction then it's easy to estimate the complexity of a solution. In the worst case we'll process transitions.562C - Restoring Map(in mirror: 566E - Restoring Map)Let's call a neighborhood of a vertex — the set consisting of it and all vertices near to it. So, we know the set of all neighborhoods of all vertices in some arbitrary order, and also each neighborhood is shuffled in an arbitrary order.Let's call the tree vertex to be internal if it is not a tree leaf. Similarly, let's call a tree edge to be internal if it connects two internal vertices. An nice observation is that if two neighborhoods intersect exactly by two elements a and b then a and b have to be connected with an edge, in particular the edge (a, b) is internal. Conversely, any internal edge (a, b) may be represented as an intersection of some two neighborhoods С and D of some two vertices c and d such that there is a path c – a – b – d in the tree. In such manner we may find all internal edges by considering pairwise intersections of all neighborhoods. This can be done in about n3 / 2 operations naively, or in 32 times faster, by using bitsets technique.Note that knowing all internal edges we may determine all internal vertices except the only case of a star graph (i. e. the graph consisting of a vertex with several other vertices attached to it). The case of a star should be considered separately.Now we know the set of all leaves, all internal vertices and a tree structure on all internal vertices. The only thing that remained is to determine for each leaf, to what internal vertex is should be attached. This can be done in following manner. Consider a leaf l. Consider all neighborhoods containing it. Consider a minimal neighborhood among them; it can be shown that it is exactly the neighborhood L corresponding to a leaf l itself. Consider all internal vertices in L. There can be no less than two of them. If there are three of them or more then we can uniquely determine to which of them l should be attached — it should be such vertex from them that has a degree inside L larger than 1. If there are exactly two internal vertices in L (let's say, a and b), then determining the attach point for l is a bit harder.Statement: l should be attached to that vertex among a, b, that has an internal degree exactly 1. Indeed, if l was attached to a vertex with internal degree larger than 1, we would have considered this case before.If both of vertices a and b have internal degree — 1 then our graph looks like a dumbbell (an edge (a, b) and all remaining vertices attached either to a or to b). Such case should also be considered separately.The solution for two special cases remains for a reader as an easy exercise.562D - Restructuring Company(in mirror: 566D - Restructuring Company)This problem allows a lot of solution with different time asymptotic. Let's describe a solution in . Let's first consider a problem with only a queries of second and third type. It can be solved in a following manner. Consider a line consisting of all employees from 1 to n. An observation: any department looks like a contiguous segment of workers. Let's keep those segments in any logarithmic data structure like a balanced binary search tree (std::set or TreeSet). When merging departments from x to y, just extract all segments that are in the range [x, y] and merge them. For answering a query of the third type just check if employees x and y belong to the same segment. In such manner we get a solution of an easier problem in per query. When adding the queries of a first type we in fact allow some segments to correspond to the same department. Let's add a DSU for handling equivalence classes of segments. Now the query of the first type is just using merge inside DSU for departments which x and y belong to. Also for queries of the second type it's important not to forget to call merge from all extracted segments.So we get a solution in time.562E - Max and Min(in mirror: 566G - Max and Min)Consider a following geometrical interpretation. Both Max and Min have a set of vectors from the first plane quadrant and a point (x, y). During his turn Max may add any of his vectors to a point (x, y), and Min — may subtract any of his vectors. Min wants point (x, y) to be strictly in the third quadrant, Max tries to prevent his from doing it. Denote Max vectors as Mxi and Min vectors as Mnj.Consider a following obvious sufficient condition for Max to win. Consider some non-negative direction in a plane, i. e. such vector (a, b) that a, b ≥ 0 and at least one of numbers a, b is not a zero. Then if among Max vectors there is such vector Mxi, that it's not shorter than any of Min vectors Mnj along the direction (a, b) then Max can surely win. Here by the length of vector v along a direction (a, b) we mean a scalar product of vector v and vector (a, b). Indeed, let Max always use that vector Mxi. Then during the turns of Max and Min point (x, y) is shifted by a vector Mxi - Mnj for some j, so its overall shift along the vector (a, b) is equal to ((Mxi - Mnj), (a, b)) = (Mxi, (a, b)) - (Mnj, (a, b)) ≥ 0. By observing that initially the scalar produt ((x, y), (a, b)) = ax + by > 0 we see that at any moment ax + by will be strictly positive. This means that Min won't be able at any moment to make x and y both be negative (since it would mean that ax + by < 0).Now let's formulate some kind of converse statement. Suppose Max vector Mxi lies strictly inside the triangle formed by Min vectors Mnj and Mnk. In particular, vector Mxi endpoint can't lie on a segment [Mnj, Mnk], but it may be collinear one of vectors Mnj and Mnk. Note that since Mxi lies strictly inside the triangle formed by vectors Mnj and Mnk it can be extended to a vector Mx'i, whose endpoint lies on a segment [Mnj, Mnk]. By using linear dependence of Mx'i and Mnj, Mnk we have that Mx'i = (p / r)Mnj + (q / r)Mnk, where p + q = r and p, q, r — integer non-negative numbers. This is equivalent to a formula rMx'i = pMnj + qMnk. This means that if per each r turns of Max in Mxi we will respond with p turns of Min in Mnj and q turns of Min in Mnk, then the total shift will be equal to  - pMnj - qMnk + rMxi =  - rMx'i + rMxi =  - r(Mx'i - Mxi), that is the vector with strictly negative components. So, we are able to block that Max turn, i. e. it does not give any advantage to Max.The natural wish is to create a convex hull of all Min turns and to consider all Max turns in respect to it. If Max turn lies inside the convex hull of Min turns, then by using the previous fact this turn is meaningless to Max. Otherwise, there are two possibilities. First, this turn may intersect the hull but go out of it somewhere; in this case this Max turn is no shorter than all Min turns in some non-negative direction (more specifically, in its own direction), so Max wins.On the other hand, Max vector lies to aside from the Min turns convex hull. Let's suppose the vector Mxi lies to the left of the Min turns. This case requires a special analysis. Consider the topmost of the Min vectors Mnj. If Mxi is no lower than Mxj, then by using the first fact Max is able to win by using only this vector. Otherwise the difference Mni - Mxj is a vector with strictly negative components, by using which we are able to block that Max vector.So, the full version of a criteria for Min being a winner looks like the following. Consider a convex hull of Min turns and expand it to the left of the topmost point and to the bottom of the rightmost point. If all Max turns lie strictly inside the formed figure then Min wins, otherwise Max wins.562F - Matching Names(в трансляции: 566A - Matching Names)Form a trie from all names and pseudonyms. Mark with red all vertices corresponding to names, and with blue all vertices corresponding to the pseudonyms (a single vertex may be marked several times, possibly with different colors). Note that if we match a name a and a pseudonym b, then the quality of such match is lcp(a, b) = 1 / 2(2 * lcp(a, b)) = 1 / 2(|a| + |b| - (|a| - lcp(a, b)) - (|b| - lcp(a, b))), that is equal to a constant 1 / 2(|a| + |b|), with subtracted half of a length of a path between a and b over the trie. So, what we need is to connect all red vertices with blue vertices with paths of a minimum possible total length.This can be done with a following greedy procedure: if we have a vertex v with x red vertices and y blue vertices in its subtree then we must match min(x, y) red vertices of its subtree to min(x, y) blue vertices of its subtree and leave the remaining max(x, y) - min(x, y) ref or blue vertices to the level higher. The correctness of such algorithm may be easily shown by the next idea. Give each edge of each path a direction from a red vertex to a blue. If some edge recieves two different directions after this procedure, we may cross-change two paths through it so that their total length is reduced by two.So, we get a solution in O(sumlen) where sumlen is a total length of all names and pseudonyms.562G - Replicating Processes(в трансляции: 566B - Replicating Processes)==== UNTRANSLATED SECTION, PLEASE WAIT A FEW MINUTES... ====Kitten to take your attention :)This problem may be solved by simulating the replication process. Let's keep a list of all replications that may be applied by the current step. Apply an arbitrary replication, after that update a list by adding/removing all suitable or now unsuitable replications touching all affected on current step servers. The list of replications may be kept in a \"double-linked list\" data structure, that allows to add and remove elements to/from the set and to extract an arbitrary element of the set in O(1).The proof of correctness of such algorithm is not hard and is left as an exercies (maybe it will appear here later).We got a solution in O(n) operation (though, the constant hidden by O-notation is pretty large; the input size is already 12n numbers and the solution itself hides a constant 36 or higher).",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/19518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 566\\s*G"
          },
          "content_length": 14875
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 1",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 2",
          "code": "1.- set(L, R, x) = set every value in range [L, R] to x\n2.- query(idx) = get the value in index idx",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 3",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        },
        {
          "title": "Editorial for VK Cup 2015 — Finals - Codeforces - Code 4",
          "code": "1.- Merge departments team(x) and team(y): set(y, y, x)\n2.- Merge departments team(x), team(x + 1), ..., team(y) = set(x, y, x)\n3.- Check is x and y are in the same department: query(x) == query(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19518",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; i++) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000000, \"di\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; i++) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000000, \"di\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; i++) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000000, \"di\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int x = opt<int>(\"x\", -1);\n    int y = opt<int>(\"y\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (x == -1) x = rnd.next(1, 1000000000);\n        if (y == -1) y = rnd.next(1, 1000000000);\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%d %d\\n\", x, y);\n\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000000000);\n            int bi = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ai, bi);\n        }\n        for (int i = 0; i < m; ++i) {\n            int ci = rnd.next(1, 1000000000);\n            int di = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ci, di);\n        }\n    } else if (type == \"max_win\") {\n        if (x == -1) x = rnd.next(1e8, 1e9);\n        if (y == -1) y = rnd.next(1e8, 1e9);\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%d %d\\n\", x, y);\n\n        // Max's pairs have large values\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1e8, 1e9);\n            int bi = rnd.next(1e8, 1e9);\n            printf(\"%d %d\\n\", ai, bi);\n        }\n\n        // Min's pairs have small values\n        for (int i = 0; i < m; ++i) {\n            int ci = rnd.next(1, 1000);\n            int di = rnd.next(1, 1000);\n            printf(\"%d %d\\n\", ci, di);\n        }\n    } else if (type == \"min_win\") {\n        if (x == -1) x = rnd.next(1, 1000);\n        if (y == -1) y = rnd.next(1, 1000);\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%d %d\\n\", x, y);\n\n        // Max's pairs have small values\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 10);\n            int bi = rnd.next(1, 10);\n            printf(\"%d %d\\n\", ai, bi);\n        }\n\n        // Min's pairs have large values\n        for (int i = 0; i < m; ++i) {\n            int ci = rnd.next(x, min(x * 10, 1000000000));\n            int di = rnd.next(y, min(y * 10, 1000000000));\n            printf(\"%d %d\\n\", ci, di);\n        }\n    } else if (type == \"edge_case\") {\n        int subtype = opt<int>(\"subtype\", 1);\n\n        if (subtype == 1) {\n            // Minimal n and m, minimal x and y\n            n = 1; m = 1; x = 1; y = 1;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1 1\\n\");\n        } else if (subtype == 2) {\n            // Max x and y, min ai and bi\n            n = 1; m = 1; x = 1000000000; y = 1000000000;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1 1\\n\");\n        } else if (subtype == 3) {\n            // Max x and y, Max's ai and bi are 1, Min's ci and di are large\n            n = 1; m = 1; x = 1000000000; y = 1000000000;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1000000000 1000000000\\n\");\n        } else {\n            // Default edge case\n            n = 1; m = 1; x = 500000000; y = 500000000;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1 1\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int x = opt<int>(\"x\", -1);\n    int y = opt<int>(\"y\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (x == -1) x = rnd.next(1, 1000000000);\n        if (y == -1) y = rnd.next(1, 1000000000);\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%d %d\\n\", x, y);\n\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000000000);\n            int bi = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ai, bi);\n        }\n        for (int i = 0; i < m; ++i) {\n            int ci = rnd.next(1, 1000000000);\n            int di = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ci, di);\n        }\n    } else if (type == \"max_win\") {\n        if (x == -1) x = rnd.next(1e8, 1e9);\n        if (y == -1) y = rnd.next(1e8, 1e9);\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%d %d\\n\", x, y);\n\n        // Max's pairs have large values\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1e8, 1e9);\n            int bi = rnd.next(1e8, 1e9);\n            printf(\"%d %d\\n\", ai, bi);\n        }\n\n        // Min's pairs have small values\n        for (int i = 0; i < m; ++i) {\n            int ci = rnd.next(1, 1000);\n            int di = rnd.next(1, 1000);\n            printf(\"%d %d\\n\", ci, di);\n        }\n    } else if (type == \"min_win\") {\n        if (x == -1) x = rnd.next(1, 1000);\n        if (y == -1) y = rnd.next(1, 1000);\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%d %d\\n\", x, y);\n\n        // Max's pairs have small values\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 10);\n            int bi = rnd.next(1, 10);\n            printf(\"%d %d\\n\", ai, bi);\n        }\n\n        // Min's pairs have large values\n        for (int i = 0; i < m; ++i) {\n            int ci = rnd.next(x, min(x * 10, 1000000000));\n            int di = rnd.next(y, min(y * 10, 1000000000));\n            printf(\"%d %d\\n\", ci, di);\n        }\n    } else if (type == \"edge_case\") {\n        int subtype = opt<int>(\"subtype\", 1);\n\n        if (subtype == 1) {\n            // Minimal n and m, minimal x and y\n            n = 1; m = 1; x = 1; y = 1;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1 1\\n\");\n        } else if (subtype == 2) {\n            // Max x and y, min ai and bi\n            n = 1; m = 1; x = 1000000000; y = 1000000000;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1 1\\n\");\n        } else if (subtype == 3) {\n            // Max x and y, Max's ai and bi are 1, Min's ci and di are large\n            n = 1; m = 1; x = 1000000000; y = 1000000000;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1000000000 1000000000\\n\");\n        } else {\n            // Default edge case\n            n = 1; m = 1; x = 500000000; y = 500000000;\n            printf(\"%d %d\\n\", n, m);\n            printf(\"%d %d\\n\", x, y);\n            printf(\"1 1\\n\");\n            printf(\"1 1\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type edge_case -subtype 1\n./gen -n 1 -m 1 -type edge_case -subtype 2\n./gen -n 1 -m 1 -type edge_case -subtype 3\n./gen -n 1 -m 1 -type edge_case -subtype 4\n\n./gen -n 2 -m 2 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type max_win\n./gen -n 100000 -m 100000 -type min_win\n\n./gen -n 100000 -m 100000 -type max_win -x 1000000000 -y 1000000000\n./gen -n 100000 -m 100000 -type min_win -x 1 -y 1\n\n./gen -n 1 -m 100000 -type max_win\n./gen -n 100000 -m 1 -type min_win\n\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 1 -type random\n\n./gen -n 100000 -m 100000 -type max_win -x 500000000 -y 500000000\n./gen -n 100000 -m 100000 -type min_win -x 500000000 -y 500000000\n\n./gen -n 50000 -m 50000 -type max_win \n./gen -n 50000 -m 50000 -type min_win\n\n./gen -n 2 -m 2 -x 1 -y 1 -type min_win\n\n./gen -n 2 -m 2 -x 1000000000 -y 1000000000 -type max_win\n\n./gen -n 1000 -m 1000 -x 123456789 -y 987654321 -type random\n\n./gen -n 100000 -m 100000 -x 999999999 -y 1 -type random\n\n./gen -n 100000 -m 100000 -x 1 -y 999999999 -type random\n\n./gen -n 100000 -m 100000 -x 123456789 -y 987654321 -type max_win\n\n./gen -n 100 -m 100000 -x 1000000000 -y 1000000000 -type max_win\n\n./gen -n 100000 -m 100 -x 1 -y 1 -type min_win\n\n./gen -n 50000 -m 50000 -x 1 -y 1 -type min_win\n\n./gen -n 1 -m 1 -type random -x 1 -y 1\n\n./gen -n 1 -m 1 -type random -x 1000000000 -y 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:49.731204",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "567/A",
      "title": "A. Lineland Mail",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (2 ≤ n ≤ 105) — the number of cities in Lineland. The second line contains the sequence of n distinct integers x1, x2, ..., xn ( - 109 ≤ xi ≤ 109), where xi is the x-coordinate of the i-th city. All the xi's are distinct and follow in ascending order.",
      "output_spec": "OutputPrint n lines, the i-th line must contain two integers mini, maxi, separated by a space, where mini is the minimum cost of sending a letter from the i-th city, and maxi is the maximum cost of sending a letter from the i-th city.",
      "sample_tests": "ExamplesInputCopy4-5 -2 2 7OutputCopy3 123 94 75 12InputCopy2-1 1OutputCopy2 22 2",
      "description": "A. Lineland Mail\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integer n (2 ≤ n ≤ 105) — the number of cities in Lineland. The second line contains the sequence of n distinct integers x1, x2, ..., xn ( - 109 ≤ xi ≤ 109), where xi is the x-coordinate of the i-th city. All the xi's are distinct and follow in ascending order.\n\nOutputPrint n lines, the i-th line must contain two integers mini, maxi, separated by a space, where mini is the minimum cost of sending a letter from the i-th city, and maxi is the maximum cost of sending a letter from the i-th city.\n\nInputCopy4-5 -2 2 7OutputCopy3 123 94 75 12InputCopy2-1 1OutputCopy2 22 2\n\nInputCopy4-5 -2 2 7\n\nOutputCopy3 123 94 75 12\n\nInputCopy2-1 1\n\nOutputCopy2 22 2",
      "solutions": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!5th august 2015 at 19:00 MSK Codeforces Round #Pi will take place for second division participants. Participants from the first division are able to participate out of the contest.This is my first round on Codeforces. I hope you will enjoy the tasks and this will stimulate me to prepare new rounds! Wish you quick Accepted verdicts and successful hacks.I want to thank Michael Mirzayanov (MikeMirzayanov) for wonderful platforms Polygon and Codeforces and for help in preparing the tasks, Maxim Akhmedov (Zlobober) for help in contest preparation, Maria Belova for translation statements to english, and also my friends Danil Sagunov (danilka.pro) and Vitaliy Kudasov (kuviman) for solving the tasks.Participants will be given six tasks and two and the half hours for solving them. Scoring system will be announced closer to round start.UPD: Scoring: 500-1000-1500-2000-2500-2500.UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces",
          "content": "567A - Lineland MailOne can notice that the maximum cost of sending a letter from i'th city is equal to maximum of distances from i'th city to first city and from i'th city to last (max(abs(xi - x0), abs(xi - xn - 1)). On the other hand, the minimum cost of sending a letter will be the minimum of distances between neighboring cities (i - 1'th and i + 1'th cities), more formally, min(abs(xi - xi - 1), abs(xi - xi + 1). For each city, except the first and the last this formula is correct, but for them formulas are (abs(xi - xi + 1)) and (abs(xi - xi - 1)) respectively.Author solution567B - Berland National LibraryTo answer the queries correct, we need to know if the person is still in the library. For that purpose we will use in array of type bool. Also we will store two variables for the answer and ''current state'' (it will store the current number of people in the library). Let's call them ans and state respectively.Thus, if we are given query  + ai then we should increase state by one, mark that this person entered the library (in[ai] = true) and try to update the answer (ans = max(ans, state)).Otherwise we are given  - ai query. If the person who leaves the library, was in there, we should just decrease state by one. Otherwise, if this person was not in the library (in[ai] == false) and leaves now, he entered the library before we started counting. It means we should increase the answer by one anyway. Also one should not forget that it is needed to mark that the person has left the library (in[ai] = false).Author solution567C - Geometric ProgressionLet's solve this problem for fixed middle element of progression. This means that if we fix element ai then the progression must consist of ai / k and ai·k elements. It could not be possible, for example, if ai is not divisible by k ().For fixed middle element one could find the number of sequences by counting how many ai / k elements are placed left from fixed element and how many ai·k are placed right from it, and then multiplying this numbers. To do this, one could use two associative arrays Al and Ar, where for each key x will be stored count of occurences of x placed left (or right respectively) from current element. This could be done with map structure.Sum of values calculated as described above will give the answer to the problem.Author solution567D - One-Dimensional Battle ShipsFirst, we should understand when the game ends. It will happen when on the n-sized board it will be impossible to place k ships of size a. For segment with length len we could count the maximum number of ships with size a that could be placed on it. Each ship occupies a + 1 cells, except the last ship. Thus, for segment with length len the formula will look like (we add \"fictive\" cell to len cells to consider the last ship cell). This way, for [l..r] segment the formula should be . For solving the problem we should store all the [l..r] segments which has no ''free'' cells (none of them was shooted). One could use (std: : set) for that purpose. This way, before the shooting, there will be only one segment [1..n]. Also we will store current maximum number of ships we could place on a board. Before the shooting it is equal to .With every shoot in cell x we should find the segment containing shooted cell (let it be [l..r]), we should update segment set. First, we should delete [l..r] segment. It means we should decrease current maximum number of ships by and delete it from the set. Next, we need to add segments [l..x - 1] and [x + 1..r] to the set (they may not be correct, so you may need to add only one segments or do not add segments at all) and update the maximum number of ships properly. We should process shoots one by one, and when the maximum number of ships will become lesser than k, we must output the answer. If that never happen, output  - 1.Author solution567E - President and RoadsAt first, let's find edges that do not belong to any shortest paths from s to t. Let's find two shortest path arrays d1 and d2 with any shortest-path-finding algorithm. First array stores shortest path length from s, and the second — from t. Edge (u, v) then will be on at least one shortest path from s to t if and only if d1[u] + w(u, v) + d2[v] == d1[t].Let's build shortest path graph, leaving only edges described above. If we consider shortest path from s to t as segment [0..D] and any edge (u, v) in shortest path graph as its subsegment [d1[u]..d1[v]], then if such subsegment do not share any common point with any other edge subsegment, except its leftest and rightest point (d1[u] and d1[v]), this edge belongs to every shortest path from s to t.Now we could surely answer \"YES\" to such edges. Next part of the solution are much simple. If edge (u, v) do not belong to every shortest path, we could try decrease its weight. This edge will belong to every shortest path if and only if its weight will become d1[t] - d1[u] - d2[v] - 1. So, if this value are strictly positive, we should answer \"CAN\" considering new edge weight. Otherwise we need to output \"NO\".Author solution567F - MausoleumConsider that we are placing blocks by pairs, one pair by one, starting from leftmost and rightmost places. Thus, for example, two blocks of height 1 we could place in positions 1 and 2, 1 and 2n, or 2n - 1 and 2n. The segment of unused positions will be changed that way and the next block pairs should be placed on new leftmost and rightmost free places. At last only two positions will be free and we should place two blocks of height n on them.Any correct sequence of blocks could be builded that way. Let's try to review the requirements consider such way of placing blocks. As soon as we place blocks one by one, the requirements are now only describes the order of placing blocks. For example, requirement ''3 >= 5'' means that we should place block in position 3 only if block in position 5 is already placed (and thus it have lesser height), or we place pair of blocks of same height on them at one moment.For counting required number of sequences we will use dynamic programming approach. Let's count dp[l][r] — the number of ways to place some blocks in the way that only positions at segment [l..r] are free. The height of current placed pair of blocks is counted from the segment borders itself (. Fix one way of placing current block pair (exclusion is l =  = r + 1). Now check if such placing meets the requirements. We will consider only requirements that meets one of the current-placing positions. For every \"current\" position \"<\" must be true only for free positions (positions in [l..r], which do not equal to current positions), \">\" must be true for already-placed positions (out of [l..r]) and \"=\" must be true only for second current position.This DP could be easily calculated using \"lazy\" approach.Author solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 567\\s*A"
          },
          "content_length": 6829
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 1",
          "code": "left_border=k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 2",
          "code": "right_border=k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 3",
          "code": "total<number_of_ships",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 4",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 5",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 6",
          "code": "(len + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 7",
          "code": "l <= c <= r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 8",
          "code": "(len(l, r) + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 9",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 10",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 11",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 12",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 13",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 14",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 15",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 17",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 18",
          "code": "map<long long,long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 19",
          "code": "it=s.upper_bound(mp(mov[i],-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 20",
          "code": "it=s.upper_bound(mp(mov[i],n+1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 21",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 22",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 2",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 3",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 4",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 5",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 6",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 8",
          "code": "max_load_factor",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 9",
          "code": "unordered_map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 10",
          "code": "map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 11",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 12",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 13",
          "code": "auto it = xs.lower_bound(mp(x, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000);\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    for (int i = 1; i < n; i++) {\n        ensuref(x[i - 1] < x[i], \"Coordinates should be in strictly increasing order: x[%d]=%d, x[%d]=%d\", i - 1, x[i - 1], i, x[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000);\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    for (int i = 1; i < n; i++) {\n        ensuref(x[i - 1] < x[i], \"Coordinates should be in strictly increasing order: x[%d]=%d, x[%d]=%d\", i - 1, x[i - 1], i, x[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000);\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    for (int i = 1; i < n; i++) {\n        ensuref(x[i - 1] < x[i], \"Coordinates should be in strictly increasing order: x[%d]=%d, x[%d]=%d\", i - 1, x[i - 1], i, x[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // We must ensure 2 <= n <= 100000 as per problem statement\n    // (The constraints allow up to 10^5 cities.)\n    // If needed, you may add checks like:\n    //   ensuref(n >= 2 && n <= 100000, \"n must be in [2..100000]\");\n    // but here we assume the user will pass valid values.\n\n    vector<long long> coords(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random integers in [-1e9, 1e9].\n        // Store them in a set to ensure distinctness, then copy to coords.\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-1000000000LL, 1000000000LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        // They might already be sorted, but to be safe, sort them\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"small\") {\n        // Generate n distinct integers in [-100, 100].\n        // Note: This only works if n <= 201. We do not enforce\n        // checks here, but the user is expected to pass a feasible n.\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-100, 100);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"allneg\") {\n        // Generate n distinct negative integers in [-1e9, -1].\n        // For n up to 100000, we have enough space (1e9 possible negative numbers).\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-1000000000LL, -1LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"allpos\") {\n        // Generate n distinct positive integers in [1, 1e9].\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(1LL, 1000000000LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"mix\") {\n        // Generate floor(n/2) distinct negatives and the rest distinct positives.\n        // Then merge, sort, and output.\n        int negCount = n / 2;                // floor(n/2)\n        int posCount = n - negCount;\n        set<long long> negSet, posSet;\n\n        while ((int)negSet.size() < negCount) {\n            long long val = rnd.next(-1000000000LL, -1LL);\n            negSet.insert(val);\n        }\n        while ((int)posSet.size() < posCount) {\n            long long val = rnd.next(1LL, 1000000000LL);\n            posSet.insert(val);\n        }\n\n        vector<long long> tmp;\n        for (auto v : negSet) tmp.push_back(v);\n        for (auto v : posSet) tmp.push_back(v);\n        sort(tmp.begin(), tmp.end());\n        coords = tmp;\n    }\n    else if (type == \"arithmetic\") {\n        // Generate an arithmetic progression with step=1,\n        // ensuring it stays within [-1e9, 1e9].\n        // We choose a random starting point s in [ -1e9, 1e9 - (n-1) ] (if feasible),\n        // so that s + (n-1)*1 <= 1e9.\n        long long maxStart = 1000000000LL - (n - 1);\n        if (maxStart < -1000000000LL) {\n            // If n is so large we can't fit an arithmetic progression with step=1\n            // from within [-1e9, 1e9], just clamp it.\n            maxStart = -1000000000LL;\n        }\n        long long s = rnd.next(-1000000000LL, maxStart);\n        for (int i = 0; i < n; i++) {\n            coords[i] = s + i;\n        }\n    }\n    else if (type == \"extreme\") {\n        // Simply place the first city at -1e9 and then each subsequent city\n        // 1 unit apart. This fits in the range for n <= 100000.\n        // coords[i] = -1e9 + i\n        for (int i = 0; i < n; i++) {\n            coords[i] = -1000000000LL + i;\n        }\n    }\n    else {\n        // Default fallback: same as random\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-1000000000LL, 1000000000LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n\n    // Output the results:\n    // First line: n\n    // Second line: sorted distinct coordinates\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << coords[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // We must ensure 2 <= n <= 100000 as per problem statement\n    // (The constraints allow up to 10^5 cities.)\n    // If needed, you may add checks like:\n    //   ensuref(n >= 2 && n <= 100000, \"n must be in [2..100000]\");\n    // but here we assume the user will pass valid values.\n\n    vector<long long> coords(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random integers in [-1e9, 1e9].\n        // Store them in a set to ensure distinctness, then copy to coords.\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-1000000000LL, 1000000000LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        // They might already be sorted, but to be safe, sort them\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"small\") {\n        // Generate n distinct integers in [-100, 100].\n        // Note: This only works if n <= 201. We do not enforce\n        // checks here, but the user is expected to pass a feasible n.\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-100, 100);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"allneg\") {\n        // Generate n distinct negative integers in [-1e9, -1].\n        // For n up to 100000, we have enough space (1e9 possible negative numbers).\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-1000000000LL, -1LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"allpos\") {\n        // Generate n distinct positive integers in [1, 1e9].\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(1LL, 1000000000LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n    else if (type == \"mix\") {\n        // Generate floor(n/2) distinct negatives and the rest distinct positives.\n        // Then merge, sort, and output.\n        int negCount = n / 2;                // floor(n/2)\n        int posCount = n - negCount;\n        set<long long> negSet, posSet;\n\n        while ((int)negSet.size() < negCount) {\n            long long val = rnd.next(-1000000000LL, -1LL);\n            negSet.insert(val);\n        }\n        while ((int)posSet.size() < posCount) {\n            long long val = rnd.next(1LL, 1000000000LL);\n            posSet.insert(val);\n        }\n\n        vector<long long> tmp;\n        for (auto v : negSet) tmp.push_back(v);\n        for (auto v : posSet) tmp.push_back(v);\n        sort(tmp.begin(), tmp.end());\n        coords = tmp;\n    }\n    else if (type == \"arithmetic\") {\n        // Generate an arithmetic progression with step=1,\n        // ensuring it stays within [-1e9, 1e9].\n        // We choose a random starting point s in [ -1e9, 1e9 - (n-1) ] (if feasible),\n        // so that s + (n-1)*1 <= 1e9.\n        long long maxStart = 1000000000LL - (n - 1);\n        if (maxStart < -1000000000LL) {\n            // If n is so large we can't fit an arithmetic progression with step=1\n            // from within [-1e9, 1e9], just clamp it.\n            maxStart = -1000000000LL;\n        }\n        long long s = rnd.next(-1000000000LL, maxStart);\n        for (int i = 0; i < n; i++) {\n            coords[i] = s + i;\n        }\n    }\n    else if (type == \"extreme\") {\n        // Simply place the first city at -1e9 and then each subsequent city\n        // 1 unit apart. This fits in the range for n <= 100000.\n        // coords[i] = -1e9 + i\n        for (int i = 0; i < n; i++) {\n            coords[i] = -1000000000LL + i;\n        }\n    }\n    else {\n        // Default fallback: same as random\n        set<long long> used;\n        while ((int)used.size() < n) {\n            long long val = rnd.next(-1000000000LL, 1000000000LL);\n            used.insert(val);\n        }\n        int idx = 0;\n        for (auto v : used) {\n            coords[idx++] = v;\n        }\n        sort(coords.begin(), coords.end());\n    }\n\n    // Output the results:\n    // First line: n\n    // Second line: sorted distinct coordinates\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << coords[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below is a list of sample commands (20 lines) to run this generator.\n# Each command prints a single test case to stdout.\n# The user can capture or redirect as needed.\n# Notice we do NOT show how to compile (per instructions), nor do we use \"> filename\".\n\n./gen -n 2 -type random\n./gen -n 2 -type extreme\n./gen -n 3 -type allneg\n./gen -n 3 -type allpos\n./gen -n 4 -type mix\n./gen -n 5 -type small\n./gen -n 5 -type arithmetic\n./gen -n 10 -type random\n./gen -n 10 -type arithmetic\n./gen -n 10 -type mix\n./gen -n 15 -type random\n./gen -n 20 -type extreme\n./gen -n 50 -type allneg\n./gen -n 50 -type allpos\n./gen -n 50 -type mix\n./gen -n 100 -type random\n./gen -n 100 -type arithmetic\n./gen -n 99999 -type extreme\n./gen -n 99999 -type random\n./gen -n 100000 -type mix\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:51.861319",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "567/B",
      "title": "B. Berland National Library",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a positive integer n (1 ≤ n ≤ 100) — the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers).It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.",
      "output_spec": "OutputPrint a single integer — the minimum possible capacity of the reading room.",
      "sample_tests": "ExamplesInputCopy6+ 12001- 12001- 1- 1200+ 1+ 7OutputCopy3InputCopy2- 1- 2OutputCopy2InputCopy2+ 1- 1OutputCopy1",
      "description": "B. Berland National Library\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a positive integer n (1 ≤ n ≤ 100) — the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 106, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers).It is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.\n\nOutputPrint a single integer — the minimum possible capacity of the reading room.\n\nInputCopy6+ 12001- 12001- 1- 1200+ 1+ 7OutputCopy3InputCopy2- 1- 2OutputCopy2InputCopy2+ 1- 1OutputCopy1\n\nInputCopy6+ 12001- 12001- 1- 1200+ 1+ 7\n\nOutputCopy3\n\nInputCopy2- 1- 2\n\nOutputCopy2\n\nInputCopy2+ 1- 1\n\nOutputCopy1\n\nNoteIn the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.",
      "solutions": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!5th august 2015 at 19:00 MSK Codeforces Round #Pi will take place for second division participants. Participants from the first division are able to participate out of the contest.This is my first round on Codeforces. I hope you will enjoy the tasks and this will stimulate me to prepare new rounds! Wish you quick Accepted verdicts and successful hacks.I want to thank Michael Mirzayanov (MikeMirzayanov) for wonderful platforms Polygon and Codeforces and for help in preparing the tasks, Maxim Akhmedov (Zlobober) for help in contest preparation, Maria Belova for translation statements to english, and also my friends Danil Sagunov (danilka.pro) and Vitaliy Kudasov (kuviman) for solving the tasks.Participants will be given six tasks and two and the half hours for solving them. Scoring system will be announced closer to round start.UPD: Scoring: 500-1000-1500-2000-2500-2500.UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces",
          "content": "567A - Lineland MailOne can notice that the maximum cost of sending a letter from i'th city is equal to maximum of distances from i'th city to first city and from i'th city to last (max(abs(xi - x0), abs(xi - xn - 1)). On the other hand, the minimum cost of sending a letter will be the minimum of distances between neighboring cities (i - 1'th and i + 1'th cities), more formally, min(abs(xi - xi - 1), abs(xi - xi + 1). For each city, except the first and the last this formula is correct, but for them formulas are (abs(xi - xi + 1)) and (abs(xi - xi - 1)) respectively.Author solution567B - Berland National LibraryTo answer the queries correct, we need to know if the person is still in the library. For that purpose we will use in array of type bool. Also we will store two variables for the answer and ''current state'' (it will store the current number of people in the library). Let's call them ans and state respectively.Thus, if we are given query  + ai then we should increase state by one, mark that this person entered the library (in[ai] = true) and try to update the answer (ans = max(ans, state)).Otherwise we are given  - ai query. If the person who leaves the library, was in there, we should just decrease state by one. Otherwise, if this person was not in the library (in[ai] == false) and leaves now, he entered the library before we started counting. It means we should increase the answer by one anyway. Also one should not forget that it is needed to mark that the person has left the library (in[ai] = false).Author solution567C - Geometric ProgressionLet's solve this problem for fixed middle element of progression. This means that if we fix element ai then the progression must consist of ai / k and ai·k elements. It could not be possible, for example, if ai is not divisible by k ().For fixed middle element one could find the number of sequences by counting how many ai / k elements are placed left from fixed element and how many ai·k are placed right from it, and then multiplying this numbers. To do this, one could use two associative arrays Al and Ar, where for each key x will be stored count of occurences of x placed left (or right respectively) from current element. This could be done with map structure.Sum of values calculated as described above will give the answer to the problem.Author solution567D - One-Dimensional Battle ShipsFirst, we should understand when the game ends. It will happen when on the n-sized board it will be impossible to place k ships of size a. For segment with length len we could count the maximum number of ships with size a that could be placed on it. Each ship occupies a + 1 cells, except the last ship. Thus, for segment with length len the formula will look like (we add \"fictive\" cell to len cells to consider the last ship cell). This way, for [l..r] segment the formula should be . For solving the problem we should store all the [l..r] segments which has no ''free'' cells (none of them was shooted). One could use (std: : set) for that purpose. This way, before the shooting, there will be only one segment [1..n]. Also we will store current maximum number of ships we could place on a board. Before the shooting it is equal to .With every shoot in cell x we should find the segment containing shooted cell (let it be [l..r]), we should update segment set. First, we should delete [l..r] segment. It means we should decrease current maximum number of ships by and delete it from the set. Next, we need to add segments [l..x - 1] and [x + 1..r] to the set (they may not be correct, so you may need to add only one segments or do not add segments at all) and update the maximum number of ships properly. We should process shoots one by one, and when the maximum number of ships will become lesser than k, we must output the answer. If that never happen, output  - 1.Author solution567E - President and RoadsAt first, let's find edges that do not belong to any shortest paths from s to t. Let's find two shortest path arrays d1 and d2 with any shortest-path-finding algorithm. First array stores shortest path length from s, and the second — from t. Edge (u, v) then will be on at least one shortest path from s to t if and only if d1[u] + w(u, v) + d2[v] == d1[t].Let's build shortest path graph, leaving only edges described above. If we consider shortest path from s to t as segment [0..D] and any edge (u, v) in shortest path graph as its subsegment [d1[u]..d1[v]], then if such subsegment do not share any common point with any other edge subsegment, except its leftest and rightest point (d1[u] and d1[v]), this edge belongs to every shortest path from s to t.Now we could surely answer \"YES\" to such edges. Next part of the solution are much simple. If edge (u, v) do not belong to every shortest path, we could try decrease its weight. This edge will belong to every shortest path if and only if its weight will become d1[t] - d1[u] - d2[v] - 1. So, if this value are strictly positive, we should answer \"CAN\" considering new edge weight. Otherwise we need to output \"NO\".Author solution567F - MausoleumConsider that we are placing blocks by pairs, one pair by one, starting from leftmost and rightmost places. Thus, for example, two blocks of height 1 we could place in positions 1 and 2, 1 and 2n, or 2n - 1 and 2n. The segment of unused positions will be changed that way and the next block pairs should be placed on new leftmost and rightmost free places. At last only two positions will be free and we should place two blocks of height n on them.Any correct sequence of blocks could be builded that way. Let's try to review the requirements consider such way of placing blocks. As soon as we place blocks one by one, the requirements are now only describes the order of placing blocks. For example, requirement ''3 >= 5'' means that we should place block in position 3 only if block in position 5 is already placed (and thus it have lesser height), or we place pair of blocks of same height on them at one moment.For counting required number of sequences we will use dynamic programming approach. Let's count dp[l][r] — the number of ways to place some blocks in the way that only positions at segment [l..r] are free. The height of current placed pair of blocks is counted from the segment borders itself (. Fix one way of placing current block pair (exclusion is l =  = r + 1). Now check if such placing meets the requirements. We will consider only requirements that meets one of the current-placing positions. For every \"current\" position \"<\" must be true only for free positions (positions in [l..r], which do not equal to current positions), \">\" must be true for already-placed positions (out of [l..r]) and \"=\" must be true only for second current position.This DP could be easily calculated using \"lazy\" approach.Author solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 567\\s*B"
          },
          "content_length": 6829
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 1",
          "code": "left_border=k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 2",
          "code": "right_border=k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 3",
          "code": "total<number_of_ships",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 4",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 5",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 6",
          "code": "(len + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 7",
          "code": "l <= c <= r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 8",
          "code": "(len(l, r) + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 9",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 10",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 11",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 12",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 13",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 14",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 15",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 17",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 18",
          "code": "map<long long,long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 19",
          "code": "it=s.upper_bound(mp(mov[i],-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 20",
          "code": "it=s.upper_bound(mp(mov[i],n+1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 21",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 22",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 2",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 3",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 4",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 5",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 6",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 8",
          "code": "max_load_factor",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 9",
          "code": "unordered_map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 10",
          "code": "map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 11",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 12",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 13",
          "code": "auto it = xs.lower_bound(mp(x, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    unordered_map<int, char> last_event;\n    \n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == '+' || c == '-', \"Invalid event type '%c' at line %d\", c, i + 2);\n        \n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000, \"ri\");\n        inf.readEoln();\n        \n        if (last_event.count(ri)) {\n            ensuref(last_event[ri] != c, \"Two consecutive events of the same type '%c' for reader %d at line %d\", c, ri, i + 2);\n        }\n        last_event[ri] = c;\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    unordered_map<int, char> last_event;\n    \n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == '+' || c == '-', \"Invalid event type '%c' at line %d\", c, i + 2);\n        \n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000, \"ri\");\n        inf.readEoln();\n        \n        if (last_event.count(ri)) {\n            ensuref(last_event[ri] != c, \"Two consecutive events of the same type '%c' for reader %d at line %d\", c, ri, i + 2);\n        }\n        last_event[ri] = c;\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    unordered_map<int, char> last_event;\n    \n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == '+' || c == '-', \"Invalid event type '%c' at line %d\", c, i + 2);\n        \n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000, \"ri\");\n        inf.readEoln();\n        \n        if (last_event.count(ri)) {\n            ensuref(last_event[ri] != c, \"Two consecutive events of the same type '%c' for reader %d at line %d\", c, ri, i + 2);\n        }\n        last_event[ri] = c;\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Event {\n    char type; // '+' or '-'\n    int ri;    // registration number\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Event> events;\n    map<int, char> lastEvent; // last event type for each ri\n    set<int> used_ri;         // set of used registration numbers\n\n    int max_ri = 1e6;\n\n    if (type == \"random\") {\n        // Randomly generate events ensuring constraints are satisfied\n        while ((int)events.size() < n) {\n            // Decide to pick a new ri or existing ri\n            bool pick_new = (used_ri.empty() || rnd.next(0, 1) == 0);\n\n            if (pick_new) {\n                // Generate new ri\n                int ri;\n                do {\n                    ri = rnd.next(1, max_ri);\n                } while (used_ri.count(ri));\n\n                used_ri.insert(ri);\n\n                // Decide start with '+' or '-'\n                char start_type = rnd.next(0, 1) == 0 ? '+' : '-';\n                events.push_back({start_type, ri});\n                lastEvent[ri] = start_type;\n            } else {\n                // Pick existing ri\n                auto it = used_ri.begin();\n                advance(it, rnd.next(0, (int)used_ri.size() - 1));\n                int ri = *it;\n                char last = lastEvent[ri];\n                char next_type = (last == '+') ? '-' : '+';\n                events.push_back({next_type, ri});\n                lastEvent[ri] = next_type;\n            }\n        }\n    } else if (type == \"initial_in\") {\n        // All events start with '-'\n        int m = min(n, 50); // Number of initial visitors\n        // Generate initial visitors\n        for (int i = 0; i < m && (int)events.size() < n; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            // Start with '-'\n            events.push_back({'-', ri});\n            lastEvent[ri] = '-';\n        }\n        // Generate remaining events\n        while ((int)events.size() < n) {\n            // Pick existing ri and alternate event\n            auto it = used_ri.begin();\n            advance(it, rnd.next(0, (int)used_ri.size() - 1));\n            int ri = *it;\n            char last = lastEvent[ri];\n            char next_type = (last == '+') ? '-' : '+';\n            events.push_back({next_type, ri});\n            lastEvent[ri] = next_type;\n        }\n    } else if (type == \"ending_in\") {\n        // All events end with '+'\n        int m = min(n, 50); // Number of visitors\n        // Generate visitors\n        for (int i = 0; i < m && (int)events.size() < n; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            // Start with '+'\n            events.push_back({'+', ri});\n            lastEvent[ri] = '+';\n        }\n        // Generate remaining events\n        while ((int)events.size() < n) {\n            // Pick existing ri and alternate event\n            auto it = used_ri.begin();\n            advance(it, rnd.next(0, (int)used_ri.size() - 1));\n            int ri = *it;\n            char last = lastEvent[ri];\n            char next_type = (last == '+') ? '-' : '+';\n            events.push_back({next_type, ri});\n            lastEvent[ri] = next_type;\n        }\n    } else if (type == \"max_capacity\") {\n        // Generate events to maximize capacity\n        int m = min(n, 100); // Number of visitors\n        vector<int> ris;\n        for (int i = 0; i < m; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            ris.push_back(ri);\n        }\n        // All visitors enter\n        for (int i = 0; i < (int)ris.size() && (int)events.size() < n; ++i) {\n            events.push_back({'+', ris[i]});\n            lastEvent[ris[i]] = '+';\n        }\n        // Visitors leave one by one\n        for (int i = 0; i < (int)ris.size() && (int)events.size() < n; ++i) {\n            events.push_back({'-', ris[i]});\n            lastEvent[ris[i]] = '-';\n        }\n    } else if (type == \"alternating\") {\n        // Each visitor has alternating '+' and '-' events\n        int m = min(n, 50); // Number of visitors\n        for (int i = 0; i < m; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            char start_type = (i % 2 == 0) ? '+' : '-';\n            events.push_back({start_type, ri});\n            lastEvent[ri] = start_type;\n        }\n        // Generate remaining events\n        while ((int)events.size() < n) {\n            // Pick existing ri and alternate event\n            auto it = used_ri.begin();\n            advance(it, rnd.next(0, (int)used_ri.size() - 1));\n            int ri = *it;\n            char last = lastEvent[ri];\n            char next_type = (last == '+') ? '-' : '+';\n            events.push_back({next_type, ri});\n            lastEvent[ri] = next_type;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle events to mix them up\n    shuffle(events.begin(), events.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output events\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c %d\\n\", events[i].type, events[i].ri);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Event {\n    char type; // '+' or '-'\n    int ri;    // registration number\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Event> events;\n    map<int, char> lastEvent; // last event type for each ri\n    set<int> used_ri;         // set of used registration numbers\n\n    int max_ri = 1e6;\n\n    if (type == \"random\") {\n        // Randomly generate events ensuring constraints are satisfied\n        while ((int)events.size() < n) {\n            // Decide to pick a new ri or existing ri\n            bool pick_new = (used_ri.empty() || rnd.next(0, 1) == 0);\n\n            if (pick_new) {\n                // Generate new ri\n                int ri;\n                do {\n                    ri = rnd.next(1, max_ri);\n                } while (used_ri.count(ri));\n\n                used_ri.insert(ri);\n\n                // Decide start with '+' or '-'\n                char start_type = rnd.next(0, 1) == 0 ? '+' : '-';\n                events.push_back({start_type, ri});\n                lastEvent[ri] = start_type;\n            } else {\n                // Pick existing ri\n                auto it = used_ri.begin();\n                advance(it, rnd.next(0, (int)used_ri.size() - 1));\n                int ri = *it;\n                char last = lastEvent[ri];\n                char next_type = (last == '+') ? '-' : '+';\n                events.push_back({next_type, ri});\n                lastEvent[ri] = next_type;\n            }\n        }\n    } else if (type == \"initial_in\") {\n        // All events start with '-'\n        int m = min(n, 50); // Number of initial visitors\n        // Generate initial visitors\n        for (int i = 0; i < m && (int)events.size() < n; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            // Start with '-'\n            events.push_back({'-', ri});\n            lastEvent[ri] = '-';\n        }\n        // Generate remaining events\n        while ((int)events.size() < n) {\n            // Pick existing ri and alternate event\n            auto it = used_ri.begin();\n            advance(it, rnd.next(0, (int)used_ri.size() - 1));\n            int ri = *it;\n            char last = lastEvent[ri];\n            char next_type = (last == '+') ? '-' : '+';\n            events.push_back({next_type, ri});\n            lastEvent[ri] = next_type;\n        }\n    } else if (type == \"ending_in\") {\n        // All events end with '+'\n        int m = min(n, 50); // Number of visitors\n        // Generate visitors\n        for (int i = 0; i < m && (int)events.size() < n; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            // Start with '+'\n            events.push_back({'+', ri});\n            lastEvent[ri] = '+';\n        }\n        // Generate remaining events\n        while ((int)events.size() < n) {\n            // Pick existing ri and alternate event\n            auto it = used_ri.begin();\n            advance(it, rnd.next(0, (int)used_ri.size() - 1));\n            int ri = *it;\n            char last = lastEvent[ri];\n            char next_type = (last == '+') ? '-' : '+';\n            events.push_back({next_type, ri});\n            lastEvent[ri] = next_type;\n        }\n    } else if (type == \"max_capacity\") {\n        // Generate events to maximize capacity\n        int m = min(n, 100); // Number of visitors\n        vector<int> ris;\n        for (int i = 0; i < m; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            ris.push_back(ri);\n        }\n        // All visitors enter\n        for (int i = 0; i < (int)ris.size() && (int)events.size() < n; ++i) {\n            events.push_back({'+', ris[i]});\n            lastEvent[ris[i]] = '+';\n        }\n        // Visitors leave one by one\n        for (int i = 0; i < (int)ris.size() && (int)events.size() < n; ++i) {\n            events.push_back({'-', ris[i]});\n            lastEvent[ris[i]] = '-';\n        }\n    } else if (type == \"alternating\") {\n        // Each visitor has alternating '+' and '-' events\n        int m = min(n, 50); // Number of visitors\n        for (int i = 0; i < m; ++i) {\n            int ri;\n            do {\n                ri = rnd.next(1, max_ri);\n            } while (used_ri.count(ri));\n            used_ri.insert(ri);\n            char start_type = (i % 2 == 0) ? '+' : '-';\n            events.push_back({start_type, ri});\n            lastEvent[ri] = start_type;\n        }\n        // Generate remaining events\n        while ((int)events.size() < n) {\n            // Pick existing ri and alternate event\n            auto it = used_ri.begin();\n            advance(it, rnd.next(0, (int)used_ri.size() - 1));\n            int ri = *it;\n            char last = lastEvent[ri];\n            char next_type = (last == '+') ? '-' : '+';\n            events.push_back({next_type, ri});\n            lastEvent[ri] = next_type;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle events to mix them up\n    shuffle(events.begin(), events.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output events\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c %d\\n\", events[i].type, events[i].ri);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type initial_in\n./gen -n 1 -type ending_in\n./gen -n 1 -type max_capacity\n./gen -n 1 -type alternating\n\n./gen -n 2 -type random\n./gen -n 2 -type initial_in\n./gen -n 2 -type ending_in\n./gen -n 2 -type max_capacity\n./gen -n 2 -type alternating\n\n./gen -n 5 -type random\n./gen -n 5 -type initial_in\n./gen -n 5 -type ending_in\n./gen -n 5 -type max_capacity\n./gen -n 5 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type initial_in\n./gen -n 10 -type ending_in\n./gen -n 10 -type max_capacity\n./gen -n 10 -type alternating\n\n./gen -n 20 -type random\n./gen -n 20 -type initial_in\n./gen -n 20 -type ending_in\n./gen -n 20 -type max_capacity\n./gen -n 20 -type alternating\n\n./gen -n 50 -type random\n./gen -n 50 -type initial_in\n./gen -n 50 -type ending_in\n./gen -n 50 -type max_capacity\n./gen -n 50 -type alternating\n\n./gen -n 70 -type random\n./gen -n 70 -type initial_in\n./gen -n 70 -type ending_in\n./gen -n 70 -type max_capacity\n./gen -n 70 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type initial_in\n./gen -n 100 -type ending_in\n./gen -n 100 -type max_capacity\n./gen -n 100 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:54.011857",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "567/C",
      "title": "C. Geometric Progression",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers, n and k (1 ≤ n, k ≤ 2·105), showing how many numbers Polycarp's sequence has and his favorite number.The second line contains n integers a1, a2, ..., an ( - 109 ≤ ai ≤ 109) — elements of the sequence.",
      "output_spec": "OutputOutput a single number — the number of ways to choose a subsequence of length three, such that it forms a geometric progression with a common ratio k.",
      "sample_tests": "ExamplesInputCopy5 21 1 2 2 4OutputCopy4InputCopy3 11 1 1OutputCopy1InputCopy10 31 2 6 2 3 6 9 18 3 9OutputCopy6",
      "description": "C. Geometric Progression\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers, n and k (1 ≤ n, k ≤ 2·105), showing how many numbers Polycarp's sequence has and his favorite number.The second line contains n integers a1, a2, ..., an ( - 109 ≤ ai ≤ 109) — elements of the sequence.\n\nOutputOutput a single number — the number of ways to choose a subsequence of length three, such that it forms a geometric progression with a common ratio k.\n\nInputCopy5 21 1 2 2 4OutputCopy4InputCopy3 11 1 1OutputCopy1InputCopy10 31 2 6 2 3 6 9 18 3 9OutputCopy6\n\nInputCopy5 21 1 2 2 4\n\nOutputCopy4\n\nInputCopy3 11 1 1\n\nOutputCopy1\n\nInputCopy10 31 2 6 2 3 6 9 18 3 9\n\nOutputCopy6\n\nNoteIn the first sample test the answer is four, as any of the two 1s can be chosen as the first element, the second element can be any of the 2s, and the third element of the subsequence must be equal to 4.",
      "solutions": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!5th august 2015 at 19:00 MSK Codeforces Round #Pi will take place for second division participants. Participants from the first division are able to participate out of the contest.This is my first round on Codeforces. I hope you will enjoy the tasks and this will stimulate me to prepare new rounds! Wish you quick Accepted verdicts and successful hacks.I want to thank Michael Mirzayanov (MikeMirzayanov) for wonderful platforms Polygon and Codeforces and for help in preparing the tasks, Maxim Akhmedov (Zlobober) for help in contest preparation, Maria Belova for translation statements to english, and also my friends Danil Sagunov (danilka.pro) and Vitaliy Kudasov (kuviman) for solving the tasks.Participants will be given six tasks and two and the half hours for solving them. Scoring system will be announced closer to round start.UPD: Scoring: 500-1000-1500-2000-2500-2500.UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces",
          "content": "567A - Lineland MailOne can notice that the maximum cost of sending a letter from i'th city is equal to maximum of distances from i'th city to first city and from i'th city to last (max(abs(xi - x0), abs(xi - xn - 1)). On the other hand, the minimum cost of sending a letter will be the minimum of distances between neighboring cities (i - 1'th and i + 1'th cities), more formally, min(abs(xi - xi - 1), abs(xi - xi + 1). For each city, except the first and the last this formula is correct, but for them formulas are (abs(xi - xi + 1)) and (abs(xi - xi - 1)) respectively.Author solution567B - Berland National LibraryTo answer the queries correct, we need to know if the person is still in the library. For that purpose we will use in array of type bool. Also we will store two variables for the answer and ''current state'' (it will store the current number of people in the library). Let's call them ans and state respectively.Thus, if we are given query  + ai then we should increase state by one, mark that this person entered the library (in[ai] = true) and try to update the answer (ans = max(ans, state)).Otherwise we are given  - ai query. If the person who leaves the library, was in there, we should just decrease state by one. Otherwise, if this person was not in the library (in[ai] == false) and leaves now, he entered the library before we started counting. It means we should increase the answer by one anyway. Also one should not forget that it is needed to mark that the person has left the library (in[ai] = false).Author solution567C - Geometric ProgressionLet's solve this problem for fixed middle element of progression. This means that if we fix element ai then the progression must consist of ai / k and ai·k elements. It could not be possible, for example, if ai is not divisible by k ().For fixed middle element one could find the number of sequences by counting how many ai / k elements are placed left from fixed element and how many ai·k are placed right from it, and then multiplying this numbers. To do this, one could use two associative arrays Al and Ar, where for each key x will be stored count of occurences of x placed left (or right respectively) from current element. This could be done with map structure.Sum of values calculated as described above will give the answer to the problem.Author solution567D - One-Dimensional Battle ShipsFirst, we should understand when the game ends. It will happen when on the n-sized board it will be impossible to place k ships of size a. For segment with length len we could count the maximum number of ships with size a that could be placed on it. Each ship occupies a + 1 cells, except the last ship. Thus, for segment with length len the formula will look like (we add \"fictive\" cell to len cells to consider the last ship cell). This way, for [l..r] segment the formula should be . For solving the problem we should store all the [l..r] segments which has no ''free'' cells (none of them was shooted). One could use (std: : set) for that purpose. This way, before the shooting, there will be only one segment [1..n]. Also we will store current maximum number of ships we could place on a board. Before the shooting it is equal to .With every shoot in cell x we should find the segment containing shooted cell (let it be [l..r]), we should update segment set. First, we should delete [l..r] segment. It means we should decrease current maximum number of ships by and delete it from the set. Next, we need to add segments [l..x - 1] and [x + 1..r] to the set (they may not be correct, so you may need to add only one segments or do not add segments at all) and update the maximum number of ships properly. We should process shoots one by one, and when the maximum number of ships will become lesser than k, we must output the answer. If that never happen, output  - 1.Author solution567E - President and RoadsAt first, let's find edges that do not belong to any shortest paths from s to t. Let's find two shortest path arrays d1 and d2 with any shortest-path-finding algorithm. First array stores shortest path length from s, and the second — from t. Edge (u, v) then will be on at least one shortest path from s to t if and only if d1[u] + w(u, v) + d2[v] == d1[t].Let's build shortest path graph, leaving only edges described above. If we consider shortest path from s to t as segment [0..D] and any edge (u, v) in shortest path graph as its subsegment [d1[u]..d1[v]], then if such subsegment do not share any common point with any other edge subsegment, except its leftest and rightest point (d1[u] and d1[v]), this edge belongs to every shortest path from s to t.Now we could surely answer \"YES\" to such edges. Next part of the solution are much simple. If edge (u, v) do not belong to every shortest path, we could try decrease its weight. This edge will belong to every shortest path if and only if its weight will become d1[t] - d1[u] - d2[v] - 1. So, if this value are strictly positive, we should answer \"CAN\" considering new edge weight. Otherwise we need to output \"NO\".Author solution567F - MausoleumConsider that we are placing blocks by pairs, one pair by one, starting from leftmost and rightmost places. Thus, for example, two blocks of height 1 we could place in positions 1 and 2, 1 and 2n, or 2n - 1 and 2n. The segment of unused positions will be changed that way and the next block pairs should be placed on new leftmost and rightmost free places. At last only two positions will be free and we should place two blocks of height n on them.Any correct sequence of blocks could be builded that way. Let's try to review the requirements consider such way of placing blocks. As soon as we place blocks one by one, the requirements are now only describes the order of placing blocks. For example, requirement ''3 >= 5'' means that we should place block in position 3 only if block in position 5 is already placed (and thus it have lesser height), or we place pair of blocks of same height on them at one moment.For counting required number of sequences we will use dynamic programming approach. Let's count dp[l][r] — the number of ways to place some blocks in the way that only positions at segment [l..r] are free. The height of current placed pair of blocks is counted from the segment borders itself (. Fix one way of placing current block pair (exclusion is l =  = r + 1). Now check if such placing meets the requirements. We will consider only requirements that meets one of the current-placing positions. For every \"current\" position \"<\" must be true only for free positions (positions in [l..r], which do not equal to current positions), \">\" must be true for already-placed positions (out of [l..r]) and \"=\" must be true only for second current position.This DP could be easily calculated using \"lazy\" approach.Author solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 567\\s*C"
          },
          "content_length": 6829
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 1",
          "code": "left_border=k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 2",
          "code": "right_border=k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 3",
          "code": "total<number_of_ships",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 4",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 5",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 6",
          "code": "(len + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 7",
          "code": "l <= c <= r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 8",
          "code": "(len(l, r) + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 9",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 10",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 11",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 12",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 13",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 14",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 15",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 17",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 18",
          "code": "map<long long,long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 19",
          "code": "it=s.upper_bound(mp(mov[i],-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 20",
          "code": "it=s.upper_bound(mp(mov[i],n+1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 21",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 22",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 2",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 3",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 4",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 5",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 6",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 8",
          "code": "max_load_factor",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 9",
          "code": "unordered_map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 10",
          "code": "map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 11",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 12",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 13",
          "code": "auto it = xs.lower_bound(mp(x, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random integers in the range [-1e9, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_same\") {\n        // All elements are the same random integer\n        int x = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"increasing\") {\n        int x = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x + i;\n        }\n    } else if (type == \"decreasing\") {\n        int x = rnd.next(-1000000000 + n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x - i;\n        }\n    } else if (type == \"alternating\") {\n        int x = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? x : -x;\n        }\n    } else if (type == \"few_gp\") {\n        // Only a few triplets form GP\n        int m = n / 2;\n        int base = rnd.next(-1000, 1000);\n        if (base == 0) base = 1; // ensure base is not zero to avoid trivial GP\n        for (int i = 0; i < n; ++i) {\n            if (i == 0) {\n                a[i] = base;\n            } else if (i == m) {\n                a[i] = base * k;\n            } else if (i == n - 1) {\n                a[i] = base * k * k;\n            } else {\n                a[i] = rnd.next(-1000000000, 1000000000);\n            }\n        }\n    } else if (type == \"max_gp\") {\n        // Generate a sequence where as many triplets as possible form GP with ratio k\n        if (k == 1) {\n            int x = rnd.next(-1000000000, 1000000000);\n            for (int i = 0; i < n; ++i) {\n                a[i] = x;\n            }\n        } else {\n            int base = rnd.next(1, 1000);\n            int i = 0;\n            long long val = base;\n            while (i < n && val <= 1000000000) {\n                a[i++] = (int)val;\n                if (val > 1000000000 / k) break; // prevent overflow\n                val *= k;\n            }\n            // Fill the rest with random numbers\n            for (; i < n; ++i) {\n                a[i] = rnd.next(-1000000000, 1000000000);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random integers in the range [-1e9, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_same\") {\n        // All elements are the same random integer\n        int x = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"increasing\") {\n        int x = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x + i;\n        }\n    } else if (type == \"decreasing\") {\n        int x = rnd.next(-1000000000 + n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x - i;\n        }\n    } else if (type == \"alternating\") {\n        int x = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? x : -x;\n        }\n    } else if (type == \"few_gp\") {\n        // Only a few triplets form GP\n        int m = n / 2;\n        int base = rnd.next(-1000, 1000);\n        if (base == 0) base = 1; // ensure base is not zero to avoid trivial GP\n        for (int i = 0; i < n; ++i) {\n            if (i == 0) {\n                a[i] = base;\n            } else if (i == m) {\n                a[i] = base * k;\n            } else if (i == n - 1) {\n                a[i] = base * k * k;\n            } else {\n                a[i] = rnd.next(-1000000000, 1000000000);\n            }\n        }\n    } else if (type == \"max_gp\") {\n        // Generate a sequence where as many triplets as possible form GP with ratio k\n        if (k == 1) {\n            int x = rnd.next(-1000000000, 1000000000);\n            for (int i = 0; i < n; ++i) {\n                a[i] = x;\n            }\n        } else {\n            int base = rnd.next(1, 1000);\n            int i = 0;\n            long long val = base;\n            while (i < n && val <= 1000000000) {\n                a[i++] = (int)val;\n                if (val > 1000000000 / k) break; // prevent overflow\n                val *= k;\n            }\n            // Fill the rest with random numbers\n            for (; i < n; ++i) {\n                a[i] = rnd.next(-1000000000, 1000000000);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, k = 1\n./gen -n 5 -k 1 -type random\n./gen -n 5 -k 1 -type all_same\n./gen -n 5 -k 1 -type zeros\n\n# Small n, k != 1\n./gen -n 5 -k 2 -type random\n./gen -n 5 -k 2 -type all_same\n./gen -n 5 -k 2 -type zeros\n\n# Medium n, k = 1\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 1 -type all_same\n./gen -n 1000 -k 1 -type zeros\n\n# Medium n, k != 1\n./gen -n 1000 -k 2 -type random\n./gen -n 1000 -k 2 -type few_gp\n./gen -n 1000 -k 2 -type max_gp\n\n# Large n, k = 1\n./gen -n 200000 -k 1 -type random\n./gen -n 200000 -k 1 -type all_same\n./gen -n 200000 -k 1 -type zeros\n\n# Large n, large k\n./gen -n 200000 -k 100000 -type random\n./gen -n 200000 -k 100000 -type few_gp\n\n# n = maximum, k = small\n./gen -n 200000 -k 2 -type random\n./gen -n 200000 -k 2 -type few_gp\n./gen -n 200000 -k 2 -type max_gp\n\n# Edge cases\n./gen -n 1 -k 1 -type random\n\n./gen -n 2 -k 1 -type zeros\n\n./gen -n 2 -k 1 -type all_same\n\n# All ones\n./gen -n 200000 -k 1 -type all_ones\n\n./gen -n 200000 -k 1 -type decreasing\n\n./gen -n 200000 -k 1 -type increasing\n\n./gen -n 200000 -k 1 -type alternating\n\n# Negative numbers\n./gen -n 200000 -k 1 -type random\n\n# Zeros and negatives\n./gen -n 200000 -k 1 -type random\n\n# Test with maximum k\n./gen -n 200000 -k 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:56.166434",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "567/D",
      "title": "D. One-Dimensional Battle Ships",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers: n, k and a (1 ≤ n, k, a ≤ 2·105) — the size of the field, the number of the ships and the size of each ship. It is guaranteed that the n, k and a are such that you can put k ships of size a on the field, so that no two ships intersect or touch each other.The second line contains integer m (1 ≤ m ≤ n) — the number of Bob's moves.The third line contains m distinct integers x1, x2, ..., xm, where xi is the number of the cell where Bob made the i-th shot. The cells are numbered from left to right from 1 to n.",
      "output_spec": "OutputPrint a single integer — the number of such Bob's first move, after which you can be sure that Alice lied. Bob's moves are numbered from 1 to m in the order the were made. If the sought move doesn't exist, then print \"-1\".",
      "sample_tests": "ExamplesInputCopy11 3 354 8 6 1 11OutputCopy3InputCopy5 1 321 5OutputCopy-1InputCopy5 1 313OutputCopy1",
      "description": "D. One-Dimensional Battle Ships\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three integers: n, k and a (1 ≤ n, k, a ≤ 2·105) — the size of the field, the number of the ships and the size of each ship. It is guaranteed that the n, k and a are such that you can put k ships of size a on the field, so that no two ships intersect or touch each other.The second line contains integer m (1 ≤ m ≤ n) — the number of Bob's moves.The third line contains m distinct integers x1, x2, ..., xm, where xi is the number of the cell where Bob made the i-th shot. The cells are numbered from left to right from 1 to n.\n\nOutputPrint a single integer — the number of such Bob's first move, after which you can be sure that Alice lied. Bob's moves are numbered from 1 to m in the order the were made. If the sought move doesn't exist, then print \"-1\".\n\nInputCopy11 3 354 8 6 1 11OutputCopy3InputCopy5 1 321 5OutputCopy-1InputCopy5 1 313OutputCopy1\n\nInputCopy11 3 354 8 6 1 11\n\nOutputCopy3\n\nInputCopy5 1 321 5\n\nOutputCopy-1\n\nInputCopy5 1 313\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!5th august 2015 at 19:00 MSK Codeforces Round #Pi will take place for second division participants. Participants from the first division are able to participate out of the contest.This is my first round on Codeforces. I hope you will enjoy the tasks and this will stimulate me to prepare new rounds! Wish you quick Accepted verdicts and successful hacks.I want to thank Michael Mirzayanov (MikeMirzayanov) for wonderful platforms Polygon and Codeforces and for help in preparing the tasks, Maxim Akhmedov (Zlobober) for help in contest preparation, Maria Belova for translation statements to english, and also my friends Danil Sagunov (danilka.pro) and Vitaliy Kudasov (kuviman) for solving the tasks.Participants will be given six tasks and two and the half hours for solving them. Scoring system will be announced closer to round start.UPD: Scoring: 500-1000-1500-2000-2500-2500.UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces",
          "content": "567A - Lineland MailOne can notice that the maximum cost of sending a letter from i'th city is equal to maximum of distances from i'th city to first city and from i'th city to last (max(abs(xi - x0), abs(xi - xn - 1)). On the other hand, the minimum cost of sending a letter will be the minimum of distances between neighboring cities (i - 1'th and i + 1'th cities), more formally, min(abs(xi - xi - 1), abs(xi - xi + 1). For each city, except the first and the last this formula is correct, but for them formulas are (abs(xi - xi + 1)) and (abs(xi - xi - 1)) respectively.Author solution567B - Berland National LibraryTo answer the queries correct, we need to know if the person is still in the library. For that purpose we will use in array of type bool. Also we will store two variables for the answer and ''current state'' (it will store the current number of people in the library). Let's call them ans and state respectively.Thus, if we are given query  + ai then we should increase state by one, mark that this person entered the library (in[ai] = true) and try to update the answer (ans = max(ans, state)).Otherwise we are given  - ai query. If the person who leaves the library, was in there, we should just decrease state by one. Otherwise, if this person was not in the library (in[ai] == false) and leaves now, he entered the library before we started counting. It means we should increase the answer by one anyway. Also one should not forget that it is needed to mark that the person has left the library (in[ai] = false).Author solution567C - Geometric ProgressionLet's solve this problem for fixed middle element of progression. This means that if we fix element ai then the progression must consist of ai / k and ai·k elements. It could not be possible, for example, if ai is not divisible by k ().For fixed middle element one could find the number of sequences by counting how many ai / k elements are placed left from fixed element and how many ai·k are placed right from it, and then multiplying this numbers. To do this, one could use two associative arrays Al and Ar, where for each key x will be stored count of occurences of x placed left (or right respectively) from current element. This could be done with map structure.Sum of values calculated as described above will give the answer to the problem.Author solution567D - One-Dimensional Battle ShipsFirst, we should understand when the game ends. It will happen when on the n-sized board it will be impossible to place k ships of size a. For segment with length len we could count the maximum number of ships with size a that could be placed on it. Each ship occupies a + 1 cells, except the last ship. Thus, for segment with length len the formula will look like (we add \"fictive\" cell to len cells to consider the last ship cell). This way, for [l..r] segment the formula should be . For solving the problem we should store all the [l..r] segments which has no ''free'' cells (none of them was shooted). One could use (std: : set) for that purpose. This way, before the shooting, there will be only one segment [1..n]. Also we will store current maximum number of ships we could place on a board. Before the shooting it is equal to .With every shoot in cell x we should find the segment containing shooted cell (let it be [l..r]), we should update segment set. First, we should delete [l..r] segment. It means we should decrease current maximum number of ships by and delete it from the set. Next, we need to add segments [l..x - 1] and [x + 1..r] to the set (they may not be correct, so you may need to add only one segments or do not add segments at all) and update the maximum number of ships properly. We should process shoots one by one, and when the maximum number of ships will become lesser than k, we must output the answer. If that never happen, output  - 1.Author solution567E - President and RoadsAt first, let's find edges that do not belong to any shortest paths from s to t. Let's find two shortest path arrays d1 and d2 with any shortest-path-finding algorithm. First array stores shortest path length from s, and the second — from t. Edge (u, v) then will be on at least one shortest path from s to t if and only if d1[u] + w(u, v) + d2[v] == d1[t].Let's build shortest path graph, leaving only edges described above. If we consider shortest path from s to t as segment [0..D] and any edge (u, v) in shortest path graph as its subsegment [d1[u]..d1[v]], then if such subsegment do not share any common point with any other edge subsegment, except its leftest and rightest point (d1[u] and d1[v]), this edge belongs to every shortest path from s to t.Now we could surely answer \"YES\" to such edges. Next part of the solution are much simple. If edge (u, v) do not belong to every shortest path, we could try decrease its weight. This edge will belong to every shortest path if and only if its weight will become d1[t] - d1[u] - d2[v] - 1. So, if this value are strictly positive, we should answer \"CAN\" considering new edge weight. Otherwise we need to output \"NO\".Author solution567F - MausoleumConsider that we are placing blocks by pairs, one pair by one, starting from leftmost and rightmost places. Thus, for example, two blocks of height 1 we could place in positions 1 and 2, 1 and 2n, or 2n - 1 and 2n. The segment of unused positions will be changed that way and the next block pairs should be placed on new leftmost and rightmost free places. At last only two positions will be free and we should place two blocks of height n on them.Any correct sequence of blocks could be builded that way. Let's try to review the requirements consider such way of placing blocks. As soon as we place blocks one by one, the requirements are now only describes the order of placing blocks. For example, requirement ''3 >= 5'' means that we should place block in position 3 only if block in position 5 is already placed (and thus it have lesser height), or we place pair of blocks of same height on them at one moment.For counting required number of sequences we will use dynamic programming approach. Let's count dp[l][r] — the number of ways to place some blocks in the way that only positions at segment [l..r] are free. The height of current placed pair of blocks is counted from the segment borders itself (. Fix one way of placing current block pair (exclusion is l =  = r + 1). Now check if such placing meets the requirements. We will consider only requirements that meets one of the current-placing positions. For every \"current\" position \"<\" must be true only for free positions (positions in [l..r], which do not equal to current positions), \">\" must be true for already-placed positions (out of [l..r]) and \"=\" must be true only for second current position.This DP could be easily calculated using \"lazy\" approach.Author solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 567\\s*D"
          },
          "content_length": 6829
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 1",
          "code": "left_border=k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 2",
          "code": "right_border=k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 3",
          "code": "total<number_of_ships",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 4",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 5",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 6",
          "code": "(len + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 7",
          "code": "l <= c <= r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 8",
          "code": "(len(l, r) + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 9",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 10",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 11",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 12",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 13",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 14",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 15",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 17",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 18",
          "code": "map<long long,long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 19",
          "code": "it=s.upper_bound(mp(mov[i],-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 20",
          "code": "it=s.upper_bound(mp(mov[i],n+1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 21",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 22",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 2",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 3",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 4",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 5",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 6",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 8",
          "code": "max_load_factor",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 9",
          "code": "unordered_map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 10",
          "code": "map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 11",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 12",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 13",
          "code": "auto it = xs.lower_bound(mp(x, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(1, 200000, \"a\");\n    inf.readEoln();\n\n    long long min_length_needed = (long long)k * a + (k - 1);\n    ensuref(n >= min_length_needed, \"Cannot place the ships without overlapping or touching\");\n\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(m, 1, n, \"x_i\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == m, \"Positions xi must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(1, 200000, \"a\");\n    inf.readEoln();\n\n    long long min_length_needed = (long long)k * a + (k - 1);\n    ensuref(n >= min_length_needed, \"Cannot place the ships without overlapping or touching\");\n\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(m, 1, n, \"x_i\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == m, \"Positions xi must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(1, 200000, \"a\");\n    inf.readEoln();\n\n    long long min_length_needed = (long long)k * a + (k - 1);\n    ensuref(n >= min_length_needed, \"Cannot place the ships without overlapping or touching\");\n\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(m, 1, n, \"x_i\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == m, \"Positions xi must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    int a = opt<int>(\"a\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within bounds\n    n = max(1, min(n, 200000));\n\n    // Generate 'a' if not provided\n    if (a == -1) {\n        a = rnd.next(1, n);\n    } else {\n        a = max(1, min(a, 200000));\n    }\n\n    // Calculate maximum possible 'k' for given 'n' and 'a'\n    int max_k = (n + 1) / (a + 1);\n\n    // Generate 'k' if not provided\n    if (k == -1) {\n        k = rnd.next(1, max_k);\n    } else {\n        k = max(1, min(k, max_k));\n    }\n\n    // Ensure that k ships can be placed without touching\n    int min_required_n = k * a + (k - 1);\n    if (min_required_n > n) {\n        n = min_required_n;\n        if (n > 200000) {\n            fprintf(stderr, \"Cannot fit %d ships of size %d into %d cells\\n\", k, a, n);\n            exit(1);\n        }\n    }\n\n    // Adjust parameters based on type\n    if (type == \"max_ships\") {\n        k = max_k;\n    } else if (type == \"min_ships\") {\n        k = 1;\n    } else if (type == \"max_a\") {\n        a = n;\n        k = 1;\n    } else if (type == \"min_a\") {\n        a = 1;\n        max_k = (n + 1) / (a + 1);\n        if (k == -1) k = rnd.next(1, max_k);\n        k = max(1, min(k, max_k));\n    } else if (type == \"large_m\") {\n        m = n;\n    } else if (type == \"small_m\") {\n        m = 1;\n    }\n\n    // Generate 'm' if not provided\n    if (m == -1) {\n        m = rnd.next(1, n);\n    } else {\n        m = max(1, min(m, n));\n    }\n\n    // Generate m distinct shot positions\n    vector<int> x(n);\n    for (int i = 1; i <= n; ++i) {\n        x[i - 1] = i;\n    }\n    shuffle(x.begin(), x.end());\n    x.resize(m);\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, k, a);\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", x[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    int a = opt<int>(\"a\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within bounds\n    n = max(1, min(n, 200000));\n\n    // Generate 'a' if not provided\n    if (a == -1) {\n        a = rnd.next(1, n);\n    } else {\n        a = max(1, min(a, 200000));\n    }\n\n    // Calculate maximum possible 'k' for given 'n' and 'a'\n    int max_k = (n + 1) / (a + 1);\n\n    // Generate 'k' if not provided\n    if (k == -1) {\n        k = rnd.next(1, max_k);\n    } else {\n        k = max(1, min(k, max_k));\n    }\n\n    // Ensure that k ships can be placed without touching\n    int min_required_n = k * a + (k - 1);\n    if (min_required_n > n) {\n        n = min_required_n;\n        if (n > 200000) {\n            fprintf(stderr, \"Cannot fit %d ships of size %d into %d cells\\n\", k, a, n);\n            exit(1);\n        }\n    }\n\n    // Adjust parameters based on type\n    if (type == \"max_ships\") {\n        k = max_k;\n    } else if (type == \"min_ships\") {\n        k = 1;\n    } else if (type == \"max_a\") {\n        a = n;\n        k = 1;\n    } else if (type == \"min_a\") {\n        a = 1;\n        max_k = (n + 1) / (a + 1);\n        if (k == -1) k = rnd.next(1, max_k);\n        k = max(1, min(k, max_k));\n    } else if (type == \"large_m\") {\n        m = n;\n    } else if (type == \"small_m\") {\n        m = 1;\n    }\n\n    // Generate 'm' if not provided\n    if (m == -1) {\n        m = rnd.next(1, n);\n    } else {\n        m = max(1, min(m, n));\n    }\n\n    // Generate m distinct shot positions\n    vector<int> x(n);\n    for (int i = 1; i <= n; ++i) {\n        x[i - 1] = i;\n    }\n    shuffle(x.begin(), x.end());\n    x.resize(m);\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, k, a);\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", x[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small field with random parameters\n./gen -n 10 -k 2 -a 3 -m 5 -type random\n./gen -n 10 -k 1 -a 5 -m 3 -type min_ships\n./gen -n 10 -a 2 -type max_ships\n\n# Medium-sized field with varying ship sizes\n./gen -n 1000 -a 1 -type max_ships\n./gen -n 1000 -a 500 -k 1 -m 100 -type random\n./gen -n 1000 -a 5 -k 50 -m 200 -type random\n\n# Large field with maximum number of ships\n./gen -n 200000 -a 1 -type max_ships\n./gen -n 200000 -a 1 -k 100000 -m 100000 -type random\n\n# Test cases with minimum ship size\n./gen -n 1000 -type min_a\n./gen -n 200000 -type min_a\n\n# Test cases with maximum ship size\n./gen -n 1000 -type max_a\n./gen -n 200000 -type max_a\n\n# Test cases with maximum number of moves\n./gen -n 1000 -m 1000 -type large_m\n./gen -n 200000 -m 200000 -type large_m\n\n# Test cases with minimum number of moves\n./gen -n 1000 -m 1 -type small_m\n./gen -n 200000 -m 1 -type small_m\n\n# Edge cases with minimal parameters\n./gen -n 1 -k 1 -a 1 -m 1 -type random\n./gen -n 2 -k 1 -a 1 -m 2 -type random\n\n# Random test cases with varying field sizes\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n./gen -n 150000 -type random\n./gen -n 200000 -type random\n\n# Test cases with ships placed densely\n./gen -n 100000 -a 2 -type max_ships\n./gen -n 200000 -a 3 -type max_ships\n\n# Test cases with ships placed sparsely\n./gen -n 100000 -k 1 -a 1 -type min_ships\n./gen -n 200000 -k 1 -a 100000 -type min_ships\n\n# Random test cases with specified number of ships and moves\n./gen -n 100000 -k 50000 -a 2 -m 50000 -type random\n./gen -n 200000 -k 100000 -a 1 -m 100000 -type random\n\n# Maximum field size with random parameters\n./gen -n 200000 -k 100000 -a 1 -m 150000 -type random\n./gen -n 200000 -k 50000 -a 2 -m 200000 -type random\n\n# Small field with maximum ship size\n./gen -n 5 -type max_a\n./gen -n 10 -type max_a\n\n# Medium field with minimum ship size\n./gen -n 5000 -type min_a\n./gen -n 10000 -type min_a\n\n# Test cases with random parameters and maximum number of moves\n./gen -n 100000 -m 100000 -type random\n./gen -n 200000 -m 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:49:58.441004",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "567/E",
      "title": "E. President and Roads",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first lines contain four integers n, m, s and t (2 ≤ n ≤ 105; 1 ≤ m ≤ 105; 1 ≤ s, t ≤ n) — the number of cities and roads in Berland, the numbers of the capital and of the Presidents' home town (s ≠ t).Next m lines contain the roads. Each road is given as a group of three integers ai, bi, li (1 ≤ ai, bi ≤ n; ai ≠ bi; 1 ≤ li ≤ 106) — the cities that are connected by the i-th road and the time needed to ride along it. The road is directed from city ai to city bi.The cities are numbered from 1 to n. Each pair of cities can have multiple roads between them. It is guaranteed that there is a path from s to t along the roads.",
      "output_spec": "OutputPrint m lines. The i-th line should contain information about the i-th road (the roads are numbered in the order of appearance in the input).If the president will definitely ride along it during his travels, the line must contain a single word \"YES\" (without the quotes).Otherwise, if the i-th road can be repaired so that the travel time on it remains positive and then president will definitely ride along it, print space-separated word \"CAN\" (without the quotes), and the minimum cost of repairing.If we can't make the road be such that president will definitely ride along it, print \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy6 7 1 61 2 21 3 102 3 72 4 83 5 34 5 25 6 1OutputCopyYESCAN 2CAN 1CAN 1CAN 1CAN 1YESInputCopy3 3 1 31 2 102 3 101 3 100OutputCopyYESYESCAN 81InputCopy2 2 1 21 2 11 2 2OutputCopyYESNO",
      "description": "E. President and Roads\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first lines contain four integers n, m, s and t (2 ≤ n ≤ 105; 1 ≤ m ≤ 105; 1 ≤ s, t ≤ n) — the number of cities and roads in Berland, the numbers of the capital and of the Presidents' home town (s ≠ t).Next m lines contain the roads. Each road is given as a group of three integers ai, bi, li (1 ≤ ai, bi ≤ n; ai ≠ bi; 1 ≤ li ≤ 106) — the cities that are connected by the i-th road and the time needed to ride along it. The road is directed from city ai to city bi.The cities are numbered from 1 to n. Each pair of cities can have multiple roads between them. It is guaranteed that there is a path from s to t along the roads.\n\nOutputPrint m lines. The i-th line should contain information about the i-th road (the roads are numbered in the order of appearance in the input).If the president will definitely ride along it during his travels, the line must contain a single word \"YES\" (without the quotes).Otherwise, if the i-th road can be repaired so that the travel time on it remains positive and then president will definitely ride along it, print space-separated word \"CAN\" (without the quotes), and the minimum cost of repairing.If we can't make the road be such that president will definitely ride along it, print \"NO\" (without the quotes).\n\nInputCopy6 7 1 61 2 21 3 102 3 72 4 83 5 34 5 25 6 1OutputCopyYESCAN 2CAN 1CAN 1CAN 1CAN 1YESInputCopy3 3 1 31 2 102 3 101 3 100OutputCopyYESYESCAN 81InputCopy2 2 1 21 2 11 2 2OutputCopyYESNO\n\nInputCopy6 7 1 61 2 21 3 102 3 72 4 83 5 34 5 25 6 1\n\nOutputCopyYESCAN 2CAN 1CAN 1CAN 1CAN 1YES\n\nInputCopy3 3 1 31 2 102 3 101 3 100\n\nOutputCopyYESYESCAN 81\n\nInputCopy2 2 1 21 2 11 2 2\n\nOutputCopyYESNO\n\nNoteThe cost of repairing the road is the difference between the time needed to ride along it before and after the repairing.In the first sample president initially may choose one of the two following ways for a ride: 1 → 2 → 4 → 5 → 6 or 1 → 2 → 3 → 5 → 6.",
      "solutions": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!5th august 2015 at 19:00 MSK Codeforces Round #Pi will take place for second division participants. Participants from the first division are able to participate out of the contest.This is my first round on Codeforces. I hope you will enjoy the tasks and this will stimulate me to prepare new rounds! Wish you quick Accepted verdicts and successful hacks.I want to thank Michael Mirzayanov (MikeMirzayanov) for wonderful platforms Polygon and Codeforces and for help in preparing the tasks, Maxim Akhmedov (Zlobober) for help in contest preparation, Maria Belova for translation statements to english, and also my friends Danil Sagunov (danilka.pro) and Vitaliy Kudasov (kuviman) for solving the tasks.Participants will be given six tasks and two and the half hours for solving them. Scoring system will be announced closer to round start.UPD: Scoring: 500-1000-1500-2000-2500-2500.UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces",
          "content": "567A - Lineland MailOne can notice that the maximum cost of sending a letter from i'th city is equal to maximum of distances from i'th city to first city and from i'th city to last (max(abs(xi - x0), abs(xi - xn - 1)). On the other hand, the minimum cost of sending a letter will be the minimum of distances between neighboring cities (i - 1'th and i + 1'th cities), more formally, min(abs(xi - xi - 1), abs(xi - xi + 1). For each city, except the first and the last this formula is correct, but for them formulas are (abs(xi - xi + 1)) and (abs(xi - xi - 1)) respectively.Author solution567B - Berland National LibraryTo answer the queries correct, we need to know if the person is still in the library. For that purpose we will use in array of type bool. Also we will store two variables for the answer and ''current state'' (it will store the current number of people in the library). Let's call them ans and state respectively.Thus, if we are given query  + ai then we should increase state by one, mark that this person entered the library (in[ai] = true) and try to update the answer (ans = max(ans, state)).Otherwise we are given  - ai query. If the person who leaves the library, was in there, we should just decrease state by one. Otherwise, if this person was not in the library (in[ai] == false) and leaves now, he entered the library before we started counting. It means we should increase the answer by one anyway. Also one should not forget that it is needed to mark that the person has left the library (in[ai] = false).Author solution567C - Geometric ProgressionLet's solve this problem for fixed middle element of progression. This means that if we fix element ai then the progression must consist of ai / k and ai·k elements. It could not be possible, for example, if ai is not divisible by k ().For fixed middle element one could find the number of sequences by counting how many ai / k elements are placed left from fixed element and how many ai·k are placed right from it, and then multiplying this numbers. To do this, one could use two associative arrays Al and Ar, where for each key x will be stored count of occurences of x placed left (or right respectively) from current element. This could be done with map structure.Sum of values calculated as described above will give the answer to the problem.Author solution567D - One-Dimensional Battle ShipsFirst, we should understand when the game ends. It will happen when on the n-sized board it will be impossible to place k ships of size a. For segment with length len we could count the maximum number of ships with size a that could be placed on it. Each ship occupies a + 1 cells, except the last ship. Thus, for segment with length len the formula will look like (we add \"fictive\" cell to len cells to consider the last ship cell). This way, for [l..r] segment the formula should be . For solving the problem we should store all the [l..r] segments which has no ''free'' cells (none of them was shooted). One could use (std: : set) for that purpose. This way, before the shooting, there will be only one segment [1..n]. Also we will store current maximum number of ships we could place on a board. Before the shooting it is equal to .With every shoot in cell x we should find the segment containing shooted cell (let it be [l..r]), we should update segment set. First, we should delete [l..r] segment. It means we should decrease current maximum number of ships by and delete it from the set. Next, we need to add segments [l..x - 1] and [x + 1..r] to the set (they may not be correct, so you may need to add only one segments or do not add segments at all) and update the maximum number of ships properly. We should process shoots one by one, and when the maximum number of ships will become lesser than k, we must output the answer. If that never happen, output  - 1.Author solution567E - President and RoadsAt first, let's find edges that do not belong to any shortest paths from s to t. Let's find two shortest path arrays d1 and d2 with any shortest-path-finding algorithm. First array stores shortest path length from s, and the second — from t. Edge (u, v) then will be on at least one shortest path from s to t if and only if d1[u] + w(u, v) + d2[v] == d1[t].Let's build shortest path graph, leaving only edges described above. If we consider shortest path from s to t as segment [0..D] and any edge (u, v) in shortest path graph as its subsegment [d1[u]..d1[v]], then if such subsegment do not share any common point with any other edge subsegment, except its leftest and rightest point (d1[u] and d1[v]), this edge belongs to every shortest path from s to t.Now we could surely answer \"YES\" to such edges. Next part of the solution are much simple. If edge (u, v) do not belong to every shortest path, we could try decrease its weight. This edge will belong to every shortest path if and only if its weight will become d1[t] - d1[u] - d2[v] - 1. So, if this value are strictly positive, we should answer \"CAN\" considering new edge weight. Otherwise we need to output \"NO\".Author solution567F - MausoleumConsider that we are placing blocks by pairs, one pair by one, starting from leftmost and rightmost places. Thus, for example, two blocks of height 1 we could place in positions 1 and 2, 1 and 2n, or 2n - 1 and 2n. The segment of unused positions will be changed that way and the next block pairs should be placed on new leftmost and rightmost free places. At last only two positions will be free and we should place two blocks of height n on them.Any correct sequence of blocks could be builded that way. Let's try to review the requirements consider such way of placing blocks. As soon as we place blocks one by one, the requirements are now only describes the order of placing blocks. For example, requirement ''3 >= 5'' means that we should place block in position 3 only if block in position 5 is already placed (and thus it have lesser height), or we place pair of blocks of same height on them at one moment.For counting required number of sequences we will use dynamic programming approach. Let's count dp[l][r] — the number of ways to place some blocks in the way that only positions at segment [l..r] are free. The height of current placed pair of blocks is counted from the segment borders itself (. Fix one way of placing current block pair (exclusion is l =  = r + 1). Now check if such placing meets the requirements. We will consider only requirements that meets one of the current-placing positions. For every \"current\" position \"<\" must be true only for free positions (positions in [l..r], which do not equal to current positions), \">\" must be true for already-placed positions (out of [l..r]) and \"=\" must be true only for second current position.This DP could be easily calculated using \"lazy\" approach.Author solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 567\\s*E"
          },
          "content_length": 6829
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 1",
          "code": "left_border=k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 2",
          "code": "right_border=k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 3",
          "code": "total<number_of_ships",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 4",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 5",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 6",
          "code": "(len + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 7",
          "code": "l <= c <= r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 8",
          "code": "(len(l, r) + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 9",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 10",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 11",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 12",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 13",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 14",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 15",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 17",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 18",
          "code": "map<long long,long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 19",
          "code": "it=s.upper_bound(mp(mov[i],-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 20",
          "code": "it=s.upper_bound(mp(mov[i],n+1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 21",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 22",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 2",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 3",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 4",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 5",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 6",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 8",
          "code": "max_load_factor",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 9",
          "code": "unordered_map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 10",
          "code": "map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 11",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 12",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 13",
          "code": "auto it = xs.lower_bound(mp(x, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 100000;\n    const int MAX_M = 100000;\n    const int MAX_L = 1000000;\n\n    int n = inf.readInt(2, MAX_N, \"n\"); // n in [2, 1e5]\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\"); // m in [1, 1e5]\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\"); // s in [1, n]\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\"); // t in [1, n]\n    inf.readEoln();\n\n    ensuref(s != t, \"s (%d) should not equal t (%d)\", s, t);\n\n    vector<vector<int>> adj(n + 1); // adjacency list for the graph\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\"); // ai in [1, n]\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\"); // bi in [1, n]\n        ensuref(ai != bi, \"Edge %d connects node to itself (%d to %d)\", i + 1, ai, bi);\n        inf.readSpace();\n        int li = inf.readInt(1, MAX_L, \"li\"); // li in [1, 1e6]\n        inf.readEoln();\n\n        adj[ai].push_back(bi); // add edge to adjacency list\n    }\n\n    // Check if there is a path from s to t\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n\n    visited[s] = true;\n    q.push(s);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    ensuref(visited[t], \"Node t (%d) is not reachable from s (%d)\", t, s);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 100000;\n    const int MAX_M = 100000;\n    const int MAX_L = 1000000;\n\n    int n = inf.readInt(2, MAX_N, \"n\"); // n in [2, 1e5]\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\"); // m in [1, 1e5]\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\"); // s in [1, n]\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\"); // t in [1, n]\n    inf.readEoln();\n\n    ensuref(s != t, \"s (%d) should not equal t (%d)\", s, t);\n\n    vector<vector<int>> adj(n + 1); // adjacency list for the graph\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\"); // ai in [1, n]\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\"); // bi in [1, n]\n        ensuref(ai != bi, \"Edge %d connects node to itself (%d to %d)\", i + 1, ai, bi);\n        inf.readSpace();\n        int li = inf.readInt(1, MAX_L, \"li\"); // li in [1, 1e6]\n        inf.readEoln();\n\n        adj[ai].push_back(bi); // add edge to adjacency list\n    }\n\n    // Check if there is a path from s to t\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n\n    visited[s] = true;\n    q.push(s);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    ensuref(visited[t], \"Node t (%d) is not reachable from s (%d)\", t, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 100000;\n    const int MAX_M = 100000;\n    const int MAX_L = 1000000;\n\n    int n = inf.readInt(2, MAX_N, \"n\"); // n in [2, 1e5]\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\"); // m in [1, 1e5]\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\"); // s in [1, n]\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\"); // t in [1, n]\n    inf.readEoln();\n\n    ensuref(s != t, \"s (%d) should not equal t (%d)\", s, t);\n\n    vector<vector<int>> adj(n + 1); // adjacency list for the graph\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\"); // ai in [1, n]\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\"); // bi in [1, n]\n        ensuref(ai != bi, \"Edge %d connects node to itself (%d to %d)\", i + 1, ai, bi);\n        inf.readSpace();\n        int li = inf.readInt(1, MAX_L, \"li\"); // li in [1, 1e6]\n        inf.readEoln();\n\n        adj[ai].push_back(bi); // add edge to adjacency list\n    }\n\n    // Check if there is a path from s to t\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n\n    visited[s] = true;\n    q.push(s);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    ensuref(visited[t], \"Node t (%d) is not reachable from s (%d)\", t, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\", 1);\n    int t = opt<int>(\"t\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n ≥ 2\n    ensure(n >= 2 && n <= 100000);\n    // Ensure s ≠ t\n    ensure(s != t);\n    // Ensure s, t ∈ [1, n]\n    ensure(1 <= s && s <= n);\n    ensure(1 <= t && t <= n);\n\n    // Ensure 1 ≤ m ≤ 1e5\n    ensure(1 <= m && m <= 100000);\n\n    vector<pair<pair<int,int>, int>> edges;\n\n    if (type == \"random\") {\n        // Generate random edges\n        // First, ensure there is at least one path from s to t\n        // Then, add random edges to reach m edges\n\n        // Create a random path from s to t\n\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                nodes.push_back(i);\n            }\n        }\n\n        shuffle(nodes.begin(), nodes.end());\n\n        vector<int> path;\n        path.push_back(s);\n        for (int node : nodes) {\n            path.push_back(node);\n        }\n        path.push_back(t);\n\n        // Create edges along this path with li = random number\n\n        for (size_t i = 0; i +1 < path.size(); ++i) {\n            int a = path[i];\n            int b = path[i+1];\n            int li = rnd.next(1, 1000000); // li in [1, 1e6]\n            edges.push_back({{a, b}, li});\n        }\n\n        int needed_edges = m - (int)edges.size();\n\n        // Generate random edges to reach m edges\n\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"multi_shortest_paths\") {\n        // Generate a graph where there are multiple shortest paths from s to t\n        // For simplicity, build two paths from s to t of equal total weight\n\n        ensure(n >= 4);\n\n        // Set up two paths from s to t:\n        // Path 1: s -> u1 -> t\n        // Path 2: s -> u2 -> t\n\n        int u1 = -1, u2 = -1;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                if (u1 == -1) u1 = i;\n                else if (u2 == -1) u2 = i;\n                if (u1 != -1 && u2 != -1) break;\n            }\n        }\n        // Path 1\n        edges.push_back({{s, u1}, 1});\n        edges.push_back({{u1, t}, 1});\n\n        // Path 2\n        edges.push_back({{s, u2}, 1});\n        edges.push_back({{u2, t}, 1});\n\n        // Now, add extra edges to reach m edges\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"unique_path\") {\n        // Build a path from s to t, no other paths are possible\n\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            nodes.push_back(i);\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        // Ensure s and t are at positions 0 and n-1\n        if (nodes[0] != s) {\n            for (size_t i = 1; i < nodes.size(); ++i) {\n                if (nodes[i] == s) {\n                    swap(nodes[0], nodes[i]);\n                    break;\n                }\n            }\n        }\n        if (nodes[nodes.size() - 1] != t) {\n            for (size_t i = 0; i < nodes.size() - 1; ++i) {\n                if (nodes[i] == t) {\n                    swap(nodes[nodes.size() - 1], nodes[i]);\n                    break;\n                }\n            }\n        }\n\n        for (size_t i = 0; i +1 < nodes.size(); ++i) {\n            int a = nodes[i];\n            int b = nodes[i+1];\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Add extra edges to reach m\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"dense\") {\n        // Generate a dense graph ensuring there is a path from s to t\n\n        // Ensure m does not exceed n*(n-1)\n        ensure(m <= (long long)n * (n - 1));\n\n        set<pair<int,int>> edge_set;\n\n        // Ensure path from s to t\n        vector<int> path;\n        path.push_back(s);\n        if (n >= 3) {\n            for (int i = 1; i <= n; ++i) {\n                if (i != s && i != t) {\n                    path.push_back(i);\n                    break;\n                }\n            }\n        }\n        path.push_back(t);\n\n        for (size_t i = 0; i+1 < path.size(); ++i) {\n            int a = path[i];\n            int b = path[i+1];\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n            edge_set.insert({a, b});\n        }\n\n        // Now add random edges\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            pair<int,int> e = {a,b};\n            int li = rnd.next(1, 1000000);\n            edges.push_back({e, li});\n        }\n\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"special\") {\n        // Generate special test cases\n\n        ensure(n >= 4);\n\n        int a = -1, b = -1;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                if (a == -1) a = i;\n                else if (b == -1) b = i;\n                if (a != -1 && b != -1) break;\n            }\n        }\n\n        // Edge from s to a with li = 1\n        edges.push_back({{s, a}, 1});\n        // Edge from a to t with li = 1\n        edges.push_back({{a, t}, 1});\n\n        // Edge from s to b with li = 2\n        edges.push_back({{s, b}, 2});\n        // Edge from b to t with li = 2\n        edges.push_back({{b, t}, 2});\n\n        // Edge that cannot be repaired to be on all shortest paths\n        edges.push_back({{s, t}, 10});\n\n        // Add more edges to reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{u,v}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Now output the data\n\n    printf(\"%d %d %d %d\\n\", n, m, s, t);\n    for (auto& e : edges) {\n        int ai = e.first.first;\n        int bi = e.first.second;\n        int li = e.second;\n        printf(\"%d %d %d\\n\", ai, bi, li);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\", 1);\n    int t = opt<int>(\"t\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n ≥ 2\n    ensure(n >= 2 && n <= 100000);\n    // Ensure s ≠ t\n    ensure(s != t);\n    // Ensure s, t ∈ [1, n]\n    ensure(1 <= s && s <= n);\n    ensure(1 <= t && t <= n);\n\n    // Ensure 1 ≤ m ≤ 1e5\n    ensure(1 <= m && m <= 100000);\n\n    vector<pair<pair<int,int>, int>> edges;\n\n    if (type == \"random\") {\n        // Generate random edges\n        // First, ensure there is at least one path from s to t\n        // Then, add random edges to reach m edges\n\n        // Create a random path from s to t\n\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                nodes.push_back(i);\n            }\n        }\n\n        shuffle(nodes.begin(), nodes.end());\n\n        vector<int> path;\n        path.push_back(s);\n        for (int node : nodes) {\n            path.push_back(node);\n        }\n        path.push_back(t);\n\n        // Create edges along this path with li = random number\n\n        for (size_t i = 0; i +1 < path.size(); ++i) {\n            int a = path[i];\n            int b = path[i+1];\n            int li = rnd.next(1, 1000000); // li in [1, 1e6]\n            edges.push_back({{a, b}, li});\n        }\n\n        int needed_edges = m - (int)edges.size();\n\n        // Generate random edges to reach m edges\n\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"multi_shortest_paths\") {\n        // Generate a graph where there are multiple shortest paths from s to t\n        // For simplicity, build two paths from s to t of equal total weight\n\n        ensure(n >= 4);\n\n        // Set up two paths from s to t:\n        // Path 1: s -> u1 -> t\n        // Path 2: s -> u2 -> t\n\n        int u1 = -1, u2 = -1;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                if (u1 == -1) u1 = i;\n                else if (u2 == -1) u2 = i;\n                if (u1 != -1 && u2 != -1) break;\n            }\n        }\n        // Path 1\n        edges.push_back({{s, u1}, 1});\n        edges.push_back({{u1, t}, 1});\n\n        // Path 2\n        edges.push_back({{s, u2}, 1});\n        edges.push_back({{u2, t}, 1});\n\n        // Now, add extra edges to reach m edges\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"unique_path\") {\n        // Build a path from s to t, no other paths are possible\n\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            nodes.push_back(i);\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        // Ensure s and t are at positions 0 and n-1\n        if (nodes[0] != s) {\n            for (size_t i = 1; i < nodes.size(); ++i) {\n                if (nodes[i] == s) {\n                    swap(nodes[0], nodes[i]);\n                    break;\n                }\n            }\n        }\n        if (nodes[nodes.size() - 1] != t) {\n            for (size_t i = 0; i < nodes.size() - 1; ++i) {\n                if (nodes[i] == t) {\n                    swap(nodes[nodes.size() - 1], nodes[i]);\n                    break;\n                }\n            }\n        }\n\n        for (size_t i = 0; i +1 < nodes.size(); ++i) {\n            int a = nodes[i];\n            int b = nodes[i+1];\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Add extra edges to reach m\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"dense\") {\n        // Generate a dense graph ensuring there is a path from s to t\n\n        // Ensure m does not exceed n*(n-1)\n        ensure(m <= (long long)n * (n - 1));\n\n        set<pair<int,int>> edge_set;\n\n        // Ensure path from s to t\n        vector<int> path;\n        path.push_back(s);\n        if (n >= 3) {\n            for (int i = 1; i <= n; ++i) {\n                if (i != s && i != t) {\n                    path.push_back(i);\n                    break;\n                }\n            }\n        }\n        path.push_back(t);\n\n        for (size_t i = 0; i+1 < path.size(); ++i) {\n            int a = path[i];\n            int b = path[i+1];\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{a, b}, li});\n            edge_set.insert({a, b});\n        }\n\n        // Now add random edges\n        while ((int)edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            pair<int,int> e = {a,b};\n            int li = rnd.next(1, 1000000);\n            edges.push_back({e, li});\n        }\n\n        shuffle(edges.begin(), edges.end());\n\n    } else if (type == \"special\") {\n        // Generate special test cases\n\n        ensure(n >= 4);\n\n        int a = -1, b = -1;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                if (a == -1) a = i;\n                else if (b == -1) b = i;\n                if (a != -1 && b != -1) break;\n            }\n        }\n\n        // Edge from s to a with li = 1\n        edges.push_back({{s, a}, 1});\n        // Edge from a to t with li = 1\n        edges.push_back({{a, t}, 1});\n\n        // Edge from s to b with li = 2\n        edges.push_back({{s, b}, 2});\n        // Edge from b to t with li = 2\n        edges.push_back({{b, t}, 2});\n\n        // Edge that cannot be repaired to be on all shortest paths\n        edges.push_back({{s, t}, 10});\n\n        // Add more edges to reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int li = rnd.next(1, 1000000);\n            edges.push_back({{u,v}, li});\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Now output the data\n\n    printf(\"%d %d %d %d\\n\", n, m, s, t);\n    for (auto& e : edges) {\n        int ai = e.first.first;\n        int bi = e.first.second;\n        int li = e.second;\n        printf(\"%d %d %d\\n\", ai, bi, li);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small graph, random type\n./gen -n 5 -m 7 -s 1 -t 5 -type random\n\n# Small graph, multiple shortest paths\n./gen -n 5 -m 6 -s 1 -t 5 -type multi_shortest_paths\n\n# Small graph, unique path\n./gen -n 5 -m 4 -s 1 -t 5 -type unique_path\n\n# Small graph, special case\n./gen -n 5 -m 10 -s 1 -t 5 -type special\n\n# Medium graph, random type\n./gen -n 1000 -m 5000 -s 1 -t 1000 -type random\n\n# Medium graph, multiple shortest paths\n./gen -n 1000 -m 2000 -s 1 -t 1000 -type multi_shortest_paths\n\n# Medium graph, unique path\n./gen -n 1000 -m 999 -s 1 -t 1000 -type unique_path\n\n# Medium graph, dense graph\n./gen -n 1000 -m 100000 -s 1 -t 1000 -type dense\n\n# Medium graph, special case\n./gen -n 1000 -m 5000 -s 1 -t 1000 -type special\n\n# Large graph, random type\n./gen -n 100000 -m 100000 -s 1 -t 100000 -type random\n\n# Large graph, multiple shortest paths\n./gen -n 100000 -m 100000 -s 1 -t 100000 -type multi_shortest_paths\n\n# Large graph, unique path\n./gen -n 100000 -m 99999 -s 1 -t 100000 -type unique_path\n\n# Large graph, dense graph\n./gen -n 100000 -m 100000 -s 1 -t 100000 -type dense\n\n# Large graph, special case\n./gen -n 100000 -m 100000 -s 1 -t 100000 -type special\n\n# Edge case: s and t are not 1 and n\n./gen -n 10 -m 15 -s 3 -t 7 -type random\n\n# Edge case: s and t are adjacent\n./gen -n 10 -m 15 -s 3 -t 4 -type random\n\n# Edge case: small n and m\n./gen -n 2 -m 1 -s 1 -t 2 -type unique_path\n\n# Edge case: multiple edges between same nodes\n./gen -n 10 -m 50 -s 1 -t 10 -type random\n\n# Edge case: maximum li values\n./gen -n 1000 -m 5000 -s 1 -t 1000 -type random\n\n# Edge case: minimum li values\n./gen -n 1000 -m 5000 -s 1 -t 1000 -type random\n\n# Edge case: cycles in the graph\n./gen -n 1000 -m 5000 -s 1 -t 1000 -type random\n\n# Edge case: large repair costs\n./gen -n 1000 -m 5000 -s 1 -t 1000 -type special\n\n# Edge case: graphs with nodes connected in unusual ways\n./gen -n 5000 -m 4999 -s 1 -t 5000 -type unique_path\n\n# Edge case: maximum number of edges\n./gen -n 100000 -m 100000 -s 1 -t 100000 -type random\n\n# Edge case: graphs where m is small\n./gen -n 100000 -m 100 -s 1 -t 100000 -type random\n\n# Custom s and t\n./gen -n 1000 -m 5000 -s 500 -t 501 -type random\n\n# Large graph, dense with maximum edges\n./gen -n 100000 -m 100000 -s 1 -t 100000 -type dense\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:00.797441",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "567/F",
      "title": "F. Mausoleum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers n and k (1 ≤ n ≤ 35, 0 ≤ k ≤ 100) — the number of pairs of blocks and the number of additional requirements.Next k lines contain listed additional requirements, one per line in the format \"xi signi yi\" (1 ≤ xi, yi ≤ 2n), and the sign is on of the list of the five possible signs.",
      "output_spec": "OutputPrint the sought number of ways.",
      "sample_tests": "ExamplesInputCopy3 0OutputCopy9InputCopy3 12 > 3OutputCopy1InputCopy4 13 = 6OutputCopy3",
      "description": "F. Mausoleum\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integers n and k (1 ≤ n ≤ 35, 0 ≤ k ≤ 100) — the number of pairs of blocks and the number of additional requirements.Next k lines contain listed additional requirements, one per line in the format \"xi signi yi\" (1 ≤ xi, yi ≤ 2n), and the sign is on of the list of the five possible signs.\n\nOutputPrint the sought number of ways.\n\nInputCopy3 0OutputCopy9InputCopy3 12 > 3OutputCopy1InputCopy4 13 = 6OutputCopy3\n\nInputCopy3 0\n\nOutputCopy9\n\nInputCopy3 12 > 3\n\nOutputCopy1\n\nInputCopy4 13 = 6\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!5th august 2015 at 19:00 MSK Codeforces Round #Pi will take place for second division participants. Participants from the first division are able to participate out of the contest.This is my first round on Codeforces. I hope you will enjoy the tasks and this will stimulate me to prepare new rounds! Wish you quick Accepted verdicts and successful hacks.I want to thank Michael Mirzayanov (MikeMirzayanov) for wonderful platforms Polygon and Codeforces and for help in preparing the tasks, Maxim Akhmedov (Zlobober) for help in contest preparation, Maria Belova for translation statements to english, and also my friends Danil Sagunov (danilka.pro) and Vitaliy Kudasov (kuviman) for solving the tasks.Participants will be given six tasks and two and the half hours for solving them. Scoring system will be announced closer to round start.UPD: Scoring: 500-1000-1500-2000-2500-2500.UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces",
          "content": "567A - Lineland MailOne can notice that the maximum cost of sending a letter from i'th city is equal to maximum of distances from i'th city to first city and from i'th city to last (max(abs(xi - x0), abs(xi - xn - 1)). On the other hand, the minimum cost of sending a letter will be the minimum of distances between neighboring cities (i - 1'th and i + 1'th cities), more formally, min(abs(xi - xi - 1), abs(xi - xi + 1). For each city, except the first and the last this formula is correct, but for them formulas are (abs(xi - xi + 1)) and (abs(xi - xi - 1)) respectively.Author solution567B - Berland National LibraryTo answer the queries correct, we need to know if the person is still in the library. For that purpose we will use in array of type bool. Also we will store two variables for the answer and ''current state'' (it will store the current number of people in the library). Let's call them ans and state respectively.Thus, if we are given query  + ai then we should increase state by one, mark that this person entered the library (in[ai] = true) and try to update the answer (ans = max(ans, state)).Otherwise we are given  - ai query. If the person who leaves the library, was in there, we should just decrease state by one. Otherwise, if this person was not in the library (in[ai] == false) and leaves now, he entered the library before we started counting. It means we should increase the answer by one anyway. Also one should not forget that it is needed to mark that the person has left the library (in[ai] = false).Author solution567C - Geometric ProgressionLet's solve this problem for fixed middle element of progression. This means that if we fix element ai then the progression must consist of ai / k and ai·k elements. It could not be possible, for example, if ai is not divisible by k ().For fixed middle element one could find the number of sequences by counting how many ai / k elements are placed left from fixed element and how many ai·k are placed right from it, and then multiplying this numbers. To do this, one could use two associative arrays Al and Ar, where for each key x will be stored count of occurences of x placed left (or right respectively) from current element. This could be done with map structure.Sum of values calculated as described above will give the answer to the problem.Author solution567D - One-Dimensional Battle ShipsFirst, we should understand when the game ends. It will happen when on the n-sized board it will be impossible to place k ships of size a. For segment with length len we could count the maximum number of ships with size a that could be placed on it. Each ship occupies a + 1 cells, except the last ship. Thus, for segment with length len the formula will look like (we add \"fictive\" cell to len cells to consider the last ship cell). This way, for [l..r] segment the formula should be . For solving the problem we should store all the [l..r] segments which has no ''free'' cells (none of them was shooted). One could use (std: : set) for that purpose. This way, before the shooting, there will be only one segment [1..n]. Also we will store current maximum number of ships we could place on a board. Before the shooting it is equal to .With every shoot in cell x we should find the segment containing shooted cell (let it be [l..r]), we should update segment set. First, we should delete [l..r] segment. It means we should decrease current maximum number of ships by and delete it from the set. Next, we need to add segments [l..x - 1] and [x + 1..r] to the set (they may not be correct, so you may need to add only one segments or do not add segments at all) and update the maximum number of ships properly. We should process shoots one by one, and when the maximum number of ships will become lesser than k, we must output the answer. If that never happen, output  - 1.Author solution567E - President and RoadsAt first, let's find edges that do not belong to any shortest paths from s to t. Let's find two shortest path arrays d1 and d2 with any shortest-path-finding algorithm. First array stores shortest path length from s, and the second — from t. Edge (u, v) then will be on at least one shortest path from s to t if and only if d1[u] + w(u, v) + d2[v] == d1[t].Let's build shortest path graph, leaving only edges described above. If we consider shortest path from s to t as segment [0..D] and any edge (u, v) in shortest path graph as its subsegment [d1[u]..d1[v]], then if such subsegment do not share any common point with any other edge subsegment, except its leftest and rightest point (d1[u] and d1[v]), this edge belongs to every shortest path from s to t.Now we could surely answer \"YES\" to such edges. Next part of the solution are much simple. If edge (u, v) do not belong to every shortest path, we could try decrease its weight. This edge will belong to every shortest path if and only if its weight will become d1[t] - d1[u] - d2[v] - 1. So, if this value are strictly positive, we should answer \"CAN\" considering new edge weight. Otherwise we need to output \"NO\".Author solution567F - MausoleumConsider that we are placing blocks by pairs, one pair by one, starting from leftmost and rightmost places. Thus, for example, two blocks of height 1 we could place in positions 1 and 2, 1 and 2n, or 2n - 1 and 2n. The segment of unused positions will be changed that way and the next block pairs should be placed on new leftmost and rightmost free places. At last only two positions will be free and we should place two blocks of height n on them.Any correct sequence of blocks could be builded that way. Let's try to review the requirements consider such way of placing blocks. As soon as we place blocks one by one, the requirements are now only describes the order of placing blocks. For example, requirement ''3 >= 5'' means that we should place block in position 3 only if block in position 5 is already placed (and thus it have lesser height), or we place pair of blocks of same height on them at one moment.For counting required number of sequences we will use dynamic programming approach. Let's count dp[l][r] — the number of ways to place some blocks in the way that only positions at segment [l..r] are free. The height of current placed pair of blocks is counted from the segment borders itself (. Fix one way of placing current block pair (exclusion is l =  = r + 1). Now check if such placing meets the requirements. We will consider only requirements that meets one of the current-placing positions. For every \"current\" position \"<\" must be true only for free positions (positions in [l..r], which do not equal to current positions), \">\" must be true for already-placed positions (out of [l..r]) and \"=\" must be true only for second current position.This DP could be easily calculated using \"lazy\" approach.Author solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 567\\s*F"
          },
          "content_length": 6829
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 1",
          "code": "left_border=k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 2",
          "code": "right_border=k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 3",
          "code": "total<number_of_ships",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 4",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 5",
          "code": "for(auto i:my)cerr << i.first <<\":\"<<i.second<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 6",
          "code": "(len + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 7",
          "code": "l <= c <= r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 8",
          "code": "(len(l, r) + 1) / (a + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 9",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 10",
          "code": "p[abs(arr[i])]-=arr[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 11",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 12",
          "code": "#ifndef ONLINE_JUDGE\n#  define LOG(x) (cerr << #x << \" = \" << (x) << endl)\n#else\n#  define LOG(x) ((void)0)\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 13",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 14",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 15",
          "code": "3\n- 5\n+ 5\n- 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 17",
          "code": "for(int i=0;i<n;++i)\n        {\n            scanf(\"%d\",&t);\n            if(k==1)res+=(a[t]*(a[t]-1))/2;\n            ++a[t];\n         }\ncout<<res;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 18",
          "code": "map<long long,long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 19",
          "code": "it=s.upper_bound(mp(mov[i],-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 20",
          "code": "it=s.upper_bound(mp(mov[i],n+1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 21",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #Pi (Div. 2) - Codeforces - Code 22",
          "code": "10 10 1 10\n1 5 178\n1 8 221\n2 7 92\n2 8 159\n3 5 55\n3 6 179\n3 10 237\n4 8 205\n5 6 191\n8 10 157",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19590",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 1",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 2",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 3",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 4",
          "code": "std::unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 5",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 6",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 8",
          "code": "max_load_factor",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 9",
          "code": "unordered_map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 10",
          "code": "map<int, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 11",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 12",
          "code": "5 6 1 5\n1 3 100\n1 2 40\n2 3 60\n3 4 5\n4 5 7\n4 5 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #Pi - Codeforces - Code 13",
          "code": "auto it = xs.lower_bound(mp(x, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 35, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, 2 * n, \"xi\");\n        inf.readSpace();\n        string sign = inf.readToken(\"(=|<|>|<=|>=)\", \"sign\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 2 * n, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 35, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, 2 * n, \"xi\");\n        inf.readSpace();\n        string sign = inf.readToken(\"(=|<|>|<=|>=)\", \"sign\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 2 * n, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 35, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, 2 * n, \"xi\");\n        inf.readSpace();\n        string sign = inf.readToken(\"(=|<|>|<=|>=)\", \"sign\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 2 * n, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_constraints(int k, int totalBlocks, vector<tuple<int, string, int>> &constraints) {\n    for(int i = 0; i < k; i++) {\n        int xi = rnd.next(1, totalBlocks);\n        int yi = rnd.next(1, totalBlocks);\n        int signType = rnd.next(0, 4); // 0: '=', 1: '<', 2: '>', 3: '<=', 4: '>='\n        string sign;\n        switch(signType) {\n            case 0: sign = \"=\"; break;\n            case 1: sign = \"<\"; break;\n            case 2: sign = \">\"; break;\n            case 3: sign = \"<=\"; break;\n            case 4: sign = \">=\"; break;\n        }\n        constraints.push_back({xi, sign, yi});\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    int max_n = 35;\n    int max_k = 100;\n\n    n = min(n, max_n);\n    k = min(k, max_k);\n\n    int totalBlocks = 2 * n;\n    vector<tuple<int, string, int>> constraints;\n\n    if(type == \"random\") {\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"max_n\") {\n        n = max_n;\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"min_n\") {\n        n = 1;\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"conflict_constraints\") {\n        // Create conflicting constraints\n        if(k == 0) k = 2;\n        constraints.push_back({1, \"<\", 2});\n        constraints.push_back({1, \">\", 2});\n    } else if(type == \"tight_constraints\") {\n        // Constraints that potentially force only one arrangement\n        if(k == 0) k = totalBlocks - 1;\n        for(int i = 1; i < totalBlocks; i++) {\n            constraints.push_back({i, \"<=\", i+1});\n        }\n    } else if(type == \"max_k\") {\n        k = max_k;\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"no_constraints\") {\n        k = 0;\n    } else if(type == \"one_arrangement\") {\n        // Generate constraints that force blocks into one particular arrangement\n        k = totalBlocks - 1;\n        for(int i = 1; i < totalBlocks; i++) {\n            constraints.push_back({i, \"<\", i+1});\n        }\n    } else if(type == \"zero_answer\") {\n        // Constraints that make the answer zero\n        k = 1;\n        constraints.push_back({1, \"<\", 1}); // Impossible constraint\n    } else if(type == \"self_constraint\") {\n        // Constraints with xi == yi\n        k = k == 0 ? 1 : k;\n        for(int i = 1; i <= k; i++) {\n            int xi = rnd.next(1, totalBlocks);\n            string sign = \"=\";\n            constraints.push_back({xi, sign, xi});\n        }\n    } else {\n        // default random\n        generate_random_constraints(k, totalBlocks, constraints);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)constraints.size());\n    for(auto &c : constraints) {\n        int xi, yi;\n        string sign;\n        tie(xi, sign, yi) = c;\n        printf(\"%d %s %d\\n\", xi, sign.c_str(), yi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_constraints(int k, int totalBlocks, vector<tuple<int, string, int>> &constraints) {\n    for(int i = 0; i < k; i++) {\n        int xi = rnd.next(1, totalBlocks);\n        int yi = rnd.next(1, totalBlocks);\n        int signType = rnd.next(0, 4); // 0: '=', 1: '<', 2: '>', 3: '<=', 4: '>='\n        string sign;\n        switch(signType) {\n            case 0: sign = \"=\"; break;\n            case 1: sign = \"<\"; break;\n            case 2: sign = \">\"; break;\n            case 3: sign = \"<=\"; break;\n            case 4: sign = \">=\"; break;\n        }\n        constraints.push_back({xi, sign, yi});\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    int max_n = 35;\n    int max_k = 100;\n\n    n = min(n, max_n);\n    k = min(k, max_k);\n\n    int totalBlocks = 2 * n;\n    vector<tuple<int, string, int>> constraints;\n\n    if(type == \"random\") {\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"max_n\") {\n        n = max_n;\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"min_n\") {\n        n = 1;\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"conflict_constraints\") {\n        // Create conflicting constraints\n        if(k == 0) k = 2;\n        constraints.push_back({1, \"<\", 2});\n        constraints.push_back({1, \">\", 2});\n    } else if(type == \"tight_constraints\") {\n        // Constraints that potentially force only one arrangement\n        if(k == 0) k = totalBlocks - 1;\n        for(int i = 1; i < totalBlocks; i++) {\n            constraints.push_back({i, \"<=\", i+1});\n        }\n    } else if(type == \"max_k\") {\n        k = max_k;\n        generate_random_constraints(k, totalBlocks, constraints);\n    } else if(type == \"no_constraints\") {\n        k = 0;\n    } else if(type == \"one_arrangement\") {\n        // Generate constraints that force blocks into one particular arrangement\n        k = totalBlocks - 1;\n        for(int i = 1; i < totalBlocks; i++) {\n            constraints.push_back({i, \"<\", i+1});\n        }\n    } else if(type == \"zero_answer\") {\n        // Constraints that make the answer zero\n        k = 1;\n        constraints.push_back({1, \"<\", 1}); // Impossible constraint\n    } else if(type == \"self_constraint\") {\n        // Constraints with xi == yi\n        k = k == 0 ? 1 : k;\n        for(int i = 1; i <= k; i++) {\n            int xi = rnd.next(1, totalBlocks);\n            string sign = \"=\";\n            constraints.push_back({xi, sign, xi});\n        }\n    } else {\n        // default random\n        generate_random_constraints(k, totalBlocks, constraints);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)constraints.size());\n    for(auto &c : constraints) {\n        int xi, yi;\n        string sign;\n        tie(xi, sign, yi) = c;\n        printf(\"%d %s %d\\n\", xi, sign.c_str(), yi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type min_n\n./gen -n 35 -k 100 -type max_n\n./gen -n 5 -k 0 -type no_constraints\n./gen -n 5 -k 3 -type random\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 20 -type random\n./gen -n 10 -k 20 -type max_k\n./gen -n 15 -type conflict_constraints\n./gen -n 15 -type tight_constraints\n./gen -n 20 -k 50 -type random\n./gen -n 35 -k 100 -type random\n./gen -n 5 -k 0 -type zero_answer\n./gen -n 10 -k 5 -type self_constraint\n./gen -n 25 -k 0 -type one_arrangement\n./gen -n 30 -k 0 -type one_arrangement\n./gen -n 35 -k 100 -type max_k\n./gen -n 34 -k 0 -type tight_constraints\n./gen -n 33 -k 0 -type conflict_constraints\n./gen -n 32 -k 10 -type zero_answer\n./gen -n 31 -k 0 -type self_constraint\n./gen -n 30 -k 50 -type random\n./gen -n 29 -k 0 -type no_constraints\n./gen -n 28 -k 5 -type random\n./gen -n 27 -type zero_answer\n./gen -n 26 -k 0 -type one_arrangement\n./gen -n 25 -k 20 -type random\n./gen -n 24 -k 0 -type tight_constraints\n./gen -n 23 -type conflict_constraints\n./gen -n 22 -k 100 -type max_k\n./gen -n 1 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:02.721905",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "568/A",
      "title": "A. Primes or Palindromes?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of two positive integers p, q, the numerator and denominator of the fraction that is the value of A (, ).",
      "output_spec": "OutputIf such maximum number exists, then print it. Otherwise, print \"Palindromic tree is better than splay tree\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy40InputCopy1 42OutputCopy1InputCopy6 4OutputCopy172",
      "description": "A. Primes or Palindromes?\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe input consists of two positive integers p, q, the numerator and denominator of the fraction that is the value of A (, ).\n\nOutputIf such maximum number exists, then print it. Otherwise, print \"Palindromic tree is better than splay tree\" (without the quotes).\n\nInputCopy1 1OutputCopy40InputCopy1 42OutputCopy1InputCopy6 4OutputCopy172\n\nInputCopy1 1\n\nOutputCopy40\n\nInputCopy1 42\n\nOutputCopy1\n\nInputCopy6 4\n\nOutputCopy172",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 568\\s*A"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int max_value = opt<int>(\"max_value\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int p, q;\n\n    if (type == \"min_values\") {\n        p = 1;\n        q = 1;\n    } else if (type == \"max_values\") {\n        p = max_value;\n        q = max_value;\n    } else if (type == \"random\") {\n        p = rnd.next(1, max_value);\n        q = rnd.next(1, max_value);\n    } else if (type == \"p_eq_q\") {\n        p = rnd.next(1, max_value);\n        q = p;\n    } else if (type == \"p_lt_q\") {\n        p = rnd.next(1, max_value);\n        q = rnd.next(p, max_value);\n    } else if (type == \"p_gt_q\") {\n        q = rnd.next(1, max_value);\n        p = rnd.next(q, max_value);\n    } else if (type == \"p_small_q_large\") {\n        p = 1;\n        q = max_value;\n    } else if (type == \"p_large_q_small\") {\n        p = max_value;\n        q = 1;\n    } else if (type == \"special\") {\n        // For specific test cases, we can define multiple options\n        int option = rnd.next(1, 3);\n        if (option == 1) {\n            p = 6;\n            q = 4;\n        } else if (option == 2) {\n            p = 1;\n            q = 42;\n        } else {\n            p = 1;\n            q = 1;\n        }\n    } else {\n        // Default to random\n        p = rnd.next(1, max_value);\n        q = rnd.next(1, max_value);\n    }\n\n    printf(\"%d %d\\n\", p, q);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int max_value = opt<int>(\"max_value\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int p, q;\n\n    if (type == \"min_values\") {\n        p = 1;\n        q = 1;\n    } else if (type == \"max_values\") {\n        p = max_value;\n        q = max_value;\n    } else if (type == \"random\") {\n        p = rnd.next(1, max_value);\n        q = rnd.next(1, max_value);\n    } else if (type == \"p_eq_q\") {\n        p = rnd.next(1, max_value);\n        q = p;\n    } else if (type == \"p_lt_q\") {\n        p = rnd.next(1, max_value);\n        q = rnd.next(p, max_value);\n    } else if (type == \"p_gt_q\") {\n        q = rnd.next(1, max_value);\n        p = rnd.next(q, max_value);\n    } else if (type == \"p_small_q_large\") {\n        p = 1;\n        q = max_value;\n    } else if (type == \"p_large_q_small\") {\n        p = max_value;\n        q = 1;\n    } else if (type == \"special\") {\n        // For specific test cases, we can define multiple options\n        int option = rnd.next(1, 3);\n        if (option == 1) {\n            p = 6;\n            q = 4;\n        } else if (option == 2) {\n            p = 1;\n            q = 42;\n        } else {\n            p = 1;\n            q = 1;\n        }\n    } else {\n        // Default to random\n        p = rnd.next(1, max_value);\n        q = rnd.next(1, max_value);\n    }\n\n    printf(\"%d %d\\n\", p, q);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_values\n./gen -type max_values -max_value 1000000\n\n./gen -type random -max_value 10\n./gen -type random -max_value 100\n./gen -type random -max_value 1000\n./gen -type random -max_value 10000\n./gen -type random -max_value 100000\n./gen -type random -max_value 1000000\n\n./gen -type p_eq_q -max_value 10\n./gen -type p_eq_q -max_value 100\n./gen -type p_eq_q -max_value 1000\n./gen -type p_eq_q -max_value 10000\n./gen -type p_eq_q -max_value 100000\n./gen -type p_eq_q -max_value 1000000\n\n./gen -type p_lt_q -max_value 10\n./gen -type p_lt_q -max_value 100\n./gen -type p_lt_q -max_value 1000\n./gen -type p_lt_q -max_value 10000\n./gen -type p_lt_q -max_value 100000\n./gen -type p_lt_q -max_value 1000000\n\n./gen -type p_gt_q -max_value 10\n./gen -type p_gt_q -max_value 100\n./gen -type p_gt_q -max_value 1000\n./gen -type p_gt_q -max_value 10000\n./gen -type p_gt_q -max_value 100000\n./gen -type p_gt_q -max_value 1000000\n\n./gen -type p_small_q_large -max_value 1000000\n./gen -type p_large_q_small -max_value 1000000\n\n./gen -type special\n./gen -type special\n./gen -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:04.431506",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "568/B",
      "title": "B. Symmetric and Transitive",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains a single integer n (1 ≤ n ≤ 4000).",
      "output_spec": "OutputIn a single line print the answer to the problem modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy2OutputCopy3InputCopy3OutputCopy10",
      "description": "B. Symmetric and Transitive\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputA single line contains a single integer n (1 ≤ n ≤ 4000).\n\nOutputIn a single line print the answer to the problem modulo 109 + 7.\n\nInputCopy1OutputCopy1InputCopy2OutputCopy3InputCopy3OutputCopy10\n\nOutputCopy1\n\nOutputCopy3\n\nOutputCopy10\n\nNoteIf n = 1 there is only one such relation — an empty one, i.e. . In other words, for a single element x of set A the following is hold: .If n = 2 there are three such relations. Let's assume that set A consists of two elements, x and y. Then the valid relations are , ρ = {(x, x)}, ρ = {(y, y)}. It is easy to see that the three listed binary relations are symmetric and transitive relations, but they are not equivalence relations.",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 568\\s*B"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", 4000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = min_n;\n\n    if (type == \"min\") {\n        n = min_n;\n    } else if (type == \"max\") {\n        n = max_n;\n    } else if (type == \"small\") {\n        n = rnd.next(min_n, min(max_n, 10));\n    } else if (type == \"large\") {\n        n = rnd.next(max(1, max_n - 10), max_n);\n    } else if (type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else if (type == \"prime\") {\n        // Generate a prime number in the range [min_n, max_n]\n        vector<int> primes;\n        int limit = max_n;\n        vector<bool> is_prime(limit + 1, true);\n        for (int i = 2; i <= limit; ++i) {\n            if (is_prime[i]) {\n                if (i >= min_n)\n                    primes.push_back(i);\n                for (int j = i * 2; j <= limit; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        if (!primes.empty())\n            n = primes[rnd.next(0, (int)primes.size() -1)];\n        else\n            n = min_n;\n    } else if (type == \"square\") {\n        // Generate a perfect square in the range [min_n, max_n]\n        int sq_min = ceil(sqrt(min_n));\n        int sq_max = floor(sqrt(max_n));\n        if (sq_min <= sq_max) {\n            int k = rnd.next(sq_min, sq_max);\n            n = k * k;\n        } else {\n            n = min_n;\n        }\n    } else {\n        // Default to random\n        n = rnd.next(min_n, max_n);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", 4000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = min_n;\n\n    if (type == \"min\") {\n        n = min_n;\n    } else if (type == \"max\") {\n        n = max_n;\n    } else if (type == \"small\") {\n        n = rnd.next(min_n, min(max_n, 10));\n    } else if (type == \"large\") {\n        n = rnd.next(max(1, max_n - 10), max_n);\n    } else if (type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else if (type == \"prime\") {\n        // Generate a prime number in the range [min_n, max_n]\n        vector<int> primes;\n        int limit = max_n;\n        vector<bool> is_prime(limit + 1, true);\n        for (int i = 2; i <= limit; ++i) {\n            if (is_prime[i]) {\n                if (i >= min_n)\n                    primes.push_back(i);\n                for (int j = i * 2; j <= limit; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        if (!primes.empty())\n            n = primes[rnd.next(0, (int)primes.size() -1)];\n        else\n            n = min_n;\n    } else if (type == \"square\") {\n        // Generate a perfect square in the range [min_n, max_n]\n        int sq_min = ceil(sqrt(min_n));\n        int sq_max = floor(sqrt(max_n));\n        if (sq_min <= sq_max) {\n            int k = rnd.next(sq_min, sq_max);\n            n = k * k;\n        } else {\n            n = min_n;\n        }\n    } else {\n        // Default to random\n        n = rnd.next(min_n, max_n);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -min_n 1 -max_n 1 -type min       # n = 1\n./gen -min_n 4000 -max_n 4000 -type max # n = 4000\n\n./gen -min_n 1 -max_n 10 -type small    # n between 1 and 10\n./gen -min_n 1 -max_n 4000 -type small  # n between 1 and 10 (since max_n >= 10)\n\n./gen -min_n 3990 -max_n 4000 -type large  # n between 3990 and 4000\n./gen -min_n 1 -max_n 4000 -type large     # n between 3990 and 4000 (since max_n >= 10)\n\n./gen -min_n 1 -max_n 4000 -type random   # random n between 1 and 4000\n./gen -min_n 1 -max_n 4000 -type random   # random n between 1 and 4000\n./gen -min_n 1 -max_n 4000 -type random   # random n between 1 and 4000\n\n./gen -min_n 1 -max_n 4000 -type prime    # n is a prime number\n./gen -min_n 1 -max_n 4000 -type prime    # n is a prime number\n./gen -min_n 1 -max_n 4000 -type prime    # n is a prime number\n\n./gen -min_n 1 -max_n 4000 -type square   # n is a perfect square\n./gen -min_n 1 -max_n 4000 -type square   # n is a perfect square\n./gen -min_n 1 -max_n 4000 -type square   # n is a perfect square\n\n./gen -min_n 1 -max_n 1 -type random      # n = 1\n./gen -min_n 2 -max_n 2 -type random      # n = 2\n./gen -min_n 3 -max_n 3 -type random      # n = 3\n./gen -min_n 4 -max_n 4 -type random      # n = 4\n\n./gen -min_n 1 -max_n 10 -type random     # n between 1 and 10\n./gen -min_n 1000 -max_n 2000 -type random  # n between 1000 and 2000\n./gen -min_n 3000 -max_n 4000 -type random  # n between 3000 and 4000\n\n./gen -min_n 1000 -max_n 1000 -type random  # n = 1000\n./gen -min_n 2000 -max_n 2000 -type random  # n = 2000\n./gen -min_n 3999 -max_n 3999 -type random  # n = 3999\n\n./gen -min_n 3900 -max_n 4000 -type random  # n between 3900 and 4000\n./gen -min_n 1 -max_n 4000 -type random     # random n between 1 and 4000\n./gen -min_n 1 -max_n 4000 -type random     # random n between 1 and 4000\n\n./gen -min_n 1 -max_n 4000 -type max        # n = 4000\n./gen -min_n 1 -max_n 1 -type min           # n = 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:06.083729",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "568/C",
      "title": "C. New Language",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single line consisting of letters 'V' (Vowel) and 'C' (Consonant), determining which letters are vowels and which letters are consonants. The length of this string l is the size of the alphabet of the new language (1 ≤ l ≤ 26). The first l letters of the English alphabet are used as the letters of the alphabet of the new language. If the i-th character of the string equals to 'V', then the corresponding letter is a vowel, otherwise it is a consonant.The second line contains two integers n, m (1 ≤ n ≤ 200, 0 ≤ m ≤ 4n(n - 1)) — the number of letters in a single word and the number of rules, correspondingly.Next m lines describe m rules of the language in the following format: pos1, t1, pos2, t2 (1 ≤ pos1, pos2 ≤ n, pos1 ≠ pos2,  'V', 'C' }).The last line contains string s of length n, consisting of the first l small letters of the English alphabet.It is guaranteed that no two rules are the same.",
      "output_spec": "OutputPrint a smallest word of a language that is lexicographically not smaller than s. If such words does not exist (for example, if the language has no words at all), print \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopyVC2 11 V 2 CaaOutputCopyabInputCopyVC2 11 C 2 VbbOutputCopy-1InputCopyVCC4 31 C 2 V2 C 3 V3 V 4 VabacOutputCopyacaa",
      "description": "C. New Language\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single line consisting of letters 'V' (Vowel) and 'C' (Consonant), determining which letters are vowels and which letters are consonants. The length of this string l is the size of the alphabet of the new language (1 ≤ l ≤ 26). The first l letters of the English alphabet are used as the letters of the alphabet of the new language. If the i-th character of the string equals to 'V', then the corresponding letter is a vowel, otherwise it is a consonant.The second line contains two integers n, m (1 ≤ n ≤ 200, 0 ≤ m ≤ 4n(n - 1)) — the number of letters in a single word and the number of rules, correspondingly.Next m lines describe m rules of the language in the following format: pos1, t1, pos2, t2 (1 ≤ pos1, pos2 ≤ n, pos1 ≠ pos2,  'V', 'C' }).The last line contains string s of length n, consisting of the first l small letters of the English alphabet.It is guaranteed that no two rules are the same.\n\nOutputPrint a smallest word of a language that is lexicographically not smaller than s. If such words does not exist (for example, if the language has no words at all), print \"-1\" (without the quotes).\n\nInputCopyVC2 11 V 2 CaaOutputCopyabInputCopyVC2 11 C 2 VbbOutputCopy-1InputCopyVCC4 31 C 2 V2 C 3 V3 V 4 VabacOutputCopyacaa\n\nInputCopyVC2 11 V 2 Caa\n\nOutputCopyab\n\nInputCopyVC2 11 C 2 Vbb\n\nOutputCopy-1\n\nInputCopyVCC4 31 C 2 V2 C 3 V3 V 4 Vabac\n\nOutputCopyacaa\n\nNoteIn the first test word \"aa\" is not a word of the language, but word \"ab\" is.In the second test out of all four possibilities only word \"bb\" is not a word of a language, but all other words are lexicographically less, so there is no answer.In the third test, due to the last rule, \"abac\" doesn't belong to the language (\"a\" is a vowel, \"c\" is a consonant). The only word with prefix \"ab\" that meets the given rules is \"abaa\". But it is less than \"abac\", so the answer will be \"acaa\"",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 568\\s*C"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: string of 'V' and 'C'\n    string letter_types = inf.readLine(\"[VC]{1,26}\", \"letter_types\");\n    int l = letter_types.length();\n\n    // Read n and m\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4 * n * (n - 1), \"m\");\n    inf.readEoln();\n\n    // Read m rules\n    set<tuple<int, int, int, int>> rules_set;\n    for (int i = 1; i <= m; i++) {\n        int pos1 = inf.readInt(1, n, \"pos1\");\n        inf.readSpace();\n        string t1 = inf.readToken(\"[VC]\", \"t1\");\n        inf.readSpace();\n        int pos2 = inf.readInt(1, n, \"pos2\");\n        inf.readSpace();\n        string t2 = inf.readToken(\"[VC]\", \"t2\");\n        inf.readEoln();\n\n        ensuref(pos1 != pos2, \"At line %d: pos1 (%d) should not be equal to pos2 (%d)\", i + 2, pos1, pos2);\n\n        int t1_code = (t1 == \"V\") ? 0 : 1;\n        int t2_code = (t2 == \"V\") ? 0 : 1;\n\n        tuple<int, int, int, int> rule = make_tuple(pos1, t1_code, pos2, t2_code);\n\n        ensuref(rules_set.find(rule) == rules_set.end(), \"Duplicate rule at line %d\", i + 2);\n\n        rules_set.insert(rule);\n    }\n\n    // Read string s\n\n    // Build the regex pattern for s\n    string letters;\n    for (char c = 'a'; c <= 'a' + l - 1; c++) {\n        letters += c;\n    }\n    string pattern = \"[\" + letters + \"]{\" + to_string(n) + \"}\";\n\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof(); // Ensure there is no extra input\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: string of 'V' and 'C'\n    string letter_types = inf.readLine(\"[VC]{1,26}\", \"letter_types\");\n    int l = letter_types.length();\n\n    // Read n and m\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4 * n * (n - 1), \"m\");\n    inf.readEoln();\n\n    // Read m rules\n    set<tuple<int, int, int, int>> rules_set;\n    for (int i = 1; i <= m; i++) {\n        int pos1 = inf.readInt(1, n, \"pos1\");\n        inf.readSpace();\n        string t1 = inf.readToken(\"[VC]\", \"t1\");\n        inf.readSpace();\n        int pos2 = inf.readInt(1, n, \"pos2\");\n        inf.readSpace();\n        string t2 = inf.readToken(\"[VC]\", \"t2\");\n        inf.readEoln();\n\n        ensuref(pos1 != pos2, \"At line %d: pos1 (%d) should not be equal to pos2 (%d)\", i + 2, pos1, pos2);\n\n        int t1_code = (t1 == \"V\") ? 0 : 1;\n        int t2_code = (t2 == \"V\") ? 0 : 1;\n\n        tuple<int, int, int, int> rule = make_tuple(pos1, t1_code, pos2, t2_code);\n\n        ensuref(rules_set.find(rule) == rules_set.end(), \"Duplicate rule at line %d\", i + 2);\n\n        rules_set.insert(rule);\n    }\n\n    // Read string s\n\n    // Build the regex pattern for s\n    string letters;\n    for (char c = 'a'; c <= 'a' + l - 1; c++) {\n        letters += c;\n    }\n    string pattern = \"[\" + letters + \"]{\" + to_string(n) + \"}\";\n\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof(); // Ensure there is no extra input\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: string of 'V' and 'C'\n    string letter_types = inf.readLine(\"[VC]{1,26}\", \"letter_types\");\n    int l = letter_types.length();\n\n    // Read n and m\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4 * n * (n - 1), \"m\");\n    inf.readEoln();\n\n    // Read m rules\n    set<tuple<int, int, int, int>> rules_set;\n    for (int i = 1; i <= m; i++) {\n        int pos1 = inf.readInt(1, n, \"pos1\");\n        inf.readSpace();\n        string t1 = inf.readToken(\"[VC]\", \"t1\");\n        inf.readSpace();\n        int pos2 = inf.readInt(1, n, \"pos2\");\n        inf.readSpace();\n        string t2 = inf.readToken(\"[VC]\", \"t2\");\n        inf.readEoln();\n\n        ensuref(pos1 != pos2, \"At line %d: pos1 (%d) should not be equal to pos2 (%d)\", i + 2, pos1, pos2);\n\n        int t1_code = (t1 == \"V\") ? 0 : 1;\n        int t2_code = (t2 == \"V\") ? 0 : 1;\n\n        tuple<int, int, int, int> rule = make_tuple(pos1, t1_code, pos2, t2_code);\n\n        ensuref(rules_set.find(rule) == rules_set.end(), \"Duplicate rule at line %d\", i + 2);\n\n        rules_set.insert(rule);\n    }\n\n    // Read string s\n\n    // Build the regex pattern for s\n    string letters;\n    for (char c = 'a'; c <= 'a' + l - 1; c++) {\n        letters += c;\n    }\n    string pattern = \"[\" + letters + \"]{\" + to_string(n) + \"}\";\n\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof(); // Ensure there is no extra input\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rule {\n    int pos1, pos2;\n    char t1, t2;\n\n    bool operator<(const Rule& other) const {\n        if (pos1 != other.pos1) return pos1 < other.pos1;\n        if (t1 != other.t1) return t1 < other.t1;\n        if (pos2 != other.pos2) return pos2 < other.pos2;\n        return t2 < other.t2;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int l = opt<int>(\"l\"); // Size of the alphabet\n    int n = opt<int>(\"n\"); // Length of the words\n    int m = opt<int>(\"m\", 0); // Number of rules (default is 0)\n    string type = opt<string>(\"type\", \"random\"); // Type of the test case\n\n    // Generate letter types ('V' or 'C') for each letter in the alphabet\n    string letter_types(l, 'V'); // Initialize with 'V'\n    if (type == \"random\") {\n        for (int i = 0; i < l; ++i) {\n            letter_types[i] = rnd.next(2) ? 'V' : 'C';\n        }\n    } else if (type == \"all_vowels\") {\n        fill(letter_types.begin(), letter_types.end(), 'V');\n    } else if (type == \"all_consonants\") {\n        fill(letter_types.begin(), letter_types.end(), 'C');\n    } else if (type == \"alternating_vc\") {\n        for (int i = 0; i < l; ++i) {\n            letter_types[i] = (i % 2 == 0) ? 'V' : 'C';\n        }\n    } else if (type == \"alternating_cv\") {\n        for (int i = 0; i < l; ++i) {\n            letter_types[i] = (i % 2 == 0) ? 'C' : 'V';\n        }\n    }\n\n    // Generate the initial string s of length n\n    string s(n, 'a');\n    if (type == \"max_s\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + l - 1;\n        }\n    } else if (type == \"min_s\") {\n        // s is already initialized to 'a'\n    } else {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(l);\n        }\n    }\n\n    // Generate m unique rules\n    set<Rule> rules_set;\n    vector<Rule> rules_list;\n\n    int max_possible_rules = 4 * n * (n - 1); // Maximum number of possible rules\n\n    if (type == \"max_rules\") {\n        // Generate all possible rules where pos1 != pos2\n        for (int pos1 = 1; pos1 <= n; ++pos1) {\n            for (int pos2 = 1; pos2 <= n; ++pos2) {\n                if (pos1 == pos2) continue;\n                for (char t1 : {'V', 'C'}) {\n                    for (char t2 : {'V', 'C'}) {\n                        rules_list.push_back({pos1, pos2, t1, t2});\n                    }\n                }\n            }\n        }\n        m = rules_list.size();\n    } else if (type == \"no_solution\") {\n        // Generate rules that make it impossible to find a solution\n        int pos = rnd.next(1, n);\n        rules_list.push_back({pos, 'V', pos, 'C'}); // Conflict at the same position\n        m = 1;\n    } else {\n        // Generate m random unique rules\n        while ((int)rules_list.size() < m && (int)rules_list.size() < max_possible_rules) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = rnd.next(2) ? 'V' : 'C';\n            char t2 = rnd.next(2) ? 'V' : 'C';\n            Rule r = {pos1, pos2, t1, t2};\n\n            if (rules_set.find(r) == rules_set.end()) {\n                rules_set.insert(r);\n                rules_list.push_back(r);\n            }\n        }\n        m = rules_list.size();\n    }\n\n    // Output the test case\n    printf(\"%s\\n\", letter_types.c_str()); // Output the letter types\n\n    printf(\"%d %d\\n\", n, m); // Output n and m\n\n    for (const Rule& r : rules_list) {\n        printf(\"%d %c %d %c\\n\", r.pos1, r.t1, r.pos2, r.t2);\n    }\n\n    printf(\"%s\\n\", s.c_str()); // Output the string s\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rule {\n    int pos1, pos2;\n    char t1, t2;\n\n    bool operator<(const Rule& other) const {\n        if (pos1 != other.pos1) return pos1 < other.pos1;\n        if (t1 != other.t1) return t1 < other.t1;\n        if (pos2 != other.pos2) return pos2 < other.pos2;\n        return t2 < other.t2;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int l = opt<int>(\"l\"); // Size of the alphabet\n    int n = opt<int>(\"n\"); // Length of the words\n    int m = opt<int>(\"m\", 0); // Number of rules (default is 0)\n    string type = opt<string>(\"type\", \"random\"); // Type of the test case\n\n    // Generate letter types ('V' or 'C') for each letter in the alphabet\n    string letter_types(l, 'V'); // Initialize with 'V'\n    if (type == \"random\") {\n        for (int i = 0; i < l; ++i) {\n            letter_types[i] = rnd.next(2) ? 'V' : 'C';\n        }\n    } else if (type == \"all_vowels\") {\n        fill(letter_types.begin(), letter_types.end(), 'V');\n    } else if (type == \"all_consonants\") {\n        fill(letter_types.begin(), letter_types.end(), 'C');\n    } else if (type == \"alternating_vc\") {\n        for (int i = 0; i < l; ++i) {\n            letter_types[i] = (i % 2 == 0) ? 'V' : 'C';\n        }\n    } else if (type == \"alternating_cv\") {\n        for (int i = 0; i < l; ++i) {\n            letter_types[i] = (i % 2 == 0) ? 'C' : 'V';\n        }\n    }\n\n    // Generate the initial string s of length n\n    string s(n, 'a');\n    if (type == \"max_s\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + l - 1;\n        }\n    } else if (type == \"min_s\") {\n        // s is already initialized to 'a'\n    } else {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(l);\n        }\n    }\n\n    // Generate m unique rules\n    set<Rule> rules_set;\n    vector<Rule> rules_list;\n\n    int max_possible_rules = 4 * n * (n - 1); // Maximum number of possible rules\n\n    if (type == \"max_rules\") {\n        // Generate all possible rules where pos1 != pos2\n        for (int pos1 = 1; pos1 <= n; ++pos1) {\n            for (int pos2 = 1; pos2 <= n; ++pos2) {\n                if (pos1 == pos2) continue;\n                for (char t1 : {'V', 'C'}) {\n                    for (char t2 : {'V', 'C'}) {\n                        rules_list.push_back({pos1, pos2, t1, t2});\n                    }\n                }\n            }\n        }\n        m = rules_list.size();\n    } else if (type == \"no_solution\") {\n        // Generate rules that make it impossible to find a solution\n        int pos = rnd.next(1, n);\n        rules_list.push_back({pos, 'V', pos, 'C'}); // Conflict at the same position\n        m = 1;\n    } else {\n        // Generate m random unique rules\n        while ((int)rules_list.size() < m && (int)rules_list.size() < max_possible_rules) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = rnd.next(2) ? 'V' : 'C';\n            char t2 = rnd.next(2) ? 'V' : 'C';\n            Rule r = {pos1, pos2, t1, t2};\n\n            if (rules_set.find(r) == rules_set.end()) {\n                rules_set.insert(r);\n                rules_list.push_back(r);\n            }\n        }\n        m = rules_list.size();\n    }\n\n    // Output the test case\n    printf(\"%s\\n\", letter_types.c_str()); // Output the letter types\n\n    printf(\"%d %d\\n\", n, m); // Output n and m\n\n    for (const Rule& r : rules_list) {\n        printf(\"%d %c %d %c\\n\", r.pos1, r.t1, r.pos2, r.t2);\n    }\n\n    printf(\"%s\\n\", s.c_str()); // Output the string s\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -l 3 -n 2 -m 1 -type random\n./gen -l 2 -n 2 -m 1 -type all_vowels\n./gen -l 5 -n 2 -m 0 -type all_consonants\n./gen -l 4 -n 5 -m 5 -type alternating_vc\n./gen -l 4 -n 5 -m 5 -type alternating_cv\n./gen -l 5 -n 10 -m 20 -type random\n./gen -l 10 -n 15 -m 50 -type random\n./gen -l 8 -n 20 -m 100 -type random\n./gen -l 15 -n 50 -m 200 -type random\n./gen -l 20 -n 100 -m 500 -type random\n./gen -l 26 -n 200 -m 1000 -type random\n./gen -l 26 -n 200 -type max_rules\n./gen -l 26 -n 200 -type no_solution\n./gen -l 1 -n 200 -m 0 -type random\n./gen -l 26 -n 1 -m 0 -type random\n./gen -l 26 -n 200 -m 5000 -type random\n./gen -l 26 -n 200 -m 0 -type random\n./gen -l 26 -n 200 -m 4 -type random\n./gen -l 26 -n 200 -type all_vowels\n./gen -l 26 -n 200 -type all_consonants\n./gen -l 26 -n 200 -type alternating_vc\n./gen -l 26 -n 200 -type alternating_cv\n./gen -l 26 -n 200 -type min_s\n./gen -l 26 -n 200 -type max_s\n./gen -l 26 -n 200 -type random\n./gen -l 10 -n 100 -m 1000 -type random\n./gen -l 20 -n 150 -m 2000 -type random\n./gen -l 26 -n 200 -m 5000 -type no_solution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:08.199775",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "568/D",
      "title": "D. Указательные столбы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеНа ввод подаются два целых положительных числа n, k (1 ≤ n ≤ 105, 1 ≤ k ≤ 5)Следующие n строк содержат по три целых числа Ai, Bi, Ci в каждой, коэффициенты уравнения, задающего дорогу (|Ai|, |Bi|, |Ci| ≤ 105, Ai2 + Bi2 ≠ 0).Гарантируется, что никакие две дороги не совпадают.",
      "output_spec": "Выходные данныеЕсли решения не существует, выведите \"NO\" в единственной строке (без кавычек).Иначе в первой строке выведите \"YES\" (без кавычек).Во второй строке выведите единственное число m (m ≤ k) — количество использованных столбов. Затем в m строках выведите описания положений столбиков.Описание положения одного столбика  — это два целых числа v, u. Если u и v — два различных целых числа от 1 до n, то считается, что столбик стоит в точке пересечения дорог с номерами v и u. Если u =  - 1, а v — целое число от 1 до n, то столбик стоит на дороге номер v, причем не в точке пересечения с какой-либо другой дорогой. В любом ином случае описание столбика будет считаться некорректным, а ваш ответ — неправильным. В том числе, если v = u, либо если v и u — номера двух непересекающихся дорог, ваш ответ также будет признан неправильным.Дороги нумеруются с 1 в том порядке, в котором они даны во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 11 0 00 -1 07 -93 0Выходные данныеСкопироватьYES11 2Входные данныеСкопировать3 11 0 00 1 01 1 3Выходные данныеСкопироватьNOВходные данныеСкопировать2 33 4 55 6 7Выходные данныеСкопироватьYES21 -12 -1",
      "description": "D. Указательные столбы\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеНа ввод подаются два целых положительных числа n, k (1 ≤ n ≤ 105, 1 ≤ k ≤ 5)Следующие n строк содержат по три целых числа Ai, Bi, Ci в каждой, коэффициенты уравнения, задающего дорогу (|Ai|, |Bi|, |Ci| ≤ 105, Ai2 + Bi2 ≠ 0).Гарантируется, что никакие две дороги не совпадают.\n\nВходные данные\n\nВыходные данныеЕсли решения не существует, выведите \"NO\" в единственной строке (без кавычек).Иначе в первой строке выведите \"YES\" (без кавычек).Во второй строке выведите единственное число m (m ≤ k) — количество использованных столбов. Затем в m строках выведите описания положений столбиков.Описание положения одного столбика  — это два целых числа v, u. Если u и v — два различных целых числа от 1 до n, то считается, что столбик стоит в точке пересечения дорог с номерами v и u. Если u =  - 1, а v — целое число от 1 до n, то столбик стоит на дороге номер v, причем не в точке пересечения с какой-либо другой дорогой. В любом ином случае описание столбика будет считаться некорректным, а ваш ответ — неправильным. В том числе, если v = u, либо если v и u — номера двух непересекающихся дорог, ваш ответ также будет признан неправильным.Дороги нумеруются с 1 в том порядке, в котором они даны во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать3 11 0 00 -1 07 -93 0Выходные данныеСкопироватьYES11 2Входные данныеСкопировать3 11 0 00 1 01 1 3Выходные данныеСкопироватьNOВходные данныеСкопировать2 33 4 55 6 7Выходные данныеСкопироватьYES21 -12 -1\n\nВходные данныеСкопировать3 11 0 00 -1 07 -93 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES11 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 11 0 00 1 01 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 33 4 55 6 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES21 -12 -1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОбратите внимание, вам не требуется минимизировать m, но оно должно быть не больше k.В первом тесте все три дороги пересекаются в точке (0,0).Во втором тесте три дороги образуют треугольник, и никак нельзя поставить один столб, чтобы он стоял на всех трёх дорогах сразу.",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Всем доброго времени суток.Скоро состоится Codeforces Round #315, авторами которого являются студенты УрФУ sivukhin и Um_nik. Это второй наш раунд, первый пришелся на черные дни Codeforces, и мы надеемся, что второй наш раунд не вызовет таких катаклизмов :)Мы хотим поблагодарить команду Codeforces за эту замечательную платформу и Polygon. Особенно хотим отметить Zlobober за помощь в подготовке задач.Желаем всем удачи!UPD1:Разбалловка.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500Настоятельно рекомендуем прочитать условия всех задач. Мы постарались подготовить достаточно разнообразные задачи, вполне возможно, что сложные для нас задачи будут простыми для вас.UPD2:РазборUPD3:Поздравляем победителей!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinВсем спасибо за участие.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 852
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - МузыкаПусть перед очередным запуском прогружено S секунд песни, найдем, сколько будет прогружено перед следующим запуском. . Отсюда x = qS.Тогда решение: будем умножать S на q пока S < T. Количество таких умножений — это ответ.Сложность — 569B - ИнвентаризацияПодойдём к задаче с другой стороны: а сколько максимально можно оставить номеров, чтобы получилась перестановка? Очевидно, что эти номера должны быть от 1 до n, причем среди них не должно быть повторяющихся. И понятно, что это условие необходимое и достаточное.Такую задачу можно решать жадным алгоритмом. Если мы встретили число, которого ещё не было, при этом оно от 1 до n, то мы его оставим. Для реализации можно завести массив used, в котором отмечать уже использованные числа.Затем нужно ещё раз пройти по массиву и распределить неиспользованные числа.Сложность — O(n).568A - Простые или палиндромы?Известно, что количество простых чисел, не превосходящих n, — число порядка .Если мы зафиксируем длину числа k, то количество палиндромных чисел такой длины будет порядка . Это .Таким образом, количество простых чисел асимптотически больше количества палиндромных чисел, а значит для любой константы A найдётся ответ. И для такого ответа . В нашем случае n будут не больше 107.Поэтому мы можем для всех чисел до 107 проверить, являются ли они простыми (с помощью решета Эратосфена), а также являются ли они палиндромными (с помощью наивного алгоритма, или же можно динамикой считать зеркальное отображение числа). Затем мы посчитаем префиксные суммы, а потом линейным поиском найдём ответ.При A ≤ 42 ответ не превышает 2·106.Сложность — .568B - Симметричное и транзитивноеДавайте сначала разберёмся, в чем же конкретно неправ Вовочка. В доказательстве хорошо всё, кроме того, что мы сразу взяли a, b такие, что . Если такие есть, то действительно . А если их нет? Если для a нет такого b, что , то, очевидно, не (иначе мы бы взяли b = a).Отсюда понятно, что наше бинарное отношение — это какое-то отношение эквивалентности, к которому присоединили такие элементы a, что для всех них не существует таких b, что .Тогда решение можно разбить на две части: Посчитать количество отношений эквивалентности на множествах размеров 0, 1, ..., n - 1 Посчитать, сколькими способами туда можно добавить недостающие \"пустые\" элементы. Отношение эквивалентности можно задать разбиением на классы эквивалентности.Тогда первую часть задачи можно решить динамическим программированием: dp[elems][classes] — кол-во способов разбить elems первых элементов на classes классов эквивалентности. Переход — каждый элемент мы можем либо отнести в один из уже существующих классов, тогда их количество не изменится, либо же создать новый класс, тогда их количество увеличится на 1.Вторая часть задачи. Зафиксируем m — размер множества, над которым мы посчитали количество отношений эквивалентности. Тогда нам нужно добавить к нему ещё n - m \"пустых\" элементов. Позиции для них можно выбрать C[n][n - m] способами, где C[n][k] — биномиальные коэффициенты. Их можно заранее посчитать треугольником Паскаля.Тогда ответ — .Сложность — O(n2)568C - Новый языкПусть мы зафиксировали буквы на каких-то позициях, как проверить, что на остальные позиции можно расставить буквы так, чтобы получилось слово из языка? Ответ — 2-SAT. Действительно, для каждой позиции есть два взаимоисключающих варианта (гласная и согласная), а правила языка — это импликации. Таким образом, такую проверку мы можем сделать за O(n + m).Будем уменьшать длину префикса, который мы оставляем таким же, как у слова s. Тогда следующая буква должна быть строго больше, чем в s, а весь дальнейший суффикс может быть любым. Переберём эту букву и проверим с помощью 2-SAT, есть ли решения. Как только мы обнаружили, что решения есть, мы нашли правильный префикс лексиграфически минимального ответа. Затем будем обратно наращивать префикс, какая-то из букв точно подойдёт. Мы получили решение за O(nmΣ ). Σ из решения можно убрать, заметив, что каждый раз нам нужно проверять только минимальные подходящие гласную и согласную буквы.Также нужно не забыть случай, когда все буквы в языке одной гласности.Сложность — O(nm)568D - Указательные столбыПредположим, что решение есть. Если n ≤ k, то мы можем на каждую дорогу поставить по столбу. Иначе рассмотрим любые k + 1 дорогу. По принципу Дирихле среди них найдутся две, для которых будет общий указатель. Переберём эту пару дорог, поставим столб на их пересечение, уберем дороги, которые тоже проходят через эту точку. Мы свели задачу к меньшему числу столбов. Таким рекурсивным перебором мы решим задачу (если решение существует).Решение это работает за . Если написать аккуратно, это может зайти.Но это решение можно ускорить. Заметим, что если у нас есть точка, через которую проходит хотя бы k + 1 дорога, то мы обязаны поставить столб в эту точку. При достаточно больших n (у меня в решении отсечка n > 30k2) такая точка точно есть (если решение существует), причём её можно искать вероятностным алгоритмом. При условии, что решение существует, вероятность, что две произвольные дороги пересекаются в такой точке не меньше , поэтому если попробовать 100 раз, то с вероятностью такая точка найдется, и мы сможем уменьшить k.Все проверки можно делать в целых числах.Сложность — .568E - Наибольшая возрастающая подпоследовательностьБудем поддерживать массив c: c[len] — минимальное число, на которое может заканчиваться возрастающая подпоследовательность длины len (Одно из двух стандартных решений задачи о наибольшей возрастающей подпоследовательности). Элементы этого массива возрастают и добавление очередного элемента v к обработанной части последовательности сводится к нахождению такого i, что c[i] ≤ v и c[i + 1] ≥ v. При обработке пропуска нам нужно попробовать вставить все числа из множества b. Предварительно их отсортировав и двигаясь двумя указателями вдоль массивов b и c мы можем проделать нужные обновления за O(n + m).Авторами подразумевалось использование O(n) памяти для восстановления ответа. Этого можно добиться следующим образом: 1. Параллельно с массивом c будем хранить массив cindex[len] — индекс элемента, на который заканчивается оптимальная НВП длины len. Если она заканчивается в пропуске — будем хранить, например,  - 1. 2. Также сохраним для каждого не пропуска — длину НВП(lenLIS[pos]), заканчивающейся в этой позиции (это несложно делается в процессе вычисления массива c) и позицию(prevIndex[pos]) предыдущего элемента в этой НВП (если это пропуск, опять же  - 1).Теперь приступим к восстановлению ответа. Пока мы не наткнулись на пропуск — можно спокойно восстанавливать НВП с конца. Сложность обнаруживается, когда несколько следующих элементов последовательности попали в пропуски. Но можно несложно определить что это за пропуски и чем их заполнить. А именно: пусть сейчас мы стоим в позиции r. Нам нужно найти такую позицию l (не пропуск), что мы сможем заполнить ровно lenLIS[r] - lenLIS[l] пропусков между l и r возрастающими числами в интервале (a[l]..a[r]). Позицию l можно итеративно перебирать от r - 1 до 0, параллельно насчитывая число пройденных пропусков. Проверку условия описанного выше можно несложно сделать с помощью пары бинпоисков.Немного подробнее и с деталями: Как узнать, что между позициями l и r можно заполнить пропуски так, чтобы не ухудшить генерируемый ответ?Пусть countSkip(l, r) — количество пропусков на интервале (l..r), а countBetween(x, y) — количество различных чисел из множества b, лежaщих в интервале (x..y). Тогда позиции l и r хорошие тогда и только тогда, когда lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip можно насчитывать в процессе уменьшения границы l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). Что делать, если НВП заканчивается или начинается в пропуске (тогда мы не знаем, откуда начать/где закончить)?Наиболее простым решением будет добавить  - ∞ и  + ∞ в начало и конец нашего массива соответственно. Это позволит избежать проблем с такими крайними случаями. Сложность — времени, O(n + m) памяти",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 568\\s*D"
          },
          "content_length": 8005
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "Это второй наш раунд, первый пришелся на черные дни Codeforces, и мы надеемся, что второй наш раунд не вызовет таких катаклизмов...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 7",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 100000;\n    const int MAXK = 5;\n    const int MAXCOEF = 100000;\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, MAXK, \"k\");\n    inf.readEoln();\n\n    map<tuple<long long, long long, long long>, int> line_map;\n\n    for (int i = 0; i < n; ++i) {\n        long long A = inf.readInt(-MAXCOEF, MAXCOEF, \"A_i\");\n        inf.readSpace();\n        long long B = inf.readInt(-MAXCOEF, MAXCOEF, \"B_i\");\n        inf.readSpace();\n        long long C = inf.readInt(-MAXCOEF, MAXCOEF, \"C_i\");\n        inf.readEoln();\n\n        ensuref(A != 0 || B != 0, \"Coefficients A_i and B_i cannot both be zero at line %d\", i + 2);\n\n        long long G = __gcd(abs(A), abs(B));\n        G = __gcd(G, abs(C));\n\n        // Divide by G\n        A /= G;\n        B /= G;\n        C /= G;\n\n        // Normalize sign\n        if (A != 0) {\n            if (A < 0) {\n                A = -A;\n                B = -B;\n                C = -C;\n            }\n        } else { // A == 0, so B != 0\n            if (B < 0) {\n                B = -B;\n                C = -C;\n            }\n        }\n\n        tuple<long long, long long, long long> line = make_tuple(A, B, C);\n\n        if (line_map.count(line)) {\n            int prev_line = line_map[line];\n            ensuref(false, \"Lines %d and %d are coinciding\", prev_line + 1, i + 1);\n        } else {\n            line_map[line] = i;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 100000;\n    const int MAXK = 5;\n    const int MAXCOEF = 100000;\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, MAXK, \"k\");\n    inf.readEoln();\n\n    map<tuple<long long, long long, long long>, int> line_map;\n\n    for (int i = 0; i < n; ++i) {\n        long long A = inf.readInt(-MAXCOEF, MAXCOEF, \"A_i\");\n        inf.readSpace();\n        long long B = inf.readInt(-MAXCOEF, MAXCOEF, \"B_i\");\n        inf.readSpace();\n        long long C = inf.readInt(-MAXCOEF, MAXCOEF, \"C_i\");\n        inf.readEoln();\n\n        ensuref(A != 0 || B != 0, \"Coefficients A_i and B_i cannot both be zero at line %d\", i + 2);\n\n        long long G = __gcd(abs(A), abs(B));\n        G = __gcd(G, abs(C));\n\n        // Divide by G\n        A /= G;\n        B /= G;\n        C /= G;\n\n        // Normalize sign\n        if (A != 0) {\n            if (A < 0) {\n                A = -A;\n                B = -B;\n                C = -C;\n            }\n        } else { // A == 0, so B != 0\n            if (B < 0) {\n                B = -B;\n                C = -C;\n            }\n        }\n\n        tuple<long long, long long, long long> line = make_tuple(A, B, C);\n\n        if (line_map.count(line)) {\n            int prev_line = line_map[line];\n            ensuref(false, \"Lines %d and %d are coinciding\", prev_line + 1, i + 1);\n        } else {\n            line_map[line] = i;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 100000;\n    const int MAXK = 5;\n    const int MAXCOEF = 100000;\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, MAXK, \"k\");\n    inf.readEoln();\n\n    map<tuple<long long, long long, long long>, int> line_map;\n\n    for (int i = 0; i < n; ++i) {\n        long long A = inf.readInt(-MAXCOEF, MAXCOEF, \"A_i\");\n        inf.readSpace();\n        long long B = inf.readInt(-MAXCOEF, MAXCOEF, \"B_i\");\n        inf.readSpace();\n        long long C = inf.readInt(-MAXCOEF, MAXCOEF, \"C_i\");\n        inf.readEoln();\n\n        ensuref(A != 0 || B != 0, \"Coefficients A_i and B_i cannot both be zero at line %d\", i + 2);\n\n        long long G = __gcd(abs(A), abs(B));\n        G = __gcd(G, abs(C));\n\n        // Divide by G\n        A /= G;\n        B /= G;\n        C /= G;\n\n        // Normalize sign\n        if (A != 0) {\n            if (A < 0) {\n                A = -A;\n                B = -B;\n                C = -C;\n            }\n        } else { // A == 0, so B != 0\n            if (B < 0) {\n                B = -B;\n                C = -C;\n            }\n        }\n\n        tuple<long long, long long, long long> line = make_tuple(A, B, C);\n\n        if (line_map.count(line)) {\n            int prev_line = line_map[line];\n            ensuref(false, \"Lines %d and %d are coinciding\", prev_line + 1, i + 1);\n        } else {\n            line_map[line] = i;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll store each road as (A, B, C). The equation of the road is A*x + B*y + C = 0.\nstatic const long long INF_LL = (long long)1 << 60;\n\nstruct Road {\n    long long A, B, C;\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input data.\n    int n = inf.readInt(1, 100000, \"n\");\n    int k = inf.readInt(1, 5, \"k\");\n    vector<Road> roads(n);\n    for(int i = 0; i < n; i++){\n        long long A = inf.readLong(-100000, 100000, \"A\");\n        long long B = inf.readLong(-100000, 100000, \"B\");\n        long long C = inf.readLong(-100000, 100000, \"C\");\n        // Make sure A^2 + B^2 != 0\n        if(A == 0 && B == 0) {\n            quitf(_fail, \"Invalid input: A=0 and B=0 for road %d\", i + 1);\n        }\n        roads[i] = {A, B, C};\n    }\n\n    // We define a function that parses an answer (either from ans or ouf),\n    // checks correctness, and returns (feasible, coverage[]).\n    // feasible = true/false depending on whether the stream says \"YES\"/\"NO\".\n    // coverage[i] = true if road i is covered by at least one sign.\n    auto parseAnswer = [&](InStream &stream) {\n        vector<bool> covered(n, false);\n        // read either YES or NO\n        string token = stream.readToken();\n        if(token == \"NO\" || token == \"No\" || token == \"no\"){\n            // The stream claims \"NO\" solution.\n            return make_pair(false, covered);\n        }\n        else if(token == \"YES\" || token == \"Yes\" || token == \"yes\"){\n            // The stream claims there is a solution.\n            // Next read m, the number of used signs (must be 0 <= m <= k).\n            int m = stream.readInt(0, k, \"m\");\n\n            // A small helper that checks if line i passes the point (x, y) in rational form:\n            // x = Xnum / Den, y = Ynum / Den. We want A_i*x + B_i*y + C_i == 0 exactly in integer arithmetic.\n            // We'll check if A_i*Xnum + B_i*Ynum + C_i*Den == 0.\n            auto coversRoad = [&](int i, long long Xnum, long long Ynum, long long Den) {\n                long long val = roads[i].A * Xnum + roads[i].B * Ynum + roads[i].C * Den;\n                return (val == 0);\n            };\n\n            // We'll read the signs and mark coverage accordingly.\n            for(int i = 0; i < m; i++){\n                // Use an overload that accepts bounds plus a variable name (for diagnosing errors).\n                // We allow -1 up to n, then check validity manually below.\n                int v = stream.readInt(-1, n, \"v\");\n                int u = stream.readInt(-1, n, \"u\");\n\n                // Checking validity per the statement:\n                // \"If u = -1, and v is in [1..n], the sign is on the road v in a point not lying on any other road.\"\n                // \"If u != -1, then both v and u must be in [1..n], v != u, and the roads must intersect.\"\n                // If invalid, stream.quitf(...) with _wa.\n\n                // If u == -1, then v must be in [1..n].\n                if(u == -1){\n                    if(v < 1 || v > n){\n                        stream.quitf(_wa, \"Invalid sign description: for (v, u) = (%d, -1), v must be in [1..n]\", v);\n                    }\n                    // This sign covers only road v\n                    covered[v - 1] = true;\n                }\n                else {\n                    // then both v and u must be in [1..n], and must be distinct\n                    if(v < 1 || v > n) {\n                        stream.quitf(_wa, \"Invalid sign description: v=%d is out of [1..n]\", v);\n                    }\n                    if(u < 1 || u > n) {\n                        stream.quitf(_wa, \"Invalid sign description: u=%d is out of [1..n]\", u);\n                    }\n                    if(v == u) {\n                        stream.quitf(_wa, \"Invalid sign description: v = u = %d is not allowed\", v);\n                    }\n                    // Check that roads v and u intersect (not parallel).\n                    long long A1 = roads[v-1].A, B1 = roads[v-1].B, C1 = roads[v-1].C;\n                    long long A2 = roads[u-1].A, B2 = roads[u-1].B, C2 = roads[u-1].C;\n                    long long D = A1*B2 - A2*B1;\n                    if(D == 0) {\n                        // lines do not intersect in a single point\n                        stream.quitf(_wa, \"Roads %d and %d do not intersect (they must be parallel or coincident)\", v, u);\n                    }\n                    // Intersection in rational form:\n                    // x = (B1*C2 - B2*C1)/D,  y = (C1*A2 - C2*A1)/D.\n                    long long Xnum = B1*C2 - B2*C1;\n                    long long Ynum = C1*A2 - C2*A1;\n                    // We'll cover any road i for which A_i * Xnum + B_i * Ynum + C_i * D = 0.\n                    for(int r = 0; r < n; r++){\n                        if(coversRoad(r, Xnum, Ynum, D)) {\n                            covered[r] = true;\n                        }\n                    }\n                }\n            }\n\n            // Now we have covered[] for all roads. We must check all roads are covered.\n            for(int i = 0; i < n; i++){\n                if(!covered[i]) {\n                    stream.quitf(_wa, \"Not all roads are covered. Road %d is not covered.\", i + 1);\n                }\n            }\n            return make_pair(true, covered);\n        }\n        else {\n            stream.quitf(_wa, \"Expected YES or NO, found \\\"%s\\\"\", token.c_str());\n            // Dummy return to appease compiler.\n            return make_pair(false, covered);\n        }\n    };\n\n    // Parse jury's answer.\n    auto juryAns = parseAnswer(ans);\n    bool jFeasible = juryAns.first;\n    // Parse participant's answer.\n    auto partAns = parseAnswer(ouf);\n    bool pFeasible = partAns.first;\n\n    // If jury says NO but participant says YES => either _fail or _ok if participant's is correct?\n    // The problem statement logic: if jury says NO, we treat that as the official solution being no.\n    // If participant claims YES and produced a valid solution, it must be a contradiction => _fail.\n    // If participant's solution was invalid, they'd get _wa first anyway.\n    if(!jFeasible && pFeasible){\n        quitf(_fail, \"Participant found a solution, but jury says NO.\");\n    }\n    // If jury says YES but participant says NO => WA\n    if(jFeasible && !pFeasible){\n        quitf(_wa, \"A solution exists (jury's YES) but participant printed NO.\");\n    }\n    // If both say NO => OK\n    if(!jFeasible && !pFeasible){\n        quitf(_ok, \"Both jury and participant agree that there is no solution.\");\n    }\n    // If both say YES => OK\n    quitf(_ok, \"Both jury and participant solutions are feasible.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    if (type == \"single_point\") {\n        /* Generate n lines passing through (0,0), no duplicates */\n        vector<int> Bs;\n        for (int i = -100000; i <= 100000; ++i) {\n            if (i != 0)\n                Bs.push_back(i);\n        }\n        shuffle(Bs.begin(), Bs.end());\n\n        for (int i = 0; i < n; ++i) {\n            int Ai = 1;\n            int Bi = Bs[i];\n            int Ci = 0;\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n        }\n    } else if (type == \"parallel\") {\n        /* Generate n parallel lines */\n        for (int i = 0; i < n; ++i) {\n            int Ai = 1;\n            int Bi = 0;\n            int Ci = -(-100000 + i % 200001);\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n        }\n    } else if (type == \"random\") {\n        /* Generate random lines */\n        set<tuple<int, int, int>> lines;\n        for (int i = 0; i < n; ) {\n            int Ai = rnd.next(-100000, 100000);\n            int Bi = rnd.next(-100000, 100000);\n            if (Ai == 0 && Bi == 0) continue;\n            int Ci = rnd.next(-100000, 100000);\n            int g = __gcd(__gcd(abs(Ai), abs(Bi)), abs(Ci));\n            if (g != 0) {\n                Ai /= g; Bi /= g; Ci /= g;\n            }\n            if (Ai < 0 || (Ai == 0 && Bi < 0) || (Ai == 0 && Bi == 0 && Ci < 0)) {\n                Ai = -Ai; Bi = -Bi; Ci = -Ci;\n            }\n            auto key = make_tuple(Ai, Bi, Ci);\n            if (lines.count(key)) continue;\n            lines.insert(key);\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n            ++i;\n        }\n    } else {\n        /* Default to random */\n        /* Generate random lines */\n        set<tuple<int, int, int>> lines;\n        for (int i = 0; i < n; ) {\n            int Ai = rnd.next(-100000, 100000);\n            int Bi = rnd.next(-100000, 100000);\n            if (Ai == 0 && Bi == 0) continue;\n            int Ci = rnd.next(-100000, 100000);\n            int g = __gcd(__gcd(abs(Ai), abs(Bi)), abs(Ci));\n            if (g != 0) {\n                Ai /= g; Bi /= g; Ci /= g;\n            }\n            if (Ai < 0 || (Ai == 0 && Bi < 0) || (Ai == 0 && Bi == 0 && Ci < 0)) {\n                Ai = -Ai; Bi = -Bi; Ci = -Ci;\n            }\n            auto key = make_tuple(Ai, Bi, Ci);\n            if (lines.count(key)) continue;\n            lines.insert(key);\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n            ++i;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    if (type == \"single_point\") {\n        /* Generate n lines passing through (0,0), no duplicates */\n        vector<int> Bs;\n        for (int i = -100000; i <= 100000; ++i) {\n            if (i != 0)\n                Bs.push_back(i);\n        }\n        shuffle(Bs.begin(), Bs.end());\n\n        for (int i = 0; i < n; ++i) {\n            int Ai = 1;\n            int Bi = Bs[i];\n            int Ci = 0;\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n        }\n    } else if (type == \"parallel\") {\n        /* Generate n parallel lines */\n        for (int i = 0; i < n; ++i) {\n            int Ai = 1;\n            int Bi = 0;\n            int Ci = -(-100000 + i % 200001);\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n        }\n    } else if (type == \"random\") {\n        /* Generate random lines */\n        set<tuple<int, int, int>> lines;\n        for (int i = 0; i < n; ) {\n            int Ai = rnd.next(-100000, 100000);\n            int Bi = rnd.next(-100000, 100000);\n            if (Ai == 0 && Bi == 0) continue;\n            int Ci = rnd.next(-100000, 100000);\n            int g = __gcd(__gcd(abs(Ai), abs(Bi)), abs(Ci));\n            if (g != 0) {\n                Ai /= g; Bi /= g; Ci /= g;\n            }\n            if (Ai < 0 || (Ai == 0 && Bi < 0) || (Ai == 0 && Bi == 0 && Ci < 0)) {\n                Ai = -Ai; Bi = -Bi; Ci = -Ci;\n            }\n            auto key = make_tuple(Ai, Bi, Ci);\n            if (lines.count(key)) continue;\n            lines.insert(key);\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n            ++i;\n        }\n    } else {\n        /* Default to random */\n        /* Generate random lines */\n        set<tuple<int, int, int>> lines;\n        for (int i = 0; i < n; ) {\n            int Ai = rnd.next(-100000, 100000);\n            int Bi = rnd.next(-100000, 100000);\n            if (Ai == 0 && Bi == 0) continue;\n            int Ci = rnd.next(-100000, 100000);\n            int g = __gcd(__gcd(abs(Ai), abs(Bi)), abs(Ci));\n            if (g != 0) {\n                Ai /= g; Bi /= g; Ci /= g;\n            }\n            if (Ai < 0 || (Ai == 0 && Bi < 0) || (Ai == 0 && Bi == 0 && Ci < 0)) {\n                Ai = -Ai; Bi = -Bi; Ci = -Ci;\n            }\n            auto key = make_tuple(Ai, Bi, Ci);\n            if (lines.count(key)) continue;\n            lines.insert(key);\n            printf(\"%d %d %d\\n\", Ai, Bi, Ci);\n            ++i;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type single_point\n./gen -n 2 -k 1 -type single_point\n./gen -n 100 -k 1 -type single_point\n./gen -n 1000 -k 1 -type single_point\n./gen -n 100000 -k 1 -type single_point\n\n./gen -n 1 -k 1 -type parallel\n./gen -n 2 -k 1 -type parallel\n./gen -n 5 -k 1 -type parallel\n./gen -n 100 -k 1 -type parallel\n./gen -n 1000 -k 1 -type parallel\n./gen -n 100000 -k 1 -type parallel\n\n./gen -n 1 -k 1 -type random\n./gen -n 10 -k 2 -type random\n./gen -n 100 -k 3 -type random\n./gen -n 1000 -k 4 -type random\n./gen -n 10000 -k 5 -type random\n./gen -n 100000 -k 5 -type random\n\n# Edge cases with maximum n and minimum k\n./gen -n 100000 -k 1 -type single_point\n./gen -n 100000 -k 1 -type parallel\n./gen -n 100000 -k 1 -type random\n\n# Test cases that are likely to output NO\n./gen -n 1000 -k 1 -type parallel\n./gen -n 100000 -k 2 -type parallel\n./gen -n 100000 -k 5 -type parallel\n\n# Test cases with random types and varying k\n./gen -n 99999 -k 2 -type random\n./gen -n 50000 -k 3 -type random\n./gen -n 25000 -k 4 -type random\n\n# Small n and k\n./gen -n 2 -k 2 -type single_point\n./gen -n 3 -k 3 -type parallel\n./gen -n 5 -k 5 -type random\n\n# Maximum possible n and k\n./gen -n 100000 -k 5 -type single_point\n./gen -n 100000 -k 5 -type parallel\n./gen -n 100000 -k 5 -type random\n\n# Test cases with varying n and k\n./gen -n 50000 -k 1 -type random\n./gen -n 75000 -k 1 -type random\n./gen -n 80000 -k 5 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:10.217669",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "568/E",
      "title": "E. Longest Increasing Subsequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test128 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the length of the array (1 ≤ n ≤ 105).The second line contains n space-separated integers — the elements of the sequence. A gap is marked as \"-1\". The elements that are not gaps are positive integers not exceeding 109. It is guaranteed that the sequence contains 0 ≤ k ≤ 1000 gaps.The third line contains a single positive integer m — the number of elements to fill the gaps (k ≤ m ≤ 105).The fourth line contains m positive integers — the numbers to fill gaps. Each number is a positive integer not exceeding 109. Some numbers may be equal.",
      "output_spec": "OutputPrint n space-separated numbers in a single line — the resulting sequence. If there are multiple possible answers, print any of them.",
      "sample_tests": "ExamplesInputCopy31 2 3110OutputCopy1 2 3 InputCopy31 -1 331 2 3OutputCopy1 2 3 InputCopy2-1 222 4OutputCopy2 2 InputCopy3-1 -1 -151 1 1 1 2OutputCopy1 1 2 InputCopy4-1 -1 -1 241 1 2 2OutputCopy1 2 1 2",
      "description": "E. Longest Increasing Subsequence\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test128 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n — the length of the array (1 ≤ n ≤ 105).The second line contains n space-separated integers — the elements of the sequence. A gap is marked as \"-1\". The elements that are not gaps are positive integers not exceeding 109. It is guaranteed that the sequence contains 0 ≤ k ≤ 1000 gaps.The third line contains a single positive integer m — the number of elements to fill the gaps (k ≤ m ≤ 105).The fourth line contains m positive integers — the numbers to fill gaps. Each number is a positive integer not exceeding 109. Some numbers may be equal.\n\nOutputPrint n space-separated numbers in a single line — the resulting sequence. If there are multiple possible answers, print any of them.\n\nInputCopy31 2 3110OutputCopy1 2 3 InputCopy31 -1 331 2 3OutputCopy1 2 3 InputCopy2-1 222 4OutputCopy2 2 InputCopy3-1 -1 -151 1 1 1 2OutputCopy1 1 2 InputCopy4-1 -1 -1 241 1 2 2OutputCopy1 2 1 2\n\nInputCopy31 2 3110\n\nOutputCopy1 2 3\n\nInputCopy31 -1 331 2 3\n\nOutputCopy1 2 3\n\nInputCopy2-1 222 4\n\nOutputCopy2 2\n\nInputCopy3-1 -1 -151 1 1 1 2\n\nOutputCopy1 1 2\n\nInputCopy4-1 -1 -1 241 1 2 2\n\nOutputCopy1 2 1 2\n\nNoteIn the first sample there are no gaps, so the correct answer is the initial sequence.In the second sample there is only one way to get an increasing subsequence of length 3.In the third sample answer \"4 2\" would also be correct. Note that only strictly increasing subsequences are considered.In the fifth sample the answer \"1 1 1 2\" is not considered correct, as number 1 can be used in replacing only two times.",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 568\\s*E"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int k = 0; // number of gaps (-1's)\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        int x = inf.readInt(-1, 1000000000);\n        if (x == -1) k++;\n        else ensuref(x >= 1, \"Array elements must be either -1 or positive integers <= 1e9\");\n    }\n    inf.readEoln();\n\n    ensuref(0 <= k && k <= 1000, \"Number of gaps (k=%d) must be between 0 and 1000 inclusive\", k);\n\n    int m = inf.readInt(k, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> gap_numbers = inf.readInts(m, 1, 1000000000, \"gap_numbers\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int k = 0; // number of gaps (-1's)\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        int x = inf.readInt(-1, 1000000000);\n        if (x == -1) k++;\n        else ensuref(x >= 1, \"Array elements must be either -1 or positive integers <= 1e9\");\n    }\n    inf.readEoln();\n\n    ensuref(0 <= k && k <= 1000, \"Number of gaps (k=%d) must be between 0 and 1000 inclusive\", k);\n\n    int m = inf.readInt(k, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> gap_numbers = inf.readInts(m, 1, 1000000000, \"gap_numbers\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int k = 0; // number of gaps (-1's)\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        int x = inf.readInt(-1, 1000000000);\n        if (x == -1) k++;\n        else ensuref(x >= 1, \"Array elements must be either -1 or positive integers <= 1e9\");\n    }\n    inf.readEoln();\n\n    ensuref(0 <= k && k <= 1000, \"Number of gaps (k=%d) must be between 0 and 1000 inclusive\", k);\n\n    int m = inf.readInt(k, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> gap_numbers = inf.readInts(m, 1, 1000000000, \"gap_numbers\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nvector<int> initSeq;\nvector<int> indicesGaps;\nmultiset<int> gapFillers;\n\nint readAndValidateOutput(InStream& stream, vector<int>& outputSeq, const multiset<int>& initialGapFillers){\n    // Read the output sequence from the participant or jury.\n\n    outputSeq.resize(n);\n\n    // Read n integers\n    for(int i = 0; i < n; i++){\n        outputSeq[i] = stream.readInt(1, 1000000000, format(\"outputSeq[%d]\", i + 1).c_str());\n    }\n\n    // Check that elements not at gaps match the input sequence.\n    for(int i = 0; i < n; i++){\n        if(initSeq[i] != -1){\n            if(initSeq[i] != outputSeq[i]){\n                stream.quitf(_wa, \"Element at position %d should be %d but found %d\", i+1, initSeq[i], outputSeq[i]);\n            }\n        }\n    }\n\n    // For elements at gaps, make sure the numbers are from gapFillers, and each is used at most once.\n\n    multiset<int> gapFillers = initialGapFillers;\n\n    for(int idx : indicesGaps){\n        int value = outputSeq[idx];\n        // Need to check whether value is in gapFillers\n        auto it = gapFillers.find(value);\n        if(it == gapFillers.end()){\n            // Value is not in gapFillers\n            stream.quitf(_wa, \"Value %d used to fill gap at position %d is not available\", value, idx + 1);\n        }else{\n            // Remove the used value from gapFillers\n            gapFillers.erase(it);\n        }\n    }\n\n    // Now compute the length of the Longest Increasing Subsequence (LIS)\n    vector<int> dp;\n    for(int i = 0; i < n; i++){\n        auto it = lower_bound(dp.begin(), dp.end(), outputSeq[i]);\n        if(it == dp.end()){\n            dp.push_back(outputSeq[i]);\n        }else{\n            *it = outputSeq[i];\n        }\n    }\n    return dp.size();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 100000, \"n\");\n    initSeq.resize(n);\n    indicesGaps.clear();\n    for(int i = 0; i < n; ++i){\n        int temp = inf.readInt(-1, 1000000000, format(\"initSeq[%d]\", i + 1).c_str());\n        initSeq[i] = temp;\n        if(temp == -1){\n            indicesGaps.push_back(i);\n        }\n    }\n    k = indicesGaps.size();\n    m = inf.readInt(k, 100000, \"m\");\n\n    gapFillers.clear();\n    for(int i = 0; i < m; ++i){\n        int num = inf.readInt(1, 1000000000, format(\"gapFillers[%d]\", i + 1).c_str());\n        gapFillers.insert(num);\n    }\n\n    // Read the jury's answer and compute its LIS length\n    vector<int> jurySeq;\n    int juryLISLength = readAndValidateOutput(ans, jurySeq, gapFillers);\n\n    // Read the participant's output and compute its LIS length\n    vector<int> participantSeq;\n    int participantLISLength = readAndValidateOutput(ouf, participantSeq, gapFillers);\n\n    if(participantLISLength < juryLISLength){\n        quitf(_wa, \"Your answer has LIS length %d, but the maximum possible is %d.\", participantLISLength, juryLISLength);\n    }else if(participantLISLength == juryLISLength){\n        quitf(_ok, \"Correct answer with LIS length %d.\", participantLISLength);\n    }else{\n        quitf(_fail, \"Participant's answer has LIS length %d greater than jury's %d.\", participantLISLength, juryLISLength);\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_K = 1000;\nconst int MAX_M = 100000;\nconst int MAX_VAL = 1000000000; // 1e9\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    int m = opt<int>(\"m\", k);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensuref(1 <= n && n <= MAX_N, \"n is out of bounds\");\n    ensuref(0 <= k && k <= MAX_K && k <= n, \"k is out of bounds\");\n    ensuref(k <= m && m <= MAX_M, \"m is out of bounds\");\n\n    vector<int> A(n);\n    vector<int> gaps_positions;\n\n    if (type == \"random\") {\n        // Generate random positions for gaps\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = rnd.next(1, MAX_VAL);\n            }\n        }\n\n    } else if (type == \"increasing\") {\n        // Initial array is increasing\n        int curr_val = 1;\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = curr_val;\n                curr_val += rnd.next(1, 10); // Increase by up to 10\n            }\n        }\n\n    } else if (type == \"decreasing\") {\n        // Initial array is decreasing\n        int curr_val = MAX_VAL;\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = curr_val;\n                curr_val -= rnd.next(1, 10); // Decrease by up to 10\n                if (curr_val < 1) curr_val = 1;\n            }\n        }\n\n    } else if (type == \"duplicates\") {\n        // Initial array with many duplicates\n        int num_values = rnd.next(1, 10);\n        vector<int> values(num_values);\n        for (int i = 0; i < num_values; ++i) {\n            values[i] = rnd.next(1, MAX_VAL);\n        }\n\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = values[rnd.next(0, num_values - 1)];\n            }\n        }\n\n    } else if (type == \"max_gaps\") {\n        // Maximize the number of gaps at the beginning\n        k = min(k, n);\n        for (int i = 0; i < n; ++i) {\n            if (i < k) {\n                A[i] = -1;\n            } else {\n                A[i] = rnd.next(1, MAX_VAL);\n            }\n        }\n\n    } else {\n        ensuref(false, \"Unknown type\");\n    }\n\n    // Generate the set S\n    vector<int> S(m);\n    for (int i = 0; i < m; ++i) {\n        S[i] = rnd.next(1, MAX_VAL);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", A[i], i + 1 == n ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", S[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_K = 1000;\nconst int MAX_M = 100000;\nconst int MAX_VAL = 1000000000; // 1e9\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    int m = opt<int>(\"m\", k);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensuref(1 <= n && n <= MAX_N, \"n is out of bounds\");\n    ensuref(0 <= k && k <= MAX_K && k <= n, \"k is out of bounds\");\n    ensuref(k <= m && m <= MAX_M, \"m is out of bounds\");\n\n    vector<int> A(n);\n    vector<int> gaps_positions;\n\n    if (type == \"random\") {\n        // Generate random positions for gaps\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = rnd.next(1, MAX_VAL);\n            }\n        }\n\n    } else if (type == \"increasing\") {\n        // Initial array is increasing\n        int curr_val = 1;\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = curr_val;\n                curr_val += rnd.next(1, 10); // Increase by up to 10\n            }\n        }\n\n    } else if (type == \"decreasing\") {\n        // Initial array is decreasing\n        int curr_val = MAX_VAL;\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = curr_val;\n                curr_val -= rnd.next(1, 10); // Decrease by up to 10\n                if (curr_val < 1) curr_val = 1;\n            }\n        }\n\n    } else if (type == \"duplicates\") {\n        // Initial array with many duplicates\n        int num_values = rnd.next(1, 10);\n        vector<int> values(num_values);\n        for (int i = 0; i < num_values; ++i) {\n            values[i] = rnd.next(1, MAX_VAL);\n        }\n\n        gaps_positions.resize(k);\n        set<int> gap_pos_set;\n        while ((int)gap_pos_set.size() < k) {\n            int pos = rnd.next(0, n - 1);\n            if (gap_pos_set.count(pos) == 0)\n                gap_pos_set.insert(pos);\n        }\n        copy(gap_pos_set.begin(), gap_pos_set.end(), gaps_positions.begin());\n        sort(gaps_positions.begin(), gaps_positions.end());\n\n        int gap_idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (gap_idx < k && i == gaps_positions[gap_idx]) {\n                A[i] = -1;\n                ++gap_idx;\n            } else {\n                A[i] = values[rnd.next(0, num_values - 1)];\n            }\n        }\n\n    } else if (type == \"max_gaps\") {\n        // Maximize the number of gaps at the beginning\n        k = min(k, n);\n        for (int i = 0; i < n; ++i) {\n            if (i < k) {\n                A[i] = -1;\n            } else {\n                A[i] = rnd.next(1, MAX_VAL);\n            }\n        }\n\n    } else {\n        ensuref(false, \"Unknown type\");\n    }\n\n    // Generate the set S\n    vector<int> S(m);\n    for (int i = 0; i < m; ++i) {\n        S[i] = rnd.next(1, MAX_VAL);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", A[i], i + 1 == n ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", S[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n./gen -n 1 -k 0 -type increasing\n\n./gen -n 5 -k 0 -type increasing\n./gen -n 5 -k 0 -type decreasing\n./gen -n 5 -k 2 -m 2 -type duplicates\n\n./gen -n 10 -k 5 -m 5 -type random\n./gen -n 10 -k 5 -m 5 -type increasing\n./gen -n 10 -k 5 -m 5 -type decreasing\n./gen -n 10 -k 5 -m 10 -type duplicates\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 500 -m 500 -type random\n./gen -n 1000 -k 500 -m 5000 -type duplicates\n\n./gen -n 100000 -k 0 -type random\n./gen -n 100000 -k 1000 -m 1000 -type random\n./gen -n 100000 -k 1000 -m 1000 -type increasing\n./gen -n 100000 -k 1000 -m 1000 -type decreasing\n./gen -n 100000 -k 1000 -m 1000 -type duplicates\n\n./gen -n 100000 -k 1000 -m 100000 -type random\n./gen -n 100000 -k 1000 -m 100000 -type increasing\n./gen -n 100000 -k 1000 -m 100000 -type decreasing\n./gen -n 100000 -k 1000 -m 100000 -type duplicates\n\n./gen -n 100000 -k 1000 -type max_gaps\n./gen -n 100000 -k 1000 -m 100000 -type max_gaps\n\n./gen -n 50000 -k 500 -m 500 -type random\n./gen -n 50000 -k 500 -m 50000 -type duplicates\n\n./gen -n 100000 -k 0 -type increasing\n./gen -n 100000 -k 0 -type decreasing\n./gen -n 100000 -k 0 -type duplicates\n\n./gen -n 100000 -k 1000 -m 50000 -type increasing\n./gen -n 100000 -k 1000 -m 50000 -type decreasing\n./gen -n 100000 -k 1000 -m 50000 -type duplicates\n\n./gen -n 100000 -k 1000 -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:12.637324",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "569/A",
      "title": "A. Музыка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строчке записаны три целых числа T, S, q (2 ≤ q ≤ 104, 1 ≤ S < T ≤ 105).",
      "output_spec": "Выходные данныеВыведите одно целое число — количество запусков композиции.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 2 2Выходные данныеСкопировать2Входные данныеСкопировать5 4 7Выходные данныеСкопировать1Входные данныеСкопировать6 2 3Выходные данныеСкопировать1",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строчке записаны три целых числа T, S, q (2 ≤ q ≤ 104, 1 ≤ S < T ≤ 105).\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — количество запусков композиции.\n\nВыходные данные\n\nВходные данныеСкопировать5 2 2Выходные данныеСкопировать2Входные данныеСкопировать5 4 7Выходные данныеСкопировать1Входные данныеСкопировать6 2 3Выходные данныеСкопировать1\n\nВходные данныеСкопировать5 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 4 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте песня проигрывается в два раза быстрее, чем скачивается, а значит через четыре секунды Лёша впервые дослушает до момента, который ещё не прогрузился, и запустит песню заново. Ещё через две секунды песня скачается полностью, а значит Лёша запустит песню два раза.Во втором тесте песня уже почти скачана, и Лёша запустит её всего один раз.В третем тесте из условия загрузка заканчивается и Лёша завершает прослушивание песни в один и тот же момент. Обратите внимание, что в таком случае Лёша не перезапускает песню заново.",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Всем доброго времени суток.Скоро состоится Codeforces Round #315, авторами которого являются студенты УрФУ sivukhin и Um_nik. Это второй наш раунд, первый пришелся на черные дни Codeforces, и мы надеемся, что второй наш раунд не вызовет таких катаклизмов :)Мы хотим поблагодарить команду Codeforces за эту замечательную платформу и Polygon. Особенно хотим отметить Zlobober за помощь в подготовке задач.Желаем всем удачи!UPD1:Разбалловка.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500Настоятельно рекомендуем прочитать условия всех задач. Мы постарались подготовить достаточно разнообразные задачи, вполне возможно, что сложные для нас задачи будут простыми для вас.UPD2:РазборUPD3:Поздравляем победителей!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinВсем спасибо за участие.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 852
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - МузыкаПусть перед очередным запуском прогружено S секунд песни, найдем, сколько будет прогружено перед следующим запуском. . Отсюда x = qS.Тогда решение: будем умножать S на q пока S < T. Количество таких умножений — это ответ.Сложность — 569B - ИнвентаризацияПодойдём к задаче с другой стороны: а сколько максимально можно оставить номеров, чтобы получилась перестановка? Очевидно, что эти номера должны быть от 1 до n, причем среди них не должно быть повторяющихся. И понятно, что это условие необходимое и достаточное.Такую задачу можно решать жадным алгоритмом. Если мы встретили число, которого ещё не было, при этом оно от 1 до n, то мы его оставим. Для реализации можно завести массив used, в котором отмечать уже использованные числа.Затем нужно ещё раз пройти по массиву и распределить неиспользованные числа.Сложность — O(n).568A - Простые или палиндромы?Известно, что количество простых чисел, не превосходящих n, — число порядка .Если мы зафиксируем длину числа k, то количество палиндромных чисел такой длины будет порядка . Это .Таким образом, количество простых чисел асимптотически больше количества палиндромных чисел, а значит для любой константы A найдётся ответ. И для такого ответа . В нашем случае n будут не больше 107.Поэтому мы можем для всех чисел до 107 проверить, являются ли они простыми (с помощью решета Эратосфена), а также являются ли они палиндромными (с помощью наивного алгоритма, или же можно динамикой считать зеркальное отображение числа). Затем мы посчитаем префиксные суммы, а потом линейным поиском найдём ответ.При A ≤ 42 ответ не превышает 2·106.Сложность — .568B - Симметричное и транзитивноеДавайте сначала разберёмся, в чем же конкретно неправ Вовочка. В доказательстве хорошо всё, кроме того, что мы сразу взяли a, b такие, что . Если такие есть, то действительно . А если их нет? Если для a нет такого b, что , то, очевидно, не (иначе мы бы взяли b = a).Отсюда понятно, что наше бинарное отношение — это какое-то отношение эквивалентности, к которому присоединили такие элементы a, что для всех них не существует таких b, что .Тогда решение можно разбить на две части: Посчитать количество отношений эквивалентности на множествах размеров 0, 1, ..., n - 1 Посчитать, сколькими способами туда можно добавить недостающие \"пустые\" элементы. Отношение эквивалентности можно задать разбиением на классы эквивалентности.Тогда первую часть задачи можно решить динамическим программированием: dp[elems][classes] — кол-во способов разбить elems первых элементов на classes классов эквивалентности. Переход — каждый элемент мы можем либо отнести в один из уже существующих классов, тогда их количество не изменится, либо же создать новый класс, тогда их количество увеличится на 1.Вторая часть задачи. Зафиксируем m — размер множества, над которым мы посчитали количество отношений эквивалентности. Тогда нам нужно добавить к нему ещё n - m \"пустых\" элементов. Позиции для них можно выбрать C[n][n - m] способами, где C[n][k] — биномиальные коэффициенты. Их можно заранее посчитать треугольником Паскаля.Тогда ответ — .Сложность — O(n2)568C - Новый языкПусть мы зафиксировали буквы на каких-то позициях, как проверить, что на остальные позиции можно расставить буквы так, чтобы получилось слово из языка? Ответ — 2-SAT. Действительно, для каждой позиции есть два взаимоисключающих варианта (гласная и согласная), а правила языка — это импликации. Таким образом, такую проверку мы можем сделать за O(n + m).Будем уменьшать длину префикса, который мы оставляем таким же, как у слова s. Тогда следующая буква должна быть строго больше, чем в s, а весь дальнейший суффикс может быть любым. Переберём эту букву и проверим с помощью 2-SAT, есть ли решения. Как только мы обнаружили, что решения есть, мы нашли правильный префикс лексиграфически минимального ответа. Затем будем обратно наращивать префикс, какая-то из букв точно подойдёт. Мы получили решение за O(nmΣ ). Σ из решения можно убрать, заметив, что каждый раз нам нужно проверять только минимальные подходящие гласную и согласную буквы.Также нужно не забыть случай, когда все буквы в языке одной гласности.Сложность — O(nm)568D - Указательные столбыПредположим, что решение есть. Если n ≤ k, то мы можем на каждую дорогу поставить по столбу. Иначе рассмотрим любые k + 1 дорогу. По принципу Дирихле среди них найдутся две, для которых будет общий указатель. Переберём эту пару дорог, поставим столб на их пересечение, уберем дороги, которые тоже проходят через эту точку. Мы свели задачу к меньшему числу столбов. Таким рекурсивным перебором мы решим задачу (если решение существует).Решение это работает за . Если написать аккуратно, это может зайти.Но это решение можно ускорить. Заметим, что если у нас есть точка, через которую проходит хотя бы k + 1 дорога, то мы обязаны поставить столб в эту точку. При достаточно больших n (у меня в решении отсечка n > 30k2) такая точка точно есть (если решение существует), причём её можно искать вероятностным алгоритмом. При условии, что решение существует, вероятность, что две произвольные дороги пересекаются в такой точке не меньше , поэтому если попробовать 100 раз, то с вероятностью такая точка найдется, и мы сможем уменьшить k.Все проверки можно делать в целых числах.Сложность — .568E - Наибольшая возрастающая подпоследовательностьБудем поддерживать массив c: c[len] — минимальное число, на которое может заканчиваться возрастающая подпоследовательность длины len (Одно из двух стандартных решений задачи о наибольшей возрастающей подпоследовательности). Элементы этого массива возрастают и добавление очередного элемента v к обработанной части последовательности сводится к нахождению такого i, что c[i] ≤ v и c[i + 1] ≥ v. При обработке пропуска нам нужно попробовать вставить все числа из множества b. Предварительно их отсортировав и двигаясь двумя указателями вдоль массивов b и c мы можем проделать нужные обновления за O(n + m).Авторами подразумевалось использование O(n) памяти для восстановления ответа. Этого можно добиться следующим образом: 1. Параллельно с массивом c будем хранить массив cindex[len] — индекс элемента, на который заканчивается оптимальная НВП длины len. Если она заканчивается в пропуске — будем хранить, например,  - 1. 2. Также сохраним для каждого не пропуска — длину НВП(lenLIS[pos]), заканчивающейся в этой позиции (это несложно делается в процессе вычисления массива c) и позицию(prevIndex[pos]) предыдущего элемента в этой НВП (если это пропуск, опять же  - 1).Теперь приступим к восстановлению ответа. Пока мы не наткнулись на пропуск — можно спокойно восстанавливать НВП с конца. Сложность обнаруживается, когда несколько следующих элементов последовательности попали в пропуски. Но можно несложно определить что это за пропуски и чем их заполнить. А именно: пусть сейчас мы стоим в позиции r. Нам нужно найти такую позицию l (не пропуск), что мы сможем заполнить ровно lenLIS[r] - lenLIS[l] пропусков между l и r возрастающими числами в интервале (a[l]..a[r]). Позицию l можно итеративно перебирать от r - 1 до 0, параллельно насчитывая число пройденных пропусков. Проверку условия описанного выше можно несложно сделать с помощью пары бинпоисков.Немного подробнее и с деталями: Как узнать, что между позициями l и r можно заполнить пропуски так, чтобы не ухудшить генерируемый ответ?Пусть countSkip(l, r) — количество пропусков на интервале (l..r), а countBetween(x, y) — количество различных чисел из множества b, лежaщих в интервале (x..y). Тогда позиции l и r хорошие тогда и только тогда, когда lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip можно насчитывать в процессе уменьшения границы l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). Что делать, если НВП заканчивается или начинается в пропуске (тогда мы не знаем, откуда начать/где закончить)?Наиболее простым решением будет добавить  - ∞ и  + ∞ в начало и конец нашего массива соответственно. Это позволит избежать проблем с такими крайними случаями. Сложность — времени, O(n + m) памяти",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 569\\s*A"
          },
          "content_length": 8005
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "Это второй наш раунд, первый пришелся на черные дни Codeforces, и мы надеемся, что второй наш раунд не вызовет таких катаклизмов...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 7",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int T = inf.readInt(2, 100000, \"T\");\n    inf.readSpace();\n    int S = inf.readInt(1, T - 1, \"S\");\n    inf.readSpace();\n    int q = inf.readInt(2, 10000, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int T = inf.readInt(2, 100000, \"T\");\n    inf.readSpace();\n    int S = inf.readInt(1, T - 1, \"S\");\n    inf.readSpace();\n    int q = inf.readInt(2, 10000, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int T = inf.readInt(2, 100000, \"T\");\n    inf.readSpace();\n    int S = inf.readInt(1, T - 1, \"S\");\n    inf.readSpace();\n    int q = inf.readInt(2, 10000, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int T = opt<int>(\"T\", -1);\n    int S = opt<int>(\"S\", -1);\n    int q = opt<int>(\"q\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random T, S, q within constraints\n        T = rnd.next(2, 100000); // 2 ≤ T ≤ 1e5\n        S = rnd.next(1, T - 1);\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_T\") {\n        T = 100000;\n        S = rnd.next(1, T - 1);\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_S\") {\n        T = rnd.next(2, 100000);\n        S = T - 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"min_S\") {\n        T = rnd.next(2, 100000);\n        S = 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_q\") {\n        T = rnd.next(2, 100000);\n        S = rnd.next(1, T - 1);\n        q = 10000;\n    } else if (type == \"min_q\") {\n        T = rnd.next(2, 100000);\n        S = rnd.next(1, T - 1);\n        q = 2;\n    } else if (type == \"S_equal_T_minus_one\") {\n        T = rnd.next(2, 100000);\n        S = T - 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"S_equal_1\") {\n        T = rnd.next(2, 100000);\n        S = 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"T_equal_S_plus_1\") {\n        S = rnd.next(1, 99999);\n        T = S + 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_T_S_q\") {\n        T = 100000;\n        S = T - 1;\n        q = 10000;\n    } else if (type == \"min_T_S_q\") {\n        T = rnd.next(2, 10);\n        S = 1;\n        q = 2;\n    } else if (type == \"custom\") {\n        // Use provided T, S, q\n        if (T == -1 || S == -1 || q == -1) {\n            fprintf(stderr, \"Error: For type=custom, you must provide T, S, and q\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output T S q\n    printf(\"%d %d %d\\n\", T, S, q);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int T = opt<int>(\"T\", -1);\n    int S = opt<int>(\"S\", -1);\n    int q = opt<int>(\"q\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random T, S, q within constraints\n        T = rnd.next(2, 100000); // 2 ≤ T ≤ 1e5\n        S = rnd.next(1, T - 1);\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_T\") {\n        T = 100000;\n        S = rnd.next(1, T - 1);\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_S\") {\n        T = rnd.next(2, 100000);\n        S = T - 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"min_S\") {\n        T = rnd.next(2, 100000);\n        S = 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_q\") {\n        T = rnd.next(2, 100000);\n        S = rnd.next(1, T - 1);\n        q = 10000;\n    } else if (type == \"min_q\") {\n        T = rnd.next(2, 100000);\n        S = rnd.next(1, T - 1);\n        q = 2;\n    } else if (type == \"S_equal_T_minus_one\") {\n        T = rnd.next(2, 100000);\n        S = T - 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"S_equal_1\") {\n        T = rnd.next(2, 100000);\n        S = 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"T_equal_S_plus_1\") {\n        S = rnd.next(1, 99999);\n        T = S + 1;\n        q = rnd.next(2, 10000);\n    } else if (type == \"max_T_S_q\") {\n        T = 100000;\n        S = T - 1;\n        q = 10000;\n    } else if (type == \"min_T_S_q\") {\n        T = rnd.next(2, 10);\n        S = 1;\n        q = 2;\n    } else if (type == \"custom\") {\n        // Use provided T, S, q\n        if (T == -1 || S == -1 || q == -1) {\n            fprintf(stderr, \"Error: For type=custom, you must provide T, S, and q\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output T S q\n    printf(\"%d %d %d\\n\", T, S, q);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max_T\n./gen -type max_T\n./gen -type max_S\n./gen -type min_S\n./gen -type max_q\n./gen -type min_q\n\n./gen -type S_equal_T_minus_one\n./gen -type S_equal_1\n./gen -type T_equal_S_plus_1\n./gen -type max_T_S_q\n./gen -type min_T_S_q\n\n./gen -type custom -T 100000 -S 1 -q 2\n./gen -type custom -T 100000 -S 1 -q 10000\n./gen -type custom -T 100000 -S 99999 -q 2\n./gen -type custom -T 2 -S 1 -q 2\n./gen -type custom -T 100000 -S 50000 -q 10000\n./gen -type custom -T 50000 -S 1 -q 2\n./gen -type custom -T 50000 -S 49999 -q 10000\n\n./gen -type custom -T 1000 -S 999 -q 2\n./gen -type custom -T 1000 -S 1 -q 2\n./gen -type custom -T 1000 -S 1 -q 10000\n./gen -type custom -T 1000 -S 999 -q 10000\n./gen -type custom -T 50000 -S 25000 -q 2\n./gen -type custom -T 50000 -S 25000 -q 10000\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:14.672372",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "569/B",
      "title": "B. Inventory",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the number of items (1 ≤ n ≤ 105).The second line contains n numbers a1, a2, ..., an (1 ≤ ai ≤ 105) — the initial inventory numbers of the items.",
      "output_spec": "OutputPrint n numbers — the final inventory numbers of the items in the order they occur in the input. If there are multiple possible answers, you may print any of them.",
      "sample_tests": "ExamplesInputCopy31 3 2OutputCopy1 3 2 InputCopy42 2 3 3OutputCopy2 1 3 4 InputCopy12OutputCopy1",
      "description": "B. Inventory\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n — the number of items (1 ≤ n ≤ 105).The second line contains n numbers a1, a2, ..., an (1 ≤ ai ≤ 105) — the initial inventory numbers of the items.\n\nOutputPrint n numbers — the final inventory numbers of the items in the order they occur in the input. If there are multiple possible answers, you may print any of them.\n\nInputCopy31 3 2OutputCopy1 3 2 InputCopy42 2 3 3OutputCopy2 1 3 4 InputCopy12OutputCopy1\n\nInputCopy31 3 2\n\nOutputCopy1 3 2\n\nInputCopy42 2 3 3\n\nOutputCopy2 1 3 4\n\nInputCopy12\n\nOutputCopy1\n\nNoteIn the first test the numeration is already a permutation, so there is no need to change anything.In the second test there are two pairs of equal numbers, in each pair you need to replace one number.In the third test you need to replace 2 by 1, as the numbering should start from one.",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 569\\s*B"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInt();\n    }\n    \n    vector<int> counts(n + 1, 0);\n    int unique_numbers = 0;\n    int overused_numbers = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int ai = a[i];\n        if (1 <= ai && ai <= n) {\n            counts[ai]++;\n            if (counts[ai] == 1) {\n                unique_numbers++;\n            } else {\n                overused_numbers++;\n            }\n        } else {\n            overused_numbers++;\n        }\n    }\n    \n    int minimal_number_of_changes = overused_numbers;\n    \n    // Read participant's output\n    vector<int> b = ouf.readInts(n, 1, n, \"output inventory numbers\");\n    \n    // Check that b is a permutation of 1 to n\n    vector<int> counts_b(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        int bi = b[i];\n        counts_b[bi]++;\n        if (counts_b[bi] > 1) {\n            quitf(_wa, \"Number %d occurs more than once in output\", bi);\n        }\n    }\n    \n    // Count number of positions where a[i] != b[i]\n    int c = 0;\n    for (int i = 0; i < n; i++) {\n        if (a[i] != b[i]) c++;\n    }\n    \n    if (c > minimal_number_of_changes) {\n        quitf(_wa, \"Number of changes (%d) is more than minimal (%d)\", c, minimal_number_of_changes);\n    } else if (c == minimal_number_of_changes) {\n        quitf(_ok, \"Correct output with minimal number of changes (%d)\", c);\n    } else { // c < minimal_number_of_changes\n        quitf(_fail, \"Participant made fewer changes (%d) than minimal required (%d)\", c, minimal_number_of_changes);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random numbers between 1 and maxAi (default 1e5)\n        int maxAi = opt<int>(\"maxAi\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } \n    else if (type == \"already_permutation\") {\n        // Generate a permutation of numbers from 1 to n\n        iota(a.begin(), a.end(), 1);\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"max_duplicates\") {\n        // All elements are the same number\n        int val = rnd.next(1, 100000);\n        fill(a.begin(), a.end(), val);\n    } \n    else if (type == \"some_duplicates\") {\n        // Generate a permutation and duplicate some numbers\n        iota(a.begin(), a.end(), 1);\n        int numDuplicates = opt<int>(\"numDuplicates\", n / 2);\n        for (int i = 0; i < numDuplicates; ++i) {\n            int idx = rnd.next(0, n - 1);\n            int dupIdx = rnd.next(0, n - 1);\n            a[idx] = a[dupIdx];\n        }\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"out_of_range\") {\n        // Generate numbers outside the range [1, n] but within [1, 1e5]\n        int minAi = opt<int>(\"minAi\", n + 1);\n        int maxAi = opt<int>(\"maxAi\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minAi, maxAi);\n        }\n    } \n    else if (type == \"reverse_order\") {\n        // Numbers from n down to 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } \n    else if (type == \"all_max\") {\n        // All elements are the maximum allowed value\n        int val = 100000;\n        fill(a.begin(), a.end(), val);\n    } \n    else if (type == \"small_values\") {\n        // All elements are small numbers\n        int maxAi = opt<int>(\"maxAi\", 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } \n    else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random numbers between 1 and maxAi (default 1e5)\n        int maxAi = opt<int>(\"maxAi\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } \n    else if (type == \"already_permutation\") {\n        // Generate a permutation of numbers from 1 to n\n        iota(a.begin(), a.end(), 1);\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"max_duplicates\") {\n        // All elements are the same number\n        int val = rnd.next(1, 100000);\n        fill(a.begin(), a.end(), val);\n    } \n    else if (type == \"some_duplicates\") {\n        // Generate a permutation and duplicate some numbers\n        iota(a.begin(), a.end(), 1);\n        int numDuplicates = opt<int>(\"numDuplicates\", n / 2);\n        for (int i = 0; i < numDuplicates; ++i) {\n            int idx = rnd.next(0, n - 1);\n            int dupIdx = rnd.next(0, n - 1);\n            a[idx] = a[dupIdx];\n        }\n        shuffle(a.begin(), a.end());\n    } \n    else if (type == \"out_of_range\") {\n        // Generate numbers outside the range [1, n] but within [1, 1e5]\n        int minAi = opt<int>(\"minAi\", n + 1);\n        int maxAi = opt<int>(\"maxAi\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minAi, maxAi);\n        }\n    } \n    else if (type == \"reverse_order\") {\n        // Numbers from n down to 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } \n    else if (type == \"all_max\") {\n        // All elements are the maximum allowed value\n        int val = 100000;\n        fill(a.begin(), a.end(), val);\n    } \n    else if (type == \"small_values\") {\n        // All elements are small numbers\n        int maxAi = opt<int>(\"maxAi\", 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } \n    else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type already_permutation\n./gen -n 1 -type max_duplicates\n\n./gen -n 2 -type random\n./gen -n 2 -type already_permutation\n./gen -n 2 -type max_duplicates\n\n./gen -n 10 -type random\n./gen -n 10 -type already_permutation\n./gen -n 10 -type some_duplicates -numDuplicates 5\n\n./gen -n 100 -type random\n./gen -n 100 -type already_permutation\n./gen -n 100 -type some_duplicates -numDuplicates 50\n./gen -n 100 -type out_of_range -minAi 101 -maxAi 200\n\n./gen -n 1000 -type random\n./gen -n 1000 -type already_permutation\n./gen -n 1000 -type reverse_order\n./gen -n 1000 -type max_duplicates\n./gen -n 1000 -type some_duplicates -numDuplicates 500\n\n./gen -n 10000 -type random\n./gen -n 10000 -type already_permutation\n./gen -n 10000 -type max_duplicates\n./gen -n 10000 -type all_max\n./gen -n 10000 -type small_values -maxAi 5\n./gen -n 10000 -type out_of_range -minAi 10001 -maxAi 20000\n\n./gen -n 100000 -type random\n./gen -n 100000 -type random -maxAi 1\n./gen -n 100000 -type already_permutation\n./gen -n 100000 -type reverse_order\n./gen -n 100000 -type max_duplicates\n./gen -n 100000 -type all_max\n./gen -n 100000 -type small_values -maxAi 1\n./gen -n 100000 -type some_duplicates -numDuplicates 99999\n./gen -n 100000 -type out_of_range -minAi 1 -maxAi 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:17.161880",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "569/C",
      "title": "C. Primes or Palindromes?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of two positive integers p, q, the numerator and denominator of the fraction that is the value of A (, ).",
      "output_spec": "OutputIf such maximum number exists, then print it. Otherwise, print \"Palindromic tree is better than splay tree\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy40InputCopy1 42OutputCopy1InputCopy6 4OutputCopy172",
      "description": "C. Primes or Palindromes?\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe input consists of two positive integers p, q, the numerator and denominator of the fraction that is the value of A (, ).\n\nOutputIf such maximum number exists, then print it. Otherwise, print \"Palindromic tree is better than splay tree\" (without the quotes).\n\nInputCopy1 1OutputCopy40InputCopy1 42OutputCopy1InputCopy6 4OutputCopy172\n\nInputCopy1 1\n\nOutputCopy40\n\nInputCopy1 42\n\nOutputCopy1\n\nInputCopy6 4\n\nOutputCopy172",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 569 和字母"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long p = inf.readLong(1, 1000000000000000000LL, \"p\");\n    inf.readSpace();\n    long long q = inf.readLong(1, 1000000000000000000LL, \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long p = inf.readLong(1, 1000000000000000000LL, \"p\");\n    inf.readSpace();\n    long long q = inf.readLong(1, 1000000000000000000LL, \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long p = inf.readLong(1, 1000000000000000000LL, \"p\");\n    inf.readSpace();\n    long long q = inf.readLong(1, 1000000000000000000LL, \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int p = opt<int>(\"p\", -1);\n    int q = opt<int>(\"q\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (p > 0 && q > 0) {\n        // Use provided p and q\n    } else {\n        if (type == \"small_pq\") {\n            p = rnd.next(1, 10);\n            q = rnd.next(1, 10);\n        } else if (type == \"large_pq\") {\n            p = rnd.next((int)1e9 - 100, (int)1e9);\n            q = rnd.next((int)1e9 - 100, (int)1e9);\n        } else if (type == \"fraction_eq_1\") {\n            p = rnd.next(1, (int)1e9);\n            q = p;\n        } else if (type == \"fraction_gt_1\") {\n            q = rnd.next(1, (int)1e9 - 1);\n            p = rnd.next(q + 1, (int)1e9);\n        } else if (type == \"fraction_lt_1\") {\n            p = rnd.next(1, (int)1e9 - 1);\n            q = rnd.next(p + 1, (int)1e9);\n        } else if (type == \"no_solution\") {\n            // We need p/q small enough that π(n) > (p/q)*rub(n) for all n\n            // Let's set p=1 and q large\n            p = 1;\n            q = rnd.next((int)1e8, (int)1e9);\n        } else if (type == \"max_n_small\") {\n            // Generate p and q so that max n is small\n            p = rnd.next(1, 10);\n            q = rnd.next(p, p + 10);\n        } else if (type == \"max_n_large\") {\n            // Generate p and q so that max n is large\n            p = rnd.next((int)1e8, (int)1e9);\n            q = rnd.next(1, (int)1e8);\n            while (p <= q) {\n                p = rnd.next((int)1e8, (int)1e9);\n                q = rnd.next(1, (int)1e8);\n            }\n        } else if (type == \"random\") {\n            p = rnd.next(1, (int)1e9);\n            q = rnd.next(1, (int)1e9);\n            // Ensure p and q are positive\n            if (p == 0) p = 1;\n            if (q == 0) q = 1;\n        } else {\n            // Default case: generate random p and q\n            p = rnd.next(1, (int)1e9);\n            q = rnd.next(1, (int)1e9);\n            if (p == 0) p = 1;\n            if (q == 0) q = 1;\n        }\n    }\n\n    // Print p and q\n    printf(\"%d %d\\n\", p, q);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int p = opt<int>(\"p\", -1);\n    int q = opt<int>(\"q\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (p > 0 && q > 0) {\n        // Use provided p and q\n    } else {\n        if (type == \"small_pq\") {\n            p = rnd.next(1, 10);\n            q = rnd.next(1, 10);\n        } else if (type == \"large_pq\") {\n            p = rnd.next((int)1e9 - 100, (int)1e9);\n            q = rnd.next((int)1e9 - 100, (int)1e9);\n        } else if (type == \"fraction_eq_1\") {\n            p = rnd.next(1, (int)1e9);\n            q = p;\n        } else if (type == \"fraction_gt_1\") {\n            q = rnd.next(1, (int)1e9 - 1);\n            p = rnd.next(q + 1, (int)1e9);\n        } else if (type == \"fraction_lt_1\") {\n            p = rnd.next(1, (int)1e9 - 1);\n            q = rnd.next(p + 1, (int)1e9);\n        } else if (type == \"no_solution\") {\n            // We need p/q small enough that π(n) > (p/q)*rub(n) for all n\n            // Let's set p=1 and q large\n            p = 1;\n            q = rnd.next((int)1e8, (int)1e9);\n        } else if (type == \"max_n_small\") {\n            // Generate p and q so that max n is small\n            p = rnd.next(1, 10);\n            q = rnd.next(p, p + 10);\n        } else if (type == \"max_n_large\") {\n            // Generate p and q so that max n is large\n            p = rnd.next((int)1e8, (int)1e9);\n            q = rnd.next(1, (int)1e8);\n            while (p <= q) {\n                p = rnd.next((int)1e8, (int)1e9);\n                q = rnd.next(1, (int)1e8);\n            }\n        } else if (type == \"random\") {\n            p = rnd.next(1, (int)1e9);\n            q = rnd.next(1, (int)1e9);\n            // Ensure p and q are positive\n            if (p == 0) p = 1;\n            if (q == 0) q = 1;\n        } else {\n            // Default case: generate random p and q\n            p = rnd.next(1, (int)1e9);\n            q = rnd.next(1, (int)1e9);\n            if (p == 0) p = 1;\n            if (q == 0) q = 1;\n        }\n    }\n\n    // Print p and q\n    printf(\"%d %d\\n\", p, q);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small_pq\n./gen -type large_pq\n./gen -type fraction_eq_1\n./gen -type fraction_gt_1\n./gen -type fraction_lt_1\n./gen -type no_solution\n./gen -type max_n_small\n./gen -type max_n_large\n./gen -type random\n\n# Manually specify p and q\n./gen -p 1 -q 1\n./gen -p 1 -q 10\n./gen -p 10 -q 1\n./gen -p 999999937 -q 999999937\n./gen -p 1000000000 -q 1\n./gen -p 1 -q 1000000000\n\n# Multiple runs with the same type to get different random values\n./gen -type small_pq\n./gen -type small_pq\n./gen -type small_pq\n\n./gen -type fraction_gt_1\n./gen -type fraction_gt_1\n./gen -type fraction_gt_1\n\n./gen -type max_n_small\n./gen -type max_n_small\n./gen -type max_n_small\n\n./gen -type max_n_large\n./gen -type max_n_large\n./gen -type max_n_large\n\n# Random p and q\n./gen\n./gen\n./gen\n\n# Edge cases where p and q are maximum\n./gen -p 1000000000 -q 1000000000\n./gen -p 1000000000 -q 999999999\n./gen -p 999999999 -q 1000000000\n\n# Edge cases where p or q is 1\n./gen -p 1 -q 1\n./gen -p 1 -q 2\n./gen -p 2 -q 1\n\n# No solution cases\n./gen -type no_solution\n./gen -type no_solution\n./gen -type no_solution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:19.165960",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "569/D",
      "title": "D. Symmetric and Transitive",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains a single integer n (1 ≤ n ≤ 4000).",
      "output_spec": "OutputIn a single line print the answer to the problem modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy2OutputCopy3InputCopy3OutputCopy10",
      "description": "D. Symmetric and Transitive\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputA single line contains a single integer n (1 ≤ n ≤ 4000).\n\nOutputIn a single line print the answer to the problem modulo 109 + 7.\n\nInputCopy1OutputCopy1InputCopy2OutputCopy3InputCopy3OutputCopy10\n\nOutputCopy1\n\nOutputCopy3\n\nOutputCopy10\n\nNoteIf n = 1 there is only one such relation — an empty one, i.e. . In other words, for a single element x of set A the following is hold: .If n = 2 there are three such relations. Let's assume that set A consists of two elements, x and y. Then the valid relations are , ρ = {(x, x)}, ρ = {(y, y)}. It is easy to see that the three listed binary relations are symmetric and transitive relations, but they are not equivalence relations.",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 569 和字母"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"provided_n\");\n    int n = 0;\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 4000;\n    } else if (type == \"max_minus_one\") {\n        n = 3999;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"medium\") {\n        n = rnd.next(10, 1000);\n    } else if (type == \"large_random\") {\n        n = rnd.next(3000, 4000);\n    } else if (type == \"just_below_power_of_two\") {\n        n = (1 << rnd.next(1,12)) - 1;\n    } else if (type == \"power_of_two\") {\n        n = (1 << rnd.next(1,12));\n    } else if (type == \"random\") {\n        n = rnd.next(1, 4000);\n    } else {\n        // Use provided n\n        n = opt<int>(\"n\", 1000); // Default n=1000 if not provided\n        n = min(max(n, 1), 4000); // Ensure n is within [1,4000]\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"provided_n\");\n    int n = 0;\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 4000;\n    } else if (type == \"max_minus_one\") {\n        n = 3999;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"medium\") {\n        n = rnd.next(10, 1000);\n    } else if (type == \"large_random\") {\n        n = rnd.next(3000, 4000);\n    } else if (type == \"just_below_power_of_two\") {\n        n = (1 << rnd.next(1,12)) - 1;\n    } else if (type == \"power_of_two\") {\n        n = (1 << rnd.next(1,12));\n    } else if (type == \"random\") {\n        n = rnd.next(1, 4000);\n    } else {\n        // Use provided n\n        n = opt<int>(\"n\", 1000); // Default n=1000 if not provided\n        n = min(max(n, 1), 4000); // Ensure n is within [1,4000]\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with minimum n\n./gen -type min\n\n# Test cases with small n\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Test cases with medium n\n./gen -type medium\n./gen -type medium\n./gen -type medium\n\n# Test cases just below a power of two\n./gen -type just_below_power_of_two\n./gen -type just_below_power_of_two\n./gen -type just_below_power_of_two\n\n# Test cases at powers of two\n./gen -type power_of_two\n./gen -type power_of_two\n./gen -type power_of_two\n\n# Test cases with large random n\n./gen -type large_random\n./gen -type large_random\n./gen -type large_random\n\n# Test cases with n equal to max minus one\n./gen -type max_minus_one\n\n# Test case with maximum n\n./gen -type max\n\n# Test cases with random n\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Test cases with specific n values\n./gen -n 1000\n./gen -n 2000\n./gen -n 3000\n./gen -n 3998\n\n# Test cases with edge cases\n./gen -n 2\n./gen -n 3\n./gen -n 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:21.075115",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "569/E",
      "title": "E. New Language",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single line consisting of letters 'V' (Vowel) and 'C' (Consonant), determining which letters are vowels and which letters are consonants. The length of this string l is the size of the alphabet of the new language (1 ≤ l ≤ 26). The first l letters of the English alphabet are used as the letters of the alphabet of the new language. If the i-th character of the string equals to 'V', then the corresponding letter is a vowel, otherwise it is a consonant.The second line contains two integers n, m (1 ≤ n ≤ 200, 0 ≤ m ≤ 4n(n - 1)) — the number of letters in a single word and the number of rules, correspondingly.Next m lines describe m rules of the language in the following format: pos1, t1, pos2, t2 (1 ≤ pos1, pos2 ≤ n, pos1 ≠ pos2,  'V', 'C' }).The last line contains string s of length n, consisting of the first l small letters of the English alphabet.It is guaranteed that no two rules are the same.",
      "output_spec": "OutputPrint a smallest word of a language that is lexicographically not smaller than s. If such words does not exist (for example, if the language has no words at all), print \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopyVC2 11 V 2 CaaOutputCopyabInputCopyVC2 11 C 2 VbbOutputCopy-1InputCopyVCC4 31 C 2 V2 C 3 V3 V 4 VabacOutputCopyacaa",
      "description": "E. New Language\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single line consisting of letters 'V' (Vowel) and 'C' (Consonant), determining which letters are vowels and which letters are consonants. The length of this string l is the size of the alphabet of the new language (1 ≤ l ≤ 26). The first l letters of the English alphabet are used as the letters of the alphabet of the new language. If the i-th character of the string equals to 'V', then the corresponding letter is a vowel, otherwise it is a consonant.The second line contains two integers n, m (1 ≤ n ≤ 200, 0 ≤ m ≤ 4n(n - 1)) — the number of letters in a single word and the number of rules, correspondingly.Next m lines describe m rules of the language in the following format: pos1, t1, pos2, t2 (1 ≤ pos1, pos2 ≤ n, pos1 ≠ pos2,  'V', 'C' }).The last line contains string s of length n, consisting of the first l small letters of the English alphabet.It is guaranteed that no two rules are the same.\n\nOutputPrint a smallest word of a language that is lexicographically not smaller than s. If such words does not exist (for example, if the language has no words at all), print \"-1\" (without the quotes).\n\nInputCopyVC2 11 V 2 CaaOutputCopyabInputCopyVC2 11 C 2 VbbOutputCopy-1InputCopyVCC4 31 C 2 V2 C 3 V3 V 4 VabacOutputCopyacaa\n\nInputCopyVC2 11 V 2 Caa\n\nOutputCopyab\n\nInputCopyVC2 11 C 2 Vbb\n\nOutputCopy-1\n\nInputCopyVCC4 31 C 2 V2 C 3 V3 V 4 Vabac\n\nOutputCopyacaa\n\nNoteIn the first test word \"aa\" is not a word of the language, but word \"ab\" is.In the second test out of all four possibilities only word \"bb\" is not a word of a language, but all other words are lexicographically less, so there is no answer.In the third test, due to the last rule, \"abac\" doesn't belong to the language (\"a\" is a vowel, \"c\" is a consonant). The only word with prefix \"ab\" that meets the given rules is \"abaa\". But it is less than \"abac\", so the answer will be \"acaa\"",
      "solutions": [
        {
          "title": "Codeforces Round #315 - Codeforces",
          "content": "Hello everyone!Codeforces Round #315 will take place soon. The authors of this round are students of Ural FU sivukhin and Um_nik. This is our second round. First one was in the black days of Codeforces and we hope that this will not happen again after our round :)We want to thank Codeforces team for great Codeforces and Polygon platforms and Zlobober for helping us prepare this round.Good luck!UPD1:Score distribution.div2 : 500-1000-1500-2250-2750div1 : 500-1000-1500-2250-2500We strongly recommend you to read all the problems. We try our best to prepare different problems and some problems that hard for us can be easy for you.UPD2:EditorialUPD3:Congratulations to the winners!div1:1. KAN2. Petr3. enot1104. tonyjjw5. Konijntje div2:1. Lost2. loser213. fyiwxp2214. hqpwca5. LazyWolfLinThank you for participating.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19681",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 820
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces",
          "content": "569A - MusicSuppose we have downloaded S seconds of the song and press the 'play' button. Let's find how many seconds will be downloaded when we will be forced to play the song once more. . Hence x = qS.Solution: let's multiply S by q while S < T. The answer is the amount of operations.Complexity — 569B - InventoryLet's look at the problem from another side: how many numbers can we leave unchanged to get permutation? It is obvious: these numbers must be from 1 to n and they are must be pairwise distinct. This condition is necessary and sufficient.This problem can be solved with greedy algorithm. If me meet the number we have never met before and this number is between 1 and n, we will leave this number unchanged. To implement this we can use array where we will mark used numbers.After that we will look over the array again and allocate numbers that weren't used.Complexity — O(n).568A - Primes or Palindromes?It is known that amount of prime numbers non greater than n is about .We can also found the amount of palindrome numbers with fixed length k — it is about which is .Therefore the number of primes asymptotically bigger than the number of palindromic numbers and for every constant A there is an answer. Moreover, for this answer n the next condition hold: . In our case n < 107.For all numbers smaller than 107 we can check if they are primes (via sieve of Eratosthenes) and/or palindromes (via trivial algorithm or compute reverse number via dynamic approach). Then we can calculate prefix sums (π(n) and rub(n)) and find the answer using linear search.For A ≤ 42 answer is smaller than 2·106.Complexity — .568B - Symmetric and TransitiveLet's find Johnny's mistake. It is all right in his proof except ``If '' part. What if there is no such b for an given a? Then obviously otherwise we'll take b = a.We can see that our binary relation is some equivalence relation which was expanded by some \"empty\" elements. For \"empty\" element a there is no such b that .Thus we can divide our solution into two parts: Count the number of equivalence relations on sets of size 0, 1, ..., n - 1 For every size count the number of ways to expand it with some \"empty\" elements. We can define equivalence relation using its equivalence classes.So first part can be solved using dynamic programming: dp[elems][classes] — the numbers of ways to divide first elems elements to classes equivalence classes. When we handle next element we can send it to one of the existing equivalence classes or we can create new class.Let's solve second part. Consider set of size m. We have found that there are eq[m] ways to build equivalence relation on this set. We have to add n - m \"empty\" elements to this set. The number of ways to choose their positions is Cnk. We can calculate all the binomial coefficients using Pascal's triangle.So the answer to the problem is .Complexity — O(n2)568C - New LanguageSuppose we have fixed letters on some positions, how can we check is there a way to select letters on other positions to build a word from the language? The answer is 2-SAT. Let's see: for every position there is two mutually exclusive options (vowel or consonant) and the rules are consequences. Therefore we can do this check in O(n + m) time.Let's decrease the length of the prefix which will be the same as in s. Then the next letter must be strictly greater but all the next letters can be any. We can iterate over all greater letters and then check if we can made this word the word from the language (via 2-SAT). Once we have found such possibilty we have found the right prefix of the answer. After that we can increase the length of the fixed prefix in a similar way. This solution works in O(nmΣ ) time. We can divide this by Σ simply try not all the letter but only the smallest possible vowel and the smallest possible consonant.And you should remember about the case when all the letters are vowel (or all the letters are consonant).Complexity — O(nm)568D - Sign PostsSuppose, that solution exist. In case n ≤ k we can put one signpost on each road. In other case let's choose any k + 1 roads. By the Dirichlet's principle there are at least two roads among selected, which have common signpost. Let's simple iterate over all variants with different two roads. After choosing roads a and b, we will remove all roads, intersecting with a and b in common points and reduce k in our problem. This recursive process solves the problem (if solution exist).Complexity of this solution — . If implement this solution carefully — you will get AC =)But in case of TL we can add one improvement to our solution. Note, that if we find point, which belongs to k + 1 or more roads, then we must include this point to out answer. For sufficiently large n (for example, if n > 30k2) this point always exist and we can find it using randomize algorithm. If solution exist, probability that two arbitrary roads are intersects in such a point not less than . Because of it, if we 100 times pick two random roads, then with probability such a point will be found and we can decrease k.All operations better to do in integers.Complexity — .568E - Longest Increasing SubsequenceLet's calculate array c: c[len] — minimal number that can complete increasing subsequence of length len. (This is one of the common solution for LIS problem).Elements of this array are increasing and we can add new element v to processed part of sequence as follows: find such index i that c[i] ≤ v and c[i + 1] ≥ v let c[i + 1] = v We can process this action in time.When we handle a gap, we must try to insert all numbers from set b. If we sort elements of b in advance, then we can move with two iterators along arrays b and c and relax all needed values as explained above. This case requires O(n + m) time.Authors implied solution with O(n) space complexity for answer restoring. We can do this in the following way: Together with array c we will store array cindex[len] — index of element, which complete optimal increasing subsequence of length len. If this subsequence ends in a gap — we will store  - 1. Also, we will store for every not gap — length of LIS(lenLIS[pos]), which ends in this position (this is simply calculating while processing array c) and position(prevIndex[pos]) of previous element in this subsequence (if this elements is gap, we store  - 1) Now we will start recovery the answer with this information.While we are working with not gaps — it's all right. We can simply restore LIS with prevIndex[pos] array. The main difficulty lies in processing gaps. If value of prevIndex[pos] in current position equal to  - 1 — we know, that before this elements must be one or more gaps. And we can determine which gaps and what values from b we must put in them as follows:Let suppose that we stand at position r (and prevIndex[r] =  - 1). Now we want to find such position l (which is not gap), that we can fill exactly lenLIS[r] - lenLIS[l] gaps between l with increasing numbers from interval (a[l]..a[r]). Position l we can simply iterates from r - 1 to 0 and with it calculating gaps between l and r. Check the condition described above we can produce via two binary search query to array b.Few details: How do we know, that between positions l and r we can fill gaps in such a way, that out answer still the best?Let countSkip(l, r) — count gaps on interval (l..r), countBetween(x, y) — count different numbers from set b, lying in the range (x..y).Then, positions l and r are good only if lenLIS[r] - lenLIS[l] = min(countSkip(l, r), countBetween(a[l], a[r])). countSkip we can calculate while iterates position l, countBetween(x, y) = max(0, lower_bound(b, y) - upper_bound(b, x)). What to do, is LIS ends or begins in gaps?This case we can solve by simply adding  - ∞ and  + ∞ in begin and end of out array. Complexity — . Memory — O(n + m).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19705",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 569 和字母"
          },
          "content_length": 7839
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #315 - Codeforces - Code 1",
          "code": "ceil(PI*100)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 2",
          "code": "I know this is a combined round, just saying...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 3",
          "code": "Succesful Hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 4",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 5",
          "code": "int n = (int) 1e6;\nint[] pr = new int[n + 1];\nArrays.fill(pr, 0);\nfor (int i = 2; i * i <= n; ++i) if (pr[i] == 0) {\n    pr[i] = i;\n    for (int j = i * i; j <= n; j += i) pr[j] = i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 - Codeforces - Code 6",
          "code": "for (int i = 2; i * i <= n; ++i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19681",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 1",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 2",
          "code": "if(q*cntprime[i] <= p*cntpal[i]){\n            cout << i << endl;\n            return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 3",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 4",
          "code": "CV\n6 9\n1 C 2 C\n1 C 2 V\n3 C 5 V\n5 V 4 C\n4 C 3 C\n3 C 6 C\n6 C 3 V\n6 C 5 V\n6 C 4 C\naaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 5",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #315 Editorial - Codeforces - Code 6",
          "code": "4 2\n1 0 2 (point 1)\n-1 1 100 (point 2)\n1 0 1 (point 3)\n1 1 100 (point 4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19705",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string vowelConsonant = inf.readToken(\"[VC]{1,26}\", \"vowelConsonant\");\n    inf.readEoln();\n    int l = vowelConsonant.length();\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4 * n * (n - 1), \"m\");\n    inf.readEoln();\n    set<tuple<int, char, int, char>> rules;\n    for(int i = 0; i < m; i++){\n        int pos1 = inf.readInt(1, n, \"pos1\");\n        inf.readSpace();\n        char t1 = inf.readChar();\n        ensuref(t1 == 'V' || t1 == 'C', \"t1 must be 'V' or 'C', but found '%c'\", t1);\n        inf.readSpace();\n        int pos2 = inf.readInt(1, n, \"pos2\");\n        inf.readSpace();\n        char t2 = inf.readChar();\n        ensuref(t2 == 'V' || t2 == 'C', \"t2 must be 'V' or 'C', but found '%c'\", t2);\n        inf.readEoln();\n        ensuref(pos1 != pos2, \"In rule %d, pos1 and pos2 must not be equal, but both are %d\", i+1, pos1);\n        tuple<int, char, int, char> rule = make_tuple(pos1, t1, pos2, t2);\n        ensuref(rules.count(rule) == 0, \"Rule %d is duplicated\", i+1);\n        rules.insert(rule);\n    }\n    string s = inf.readToken();\n    inf.readEoln();\n    ensuref((int)s.length() == n, \"Length of string s must be %d, but found %d\", n, (int)s.length());\n    for(char c : s){\n        ensuref('a' <= c && c <= 'a' + l - 1, \"Character '%c' in s is invalid, must be among 'a' to '%c'\", c, (char)('a' + l - 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string vowelConsonant = inf.readToken(\"[VC]{1,26}\", \"vowelConsonant\");\n    inf.readEoln();\n    int l = vowelConsonant.length();\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4 * n * (n - 1), \"m\");\n    inf.readEoln();\n    set<tuple<int, char, int, char>> rules;\n    for(int i = 0; i < m; i++){\n        int pos1 = inf.readInt(1, n, \"pos1\");\n        inf.readSpace();\n        char t1 = inf.readChar();\n        ensuref(t1 == 'V' || t1 == 'C', \"t1 must be 'V' or 'C', but found '%c'\", t1);\n        inf.readSpace();\n        int pos2 = inf.readInt(1, n, \"pos2\");\n        inf.readSpace();\n        char t2 = inf.readChar();\n        ensuref(t2 == 'V' || t2 == 'C', \"t2 must be 'V' or 'C', but found '%c'\", t2);\n        inf.readEoln();\n        ensuref(pos1 != pos2, \"In rule %d, pos1 and pos2 must not be equal, but both are %d\", i+1, pos1);\n        tuple<int, char, int, char> rule = make_tuple(pos1, t1, pos2, t2);\n        ensuref(rules.count(rule) == 0, \"Rule %d is duplicated\", i+1);\n        rules.insert(rule);\n    }\n    string s = inf.readToken();\n    inf.readEoln();\n    ensuref((int)s.length() == n, \"Length of string s must be %d, but found %d\", n, (int)s.length());\n    for(char c : s){\n        ensuref('a' <= c && c <= 'a' + l - 1, \"Character '%c' in s is invalid, must be among 'a' to '%c'\", c, (char)('a' + l - 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string vowelConsonant = inf.readToken(\"[VC]{1,26}\", \"vowelConsonant\");\n    inf.readEoln();\n    int l = vowelConsonant.length();\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4 * n * (n - 1), \"m\");\n    inf.readEoln();\n    set<tuple<int, char, int, char>> rules;\n    for(int i = 0; i < m; i++){\n        int pos1 = inf.readInt(1, n, \"pos1\");\n        inf.readSpace();\n        char t1 = inf.readChar();\n        ensuref(t1 == 'V' || t1 == 'C', \"t1 must be 'V' or 'C', but found '%c'\", t1);\n        inf.readSpace();\n        int pos2 = inf.readInt(1, n, \"pos2\");\n        inf.readSpace();\n        char t2 = inf.readChar();\n        ensuref(t2 == 'V' || t2 == 'C', \"t2 must be 'V' or 'C', but found '%c'\", t2);\n        inf.readEoln();\n        ensuref(pos1 != pos2, \"In rule %d, pos1 and pos2 must not be equal, but both are %d\", i+1, pos1);\n        tuple<int, char, int, char> rule = make_tuple(pos1, t1, pos2, t2);\n        ensuref(rules.count(rule) == 0, \"Rule %d is duplicated\", i+1);\n        rules.insert(rule);\n    }\n    string s = inf.readToken();\n    inf.readEoln();\n    ensuref((int)s.length() == n, \"Length of string s must be %d, but found %d\", n, (int)s.length());\n    for(char c : s){\n        ensuref('a' <= c && c <= 'a' + l - 1, \"Character '%c' in s is invalid, must be among 'a' to '%c'\", c, (char)('a' + l - 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rule {\n    int pos1, pos2;\n    char t1, t2;\n    bool operator<(const Rule& other) const {\n        if (pos1 != other.pos1) return pos1 < other.pos1;\n        if (t1 != other.t1) return t1 < other.t1;\n        if (pos2 != other.pos2) return pos2 < other.pos2;\n        return t2 < other.t2;\n    }\n};\n\nstring generateAlphabet(int l, const string& alphabet_type) {\n    string res;\n    if (alphabet_type == \"all_vowels\") {\n        res = string(l, 'V');\n    } else if (alphabet_type == \"all_consonants\") {\n        res = string(l, 'C');\n    } else if (alphabet_type == \"alternate\") {\n        res.resize(l);\n        for (int i = 0; i < l; ++i) {\n            res[i] = (i % 2 == 0) ? 'V' : 'C';\n        }\n    } else {\n        // Default to random\n        res.resize(l);\n        for (int i = 0; i < l; ++i) {\n            res[i] = (rnd.next(2) == 0) ? 'V' : 'C';\n        }\n    }\n    return res;\n}\n\nvector<Rule> generateRules(int n, int m, const string& rules_type) {\n    set<Rule> rules_set;\n    vector<Rule> rules;\n    int max_attempts = m * 10; // To avoid infinite loop\n    if (rules_type == \"random\") {\n        while ((int)rules_set.size() < m && max_attempts-- > 0) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = (rnd.next(2) == 0) ? 'V' : 'C';\n            char t2 = (rnd.next(2) == 0) ? 'V' : 'C';\n            Rule r {pos1, pos2, t1, t2};\n            if (rules_set.count(r) == 0) {\n                rules_set.insert(r);\n                rules.push_back(r);\n            }\n        }\n    } else if (rules_type == \"consistent\") {\n        // First, assign types to positions\n        vector<char> types(n + 1); // positions are 1-based\n        for (int i = 1; i <= n; ++i) {\n            types[i] = (rnd.next(2) == 0) ? 'V' : 'C';\n        }\n        // Now, generate rules consistent with these types\n        for (int i = 0; i < m && max_attempts-- > 0; ) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = types[pos1];\n            char t2 = types[pos2];\n            Rule r {pos1, pos2, t1, t2};\n            if (rules_set.count(r) == 0) {\n                rules_set.insert(r);\n                rules.push_back(r);\n                ++i;\n            }\n        }\n    } else if (rules_type == \"conflict\") {\n        // Generate conflicting rules\n        if (n < 2) {\n            return rules;\n        }\n        int pos1 = 1;\n        int pos2 = 2;\n        // Create rules that conflict\n        Rule r1 {pos1, 'V', pos2, 'V'};\n        Rule r2 {pos1, 'V', pos2, 'C'};\n        rules_set.insert(r1);\n        rules_set.insert(r2);\n        rules.push_back(r1);\n        rules.push_back(r2);\n        // Now, fill the rest with conflicting rules\n        for (int i = 0; i < m - 2 && max_attempts-- > 0; ) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = (rnd.next(2) == 0) ? 'V' : 'C';\n            // Create conflicting rules for same (pos1, t1, pos2)\n            Rule r1 {pos1, t1, pos2, 'V'};\n            Rule r2 {pos1, t1, pos2, 'C'};\n            if (rules_set.count(r1) == 0) {\n                rules_set.insert(r1);\n                rules.push_back(r1);\n                ++i;\n            }\n            if (i < m - 2 && rules_set.count(r2) == 0) {\n                rules_set.insert(r2);\n                rules.push_back(r2);\n                ++i;\n            }\n        }\n        if ((int)rules.size() > m) {\n            rules.resize(m);\n        }\n    } else {\n        // Default to random\n        while ((int)rules_set.size() < m && max_attempts-- > 0) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = (rnd.next(2) == 0) ? 'V' : 'C';\n            char t2 = (rnd.next(2) == 0) ? 'V' : 'C';\n            Rule r {pos1, pos2, t1, t2};\n            if (rules_set.count(r) == 0) {\n                rules_set.insert(r);\n                rules.push_back(r);\n            }\n        }\n    }\n    if ((int)rules.size() > m) {\n        rules.resize(m);\n    }\n    return rules;\n}\n\nstring generateStringS(int n, int l, const string& s_type) {\n    string res;\n    if (s_type == \"minimum\") {\n        res = string(n, 'a');\n    } else if (s_type == \"maximum\") {\n        res = string(n, 'a' + l - 1);\n    } else {\n        // Default to random\n        res.resize(n);\n        for (int i = 0; i < n; ++i) {\n            res[i] = 'a' + rnd.next(l);\n        }\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int l = opt<int>(\"l\");\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string alphabet_type = opt<string>(\"alphabet_type\", \"random\");\n    string rules_type = opt<string>(\"rules_type\", \"random\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n\n    ensuref(1 <= l && l <= 26, \"l must be between 1 and 26\");\n    ensuref(1 <= n && n <= 200, \"n must be between 1 and 200\");\n    ensuref(0 <= m && m <= 4 * n * (n - 1), \"m must be between 0 and 4n(n-1)\");\n\n    // Generate 'V' / 'C' string\n    string vc_str = generateAlphabet(l, alphabet_type);\n    cout << vc_str << endl;\n\n    // Generate rules\n    vector<Rule> rules = generateRules(n, m, rules_type);\n    cout << n << \" \" << m << endl;\n    for (const auto& rule : rules) {\n        printf(\"%d %c %d %c\\n\", rule.pos1, rule.t1, rule.pos2, rule.t2);\n    }\n\n    // Generate string s\n    string s = generateStringS(n, l, s_type);\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rule {\n    int pos1, pos2;\n    char t1, t2;\n    bool operator<(const Rule& other) const {\n        if (pos1 != other.pos1) return pos1 < other.pos1;\n        if (t1 != other.t1) return t1 < other.t1;\n        if (pos2 != other.pos2) return pos2 < other.pos2;\n        return t2 < other.t2;\n    }\n};\n\nstring generateAlphabet(int l, const string& alphabet_type) {\n    string res;\n    if (alphabet_type == \"all_vowels\") {\n        res = string(l, 'V');\n    } else if (alphabet_type == \"all_consonants\") {\n        res = string(l, 'C');\n    } else if (alphabet_type == \"alternate\") {\n        res.resize(l);\n        for (int i = 0; i < l; ++i) {\n            res[i] = (i % 2 == 0) ? 'V' : 'C';\n        }\n    } else {\n        // Default to random\n        res.resize(l);\n        for (int i = 0; i < l; ++i) {\n            res[i] = (rnd.next(2) == 0) ? 'V' : 'C';\n        }\n    }\n    return res;\n}\n\nvector<Rule> generateRules(int n, int m, const string& rules_type) {\n    set<Rule> rules_set;\n    vector<Rule> rules;\n    int max_attempts = m * 10; // To avoid infinite loop\n    if (rules_type == \"random\") {\n        while ((int)rules_set.size() < m && max_attempts-- > 0) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = (rnd.next(2) == 0) ? 'V' : 'C';\n            char t2 = (rnd.next(2) == 0) ? 'V' : 'C';\n            Rule r {pos1, pos2, t1, t2};\n            if (rules_set.count(r) == 0) {\n                rules_set.insert(r);\n                rules.push_back(r);\n            }\n        }\n    } else if (rules_type == \"consistent\") {\n        // First, assign types to positions\n        vector<char> types(n + 1); // positions are 1-based\n        for (int i = 1; i <= n; ++i) {\n            types[i] = (rnd.next(2) == 0) ? 'V' : 'C';\n        }\n        // Now, generate rules consistent with these types\n        for (int i = 0; i < m && max_attempts-- > 0; ) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = types[pos1];\n            char t2 = types[pos2];\n            Rule r {pos1, pos2, t1, t2};\n            if (rules_set.count(r) == 0) {\n                rules_set.insert(r);\n                rules.push_back(r);\n                ++i;\n            }\n        }\n    } else if (rules_type == \"conflict\") {\n        // Generate conflicting rules\n        if (n < 2) {\n            return rules;\n        }\n        int pos1 = 1;\n        int pos2 = 2;\n        // Create rules that conflict\n        Rule r1 {pos1, 'V', pos2, 'V'};\n        Rule r2 {pos1, 'V', pos2, 'C'};\n        rules_set.insert(r1);\n        rules_set.insert(r2);\n        rules.push_back(r1);\n        rules.push_back(r2);\n        // Now, fill the rest with conflicting rules\n        for (int i = 0; i < m - 2 && max_attempts-- > 0; ) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = (rnd.next(2) == 0) ? 'V' : 'C';\n            // Create conflicting rules for same (pos1, t1, pos2)\n            Rule r1 {pos1, t1, pos2, 'V'};\n            Rule r2 {pos1, t1, pos2, 'C'};\n            if (rules_set.count(r1) == 0) {\n                rules_set.insert(r1);\n                rules.push_back(r1);\n                ++i;\n            }\n            if (i < m - 2 && rules_set.count(r2) == 0) {\n                rules_set.insert(r2);\n                rules.push_back(r2);\n                ++i;\n            }\n        }\n        if ((int)rules.size() > m) {\n            rules.resize(m);\n        }\n    } else {\n        // Default to random\n        while ((int)rules_set.size() < m && max_attempts-- > 0) {\n            int pos1 = rnd.next(1, n);\n            int pos2 = rnd.next(1, n);\n            if (pos1 == pos2) continue;\n            char t1 = (rnd.next(2) == 0) ? 'V' : 'C';\n            char t2 = (rnd.next(2) == 0) ? 'V' : 'C';\n            Rule r {pos1, pos2, t1, t2};\n            if (rules_set.count(r) == 0) {\n                rules_set.insert(r);\n                rules.push_back(r);\n            }\n        }\n    }\n    if ((int)rules.size() > m) {\n        rules.resize(m);\n    }\n    return rules;\n}\n\nstring generateStringS(int n, int l, const string& s_type) {\n    string res;\n    if (s_type == \"minimum\") {\n        res = string(n, 'a');\n    } else if (s_type == \"maximum\") {\n        res = string(n, 'a' + l - 1);\n    } else {\n        // Default to random\n        res.resize(n);\n        for (int i = 0; i < n; ++i) {\n            res[i] = 'a' + rnd.next(l);\n        }\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int l = opt<int>(\"l\");\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string alphabet_type = opt<string>(\"alphabet_type\", \"random\");\n    string rules_type = opt<string>(\"rules_type\", \"random\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n\n    ensuref(1 <= l && l <= 26, \"l must be between 1 and 26\");\n    ensuref(1 <= n && n <= 200, \"n must be between 1 and 200\");\n    ensuref(0 <= m && m <= 4 * n * (n - 1), \"m must be between 0 and 4n(n-1)\");\n\n    // Generate 'V' / 'C' string\n    string vc_str = generateAlphabet(l, alphabet_type);\n    cout << vc_str << endl;\n\n    // Generate rules\n    vector<Rule> rules = generateRules(n, m, rules_type);\n    cout << n << \" \" << m << endl;\n    for (const auto& rule : rules) {\n        printf(\"%d %c %d %c\\n\", rule.pos1, rule.t1, rule.pos2, rule.t2);\n    }\n\n    // Generate string s\n    string s = generateStringS(n, l, s_type);\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -l 5 -n 5 -m 10 -alphabet_type random -rules_type random -s_type random\n./gen -l 5 -n 5 -m 10 -alphabet_type all_vowels -rules_type random -s_type minimum\n./gen -l 5 -n 5 -m 10 -alphabet_type all_consonants -rules_type random -s_type maximum\n./gen -l 5 -n 5 -m 10 -alphabet_type alternate -rules_type consistent -s_type random\n./gen -l 5 -n 5 -m 10 -alphabet_type random -rules_type consistent -s_type random\n./gen -l 5 -n 5 -m 10 -alphabet_type random -rules_type conflict -s_type random\n./gen -l 26 -n 200 -m 0 -alphabet_type random -rules_type random -s_type random\n./gen -l 1 -n 1 -m 0 -alphabet_type all_vowels -rules_type random -s_type maximum\n./gen -l 26 -n 200 -m 1000 -alphabet_type random -rules_type random -s_type minimum\n./gen -l 15 -n 100 -m 1000 -alphabet_type alternate -rules_type consistent -s_type maximum\n./gen -l 10 -n 50 -m 500 -alphabet_type all_vowels -rules_type consistent -s_type random\n./gen -l 10 -n 50 -m 500 -alphabet_type all_consonants -rules_type conflict -s_type random\n./gen -l 20 -n 100 -m 2000 -alphabet_type random -rules_type conflict -s_type maximum\n./gen -l 26 -n 200 -m 10000 -alphabet_type random -rules_type random -s_type random\n./gen -l 5 -n 10 -m 0 -alphabet_type random -rules_type random -s_type minimum\n./gen -l 5 -n 10 -m 0 -alphabet_type random -rules_type random -s_type maximum\n./gen -l 15 -n 100 -m 0 -alphabet_type random -rules_type random -s_type random\n./gen -l 26 -n 200 -m 10000 -alphabet_type random -rules_type consistent -s_type random\n./gen -l 5 -n 50 -m 2000 -alphabet_type random -rules_type conflict -s_type maximum\n./gen -l 26 -n 200 -m 159200 -alphabet_type random -rules_type random -s_type random\n./gen -l 26 -n 200 -m 159200 -alphabet_type random -rules_type conflict -s_type random\n./gen -l 1 -n 200 -m 1000 -alphabet_type all_vowels -rules_type consistent -s_type random\n./gen -l 2 -n 200 -m 1000 -alphabet_type alternate -rules_type consistent -s_type random\n./gen -l 26 -n 1 -m 0 -alphabet_type random -rules_type random -s_type random\n./gen -l 26 -n 1 -m 0 -alphabet_type random -rules_type random -s_type maximum\n./gen -l 5 -n 5 -m 20 -alphabet_type random -rules_type random -s_type maximum\n./gen -l 5 -n 5 -m 20 -alphabet_type random -rules_type random -s_type minimum\n./gen -l 5 -n 5 -m 0 -alphabet_type random -rules_type random -s_type random\n./gen -l 5 -n 5 -m 20 -alphabet_type random -rules_type conflict -s_type random\n./gen -l 5 -n 5 -m 20 -alphabet_type random -rules_type consistent -s_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:23.253142",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "57/A",
      "title": "A. Square Earth?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains 5 space-separated integers: n, x1, y1, x2, y2 (1 ≤ n ≤ 1000, 0 ≤ x1, y1, x2, y2 ≤ n) which correspondingly represent a side of the square, the coordinates of the first point and the coordinates of the second point. It is guaranteed that the points lie on the sides of the square.",
      "output_spec": "OutputYou must print on a single line the shortest distance between the points.",
      "sample_tests": "ExamplesInputCopy2 0 0 1 0OutputCopy1InputCopy2 0 1 2 1OutputCopy4InputCopy100 0 0 100 100OutputCopy200",
      "description": "A. Square Earth?\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains 5 space-separated integers: n, x1, y1, x2, y2 (1 ≤ n ≤ 1000, 0 ≤ x1, y1, x2, y2 ≤ n) which correspondingly represent a side of the square, the coordinates of the first point and the coordinates of the second point. It is guaranteed that the points lie on the sides of the square.\n\nOutputYou must print on a single line the shortest distance between the points.\n\nInputCopy2 0 0 1 0OutputCopy1InputCopy2 0 1 2 1OutputCopy4InputCopy100 0 0 100 100OutputCopy200\n\nInputCopy2 0 0 1 0\n\nOutputCopy1\n\nInputCopy2 0 1 2 1\n\nOutputCopy4\n\nInputCopy100 0 0 100 100\n\nOutputCopy200",
      "solutions": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces",
          "content": "Good evening!Congratulation to all on the day of student, calm sessions, easy exams and a lot of new knowledge! I also want to congratulate those girls (women) whose name is Tatiana on their Angel Day.I am glad to invite you to participate in Codeforces Beta Round 53. Today's round was prepared Michael Mirzayanov, Nevidomy Vitaliy, Artem Rakhov and Maria Belov, problems author is nevidomy.Contest is over.Congratulations to the winner: tourist. After the round he becomes first \"General\" of Codeforces!!! Link to results: http://codeforces.com/contest/57/standingsAnalysisNevidomy Vitaliy and Codeforces team.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1165",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 57 和字母"
          },
          "content_length": 612
        },
        {
          "title": "Codeforces Beta Round #53 [Analysis] - Codeforces",
          "content": "Problem А.Since the restrictions were not so big you can offer many different solutions. For example, you can construct a graph with N * 4 vertices and use bfs. But there was a faster solution with complexity O(1): enumerate the integer points lying on the square, for example, as is shown below:Then finding the number of a point by its coordinates isn’t difficult. For example if a point has coordinate y == n -> then its position is n + x (if the numeration, is as shown, i.e. starts with zero). It turns out that we have transformed the square into a line with a small complication: cells N * 4 - 1 and 0 are adjacent, so we have not a line but a circle, where for the base points from 0 to 4 * N-1 the distance between the adjacent two points is 1. It is easy to take the difference of indices of the points and find the distance when moving clockwise and counterclockwise: (a-b +4 * n)% (4 * n) and (b - a + 4 * n)% (4 * n), the shortest distance will be the answer.Problem BUnder the restrictions on the number of requests, you cannot iteratively add staircase. But the problem is simplified by the fact that the number of cells in which it was necessary to know the number of stones was no more than 100. That’s why you can check for each \"interesting\" cell all the queries and calculate how much each of them adds stones, so the complexity is: O (K * M), which fits within the given 2 seconds well. A faster solution with complexity O(N + M + K) is as follows: we will keep in mind two variables: a – how many items should be added now to the cell, v - how much should change a next step. So problem is to update the value of a and v so that a equaled to the number of stones in the cell after all the operations, and v – to how much a increases during the transition to the next cell. Then the problem will be reduced to that you need to properly update a and v, which is not very difficult to do, for example if there is a request (x, y, z) – then in the cell x you need to add x to a and add 1 to v, since with each next cell the number of stones for some staircase will increase by 1. Similarly, after the cell y is passed you need to subtract 1 from v and pick up from “a” the current number of stones subquery. If you save all such pairs of queries in a single array and it's possible to calculate everything in one cycle.Problem CFirst, let's count how many there are arrays in which each successive element starting from the second one is no less than the previous one. To do this quickly, let’s take a piece of squared with height of one square and the length of N*2 - 1 square, then select N-1 squares and put crosses in them - let it encode some array, let the number of blank cells from the beginning of the array before the first cross be equal to the number of ones in the array, the number of blank cells from the first cross to the second – to the number of 2 in the array, and so on. It is easy to see that the number of empty cells will be equal to N * 2-1 - (N-1) = N. It turns out that each paper encodes an array which suits us, and moreover all the possible arrays can be encoded using such paper. There is exactly C (N * 2-1, N) different pieces of paper (the binomial coefficient of N * 2-1 to N). This number can be calculated by formula with factorials, the only difficulty is division. Since the module was prime - it was possible to calculate the inverse number in the field for the module and replace division by multiplication. So we get the number of non-decreasing sequences, respectively have the same number of non-increasing, we just need to take away those who were represented in both array sets, but they are just arrays with a similar number like {1,1,1,...,1} or {4,4,...,4,4} just subtract n.Problem DLet's see, if there is no occupied cells, then it is not difficult to calculate the answer - the answer is a sum of Manhattan distances, taking into account the fact that the Manhattan distance can be divided: first we can calculate the distance of one coordinate and then of another one and then just to sum up, so the answer is not difficult to find. What do we have when there are occupied cells? If the cell from which we seek the distance does not lie on the same horizontal or vertical with occupied cells – then it absolutely does not affect the difficulty of accessing the rest of the cells:This happens due to the fact that in each cell from the previous distance front (the distance to the set of cells with maximum distance from the start cell, the fronts form a diamond as you can see in the picture or from the Manhattan distance formula) there are two ways how to get to the cell, we take into account the rule that no two cells can be adjacent (either diagonally or vertically or horizontally), it turns out that such a cell does not interfere with us. But a close look at the picture brings to mind the obvious: it is the cell which is located on the same vertical / horizontal that has only one neighbor from the previous front, let’s see what happens in such case:All the cells after occupied one starts \"to lag\" at 2 in distance, but more importantly, that changed the front! Now (with the upper side of the front) are 2 cells for which the transition from the previous front is unique, and as a consequence there are two cells meeting of which will produce a new segment of a late cells, and the angle of the front will change again. Since we are only interested in one side of its expansion (on the other hand there can not be occupied cells by the condition) so we can assume that it was expand from the start cell:It turns out that you can count how many cells will be \"delayed\", especially considering that the lag always equals to two. For each direction, you can choose each occupied cell and check in the left and right directions for adjacent cells series, and add delay for interval of free cell before occupied cell (in the current direction). It is possible to calculate such delays with complexity: square of the number of occupied cells (it is not greater than min(N, M)). The rest is details. You need to compute all Manhattan distances, taking into account the existence of occupied cells. To do this, first calculate the sum of distances for an empty field, then for each occupied cell calculate the distance to all the others - subtract it twice, as the extra distance is subtracted for the first time when we got out of this cell and for the second time when takes away from all other cells to the given one. But in this case we will take away twice the distance between two occupied cells - so we’ll have to add them (the complexity is also a square). A total complexity of solution is O (K ^ 2) where K is the number of occupied cells.Problem EThe task turned out to be very difficult as it was planned. First remove all the deleted cells - let's see how changes the number of accessible cells with the increase of the new moves. First, the changes do not appear stable, but at some point we see a figure which won’t to change the form anymore and will only expand, it is obvious that the figure is two-dimensional, therefore the growth of its “area” is a quadratic function, in fact, a simple check shows that with each new turn the number of cells increases by the number of new cells opened with previous turn + 28, so after a certain point, you can simply take the sum of an arithmetic progression. The case with the deleted cells is similar. In general, there are several possible options - either occupied cells block further penetration of the horse or not, in the first case bfs is simply enough to find solutions, in the second one the story is the same: over time, when the figure \"becomes balanced\", the number of new opened cells satisfies the same rule \"prev +28\" . Moreover, because of restrictions of the coordinates of the deleted cells (-10 <= x, y <= 10) this happens fairly quickly. So, use usual bfs to balance figures, and after this use the sum of the arithmetic progression.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7988
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 1",
          "code": "47 24\n........................\n........................\n........................\n........................\n........................\n........................\nX.......................\n........................\n....X...................\n..........X......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 2",
          "code": "23.6657545509435892",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 3",
          "code": "23.670250896057",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 4",
          "code": "wrong answer 1st numbers differ - expected: '23.6702509', found: '23.6657546', error = '0.0001900'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 5",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    long long int *v;        cin >> n >> m >> k;    v = (long long int*)malloc(sizeof(long long int)*n);           memset(v,0,sizeof(v));    for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }   //      for(int i=0;i<n;i++){//          cout << v[i] << endl;//      }//      cout << endl << endl;    }//  for(int i=0;i<n;i++){//      cout << v[i] << endl;//  }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 6",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>#include <vector>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    cin >> n >> m >> k;    vector<long long int> v;    for(int i=0;i<n;i++){        v.push_back(0);    }        for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }       }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}...this got accepted....I concluded that memset was giving garbage..I dont knw why..!!....",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 7",
          "code": "long long int *v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 8",
          "code": "sizeof(v) is equal to size of pointer to long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 9",
          "code": "you need write memset(v,0,sizeof(v[0]) * n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 10",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 11",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x1 = inf.readInt(0, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, n, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(0, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, n, \"y2\");\n    inf.readEoln();\n\n    ensuref(x1 == 0 || x1 == n || y1 == 0 || y1 == n, \"First point must lie on the sides of the square\");\n    ensuref(x2 == 0 || x2 == n || y2 == 0 || y2 == n, \"Second point must lie on the sides of the square\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x1 = inf.readInt(0, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, n, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(0, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, n, \"y2\");\n    inf.readEoln();\n\n    ensuref(x1 == 0 || x1 == n || y1 == 0 || y1 == n, \"First point must lie on the sides of the square\");\n    ensuref(x2 == 0 || x2 == n || y2 == 0 || y2 == n, \"Second point must lie on the sides of the square\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x1 = inf.readInt(0, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, n, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(0, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, n, \"y2\");\n    inf.readEoln();\n\n    ensuref(x1 == 0 || x1 == n || y1 == 0 || y1 == n, \"First point must lie on the sides of the square\");\n    ensuref(x2 == 0 || x2 == n || y2 == 0 || y2 == n, \"Second point must lie on the sides of the square\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int x1, y1, x2, y2;\n\n    // Function to get coordinates on the square perimeter\n    auto get_coord = [&](int side, int pos, int &x, int &y) {\n        if (side == 0) {\n            // Side from (0,0) to (n,0)\n            x = pos;\n            y = 0;\n        } else if (side == 1) {\n            // Side from (n,0) to (n,n)\n            x = n;\n            y = pos;\n        } else if (side == 2) {\n            // Side from (n,n) to (0,n)\n            x = n - pos;\n            y = n;\n        } else {\n            // Side from (0,n) to (0,0)\n            x = 0;\n            y = n - pos;\n        }\n    };\n\n    if (type == \"random\") {\n        // Generate two random points on the perimeter\n        int side1 = rnd.next(4); // 0 to 3\n        int pos1 = rnd.next(0, n);\n        int side2 = rnd.next(4);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else if (type == \"same_side\") {\n        // Both points on the same side\n        int side = rnd.next(4);\n        int pos1 = rnd.next(0, n);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side, pos1, x1, y1);\n        get_coord(side, pos2, x2, y2);\n    } else if (type == \"adjacent_sides\") {\n        // Points on adjacent sides\n        int side1 = rnd.next(4);\n        int side2 = (side1 + 1) % 4;\n        int pos1 = rnd.next(0, n);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else if (type == \"opposite_sides\") {\n        // Points on opposite sides\n        int side1 = rnd.next(4);\n        int side2 = (side1 + 2) % 4;\n        int pos1 = rnd.next(0, n);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else if (type == \"corner_cases\") {\n        // Points at corners\n        vector<pair<int, int>> corners = {{0, 0}, {n, 0}, {n, n}, {0, n}};\n        int idx1 = rnd.next(4);\n        int idx2 = rnd.next(4);\n\n        x1 = corners[idx1].first;\n        y1 = corners[idx1].second;\n        x2 = corners[idx2].first;\n        y2 = corners[idx2].second;\n    } else if (type == \"midpoints\") {\n        // Points at midpoints of sides\n        vector<pair<int, int>> midpoints = {{n / 2, 0}, {n, n / 2}, {n / 2, n}, {0, n / 2}};\n        int idx1 = rnd.next(4);\n        int idx2 = rnd.next(4);\n\n        x1 = midpoints[idx1].first;\n        y1 = midpoints[idx1].second;\n        x2 = midpoints[idx2].first;\n        y2 = midpoints[idx2].second;\n    } else if (type == \"minimal_distance\") {\n        // Points very close to each other\n        int side = rnd.next(4);\n        int pos = rnd.next(0, n - 1); // Ensure pos + 1 ≤ n\n        int delta = 1;\n\n        get_coord(side, pos, x1, y1);\n        get_coord(side, pos + delta, x2, y2);\n    } else if (type == \"maximal_distance\") {\n        // Points far apart\n        int side1 = rnd.next(4);\n        int side2 = (side1 + 2) % 4;\n        int pos1 = 0;\n        int pos2 = n;\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else {\n        // Default to random\n        int side1 = rnd.next(4);\n        int pos1 = rnd.next(0, n);\n        int side2 = rnd.next(4);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    }\n\n    // Output n x1 y1 x2 y2\n    printf(\"%d %d %d %d %d\\n\", n, x1, y1, x2, y2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int x1, y1, x2, y2;\n\n    // Function to get coordinates on the square perimeter\n    auto get_coord = [&](int side, int pos, int &x, int &y) {\n        if (side == 0) {\n            // Side from (0,0) to (n,0)\n            x = pos;\n            y = 0;\n        } else if (side == 1) {\n            // Side from (n,0) to (n,n)\n            x = n;\n            y = pos;\n        } else if (side == 2) {\n            // Side from (n,n) to (0,n)\n            x = n - pos;\n            y = n;\n        } else {\n            // Side from (0,n) to (0,0)\n            x = 0;\n            y = n - pos;\n        }\n    };\n\n    if (type == \"random\") {\n        // Generate two random points on the perimeter\n        int side1 = rnd.next(4); // 0 to 3\n        int pos1 = rnd.next(0, n);\n        int side2 = rnd.next(4);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else if (type == \"same_side\") {\n        // Both points on the same side\n        int side = rnd.next(4);\n        int pos1 = rnd.next(0, n);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side, pos1, x1, y1);\n        get_coord(side, pos2, x2, y2);\n    } else if (type == \"adjacent_sides\") {\n        // Points on adjacent sides\n        int side1 = rnd.next(4);\n        int side2 = (side1 + 1) % 4;\n        int pos1 = rnd.next(0, n);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else if (type == \"opposite_sides\") {\n        // Points on opposite sides\n        int side1 = rnd.next(4);\n        int side2 = (side1 + 2) % 4;\n        int pos1 = rnd.next(0, n);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else if (type == \"corner_cases\") {\n        // Points at corners\n        vector<pair<int, int>> corners = {{0, 0}, {n, 0}, {n, n}, {0, n}};\n        int idx1 = rnd.next(4);\n        int idx2 = rnd.next(4);\n\n        x1 = corners[idx1].first;\n        y1 = corners[idx1].second;\n        x2 = corners[idx2].first;\n        y2 = corners[idx2].second;\n    } else if (type == \"midpoints\") {\n        // Points at midpoints of sides\n        vector<pair<int, int>> midpoints = {{n / 2, 0}, {n, n / 2}, {n / 2, n}, {0, n / 2}};\n        int idx1 = rnd.next(4);\n        int idx2 = rnd.next(4);\n\n        x1 = midpoints[idx1].first;\n        y1 = midpoints[idx1].second;\n        x2 = midpoints[idx2].first;\n        y2 = midpoints[idx2].second;\n    } else if (type == \"minimal_distance\") {\n        // Points very close to each other\n        int side = rnd.next(4);\n        int pos = rnd.next(0, n - 1); // Ensure pos + 1 ≤ n\n        int delta = 1;\n\n        get_coord(side, pos, x1, y1);\n        get_coord(side, pos + delta, x2, y2);\n    } else if (type == \"maximal_distance\") {\n        // Points far apart\n        int side1 = rnd.next(4);\n        int side2 = (side1 + 2) % 4;\n        int pos1 = 0;\n        int pos2 = n;\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    } else {\n        // Default to random\n        int side1 = rnd.next(4);\n        int pos1 = rnd.next(0, n);\n        int side2 = rnd.next(4);\n        int pos2 = rnd.next(0, n);\n\n        get_coord(side1, pos1, x1, y1);\n        get_coord(side2, pos2, x2, y2);\n    }\n\n    // Output n x1 y1 x2 y2\n    printf(\"%d %d %d %d %d\\n\", n, x1, y1, x2, y2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with small n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n\n# Random test cases with large n\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n\n# Same side test cases\n./gen -n 1 -type same_side\n./gen -n 100 -type same_side\n./gen -n 500 -type same_side\n./gen -n 1000 -type same_side\n\n# Adjacent sides test cases\n./gen -n 1 -type adjacent_sides\n./gen -n 100 -type adjacent_sides\n./gen -n 500 -type adjacent_sides\n./gen -n 1000 -type adjacent_sides\n\n# Opposite sides test cases\n./gen -n 1 -type opposite_sides\n./gen -n 100 -type opposite_sides\n./gen -n 500 -type opposite_sides\n./gen -n 1000 -type opposite_sides\n\n# Corner cases\n./gen -n 1 -type corner_cases\n./gen -n 100 -type corner_cases\n./gen -n 500 -type corner_cases\n./gen -n 1000 -type corner_cases\n\n# Midpoints\n./gen -n 1 -type midpoints\n./gen -n 100 -type midpoints\n./gen -n 500 -type midpoints\n./gen -n 1000 -type midpoints\n\n# Minimal distance test cases\n./gen -n 2 -type minimal_distance\n./gen -n 100 -type minimal_distance\n./gen -n 500 -type minimal_distance\n./gen -n 1000 -type minimal_distance\n\n# Maximal distance test cases\n./gen -n 1 -type maximal_distance\n./gen -n 100 -type maximal_distance\n./gen -n 500 -type maximal_distance\n./gen -n 1000 -type maximal_distance\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:25.182977",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "57/B",
      "title": "B. Martian Architecture",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers: n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ min(n, 100)) which is the number of cells, the number of \"Roads to the Sun\" and the number of cells in the query correspondingly. Each of the following m roads contain three space-separated integers: ai, bi, ci (1 ≤ ai ≤ bi ≤ n, 1 ≤ ci ≤ 1000) which are the stairway's description, its beginning, end and the initial cell's height. Then follow a line, containing k different space-separated integers bi. All these numbers ranging from 1 to n are cells, the number of stones in which interests Chris.",
      "output_spec": "OutputYou have to print a single number on a single line which is the sum of stones in all the cells Chris is interested in.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).",
      "sample_tests": "ExamplesInputCopy5 2 11 5 12 4 13OutputCopy5InputCopy3 2 11 3 11 3 12OutputCopy4InputCopy3 2 11 3 11 3 13OutputCopy6",
      "description": "B. Martian Architecture\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers: n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ min(n, 100)) which is the number of cells, the number of \"Roads to the Sun\" and the number of cells in the query correspondingly. Each of the following m roads contain three space-separated integers: ai, bi, ci (1 ≤ ai ≤ bi ≤ n, 1 ≤ ci ≤ 1000) which are the stairway's description, its beginning, end and the initial cell's height. Then follow a line, containing k different space-separated integers bi. All these numbers ranging from 1 to n are cells, the number of stones in which interests Chris.\n\nOutputYou have to print a single number on a single line which is the sum of stones in all the cells Chris is interested in.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).\n\nInputCopy5 2 11 5 12 4 13OutputCopy5InputCopy3 2 11 3 11 3 12OutputCopy4InputCopy3 2 11 3 11 3 13OutputCopy6\n\nInputCopy5 2 11 5 12 4 13\n\nOutputCopy5\n\nInputCopy3 2 11 3 11 3 12\n\nOutputCopy4\n\nInputCopy3 2 11 3 11 3 13\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces",
          "content": "Good evening!Congratulation to all on the day of student, calm sessions, easy exams and a lot of new knowledge! I also want to congratulate those girls (women) whose name is Tatiana on their Angel Day.I am glad to invite you to participate in Codeforces Beta Round 53. Today's round was prepared Michael Mirzayanov, Nevidomy Vitaliy, Artem Rakhov and Maria Belov, problems author is nevidomy.Contest is over.Congratulations to the winner: tourist. After the round he becomes first \"General\" of Codeforces!!! Link to results: http://codeforces.com/contest/57/standingsAnalysisNevidomy Vitaliy and Codeforces team.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1165",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 57 和字母"
          },
          "content_length": 612
        },
        {
          "title": "Codeforces Beta Round #53 [Analysis] - Codeforces",
          "content": "Problem А.Since the restrictions were not so big you can offer many different solutions. For example, you can construct a graph with N * 4 vertices and use bfs. But there was a faster solution with complexity O(1): enumerate the integer points lying on the square, for example, as is shown below:Then finding the number of a point by its coordinates isn’t difficult. For example if a point has coordinate y == n -> then its position is n + x (if the numeration, is as shown, i.e. starts with zero). It turns out that we have transformed the square into a line with a small complication: cells N * 4 - 1 and 0 are adjacent, so we have not a line but a circle, where for the base points from 0 to 4 * N-1 the distance between the adjacent two points is 1. It is easy to take the difference of indices of the points and find the distance when moving clockwise and counterclockwise: (a-b +4 * n)% (4 * n) and (b - a + 4 * n)% (4 * n), the shortest distance will be the answer.Problem BUnder the restrictions on the number of requests, you cannot iteratively add staircase. But the problem is simplified by the fact that the number of cells in which it was necessary to know the number of stones was no more than 100. That’s why you can check for each \"interesting\" cell all the queries and calculate how much each of them adds stones, so the complexity is: O (K * M), which fits within the given 2 seconds well. A faster solution with complexity O(N + M + K) is as follows: we will keep in mind two variables: a – how many items should be added now to the cell, v - how much should change a next step. So problem is to update the value of a and v so that a equaled to the number of stones in the cell after all the operations, and v – to how much a increases during the transition to the next cell. Then the problem will be reduced to that you need to properly update a and v, which is not very difficult to do, for example if there is a request (x, y, z) – then in the cell x you need to add x to a and add 1 to v, since with each next cell the number of stones for some staircase will increase by 1. Similarly, after the cell y is passed you need to subtract 1 from v and pick up from “a” the current number of stones subquery. If you save all such pairs of queries in a single array and it's possible to calculate everything in one cycle.Problem CFirst, let's count how many there are arrays in which each successive element starting from the second one is no less than the previous one. To do this quickly, let’s take a piece of squared with height of one square and the length of N*2 - 1 square, then select N-1 squares and put crosses in them - let it encode some array, let the number of blank cells from the beginning of the array before the first cross be equal to the number of ones in the array, the number of blank cells from the first cross to the second – to the number of 2 in the array, and so on. It is easy to see that the number of empty cells will be equal to N * 2-1 - (N-1) = N. It turns out that each paper encodes an array which suits us, and moreover all the possible arrays can be encoded using such paper. There is exactly C (N * 2-1, N) different pieces of paper (the binomial coefficient of N * 2-1 to N). This number can be calculated by formula with factorials, the only difficulty is division. Since the module was prime - it was possible to calculate the inverse number in the field for the module and replace division by multiplication. So we get the number of non-decreasing sequences, respectively have the same number of non-increasing, we just need to take away those who were represented in both array sets, but they are just arrays with a similar number like {1,1,1,...,1} or {4,4,...,4,4} just subtract n.Problem DLet's see, if there is no occupied cells, then it is not difficult to calculate the answer - the answer is a sum of Manhattan distances, taking into account the fact that the Manhattan distance can be divided: first we can calculate the distance of one coordinate and then of another one and then just to sum up, so the answer is not difficult to find. What do we have when there are occupied cells? If the cell from which we seek the distance does not lie on the same horizontal or vertical with occupied cells – then it absolutely does not affect the difficulty of accessing the rest of the cells:This happens due to the fact that in each cell from the previous distance front (the distance to the set of cells with maximum distance from the start cell, the fronts form a diamond as you can see in the picture or from the Manhattan distance formula) there are two ways how to get to the cell, we take into account the rule that no two cells can be adjacent (either diagonally or vertically or horizontally), it turns out that such a cell does not interfere with us. But a close look at the picture brings to mind the obvious: it is the cell which is located on the same vertical / horizontal that has only one neighbor from the previous front, let’s see what happens in such case:All the cells after occupied one starts \"to lag\" at 2 in distance, but more importantly, that changed the front! Now (with the upper side of the front) are 2 cells for which the transition from the previous front is unique, and as a consequence there are two cells meeting of which will produce a new segment of a late cells, and the angle of the front will change again. Since we are only interested in one side of its expansion (on the other hand there can not be occupied cells by the condition) so we can assume that it was expand from the start cell:It turns out that you can count how many cells will be \"delayed\", especially considering that the lag always equals to two. For each direction, you can choose each occupied cell and check in the left and right directions for adjacent cells series, and add delay for interval of free cell before occupied cell (in the current direction). It is possible to calculate such delays with complexity: square of the number of occupied cells (it is not greater than min(N, M)). The rest is details. You need to compute all Manhattan distances, taking into account the existence of occupied cells. To do this, first calculate the sum of distances for an empty field, then for each occupied cell calculate the distance to all the others - subtract it twice, as the extra distance is subtracted for the first time when we got out of this cell and for the second time when takes away from all other cells to the given one. But in this case we will take away twice the distance between two occupied cells - so we’ll have to add them (the complexity is also a square). A total complexity of solution is O (K ^ 2) where K is the number of occupied cells.Problem EThe task turned out to be very difficult as it was planned. First remove all the deleted cells - let's see how changes the number of accessible cells with the increase of the new moves. First, the changes do not appear stable, but at some point we see a figure which won’t to change the form anymore and will only expand, it is obvious that the figure is two-dimensional, therefore the growth of its “area” is a quadratic function, in fact, a simple check shows that with each new turn the number of cells increases by the number of new cells opened with previous turn + 28, so after a certain point, you can simply take the sum of an arithmetic progression. The case with the deleted cells is similar. In general, there are several possible options - either occupied cells block further penetration of the horse or not, in the first case bfs is simply enough to find solutions, in the second one the story is the same: over time, when the figure \"becomes balanced\", the number of new opened cells satisfies the same rule \"prev +28\" . Moreover, because of restrictions of the coordinates of the deleted cells (-10 <= x, y <= 10) this happens fairly quickly. So, use usual bfs to balance figures, and after this use the sum of the arithmetic progression.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7988
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 1",
          "code": "47 24\n........................\n........................\n........................\n........................\n........................\n........................\nX.......................\n........................\n....X...................\n..........X......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 2",
          "code": "23.6657545509435892",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 3",
          "code": "23.670250896057",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 4",
          "code": "wrong answer 1st numbers differ - expected: '23.6702509', found: '23.6657546', error = '0.0001900'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 5",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    long long int *v;        cin >> n >> m >> k;    v = (long long int*)malloc(sizeof(long long int)*n);           memset(v,0,sizeof(v));    for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }   //      for(int i=0;i<n;i++){//          cout << v[i] << endl;//      }//      cout << endl << endl;    }//  for(int i=0;i<n;i++){//      cout << v[i] << endl;//  }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 6",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>#include <vector>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    cin >> n >> m >> k;    vector<long long int> v;    for(int i=0;i<n;i++){        v.push_back(0);    }        for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }       }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}...this got accepted....I concluded that memset was giving garbage..I dont knw why..!!....",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 7",
          "code": "long long int *v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 8",
          "code": "sizeof(v) is equal to size of pointer to long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 9",
          "code": "you need write memset(v,0,sizeof(v[0]) * n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 10",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 11",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 100), \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000, \"ci\");\n        inf.readEoln();\n    }\n\n    vector<int> cells = inf.readInts(k, 1, n, \"cells\");\n    inf.readEoln();\n\n    std::set<int> cellSet(cells.begin(), cells.end());\n    ensuref((int)cellSet.size() == k, \"All k integers should be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 100), \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000, \"ci\");\n        inf.readEoln();\n    }\n\n    vector<int> cells = inf.readInts(k, 1, n, \"cells\");\n    inf.readEoln();\n\n    std::set<int> cellSet(cells.begin(), cells.end());\n    ensuref((int)cellSet.size() == k, \"All k integers should be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 100), \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000, \"ci\");\n        inf.readEoln();\n    }\n\n    vector<int> cells = inf.readInts(k, 1, n, \"cells\");\n    inf.readEoln();\n\n    std::set<int> cellSet(cells.begin(), cells.end());\n    ensuref((int)cellSet.size() == k, \"All k integers should be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", min(n, 100));\n    k = min(k, min(n, 100));\n    k = max(k, 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m), b(m), c(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_overlap\") {\n        // All roads cover the same range\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = l;\n            b[i] = r;\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"edge_cells\") {\n        for (int i = 0; i < m; ++i) {\n            if (rnd.next(2)) {\n                a[i] = 1;\n            } else {\n                a[i] = n;\n            }\n            b[i] = a[i];\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"single_cell_roads\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = a[i];\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"full_range\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n            b[i] = n;\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_ci\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = 1000;\n        }\n    } else if (type == \"min_ci\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = 1;\n        }\n    } else if (type == \"staircase\") {\n        int ci = 1;\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = ci;\n            ci = (ci % 1000) + 1;\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n    }\n\n    // Generate cells of interest\n    vector<int> cells(n);\n    for (int i = 0; i < n; ++i) cells[i] = i + 1;\n\n    if (type == \"edge_cells\") {\n        // Ensure k includes 1 and n if possible\n        set<int> query_cells;\n        query_cells.insert(1);\n        if (n > 1) query_cells.insert(n);\n        shuffle(cells.begin(), cells.end());\n        for (int i = 0; i < n && (int)query_cells.size() < k; ++i) {\n            if (cells[i] != 1 && cells[i] != n) {\n                query_cells.insert(cells[i]);\n            }\n        }\n        vector<int> query_cells_vec(query_cells.begin(), query_cells.end());\n        query_cells_vec.resize(k);\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d%c\", query_cells_vec[i], (i == k -1) ? '\\n' : ' ');\n        }\n    } else {\n        shuffle(cells.begin(), cells.end());\n        cells.resize(k);\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d%c\", cells[i], (i == k -1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", min(n, 100));\n    k = min(k, min(n, 100));\n    k = max(k, 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m), b(m), c(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_overlap\") {\n        // All roads cover the same range\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = l;\n            b[i] = r;\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"edge_cells\") {\n        for (int i = 0; i < m; ++i) {\n            if (rnd.next(2)) {\n                a[i] = 1;\n            } else {\n                a[i] = n;\n            }\n            b[i] = a[i];\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"single_cell_roads\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = a[i];\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"full_range\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n            b[i] = n;\n            c[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_ci\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = 1000;\n        }\n    } else if (type == \"min_ci\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = 1;\n        }\n    } else if (type == \"staircase\") {\n        int ci = 1;\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = ci;\n            ci = (ci % 1000) + 1;\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(a[i], n);\n            c[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n    }\n\n    // Generate cells of interest\n    vector<int> cells(n);\n    for (int i = 0; i < n; ++i) cells[i] = i + 1;\n\n    if (type == \"edge_cells\") {\n        // Ensure k includes 1 and n if possible\n        set<int> query_cells;\n        query_cells.insert(1);\n        if (n > 1) query_cells.insert(n);\n        shuffle(cells.begin(), cells.end());\n        for (int i = 0; i < n && (int)query_cells.size() < k; ++i) {\n            if (cells[i] != 1 && cells[i] != n) {\n                query_cells.insert(cells[i]);\n            }\n        }\n        vector<int> query_cells_vec(query_cells.begin(), query_cells.end());\n        query_cells_vec.resize(k);\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d%c\", query_cells_vec[i], (i == k -1) ? '\\n' : ' ');\n        }\n    } else {\n        shuffle(cells.begin(), cells.end());\n        cells.resize(k);\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d%c\", cells[i], (i == k -1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type min_values\n\n./gen -n 1 -m 1 -k 1 -type full_range\n\n./gen -n 10 -m 10 -k 10 -type random\n\n./gen -n 100 -m 100 -k 10 -type random\n\n./gen -n 1000 -m 1000 -k 100 -type random\n\n./gen -n 5000 -m 5000 -k 100 -type full_range\n\n./gen -n 10000 -m 10000 -k 100 -type max_overlap\n\n./gen -n 100000 -m 100000 -k 100 -type max_values\n\n./gen -n 100000 -m 100000 -k 100 -type full_range\n\n./gen -n 100000 -m 100000 -k 100 -type single_cell_roads\n\n./gen -n 100000 -m 100000 -k 1 -type max_ci\n\n./gen -n 50000 -m 50000 -k 50 -type min_ci\n\n./gen -n 50000 -m 50000 -k 50 -type staircase\n\n./gen -n 50000 -m 50000 -k 1 -type edge_cells\n\n./gen -n 100000 -m 100000 -k 100 -type random\n\n./gen -n 100000 -m 100000 -k 100 -type edge_cells\n\n./gen -n 12345 -m 54321 -k 100 -type random\n\n./gen -n 54321 -m 12345 -k 100 -type random\n\n./gen -n 100000 -m 100000 -k 1 -type random\n\n./gen -n 100000 -m 100000 -k 100 -type random\n\n./gen -n 99999 -m 99999 -k 99 -type random\n\n./gen -n 1 -m 100000 -k 1 -type full_range\n\n./gen -n 1 -m 50000 -k 1 -type single_cell_roads\n\n./gen -n 100000 -m 1 -k 1 -type max_ci\n\n./gen -n 1 -m 1 -k 1 -type random\n\n./gen -n 100000 -m 100000 -k 100 -type max_overlap\n\n./gen -n 100000 -m 100000 -k 100 -type min_ci\n\n./gen -n 1 -m 1 -k 1 -type staircase\n\n./gen -n 2 -m 1 -k 1 -type edge_cells\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:27.710956",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "57/C",
      "title": "C. Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains an integer n which is the size of the array (1 ≤ n ≤ 105).",
      "output_spec": "OutputYou must print the answer on a single line. As it can be rather long, you should print it modulo 1000000007.",
      "sample_tests": "ExamplesInputCopy2OutputCopy4InputCopy3OutputCopy17",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains an integer n which is the size of the array (1 ≤ n ≤ 105).\n\nOutputYou must print the answer on a single line. As it can be rather long, you should print it modulo 1000000007.\n\nInputCopy2OutputCopy4InputCopy3OutputCopy17\n\nOutputCopy4\n\nOutputCopy17",
      "solutions": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces",
          "content": "Good evening!Congratulation to all on the day of student, calm sessions, easy exams and a lot of new knowledge! I also want to congratulate those girls (women) whose name is Tatiana on their Angel Day.I am glad to invite you to participate in Codeforces Beta Round 53. Today's round was prepared Michael Mirzayanov, Nevidomy Vitaliy, Artem Rakhov and Maria Belov, problems author is nevidomy.Contest is over.Congratulations to the winner: tourist. After the round he becomes first \"General\" of Codeforces!!! Link to results: http://codeforces.com/contest/57/standingsAnalysisNevidomy Vitaliy and Codeforces team.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1165",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 57 和字母"
          },
          "content_length": 612
        },
        {
          "title": "Codeforces Beta Round #53 [Analysis] - Codeforces",
          "content": "Problem А.Since the restrictions were not so big you can offer many different solutions. For example, you can construct a graph with N * 4 vertices and use bfs. But there was a faster solution with complexity O(1): enumerate the integer points lying on the square, for example, as is shown below:Then finding the number of a point by its coordinates isn’t difficult. For example if a point has coordinate y == n -> then its position is n + x (if the numeration, is as shown, i.e. starts with zero). It turns out that we have transformed the square into a line with a small complication: cells N * 4 - 1 and 0 are adjacent, so we have not a line but a circle, where for the base points from 0 to 4 * N-1 the distance between the adjacent two points is 1. It is easy to take the difference of indices of the points and find the distance when moving clockwise and counterclockwise: (a-b +4 * n)% (4 * n) and (b - a + 4 * n)% (4 * n), the shortest distance will be the answer.Problem BUnder the restrictions on the number of requests, you cannot iteratively add staircase. But the problem is simplified by the fact that the number of cells in which it was necessary to know the number of stones was no more than 100. That’s why you can check for each \"interesting\" cell all the queries and calculate how much each of them adds stones, so the complexity is: O (K * M), which fits within the given 2 seconds well. A faster solution with complexity O(N + M + K) is as follows: we will keep in mind two variables: a – how many items should be added now to the cell, v - how much should change a next step. So problem is to update the value of a and v so that a equaled to the number of stones in the cell after all the operations, and v – to how much a increases during the transition to the next cell. Then the problem will be reduced to that you need to properly update a and v, which is not very difficult to do, for example if there is a request (x, y, z) – then in the cell x you need to add x to a and add 1 to v, since with each next cell the number of stones for some staircase will increase by 1. Similarly, after the cell y is passed you need to subtract 1 from v and pick up from “a” the current number of stones subquery. If you save all such pairs of queries in a single array and it's possible to calculate everything in one cycle.Problem CFirst, let's count how many there are arrays in which each successive element starting from the second one is no less than the previous one. To do this quickly, let’s take a piece of squared with height of one square and the length of N*2 - 1 square, then select N-1 squares and put crosses in them - let it encode some array, let the number of blank cells from the beginning of the array before the first cross be equal to the number of ones in the array, the number of blank cells from the first cross to the second – to the number of 2 in the array, and so on. It is easy to see that the number of empty cells will be equal to N * 2-1 - (N-1) = N. It turns out that each paper encodes an array which suits us, and moreover all the possible arrays can be encoded using such paper. There is exactly C (N * 2-1, N) different pieces of paper (the binomial coefficient of N * 2-1 to N). This number can be calculated by formula with factorials, the only difficulty is division. Since the module was prime - it was possible to calculate the inverse number in the field for the module and replace division by multiplication. So we get the number of non-decreasing sequences, respectively have the same number of non-increasing, we just need to take away those who were represented in both array sets, but they are just arrays with a similar number like {1,1,1,...,1} or {4,4,...,4,4} just subtract n.Problem DLet's see, if there is no occupied cells, then it is not difficult to calculate the answer - the answer is a sum of Manhattan distances, taking into account the fact that the Manhattan distance can be divided: first we can calculate the distance of one coordinate and then of another one and then just to sum up, so the answer is not difficult to find. What do we have when there are occupied cells? If the cell from which we seek the distance does not lie on the same horizontal or vertical with occupied cells – then it absolutely does not affect the difficulty of accessing the rest of the cells:This happens due to the fact that in each cell from the previous distance front (the distance to the set of cells with maximum distance from the start cell, the fronts form a diamond as you can see in the picture or from the Manhattan distance formula) there are two ways how to get to the cell, we take into account the rule that no two cells can be adjacent (either diagonally or vertically or horizontally), it turns out that such a cell does not interfere with us. But a close look at the picture brings to mind the obvious: it is the cell which is located on the same vertical / horizontal that has only one neighbor from the previous front, let’s see what happens in such case:All the cells after occupied one starts \"to lag\" at 2 in distance, but more importantly, that changed the front! Now (with the upper side of the front) are 2 cells for which the transition from the previous front is unique, and as a consequence there are two cells meeting of which will produce a new segment of a late cells, and the angle of the front will change again. Since we are only interested in one side of its expansion (on the other hand there can not be occupied cells by the condition) so we can assume that it was expand from the start cell:It turns out that you can count how many cells will be \"delayed\", especially considering that the lag always equals to two. For each direction, you can choose each occupied cell and check in the left and right directions for adjacent cells series, and add delay for interval of free cell before occupied cell (in the current direction). It is possible to calculate such delays with complexity: square of the number of occupied cells (it is not greater than min(N, M)). The rest is details. You need to compute all Manhattan distances, taking into account the existence of occupied cells. To do this, first calculate the sum of distances for an empty field, then for each occupied cell calculate the distance to all the others - subtract it twice, as the extra distance is subtracted for the first time when we got out of this cell and for the second time when takes away from all other cells to the given one. But in this case we will take away twice the distance between two occupied cells - so we’ll have to add them (the complexity is also a square). A total complexity of solution is O (K ^ 2) where K is the number of occupied cells.Problem EThe task turned out to be very difficult as it was planned. First remove all the deleted cells - let's see how changes the number of accessible cells with the increase of the new moves. First, the changes do not appear stable, but at some point we see a figure which won’t to change the form anymore and will only expand, it is obvious that the figure is two-dimensional, therefore the growth of its “area” is a quadratic function, in fact, a simple check shows that with each new turn the number of cells increases by the number of new cells opened with previous turn + 28, so after a certain point, you can simply take the sum of an arithmetic progression. The case with the deleted cells is similar. In general, there are several possible options - either occupied cells block further penetration of the horse or not, in the first case bfs is simply enough to find solutions, in the second one the story is the same: over time, when the figure \"becomes balanced\", the number of new opened cells satisfies the same rule \"prev +28\" . Moreover, because of restrictions of the coordinates of the deleted cells (-10 <= x, y <= 10) this happens fairly quickly. So, use usual bfs to balance figures, and after this use the sum of the arithmetic progression.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7988
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 1",
          "code": "47 24\n........................\n........................\n........................\n........................\n........................\n........................\nX.......................\n........................\n....X...................\n..........X......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 2",
          "code": "23.6657545509435892",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 3",
          "code": "23.670250896057",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 4",
          "code": "wrong answer 1st numbers differ - expected: '23.6702509', found: '23.6657546', error = '0.0001900'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 5",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    long long int *v;        cin >> n >> m >> k;    v = (long long int*)malloc(sizeof(long long int)*n);           memset(v,0,sizeof(v));    for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }   //      for(int i=0;i<n;i++){//          cout << v[i] << endl;//      }//      cout << endl << endl;    }//  for(int i=0;i<n;i++){//      cout << v[i] << endl;//  }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 6",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>#include <vector>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    cin >> n >> m >> k;    vector<long long int> v;    for(int i=0;i<n;i++){        v.push_back(0);    }        for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }       }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}...this got accepted....I concluded that memset was giving garbage..I dont knw why..!!....",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 7",
          "code": "long long int *v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 8",
          "code": "sizeof(v) is equal to size of pointer to long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 9",
          "code": "you need write memset(v,0,sizeof(v[0]) * n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 10",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 11",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    ensure(1 <= min_n && min_n <= max_n && max_n <= 100000);\n    int n;\n    if(type == \"min\") {\n        n = min_n;\n    } else if(type == \"max\") {\n        n = max_n;\n    } else if(type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else {\n        n = min_n;\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    ensure(1 <= min_n && min_n <= max_n && max_n <= 100000);\n    int n;\n    if(type == \"min\") {\n        n = min_n;\n    } else if(type == \"max\") {\n        n = max_n;\n    } else if(type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else {\n        n = min_n;\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Min n (n = 1)\n./gen -min_n 1 -max_n 1 -type min\n\n# Small n values\n./gen -min_n 1 -max_n 10 -type random\n./gen -min_n 1 -max_n 10 -type random\n./gen -min_n 1 -max_n 10 -type random\n\n# Specific small n values\n./gen -min_n 2 -max_n 2 -type min\n./gen -min_n 3 -max_n 3 -type min\n./gen -min_n 4 -max_n 4 -type min\n./gen -min_n 5 -max_n 5 -type min\n\n# Medium n values\n./gen -min_n 100 -max_n 1000 -type random\n./gen -min_n 100 -max_n 1000 -type random\n./gen -min_n 100 -max_n 1000 -type random\n\n# Specific medium n values\n./gen -min_n 100 -max_n 100 -type min\n./gen -min_n 500 -max_n 500 -type min\n./gen -min_n 1000 -max_n 1000 -type min\n\n# Large n values\n./gen -min_n 90000 -max_n 100000 -type random\n./gen -min_n 90000 -max_n 100000 -type random\n./gen -min_n 90000 -max_n 100000 -type random\n\n# Specific large n values\n./gen -min_n 99999 -max_n 99999 -type min\n./gen -min_n 100000 -max_n 100000 -type max\n\n# Max n (n = 100000)\n./gen -min_n 100000 -max_n 100000 -type max\n\n# Random n in full range\n./gen -min_n 1 -max_n 100000 -type random\n./gen -min_n 1 -max_n 100000 -type random\n./gen -min_n 1 -max_n 100000 -type random\n\n# Additional small n values\n./gen -min_n 5 -max_n 10 -type random\n./gen -min_n 5 -max_n 10 -type random\n\n# Additional medium n values\n./gen -min_n 500 -max_n 10000 -type random\n./gen -min_n 500 -max_n 10000 -type random\n\n# Additional large n values\n./gen -min_n 50000 -max_n 100000 -type random\n./gen -min_n 50000 -max_n 100000 -type random\n\n# Edge cases\n./gen -min_n 1 -max_n 1 -type min\n./gen -min_n 100000 -max_n 100000 -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:29.375401",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "57/D",
      "title": "D. Journey",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n, m (2 ≤ n, m ≤ 1000) which represent the sizes of the universe. The next n lines containing m symbols each describe the universe without dynamic particles — the j-th symbol of the i-th line equals to 'X' if the cell is occupied by a static particle, and to '.' if it is empty. It is guaranteed that the described universe satisfies the properties described above, that is no two static particles can be in one column or in one row, besides, they can't be positioned in the diagonally adjacent cells.",
      "output_spec": "OutputYou have to print on a single line a single number which is the average life span of a particle with an accuracy of at least 6 decimal places.The answer will be accepted if it is within 10 - 6 of absolute or relative error from the correct answer.",
      "sample_tests": "ExamplesInputCopy2 2...XOutputCopy0.888888888889InputCopy3 3....X....OutputCopy2.000000000000",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n, m (2 ≤ n, m ≤ 1000) which represent the sizes of the universe. The next n lines containing m symbols each describe the universe without dynamic particles — the j-th symbol of the i-th line equals to 'X' if the cell is occupied by a static particle, and to '.' if it is empty. It is guaranteed that the described universe satisfies the properties described above, that is no two static particles can be in one column or in one row, besides, they can't be positioned in the diagonally adjacent cells.\n\nOutputYou have to print on a single line a single number which is the average life span of a particle with an accuracy of at least 6 decimal places.The answer will be accepted if it is within 10 - 6 of absolute or relative error from the correct answer.\n\nInputCopy2 2...XOutputCopy0.888888888889InputCopy3 3....X....OutputCopy2.000000000000\n\nInputCopy2 2...X\n\nOutputCopy0.888888888889\n\nInputCopy3 3....X....\n\nOutputCopy2.000000000000",
      "solutions": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces",
          "content": "Good evening!Congratulation to all on the day of student, calm sessions, easy exams and a lot of new knowledge! I also want to congratulate those girls (women) whose name is Tatiana on their Angel Day.I am glad to invite you to participate in Codeforces Beta Round 53. Today's round was prepared Michael Mirzayanov, Nevidomy Vitaliy, Artem Rakhov and Maria Belov, problems author is nevidomy.Contest is over.Congratulations to the winner: tourist. After the round he becomes first \"General\" of Codeforces!!! Link to results: http://codeforces.com/contest/57/standingsAnalysisNevidomy Vitaliy and Codeforces team.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1165",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 57 和字母"
          },
          "content_length": 612
        },
        {
          "title": "Codeforces Beta Round #53 [Analysis] - Codeforces",
          "content": "Problem А.Since the restrictions were not so big you can offer many different solutions. For example, you can construct a graph with N * 4 vertices and use bfs. But there was a faster solution with complexity O(1): enumerate the integer points lying on the square, for example, as is shown below:Then finding the number of a point by its coordinates isn’t difficult. For example if a point has coordinate y == n -> then its position is n + x (if the numeration, is as shown, i.e. starts with zero). It turns out that we have transformed the square into a line with a small complication: cells N * 4 - 1 and 0 are adjacent, so we have not a line but a circle, where for the base points from 0 to 4 * N-1 the distance between the adjacent two points is 1. It is easy to take the difference of indices of the points and find the distance when moving clockwise and counterclockwise: (a-b +4 * n)% (4 * n) and (b - a + 4 * n)% (4 * n), the shortest distance will be the answer.Problem BUnder the restrictions on the number of requests, you cannot iteratively add staircase. But the problem is simplified by the fact that the number of cells in which it was necessary to know the number of stones was no more than 100. That’s why you can check for each \"interesting\" cell all the queries and calculate how much each of them adds stones, so the complexity is: O (K * M), which fits within the given 2 seconds well. A faster solution with complexity O(N + M + K) is as follows: we will keep in mind two variables: a – how many items should be added now to the cell, v - how much should change a next step. So problem is to update the value of a and v so that a equaled to the number of stones in the cell after all the operations, and v – to how much a increases during the transition to the next cell. Then the problem will be reduced to that you need to properly update a and v, which is not very difficult to do, for example if there is a request (x, y, z) – then in the cell x you need to add x to a and add 1 to v, since with each next cell the number of stones for some staircase will increase by 1. Similarly, after the cell y is passed you need to subtract 1 from v and pick up from “a” the current number of stones subquery. If you save all such pairs of queries in a single array and it's possible to calculate everything in one cycle.Problem CFirst, let's count how many there are arrays in which each successive element starting from the second one is no less than the previous one. To do this quickly, let’s take a piece of squared with height of one square and the length of N*2 - 1 square, then select N-1 squares and put crosses in them - let it encode some array, let the number of blank cells from the beginning of the array before the first cross be equal to the number of ones in the array, the number of blank cells from the first cross to the second – to the number of 2 in the array, and so on. It is easy to see that the number of empty cells will be equal to N * 2-1 - (N-1) = N. It turns out that each paper encodes an array which suits us, and moreover all the possible arrays can be encoded using such paper. There is exactly C (N * 2-1, N) different pieces of paper (the binomial coefficient of N * 2-1 to N). This number can be calculated by formula with factorials, the only difficulty is division. Since the module was prime - it was possible to calculate the inverse number in the field for the module and replace division by multiplication. So we get the number of non-decreasing sequences, respectively have the same number of non-increasing, we just need to take away those who were represented in both array sets, but they are just arrays with a similar number like {1,1,1,...,1} or {4,4,...,4,4} just subtract n.Problem DLet's see, if there is no occupied cells, then it is not difficult to calculate the answer - the answer is a sum of Manhattan distances, taking into account the fact that the Manhattan distance can be divided: first we can calculate the distance of one coordinate and then of another one and then just to sum up, so the answer is not difficult to find. What do we have when there are occupied cells? If the cell from which we seek the distance does not lie on the same horizontal or vertical with occupied cells – then it absolutely does not affect the difficulty of accessing the rest of the cells:This happens due to the fact that in each cell from the previous distance front (the distance to the set of cells with maximum distance from the start cell, the fronts form a diamond as you can see in the picture or from the Manhattan distance formula) there are two ways how to get to the cell, we take into account the rule that no two cells can be adjacent (either diagonally or vertically or horizontally), it turns out that such a cell does not interfere with us. But a close look at the picture brings to mind the obvious: it is the cell which is located on the same vertical / horizontal that has only one neighbor from the previous front, let’s see what happens in such case:All the cells after occupied one starts \"to lag\" at 2 in distance, but more importantly, that changed the front! Now (with the upper side of the front) are 2 cells for which the transition from the previous front is unique, and as a consequence there are two cells meeting of which will produce a new segment of a late cells, and the angle of the front will change again. Since we are only interested in one side of its expansion (on the other hand there can not be occupied cells by the condition) so we can assume that it was expand from the start cell:It turns out that you can count how many cells will be \"delayed\", especially considering that the lag always equals to two. For each direction, you can choose each occupied cell and check in the left and right directions for adjacent cells series, and add delay for interval of free cell before occupied cell (in the current direction). It is possible to calculate such delays with complexity: square of the number of occupied cells (it is not greater than min(N, M)). The rest is details. You need to compute all Manhattan distances, taking into account the existence of occupied cells. To do this, first calculate the sum of distances for an empty field, then for each occupied cell calculate the distance to all the others - subtract it twice, as the extra distance is subtracted for the first time when we got out of this cell and for the second time when takes away from all other cells to the given one. But in this case we will take away twice the distance between two occupied cells - so we’ll have to add them (the complexity is also a square). A total complexity of solution is O (K ^ 2) where K is the number of occupied cells.Problem EThe task turned out to be very difficult as it was planned. First remove all the deleted cells - let's see how changes the number of accessible cells with the increase of the new moves. First, the changes do not appear stable, but at some point we see a figure which won’t to change the form anymore and will only expand, it is obvious that the figure is two-dimensional, therefore the growth of its “area” is a quadratic function, in fact, a simple check shows that with each new turn the number of cells increases by the number of new cells opened with previous turn + 28, so after a certain point, you can simply take the sum of an arithmetic progression. The case with the deleted cells is similar. In general, there are several possible options - either occupied cells block further penetration of the horse or not, in the first case bfs is simply enough to find solutions, in the second one the story is the same: over time, when the figure \"becomes balanced\", the number of new opened cells satisfies the same rule \"prev +28\" . Moreover, because of restrictions of the coordinates of the deleted cells (-10 <= x, y <= 10) this happens fairly quickly. So, use usual bfs to balance figures, and after this use the sum of the arithmetic progression.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7988
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 1",
          "code": "47 24\n........................\n........................\n........................\n........................\n........................\n........................\nX.......................\n........................\n....X...................\n..........X......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 2",
          "code": "23.6657545509435892",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 3",
          "code": "23.670250896057",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 4",
          "code": "wrong answer 1st numbers differ - expected: '23.6702509', found: '23.6657546', error = '0.0001900'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 5",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    long long int *v;        cin >> n >> m >> k;    v = (long long int*)malloc(sizeof(long long int)*n);           memset(v,0,sizeof(v));    for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }   //      for(int i=0;i<n;i++){//          cout << v[i] << endl;//      }//      cout << endl << endl;    }//  for(int i=0;i<n;i++){//      cout << v[i] << endl;//  }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 6",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>#include <vector>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    cin >> n >> m >> k;    vector<long long int> v;    for(int i=0;i<n;i++){        v.push_back(0);    }        for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }       }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}...this got accepted....I concluded that memset was giving garbage..I dont knw why..!!....",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 7",
          "code": "long long int *v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 8",
          "code": "sizeof(v) is equal to size of pointer to long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 9",
          "code": "you need write memset(v,0,sizeof(v[0]) * n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 10",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 11",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    vector<int> xs_row_positions;  // store the row indices of 'X's\n    vector<int> xs_col_positions;  // store the column indices of 'X's\n    vector<pair<int, int>> xs_positions;  // positions of 'X's\n\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Line %d length is %d, but expected %d\", i+1, int(grid[i].size()), m);\n\n        for (int j = 0; j < m; ++j) {\n            char ch = grid[i][j];\n            ensuref(ch == '.' || ch == 'X', \"Invalid character '%c' at line %d column %d\", ch, i+1, j+1);\n            if (ch == 'X') {\n                xs_row_positions.push_back(i);\n                xs_col_positions.push_back(j);\n                xs_positions.emplace_back(i, j);\n            }\n        }\n    }\n\n    // Check no two 'X's are in the same row\n    {\n        set<int> seen_rows;\n        for (int r : xs_row_positions) {\n            ensuref(seen_rows.count(r) == 0, \"Two 'X's found in the same row %d\", r+1);\n            seen_rows.insert(r);\n        }\n    }\n\n    // Check no two 'X's are in the same column\n    {\n        set<int> seen_cols;\n        for (int c : xs_col_positions) {\n            ensuref(seen_cols.count(c) == 0, \"Two 'X's found in the same column %d\", c+1);\n            seen_cols.insert(c);\n        }\n    }\n\n    // Check no two 'X's are in diagonally adjacent cells\n    int num_xs = xs_positions.size();\n    for (int i = 0; i < num_xs; ++i) {\n        int x1 = xs_positions[i].first;\n        int y1 = xs_positions[i].second;\n        for (int j = i + 1; j < num_xs; ++j) {\n            int x2 = xs_positions[j].first;\n            int y2 = xs_positions[j].second;\n            if (abs(x1 - x2) == 1 && abs(y1 - y2) == 1) {\n                ensuref(false, \"Two 'X's found in diagonally adjacent cells at (%d,%d) and (%d,%d)\", x1+1, y1+1, x2+1, y2+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    vector<int> xs_row_positions;  // store the row indices of 'X's\n    vector<int> xs_col_positions;  // store the column indices of 'X's\n    vector<pair<int, int>> xs_positions;  // positions of 'X's\n\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Line %d length is %d, but expected %d\", i+1, int(grid[i].size()), m);\n\n        for (int j = 0; j < m; ++j) {\n            char ch = grid[i][j];\n            ensuref(ch == '.' || ch == 'X', \"Invalid character '%c' at line %d column %d\", ch, i+1, j+1);\n            if (ch == 'X') {\n                xs_row_positions.push_back(i);\n                xs_col_positions.push_back(j);\n                xs_positions.emplace_back(i, j);\n            }\n        }\n    }\n\n    // Check no two 'X's are in the same row\n    {\n        set<int> seen_rows;\n        for (int r : xs_row_positions) {\n            ensuref(seen_rows.count(r) == 0, \"Two 'X's found in the same row %d\", r+1);\n            seen_rows.insert(r);\n        }\n    }\n\n    // Check no two 'X's are in the same column\n    {\n        set<int> seen_cols;\n        for (int c : xs_col_positions) {\n            ensuref(seen_cols.count(c) == 0, \"Two 'X's found in the same column %d\", c+1);\n            seen_cols.insert(c);\n        }\n    }\n\n    // Check no two 'X's are in diagonally adjacent cells\n    int num_xs = xs_positions.size();\n    for (int i = 0; i < num_xs; ++i) {\n        int x1 = xs_positions[i].first;\n        int y1 = xs_positions[i].second;\n        for (int j = i + 1; j < num_xs; ++j) {\n            int x2 = xs_positions[j].first;\n            int y2 = xs_positions[j].second;\n            if (abs(x1 - x2) == 1 && abs(y1 - y2) == 1) {\n                ensuref(false, \"Two 'X's found in diagonally adjacent cells at (%d,%d) and (%d,%d)\", x1+1, y1+1, x2+1, y2+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    vector<int> xs_row_positions;  // store the row indices of 'X's\n    vector<int> xs_col_positions;  // store the column indices of 'X's\n    vector<pair<int, int>> xs_positions;  // positions of 'X's\n\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Line %d length is %d, but expected %d\", i+1, int(grid[i].size()), m);\n\n        for (int j = 0; j < m; ++j) {\n            char ch = grid[i][j];\n            ensuref(ch == '.' || ch == 'X', \"Invalid character '%c' at line %d column %d\", ch, i+1, j+1);\n            if (ch == 'X') {\n                xs_row_positions.push_back(i);\n                xs_col_positions.push_back(j);\n                xs_positions.emplace_back(i, j);\n            }\n        }\n    }\n\n    // Check no two 'X's are in the same row\n    {\n        set<int> seen_rows;\n        for (int r : xs_row_positions) {\n            ensuref(seen_rows.count(r) == 0, \"Two 'X's found in the same row %d\", r+1);\n            seen_rows.insert(r);\n        }\n    }\n\n    // Check no two 'X's are in the same column\n    {\n        set<int> seen_cols;\n        for (int c : xs_col_positions) {\n            ensuref(seen_cols.count(c) == 0, \"Two 'X's found in the same column %d\", c+1);\n            seen_cols.insert(c);\n        }\n    }\n\n    // Check no two 'X's are in diagonally adjacent cells\n    int num_xs = xs_positions.size();\n    for (int i = 0; i < num_xs; ++i) {\n        int x1 = xs_positions[i].first;\n        int y1 = xs_positions[i].second;\n        for (int j = i + 1; j < num_xs; ++j) {\n            int x2 = xs_positions[j].first;\n            int y2 = xs_positions[j].second;\n            if (abs(x1 - x2) == 1 && abs(y1 - y2) == 1) {\n                ensuref(false, \"Two 'X's found in diagonally adjacent cells at (%d,%d) and (%d,%d)\", x1+1, y1+1, x2+1, y2+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate positions of static particles without violating constraints.\nvector<pair<int,int>> generate_positions(int n, int m, int max_particles = -1) {\n    vector<pair<int,int>> best_positions;\n    for (int parity = 0; parity <=1; ++parity) {\n        vector<pair<int,int>> positions;\n        set<int> used_rows;\n        set<int> used_cols;\n\n        vector<int> rows(n);\n        vector<int> cols(m);\n        iota(rows.begin(), rows.end(), 0);\n        iota(cols.begin(), cols.end(), 0);\n\n        shuffle(rows.begin(), rows.end());\n        shuffle(cols.begin(), cols.end());\n\n        int limit = min(n, m);\n        if (max_particles != -1) {\n            limit = min(limit, max_particles);\n        }\n\n        for (int i = 0; i < limit; ++i) {\n            int r = rows[i];\n            int c = cols[i];\n\n            if ((r + c) % 2 != parity) continue;\n\n            bool ok = true;\n            for (auto& p : positions) {\n                if (abs(p.first - r) == 1 && abs(p.second - c) == 1) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if (ok) {\n                positions.push_back({r, c});\n                used_rows.insert(r);\n                used_cols.insert(c);\n            }\n        }\n        if (positions.size() > best_positions.size()) {\n            best_positions = positions;\n        }\n    }\n    return best_positions;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // No static particles.\n        // Grid is already initialized with '.'\n    } else if (type == \"full\") {\n        // Place as many static particles as possible.\n        auto positions = generate_positions(n, m);\n\n        for (auto& p : positions) {\n            int r = p.first;\n            int c = p.second;\n            grid[r][c] = 'X';\n        }\n    } else if (type == \"diagonal\") {\n        // Place static particles along the main diagonal.\n        for (int i = 0; i < min(n, m); i += 2) {\n            grid[i][i] = 'X';\n        }\n    } else if (type == \"border\") {\n        // Place static particles along the borders.\n        set<int> used_rows;\n        set<int> used_cols;\n\n        for (int i = 0; i < n; i += 2) {\n            grid[i][0] = 'X';\n            used_rows.insert(i);\n            used_cols.insert(0);\n        }\n        for (int j = 2; j < m; j += 2) {\n            if (used_rows.count(0) == 0) {\n                grid[0][j] = 'X';\n                used_rows.insert(0);\n                used_cols.insert(j);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random number of static particles.\n        int max_particles = generate_positions(n, m).size();\n        int num_particles = rnd.next(0, max_particles);\n\n        auto positions = generate_positions(n, m, num_particles);\n\n        for (auto& p : positions) {\n            int r = p.first;\n            int c = p.second;\n            grid[r][c] = 'X';\n        }\n    } else {\n        // Unknown type.\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m.\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid.\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate positions of static particles without violating constraints.\nvector<pair<int,int>> generate_positions(int n, int m, int max_particles = -1) {\n    vector<pair<int,int>> best_positions;\n    for (int parity = 0; parity <=1; ++parity) {\n        vector<pair<int,int>> positions;\n        set<int> used_rows;\n        set<int> used_cols;\n\n        vector<int> rows(n);\n        vector<int> cols(m);\n        iota(rows.begin(), rows.end(), 0);\n        iota(cols.begin(), cols.end(), 0);\n\n        shuffle(rows.begin(), rows.end());\n        shuffle(cols.begin(), cols.end());\n\n        int limit = min(n, m);\n        if (max_particles != -1) {\n            limit = min(limit, max_particles);\n        }\n\n        for (int i = 0; i < limit; ++i) {\n            int r = rows[i];\n            int c = cols[i];\n\n            if ((r + c) % 2 != parity) continue;\n\n            bool ok = true;\n            for (auto& p : positions) {\n                if (abs(p.first - r) == 1 && abs(p.second - c) == 1) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if (ok) {\n                positions.push_back({r, c});\n                used_rows.insert(r);\n                used_cols.insert(c);\n            }\n        }\n        if (positions.size() > best_positions.size()) {\n            best_positions = positions;\n        }\n    }\n    return best_positions;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // No static particles.\n        // Grid is already initialized with '.'\n    } else if (type == \"full\") {\n        // Place as many static particles as possible.\n        auto positions = generate_positions(n, m);\n\n        for (auto& p : positions) {\n            int r = p.first;\n            int c = p.second;\n            grid[r][c] = 'X';\n        }\n    } else if (type == \"diagonal\") {\n        // Place static particles along the main diagonal.\n        for (int i = 0; i < min(n, m); i += 2) {\n            grid[i][i] = 'X';\n        }\n    } else if (type == \"border\") {\n        // Place static particles along the borders.\n        set<int> used_rows;\n        set<int> used_cols;\n\n        for (int i = 0; i < n; i += 2) {\n            grid[i][0] = 'X';\n            used_rows.insert(i);\n            used_cols.insert(0);\n        }\n        for (int j = 2; j < m; j += 2) {\n            if (used_rows.count(0) == 0) {\n                grid[0][j] = 'X';\n                used_rows.insert(0);\n                used_cols.insert(j);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random number of static particles.\n        int max_particles = generate_positions(n, m).size();\n        int num_particles = rnd.next(0, max_particles);\n\n        auto positions = generate_positions(n, m, num_particles);\n\n        for (auto& p : positions) {\n            int r = p.first;\n            int c = p.second;\n            grid[r][c] = 'X';\n        }\n    } else {\n        // Unknown type.\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m.\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid.\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type full\n./gen -n 2 -m 2 -type random\n\n./gen -n 2 -m 3 -type empty\n./gen -n 2 -m 3 -type full\n./gen -n 2 -m 3 -type random\n\n./gen -n 3 -m 2 -type empty\n./gen -n 3 -m 2 -type full\n./gen -n 3 -m 2 -type random\n\n./gen -n 10 -m 10 -type empty\n./gen -n 10 -m 10 -type full\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type diagonal\n./gen -n 10 -m 10 -type border\n\n./gen -n 1000 -m 1000 -type empty\n./gen -n 1000 -m 1000 -type full\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type diagonal\n./gen -n 1000 -m 1000 -type border\n\n./gen -n 1000 -m 2 -type empty\n./gen -n 1000 -m 2 -type full\n./gen -n 1000 -m 2 -type random\n\n./gen -n 2 -m 1000 -type empty\n./gen -n 2 -m 1000 -type full\n./gen -n 2 -m 1000 -type random\n\n./gen -n 500 -m 500 -type random\n./gen -n 999 -m 1000 -type random\n./gen -n 1000 -m 999 -type random\n\n./gen -n 123 -m 456 -type random\n./gen -n 789 -m 321 -type random\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 2 -m 2 -type diagonal\n./gen -n 3 -m 3 -type diagonal\n./gen -n 4 -m 4 -type diagonal\n./gen -n 5 -m 5 -type diagonal\n\n./gen -n 50 -m 100 -type border\n./gen -n 100 -m 50 -type border\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:31.338544",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "57/E",
      "title": "E. Chess",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers k and n (0 ≤ k ≤ 1018, 0 ≤ n ≤ 440) which are correspondingly the maximal number of moves a knight can make and the number of deleted cells. Then follow n lines, each giving the coordinates of a deleted square in the form (xi, yi) (|xi| ≤ 10, |yi| ≤ 10). All the numbers are integer, the deleted squares are different and it is guaranteed that the square (0, 0) is not deleted.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).",
      "output_spec": "OutputYou must print the answer on a single line. As it can be rather long, you should print it modulo 1000000007.",
      "sample_tests": "ExamplesInputCopy1 0OutputCopy9InputCopy2 7-1 21 22 12 -11 -2-1 -2-2 -1OutputCopy9",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers k and n (0 ≤ k ≤ 1018, 0 ≤ n ≤ 440) which are correspondingly the maximal number of moves a knight can make and the number of deleted cells. Then follow n lines, each giving the coordinates of a deleted square in the form (xi, yi) (|xi| ≤ 10, |yi| ≤ 10). All the numbers are integer, the deleted squares are different and it is guaranteed that the square (0, 0) is not deleted.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).\n\nOutputYou must print the answer on a single line. As it can be rather long, you should print it modulo 1000000007.\n\nInputCopy1 0OutputCopy9InputCopy2 7-1 21 22 12 -11 -2-1 -2-2 -1OutputCopy9\n\nInputCopy1 0\n\nOutputCopy9\n\nInputCopy2 7-1 21 22 12 -11 -2-1 -2-2 -1\n\nOutputCopy9",
      "solutions": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces",
          "content": "Good evening!Congratulation to all on the day of student, calm sessions, easy exams and a lot of new knowledge! I also want to congratulate those girls (women) whose name is Tatiana on their Angel Day.I am glad to invite you to participate in Codeforces Beta Round 53. Today's round was prepared Michael Mirzayanov, Nevidomy Vitaliy, Artem Rakhov and Maria Belov, problems author is nevidomy.Contest is over.Congratulations to the winner: tourist. After the round he becomes first \"General\" of Codeforces!!! Link to results: http://codeforces.com/contest/57/standingsAnalysisNevidomy Vitaliy and Codeforces team.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1165",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 57 和字母"
          },
          "content_length": 612
        },
        {
          "title": "Codeforces Beta Round #53 [Analysis] - Codeforces",
          "content": "Problem А.Since the restrictions were not so big you can offer many different solutions. For example, you can construct a graph with N * 4 vertices and use bfs. But there was a faster solution with complexity O(1): enumerate the integer points lying on the square, for example, as is shown below:Then finding the number of a point by its coordinates isn’t difficult. For example if a point has coordinate y == n -> then its position is n + x (if the numeration, is as shown, i.e. starts with zero). It turns out that we have transformed the square into a line with a small complication: cells N * 4 - 1 and 0 are adjacent, so we have not a line but a circle, where for the base points from 0 to 4 * N-1 the distance between the adjacent two points is 1. It is easy to take the difference of indices of the points and find the distance when moving clockwise and counterclockwise: (a-b +4 * n)% (4 * n) and (b - a + 4 * n)% (4 * n), the shortest distance will be the answer.Problem BUnder the restrictions on the number of requests, you cannot iteratively add staircase. But the problem is simplified by the fact that the number of cells in which it was necessary to know the number of stones was no more than 100. That’s why you can check for each \"interesting\" cell all the queries and calculate how much each of them adds stones, so the complexity is: O (K * M), which fits within the given 2 seconds well. A faster solution with complexity O(N + M + K) is as follows: we will keep in mind two variables: a – how many items should be added now to the cell, v - how much should change a next step. So problem is to update the value of a and v so that a equaled to the number of stones in the cell after all the operations, and v – to how much a increases during the transition to the next cell. Then the problem will be reduced to that you need to properly update a and v, which is not very difficult to do, for example if there is a request (x, y, z) – then in the cell x you need to add x to a and add 1 to v, since with each next cell the number of stones for some staircase will increase by 1. Similarly, after the cell y is passed you need to subtract 1 from v and pick up from “a” the current number of stones subquery. If you save all such pairs of queries in a single array and it's possible to calculate everything in one cycle.Problem CFirst, let's count how many there are arrays in which each successive element starting from the second one is no less than the previous one. To do this quickly, let’s take a piece of squared with height of one square and the length of N*2 - 1 square, then select N-1 squares and put crosses in them - let it encode some array, let the number of blank cells from the beginning of the array before the first cross be equal to the number of ones in the array, the number of blank cells from the first cross to the second – to the number of 2 in the array, and so on. It is easy to see that the number of empty cells will be equal to N * 2-1 - (N-1) = N. It turns out that each paper encodes an array which suits us, and moreover all the possible arrays can be encoded using such paper. There is exactly C (N * 2-1, N) different pieces of paper (the binomial coefficient of N * 2-1 to N). This number can be calculated by formula with factorials, the only difficulty is division. Since the module was prime - it was possible to calculate the inverse number in the field for the module and replace division by multiplication. So we get the number of non-decreasing sequences, respectively have the same number of non-increasing, we just need to take away those who were represented in both array sets, but they are just arrays with a similar number like {1,1,1,...,1} or {4,4,...,4,4} just subtract n.Problem DLet's see, if there is no occupied cells, then it is not difficult to calculate the answer - the answer is a sum of Manhattan distances, taking into account the fact that the Manhattan distance can be divided: first we can calculate the distance of one coordinate and then of another one and then just to sum up, so the answer is not difficult to find. What do we have when there are occupied cells? If the cell from which we seek the distance does not lie on the same horizontal or vertical with occupied cells – then it absolutely does not affect the difficulty of accessing the rest of the cells:This happens due to the fact that in each cell from the previous distance front (the distance to the set of cells with maximum distance from the start cell, the fronts form a diamond as you can see in the picture or from the Manhattan distance formula) there are two ways how to get to the cell, we take into account the rule that no two cells can be adjacent (either diagonally or vertically or horizontally), it turns out that such a cell does not interfere with us. But a close look at the picture brings to mind the obvious: it is the cell which is located on the same vertical / horizontal that has only one neighbor from the previous front, let’s see what happens in such case:All the cells after occupied one starts \"to lag\" at 2 in distance, but more importantly, that changed the front! Now (with the upper side of the front) are 2 cells for which the transition from the previous front is unique, and as a consequence there are two cells meeting of which will produce a new segment of a late cells, and the angle of the front will change again. Since we are only interested in one side of its expansion (on the other hand there can not be occupied cells by the condition) so we can assume that it was expand from the start cell:It turns out that you can count how many cells will be \"delayed\", especially considering that the lag always equals to two. For each direction, you can choose each occupied cell and check in the left and right directions for adjacent cells series, and add delay for interval of free cell before occupied cell (in the current direction). It is possible to calculate such delays with complexity: square of the number of occupied cells (it is not greater than min(N, M)). The rest is details. You need to compute all Manhattan distances, taking into account the existence of occupied cells. To do this, first calculate the sum of distances for an empty field, then for each occupied cell calculate the distance to all the others - subtract it twice, as the extra distance is subtracted for the first time when we got out of this cell and for the second time when takes away from all other cells to the given one. But in this case we will take away twice the distance between two occupied cells - so we’ll have to add them (the complexity is also a square). A total complexity of solution is O (K ^ 2) where K is the number of occupied cells.Problem EThe task turned out to be very difficult as it was planned. First remove all the deleted cells - let's see how changes the number of accessible cells with the increase of the new moves. First, the changes do not appear stable, but at some point we see a figure which won’t to change the form anymore and will only expand, it is obvious that the figure is two-dimensional, therefore the growth of its “area” is a quadratic function, in fact, a simple check shows that with each new turn the number of cells increases by the number of new cells opened with previous turn + 28, so after a certain point, you can simply take the sum of an arithmetic progression. The case with the deleted cells is similar. In general, there are several possible options - either occupied cells block further penetration of the horse or not, in the first case bfs is simply enough to find solutions, in the second one the story is the same: over time, when the figure \"becomes balanced\", the number of new opened cells satisfies the same rule \"prev +28\" . Moreover, because of restrictions of the coordinates of the deleted cells (-10 <= x, y <= 10) this happens fairly quickly. So, use usual bfs to balance figures, and after this use the sum of the arithmetic progression.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7988
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 1",
          "code": "47 24\n........................\n........................\n........................\n........................\n........................\n........................\nX.......................\n........................\n....X...................\n..........X......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 2",
          "code": "23.6657545509435892",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 3",
          "code": "23.670250896057",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 4",
          "code": "wrong answer 1st numbers differ - expected: '23.6702509', found: '23.6657546', error = '0.0001900'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 5",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    long long int *v;        cin >> n >> m >> k;    v = (long long int*)malloc(sizeof(long long int)*n);           memset(v,0,sizeof(v));    for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }   //      for(int i=0;i<n;i++){//          cout << v[i] << endl;//      }//      cout << endl << endl;    }//  for(int i=0;i<n;i++){//      cout << v[i] << endl;//  }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 6",
          "code": "#include <iostream>#include <cstdlib>#include <string.h>#include <vector>using namespace std;int main(){    long long int n=0,m=0,k=0,soln=0;    cin >> n >> m >> k;    vector<long long int> v;    for(int i=0;i<n;i++){        v.push_back(0);    }        for(int i =0 ; i < m;i++){        long long int a=0,b=0,c=0;        cin >> a >> b >> c;                v[a-1]+=c;        long long int f=0;        for(int j=a;j<b;j++){            f++;            v[j]=v[j]+c+f;        }       }    for(int i=1;i<=k;i++){        long long int t;        cin >> t;        soln = soln+v[t-1];    }    cout << soln << endl;}...this got accepted....I concluded that memset was giving garbage..I dont knw why..!!....",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 7",
          "code": "long long int *v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 8",
          "code": "sizeof(v) is equal to size of pointer to long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 9",
          "code": "you need write memset(v,0,sizeof(v[0]) * n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 10",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #53 - Codeforces - Code 11",
          "code": "memset(v,0,sizeof(v));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1165",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 440, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> deletedSquares;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10, 10, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10, 10, \"yi\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"The square (0, 0) cannot be deleted\");\n\n        pair<int, int> pos = make_pair(xi, yi);\n\n        ensuref(deletedSquares.count(pos) == 0, \"Deleted squares should be unique\");\n\n        deletedSquares.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 440, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> deletedSquares;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10, 10, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10, 10, \"yi\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"The square (0, 0) cannot be deleted\");\n\n        pair<int, int> pos = make_pair(xi, yi);\n\n        ensuref(deletedSquares.count(pos) == 0, \"Deleted squares should be unique\");\n\n        deletedSquares.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 440, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> deletedSquares;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10, 10, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10, 10, \"yi\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"The square (0, 0) cannot be deleted\");\n\n        pair<int, int> pos = make_pair(xi, yi);\n\n        ensuref(deletedSquares.count(pos) == 0, \"Deleted squares should be unique\");\n\n        deletedSquares.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long k = opt<long long>(\"k\");\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that k and n are within the constraints\n    assert(0 <= k && k <= 1000000000000000000LL);\n    assert(0 <= n && n <= 440);\n\n    vector<pair<int, int>> deletions;\n\n    if (type == \"none\") {\n        // No deletions\n        n = 0;\n    } else if (type == \"random\") {\n        // Generate n unique random positions excluding (0,0)\n        vector<pair<int, int>> positions;\n        for (int x = -10; x <= 10; x++) {\n            for (int y = -10; y <= 10; y++) {\n                if (x == 0 && y == 0) continue;\n                positions.push_back({x, y});\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        if (n > (int)positions.size()) n = positions.size();\n        deletions.insert(deletions.end(), positions.begin(), positions.begin() + n);\n    } else if (type == \"adjacent\") {\n        // Delete all squares reachable in 1 knight move from (0,0)\n        int dx[] = {1, 2, 2, 1, -1, -2, -2, -1};\n        int dy[] = {2, 1, -1, -2, -2, -1, 1, 2};\n        for (int i = 0; i < 8; i++) {\n            int x = dx[i];\n            int y = dy[i];\n            if (x < -10 || x > 10 || y < -10 || y > 10) continue;\n            deletions.push_back({x, y});\n        }\n        n = deletions.size();\n    } else if (type == \"max_del\") {\n        // Delete all positions except (0,0)\n        for (int x = -10; x <= 10; x++) {\n            for (int y = -10; y <= 10; y++) {\n                if (x == 0 && y == 0) continue;\n                deletions.push_back({x, y});\n            }\n        }\n        n = deletions.size();\n    } else if (type == \"line\") {\n        // Delete a line of squares, x = 1 for y from -10 to 10\n        for (int y = -10; y <= 10; y++) {\n            if (1 == 0 && y == 0) continue;\n            deletions.push_back({1, y});\n        }\n        n = deletions.size();\n    } else if (type == \"block\") {\n        // Delete all squares reachable from (0,0) in one knight move to block the knight\n        if (k >= 1) {\n            int dx[] = {1, 2, 2, 1, -1, -2, -2, -1};\n            int dy[] = {2, 1, -1, -2, -2, -1, 1, 2};\n            for (int i = 0; i < 8; i++) {\n                int x = dx[i];\n                int y = dy[i];\n                if (x < -10 || x > 10 || y < -10 || y > 10) continue;\n                deletions.push_back({x, y});\n            }\n            n = deletions.size();\n        } else {\n            // Cannot block the knight if k = 0\n            n = 0;\n        }\n    } else {\n        // Default to random deletions if type is unrecognized\n        vector<pair<int, int>> positions;\n        for (int x = -10; x <= 10; x++) {\n            for (int y = -10; y <= 10; y++) {\n                if (x == 0 && y == 0) continue;\n                positions.push_back({x, y});\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        if (n > (int)positions.size()) n = positions.size();\n        deletions.insert(deletions.end(), positions.begin(), positions.begin() + n);\n    }\n\n    // Output the test case\n    cout << k << \" \" << n << endl;\n\n    for (int i = 0; i < n; i++) {\n        cout << deletions[i].first << \" \" << deletions[i].second << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long k = opt<long long>(\"k\");\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that k and n are within the constraints\n    assert(0 <= k && k <= 1000000000000000000LL);\n    assert(0 <= n && n <= 440);\n\n    vector<pair<int, int>> deletions;\n\n    if (type == \"none\") {\n        // No deletions\n        n = 0;\n    } else if (type == \"random\") {\n        // Generate n unique random positions excluding (0,0)\n        vector<pair<int, int>> positions;\n        for (int x = -10; x <= 10; x++) {\n            for (int y = -10; y <= 10; y++) {\n                if (x == 0 && y == 0) continue;\n                positions.push_back({x, y});\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        if (n > (int)positions.size()) n = positions.size();\n        deletions.insert(deletions.end(), positions.begin(), positions.begin() + n);\n    } else if (type == \"adjacent\") {\n        // Delete all squares reachable in 1 knight move from (0,0)\n        int dx[] = {1, 2, 2, 1, -1, -2, -2, -1};\n        int dy[] = {2, 1, -1, -2, -2, -1, 1, 2};\n        for (int i = 0; i < 8; i++) {\n            int x = dx[i];\n            int y = dy[i];\n            if (x < -10 || x > 10 || y < -10 || y > 10) continue;\n            deletions.push_back({x, y});\n        }\n        n = deletions.size();\n    } else if (type == \"max_del\") {\n        // Delete all positions except (0,0)\n        for (int x = -10; x <= 10; x++) {\n            for (int y = -10; y <= 10; y++) {\n                if (x == 0 && y == 0) continue;\n                deletions.push_back({x, y});\n            }\n        }\n        n = deletions.size();\n    } else if (type == \"line\") {\n        // Delete a line of squares, x = 1 for y from -10 to 10\n        for (int y = -10; y <= 10; y++) {\n            if (1 == 0 && y == 0) continue;\n            deletions.push_back({1, y});\n        }\n        n = deletions.size();\n    } else if (type == \"block\") {\n        // Delete all squares reachable from (0,0) in one knight move to block the knight\n        if (k >= 1) {\n            int dx[] = {1, 2, 2, 1, -1, -2, -2, -1};\n            int dy[] = {2, 1, -1, -2, -2, -1, 1, 2};\n            for (int i = 0; i < 8; i++) {\n                int x = dx[i];\n                int y = dy[i];\n                if (x < -10 || x > 10 || y < -10 || y > 10) continue;\n                deletions.push_back({x, y});\n            }\n            n = deletions.size();\n        } else {\n            // Cannot block the knight if k = 0\n            n = 0;\n        }\n    } else {\n        // Default to random deletions if type is unrecognized\n        vector<pair<int, int>> positions;\n        for (int x = -10; x <= 10; x++) {\n            for (int y = -10; y <= 10; y++) {\n                if (x == 0 && y == 0) continue;\n                positions.push_back({x, y});\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        if (n > (int)positions.size()) n = positions.size();\n        deletions.insert(deletions.end(), positions.begin(), positions.begin() + n);\n    }\n\n    // Output the test case\n    cout << k << \" \" << n << endl;\n\n    for (int i = 0; i < n; i++) {\n        cout << deletions[i].first << \" \" << deletions[i].second << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 0 -n 0 -type none\n./gen -k 1 -n 0 -type none\n./gen -k 1 -n 8 -type adjacent\n./gen -k 1 -n 8 -type random\n./gen -k 1 -n 0 -type block\n./gen -k 1 -n 0 -type line\n./gen -k 1 -n 440 -type max_del\n./gen -k 2 -n 0 -type none\n./gen -k 2 -n 8 -type adjacent\n./gen -k 2 -n 0 -type block\n./gen -k 2 -n 0 -type random\n./gen -k 5 -n 100 -type random\n./gen -k 10 -n 0 -type none\n./gen -k 10 -n 50 -type random\n./gen -k 10 -n 21 -type line\n./gen -k 10 -n 0 -type line\n./gen -k 100 -n 0 -type none\n./gen -k 100 -n 100 -type random\n./gen -k 100 -n 0 -type line\n./gen -k 1000 -n 0 -type none\n./gen -k 1000 -n 100 -type random\n./gen -k 10000 -n 0 -type none\n./gen -k 10000 -n 150 -type random\n./gen -k 1000000 -n 0 -type none\n./gen -k 1000000 -n 200 -type random\n./gen -k 1000000000000000000 -n 0 -type none\n./gen -k 1000000000000000000 -n 440 -type max_del\n./gen -k 1000000000000000000 -n 21 -type line\n./gen -k 1000000000000000000 -n 0 -type line\n./gen -k 1000000000000000000 -n 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:33.093492",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "570/A",
      "title": "A. Выборы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит два целых числа n, m (1 ≤ n, m ≤ 100) — количество кандидатов и городов соответственно.В последующих m строках записано по n целых неотрицательных чисел, j-е число в i-й строке aij (1 ≤ j ≤ n, 1 ≤ i ≤ m, 0 ≤ aij ≤ 109) обозначает количество голосов за кандидата номер j в городе номер i.Гарантируется что суммарное количество жителей во всех городах не превосходит 109.",
      "output_spec": "Выходные данныеВыведите единственное число — номер кандидата, победившего в выборах. Кандидаты нумеруются с единицы.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 31 2 32 3 11 2 1Выходные данныеСкопировать2Входные данныеСкопировать3 410 10 35 1 62 2 21 5 7Выходные данныеСкопировать1",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка входных данных содержит два целых числа n, m (1 ≤ n, m ≤ 100) — количество кандидатов и городов соответственно.В последующих m строках записано по n целых неотрицательных чисел, j-е число в i-й строке aij (1 ≤ j ≤ n, 1 ≤ i ≤ m, 0 ≤ aij ≤ 109) обозначает количество голосов за кандидата номер j в городе номер i.Гарантируется что суммарное количество жителей во всех городах не превосходит 109.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — номер кандидата, победившего в выборах. Кандидаты нумеруются с единицы.\n\nВыходные данные\n\nВходные данныеСкопировать3 31 2 32 3 11 2 1Выходные данныеСкопировать2Входные данныеСкопировать3 410 10 35 1 62 2 21 5 7Выходные данныеСкопировать1\n\nВходные данныеСкопировать3 31 2 32 3 11 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 410 10 35 1 62 2 21 5 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснение к первому тесту из условия. В первом туре город 1 проголосовал за кандидата 3, город 2 проголосовал за кандидата 2, город 3 проголосовал за кандидата 2. Победил кандидат 2, набрав 2 голоса.Пояснение ко второму тесту из условия. В первом туре в городе 1 за кандидатов 1 и 2 проголосовало одинаковое максимальное количество голосов, но кандидат 1 имеет меньший номер поэтому город отдал предпочтение кандидату 1. Город 2 проголосовал за кандидата 3. Город 3 проголосовал за 1, в связи с тем что все имеют одинаковое количество голосов и 1 имеет наименьший номер. Город 4 проголосовал за кандидата 3. За кандидатов 1 и 3 проголосовало равное количество городов. Победил кандидат 1, имеющий наименьший номер.",
      "solutions": [
        {
          "title": "Codeforces Round #316 (Div. 2) - Codeforces",
          "content": "Доброго всем времени суток!13 августа 2015 года в 19:30 MSK состоится очередной раунд Codeforces #316 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Это мой первый Codeforces раунд. Надеюсь, он вам понравится.Хотелось бы сказать большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено пять задач и два часа на их решение.UPD: Распределение баллов по задачам 500-1000-1500-2000-2500Желаю всем участникам удачи!UPD: Всем спасибо за участие!Поздравляем победителей!Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19753",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 734
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces",
          "content": "570А — Выборы РеализацияДля каждого города определим: за кого он голосует. Просуммируем для каждого кандидата и определим победителя.O(n * m)Решение570B — Простая игра Математика, разбор случаевПоймем, какие ходы интересные. Заметим, что Андрею нет смысла делать ход, при котором |a–m| > 1 так, как мы можем увеличить вероятность победы, если подвинем число a ближе к m. Таким образом, мы рассматриваем два варианта хода a = c–1 и a = c + 1. Вероятность победы в первом случае c / n, во втором (n–c + 1) / n. Выбираем наилучший вариант. Нужно помнить про случай n = 1.O(1)Решение570C — ЗаменыРазбор случаев, (возможно) структурыРассмотрим, как происходят замены. Если был отрезок из точек длины l, то мы потратим l–1 операцию и прекратим замены для этого отрезка. Если просуммировать длины всех отрезков и их количества, то ответ это суммарная длина минус количество отрезков. После изменения одного типа символа длина изменятся на 1. Количество отрезков можно поддерживать при помощи массива. Рассмотрим события слияния, деление, появление и удаление отрезков. Для слияния смотрим на правого и левого соседа. Если они являются точками, то произошло слияние и количество отрезков уменьшилось на 1. Остальные случаи аналогично можно разобрать. O(n + m)Решение570D — Деревянные запросыDFS, бинарный поискЗапишем вершины в порядке DFS от корня для вершин каждой глубины отдельно, храним время входа/выхода из вершины в DFS. Все вершины находящиеся в поддереве v, в такой записи представляют отрезок. Теперь мы умеем получать все вершины в v на высоте h, в виде отрезка, делая два бинарных поиска. Палиндром можно составить, если количество нечетных вхождений каждой буквы меньше 2. Эту функцию можно посчитать для каждого префикса в обходе на каждой глубине отдельно. Для экономии памяти можно воспользоваться битовым сжатием, поняв, что нас интересует только четность и функция – это xor. O(m * (logn + 26) + n) – времени O(n * 26) — памяти, существует оффлайн решение за O(m * 26 / 32 + n) и O(n * 26 / 8) памятиРешение570E — Свинка и палиндромыДПНас интересуют пути являющиеся палиндромами. Палиндром читается с начала и с конца одинаково. Воспользуемся этим. Считаем динамику от координат двух клеток, первой и последней в палиндроме. Из каждого состояние есть 4 перехода (комбинации: первая клетка вниз/вправо и вторая клетка вверх/влево). Нас интересуют переходы только по равным символам, по свойству палиндрома. Заметим, что нас интересуют пары клеток находящихся на одинаковом расстоянии от начала и конца соответственно. Если у первой клетки координаты (x1;y1), у последней (x2;y2), то x1 + y1 = n + m - x2 - y2.Чтоб сэкономить память воспользуемся идеей хранить 2 последних слоя. O(n3) – времени и O(n2) — памятиРешение",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19770",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 570 和字母"
          },
          "content_length": 2727
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #316 (Div. 2) - Codeforces - Code 1",
          "code": "Если таких значений несколько, выведите минимальное из них.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19753",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 1",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 2",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 3",
          "code": "else if (t == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 4",
          "code": "else if (t == 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 5",
          "code": "default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 6",
          "code": "default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 7",
          "code": "edges[v].forEach(v2 -> dfs(v2, lvl + 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 8",
          "code": "edges[v].forEach(v2 -> dfs(v2, lvl + 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 9",
          "code": "for (int v2 : edges[v]) {\n            dfs(v2, lvl + 1);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 10",
          "code": "for (int v2 : edges[v]) {\n            dfs(v2, lvl + 1);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 11",
          "code": "O(nlog(n) + 26m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    long long total_votes = 0;\n    for (int i = 0; i < m; i++) {\n        vector<int> votes = inf.readInts(n, 0, 1000000000, \"a_ij\");\n        inf.readEoln();\n        for (int j = 0; j < n; j++) {\n            total_votes += votes[j];\n        }\n    }\n    ensuref(total_votes <= 1000000000, \"Total number of votes must not exceed 1e9, but is %lld\", total_votes);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    long long total_votes = 0;\n    for (int i = 0; i < m; i++) {\n        vector<int> votes = inf.readInts(n, 0, 1000000000, \"a_ij\");\n        inf.readEoln();\n        for (int j = 0; j < n; j++) {\n            total_votes += votes[j];\n        }\n    }\n    ensuref(total_votes <= 1000000000, \"Total number of votes must not exceed 1e9, but is %lld\", total_votes);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    long long total_votes = 0;\n    for (int i = 0; i < m; i++) {\n        vector<int> votes = inf.readInts(n, 0, 1000000000, \"a_ij\");\n        inf.readEoln();\n        for (int j = 0; j < n; j++) {\n            total_votes += votes[j];\n        }\n    }\n    ensuref(total_votes <= 1000000000, \"Total number of votes must not exceed 1e9, but is %lld\", total_votes);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long total_votes_limit = 1000000000LL;\n\n    // Maximum votes per candidate per city to ensure total votes do not exceed limit\n    long long max_votes_per_candidate_city = total_votes_limit / (n * m);\n    max_votes_per_candidate_city = min(max_votes_per_candidate_city, 1000000000LL);\n\n    // Container for votes\n    vector<vector<long long>> votes(m, vector<long long>(n, 0));\n\n    if (type == \"random\") {\n        // Generate random votes between 0 and max_votes_per_candidate_city\n        long long total_votes = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                long long v = rnd.next(0LL, max_votes_per_candidate_city);\n                votes[i][j] = v;\n                total_votes += v;\n            }\n        }\n        // Scale down votes if total exceeds limit\n        if (total_votes > total_votes_limit) {\n            double scale = (double)total_votes_limit / total_votes;\n            total_votes = 0;\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = (long long)(votes[i][j] * scale);\n                    total_votes += votes[i][j];\n                }\n            }\n        }\n    } else if (type == \"tie_in_city\") {\n        // Create ties in some cities\n        for (int i = 0; i < m; ++i) {\n            bool tie = rnd.next(0, 1); // 50% chance of tie\n            if (tie) {\n                // Select two candidates to tie\n                int cand1 = rnd.next(0, n - 1);\n                int cand2 = rnd.next(0, n - 1);\n                while (cand2 == cand1) cand2 = rnd.next(0, n - 1);\n                long long v = rnd.next(1LL, max_votes_per_candidate_city);\n                votes[i][cand1] = v;\n                votes[i][cand2] = v;\n                // Others get random votes less than v\n                for (int j = 0; j < n; ++j) {\n                    if (j != cand1 && j != cand2) {\n                        votes[i][j] = rnd.next(0LL, v - 1);\n                    }\n                }\n            } else {\n                // Random votes\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = rnd.next(0LL, max_votes_per_candidate_city);\n                }\n            }\n        }\n    } else if (type == \"tie_overall\") {\n        // Two candidates win the same number of cities\n        int cand1 = rnd.next(0, n - 1);\n        int cand2 = rnd.next(0, n - 1);\n        while (cand2 == cand1) cand2 = rnd.next(0, n - 1);\n        vector<int> order(m);\n        for (int i = 0; i < m; ++i) order[i] = i;\n        shuffle(order.begin(), order.end());\n        int half_m = m / 2;\n        for (int k = 0; k < m; ++k) {\n            int i = order[k];\n            if (k < half_m) {\n                // Candidate 1 wins\n                votes[i][cand1] = rnd.next(max_votes_per_candidate_city / 2, max_votes_per_candidate_city);\n                for (int j = 0; j < n; ++j) {\n                    if (j != cand1) {\n                        votes[i][j] = rnd.next(0LL, votes[i][cand1] - 1);\n                    }\n                }\n            } else {\n                // Candidate 2 wins\n                votes[i][cand2] = rnd.next(max_votes_per_candidate_city / 2, max_votes_per_candidate_city);\n                for (int j = 0; j < n; ++j) {\n                    if (j != cand2) {\n                        votes[i][j] = rnd.next(0LL, votes[i][cand2] - 1);\n                    }\n                }\n            }\n        }\n    } else if (type == \"zero_votes\") {\n        // Some cities have zero votes\n        for (int i = 0; i < m; ++i) {\n            bool zero_city = rnd.next(0, 1); // 50% chance of zero votes\n            if (zero_city) {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = 0;\n                }\n            } else {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = rnd.next(0LL, max_votes_per_candidate_city);\n                }\n            }\n        }\n    } else if (type == \"max_votes\") {\n        // Votes are near maximum\n        long long per_vote = max_votes_per_candidate_city;\n        for (int i = 0; i < m; ++i) {\n            int winner = rnd.next(0, n - 1);\n            votes[i][winner] = per_vote;\n            for (int j = 0; j < n; ++j) {\n                if (j != winner) {\n                    votes[i][j] = rnd.next(0LL, per_vote - 1);\n                }\n            }\n        }\n    } else if (type == \"min_votes\") {\n        // Votes are minimal\n        for (int i = 0; i < m; ++i) {\n            int winner = rnd.next(0, n - 1);\n            votes[i][winner] = 1;\n            for (int j = 0; j < n; ++j) {\n                if (j != winner) {\n                    votes[i][j] = 0;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        long long total_votes = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                long long v = rnd.next(0LL, max_votes_per_candidate_city);\n                votes[i][j] = v;\n                total_votes += v;\n            }\n        }\n        if (total_votes > total_votes_limit) {\n            double scale = (double)total_votes_limit / total_votes;\n            total_votes = 0;\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = (long long)(votes[i][j] * scale);\n                    total_votes += votes[i][j];\n                }\n            }\n        }\n    }\n\n    // Compute total votes and ensure it doesn't exceed the limit\n    long long total_votes = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            total_votes += votes[i][j];\n        }\n    }\n    if (total_votes > total_votes_limit) {\n        double scale = (double)total_votes_limit / total_votes;\n        total_votes = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                votes[i][j] = (long long)(votes[i][j] * scale);\n                total_votes += votes[i][j];\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        // Output votes for city i\n        for (int j = 0; j < n; ++j) {\n            printf(\"%lld\", votes[i][j]);\n            if (j + 1 < n) {\n                printf(\" \");\n            }\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long total_votes_limit = 1000000000LL;\n\n    // Maximum votes per candidate per city to ensure total votes do not exceed limit\n    long long max_votes_per_candidate_city = total_votes_limit / (n * m);\n    max_votes_per_candidate_city = min(max_votes_per_candidate_city, 1000000000LL);\n\n    // Container for votes\n    vector<vector<long long>> votes(m, vector<long long>(n, 0));\n\n    if (type == \"random\") {\n        // Generate random votes between 0 and max_votes_per_candidate_city\n        long long total_votes = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                long long v = rnd.next(0LL, max_votes_per_candidate_city);\n                votes[i][j] = v;\n                total_votes += v;\n            }\n        }\n        // Scale down votes if total exceeds limit\n        if (total_votes > total_votes_limit) {\n            double scale = (double)total_votes_limit / total_votes;\n            total_votes = 0;\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = (long long)(votes[i][j] * scale);\n                    total_votes += votes[i][j];\n                }\n            }\n        }\n    } else if (type == \"tie_in_city\") {\n        // Create ties in some cities\n        for (int i = 0; i < m; ++i) {\n            bool tie = rnd.next(0, 1); // 50% chance of tie\n            if (tie) {\n                // Select two candidates to tie\n                int cand1 = rnd.next(0, n - 1);\n                int cand2 = rnd.next(0, n - 1);\n                while (cand2 == cand1) cand2 = rnd.next(0, n - 1);\n                long long v = rnd.next(1LL, max_votes_per_candidate_city);\n                votes[i][cand1] = v;\n                votes[i][cand2] = v;\n                // Others get random votes less than v\n                for (int j = 0; j < n; ++j) {\n                    if (j != cand1 && j != cand2) {\n                        votes[i][j] = rnd.next(0LL, v - 1);\n                    }\n                }\n            } else {\n                // Random votes\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = rnd.next(0LL, max_votes_per_candidate_city);\n                }\n            }\n        }\n    } else if (type == \"tie_overall\") {\n        // Two candidates win the same number of cities\n        int cand1 = rnd.next(0, n - 1);\n        int cand2 = rnd.next(0, n - 1);\n        while (cand2 == cand1) cand2 = rnd.next(0, n - 1);\n        vector<int> order(m);\n        for (int i = 0; i < m; ++i) order[i] = i;\n        shuffle(order.begin(), order.end());\n        int half_m = m / 2;\n        for (int k = 0; k < m; ++k) {\n            int i = order[k];\n            if (k < half_m) {\n                // Candidate 1 wins\n                votes[i][cand1] = rnd.next(max_votes_per_candidate_city / 2, max_votes_per_candidate_city);\n                for (int j = 0; j < n; ++j) {\n                    if (j != cand1) {\n                        votes[i][j] = rnd.next(0LL, votes[i][cand1] - 1);\n                    }\n                }\n            } else {\n                // Candidate 2 wins\n                votes[i][cand2] = rnd.next(max_votes_per_candidate_city / 2, max_votes_per_candidate_city);\n                for (int j = 0; j < n; ++j) {\n                    if (j != cand2) {\n                        votes[i][j] = rnd.next(0LL, votes[i][cand2] - 1);\n                    }\n                }\n            }\n        }\n    } else if (type == \"zero_votes\") {\n        // Some cities have zero votes\n        for (int i = 0; i < m; ++i) {\n            bool zero_city = rnd.next(0, 1); // 50% chance of zero votes\n            if (zero_city) {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = 0;\n                }\n            } else {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = rnd.next(0LL, max_votes_per_candidate_city);\n                }\n            }\n        }\n    } else if (type == \"max_votes\") {\n        // Votes are near maximum\n        long long per_vote = max_votes_per_candidate_city;\n        for (int i = 0; i < m; ++i) {\n            int winner = rnd.next(0, n - 1);\n            votes[i][winner] = per_vote;\n            for (int j = 0; j < n; ++j) {\n                if (j != winner) {\n                    votes[i][j] = rnd.next(0LL, per_vote - 1);\n                }\n            }\n        }\n    } else if (type == \"min_votes\") {\n        // Votes are minimal\n        for (int i = 0; i < m; ++i) {\n            int winner = rnd.next(0, n - 1);\n            votes[i][winner] = 1;\n            for (int j = 0; j < n; ++j) {\n                if (j != winner) {\n                    votes[i][j] = 0;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        long long total_votes = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                long long v = rnd.next(0LL, max_votes_per_candidate_city);\n                votes[i][j] = v;\n                total_votes += v;\n            }\n        }\n        if (total_votes > total_votes_limit) {\n            double scale = (double)total_votes_limit / total_votes;\n            total_votes = 0;\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    votes[i][j] = (long long)(votes[i][j] * scale);\n                    total_votes += votes[i][j];\n                }\n            }\n        }\n    }\n\n    // Compute total votes and ensure it doesn't exceed the limit\n    long long total_votes = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            total_votes += votes[i][j];\n        }\n    }\n    if (total_votes > total_votes_limit) {\n        double scale = (double)total_votes_limit / total_votes;\n        total_votes = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                votes[i][j] = (long long)(votes[i][j] * scale);\n                total_votes += votes[i][j];\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        // Output votes for city i\n        for (int j = 0; j < n; ++j) {\n            printf(\"%lld\", votes[i][j]);\n            if (j + 1 < n) {\n                printf(\" \");\n            }\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n\n./gen -n 5 -m 5 -type tie_in_city\n./gen -n 20 -m 20 -type tie_in_city\n./gen -n 50 -m 50 -type tie_in_city\n\n./gen -n 5 -m 5 -type tie_overall\n./gen -n 20 -m 20 -type tie_overall\n./gen -n 50 -m 50 -type tie_overall\n\n./gen -n 5 -m 5 -type zero_votes\n./gen -n 20 -m 20 -type zero_votes\n./gen -n 50 -m 50 -type zero_votes\n\n./gen -n 5 -m 5 -type max_votes\n./gen -n 20 -m 20 -type max_votes\n./gen -n 50 -m 50 -type max_votes\n\n./gen -n 5 -m 5 -type min_votes\n./gen -n 20 -m 20 -type min_votes\n./gen -n 50 -m 50 -type min_votes\n\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 1 -type random\n\n./gen -n 100 -m 100 -type tie_in_city\n./gen -n 100 -m 100 -type tie_overall\n./gen -n 100 -m 100 -type zero_votes\n./gen -n 100 -m 100 -type max_votes\n./gen -n 100 -m 100 -type min_votes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:35.227907",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "570/B",
      "title": "B. Simple Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ m ≤ n ≤ 109) — the range of numbers in the game, and the number selected by Misha respectively.",
      "output_spec": "OutputPrint a single number — such value a, that probability that Andrew wins is the highest. If there are multiple such values, print the minimum of them.",
      "sample_tests": "ExamplesInputCopy3 1OutputCopy2InputCopy4 3OutputCopy2",
      "description": "B. Simple Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m (1 ≤ m ≤ n ≤ 109) — the range of numbers in the game, and the number selected by Misha respectively.\n\nOutputPrint a single number — such value a, that probability that Andrew wins is the highest. If there are multiple such values, print the minimum of them.\n\nInputCopy3 1OutputCopy2InputCopy4 3OutputCopy2\n\nInputCopy3 1\n\nOutputCopy2\n\nInputCopy4 3\n\nOutputCopy2\n\nNoteIn the first sample test: Andrew wins if c is equal to 2 or 3. The probability that Andrew wins is 2 / 3. If Andrew chooses a = 3, the probability of winning will be 1 / 3. If a = 1, the probability of winning is 0.In the second sample test: Andrew wins if c is equal to 1 and 2. The probability that Andrew wins is 1 / 2. For other choices of a the probability of winning is less.",
      "solutions": [
        {
          "title": "Codeforces Round #316 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #316 for participants from the second division will take place on August 13, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my first round on Codeforces. Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: The score distribution is standard, 500-1000-1500-2000-2500Good luck!UPD: Contest is finished. Thank you everyone!Congratulations to the winners!UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19753",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 752
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces",
          "content": "570А — Elections We need to determine choice for each city. Then sum it for each candidate and determine the winner.O(n * m)Solutions570B — Simple Game Lets find which variant is interesting. For Andrew is no need a variant wherein |a - m| > 1 because we can increase probability of victory if we will be closer to m. Then we consider two variants, a = c - 1 and a = c + 1. Probability of victory will be c / n for first variant and (n - c + 1) / n for second. We need to choose better variant, also we must keep in mind case of n = 1.O(1)Solutions570C — ReplacementLets find how replacements occur. If we have segment of points with length l,we need l - 1 operations and stop replacements for this segment. If we sum lenghts of all segments and its quantity then answer will be = total length of segments — quantity of segments. After change of one symbol length changes by 1.Quantity of segments can be supported by array. Consider events of merging, dividing,creation and deletion of segments. For merging we need to find if both of neighbors(right and left) are points then merging occured and quantity of segments reduced by 1. Other cases can be cosidered similarly.O(n + m)Solutions570D — Tree RequestsWe need to write vertices in DFS order and store time of enter/exit of vertices in DFS. All vertices in subtree represent a segment. Now we can get all vertices in subtree v on height h as a segment, making two binary searches.We can make a palindrome if quantity of uneven entries of each letter is less than 2.This function can be counted for each prefix in bypass for each depth.For saving the memory bit compression can be used considering that we need only parity and function is xor.O(m * (log + 26) + n)D had a offline solution too in O(n + m * (26 / 32)) time and O(n * 26 / 8) memorySolutions570E — Pig and PalindromesWe need palindrome paths. Palindrome is word which reads the same backward or forward. We can use it. Count the dynamic from coordinates of 2 cells, first and latest in palindrome.From each state exists 4 transitions (combinations: first cell down/to the right and second cell up/to the left). We need only transitions on equal symbols for making a palindrome. Note that we need a pairs of cells on equal distance from start and end for each.For saving memory we need to store two latest layers. O(n3) — time and O(n2) — memorySolutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19770",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 570\\s*B"
          },
          "content_length": 2372
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 1",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 2",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 3",
          "code": "else if (t == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 4",
          "code": "else if (t == 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 5",
          "code": "O(nlog(n) + 26m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse the command line arguments\n    string n_type = opt<string>(\"n_type\", \"random\");\n    string m_pos = opt<string>(\"m_pos\", \"random\");\n    int n = opt<int>(\"n\", 0);\n    int m = opt<int>(\"m\", 0);\n\n    if (n == 0) {\n        if (n_type == \"small\") {\n            n = rnd.next(1, 10); // Small n between 1 and 10\n        } else if (n_type == \"large\") {\n            n = 1000000000; // n = maximum\n        } else if (n_type == \"random\") {\n            n = rnd.next(1, 1000000000);\n        } else {\n            printf(\"Invalid n_type\\n\");\n            return 1;\n        }\n    } else {\n        // n is provided, check constraints\n        if (n < 1 || n > 1000000000) {\n            printf(\"Invalid n value\\n\");\n            return 1;\n        }\n    }\n\n    if (m == 0) {\n        if (m_pos == \"start\") {\n            m = 1;\n        } else if (m_pos == \"end\") {\n            m = n;\n        } else if (m_pos == \"middle\") {\n            m = n / 2 + rnd.next(-10, 10);\n            // Adjust m to be within [1,n]\n            if (m < 1) m = 1;\n            if (m > n) m = n;\n        } else if (m_pos == \"random\") {\n            m = rnd.next(1, n);\n        } else {\n            printf(\"Invalid m_pos\\n\");\n            return 1;\n        }\n    } else {\n        // m is provided, check constraints\n        if (m < 1 || m > n) {\n            printf(\"Invalid m value\\n\");\n            return 1;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse the command line arguments\n    string n_type = opt<string>(\"n_type\", \"random\");\n    string m_pos = opt<string>(\"m_pos\", \"random\");\n    int n = opt<int>(\"n\", 0);\n    int m = opt<int>(\"m\", 0);\n\n    if (n == 0) {\n        if (n_type == \"small\") {\n            n = rnd.next(1, 10); // Small n between 1 and 10\n        } else if (n_type == \"large\") {\n            n = 1000000000; // n = maximum\n        } else if (n_type == \"random\") {\n            n = rnd.next(1, 1000000000);\n        } else {\n            printf(\"Invalid n_type\\n\");\n            return 1;\n        }\n    } else {\n        // n is provided, check constraints\n        if (n < 1 || n > 1000000000) {\n            printf(\"Invalid n value\\n\");\n            return 1;\n        }\n    }\n\n    if (m == 0) {\n        if (m_pos == \"start\") {\n            m = 1;\n        } else if (m_pos == \"end\") {\n            m = n;\n        } else if (m_pos == \"middle\") {\n            m = n / 2 + rnd.next(-10, 10);\n            // Adjust m to be within [1,n]\n            if (m < 1) m = 1;\n            if (m > n) m = n;\n        } else if (m_pos == \"random\") {\n            m = rnd.next(1, n);\n        } else {\n            printf(\"Invalid m_pos\\n\");\n            return 1;\n        }\n    } else {\n        // m is provided, check constraints\n        if (m < 1 || m > n) {\n            printf(\"Invalid m value\\n\");\n            return 1;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, m at different positions\n./gen -n_type small -m_pos start\n./gen -n_type small -m_pos end\n./gen -n_type small -m_pos middle\n./gen -n_type small -m_pos random\n\n# Large n (maximum n), m at different positions\n./gen -n_type large -m_pos start\n./gen -n_type large -m_pos end\n./gen -n_type large -m_pos middle\n./gen -n_type large -m_pos random\n\n# Random n, m at different positions\n./gen -n_type random -m_pos start\n./gen -n_type random -m_pos end\n./gen -n_type random -m_pos middle\n./gen -n_type random -m_pos random\n\n# Specific small n and m\n./gen -n 1 -m 1\n./gen -n 2 -m 1\n./gen -n 2 -m 2\n./gen -n 3 -m 2\n\n# n is maximum, m at specific positions\n./gen -n 1000000000 -m_pos start\n./gen -n 1000000000 -m_pos end\n./gen -n 1000000000 -m_pos middle\n./gen -n 1000000000 -m_pos random\n\n# m near the middle for small n\n./gen -n 5 -m_pos middle\n./gen -n 6 -m_pos middle\n./gen -n 7 -m_pos middle\n./gen -n 8 -m_pos middle\n./gen -n 9 -m_pos middle\n./gen -n 10 -m_pos middle\n\n# Random test cases\nfor i in {1..10}; do\n    ./gen -n_type random -m_pos random\ndone\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:37.065054",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "570/C",
      "title": "C. Replacement",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 300 000) the length of the string and the number of queries.The second line contains string s, consisting of n lowercase English letters and period signs.The following m lines contain the descriptions of queries. The i-th line contains integer xi and ci (1 ≤ xi ≤ n, ci — a lowercas English letter or a period sign), describing the query of assigning symbol ci to position xi.",
      "output_spec": "OutputPrint m numbers, one per line, the i-th of these numbers must be equal to the value of f(s) after performing the i-th assignment.",
      "sample_tests": "ExamplesInputCopy10 3.b..bz....1 h3 c9 fOutputCopy431InputCopy4 4.cc.2 .3 .2 a1 aOutputCopy1311",
      "description": "C. Replacement\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 300 000) the length of the string and the number of queries.The second line contains string s, consisting of n lowercase English letters and period signs.The following m lines contain the descriptions of queries. The i-th line contains integer xi and ci (1 ≤ xi ≤ n, ci — a lowercas English letter or a period sign), describing the query of assigning symbol ci to position xi.\n\nOutputPrint m numbers, one per line, the i-th of these numbers must be equal to the value of f(s) after performing the i-th assignment.\n\nInputCopy10 3.b..bz....1 h3 c9 fOutputCopy431InputCopy4 4.cc.2 .3 .2 a1 aOutputCopy1311\n\nInputCopy10 3.b..bz....1 h3 c9 f\n\nOutputCopy431\n\nInputCopy4 4.cc.2 .3 .2 a1 a\n\nOutputCopy1311\n\nNoteNote to the first sample test (replaced periods are enclosed in square brackets).The original string is \".b..bz....\". after the first query f(hb..bz....) = 4    (\"hb[..]bz....\"  →  \"hb.bz[..]..\"  →  \"hb.bz[..].\"  →  \"hb.bz[..]\"  →  \"hb.bz.\") after the second query f(hbс.bz....) = 3    (\"hbс.bz[..]..\"  →  \"hbс.bz[..].\"  →  \"hbс.bz[..]\"  →  \"hbс.bz.\") after the third query f(hbс.bz..f.) = 1    (\"hbс.bz[..]f.\"  →  \"hbс.bz.f.\")Note to the second sample test.The original string is \".cc.\". after the first query: f(..c.) = 1    (\"[..]c.\"  →  \".c.\") after the second query: f(....) = 3    (\"[..]..\"  →  \"[..].\"  →  \"[..]\"  →  \".\") after the third query: f(.a..) = 1    (\".a[..]\"  →  \".a.\") after the fourth query: f(aa..) = 1    (\"aa[..]\"  →  \"aa.\")",
      "solutions": [
        {
          "title": "Codeforces Round #316 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #316 for participants from the second division will take place on August 13, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my first round on Codeforces. Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: The score distribution is standard, 500-1000-1500-2000-2500Good luck!UPD: Contest is finished. Thank you everyone!Congratulations to the winners!UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19753",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 752
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces",
          "content": "570А — Elections We need to determine choice for each city. Then sum it for each candidate and determine the winner.O(n * m)Solutions570B — Simple Game Lets find which variant is interesting. For Andrew is no need a variant wherein |a - m| > 1 because we can increase probability of victory if we will be closer to m. Then we consider two variants, a = c - 1 and a = c + 1. Probability of victory will be c / n for first variant and (n - c + 1) / n for second. We need to choose better variant, also we must keep in mind case of n = 1.O(1)Solutions570C — ReplacementLets find how replacements occur. If we have segment of points with length l,we need l - 1 operations and stop replacements for this segment. If we sum lenghts of all segments and its quantity then answer will be = total length of segments — quantity of segments. After change of one symbol length changes by 1.Quantity of segments can be supported by array. Consider events of merging, dividing,creation and deletion of segments. For merging we need to find if both of neighbors(right and left) are points then merging occured and quantity of segments reduced by 1. Other cases can be cosidered similarly.O(n + m)Solutions570D — Tree RequestsWe need to write vertices in DFS order and store time of enter/exit of vertices in DFS. All vertices in subtree represent a segment. Now we can get all vertices in subtree v on height h as a segment, making two binary searches.We can make a palindrome if quantity of uneven entries of each letter is less than 2.This function can be counted for each prefix in bypass for each depth.For saving the memory bit compression can be used considering that we need only parity and function is xor.O(m * (log + 26) + n)D had a offline solution too in O(n + m * (26 / 32)) time and O(n * 26 / 8) memorySolutions570E — Pig and PalindromesWe need palindrome paths. Palindrome is word which reads the same backward or forward. We can use it. Count the dynamic from coordinates of 2 cells, first and latest in palindrome.From each state exists 4 transitions (combinations: first cell down/to the right and second cell up/to the left). We need only transitions on equal symbols for making a palindrome. Note that we need a pairs of cells on equal distance from start and end for each.For saving memory we need to store two latest layers. O(n3) — time and O(n2) — memorySolutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19770",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 570\\s*C"
          },
          "content_length": 2372
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 1",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 2",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 3",
          "code": "else if (t == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 4",
          "code": "else if (t == 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 5",
          "code": "O(nlog(n) + 26m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z\\\\.]{1,300000}\", \"s\");\n    ensuref((int)s.length() == n, \"Length of s must be %d, but it is %d\", n, (int)s.length());\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        string ciToken = inf.readToken(\"[a-z\\\\.]\", \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z\\\\.]{1,300000}\", \"s\");\n    ensuref((int)s.length() == n, \"Length of s must be %d, but it is %d\", n, (int)s.length());\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        string ciToken = inf.readToken(\"[a-z\\\\.]\", \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z\\\\.]{1,300000}\", \"s\");\n    ensuref((int)s.length() == n, \"Length of s must be %d, but it is %d\", n, (int)s.length());\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        string ciToken = inf.readToken(\"[a-z\\\\.]\", \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a'); // initial s\n    vector<pair<int, char>> queries;\n\n    if (type == \"max_periods\") {\n        // s is all periods\n        s = string(n, '.');\n        for (int i = 0; i < m; ++i) {\n            // Randomly change a period to a letter or keep it as a period\n            int xi = rnd.next(1, n);\n            char ci;\n            if (rnd.next(0, 1) == 0) {\n                ci = '.'; // keep as period\n            } else {\n                ci = rnd.next('a', 'z'); // change to letter\n            }\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"no_periods\") {\n        // s is all letters\n        s = string(n, 'a');\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            if (rnd.next(0, 1) == 0) {\n                ci = '.'; // change to period\n            } else {\n                ci = rnd.next('a', 'z'); // keep as letter\n            }\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"random\") {\n        // s is random letters and periods\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1);\n            if (t == 0) s[i] = rnd.next('a', 'z');\n            else s[i] = '.';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            int t = rnd.next(0, 1);\n            if (t == 0) ci = rnd.next('a', 'z');\n            else ci = '.';\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"alternating\") {\n        // s alternates between letters and periods\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) s[i] = '.';\n            else s[i] = 'a';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci = (s[xi-1] == '.') ? 'a' : '.';\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"single_consecutive\") {\n        // s has a single occurrence of '..'\n        s = string(n, 'a');\n        if (n >= 2) {\n            int pos = rnd.next(1, n - 1);\n            s[pos - 1] = '.';\n            s[pos] = '.';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            if (rnd.next(0, 1) == 0) ci = '.';\n            else ci = rnd.next('a', 'z');\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1);\n            if (t == 0) s[i] = rnd.next('a', 'z');\n            else s[i] = '.';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            int t = rnd.next(0, 1);\n            if (t == 0) ci = rnd.next('a', 'z');\n            else ci = '.';\n            queries.emplace_back(xi, ci);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", s.c_str());\n    for (const auto& q : queries) {\n        printf(\"%d %c\\n\", q.first, q.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a'); // initial s\n    vector<pair<int, char>> queries;\n\n    if (type == \"max_periods\") {\n        // s is all periods\n        s = string(n, '.');\n        for (int i = 0; i < m; ++i) {\n            // Randomly change a period to a letter or keep it as a period\n            int xi = rnd.next(1, n);\n            char ci;\n            if (rnd.next(0, 1) == 0) {\n                ci = '.'; // keep as period\n            } else {\n                ci = rnd.next('a', 'z'); // change to letter\n            }\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"no_periods\") {\n        // s is all letters\n        s = string(n, 'a');\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            if (rnd.next(0, 1) == 0) {\n                ci = '.'; // change to period\n            } else {\n                ci = rnd.next('a', 'z'); // keep as letter\n            }\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"random\") {\n        // s is random letters and periods\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1);\n            if (t == 0) s[i] = rnd.next('a', 'z');\n            else s[i] = '.';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            int t = rnd.next(0, 1);\n            if (t == 0) ci = rnd.next('a', 'z');\n            else ci = '.';\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"alternating\") {\n        // s alternates between letters and periods\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) s[i] = '.';\n            else s[i] = 'a';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci = (s[xi-1] == '.') ? 'a' : '.';\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else if (type == \"single_consecutive\") {\n        // s has a single occurrence of '..'\n        s = string(n, 'a');\n        if (n >= 2) {\n            int pos = rnd.next(1, n - 1);\n            s[pos - 1] = '.';\n            s[pos] = '.';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            if (rnd.next(0, 1) == 0) ci = '.';\n            else ci = rnd.next('a', 'z');\n            queries.emplace_back(xi, ci);\n        }\n    }\n    else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1);\n            if (t == 0) s[i] = rnd.next('a', 'z');\n            else s[i] = '.';\n        }\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            char ci;\n            int t = rnd.next(0, 1);\n            if (t == 0) ci = rnd.next('a', 'z');\n            else ci = '.';\n            queries.emplace_back(xi, ci);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", s.c_str());\n    for (const auto& q : queries) {\n        printf(\"%d %c\\n\", q.first, q.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type max_periods\n./gen -n 10 -m 5 -type no_periods\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type alternating\n./gen -n 10 -m 5 -type single_consecutive\n\n./gen -n 1000 -m 1000 -type max_periods\n./gen -n 1000 -m 1000 -type no_periods\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type alternating\n./gen -n 1000 -m 1000 -type single_consecutive\n\n./gen -n 100000 -m 100000 -type max_periods\n./gen -n 100000 -m 100000 -type no_periods\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type alternating\n./gen -n 100000 -m 100000 -type single_consecutive\n\n./gen -n 300000 -m 300000 -type max_periods\n./gen -n 300000 -m 300000 -type no_periods\n./gen -n 300000 -m 300000 -type random\n./gen -n 300000 -m 300000 -type alternating\n./gen -n 300000 -m 300000 -type single_consecutive\n\n./gen -n 300000 -m 300000 -type max_periods\n./gen -n 300000 -m 0 -type max_periods\n./gen -n 300000 -m 300000 -type no_periods\n./gen -n 300000 -m 0 -type no_periods\n./gen -n 300000 -m 300000 -type random\n./gen -n 300000 -m 0 -type random\n\n./gen -n 300000 -m 300000 -type random\n./gen -n 300000 -m 1 -type single_consecutive\n./gen -n 2 -m 1 -type single_consecutive\n./gen -n 1 -m 0 -type max_periods\n./gen -n 1 -m 1 -type random\n./gen -n 300000 -m 300000 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:38.747510",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "570/D",
      "title": "D. Tree Requests",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 500 000) — the number of nodes in the tree and queries, respectively.The following line contains n - 1 integers p2, p3, ..., pn — the parents of vertices from the second to the n-th (1 ≤ pi < i).The next line contains n lowercase English letters, the i-th of these letters is written on vertex i.Next m lines describe the queries, the i-th line contains two numbers vi, hi (1 ≤ vi, hi ≤ n) — the vertex and the depth that appear in the i-th query.",
      "output_spec": "OutputPrint m lines. In the i-th line print \"Yes\" (without the quotes), if in the i-th query you can make a palindrome from the letters written on the vertices, otherwise print \"No\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy6 51 1 1 3 3zacccd1 13 34 16 11 2OutputCopyYesNoYesYesYes",
      "description": "D. Tree Requests\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 500 000) — the number of nodes in the tree and queries, respectively.The following line contains n - 1 integers p2, p3, ..., pn — the parents of vertices from the second to the n-th (1 ≤ pi < i).The next line contains n lowercase English letters, the i-th of these letters is written on vertex i.Next m lines describe the queries, the i-th line contains two numbers vi, hi (1 ≤ vi, hi ≤ n) — the vertex and the depth that appear in the i-th query.\n\nOutputPrint m lines. In the i-th line print \"Yes\" (without the quotes), if in the i-th query you can make a palindrome from the letters written on the vertices, otherwise print \"No\" (without the quotes).\n\nInputCopy6 51 1 1 3 3zacccd1 13 34 16 11 2OutputCopyYesNoYesYesYes\n\nInputCopy6 51 1 1 3 3zacccd1 13 34 16 11 2\n\nOutputCopyYesNoYesYesYes\n\nNoteString s is a palindrome if reads the same from left to right and from right to left. In particular, an empty string is a palindrome.Clarification for the sample test.In the first query there exists only a vertex 1 satisfying all the conditions, we can form a palindrome \"z\".In the second query vertices 5 and 6 satisfy condititions, they contain letters \"с\" and \"d\" respectively. It is impossible to form a palindrome of them.In the third query there exist no vertices at depth 1 and in subtree of 4. We may form an empty palindrome.In the fourth query there exist no vertices in subtree of 6 at depth 1. We may form an empty palindrome.In the fifth query there vertices 2, 3 and 4 satisfying all conditions above, they contain letters \"a\", \"c\" and \"c\". We may form a palindrome \"cac\".",
      "solutions": [
        {
          "title": "Codeforces Round #316 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #316 for participants from the second division will take place on August 13, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my first round on Codeforces. Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: The score distribution is standard, 500-1000-1500-2000-2500Good luck!UPD: Contest is finished. Thank you everyone!Congratulations to the winners!UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19753",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 752
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces",
          "content": "570А — Elections We need to determine choice for each city. Then sum it for each candidate and determine the winner.O(n * m)Solutions570B — Simple Game Lets find which variant is interesting. For Andrew is no need a variant wherein |a - m| > 1 because we can increase probability of victory if we will be closer to m. Then we consider two variants, a = c - 1 and a = c + 1. Probability of victory will be c / n for first variant and (n - c + 1) / n for second. We need to choose better variant, also we must keep in mind case of n = 1.O(1)Solutions570C — ReplacementLets find how replacements occur. If we have segment of points with length l,we need l - 1 operations and stop replacements for this segment. If we sum lenghts of all segments and its quantity then answer will be = total length of segments — quantity of segments. After change of one symbol length changes by 1.Quantity of segments can be supported by array. Consider events of merging, dividing,creation and deletion of segments. For merging we need to find if both of neighbors(right and left) are points then merging occured and quantity of segments reduced by 1. Other cases can be cosidered similarly.O(n + m)Solutions570D — Tree RequestsWe need to write vertices in DFS order and store time of enter/exit of vertices in DFS. All vertices in subtree represent a segment. Now we can get all vertices in subtree v on height h as a segment, making two binary searches.We can make a palindrome if quantity of uneven entries of each letter is less than 2.This function can be counted for each prefix in bypass for each depth.For saving the memory bit compression can be used considering that we need only parity and function is xor.O(m * (log + 26) + n)D had a offline solution too in O(n + m * (26 / 32)) time and O(n * 26 / 8) memorySolutions570E — Pig and PalindromesWe need palindrome paths. Palindrome is word which reads the same backward or forward. We can use it. Count the dynamic from coordinates of 2 cells, first and latest in palindrome.From each state exists 4 transitions (combinations: first cell down/to the right and second cell up/to the left). We need only transitions on equal symbols for making a palindrome. Note that we need a pairs of cells on equal distance from start and end for each.For saving memory we need to store two latest layers. O(n3) — time and O(n2) — memorySolutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19770",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 570\\s*D"
          },
          "content_length": 2372
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 1",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 2",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 3",
          "code": "else if (t == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 4",
          "code": "else if (t == 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 5",
          "code": "O(nlog(n) + 26m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readEoln();\n\n    // Initialize Union-Find DSU for n nodes\n    vector<int> parent(n+1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    int components = n;\n    for (int i = 2; i <= n; i++) {\n        int pi = inf.readInt(1, i - 1, (\"p\" + to_string(i)).c_str());\n\n        // Union i and pi\n        int u = find(i), v = find(pi);\n        if (u != v) {\n            parent[u] = v;\n            components--;\n        } else {\n            quitf(_fail, \"Cycle detected in the tree at edge %d - %d\", i, pi);\n        }\n\n        if (i != n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    ensuref(components == 1, \"The graph is not connected, components = %d\", components);\n\n    // Read letters\n    string letters = inf.readLine();\n    ensuref((int)letters.size() == n, \"Expected string of length %d, but got length %d\", n, (int)letters.size());\n    for (char c : letters) {\n        ensuref('a' <= c && c <= 'z', \"All letters must be lowercase English letters, found '%c'\", c);\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, (\"v\" + to_string(i+1)).c_str());\n        inf.readSpace();\n        int hi = inf.readInt(1, n, (\"h\" + to_string(i+1)).c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readEoln();\n\n    // Initialize Union-Find DSU for n nodes\n    vector<int> parent(n+1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    int components = n;\n    for (int i = 2; i <= n; i++) {\n        int pi = inf.readInt(1, i - 1, (\"p\" + to_string(i)).c_str());\n\n        // Union i and pi\n        int u = find(i), v = find(pi);\n        if (u != v) {\n            parent[u] = v;\n            components--;\n        } else {\n            quitf(_fail, \"Cycle detected in the tree at edge %d - %d\", i, pi);\n        }\n\n        if (i != n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    ensuref(components == 1, \"The graph is not connected, components = %d\", components);\n\n    // Read letters\n    string letters = inf.readLine();\n    ensuref((int)letters.size() == n, \"Expected string of length %d, but got length %d\", n, (int)letters.size());\n    for (char c : letters) {\n        ensuref('a' <= c && c <= 'z', \"All letters must be lowercase English letters, found '%c'\", c);\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, (\"v\" + to_string(i+1)).c_str());\n        inf.readSpace();\n        int hi = inf.readInt(1, n, (\"h\" + to_string(i+1)).c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readEoln();\n\n    // Initialize Union-Find DSU for n nodes\n    vector<int> parent(n+1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    int components = n;\n    for (int i = 2; i <= n; i++) {\n        int pi = inf.readInt(1, i - 1, (\"p\" + to_string(i)).c_str());\n\n        // Union i and pi\n        int u = find(i), v = find(pi);\n        if (u != v) {\n            parent[u] = v;\n            components--;\n        } else {\n            quitf(_fail, \"Cycle detected in the tree at edge %d - %d\", i, pi);\n        }\n\n        if (i != n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    ensuref(components == 1, \"The graph is not connected, components = %d\", components);\n\n    // Read letters\n    string letters = inf.readLine();\n    ensuref((int)letters.size() == n, \"Expected string of length %d, but got length %d\", n, (int)letters.size());\n    for (char c : letters) {\n        ensuref('a' <= c && c <= 'z', \"All letters must be lowercase English letters, found '%c'\", c);\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, (\"v\" + to_string(i+1)).c_str());\n        inf.readSpace();\n        int hi = inf.readInt(1, n, (\"h\" + to_string(i+1)).c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string letter_type = opt<string>(\"letter_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> p(n + 1); // Parent array\n    vector<char> letters(n + 1); // Letters at each node\n\n    // Build the tree\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = i - 1;\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = 1;\n    } else if (tree_type == \"balanced\") {\n        // Balanced binary tree\n        queue<int> q;\n        int curr_node = 1;\n        q.push(curr_node);\n        curr_node++;\n        while (curr_node <= n) {\n            int u = q.front();\n            q.pop();\n            // Left child\n            if (curr_node <= n) {\n                p[curr_node] = u;\n                q.push(curr_node);\n                curr_node++;\n            }\n            // Right child\n            if (curr_node <= n) {\n                p[curr_node] = u;\n                q.push(curr_node);\n                curr_node++;\n            }\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        p[2] = 1;\n        for (int i = 3; i <= n; ++i)\n            p[i] = p[i - 1];\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i -1);\n    }\n\n    // Assign letters\n    if (letter_type == \"all_same\") {\n        for (int i = 1; i <= n; ++i)\n            letters[i] = 'a';\n    } else if (letter_type == \"alternating\") {\n        for (int i = 1; i <= n; ++i)\n            letters[i] = 'a' + (i % 2);\n    } else if (letter_type == \"palindromic_depths\") {\n        // Assign letters to ensure palindromes at each depth\n        vector<vector<int>> tree(n + 1);\n        for (int i = 2; i <= n; ++i)\n            tree[p[i]].push_back(i);\n        vector<int> depth(n + 1);\n        function<void(int)> dfs = [&](int u) {\n            for (int v : tree[u]) {\n                depth[v] = depth[u] + 1;\n                dfs(v);\n            }\n        };\n        depth[1] = 1;\n        dfs(1);\n        int max_depth = *max_element(depth.begin() + 1, depth.end());\n        vector<char> depth_letters(max_depth + 1, 'a');\n        for (int i = 1; i <= n; ++i) {\n            letters[i] = depth_letters[depth[i]];\n            depth_letters[depth[i]]++;\n            if (depth_letters[depth[i]] > 'z')\n                depth_letters[depth[i]] = 'a';\n        }\n    } else {\n        // Random letters\n        for (int i = 1; i <= n; ++i)\n            letters[i] = 'a' + rnd.next(0, 25);\n    }\n\n    // Generate queries\n    vector<pair<int,int>> queries(m);\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int hi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else if (query_type == \"max_depth\") {\n        int hi = n;\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else if (query_type == \"min_depth\") {\n        int hi = 1;\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else if (query_type == \"same_node\") {\n        int vi = rnd.next(1, n);\n        int hi = rnd.next(1, n);\n        for (int i = 0; i < m; ++i)\n            queries[i] = make_pair(vi, hi);\n    } else if (query_type == \"nonexistent_depth\") {\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int hi = n + 1 + rnd.next(0, 1000);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int hi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 2; i <= n; ++i)\n        printf(\"%d%c\", p[i], (i == n) ? '\\n' : ' ');\n    for (int i = 1; i <= n; ++i)\n        printf(\"%c\", letters[i]);\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string letter_type = opt<string>(\"letter_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> p(n + 1); // Parent array\n    vector<char> letters(n + 1); // Letters at each node\n\n    // Build the tree\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = i - 1;\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = 1;\n    } else if (tree_type == \"balanced\") {\n        // Balanced binary tree\n        queue<int> q;\n        int curr_node = 1;\n        q.push(curr_node);\n        curr_node++;\n        while (curr_node <= n) {\n            int u = q.front();\n            q.pop();\n            // Left child\n            if (curr_node <= n) {\n                p[curr_node] = u;\n                q.push(curr_node);\n                curr_node++;\n            }\n            // Right child\n            if (curr_node <= n) {\n                p[curr_node] = u;\n                q.push(curr_node);\n                curr_node++;\n            }\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        p[2] = 1;\n        for (int i = 3; i <= n; ++i)\n            p[i] = p[i - 1];\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i -1);\n    }\n\n    // Assign letters\n    if (letter_type == \"all_same\") {\n        for (int i = 1; i <= n; ++i)\n            letters[i] = 'a';\n    } else if (letter_type == \"alternating\") {\n        for (int i = 1; i <= n; ++i)\n            letters[i] = 'a' + (i % 2);\n    } else if (letter_type == \"palindromic_depths\") {\n        // Assign letters to ensure palindromes at each depth\n        vector<vector<int>> tree(n + 1);\n        for (int i = 2; i <= n; ++i)\n            tree[p[i]].push_back(i);\n        vector<int> depth(n + 1);\n        function<void(int)> dfs = [&](int u) {\n            for (int v : tree[u]) {\n                depth[v] = depth[u] + 1;\n                dfs(v);\n            }\n        };\n        depth[1] = 1;\n        dfs(1);\n        int max_depth = *max_element(depth.begin() + 1, depth.end());\n        vector<char> depth_letters(max_depth + 1, 'a');\n        for (int i = 1; i <= n; ++i) {\n            letters[i] = depth_letters[depth[i]];\n            depth_letters[depth[i]]++;\n            if (depth_letters[depth[i]] > 'z')\n                depth_letters[depth[i]] = 'a';\n        }\n    } else {\n        // Random letters\n        for (int i = 1; i <= n; ++i)\n            letters[i] = 'a' + rnd.next(0, 25);\n    }\n\n    // Generate queries\n    vector<pair<int,int>> queries(m);\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int hi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else if (query_type == \"max_depth\") {\n        int hi = n;\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else if (query_type == \"min_depth\") {\n        int hi = 1;\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else if (query_type == \"same_node\") {\n        int vi = rnd.next(1, n);\n        int hi = rnd.next(1, n);\n        for (int i = 0; i < m; ++i)\n            queries[i] = make_pair(vi, hi);\n    } else if (query_type == \"nonexistent_depth\") {\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int hi = n + 1 + rnd.next(0, 1000);\n            queries[i] = make_pair(vi, hi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int hi = rnd.next(1, n);\n            queries[i] = make_pair(vi, hi);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 2; i <= n; ++i)\n        printf(\"%d%c\", p[i], (i == n) ? '\\n' : ' ');\n    for (int i = 1; i <= n; ++i)\n        printf(\"%c\", letters[i]);\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m\n./gen -n 1 -m 1 -tree_type chain -letter_type all_same -query_type random\n./gen -n 5 -m 5 -tree_type chain -letter_type all_same -query_type random\n./gen -n 5 -m 5 -tree_type star -letter_type random -query_type random\n./gen -n 5 -m 5 -tree_type random -letter_type alternating -query_type random\n./gen -n 10 -m 10 -tree_type balanced -letter_type random -query_type random\n\n# Medium n and m\n./gen -n 1000 -m 1000 -tree_type chain -letter_type all_same -query_type random\n./gen -n 1000 -m 1000 -tree_type random -letter_type random -query_type random\n./gen -n 1000 -m 1000 -tree_type star -letter_type alternating -query_type random\n./gen -n 1000 -m 1000 -tree_type balanced -letter_type palindromic_depths -query_type random\n\n# Large n and m with different tree types\n./gen -n 500000 -m 500000 -tree_type chain -letter_type all_same -query_type random\n./gen -n 500000 -m 500000 -tree_type chain -letter_type all_same -query_type nonexistent_depth\n./gen -n 500000 -m 500000 -tree_type chain -letter_type all_same -query_type same_node\n./gen -n 500000 -m 500000 -tree_type star -letter_type random -query_type random\n./gen -n 500000 -m 500000 -tree_type balanced -letter_type palindromic_depths -query_type max_depth\n./gen -n 500000 -m 500000 -tree_type random -letter_type random -query_type random\n\n# Edge cases\n./gen -n 500000 -m 500000 -tree_type skewed -letter_type random -query_type random\n./gen -n 500000 -m 500000 -tree_type random -letter_type all_same -query_type min_depth\n./gen -n 500000 -m 500000 -tree_type balanced -letter_type palindromic_depths -query_type max_depth\n./gen -n 500000 -m 500000 -tree_type random -letter_type random -query_type random\n./gen -n 500000 -m 500000 -tree_type balanced -letter_type palindromic_depths -query_type same_node\n\n# Different letter types\n./gen -n 500000 -m 500000 -tree_type random -letter_type all_same -query_type random\n./gen -n 500000 -m 500000 -tree_type random -letter_type alternating -query_type random\n\n# All Yes test cases\n./gen -n 500000 -m 500000 -tree_type random -letter_type all_same -query_type random\n\n# All No test cases\n./gen -n 500000 -m 500000 -tree_type random -letter_type unique -query_type random\n\n# Nonexistent depths\n./gen -n 500000 -m 500000 -tree_type random -letter_type random -query_type nonexistent_depth\n\n# Max m but small n\n./gen -n 10 -m 500000 -tree_type random -letter_type random -query_type random\n\n# Max n but small m\n./gen -n 500000 -m 10 -tree_type random -letter_type random -query_type random\n\n# Repeated same node in queries\n./gen -n 500000 -m 500000 -tree_type random -letter_type random -query_type same_node\n\n# Random everything\n./gen -n 500000 -m 500000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:40.742934",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "570/E",
      "title": "E. Свинка и палиндромы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся два целых числа n, m (1 ≤ n, m ≤ 500) — высота и ширина поля.В следующих n строках находится по m строчных английских букв, обозначающих виды клеток леса. Одинаковым клеткам соответствуют одинаковые буквы, разным — разные.",
      "output_spec": "Выходные данныеВыведите одно целое число — количество красивых путей по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 4aaabbaaaabbaВыходные данныеСкопировать3",
      "description": "E. Свинка и палиндромы\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся два целых числа n, m (1 ≤ n, m ≤ 500) — высота и ширина поля.В следующих n строках находится по m строчных английских букв, обозначающих виды клеток леса. Одинаковым клеткам соответствуют одинаковые буквы, разным — разные.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — количество красивых путей по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать3 4aaabbaaaabbaВыходные данныеСкопировать3\n\nВходные данныеСкопировать3 4aaabbaaaabba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснение к первому тесту из условия.",
      "solutions": [
        {
          "title": "Codeforces Round #316 (Div. 2) - Codeforces",
          "content": "Доброго всем времени суток!13 августа 2015 года в 19:30 MSK состоится очередной раунд Codeforces #316 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Это мой первый Codeforces раунд. Надеюсь, он вам понравится.Хотелось бы сказать большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено пять задач и два часа на их решение.UPD: Распределение баллов по задачам 500-1000-1500-2000-2500Желаю всем участникам удачи!UPD: Всем спасибо за участие!Поздравляем победителей!Разбор",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19753",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 734
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces",
          "content": "570А — Выборы РеализацияДля каждого города определим: за кого он голосует. Просуммируем для каждого кандидата и определим победителя.O(n * m)Решение570B — Простая игра Математика, разбор случаевПоймем, какие ходы интересные. Заметим, что Андрею нет смысла делать ход, при котором |a–m| > 1 так, как мы можем увеличить вероятность победы, если подвинем число a ближе к m. Таким образом, мы рассматриваем два варианта хода a = c–1 и a = c + 1. Вероятность победы в первом случае c / n, во втором (n–c + 1) / n. Выбираем наилучший вариант. Нужно помнить про случай n = 1.O(1)Решение570C — ЗаменыРазбор случаев, (возможно) структурыРассмотрим, как происходят замены. Если был отрезок из точек длины l, то мы потратим l–1 операцию и прекратим замены для этого отрезка. Если просуммировать длины всех отрезков и их количества, то ответ это суммарная длина минус количество отрезков. После изменения одного типа символа длина изменятся на 1. Количество отрезков можно поддерживать при помощи массива. Рассмотрим события слияния, деление, появление и удаление отрезков. Для слияния смотрим на правого и левого соседа. Если они являются точками, то произошло слияние и количество отрезков уменьшилось на 1. Остальные случаи аналогично можно разобрать. O(n + m)Решение570D — Деревянные запросыDFS, бинарный поискЗапишем вершины в порядке DFS от корня для вершин каждой глубины отдельно, храним время входа/выхода из вершины в DFS. Все вершины находящиеся в поддереве v, в такой записи представляют отрезок. Теперь мы умеем получать все вершины в v на высоте h, в виде отрезка, делая два бинарных поиска. Палиндром можно составить, если количество нечетных вхождений каждой буквы меньше 2. Эту функцию можно посчитать для каждого префикса в обходе на каждой глубине отдельно. Для экономии памяти можно воспользоваться битовым сжатием, поняв, что нас интересует только четность и функция – это xor. O(m * (logn + 26) + n) – времени O(n * 26) — памяти, существует оффлайн решение за O(m * 26 / 32 + n) и O(n * 26 / 8) памятиРешение570E — Свинка и палиндромыДПНас интересуют пути являющиеся палиндромами. Палиндром читается с начала и с конца одинаково. Воспользуемся этим. Считаем динамику от координат двух клеток, первой и последней в палиндроме. Из каждого состояние есть 4 перехода (комбинации: первая клетка вниз/вправо и вторая клетка вверх/влево). Нас интересуют переходы только по равным символам, по свойству палиндрома. Заметим, что нас интересуют пары клеток находящихся на одинаковом расстоянии от начала и конца соответственно. Если у первой клетки координаты (x1;y1), у последней (x2;y2), то x1 + y1 = n + m - x2 - y2.Чтоб сэкономить память воспользуемся идеей хранить 2 последних слоя. O(n3) – времени и O(n2) — памятиРешение",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19770",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 570\\s*E"
          },
          "content_length": 2727
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #316 (Div. 2) - Codeforces - Code 1",
          "code": "Если таких значений несколько, выведите минимальное из них.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19753",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 1",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 2",
          "code": "f(x1, y1, x2, y2) :\n  if S[x1][y1] != S[x2][y2] : return 0\n  if x1 > x2 or y1 > y2 : return 0\n\n  // include the base case when have two neighbouring cells or single cell\n  // if neighbouring cells have same value return 1\n  // else return 0\n\n  ans = 0\n  ans = ans + f(x1 + 1, y1, x2 - 1, y2)\n  ans = ans + f(x1, y1 + 1, x2 - 1, y2)\n  ans = ans + f(x1 + 1, y1, x2, y2 - 1)\n  ans = ans + f(x1, y1 + 1, x2, y2 - 1)\n  return ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 3",
          "code": "else if (t == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 4",
          "code": "else if (t == 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 5",
          "code": "default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 6",
          "code": "default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 7",
          "code": "edges[v].forEach(v2 -> dfs(v2, lvl + 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 8",
          "code": "edges[v].forEach(v2 -> dfs(v2, lvl + 1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 9",
          "code": "for (int v2 : edges[v]) {\n            dfs(v2, lvl + 1);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 10",
          "code": "for (int v2 : edges[v]) {\n            dfs(v2, lvl + 1);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #316 Editorial - Codeforces - Code 11",
          "code": "O(nlog(n) + 26m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19770",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + vtos(m) + \"}\";\n    for (int i = 0; i < n; ++i){\n        string s = inf.readLine(pattern, \"row \" + vtos(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + vtos(m) + \"}\";\n    for (int i = 0; i < n; ++i){\n        string s = inf.readLine(pattern, \"row \" + vtos(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + vtos(m) + \"}\";\n    for (int i = 0; i < n; ++i){\n        string s = inf.readLine(pattern, \"row \" + vtos(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<string> grid(n, string(m, 'a'));\n\n    if (type == \"same\") {\n        /* All cells have the same letter */\n        char c = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, c);\n        }\n    } else if (type == \"horizontal\") {\n        /* Each row has the same letter, different from other rows */\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            grid[i] = string(m, c);\n        }\n    } else if (type == \"vertical\") {\n        /* Each column has the same letter, different from other columns */\n        for (int j = 0; j < m; ++j) {\n            char c = 'a' + (j % 26);\n            for (int i = 0; i < n; ++i) {\n                grid[i][j] = c;\n            }\n        }\n    } else if (type == \"max_palindromic\") {\n        /* Grid designed to maximize the number of beautiful paths */\n        grid.assign(n, string(m, 0));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 0) {\n                    char c = 'a' + rnd.next(26);\n                    grid[i][j] = c;\n                    grid[n - i -1][m - j -1] = c;\n                }\n            }\n        }\n    } else {\n        /* Random grid */\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += (char)('a' + rnd.next(26));\n            }\n        }\n    }\n\n    /* Output n and m */\n    printf(\"%d %d\\n\", n, m);\n\n    /* Output grid */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<string> grid(n, string(m, 'a'));\n\n    if (type == \"same\") {\n        /* All cells have the same letter */\n        char c = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, c);\n        }\n    } else if (type == \"horizontal\") {\n        /* Each row has the same letter, different from other rows */\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            grid[i] = string(m, c);\n        }\n    } else if (type == \"vertical\") {\n        /* Each column has the same letter, different from other columns */\n        for (int j = 0; j < m; ++j) {\n            char c = 'a' + (j % 26);\n            for (int i = 0; i < n; ++i) {\n                grid[i][j] = c;\n            }\n        }\n    } else if (type == \"max_palindromic\") {\n        /* Grid designed to maximize the number of beautiful paths */\n        grid.assign(n, string(m, 0));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 0) {\n                    char c = 'a' + rnd.next(26);\n                    grid[i][j] = c;\n                    grid[n - i -1][m - j -1] = c;\n                }\n            }\n        }\n    } else {\n        /* Random grid */\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += (char)('a' + rnd.next(26));\n            }\n        }\n    }\n\n    /* Output n and m */\n    printf(\"%d %d\\n\", n, m);\n\n    /* Output grid */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small sizes\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type same\n./gen -n 1 -m 1 -type horizontal\n./gen -n 1 -m 1 -type vertical\n./gen -n 1 -m 1 -type max_palindromic\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type same\n./gen -n 2 -m 2 -type horizontal\n./gen -n 2 -m 2 -type vertical\n./gen -n 2 -m 2 -type max_palindromic\n\n./gen -n 3 -m 3 -type random\n./gen -n 3 -m 3 -type same\n./gen -n 3 -m 3 -type horizontal\n./gen -n 3 -m 3 -type vertical\n./gen -n 3 -m 3 -type max_palindromic\n\n# Medium sizes\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type same\n./gen -n 10 -m 10 -type horizontal\n./gen -n 10 -m 10 -type vertical\n./gen -n 10 -m 10 -type max_palindromic\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type same\n./gen -n 100 -m 100 -type horizontal\n./gen -n 100 -m 100 -type vertical\n./gen -n 100 -m 100 -type max_palindromic\n\n# Maximum sizes\n./gen -n 500 -m 500 -type random\n./gen -n 500 -m 500 -type same\n./gen -n 500 -m 500 -type horizontal\n./gen -n 500 -m 500 -type vertical\n./gen -n 500 -m 500 -type max_palindromic\n\n# Other combinations\n./gen -n 1 -m 500 -type random\n./gen -n 1 -m 500 -type same\n./gen -n 1 -m 500 -type horizontal\n./gen -n 1 -m 500 -type vertical\n./gen -n 1 -m 500 -type max_palindromic\n\n./gen -n 500 -m 1 -type random\n./gen -n 500 -m 1 -type same\n./gen -n 500 -m 1 -type horizontal\n./gen -n 500 -m 1 -type vertical\n./gen -n 500 -m 1 -type max_palindromic\n\n# Uneven sizes\n./gen -n 300 -m 500 -type random\n./gen -n 500 -m 300 -type random\n./gen -n 200 -m 400 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:42.937865",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "571/A",
      "title": "A. Удлинение палочек",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке задано 4 целых числа a, b, c, l (1 ≤ a, b, c ≤ 3·105, 0 ≤ l ≤ 3·105).",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество способов увеличить размеры палочек в сумме не больше, чем на l сантиметров, так, чтобы из них можно было составить невырожденный треугольник.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1 1 2Выходные данныеСкопировать4Входные данныеСкопировать1 2 3 1Выходные данныеСкопировать2Входные данныеСкопировать10 2 1 7Выходные данныеСкопировать0",
      "description": "A. Удлинение палочек\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке задано 4 целых числа a, b, c, l (1 ≤ a, b, c ≤ 3·105, 0 ≤ l ≤ 3·105).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество способов увеличить размеры палочек в сумме не больше, чем на l сантиметров, так, чтобы из них можно было составить невырожденный треугольник.\n\nВыходные данные\n\nВходные данныеСкопировать1 1 1 2Выходные данныеСкопировать4Входные данныеСкопировать1 2 3 1Выходные данныеСкопировать2Входные данныеСкопировать10 2 1 7Выходные данныеСкопировать0\n\nВходные данныеСкопировать1 1 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 2 1 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия можно не увеличивать ни одну из палочек, либо увеличить любые две палочки на 1 сантиметр.Во втором тесте из условия можно увеличить либо первую, либо вторую палочку на один сантиметр. Обратите внимание, что треугольник, составленный из исходных палочек, является вырожденным, и поэтому не подходит.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Привет, Codeforces!22 августа, в субботу, в 19:30 MSK состоится 317 раунд Codeforces.Раунд подготовили для вас сотрудники компании AimFund: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina и zeliboba.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Макса Ахмедова (Zlobober) и Марию Белову (Delinur) за перевод условий на английский.В первом дивизионе будет разыграно 200 футболок c символикой нашей компании. Прочитать подробнее про нас и наши вакансии можно на сайте aimfund.ru и в анонсе этого раунда.Этот раунд подготовлен в рамках программы \"5 лет CodeForces\", как часть нашего подарка сообществу. С этого раунда на CF начинается серия thanks-раундов, которые посвящаются людям и компаниям, пожертвовавшим значительные средства.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в четверг в 8 вечера будет организован фуршет в Пауланер Бройхаус.P.P.S. Разбалловка: 1 дивизион 750-1250-1500-2000-2750, 2 дивизион 500-1000-1750-2250-2500P.P.P.S. Топ-20 участников второго дивизиона также получат футболки.РазборP.P.P.P.S. Друзья, с большим удовольствием сообщаем вам, что мы начинаем отправку наших фирменных футболок их счастливым обладателям по всему миру. Надеемся, что они вам понравятся, и вы будете носить их с удовольствием :)",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1466
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 571\\s*A"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "В течение месяца мы планируем провести свой раунд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "Мы не имеем четкого Великого-Свода-Правил-Поведения-На-Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 8",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 9",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 300000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 300000, \"c\");\n    inf.readSpace();\n    int l = inf.readInt(0, 300000, \"l\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 300000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 300000, \"c\");\n    inf.readSpace();\n    int l = inf.readInt(0, 300000, \"l\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 300000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 300000, \"c\");\n    inf.readSpace();\n    int l = inf.readInt(0, 300000, \"l\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_value = 300000;\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    int l = opt<int>(\"l\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (a == -1) a = rnd.next(1, max_value);\n    if (b == -1) b = rnd.next(1, max_value);\n    if (c == -1) c = rnd.next(1, max_value);\n    if (l == -1) l = rnd.next(0, max_value);\n\n    if (type == \"minimal\") {\n        a = b = c = 1;\n        l = 0;\n    } else if (type == \"maximal\") {\n        a = b = c = max_value;\n        l = max_value;\n    } else if (type == \"equal\") {\n        a = b = c = rnd.next(1, max_value);\n        // Use provided l or generate a random one\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value);\n    } else if (type == \"iso\") {\n        a = b = rnd.next(1, max_value);\n        do {\n            c = rnd.next(1, max_value);\n        } while (c == a);\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value);\n    } else if (type == \"degenerate\") {\n        a = rnd.next(1, max_value / 2);\n        b = rnd.next(1, max_value / 2);\n        c = a + b;\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value);\n    } else if (type == \"infeasible\") {\n        a = 1;\n        b = 1;\n        c = max_value;\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value / 10);\n    } else if (type == \"l_zero\") {\n        a = rnd.next(1, max_value);\n        b = rnd.next(1, max_value);\n        c = rnd.next(1, max_value);\n        l = 0;\n    }\n\n    printf(\"%d %d %d %d\\n\", a, b, c, l);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_value = 300000;\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    int l = opt<int>(\"l\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (a == -1) a = rnd.next(1, max_value);\n    if (b == -1) b = rnd.next(1, max_value);\n    if (c == -1) c = rnd.next(1, max_value);\n    if (l == -1) l = rnd.next(0, max_value);\n\n    if (type == \"minimal\") {\n        a = b = c = 1;\n        l = 0;\n    } else if (type == \"maximal\") {\n        a = b = c = max_value;\n        l = max_value;\n    } else if (type == \"equal\") {\n        a = b = c = rnd.next(1, max_value);\n        // Use provided l or generate a random one\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value);\n    } else if (type == \"iso\") {\n        a = b = rnd.next(1, max_value);\n        do {\n            c = rnd.next(1, max_value);\n        } while (c == a);\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value);\n    } else if (type == \"degenerate\") {\n        a = rnd.next(1, max_value / 2);\n        b = rnd.next(1, max_value / 2);\n        c = a + b;\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value);\n    } else if (type == \"infeasible\") {\n        a = 1;\n        b = 1;\n        c = max_value;\n        if (opt<int>(\"l\", -1) == -1) l = rnd.next(0, max_value / 10);\n    } else if (type == \"l_zero\") {\n        a = rnd.next(1, max_value);\n        b = rnd.next(1, max_value);\n        c = rnd.next(1, max_value);\n        l = 0;\n    }\n\n    printf(\"%d %d %d %d\\n\", a, b, c, l);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n./gen -type maximal\n./gen -type equal -l 0\n./gen -type equal -l 100\n./gen -type equal -l 300000\n./gen -type iso -l 0\n./gen -type iso -l 100\n./gen -type iso -l 300000\n./gen -type degenerate -l 0\n./gen -type degenerate -l 100\n./gen -type infeasible -l 0\n./gen -type infeasible -l 10\n./gen -type l_zero\n./gen -type random -l 300000\n./gen -type random -l 200000\n./gen -type random -l 100000\n./gen -type random -l 0\n./gen -type random -l 1\n./gen -a 1 -b 1 -c 1 -l 2\n./gen -a 1 -b 2 -c 3 -l 1\n./gen -a 10 -b 2 -c 1 -l 7\n./gen -a 1 -b 1 -c 2 -l 100000\n./gen -a 1 -b 1 -c 100000 -l 300000\n./gen -a 1 -b 1 -c 1 -l 300000\n./gen -a 100000 -b 200000 -c 300000 -l 0\n./gen -a 100000 -b 200000 -c 300000 -l 300000\n./gen -type equal\n./gen -type equal\n./gen -type iso\n./gen -type iso\n./gen -type degenerate\n./gen -type degenerate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:45.246060",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "571/B",
      "title": "B. Минимизация",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n, k (2 ≤ n ≤ 3·105, 1 ≤ k ≤ min(5000, n - 1)). Во второй строке следуют n целых чисел A[1], A[2], ..., A[n] ( - 109 ≤ A[i] ≤ 109), разделенных пробелами — элементы массива A.",
      "output_spec": "Выходные данныеВыведите минимальное возможное значение суммы, описанной в условии задачи.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 21 2 4Выходные данныеСкопировать1Входные данныеСкопировать5 23 -5 3 -5 3Выходные данныеСкопировать0Входные данныеСкопировать6 34 3 4 3 2 5Выходные данныеСкопировать3",
      "description": "B. Минимизация\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке заданы два целых числа n, k (2 ≤ n ≤ 3·105, 1 ≤ k ≤ min(5000, n - 1)). Во второй строке следуют n целых чисел A[1], A[2], ..., A[n] ( - 109 ≤ A[i] ≤ 109), разделенных пробелами — элементы массива A.\n\nВходные данные\n\nВыходные данныеВыведите минимальное возможное значение суммы, описанной в условии задачи.\n\nВыходные данные\n\nВходные данныеСкопировать3 21 2 4Выходные данныеСкопировать1Входные данныеСкопировать5 23 -5 3 -5 3Выходные данныеСкопировать0Входные данныеСкопировать6 34 3 4 3 2 5Выходные данныеСкопировать3\n\nВходные данныеСкопировать3 21 2 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 23 -5 3 -5 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 34 3 4 3 2 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте одна из оптимальных перестановок имеет вид 1 4 2. Во втором тесте исходная перестановка является оптимальной. В третьем тесте одна из оптимальных перестановок имеет вид 2 3 4 4 3 5.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Привет, Codeforces!22 августа, в субботу, в 19:30 MSK состоится 317 раунд Codeforces.Раунд подготовили для вас сотрудники компании AimFund: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina и zeliboba.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Макса Ахмедова (Zlobober) и Марию Белову (Delinur) за перевод условий на английский.В первом дивизионе будет разыграно 200 футболок c символикой нашей компании. Прочитать подробнее про нас и наши вакансии можно на сайте aimfund.ru и в анонсе этого раунда.Этот раунд подготовлен в рамках программы \"5 лет CodeForces\", как часть нашего подарка сообществу. С этого раунда на CF начинается серия thanks-раундов, которые посвящаются людям и компаниям, пожертвовавшим значительные средства.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в четверг в 8 вечера будет организован фуршет в Пауланер Бройхаус.P.P.S. Разбалловка: 1 дивизион 750-1250-1500-2000-2750, 2 дивизион 500-1000-1750-2250-2500P.P.P.S. Топ-20 участников второго дивизиона также получат футболки.РазборP.P.P.P.S. Друзья, с большим удовольствием сообщаем вам, что мы начинаем отправку наших фирменных футболок их счастливым обладателям по всему миру. Надеемся, что они вам понравятся, и вы будете носить их с удовольствием :)",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1466
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 571\\s*B"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "В течение месяца мы планируем провести свой раунд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "Мы не имеем четкого Великого-Свода-Правил-Поведения-На-Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 8",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 9",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int max_k = min(5000, n - 1);\n    int k = inf.readInt(1, max_k, \"k\");\n    inf.readEoln();\n    \n    vector<int> A = inf.readInts(n, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int max_k = min(5000, n - 1);\n    int k = inf.readInt(1, max_k, \"k\");\n    inf.readEoln();\n    \n    vector<int> A = inf.readInts(n, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int max_k = min(5000, n - 1);\n    int k = inf.readInt(1, max_k, \"k\");\n    inf.readEoln();\n    \n    vector<int> A = inf.readInts(n, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 1000000000); // default 1e9\n    int value = opt<int>(\"value\", 0); // for \"all_same\" type\n    \n    vector<int> A(n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"all_same\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = value;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n        sort(A.begin(), A.end());\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n        sort(A.begin(), A.end(), greater<int>());\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = 0;\n        }\n    } else if (type == \"positive\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"negative\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, -1);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                A[i] = rnd.next(1, maxA);\n            else\n                A[i] = rnd.next(-maxA, -1);\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n    }\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", A[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 1000000000); // default 1e9\n    int value = opt<int>(\"value\", 0); // for \"all_same\" type\n    \n    vector<int> A(n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"all_same\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = value;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n        sort(A.begin(), A.end());\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n        sort(A.begin(), A.end(), greater<int>());\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = 0;\n        }\n    } else if (type == \"positive\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"negative\") {\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, -1);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                A[i] = rnd.next(1, maxA);\n            else\n                A[i] = rnd.next(-maxA, -1);\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(-maxA, maxA);\n        }\n    }\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", A[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 1 -type all_same -value 0\n./gen -n 2 -k 1 -type zeros\n./gen -n 2 -k 1 -type random\n\n./gen -n 10 -k 1 -type increasing\n./gen -n 10 -k 1 -type decreasing\n./gen -n 10 -k 5 -type mixed\n\n./gen -n 100 -k 1 -type random\n./gen -n 100 -k 50 -type random\n\n./gen -n 5000 -k 1 -type random\n./gen -n 5000 -k 4999 -type random\n./gen -n 5000 -k 4999 -type positive\n./gen -n 5000 -k 4999 -type negative\n./gen -n 5000 -k 2500 -type mixed\n./gen -n 5000 -k 1 -type all_same -value 1\n\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 5000 -type random\n\n./gen -n 300000 -k 1 -type random\n./gen -n 300000 -k 5000 -type random\n./gen -n 300000 -k 5000 -type positive\n./gen -n 300000 -k 5000 -type negative\n./gen -n 300000 -k 1 -type increasing\n./gen -n 300000 -k 1 -type decreasing\n./gen -n 300000 -k 5000 -type zeros\n./gen -n 300000 -k 4999 -type random\n./gen -n 300000 -k 3000 -type mixed\n./gen -n 300000 -k 5000 -type all_same -value -1000000000\n./gen -n 300000 -k 5000 -type all_same -value 1000000000\n./gen -n 300000 -k 5000 -type random -maxA 100\n./gen -n 300000 -k 1 -type random -maxA 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:47.459845",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "571/C",
      "title": "C. CNF 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and m (1 ≤ n, m ≤ 2·105) — the number of clauses and the number variables, correspondingly.Next n lines contain the descriptions of each clause. The i-th line first contains first number ki (ki ≥ 1) — the number of literals in the i-th clauses. Then follow space-separated literals vij (1 ≤ |vij| ≤ m). A literal that corresponds to vij is x|vij| either with negation, if vij is negative, or without negation otherwise.",
      "output_spec": "OutputIf CNF is not satisfiable, print a single line \"NO\" (without the quotes), otherwise print two strings: string \"YES\" (without the quotes), and then a string of m numbers zero or one — the values of variables in satisfying assignment in the order from x1 to xm.",
      "sample_tests": "ExamplesInputCopy2 22 1 -22 2 -1OutputCopyYES11InputCopy4 31 11 23 -1 -2 31 -3OutputCopyNOInputCopy5 62 1 23 1 -2 34 -3 5 4 62 -6 -41 5OutputCopyYES100010",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers n and m (1 ≤ n, m ≤ 2·105) — the number of clauses and the number variables, correspondingly.Next n lines contain the descriptions of each clause. The i-th line first contains first number ki (ki ≥ 1) — the number of literals in the i-th clauses. Then follow space-separated literals vij (1 ≤ |vij| ≤ m). A literal that corresponds to vij is x|vij| either with negation, if vij is negative, or without negation otherwise.\n\nOutputIf CNF is not satisfiable, print a single line \"NO\" (without the quotes), otherwise print two strings: string \"YES\" (without the quotes), and then a string of m numbers zero or one — the values of variables in satisfying assignment in the order from x1 to xm.\n\nInputCopy2 22 1 -22 2 -1OutputCopyYES11InputCopy4 31 11 23 -1 -2 31 -3OutputCopyNOInputCopy5 62 1 23 1 -2 34 -3 5 4 62 -6 -41 5OutputCopyYES100010\n\nInputCopy2 22 1 -22 2 -1\n\nOutputCopyYES11\n\nInputCopy4 31 11 23 -1 -2 31 -3\n\nOutputCopyNO\n\nInputCopy5 62 1 23 1 -2 34 -3 5 4 62 -6 -41 5\n\nOutputCopyYES100010\n\nNoteIn the first sample test formula is . One of possible answer is x1 = TRUE, x2 = TRUE.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round 317 will take place on August, 22 at 19:30 MSK.The round is prepared by AimFund employees: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina and zeliboba.Scoring system will be static. Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Max Akhmedov (Zlobober) and Maria Belova (Delinur) for English translation.Top 200 div1 participants will be awarded t-shirts. To learn more about AimFund please refer to our previous post.This round is prepared as part of \"5 years\" Codeforces program as our present to community. This round is the first Thanks-Round devoted to companies donated significant money.We wish you good luck and high frequency rating!P.S: scoring 1 div 750-1250-1500-2000-2750. 2 div 500-1000-1750-2250-2500P.P.S. Top-20 div2 participants will be awarded t-shirts.AnalysisP.P.P.S. Dear friends. We are pleased to inform you that t shirts delivery will be under way next week. We hope you will really like them. Our sincere congrats again to you all!",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1067
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 571\\s*C"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> variable_count(m + 1, 0); // Index from 1 to m\n    long long total_literals = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(1, 200000, \"k_i\");\n        total_literals += ki;\n        ensuref(total_literals <= 400000, \"Total number of literals exceeds 400000\");\n\n        if (ki > 0) {\n            inf.readSpace();\n        }\n\n        set<int> variables_in_clause;\n\n        for (int j = 0; j < ki; ++j) {\n            int vij = inf.readInt(-m, m, \"v_ij\");\n            ensuref(vij != 0, \"vij cannot be zero\");\n\n            int var_index = abs(vij);\n\n            ensuref(variables_in_clause.count(var_index) == 0,\n                    \"Variable %d occurs more than once in clause %d\", var_index, i + 1);\n            variables_in_clause.insert(var_index);\n\n            variable_count[var_index]++;\n            ensuref(variable_count[var_index] <= 2,\n                    \"Variable %d occurs more than twice\", var_index);\n\n            if (j < ki - 1) {\n                inf.readSpace();\n            }\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> variable_count(m + 1, 0); // Index from 1 to m\n    long long total_literals = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(1, 200000, \"k_i\");\n        total_literals += ki;\n        ensuref(total_literals <= 400000, \"Total number of literals exceeds 400000\");\n\n        if (ki > 0) {\n            inf.readSpace();\n        }\n\n        set<int> variables_in_clause;\n\n        for (int j = 0; j < ki; ++j) {\n            int vij = inf.readInt(-m, m, \"v_ij\");\n            ensuref(vij != 0, \"vij cannot be zero\");\n\n            int var_index = abs(vij);\n\n            ensuref(variables_in_clause.count(var_index) == 0,\n                    \"Variable %d occurs more than once in clause %d\", var_index, i + 1);\n            variables_in_clause.insert(var_index);\n\n            variable_count[var_index]++;\n            ensuref(variable_count[var_index] <= 2,\n                    \"Variable %d occurs more than twice\", var_index);\n\n            if (j < ki - 1) {\n                inf.readSpace();\n            }\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> variable_count(m + 1, 0); // Index from 1 to m\n    long long total_literals = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(1, 200000, \"k_i\");\n        total_literals += ki;\n        ensuref(total_literals <= 400000, \"Total number of literals exceeds 400000\");\n\n        if (ki > 0) {\n            inf.readSpace();\n        }\n\n        set<int> variables_in_clause;\n\n        for (int j = 0; j < ki; ++j) {\n            int vij = inf.readInt(-m, m, \"v_ij\");\n            ensuref(vij != 0, \"vij cannot be zero\");\n\n            int var_index = abs(vij);\n\n            ensuref(variables_in_clause.count(var_index) == 0,\n                    \"Variable %d occurs more than once in clause %d\", var_index, i + 1);\n            variables_in_clause.insert(var_index);\n\n            variable_count[var_index]++;\n            ensuref(variable_count[var_index] <= 2,\n                    \"Variable %d occurs more than twice\", var_index);\n\n            if (j < ki - 1) {\n                inf.readSpace();\n            }\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<vector<int>> clauses;\n\n// Function to read the answer from a stream and set isSat and assignment accordingly\nvoid readAns(InStream& stream, bool& isSat, vector<int>& assignment) {\n    string verdict = stream.readToken();\n    if (verdict == \"NO\") {\n        isSat = false;\n    } else if (verdict == \"YES\") {\n        isSat = true;\n        string var_values = stream.readToken();\n        if (int(var_values.length()) != m)\n            stream.quitf(_wa, \"Expected variable assignment of length %d, got length %d\", m, var_values.length());\n        assignment.resize(m);\n        for (int i = 0; i < m; i++) {\n            if (var_values[i] != '0' && var_values[i] != '1') {\n                stream.quitf(_pe, \"Invalid variable assignment at position %d: expected '0' or '1', got '%c'\", i + 1, var_values[i]);\n            }\n            assignment[i] = var_values[i] - '0';\n        }\n    } else {\n        stream.quitf(_pe, \"Invalid verdict: expected 'YES' or 'NO', got '%s'\", verdict.c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input clauses\n    n = inf.readInt(1, 200000, \"n\");\n    m = inf.readInt(1, 200000, \"m\");\n    clauses.resize(n);\n    int total_literals = 0;\n    for (int i = 0; i < n; ++i) {\n        int k = inf.readInt(1, 500000, format(\"k[%d]\", i + 1).c_str());\n        clauses[i].resize(k);\n        total_literals += k;\n        for (int j = 0; j < k; ++j) {\n            int vij = inf.readInt(-m, m, format(\"v[%d][%d]\", i + 1, j + 1).c_str());\n            if (vij == 0) {\n                inf.quitf(_fail, \"Literal vij cannot be 0\");\n            }\n            clauses[i][j] = vij;\n        }\n    }\n    if (total_literals > 500000) {\n        inf.quitf(_fail, \"Total number of literals exceeds the limit: total_literals = %d\", total_literals);\n    }\n\n    // Read jury's answer\n    bool isSatJury;\n    vector<int> assignmentJury;\n    readAns(ans, isSatJury, assignmentJury);\n\n    // Read contestant's answer\n    bool isSatContestant;\n    vector<int> assignmentContestant;\n    readAns(ouf, isSatContestant, assignmentContestant);\n\n    // Compare verdicts and check correctness\n    if (!isSatJury && !isSatContestant) {\n        quitf(_ok, \"Correct: both state unsatisfiable\");\n    }\n    if (!isSatJury && isSatContestant) {\n        quitf(_wa, \"Contestant claims satisfiable, but jury claims unsatisfiable\");\n    }\n    if (isSatJury && !isSatContestant) {\n        quitf(_wa, \"Contestant claims unsatisfiable, but jury provides satisfying assignment\");\n    }\n    if (isSatContestant) {\n        // Verify contestant's assignment\n        for (int i = 0; i < n; ++i) {\n            bool clauseSatisfied = false;\n            for (int vij : clauses[i]) {\n                int var = abs(vij);\n                int val = assignmentContestant[var - 1];\n                bool literalValue = (vij > 0) ? (val == 1) : (val == 0);\n                if (literalValue) {\n                    clauseSatisfied = true;\n                    break;\n                }\n            }\n            if (!clauseSatisfied) {\n                quitf(_wa, \"Clause %d is not satisfied by contestant's assignment\", i + 1);\n            }\n        }\n        quitf(_ok, \"Correct: contestant's assignment satisfies the formula\");\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test (n clauses, m variables) for the CNF\n  satisfiability problem described. The key constraint is that each variable\n  (1..m) may appear in at most 2 clauses total (whether negated or unnegated),\n  and that within any single clause, the same variable cannot appear twice.\n\n  The generator has several modes (controlled by the \"type\" parameter):\n  1) \"random\"  : Generates a larger random CNF (up to n clauses, m variables),\n                 with each variable appearing up to 2 times in total.\n  2) \"small\"   : Generates a small random instance with n and m very small.\n  3) \"sat\"     : Generates a simple, guaranteed satisfiable formula.\n  4) \"unsat\"   : Generates a simple, guaranteed unsatisfiable formula.\n  5) \"unit\"    : Generates only unit clauses.\n  6) \"special\" : Generates a small formula covering corner cases\n                 (e.g. single-literal, repeated variables, etc.).\n\n  Parameters:\n    -n <int> : number of clauses\n    -m <int> : number of variables\n    -type <string> : generation mode (listed above; default \"random\")\n\n  IMPORTANT:\n   - We do NOT set or pass a random seed.\n   - We rely on testlib's rnd (instead of std library random).\n   - We ensure each variable appears in at most 2 clauses total.\n   - We ensure that within a clause, no variable is repeated.\n   - We ensure n, m, and the resulting CNF meet problem constraints.\n*/\n\nstatic void printCNF(int n, int m, const vector<vector<int>> &clauses) {\n    // Output:\n    // First line: n m\n    // Next n lines: ki, then ki literals\n    // Each literal is in the range [ -m, -1 ] union [1, m ].\n    // ki >= 1\n    printf(\"%d %d\\n\", n, m);\n    for (const auto &c : clauses) {\n        printf(\"%d\", (int)c.size());\n        for (int lit : c) {\n            printf(\" %d\", lit);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Helper: produce a random sign literal for a variable in [1..m].\nstatic int randomLiteralSign(int var) {\n    // with 50% chance return var, with 50% chance return -var\n    if (rnd.next(2)) return var;\n    return -var;\n}\n\n// Generates a random CNF with the constraint that each variable can appear\n// at most twice total (negated or unnegated).\n// We'll attempt to produce a \"larger\" test with possibly bigger n, m.\nstatic void generateRandom(int n, int m) {\n    // We will create up to 2 occurrences for each variable (some might appear 0, 1, or 2 times).\n    // Then we will distribute them across the n clauses, ensuring each clause has at least 1 literal.\n    // Also we ensure that a variable never appears twice in the same clause.\n\n    // If n > 2*m, it's impossible to fill n clauses each with at least 1 literal\n    // and not violate the \"each variable appears at most 2 times\" rule.\n    // If that happens, we reduce n to 2*m (if it’s not zero).\n    if (2 * (long long)m < n) {\n        // If the user requests an impossible combination, clamp n.\n        n = max(1, 2*m); \n    }\n\n    // Decide how many times each variable occurs: 0, 1, or 2\n    // We'll store all the literal references in a vector.\n    vector<int> literalPool;\n    literalPool.reserve(2 * m);\n    for(int var = 1; var <= m; var++){\n        // random choices for how many times to appear\n        // we want to ensure total occurrences >= n so every clause can have at least 1 lit\n        // so let's do a random distribution: 0,1,2 equally, then if total < n, we fix it\n        int c = rnd.next(3); // 0,1,2\n        for(int i = 0; i < c; i++){\n            // each occurrence gets a random sign\n            literalPool.push_back(randomLiteralSign(var));\n        }\n    }\n    // If we didn't get enough references (literalPool.size() < n), forcibly add more references\n    // (until we can fill n single-literal clauses).\n    // We'll add them as random variables with random sign, while not exceeding 2 occurrences per var.\n    // For simplicity, let's just keep adding references to random variables that are still under 2 occurrences.\n    // We'll do it until we have at least n references in total. \n    // (We do not guarantee a perfect distribution, but it's enough to comply with constraints.)\n    vector<int> varCount(m+1, 0);\n    for (int lit : literalPool) {\n        varCount[abs(lit)]++;\n    }\n    while ((int)literalPool.size() < n) {\n        int var = rnd.next(1, m);\n        if (varCount[var] < 2) {\n            int lit = randomLiteralSign(var);\n            literalPool.push_back(lit);\n            varCount[var]++;\n        }\n        // If we can't find any variable with <2 usage, we break out to avoid infinite loop\n        // (this can only happen if m < n/2).\n        // Typically we won't get stuck if 2*m >= n.\n        bool allFull = true;\n        for(int i = 1; i <= m; i++){\n            if (varCount[i] < 2){\n                allFull = false; break;\n            }\n        }\n        if(allFull) break;\n    }\n    // Now we have at least n references. We will distribute them into n clauses,\n    // guaranteeing at least 1 literal per clause.\n\n    shuffle(literalPool.begin(), literalPool.end());\n\n    vector<vector<int>> clauses(n);\n    // First, give each clause exactly 1 literal from the front, to ensure no empty clause.\n    int idx = 0;\n    for(int i = 0; i < n; i++){\n        clauses[i].push_back(literalPool[idx++]);\n    }\n    // Next, we try to distribute the remaining references among the clauses randomly,\n    // ensuring we don't put two references of the same variable into the same clause.\n    while (idx < (int)literalPool.size()) {\n        int candidate = literalPool[idx++];\n        int cidx = rnd.next(0, n-1); // pick a random clause\n        // check if variable is already in that clause\n        int v = abs(candidate);\n        bool canUse = true;\n        for (int lit : clauses[cidx]) {\n            if (abs(lit) == v) {\n                canUse = false;\n                break;\n            }\n        }\n        if (canUse) {\n            clauses[cidx].push_back(candidate);\n        }\n        // if we cannot use it in that random clause, we discard it\n        // (this is a simpler approach, though slightly wasteful).\n    }\n\n    // Output the final CNF\n    printCNF(n, m, clauses);\n}\n\n// A small random instance with small n, m (e.g. up to 10).\nstatic void generateSmall() {\n    int n = rnd.next(1, 10);\n    int m = rnd.next(1, 10);\n    // We just do the same random approach but with these small n, m\n    generateRandom(n, m);\n}\n\n// Guaranteed satisfiable: For instance, we can produce a formula with 1 clause\n// that has one literal x1, or produce a set of clauses all containing the same\n// non-negated literal. As long as each variable appears <= 2 times.\nstatic void generateSat(int n, int m) {\n    // If n or m not sensible, adjust them.\n    // We'll create a formula with n clauses, each containing x1 as a positive literal.\n    // That obviously is satisfiable if x1 = TRUE.\n    if (m < 1) m = 1; // we need at least 1 variable\n    if (n < 1) n = 1; // we need at least 1 clause\n    // But each variable can appear up to 2 times. If n > 2, repeating x1 in all\n    // clauses is not allowed! So let's do the following:\n    // - If n=1, put x1 in that single clause.\n    // - If n=2, we can put x1 in both.\n    // - If n>2, we can put x1 in two clauses, and fill the rest with x2 in two clauses,\n    //   x3 in two clauses, etc., until we have n clauses total.\n    // This ensures each variable is used at most 2 times.\n\n    // We'll gather all references in a vector of size n, each is a single-literal clause.\n    vector<vector<int>> clauses(n);\n    int var = 1; \n    int usedCount = 0; // how many times var has been used\n    for(int i = 0; i < n; i++){\n        // If the current var is used 2 times, move to next var\n        if (usedCount == 2) {\n            var++;\n            usedCount = 0;\n            if (var > m) {\n                // if we run out of variables, forcibly re-use the last var anyway\n                // (just to keep a minimal approach, though it might break the \"at most 2 times\" rule\n                // if we strictly keep going. Let's just clamp n to 2*m in practice.)\n                // But to keep it simple, if we exceed, we just clamp i to 2*m.\n                break;\n            }\n        }\n        clauses[i].push_back(var); // single-literal clause: x_var\n        usedCount++;\n    }\n    // If we couldn't create all n single-literal clauses because we ran out of variables,\n    // we clamp the number of clauses to 2*m if needed.\n    int actualN = n;\n    if (var > m && usedCount == 0) {\n        // we used up exactly m variables * 2 times each => 2*m clauses\n        actualN = 2 * m;\n        if (actualN < 1) actualN = 1; // edge case\n        clauses.resize(actualN);\n    }\n\n    printCNF((int)clauses.size(), m, clauses);\n}\n\n// Guaranteed unsatisfiable: A simple example is (x1) & (~x1) with no other clauses.\n// That is unsatisfiable if x1 appears exactly once positively and exactly once negatively.\n// We just need n >= 2, m >= 1, and that variable used exactly twice in total.\nstatic void generateUnsat(int n, int m) {\n    if (m < 1) m = 1;\n    if (n < 2) n = 2;\n\n    // We'll create exactly 2 clauses:\n    //  1) ( x1 )\n    //  2) ( -x1 )\n    // and if n > 2, we fill the rest with something that doesn't break the formula\n    // For example, we can just use single-literal clauses with new variables\n    // that do not appear again, so it remains unsatisfiable due to x1 & ~x1.\n    vector<vector<int>> clauses(n);\n    // Clause 0: ( x1 )\n    clauses[0].push_back(1);\n    // Clause 1: ( -x1 )\n    clauses[1].push_back(-1);\n\n    // Now fill the remaining n-2 clauses with variables x2, x3, ...\n    // but each only once or twice if needed. Because if we do not fill them,\n    // they'll be 0-literal, which is invalid. We'll just assign single-literal clauses.\n    int clauseIndex = 2;\n    int varIndex = 2;\n    while (clauseIndex < n) {\n        // if we run out of variables, just break\n        if (varIndex > m) break;\n        clauses[clauseIndex].push_back(varIndex);\n        clauseIndex++;\n        varIndex++;\n    }\n    // If we still have more clauses beyond what we can fill with unique variables,\n    // we can just clamp n. \n    if (clauseIndex < n) {\n        clauses.resize(clauseIndex); \n    }\n\n    printCNF((int)clauses.size(), m, clauses);\n}\n\n// Generate all unit clauses. This can be interesting for corner cases.\nstatic void generateUnit(int n, int m) {\n    // We want n <= 2*m to be valid, because each variable can appear up to 2 times.\n    if (2 * (long long)m < n) {\n        // clamp if the user asked for too big n\n        n = max(1, 2*m);\n    }\n    // Create n single-literal clauses. Each variable can appear at most twice in total.\n    // We'll do something similar to generateSat with single-literal clauses,\n    // but we won't try to ensure \"satisfiable\" or \"unsatisfiable\" specifically.\n    // We'll simply fill them in a round-robin style.\n    vector<vector<int>> clauses(n);\n    int var = 1;\n    int usage = 0; // how many times current var used\n    for (int i = 0; i < n; i++){\n        // assign a random sign\n        int s = rnd.next(2) ? 1 : -1;\n        clauses[i].push_back(s * var);\n        usage++;\n        if (usage == 2) {\n            var++;\n            usage = 0;\n            if (var > m) break;\n        }\n    }\n    // in case we haven't filled all n because we ran out of variables, clamp\n    if (var > m && usage == 0) {\n        clauses.resize(var*2 - 2);\n    }\n    printCNF((int)clauses.size(), m, clauses);\n}\n\n// A hand-crafted \"special\" mode with multiple corner cases in one test.\nstatic void generateSpecial() {\n    // We'll just create a small-ish example that includes unit clauses, multi-literal clauses,\n    // a variable repeated in two distinct clauses, etc. All in one test.\n\n    // Let n=7, m=5, for instance.\n    int n = 7;\n    int m = 5;\n    // We'll define them manually. But still must be valid: each var appears <= 2 times in total.\n    // Clause 1: x1\n    // Clause 2: (x2 or ~x3)\n    // Clause 3: (~x2 or x1)\n    // Clause 4: (~x5)\n    // Clause 5: (x4)\n    // Clause 6: (x3)\n    // Clause 7: (~x1 or x2 or x5)  // This would be the second occurrence for some variables\n    // We must track usage:\n\n    // usage: x1 -> in clauses 1, 3, 7 (that's 3). Oops, too many. Let's fix it.\n    // Let's do: x1 in clause1, 7 => that's 2 times total\n    // x2 in clause2, 3, 7 => that is 3 times => too many. We must fix that as well.\n    // we can try a small re-shuffle:\n    // let's do:\n    //  c1: ( x1 )                # x1 used once\n    //  c2: ( x2 OR ~x3 )         # x2 used once, x3 used once\n    //  c3: (~x2 OR x4)           # x2 used second time, x4 used once\n    //  c4: (~x5)                 # x5 used once\n    //  c5: ( x4 )                # x4 used second time\n    //  c6: ( x3 )                # x3 used second time\n    //  c7: (~x1 OR x5)           # x1 used second time, x5 used second time\n    // This is valid. Each variable x1..x5 is used exactly 2 times except possibly others.\n\n    vector<vector<int>> clauses;\n    clauses.push_back({ 1 });          // c1:  x1\n    clauses.push_back({ 2, -3 });      // c2:  x2 OR ~x3\n    clauses.push_back({ -2, 4 });      // c3:  ~x2 OR x4\n    clauses.push_back({ -5 });         // c4:  ~x5\n    clauses.push_back({ 4 });          // c5:  x4\n    clauses.push_back({ 3 });          // c6:  x3\n    clauses.push_back({ -1, 5 });      // c7:  ~x1 OR x5\n\n    printCNF((int)clauses.size(), m, clauses);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\", 10);       // default 10\n    int m = opt<int>(\"m\", 10);       // default 10\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        generateRandom(n, m);\n    } \n    else if (type == \"small\") {\n        generateSmall();\n    }\n    else if (type == \"sat\") {\n        generateSat(n, m);\n    }\n    else if (type == \"unsat\") {\n        generateUnsat(n, m);\n    }\n    else if (type == \"unit\") {\n        generateUnit(n, m);\n    }\n    else if (type == \"special\") {\n        generateSpecial();\n    } \n    else {\n        // fallback: same as \"random\"\n        generateRandom(n, m);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test (n clauses, m variables) for the CNF\n  satisfiability problem described. The key constraint is that each variable\n  (1..m) may appear in at most 2 clauses total (whether negated or unnegated),\n  and that within any single clause, the same variable cannot appear twice.\n\n  The generator has several modes (controlled by the \"type\" parameter):\n  1) \"random\"  : Generates a larger random CNF (up to n clauses, m variables),\n                 with each variable appearing up to 2 times in total.\n  2) \"small\"   : Generates a small random instance with n and m very small.\n  3) \"sat\"     : Generates a simple, guaranteed satisfiable formula.\n  4) \"unsat\"   : Generates a simple, guaranteed unsatisfiable formula.\n  5) \"unit\"    : Generates only unit clauses.\n  6) \"special\" : Generates a small formula covering corner cases\n                 (e.g. single-literal, repeated variables, etc.).\n\n  Parameters:\n    -n <int> : number of clauses\n    -m <int> : number of variables\n    -type <string> : generation mode (listed above; default \"random\")\n\n  IMPORTANT:\n   - We do NOT set or pass a random seed.\n   - We rely on testlib's rnd (instead of std library random).\n   - We ensure each variable appears in at most 2 clauses total.\n   - We ensure that within a clause, no variable is repeated.\n   - We ensure n, m, and the resulting CNF meet problem constraints.\n*/\n\nstatic void printCNF(int n, int m, const vector<vector<int>> &clauses) {\n    // Output:\n    // First line: n m\n    // Next n lines: ki, then ki literals\n    // Each literal is in the range [ -m, -1 ] union [1, m ].\n    // ki >= 1\n    printf(\"%d %d\\n\", n, m);\n    for (const auto &c : clauses) {\n        printf(\"%d\", (int)c.size());\n        for (int lit : c) {\n            printf(\" %d\", lit);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Helper: produce a random sign literal for a variable in [1..m].\nstatic int randomLiteralSign(int var) {\n    // with 50% chance return var, with 50% chance return -var\n    if (rnd.next(2)) return var;\n    return -var;\n}\n\n// Generates a random CNF with the constraint that each variable can appear\n// at most twice total (negated or unnegated).\n// We'll attempt to produce a \"larger\" test with possibly bigger n, m.\nstatic void generateRandom(int n, int m) {\n    // We will create up to 2 occurrences for each variable (some might appear 0, 1, or 2 times).\n    // Then we will distribute them across the n clauses, ensuring each clause has at least 1 literal.\n    // Also we ensure that a variable never appears twice in the same clause.\n\n    // If n > 2*m, it's impossible to fill n clauses each with at least 1 literal\n    // and not violate the \"each variable appears at most 2 times\" rule.\n    // If that happens, we reduce n to 2*m (if it’s not zero).\n    if (2 * (long long)m < n) {\n        // If the user requests an impossible combination, clamp n.\n        n = max(1, 2*m); \n    }\n\n    // Decide how many times each variable occurs: 0, 1, or 2\n    // We'll store all the literal references in a vector.\n    vector<int> literalPool;\n    literalPool.reserve(2 * m);\n    for(int var = 1; var <= m; var++){\n        // random choices for how many times to appear\n        // we want to ensure total occurrences >= n so every clause can have at least 1 lit\n        // so let's do a random distribution: 0,1,2 equally, then if total < n, we fix it\n        int c = rnd.next(3); // 0,1,2\n        for(int i = 0; i < c; i++){\n            // each occurrence gets a random sign\n            literalPool.push_back(randomLiteralSign(var));\n        }\n    }\n    // If we didn't get enough references (literalPool.size() < n), forcibly add more references\n    // (until we can fill n single-literal clauses).\n    // We'll add them as random variables with random sign, while not exceeding 2 occurrences per var.\n    // For simplicity, let's just keep adding references to random variables that are still under 2 occurrences.\n    // We'll do it until we have at least n references in total. \n    // (We do not guarantee a perfect distribution, but it's enough to comply with constraints.)\n    vector<int> varCount(m+1, 0);\n    for (int lit : literalPool) {\n        varCount[abs(lit)]++;\n    }\n    while ((int)literalPool.size() < n) {\n        int var = rnd.next(1, m);\n        if (varCount[var] < 2) {\n            int lit = randomLiteralSign(var);\n            literalPool.push_back(lit);\n            varCount[var]++;\n        }\n        // If we can't find any variable with <2 usage, we break out to avoid infinite loop\n        // (this can only happen if m < n/2).\n        // Typically we won't get stuck if 2*m >= n.\n        bool allFull = true;\n        for(int i = 1; i <= m; i++){\n            if (varCount[i] < 2){\n                allFull = false; break;\n            }\n        }\n        if(allFull) break;\n    }\n    // Now we have at least n references. We will distribute them into n clauses,\n    // guaranteeing at least 1 literal per clause.\n\n    shuffle(literalPool.begin(), literalPool.end());\n\n    vector<vector<int>> clauses(n);\n    // First, give each clause exactly 1 literal from the front, to ensure no empty clause.\n    int idx = 0;\n    for(int i = 0; i < n; i++){\n        clauses[i].push_back(literalPool[idx++]);\n    }\n    // Next, we try to distribute the remaining references among the clauses randomly,\n    // ensuring we don't put two references of the same variable into the same clause.\n    while (idx < (int)literalPool.size()) {\n        int candidate = literalPool[idx++];\n        int cidx = rnd.next(0, n-1); // pick a random clause\n        // check if variable is already in that clause\n        int v = abs(candidate);\n        bool canUse = true;\n        for (int lit : clauses[cidx]) {\n            if (abs(lit) == v) {\n                canUse = false;\n                break;\n            }\n        }\n        if (canUse) {\n            clauses[cidx].push_back(candidate);\n        }\n        // if we cannot use it in that random clause, we discard it\n        // (this is a simpler approach, though slightly wasteful).\n    }\n\n    // Output the final CNF\n    printCNF(n, m, clauses);\n}\n\n// A small random instance with small n, m (e.g. up to 10).\nstatic void generateSmall() {\n    int n = rnd.next(1, 10);\n    int m = rnd.next(1, 10);\n    // We just do the same random approach but with these small n, m\n    generateRandom(n, m);\n}\n\n// Guaranteed satisfiable: For instance, we can produce a formula with 1 clause\n// that has one literal x1, or produce a set of clauses all containing the same\n// non-negated literal. As long as each variable appears <= 2 times.\nstatic void generateSat(int n, int m) {\n    // If n or m not sensible, adjust them.\n    // We'll create a formula with n clauses, each containing x1 as a positive literal.\n    // That obviously is satisfiable if x1 = TRUE.\n    if (m < 1) m = 1; // we need at least 1 variable\n    if (n < 1) n = 1; // we need at least 1 clause\n    // But each variable can appear up to 2 times. If n > 2, repeating x1 in all\n    // clauses is not allowed! So let's do the following:\n    // - If n=1, put x1 in that single clause.\n    // - If n=2, we can put x1 in both.\n    // - If n>2, we can put x1 in two clauses, and fill the rest with x2 in two clauses,\n    //   x3 in two clauses, etc., until we have n clauses total.\n    // This ensures each variable is used at most 2 times.\n\n    // We'll gather all references in a vector of size n, each is a single-literal clause.\n    vector<vector<int>> clauses(n);\n    int var = 1; \n    int usedCount = 0; // how many times var has been used\n    for(int i = 0; i < n; i++){\n        // If the current var is used 2 times, move to next var\n        if (usedCount == 2) {\n            var++;\n            usedCount = 0;\n            if (var > m) {\n                // if we run out of variables, forcibly re-use the last var anyway\n                // (just to keep a minimal approach, though it might break the \"at most 2 times\" rule\n                // if we strictly keep going. Let's just clamp n to 2*m in practice.)\n                // But to keep it simple, if we exceed, we just clamp i to 2*m.\n                break;\n            }\n        }\n        clauses[i].push_back(var); // single-literal clause: x_var\n        usedCount++;\n    }\n    // If we couldn't create all n single-literal clauses because we ran out of variables,\n    // we clamp the number of clauses to 2*m if needed.\n    int actualN = n;\n    if (var > m && usedCount == 0) {\n        // we used up exactly m variables * 2 times each => 2*m clauses\n        actualN = 2 * m;\n        if (actualN < 1) actualN = 1; // edge case\n        clauses.resize(actualN);\n    }\n\n    printCNF((int)clauses.size(), m, clauses);\n}\n\n// Guaranteed unsatisfiable: A simple example is (x1) & (~x1) with no other clauses.\n// That is unsatisfiable if x1 appears exactly once positively and exactly once negatively.\n// We just need n >= 2, m >= 1, and that variable used exactly twice in total.\nstatic void generateUnsat(int n, int m) {\n    if (m < 1) m = 1;\n    if (n < 2) n = 2;\n\n    // We'll create exactly 2 clauses:\n    //  1) ( x1 )\n    //  2) ( -x1 )\n    // and if n > 2, we fill the rest with something that doesn't break the formula\n    // For example, we can just use single-literal clauses with new variables\n    // that do not appear again, so it remains unsatisfiable due to x1 & ~x1.\n    vector<vector<int>> clauses(n);\n    // Clause 0: ( x1 )\n    clauses[0].push_back(1);\n    // Clause 1: ( -x1 )\n    clauses[1].push_back(-1);\n\n    // Now fill the remaining n-2 clauses with variables x2, x3, ...\n    // but each only once or twice if needed. Because if we do not fill them,\n    // they'll be 0-literal, which is invalid. We'll just assign single-literal clauses.\n    int clauseIndex = 2;\n    int varIndex = 2;\n    while (clauseIndex < n) {\n        // if we run out of variables, just break\n        if (varIndex > m) break;\n        clauses[clauseIndex].push_back(varIndex);\n        clauseIndex++;\n        varIndex++;\n    }\n    // If we still have more clauses beyond what we can fill with unique variables,\n    // we can just clamp n. \n    if (clauseIndex < n) {\n        clauses.resize(clauseIndex); \n    }\n\n    printCNF((int)clauses.size(), m, clauses);\n}\n\n// Generate all unit clauses. This can be interesting for corner cases.\nstatic void generateUnit(int n, int m) {\n    // We want n <= 2*m to be valid, because each variable can appear up to 2 times.\n    if (2 * (long long)m < n) {\n        // clamp if the user asked for too big n\n        n = max(1, 2*m);\n    }\n    // Create n single-literal clauses. Each variable can appear at most twice in total.\n    // We'll do something similar to generateSat with single-literal clauses,\n    // but we won't try to ensure \"satisfiable\" or \"unsatisfiable\" specifically.\n    // We'll simply fill them in a round-robin style.\n    vector<vector<int>> clauses(n);\n    int var = 1;\n    int usage = 0; // how many times current var used\n    for (int i = 0; i < n; i++){\n        // assign a random sign\n        int s = rnd.next(2) ? 1 : -1;\n        clauses[i].push_back(s * var);\n        usage++;\n        if (usage == 2) {\n            var++;\n            usage = 0;\n            if (var > m) break;\n        }\n    }\n    // in case we haven't filled all n because we ran out of variables, clamp\n    if (var > m && usage == 0) {\n        clauses.resize(var*2 - 2);\n    }\n    printCNF((int)clauses.size(), m, clauses);\n}\n\n// A hand-crafted \"special\" mode with multiple corner cases in one test.\nstatic void generateSpecial() {\n    // We'll just create a small-ish example that includes unit clauses, multi-literal clauses,\n    // a variable repeated in two distinct clauses, etc. All in one test.\n\n    // Let n=7, m=5, for instance.\n    int n = 7;\n    int m = 5;\n    // We'll define them manually. But still must be valid: each var appears <= 2 times in total.\n    // Clause 1: x1\n    // Clause 2: (x2 or ~x3)\n    // Clause 3: (~x2 or x1)\n    // Clause 4: (~x5)\n    // Clause 5: (x4)\n    // Clause 6: (x3)\n    // Clause 7: (~x1 or x2 or x5)  // This would be the second occurrence for some variables\n    // We must track usage:\n\n    // usage: x1 -> in clauses 1, 3, 7 (that's 3). Oops, too many. Let's fix it.\n    // Let's do: x1 in clause1, 7 => that's 2 times total\n    // x2 in clause2, 3, 7 => that is 3 times => too many. We must fix that as well.\n    // we can try a small re-shuffle:\n    // let's do:\n    //  c1: ( x1 )                # x1 used once\n    //  c2: ( x2 OR ~x3 )         # x2 used once, x3 used once\n    //  c3: (~x2 OR x4)           # x2 used second time, x4 used once\n    //  c4: (~x5)                 # x5 used once\n    //  c5: ( x4 )                # x4 used second time\n    //  c6: ( x3 )                # x3 used second time\n    //  c7: (~x1 OR x5)           # x1 used second time, x5 used second time\n    // This is valid. Each variable x1..x5 is used exactly 2 times except possibly others.\n\n    vector<vector<int>> clauses;\n    clauses.push_back({ 1 });          // c1:  x1\n    clauses.push_back({ 2, -3 });      // c2:  x2 OR ~x3\n    clauses.push_back({ -2, 4 });      // c3:  ~x2 OR x4\n    clauses.push_back({ -5 });         // c4:  ~x5\n    clauses.push_back({ 4 });          // c5:  x4\n    clauses.push_back({ 3 });          // c6:  x3\n    clauses.push_back({ -1, 5 });      // c7:  ~x1 OR x5\n\n    printCNF((int)clauses.size(), m, clauses);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\", 10);       // default 10\n    int m = opt<int>(\"m\", 10);       // default 10\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        generateRandom(n, m);\n    } \n    else if (type == \"small\") {\n        generateSmall();\n    }\n    else if (type == \"sat\") {\n        generateSat(n, m);\n    }\n    else if (type == \"unsat\") {\n        generateUnsat(n, m);\n    }\n    else if (type == \"unit\") {\n        generateUnit(n, m);\n    }\n    else if (type == \"special\") {\n        generateSpecial();\n    } \n    else {\n        // fallback: same as \"random\"\n        generateRandom(n, m);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small\n./gen -type small\n\n./gen -type sat -n 1 -m 1\n./gen -type sat -n 2 -m 1\n./gen -type sat -n 4 -m 2\n./gen -type sat -n 10 -m 5\n\n./gen -type unsat -n 2 -m 1\n./gen -type unsat -n 5 -m 3\n./gen -type unsat -n 10 -m 4\n\n./gen -type unit -n 5 -m 3\n./gen -type unit -n 10 -m 5\n./gen -type unit -n 20 -m 10\n\n./gen -type special\n\n./gen -type random -n 5 -m 5\n./gen -type random -n 10 -m 10\n./gen -type random -n 50 -m 40\n./gen -type random -n 100 -m 80\n./gen -type random -n 100 -m 100\n\n# Larger random tests\n./gen -type random -n 200 -m 150\n./gen -type random -n 500 -m 400\n./gen -type random -n 1000 -m 800\n./gen -type random -n 20000 -m 15000\n./gen -type random -n 200000 -m 200000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:49.248324",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "571/D",
      "title": "D. Campus",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and m (1 ≤ n, m ≤ 5·105) — the number of dormitories and the number of queries, respectively.Next m lines contain the queries, each of them is given in one of the following formats:   «U aj bj» — merging universities;  «M cj dj» — merging military offices;  «A xj» — students of university xj moving in the dormitories;  «Z yj» — a raid in military office yj;  «Q qj» — a query asking the number of people in dormitory qj.  All the numbers in the queries are positive integers and do not exceed n. It is guaranteed that at the moment of the query the universities and military offices, that are present in the query, exist.",
      "output_spec": "OutputIn the i-th line print the answer to the i-th query asking the number of people in the dormitory.",
      "sample_tests": "ExamplesInputCopy2 7A 1Q 1U 1 2A 1Z 1Q 1Q 2OutputCopy102InputCopy5 12U 1 2M 4 5A 1Q 1A 3A 4Q 3Q 4Z 4Q 4A 5Q 5OutputCopy21101",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and m (1 ≤ n, m ≤ 5·105) — the number of dormitories and the number of queries, respectively.Next m lines contain the queries, each of them is given in one of the following formats:   «U aj bj» — merging universities;  «M cj dj» — merging military offices;  «A xj» — students of university xj moving in the dormitories;  «Z yj» — a raid in military office yj;  «Q qj» — a query asking the number of people in dormitory qj.  All the numbers in the queries are positive integers and do not exceed n. It is guaranteed that at the moment of the query the universities and military offices, that are present in the query, exist.\n\nOutputIn the i-th line print the answer to the i-th query asking the number of people in the dormitory.\n\nInputCopy2 7A 1Q 1U 1 2A 1Z 1Q 1Q 2OutputCopy102InputCopy5 12U 1 2M 4 5A 1Q 1A 3A 4Q 3Q 4Z 4Q 4A 5Q 5OutputCopy21101\n\nInputCopy2 7A 1Q 1U 1 2A 1Z 1Q 1Q 2\n\nOutputCopy102\n\nInputCopy5 12U 1 2M 4 5A 1Q 1A 3A 4Q 3Q 4Z 4Q 4A 5Q 5\n\nOutputCopy21101\n\nNoteConsider the first sample test:   In the first query university 1 owns only dormitory 1, so after the query dormitory 1 will have 1 student.  After the third query university 1 owns dormitories 1 and 2.  The fourth query increases by 2 the number of students living in dormitories 1 and 2 that belong to university number 1. After that 3 students live in the first dormitory and 2 students live in the second dormitory.  At the fifth query the number of students living in dormitory 1, assigned to the military office 1, becomes zero.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round 317 will take place on August, 22 at 19:30 MSK.The round is prepared by AimFund employees: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina and zeliboba.Scoring system will be static. Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Max Akhmedov (Zlobober) and Maria Belova (Delinur) for English translation.Top 200 div1 participants will be awarded t-shirts. To learn more about AimFund please refer to our previous post.This round is prepared as part of \"5 years\" Codeforces program as our present to community. This round is the first Thanks-Round devoted to companies donated significant money.We wish you good luck and high frequency rating!P.S: scoring 1 div 750-1250-1500-2000-2750. 2 div 500-1000-1750-2250-2500P.P.S. Top-20 div2 participants will be awarded t-shirts.AnalysisP.P.P.S. Dear friends. We are pleased to inform you that t shirts delivery will be under way next week. We hope you will really like them. Our sincere congrats again to you all!",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1067
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 571\\s*D"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string queryType = inf.readToken();\n        if (queryType == \"U\") {\n            inf.readSpace();\n            int aj = inf.readInt(1, n, \"aj\");\n            inf.readSpace();\n            int bj = inf.readInt(1, n, \"bj\");\n            inf.readEoln();\n        } else if (queryType == \"M\") {\n            inf.readSpace();\n            int cj = inf.readInt(1, n, \"cj\");\n            inf.readSpace();\n            int dj = inf.readInt(1, n, \"dj\");\n            inf.readEoln();\n        } else if (queryType == \"A\") {\n            inf.readSpace();\n            int xj = inf.readInt(1, n, \"xj\");\n            inf.readEoln();\n        } else if (queryType == \"Z\") {\n            inf.readSpace();\n            int yj = inf.readInt(1, n, \"yj\");\n            inf.readEoln();\n        } else if (queryType == \"Q\") {\n            inf.readSpace();\n            int qj = inf.readInt(1, n, \"qj\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Unknown query type '%s'\", queryType.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string queryType = inf.readToken();\n        if (queryType == \"U\") {\n            inf.readSpace();\n            int aj = inf.readInt(1, n, \"aj\");\n            inf.readSpace();\n            int bj = inf.readInt(1, n, \"bj\");\n            inf.readEoln();\n        } else if (queryType == \"M\") {\n            inf.readSpace();\n            int cj = inf.readInt(1, n, \"cj\");\n            inf.readSpace();\n            int dj = inf.readInt(1, n, \"dj\");\n            inf.readEoln();\n        } else if (queryType == \"A\") {\n            inf.readSpace();\n            int xj = inf.readInt(1, n, \"xj\");\n            inf.readEoln();\n        } else if (queryType == \"Z\") {\n            inf.readSpace();\n            int yj = inf.readInt(1, n, \"yj\");\n            inf.readEoln();\n        } else if (queryType == \"Q\") {\n            inf.readSpace();\n            int qj = inf.readInt(1, n, \"qj\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Unknown query type '%s'\", queryType.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string queryType = inf.readToken();\n        if (queryType == \"U\") {\n            inf.readSpace();\n            int aj = inf.readInt(1, n, \"aj\");\n            inf.readSpace();\n            int bj = inf.readInt(1, n, \"bj\");\n            inf.readEoln();\n        } else if (queryType == \"M\") {\n            inf.readSpace();\n            int cj = inf.readInt(1, n, \"cj\");\n            inf.readSpace();\n            int dj = inf.readInt(1, n, \"dj\");\n            inf.readEoln();\n        } else if (queryType == \"A\") {\n            inf.readSpace();\n            int xj = inf.readInt(1, n, \"xj\");\n            inf.readEoln();\n        } else if (queryType == \"Z\") {\n            inf.readSpace();\n            int yj = inf.readInt(1, n, \"yj\");\n            inf.readEoln();\n        } else if (queryType == \"Q\") {\n            inf.readSpace();\n            int qj = inf.readInt(1, n, \"qj\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Unknown query type '%s'\", queryType.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize existing universities and military offices\n    vector<int> universities, military_offices;\n    for (int i = 1; i <= n; ++i) {\n        universities.push_back(i);\n        military_offices.push_back(i);\n    }\n\n    vector<string> operations;\n\n    if (type == \"random\") {\n        // Randomly generate m operations, ensuring constraints are met\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(5);  // 0 to 4\n            if (op_type == 0) {\n                // \"U aj bj\"\n                if (universities.size() >= 2) {\n                    int idx_aj = rnd.next((int)universities.size());\n                    int aj = universities[idx_aj];\n                    int idx_bj = rnd.next((int)universities.size());\n                    while (idx_bj == idx_aj) {\n                        idx_bj = rnd.next((int)universities.size());\n                    }\n                    int bj = universities[idx_bj];\n                    // Remove bj from universities after the merge\n                    operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n                    swap(universities[idx_bj], universities.back());\n                    universities.pop_back();\n                } else {\n                    // Not enough universities to merge, generate another operation\n                    --i;\n                    continue;\n                }\n            } else if (op_type == 1) {\n                // \"M cj dj\"\n                if (military_offices.size() >= 2) {\n                    int idx_cj = rnd.next((int)military_offices.size());\n                    int cj = military_offices[idx_cj];\n                    int idx_dj = rnd.next((int)military_offices.size());\n                    while (idx_dj == idx_cj) {\n                        idx_dj = rnd.next((int)military_offices.size());\n                    }\n                    int dj = military_offices[idx_dj];\n                    // Remove dj from military offices after the merge\n                    operations.push_back(\"M \" + to_string(cj) + \" \" + to_string(dj));\n                    swap(military_offices[idx_dj], military_offices.back());\n                    military_offices.pop_back();\n                } else {\n                    // Not enough military offices to merge\n                    --i;\n                    continue;\n                }\n            } else if (op_type == 2) {\n                // \"A xj\"\n                if (!universities.empty()) {\n                    int idx_xj = rnd.next((int)universities.size());\n                    int xj = universities[idx_xj];\n                    operations.push_back(\"A \" + to_string(xj));\n                } else {\n                    // No universities exist\n                    --i;\n                    continue;\n                }\n            } else if (op_type == 3) {\n                // \"Z yj\"\n                if (!military_offices.empty()) {\n                    int idx_yj = rnd.next((int)military_offices.size());\n                    int yj = military_offices[idx_yj];\n                    operations.push_back(\"Z \" + to_string(yj));\n                } else {\n                    // No military offices exist\n                    --i;\n                    continue;\n                }\n            } else {\n                // \"Q qj\"\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"merges\") {\n        // Generate operations focused on merges\n        for (int i = 0; i < m; ++i) {\n            if (universities.size() >= 2) {\n                // Merge universities\n                int idx_aj = rnd.next((int)universities.size());\n                int aj = universities[idx_aj];\n                int idx_bj = rnd.next((int)universities.size());\n                while (idx_bj == idx_aj) {\n                    idx_bj = rnd.next((int)universities.size());\n                }\n                int bj = universities[idx_bj];\n                operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n                swap(universities[idx_bj], universities.back());\n                universities.pop_back();\n            } else if (military_offices.size() >= 2) {\n                // Merge military offices\n                int idx_cj = rnd.next((int)military_offices.size());\n                int cj = military_offices[idx_cj];\n                int idx_dj = rnd.next((int)military_offices.size());\n                while (idx_dj == idx_cj) {\n                    idx_dj = rnd.next((int)military_offices.size());\n                }\n                int dj = military_offices[idx_dj];\n                operations.push_back(\"M \" + to_string(cj) + \" \" + to_string(dj));\n                swap(military_offices[idx_dj], military_offices.back());\n                military_offices.pop_back();\n            } else {\n                // Generate other operations as filler\n                int op_type = rnd.next(3);\n                if (op_type == 0 && !universities.empty()) {\n                    int idx_xj = rnd.next((int)universities.size());\n                    int xj = universities[idx_xj];\n                    operations.push_back(\"A \" + to_string(xj));\n                } else if (op_type == 1 && !military_offices.empty()) {\n                    int idx_yj = rnd.next((int)military_offices.size());\n                    int yj = military_offices[idx_yj];\n                    operations.push_back(\"Z \" + to_string(yj));\n                } else {\n                    int qj = rnd.next(1, n);\n                    operations.push_back(\"Q \" + to_string(qj));\n                }\n            }\n        }\n    } else if (type == \"students\") {\n        // Generate many students moving in\n        for (int i = 0; i < m; ++i) {\n            if (!universities.empty()) {\n                int idx_xj = rnd.next((int)universities.size());\n                int xj = universities[idx_xj];\n                operations.push_back(\"A \" + to_string(xj));\n            } else {\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"raids\") {\n        // Generate many raids\n        for (int i = 0; i < m; ++i) {\n            if (!military_offices.empty()) {\n                int idx_yj = rnd.next((int)military_offices.size());\n                int yj = military_offices[idx_yj];\n                operations.push_back(\"Z \" + to_string(yj));\n            } else {\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"queries\") {\n        // Generate many queries\n        for (int i = 0; i < m; ++i) {\n            int qj = rnd.next(1, n);\n            operations.push_back(\"Q \" + to_string(qj));\n        }\n    } else if (type == \"max\") {\n        // Generate operations designed to stress-test data structures\n        // Merge all universities and military offices into one\n        for (int i = 0; i < n - 1; ++i) {\n            // Merge universities to university 1\n            int aj = 1;\n            int bj = i + 2;\n            operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n        }\n        universities.resize(1);\n\n        for (int i = 0; i < n - 1; ++i) {\n            // Merge military offices to military office 1\n            int cj = 1;\n            int dj = i + 2;\n            operations.push_back(\"M \" + to_string(cj) + \" \" + to_string(dj));\n        }\n        military_offices.resize(1);\n\n        // Now add m - 2*(n - 1) operations\n        int remaining_ops = m - 2 * (n - 1);\n        for (int i = 0; i < remaining_ops; ++i) {\n            int op_type = rnd.next(3);\n            if (op_type == 0) {\n                // \"A xj\" where xj = 1\n                operations.push_back(\"A 1\");\n            } else if (op_type == 1) {\n                // \"Z yj\" where yj = 1\n                operations.push_back(\"Z 1\");\n            } else {\n                // \"Q qj\"\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"merges_and_students\") {\n        // Merge universities into one and perform many \"A\" operations\n        for (int i = 0; i < n - 1; ++i) {\n            // Merge universities to university 1\n            int aj = 1;\n            int bj = i + 2;\n            operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n        }\n        universities.resize(1);\n\n        int remaining_ops = m - (n - 1);\n        for (int i = 0; i < remaining_ops; ++i) {\n            int op_type = rnd.next(2);\n            if (op_type == 0) {\n                // \"A xj\" where xj = 1\n                operations.push_back(\"A 1\");\n            } else {\n                // \"Q qj\"\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else {\n        // Default to random\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)operations.size());\n    for (auto& op : operations) {\n        printf(\"%s\\n\", op.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize existing universities and military offices\n    vector<int> universities, military_offices;\n    for (int i = 1; i <= n; ++i) {\n        universities.push_back(i);\n        military_offices.push_back(i);\n    }\n\n    vector<string> operations;\n\n    if (type == \"random\") {\n        // Randomly generate m operations, ensuring constraints are met\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(5);  // 0 to 4\n            if (op_type == 0) {\n                // \"U aj bj\"\n                if (universities.size() >= 2) {\n                    int idx_aj = rnd.next((int)universities.size());\n                    int aj = universities[idx_aj];\n                    int idx_bj = rnd.next((int)universities.size());\n                    while (idx_bj == idx_aj) {\n                        idx_bj = rnd.next((int)universities.size());\n                    }\n                    int bj = universities[idx_bj];\n                    // Remove bj from universities after the merge\n                    operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n                    swap(universities[idx_bj], universities.back());\n                    universities.pop_back();\n                } else {\n                    // Not enough universities to merge, generate another operation\n                    --i;\n                    continue;\n                }\n            } else if (op_type == 1) {\n                // \"M cj dj\"\n                if (military_offices.size() >= 2) {\n                    int idx_cj = rnd.next((int)military_offices.size());\n                    int cj = military_offices[idx_cj];\n                    int idx_dj = rnd.next((int)military_offices.size());\n                    while (idx_dj == idx_cj) {\n                        idx_dj = rnd.next((int)military_offices.size());\n                    }\n                    int dj = military_offices[idx_dj];\n                    // Remove dj from military offices after the merge\n                    operations.push_back(\"M \" + to_string(cj) + \" \" + to_string(dj));\n                    swap(military_offices[idx_dj], military_offices.back());\n                    military_offices.pop_back();\n                } else {\n                    // Not enough military offices to merge\n                    --i;\n                    continue;\n                }\n            } else if (op_type == 2) {\n                // \"A xj\"\n                if (!universities.empty()) {\n                    int idx_xj = rnd.next((int)universities.size());\n                    int xj = universities[idx_xj];\n                    operations.push_back(\"A \" + to_string(xj));\n                } else {\n                    // No universities exist\n                    --i;\n                    continue;\n                }\n            } else if (op_type == 3) {\n                // \"Z yj\"\n                if (!military_offices.empty()) {\n                    int idx_yj = rnd.next((int)military_offices.size());\n                    int yj = military_offices[idx_yj];\n                    operations.push_back(\"Z \" + to_string(yj));\n                } else {\n                    // No military offices exist\n                    --i;\n                    continue;\n                }\n            } else {\n                // \"Q qj\"\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"merges\") {\n        // Generate operations focused on merges\n        for (int i = 0; i < m; ++i) {\n            if (universities.size() >= 2) {\n                // Merge universities\n                int idx_aj = rnd.next((int)universities.size());\n                int aj = universities[idx_aj];\n                int idx_bj = rnd.next((int)universities.size());\n                while (idx_bj == idx_aj) {\n                    idx_bj = rnd.next((int)universities.size());\n                }\n                int bj = universities[idx_bj];\n                operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n                swap(universities[idx_bj], universities.back());\n                universities.pop_back();\n            } else if (military_offices.size() >= 2) {\n                // Merge military offices\n                int idx_cj = rnd.next((int)military_offices.size());\n                int cj = military_offices[idx_cj];\n                int idx_dj = rnd.next((int)military_offices.size());\n                while (idx_dj == idx_cj) {\n                    idx_dj = rnd.next((int)military_offices.size());\n                }\n                int dj = military_offices[idx_dj];\n                operations.push_back(\"M \" + to_string(cj) + \" \" + to_string(dj));\n                swap(military_offices[idx_dj], military_offices.back());\n                military_offices.pop_back();\n            } else {\n                // Generate other operations as filler\n                int op_type = rnd.next(3);\n                if (op_type == 0 && !universities.empty()) {\n                    int idx_xj = rnd.next((int)universities.size());\n                    int xj = universities[idx_xj];\n                    operations.push_back(\"A \" + to_string(xj));\n                } else if (op_type == 1 && !military_offices.empty()) {\n                    int idx_yj = rnd.next((int)military_offices.size());\n                    int yj = military_offices[idx_yj];\n                    operations.push_back(\"Z \" + to_string(yj));\n                } else {\n                    int qj = rnd.next(1, n);\n                    operations.push_back(\"Q \" + to_string(qj));\n                }\n            }\n        }\n    } else if (type == \"students\") {\n        // Generate many students moving in\n        for (int i = 0; i < m; ++i) {\n            if (!universities.empty()) {\n                int idx_xj = rnd.next((int)universities.size());\n                int xj = universities[idx_xj];\n                operations.push_back(\"A \" + to_string(xj));\n            } else {\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"raids\") {\n        // Generate many raids\n        for (int i = 0; i < m; ++i) {\n            if (!military_offices.empty()) {\n                int idx_yj = rnd.next((int)military_offices.size());\n                int yj = military_offices[idx_yj];\n                operations.push_back(\"Z \" + to_string(yj));\n            } else {\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"queries\") {\n        // Generate many queries\n        for (int i = 0; i < m; ++i) {\n            int qj = rnd.next(1, n);\n            operations.push_back(\"Q \" + to_string(qj));\n        }\n    } else if (type == \"max\") {\n        // Generate operations designed to stress-test data structures\n        // Merge all universities and military offices into one\n        for (int i = 0; i < n - 1; ++i) {\n            // Merge universities to university 1\n            int aj = 1;\n            int bj = i + 2;\n            operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n        }\n        universities.resize(1);\n\n        for (int i = 0; i < n - 1; ++i) {\n            // Merge military offices to military office 1\n            int cj = 1;\n            int dj = i + 2;\n            operations.push_back(\"M \" + to_string(cj) + \" \" + to_string(dj));\n        }\n        military_offices.resize(1);\n\n        // Now add m - 2*(n - 1) operations\n        int remaining_ops = m - 2 * (n - 1);\n        for (int i = 0; i < remaining_ops; ++i) {\n            int op_type = rnd.next(3);\n            if (op_type == 0) {\n                // \"A xj\" where xj = 1\n                operations.push_back(\"A 1\");\n            } else if (op_type == 1) {\n                // \"Z yj\" where yj = 1\n                operations.push_back(\"Z 1\");\n            } else {\n                // \"Q qj\"\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else if (type == \"merges_and_students\") {\n        // Merge universities into one and perform many \"A\" operations\n        for (int i = 0; i < n - 1; ++i) {\n            // Merge universities to university 1\n            int aj = 1;\n            int bj = i + 2;\n            operations.push_back(\"U \" + to_string(aj) + \" \" + to_string(bj));\n        }\n        universities.resize(1);\n\n        int remaining_ops = m - (n - 1);\n        for (int i = 0; i < remaining_ops; ++i) {\n            int op_type = rnd.next(2);\n            if (op_type == 0) {\n                // \"A xj\" where xj = 1\n                operations.push_back(\"A 1\");\n            } else {\n                // \"Q qj\"\n                int qj = rnd.next(1, n);\n                operations.push_back(\"Q \" + to_string(qj));\n            }\n        }\n    } else {\n        // Default to random\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)operations.size());\n    for (auto& op : operations) {\n        printf(\"%s\\n\", op.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 2 -m 3 -type random\n./gen -n 5 -m 10 -type random\n./gen -n 100 -m 1000 -type random\n./gen -n 1000 -m 10000 -type random\n\n./gen -n 5 -m 10 -type merges\n./gen -n 100 -m 200 -type merges\n./gen -n 1000 -m 2000 -type merges\n./gen -n 50000 -m 100000 -type merges\n\n./gen -n 100000 -m 500000 -type random\n./gen -n 500000 -m 500000 -type random\n\n./gen -n 500000 -m 500000 -type students\n./gen -n 500000 -m 500000 -type raids\n./gen -n 500000 -m 500000 -type queries\n\n./gen -n 500000 -m 500000 -type merges\n\n# Edge cases\n./gen -n 1 -m 500000 -type queries\n./gen -n 1 -m 500000 -type students\n\n# Merges leading to a single university and military office\n./gen -n 100000 -m 500000 -type merges_and_students\n./gen -n 500000 -m 500000 -type max\n\n# More random large cases\n./gen -n 500000 -m 500000 -type random\n./gen -n 500000 -m 500000 -type merges_and_students\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:51.459791",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "571/E",
      "title": "E. Geometric Progressions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer (1 ≤ n ≤ 100) — the number of geometric progressions. Next n lines contain pairs of integers a, b (1 ≤ a, b ≤ 109), that are the first element and the common ratio of the corresponding geometric progression.",
      "output_spec": "OutputIf the intersection of all progressions is empty, then print  - 1, otherwise print the remainder of the minimal positive integer number belonging to all progressions modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy22 24 1OutputCopy4InputCopy22 23 3OutputCopy-1",
      "description": "E. Geometric Progressions\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer (1 ≤ n ≤ 100) — the number of geometric progressions. Next n lines contain pairs of integers a, b (1 ≤ a, b ≤ 109), that are the first element and the common ratio of the corresponding geometric progression.\n\nOutputIf the intersection of all progressions is empty, then print  - 1, otherwise print the remainder of the minimal positive integer number belonging to all progressions modulo 1000000007 (109 + 7).\n\nInputCopy22 24 1OutputCopy4InputCopy22 23 3OutputCopy-1\n\nInputCopy22 24 1\n\nOutputCopy4\n\nInputCopy22 23 3\n\nOutputCopy-1\n\nNoteIn the second sample test one of the progressions contains only powers of two, the other one contains only powers of three.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round 317 will take place on August, 22 at 19:30 MSK.The round is prepared by AimFund employees: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina and zeliboba.Scoring system will be static. Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Max Akhmedov (Zlobober) and Maria Belova (Delinur) for English translation.Top 200 div1 participants will be awarded t-shirts. To learn more about AimFund please refer to our previous post.This round is prepared as part of \"5 years\" Codeforces program as our present to community. This round is the first Thanks-Round devoted to companies donated significant money.We wish you good luck and high frequency rating!P.S: scoring 1 div 750-1250-1500-2000-2750. 2 div 500-1000-1750-2250-2500P.P.S. Top-20 div2 participants will be awarded t-shirts.AnalysisP.P.P.S. Dear friends. We are pleased to inform you that t shirts delivery will be under way next week. We hope you will really like them. Our sincere congrats again to you all!",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1067
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 571\\s*E"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        long long a = inf.readLong(1, 1000000000LL, \"a_i\");\n        inf.readSpace();\n        long long b = inf.readLong(1, 1000000000LL, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        long long a = inf.readLong(1, 1000000000LL, \"a_i\");\n        inf.readSpace();\n        long long b = inf.readLong(1, 1000000000LL, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        long long a = inf.readLong(1, 1000000000LL, \"a_i\");\n        inf.readSpace();\n        long long b = inf.readLong(1, 1000000000LL, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"same_progression\") {\n        int a = rnd.next(1, 1000000000);\n        int b = rnd.next(1, 1000000000);\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"no_intersection\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int b = 1000000000 - i; // Ensure b is different for each progression\n            int a = b;              // First term equals to b\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"b_equals_one_same_a\") {\n        int a = rnd.next(1, 1000000000);\n        int b = 1;\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"b_equals_one_different_a\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = 1;\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"mixed_b1\") {\n        printf(\"%d\\n\", n);\n        int num_b1 = n / 2;\n        int a_common = rnd.next(1, 1000000000);\n        for (int i = 0; i < num_b1; ++i) {\n            printf(\"%d %d\\n\", a_common, 1);\n        }\n        for (int i = num_b1; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(2, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"big_numbers\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1000000000 - 1000, 1000000000);\n            int b = rnd.next(1000000000 - 1000, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"minimal_values\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1\\n\");\n        }\n    }\n    else if (type == \"power_sequences\") {\n        printf(\"%d\\n\", n);\n        // Common exponents for primes 2, 3, and 5\n        int exp2 = rnd.next(1, 10);\n        int exp3 = rnd.next(1, 10);\n        int exp5 = rnd.next(1, 10);\n        long long x = 1;\n        x *= pow(2LL, exp2);\n        x *= pow(3LL, exp3);\n        x *= pow(5LL, exp5);\n\n        vector<int> primes = {2, 3, 5};\n        for (int i = 0; i < n; ++i) {\n            int p = primes[i % primes.size()];\n            int exponent;\n            if (p == 2) exponent = exp2;\n            else if (p == 3) exponent = exp3;\n            else exponent = exp5;\n\n            long long a = pow(p, exponent);\n            int b = p;\n            while (a > 1000000000) {\n                a /= p;\n                exponent--;\n            }\n            printf(\"%lld %d\\n\", a, b);\n        }\n    }\n    else {\n        // Default to random if unknown type\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"same_progression\") {\n        int a = rnd.next(1, 1000000000);\n        int b = rnd.next(1, 1000000000);\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"no_intersection\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int b = 1000000000 - i; // Ensure b is different for each progression\n            int a = b;              // First term equals to b\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"b_equals_one_same_a\") {\n        int a = rnd.next(1, 1000000000);\n        int b = 1;\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"b_equals_one_different_a\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = 1;\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"mixed_b1\") {\n        printf(\"%d\\n\", n);\n        int num_b1 = n / 2;\n        int a_common = rnd.next(1, 1000000000);\n        for (int i = 0; i < num_b1; ++i) {\n            printf(\"%d %d\\n\", a_common, 1);\n        }\n        for (int i = num_b1; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(2, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"big_numbers\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1000000000 - 1000, 1000000000);\n            int b = rnd.next(1000000000 - 1000, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n    else if (type == \"minimal_values\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1\\n\");\n        }\n    }\n    else if (type == \"power_sequences\") {\n        printf(\"%d\\n\", n);\n        // Common exponents for primes 2, 3, and 5\n        int exp2 = rnd.next(1, 10);\n        int exp3 = rnd.next(1, 10);\n        int exp5 = rnd.next(1, 10);\n        long long x = 1;\n        x *= pow(2LL, exp2);\n        x *= pow(3LL, exp3);\n        x *= pow(5LL, exp5);\n\n        vector<int> primes = {2, 3, 5};\n        for (int i = 0; i < n; ++i) {\n            int p = primes[i % primes.size()];\n            int exponent;\n            if (p == 2) exponent = exp2;\n            else if (p == 3) exponent = exp3;\n            else exponent = exp5;\n\n            long long a = pow(p, exponent);\n            int b = p;\n            while (a > 1000000000) {\n                a /= p;\n                exponent--;\n            }\n            printf(\"%lld %d\\n\", a, b);\n        }\n    }\n    else {\n        // Default to random if unknown type\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same_progression\n./gen -n 1 -type no_intersection\n./gen -n 1 -type b_equals_one_same_a\n./gen -n 1 -type b_equals_one_different_a\n./gen -n 1 -type minimal_values\n./gen -n 2 -type random\n./gen -n 2 -type same_progression\n./gen -n 2 -type no_intersection\n./gen -n 2 -type b_equals_one_same_a\n./gen -n 2 -type b_equals_one_different_a\n./gen -n 2 -type mixed_b1\n./gen -n 2 -type power_sequences\n./gen -n 5 -type random\n./gen -n 5 -type big_numbers\n./gen -n 5 -type mixed_b1\n./gen -n 10 -type random\n./gen -n 10 -type big_numbers\n./gen -n 10 -type same_progression\n./gen -n 10 -type no_intersection\n./gen -n 10 -type power_sequences\n./gen -n 50 -type random\n./gen -n 50 -type big_numbers\n./gen -n 50 -type same_progression\n./gen -n 50 -type minimal_values\n./gen -n 100 -type random\n./gen -n 100 -type big_numbers\n./gen -n 100 -type same_progression\n./gen -n 100 -type no_intersection\n./gen -n 100 -type b_equals_one_same_a\n./gen -n 100 -type b_equals_one_different_a\n./gen -n 100 -type mixed_b1\n./gen -n 100 -type power_sequences\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:53.491761",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "572/A",
      "title": "A. Массивы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа nA, nB (1 ≤ nA, nB ≤ 105), разделенные пробелом — размеры массивов A и B, соответственно.Во второй строке записаны два челых числа k и m (1 ≤ k ≤ nA, 1 ≤ m ≤ nB), разделенные пробелом.В третьей строке записаны nA чисел a1, a2, ... anA ( - 109 ≤ a1 ≤ a2 ≤ ... ≤ anA ≤ 109), разделенных пробелами — элементы массива A.В четвертой строке записаны nB чисел b1, b2, ... bnB ( - 109 ≤ b1 ≤ b2 ≤ ... ≤ bnB ≤ 109), разделенных пробелами — элементы массива B.",
      "output_spec": "Выходные данныеВыведите \"YES\" (без кавычек), если в массиве A можно выбрать k чисел, а в массиве B — m чисел так, любое выбранное в массиве A число строго меньше любого выбранного в массиве B числа. В противном случае выведите \"NO\" (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 32 11 2 33 4 5Выходные данныеСкопироватьYESВходные данныеСкопировать3 33 31 2 33 4 5Выходные данныеСкопироватьNOВходные данныеСкопировать5 23 11 1 1 1 12 2Выходные данныеСкопироватьYES",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке заданы два целых числа nA, nB (1 ≤ nA, nB ≤ 105), разделенные пробелом — размеры массивов A и B, соответственно.Во второй строке записаны два челых числа k и m (1 ≤ k ≤ nA, 1 ≤ m ≤ nB), разделенные пробелом.В третьей строке записаны nA чисел a1, a2, ... anA ( - 109 ≤ a1 ≤ a2 ≤ ... ≤ anA ≤ 109), разделенных пробелами — элементы массива A.В четвертой строке записаны nB чисел b1, b2, ... bnB ( - 109 ≤ b1 ≤ b2 ≤ ... ≤ bnB ≤ 109), разделенных пробелами — элементы массива B.\n\nВходные данные\n\nВыходные данныеВыведите \"YES\" (без кавычек), если в массиве A можно выбрать k чисел, а в массиве B — m чисел так, любое выбранное в массиве A число строго меньше любого выбранного в массиве B числа. В противном случае выведите \"NO\" (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать3 32 11 2 33 4 5Выходные данныеСкопироватьYESВходные данныеСкопировать3 33 31 2 33 4 5Выходные данныеСкопироватьNOВходные данныеСкопировать5 23 11 1 1 1 12 2Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать3 32 11 2 33 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 33 31 2 33 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 23 11 1 1 1 12 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере, можно например, выбрать числа 1 и 2 из массива A и число 3 из массива B (1 < 3 и 2 < 3).Во втором тестовом примере единственный способ выбрать k элементов в первом массиве и m элементов во втором — выбрать все числа в обоих массивах, но тогда не все выбранные числа в A будут меньше, чем все выбранные в B: .",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Привет, Codeforces!22 августа, в субботу, в 19:30 MSK состоится 317 раунд Codeforces.Раунд подготовили для вас сотрудники компании AimFund: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina и zeliboba.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Макса Ахмедова (Zlobober) и Марию Белову (Delinur) за перевод условий на английский.В первом дивизионе будет разыграно 200 футболок c символикой нашей компании. Прочитать подробнее про нас и наши вакансии можно на сайте aimfund.ru и в анонсе этого раунда.Этот раунд подготовлен в рамках программы \"5 лет CodeForces\", как часть нашего подарка сообществу. С этого раунда на CF начинается серия thanks-раундов, которые посвящаются людям и компаниям, пожертвовавшим значительные средства.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в четверг в 8 вечера будет организован фуршет в Пауланер Бройхаус.P.P.S. Разбалловка: 1 дивизион 750-1250-1500-2000-2750, 2 дивизион 500-1000-1750-2250-2500P.P.P.S. Топ-20 участников второго дивизиона также получат футболки.РазборP.P.P.P.S. Друзья, с большим удовольствием сообщаем вам, что мы начинаем отправку наших фирменных футболок их счастливым обладателям по всему миру. Надеемся, что они вам понравятся, и вы будете носить их с удовольствием :)",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1466
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 572\\s*A"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "В течение месяца мы планируем провести свой раунд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "Мы не имеем четкого Великого-Свода-Правил-Поведения-На-Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 8",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 9",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int nA = inf.readInt(1, 100000, \"nA\");\n    inf.readSpace();\n    int nB = inf.readInt(1, 100000, \"nB\");\n    inf.readEoln();\n\n    int k = inf.readInt(1, nA, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, nB, \"m\");\n    inf.readEoln();\n\n    vector<int> A = inf.readInts(nA, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n\n    for (int i = 0; i < nA - 1; i++) {\n        ensuref(A[i] <= A[i + 1], \"Array A is not sorted at position %d\", i + 1);\n    }\n\n    vector<int> B = inf.readInts(nB, -1000000000, 1000000000, \"B\");\n    inf.readEoln();\n\n    for (int i = 0; i < nB - 1; i++) {\n        ensuref(B[i] <= B[i + 1], \"Array B is not sorted at position %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int nA = inf.readInt(1, 100000, \"nA\");\n    inf.readSpace();\n    int nB = inf.readInt(1, 100000, \"nB\");\n    inf.readEoln();\n\n    int k = inf.readInt(1, nA, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, nB, \"m\");\n    inf.readEoln();\n\n    vector<int> A = inf.readInts(nA, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n\n    for (int i = 0; i < nA - 1; i++) {\n        ensuref(A[i] <= A[i + 1], \"Array A is not sorted at position %d\", i + 1);\n    }\n\n    vector<int> B = inf.readInts(nB, -1000000000, 1000000000, \"B\");\n    inf.readEoln();\n\n    for (int i = 0; i < nB - 1; i++) {\n        ensuref(B[i] <= B[i + 1], \"Array B is not sorted at position %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int nA = inf.readInt(1, 100000, \"nA\");\n    inf.readSpace();\n    int nB = inf.readInt(1, 100000, \"nB\");\n    inf.readEoln();\n\n    int k = inf.readInt(1, nA, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, nB, \"m\");\n    inf.readEoln();\n\n    vector<int> A = inf.readInts(nA, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n\n    for (int i = 0; i < nA - 1; i++) {\n        ensuref(A[i] <= A[i + 1], \"Array A is not sorted at position %d\", i + 1);\n    }\n\n    vector<int> B = inf.readInts(nB, -1000000000, 1000000000, \"B\");\n    inf.readEoln();\n\n    for (int i = 0; i < nB - 1; i++) {\n        ensuref(B[i] <= B[i + 1], \"Array B is not sorted at position %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nA = opt<int>(\"nA\");\n    int nB = opt<int>(\"nB\");\n    int k = opt<int>(\"k\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate input parameters\n    ensure(1 <= nA && nA <= 100000);\n    ensure(1 <= nB && nB <= 100000);\n    ensure(1 <= k && k <= nA);\n    ensure(1 <= m && m <= nB);\n\n    vector<int> a(nA);\n    vector<int> b(nB);\n\n    if (type == \"random\") {\n        // Generate random arrays A and B\n        for (int i = 0; i < nA; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < nB; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"equal\") {\n        // Create arrays where a[k - 1] == b[nB - m]\n        int x = rnd.next(-1000000000, 1000000000);\n        // Build array A\n        a[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < k - 1; ++i) {\n            a[i] = rnd.next(a[i - 1], x);\n        }\n        a[k - 1] = x;\n        for (int i = k; i < nA; ++i) {\n            a[i] = rnd.next(a[i - 1], 1000000000);\n        }\n        // Build array B\n        b[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < nB - m; ++i) {\n            b[i] = rnd.next(b[i - 1], x);\n        }\n        b[nB - m] = x;\n        for (int i = nB - m + 1; i < nB; ++i) {\n            b[i] = rnd.next(b[i - 1], 1000000000);\n        }\n    } else if (type == \"less\") {\n        // Create arrays where a[k - 1] < b[nB - m]\n        int x = rnd.next(-1000000000, 999999999); // x <= 1e9 -1\n        int y = rnd.next(x + 1, 1000000000);      // y >= x + 1\n        // Build array A\n        a[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < k - 1; ++i) {\n            a[i] = rnd.next(a[i - 1], x);\n        }\n        a[k - 1] = x;\n        for (int i = k; i < nA; ++i) {\n            a[i] = rnd.next(a[i - 1], 1000000000);\n        }\n        // Build array B\n        b[0] = rnd.next(-1000000000, y);\n        for (int i = 1; i < nB - m; ++i) {\n            b[i] = rnd.next(b[i - 1], y);\n        }\n        b[nB - m] = y;\n        for (int i = nB - m + 1; i < nB; ++i) {\n            b[i] = rnd.next(b[i - 1], 1000000000);\n        }\n    } else if (type == \"greater_or_equal\") {\n        // Create arrays where a[k - 1] >= b[nB - m]\n        int y = rnd.next(-1000000000, 1000000000);\n        int x = rnd.next(y, 1000000000);\n        // Build array A\n        a[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < k - 1; ++i) {\n            a[i] = rnd.next(a[i - 1], x);\n        }\n        a[k - 1] = x;\n        for (int i = k; i < nA; ++i) {\n            a[i] = rnd.next(a[i - 1], 1000000000);\n        }\n        // Build array B\n        b[0] = rnd.next(-1000000000, y);\n        for (int i = 1; i < nB - m; ++i) {\n            b[i] = rnd.next(b[i - 1], y);\n        }\n        b[nB - m] = y;\n        for (int i = nB - m + 1; i < nB; ++i) {\n            b[i] = rnd.next(b[i - 1], 1000000000);\n        }\n    } else if (type == \"duplicates\") {\n        // Create arrays with duplicate elements\n        int x = rnd.next(-1000000000, 999999999);\n        int y = rnd.next(x + 1, 1000000000);\n        // Fill array A with x\n        fill(a.begin(), a.end(), x);\n        // Fill array B with y\n        fill(b.begin(), b.end(), y);\n    } else if (type == \"max_elements\") {\n        // Fill arrays with maximum allowed value\n        int x = 1000000000;\n        fill(a.begin(), a.end(), x);\n        fill(b.begin(), b.end(), x);\n    } else if (type == \"min_elements\") {\n        // Fill arrays with minimum allowed value\n        int x = -1000000000;\n        fill(a.begin(), a.end(), x);\n        fill(b.begin(), b.end(), x);\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < nA; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < nB; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", nA, nB);\n    printf(\"%d %d\\n\", k, m);\n    for (int i = 0; i < nA; ++i) {\n        printf(\"%d%c\", a[i], i == nA -1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < nB; ++i) {\n        printf(\"%d%c\", b[i], i == nB -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nA = opt<int>(\"nA\");\n    int nB = opt<int>(\"nB\");\n    int k = opt<int>(\"k\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate input parameters\n    ensure(1 <= nA && nA <= 100000);\n    ensure(1 <= nB && nB <= 100000);\n    ensure(1 <= k && k <= nA);\n    ensure(1 <= m && m <= nB);\n\n    vector<int> a(nA);\n    vector<int> b(nB);\n\n    if (type == \"random\") {\n        // Generate random arrays A and B\n        for (int i = 0; i < nA; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < nB; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"equal\") {\n        // Create arrays where a[k - 1] == b[nB - m]\n        int x = rnd.next(-1000000000, 1000000000);\n        // Build array A\n        a[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < k - 1; ++i) {\n            a[i] = rnd.next(a[i - 1], x);\n        }\n        a[k - 1] = x;\n        for (int i = k; i < nA; ++i) {\n            a[i] = rnd.next(a[i - 1], 1000000000);\n        }\n        // Build array B\n        b[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < nB - m; ++i) {\n            b[i] = rnd.next(b[i - 1], x);\n        }\n        b[nB - m] = x;\n        for (int i = nB - m + 1; i < nB; ++i) {\n            b[i] = rnd.next(b[i - 1], 1000000000);\n        }\n    } else if (type == \"less\") {\n        // Create arrays where a[k - 1] < b[nB - m]\n        int x = rnd.next(-1000000000, 999999999); // x <= 1e9 -1\n        int y = rnd.next(x + 1, 1000000000);      // y >= x + 1\n        // Build array A\n        a[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < k - 1; ++i) {\n            a[i] = rnd.next(a[i - 1], x);\n        }\n        a[k - 1] = x;\n        for (int i = k; i < nA; ++i) {\n            a[i] = rnd.next(a[i - 1], 1000000000);\n        }\n        // Build array B\n        b[0] = rnd.next(-1000000000, y);\n        for (int i = 1; i < nB - m; ++i) {\n            b[i] = rnd.next(b[i - 1], y);\n        }\n        b[nB - m] = y;\n        for (int i = nB - m + 1; i < nB; ++i) {\n            b[i] = rnd.next(b[i - 1], 1000000000);\n        }\n    } else if (type == \"greater_or_equal\") {\n        // Create arrays where a[k - 1] >= b[nB - m]\n        int y = rnd.next(-1000000000, 1000000000);\n        int x = rnd.next(y, 1000000000);\n        // Build array A\n        a[0] = rnd.next(-1000000000, x);\n        for (int i = 1; i < k - 1; ++i) {\n            a[i] = rnd.next(a[i - 1], x);\n        }\n        a[k - 1] = x;\n        for (int i = k; i < nA; ++i) {\n            a[i] = rnd.next(a[i - 1], 1000000000);\n        }\n        // Build array B\n        b[0] = rnd.next(-1000000000, y);\n        for (int i = 1; i < nB - m; ++i) {\n            b[i] = rnd.next(b[i - 1], y);\n        }\n        b[nB - m] = y;\n        for (int i = nB - m + 1; i < nB; ++i) {\n            b[i] = rnd.next(b[i - 1], 1000000000);\n        }\n    } else if (type == \"duplicates\") {\n        // Create arrays with duplicate elements\n        int x = rnd.next(-1000000000, 999999999);\n        int y = rnd.next(x + 1, 1000000000);\n        // Fill array A with x\n        fill(a.begin(), a.end(), x);\n        // Fill array B with y\n        fill(b.begin(), b.end(), y);\n    } else if (type == \"max_elements\") {\n        // Fill arrays with maximum allowed value\n        int x = 1000000000;\n        fill(a.begin(), a.end(), x);\n        fill(b.begin(), b.end(), x);\n    } else if (type == \"min_elements\") {\n        // Fill arrays with minimum allowed value\n        int x = -1000000000;\n        fill(a.begin(), a.end(), x);\n        fill(b.begin(), b.end(), x);\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < nA; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < nB; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", nA, nB);\n    printf(\"%d %d\\n\", k, m);\n    for (int i = 0; i < nA; ++i) {\n        printf(\"%d%c\", a[i], i == nA -1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < nB; ++i) {\n        printf(\"%d%c\", b[i], i == nB -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -nA 10 -nB 10 -k 5 -m 5 -type random\n./gen -nA 10 -nB 10 -k 3 -m 7 -type equal\n./gen -nA 10 -nB 10 -k 3 -m 7 -type less\n./gen -nA 10 -nB 10 -k 3 -m 7 -type greater_or_equal\n./gen -nA 10 -nB 10 -k 4 -m 6 -type duplicates\n./gen -nA 10 -nB 10 -k 5 -m 5 -type max_elements\n./gen -nA 10 -nB 10 -k 5 -m 5 -type min_elements\n\n./gen -nA 100 -nB 100 -k 50 -m 50 -type random\n./gen -nA 100 -nB 100 -k 25 -m 75 -type equal\n./gen -nA 100 -nB 100 -k 75 -m 25 -type less\n./gen -nA 100 -nB 100 -k 60 -m 40 -type greater_or_equal\n./gen -nA 100 -nB 100 -k 50 -m 50 -type duplicates\n./gen -nA 100 -nB 100 -k 70 -m 30 -type max_elements\n./gen -nA 100 -nB 100 -k 30 -m 70 -type min_elements\n\n./gen -nA 1000 -nB 1000 -k 500 -m 500 -type random\n./gen -nA 1000 -nB 1000 -k 200 -m 800 -type equal\n./gen -nA 1000 -nB 1000 -k 800 -m 200 -type less\n./gen -nA 1000 -nB 1000 -k 600 -m 400 -type greater_or_equal\n./gen -nA 1000 -nB 1000 -k 500 -m 500 -type duplicates\n./gen -nA 1000 -nB 1000 -k 700 -m 300 -type max_elements\n./gen -nA 1000 -nB 1000 -k 300 -m 700 -type min_elements\n\n./gen -nA 100000 -nB 100000 -k 50000 -m 50000 -type random\n./gen -nA 100000 -nB 100000 -k 25000 -m 75000 -type equal\n./gen -nA 100000 -nB 100000 -k 80000 -m 20000 -type less\n./gen -nA 100000 -nB 100000 -k 60000 -m 40000 -type greater_or_equal\n./gen -nA 100000 -nB 100000 -k 50000 -m 50000 -type duplicates\n./gen -nA 100000 -nB 100000 -k 75000 -m 25000 -type max_elements\n./gen -nA 100000 -nB 100000 -k 25000 -m 75000 -type min_elements\n\n./gen -nA 100000 -nB 100000 -k 1 -m 1 -type random\n./gen -nA 100000 -nB 100000 -k 1 -m 100000 -type min_elements\n./gen -nA 100000 -nB 100000 -k 100000 -m 1 -type max_elements\n./gen -nA 100000 -nB 100000 -k 99999 -m 99999 -type duplicates\n\n./gen -nA 10 -nB 10 -k 1 -m 1 -type min_elements\n./gen -nA 10 -nB 10 -k 10 -m 10 -type max_elements\n./gen -nA 10 -nB 100000 -k 5 -m 50000 -type random\n./gen -nA 100000 -nB 10 -k 50000 -m 5 -type random\n./gen -nA 50000 -nB 50000 -k 25000 -m 25000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:55.437444",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "572/B",
      "title": "B. Биржевые заявки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и s (1 ≤ n ≤ 1000, 1 ≤ s ≤ 50) — количество заявок и глубина стакана соответственно.В каждой из следующих n строк следуют символ di (либо 'B', либо 'S'), целое число pi (0 ≤ pi ≤ 105), а также целое число qi (1 ≤ qi ≤ 104) — направление, цена и объем заявки соответственно. Символ 'B' означает покупку, 'S' — продажу. Цена любой заявки на продажу больше цены любой заявки на покупку.",
      "output_spec": "Выходные данныеВыведите не больше чем 2s строк, в которых содержатся аггрегированные заявки биржевого стакана глубины s. Заявки требуется выводить в том же формате что и во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 2B 10 3S 50 2S 40 1S 50 6B 20 4B 25 10Выходные данныеСкопироватьS 50 8S 40 1B 25 10B 20 4",
      "description": "B. Биржевые заявки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записаны два целых числа n и s (1 ≤ n ≤ 1000, 1 ≤ s ≤ 50) — количество заявок и глубина стакана соответственно.В каждой из следующих n строк следуют символ di (либо 'B', либо 'S'), целое число pi (0 ≤ pi ≤ 105), а также целое число qi (1 ≤ qi ≤ 104) — направление, цена и объем заявки соответственно. Символ 'B' означает покупку, 'S' — продажу. Цена любой заявки на продажу больше цены любой заявки на покупку.\n\nВходные данные\n\nВыходные данныеВыведите не больше чем 2s строк, в которых содержатся аггрегированные заявки биржевого стакана глубины s. Заявки требуется выводить в том же формате что и во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать6 2B 10 3S 50 2S 40 1S 50 6B 20 4B 25 10Выходные данныеСкопироватьS 50 8S 40 1B 25 10B 20 4\n\nВходные данныеСкопировать6 2B 10 3S 50 2S 40 1S 50 6B 20 4B 25 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьS 50 8S 40 1B 25 10B 20 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеБудем обозначать (x, y) заявку по цене x с объемом y. В тестовом примере имеются три аггрегированные заявки на покупку: (10, 3), (20, 4), (25, 10) и две на продажу: (50, 8), (40, 1)Нужно вывести не более двух лучших заявок по каждому направлению, поэтому заявку (10 3), имеющую худшую цену среди заявок на покупку, выводить не нужно.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Привет, Codeforces!22 августа, в субботу, в 19:30 MSK состоится 317 раунд Codeforces.Раунд подготовили для вас сотрудники компании AimFund: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina и zeliboba.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Макса Ахмедова (Zlobober) и Марию Белову (Delinur) за перевод условий на английский.В первом дивизионе будет разыграно 200 футболок c символикой нашей компании. Прочитать подробнее про нас и наши вакансии можно на сайте aimfund.ru и в анонсе этого раунда.Этот раунд подготовлен в рамках программы \"5 лет CodeForces\", как часть нашего подарка сообществу. С этого раунда на CF начинается серия thanks-раундов, которые посвящаются людям и компаниям, пожертвовавшим значительные средства.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в четверг в 8 вечера будет организован фуршет в Пауланер Бройхаус.P.P.S. Разбалловка: 1 дивизион 750-1250-1500-2000-2750, 2 дивизион 500-1000-1750-2250-2500P.P.P.S. Топ-20 участников второго дивизиона также получат футболки.РазборP.P.P.P.S. Друзья, с большим удовольствием сообщаем вам, что мы начинаем отправку наших фирменных футболок их счастливым обладателям по всему миру. Надеемся, что они вам понравятся, и вы будете носить их с удовольствием :)",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1466
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 572\\s*B"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "В течение месяца мы планируем провести свой раунд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "Мы не имеем четкого Великого-Свода-Правил-Поведения-На-Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 8",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 9",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 50, \"s\");\n    inf.readEoln();\n\n    int max_buy_price = -1;\n    int min_sell_price = INF;\n    for (int i = 0; i < n; i++) {\n        string di = inf.readToken(\"[BS]\", \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(0, 100000, \"pi\");\n        inf.readSpace();\n        int qi = inf.readInt(1, 10000, \"qi\");\n        inf.readEoln();\n\n        if (di == \"B\") {\n            max_buy_price = max(max_buy_price, pi);\n        } else { // di == \"S\"\n            min_sell_price = min(min_sell_price, pi);\n        }\n    }\n\n    if (max_buy_price != -1 && min_sell_price != INF) {\n        ensuref(max_buy_price < min_sell_price, \"The price of any sell order must be higher than the price of any buy order\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 50, \"s\");\n    inf.readEoln();\n\n    int max_buy_price = -1;\n    int min_sell_price = INF;\n    for (int i = 0; i < n; i++) {\n        string di = inf.readToken(\"[BS]\", \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(0, 100000, \"pi\");\n        inf.readSpace();\n        int qi = inf.readInt(1, 10000, \"qi\");\n        inf.readEoln();\n\n        if (di == \"B\") {\n            max_buy_price = max(max_buy_price, pi);\n        } else { // di == \"S\"\n            min_sell_price = min(min_sell_price, pi);\n        }\n    }\n\n    if (max_buy_price != -1 && min_sell_price != INF) {\n        ensuref(max_buy_price < min_sell_price, \"The price of any sell order must be higher than the price of any buy order\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 50, \"s\");\n    inf.readEoln();\n\n    int max_buy_price = -1;\n    int min_sell_price = INF;\n    for (int i = 0; i < n; i++) {\n        string di = inf.readToken(\"[BS]\", \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(0, 100000, \"pi\");\n        inf.readSpace();\n        int qi = inf.readInt(1, 10000, \"qi\");\n        inf.readEoln();\n\n        if (di == \"B\") {\n            max_buy_price = max(max_buy_price, pi);\n        } else { // di == \"S\"\n            min_sell_price = min(min_sell_price, pi);\n        }\n    }\n\n    if (max_buy_price != -1 && min_sell_price != INF) {\n        ensuref(max_buy_price < min_sell_price, \"The price of any sell order must be higher than the price of any buy order\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<tuple<char, int, int>> generate_random_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n    for (int i = 0; i < n; ++i) {\n        char dir = rnd.next(0, 1) ? 'B' : 'S';\n        int pi;\n        if (dir == 'B') {\n            pi = rnd.next(0, T - 1);\n        } else {\n            pi = rnd.next(T + 1, 100000);\n        }\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple(dir, pi, qi));\n    }\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_unique_price_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    set<int> buy_prices;\n    set<int> sell_prices;\n\n    // Generate unique buy prices in [0, T - 1]\n    while ((int)buy_prices.size() < nb) {\n        int pi = rnd.next(0, T - 1);\n        buy_prices.insert(pi);\n    }\n\n    // Generate unique sell prices in [T + 1, 100000]\n    while ((int)sell_prices.size() < ns) {\n        int pi = rnd.next(T + 1, 100000);\n        sell_prices.insert(pi);\n    }\n\n    // For each buy price, generate an order\n    for (int pi : buy_prices) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', pi, qi));\n    }\n\n    // For each sell price, generate an order\n    for (int pi : sell_prices) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', pi, qi));\n    }\n\n    // Shuffle orders\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_same_price_same_direction_orders(int n, int T, string specified_dir = \"\") {\n    vector<tuple<char, int, int>> orders;\n\n    char dir;\n    if (specified_dir == \"\") {\n        dir = rnd.next(0, 1) ? 'B' : 'S';\n    } else {\n        dir = specified_dir[0]; // assume 'B' or 'S'\n    }\n\n    int pi;\n    if (dir == 'B') {\n        pi = rnd.next(0, T - 1);\n    } else {\n        pi = rnd.next(T + 1, 100000);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple(dir, pi, qi));\n    }\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_max_volume_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    for (int i = 0; i < n; ++i) {\n        char dir = rnd.next(0, 1) ? 'B' : 'S';\n        int pi;\n        if (dir == 'B') {\n            pi = rnd.next(0, T - 1);\n        } else {\n            pi = rnd.next(T + 1, 100000);\n        }\n        int qi = 10000;\n        orders.push_back(make_tuple(dir, pi, qi));\n    }\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_edge_price_orders(int n) {\n    vector<tuple<char, int, int>> orders;\n\n    // Determine number of buy and sell orders\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    // For buy orders, pi = 0\n    for (int i = 0; i < nb; ++i) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', 0, qi));\n    }\n\n    // For sell orders, pi = 100000\n    for (int i = 0; i < ns; ++i) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', 100000, qi));\n    }\n\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_ascending_price_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    // Generate buy orders with ascending prices\n    int min_buy_price = max(0, T - nb * 10);\n    for (int i = 0; i < nb; ++i) {\n        int pi = min_buy_price + i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', pi, qi));\n    }\n\n    // Generate sell orders with ascending prices\n    int min_sell_price = T + 1;\n    for (int i = 0; i < ns; ++i) {\n        int pi = min_sell_price + i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', pi, qi));\n    }\n\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_descending_price_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    // Generate buy orders with descending prices\n    int max_buy_price = min(T - 1, T - 1 + nb * 10);\n    for (int i = 0; i < nb; ++i) {\n        int pi = max_buy_price - i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', pi, qi));\n    }\n\n    // Generate sell orders with descending prices\n    int max_sell_price = min(100000, T + 1 + ns * 10);\n    for (int i = 0; i < ns; ++i) {\n        int pi = max_sell_price - i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', pi, qi));\n    }\n\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n\n    string type = opt<string>(\"type\", \"random\");\n    string specified_dir = opt<string>(\"dir\", \"\");\n\n    // Threshold T to separate buy and sell prices\n    int T = rnd.next(1, 99999);\n\n    vector<tuple<char, int, int>> orders;\n\n    if (type == \"random\") {\n        orders = generate_random_orders(n, T);\n    } else if (type == \"unique_prices\") {\n        orders = generate_unique_price_orders(n, T);\n    } else if (type == \"same_price_same_direction\") {\n        orders = generate_same_price_same_direction_orders(n, T, specified_dir);\n    } else if (type == \"max_volume\") {\n        orders = generate_max_volume_orders(n, T);\n    } else if (type == \"edge_prices\") {\n        orders = generate_edge_price_orders(n);\n    } else if (type == \"ascending_prices\") {\n        orders = generate_ascending_price_orders(n, T);\n    } else if (type == \"descending_prices\") {\n        orders = generate_descending_price_orders(n, T);\n    } else {\n        // default to random\n        orders = generate_random_orders(n, T);\n    }\n\n    printf(\"%d %d\\n\", n, s);\n    for (auto& order : orders) {\n        char dir = get<0>(order);\n        int pi = get<1>(order);\n        int qi = get<2>(order);\n        printf(\"%c %d %d\\n\", dir, pi, qi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<tuple<char, int, int>> generate_random_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n    for (int i = 0; i < n; ++i) {\n        char dir = rnd.next(0, 1) ? 'B' : 'S';\n        int pi;\n        if (dir == 'B') {\n            pi = rnd.next(0, T - 1);\n        } else {\n            pi = rnd.next(T + 1, 100000);\n        }\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple(dir, pi, qi));\n    }\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_unique_price_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    set<int> buy_prices;\n    set<int> sell_prices;\n\n    // Generate unique buy prices in [0, T - 1]\n    while ((int)buy_prices.size() < nb) {\n        int pi = rnd.next(0, T - 1);\n        buy_prices.insert(pi);\n    }\n\n    // Generate unique sell prices in [T + 1, 100000]\n    while ((int)sell_prices.size() < ns) {\n        int pi = rnd.next(T + 1, 100000);\n        sell_prices.insert(pi);\n    }\n\n    // For each buy price, generate an order\n    for (int pi : buy_prices) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', pi, qi));\n    }\n\n    // For each sell price, generate an order\n    for (int pi : sell_prices) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', pi, qi));\n    }\n\n    // Shuffle orders\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_same_price_same_direction_orders(int n, int T, string specified_dir = \"\") {\n    vector<tuple<char, int, int>> orders;\n\n    char dir;\n    if (specified_dir == \"\") {\n        dir = rnd.next(0, 1) ? 'B' : 'S';\n    } else {\n        dir = specified_dir[0]; // assume 'B' or 'S'\n    }\n\n    int pi;\n    if (dir == 'B') {\n        pi = rnd.next(0, T - 1);\n    } else {\n        pi = rnd.next(T + 1, 100000);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple(dir, pi, qi));\n    }\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_max_volume_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    for (int i = 0; i < n; ++i) {\n        char dir = rnd.next(0, 1) ? 'B' : 'S';\n        int pi;\n        if (dir == 'B') {\n            pi = rnd.next(0, T - 1);\n        } else {\n            pi = rnd.next(T + 1, 100000);\n        }\n        int qi = 10000;\n        orders.push_back(make_tuple(dir, pi, qi));\n    }\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_edge_price_orders(int n) {\n    vector<tuple<char, int, int>> orders;\n\n    // Determine number of buy and sell orders\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    // For buy orders, pi = 0\n    for (int i = 0; i < nb; ++i) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', 0, qi));\n    }\n\n    // For sell orders, pi = 100000\n    for (int i = 0; i < ns; ++i) {\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', 100000, qi));\n    }\n\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_ascending_price_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    // Generate buy orders with ascending prices\n    int min_buy_price = max(0, T - nb * 10);\n    for (int i = 0; i < nb; ++i) {\n        int pi = min_buy_price + i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', pi, qi));\n    }\n\n    // Generate sell orders with ascending prices\n    int min_sell_price = T + 1;\n    for (int i = 0; i < ns; ++i) {\n        int pi = min_sell_price + i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', pi, qi));\n    }\n\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nvector<tuple<char, int, int>> generate_descending_price_orders(int n, int T) {\n    vector<tuple<char, int, int>> orders;\n\n    int nb = rnd.next(1, n - 1), ns = n - nb;\n\n    // Generate buy orders with descending prices\n    int max_buy_price = min(T - 1, T - 1 + nb * 10);\n    for (int i = 0; i < nb; ++i) {\n        int pi = max_buy_price - i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('B', pi, qi));\n    }\n\n    // Generate sell orders with descending prices\n    int max_sell_price = min(100000, T + 1 + ns * 10);\n    for (int i = 0; i < ns; ++i) {\n        int pi = max_sell_price - i * 5;\n        int qi = rnd.next(1, 10000);\n        orders.push_back(make_tuple('S', pi, qi));\n    }\n\n    shuffle(orders.begin(), orders.end());\n\n    return orders;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n\n    string type = opt<string>(\"type\", \"random\");\n    string specified_dir = opt<string>(\"dir\", \"\");\n\n    // Threshold T to separate buy and sell prices\n    int T = rnd.next(1, 99999);\n\n    vector<tuple<char, int, int>> orders;\n\n    if (type == \"random\") {\n        orders = generate_random_orders(n, T);\n    } else if (type == \"unique_prices\") {\n        orders = generate_unique_price_orders(n, T);\n    } else if (type == \"same_price_same_direction\") {\n        orders = generate_same_price_same_direction_orders(n, T, specified_dir);\n    } else if (type == \"max_volume\") {\n        orders = generate_max_volume_orders(n, T);\n    } else if (type == \"edge_prices\") {\n        orders = generate_edge_price_orders(n);\n    } else if (type == \"ascending_prices\") {\n        orders = generate_ascending_price_orders(n, T);\n    } else if (type == \"descending_prices\") {\n        orders = generate_descending_price_orders(n, T);\n    } else {\n        // default to random\n        orders = generate_random_orders(n, T);\n    }\n\n    printf(\"%d %d\\n\", n, s);\n    for (auto& order : orders) {\n        char dir = get<0>(order);\n        int pi = get<1>(order);\n        int qi = get<2>(order);\n        printf(\"%c %d %d\\n\", dir, pi, qi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -s 5 -type random\n./gen -n 10 -s 5 -type unique_prices\n./gen -n 10 -s 5 -type same_price_same_direction\n./gen -n 10 -s 5 -type max_volume\n./gen -n 10 -s 5 -type edge_prices\n./gen -n 10 -s 5 -type ascending_prices\n./gen -n 10 -s 5 -type descending_prices\n\n./gen -n 50 -s 25 -type random\n./gen -n 50 -s 25 -type unique_prices\n./gen -n 50 -s 25 -type same_price_same_direction\n./gen -n 50 -s 25 -type max_volume\n./gen -n 50 -s 25 -type edge_prices\n./gen -n 50 -s 25 -type ascending_prices\n./gen -n 50 -s 25 -type descending_prices\n\n./gen -n 100 -s 50 -type random\n./gen -n 100 -s 50 -type unique_prices\n./gen -n 100 -s 50 -type same_price_same_direction\n./gen -n 100 -s 50 -type max_volume\n./gen -n 100 -s 50 -type edge_prices\n./gen -n 100 -s 50 -type ascending_prices\n./gen -n 100 -s 50 -type descending_prices\n\n./gen -n 500 -s 50 -type random\n./gen -n 500 -s 50 -type unique_prices\n./gen -n 500 -s 50 -type max_volume\n./gen -n 500 -s 50 -type edge_prices\n\n./gen -n 1000 -s 50 -type random\n./gen -n 1000 -s 50 -type unique_prices\n./gen -n 1000 -s 50 -type max_volume\n./gen -n 1000 -s 50 -type edge_prices\n\n# Test with s=1\n./gen -n 1000 -s 1 -type random\n\n# Test with n=1\n./gen -n 1 -s 1 -type random\n./gen -n 1 -s 1 -type max_volume\n\n# Test with s greater than number of aggregated orders\n./gen -n 10 -s 20 -type unique_prices\n\n# Test with all buy orders\n./gen -n 50 -s 25 -type same_price_same_direction -dir B\n\n# Test with all sell orders\n./gen -n 50 -s 25 -type same_price_same_direction -dir S\n\n# Edge cases with minimal and maximal prices\n./gen -n 100 -s 50 -type edge_prices\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:57.297335",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "572/C",
      "title": "C. Lengthening Sticks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains 4 integers a, b, c, l (1 ≤ a, b, c ≤ 3·105, 0 ≤ l ≤ 3·105).",
      "output_spec": "OutputPrint a single integer — the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you can make a non-degenerate triangle from it.",
      "sample_tests": "ExamplesInputCopy1 1 1 2OutputCopy4InputCopy1 2 3 1OutputCopy2InputCopy10 2 1 7OutputCopy0",
      "description": "C. Lengthening Sticks\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe single line contains 4 integers a, b, c, l (1 ≤ a, b, c ≤ 3·105, 0 ≤ l ≤ 3·105).\n\nOutputPrint a single integer — the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you can make a non-degenerate triangle from it.\n\nInputCopy1 1 1 2OutputCopy4InputCopy1 2 3 1OutputCopy2InputCopy10 2 1 7OutputCopy0\n\nInputCopy1 1 1 2\n\nOutputCopy4\n\nInputCopy1 2 3 1\n\nOutputCopy2\n\nInputCopy10 2 1 7\n\nOutputCopy0\n\nNoteIn the first sample test you can either not increase any stick or increase any two sticks by 1 centimeter.In the second sample test you can increase either the first or the second stick by one centimeter. Note that the triangle made from the initial sticks is degenerate and thus, doesn't meet the conditions.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round 317 will take place on August, 22 at 19:30 MSK.The round is prepared by AimFund employees: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina and zeliboba.Scoring system will be static. Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Max Akhmedov (Zlobober) and Maria Belova (Delinur) for English translation.Top 200 div1 participants will be awarded t-shirts. To learn more about AimFund please refer to our previous post.This round is prepared as part of \"5 years\" Codeforces program as our present to community. This round is the first Thanks-Round devoted to companies donated significant money.We wish you good luck and high frequency rating!P.S: scoring 1 div 750-1250-1500-2000-2750. 2 div 500-1000-1750-2250-2500P.P.S. Top-20 div2 participants will be awarded t-shirts.AnalysisP.P.P.S. Dear friends. We are pleased to inform you that t shirts delivery will be under way next week. We hope you will really like them. Our sincere congrats again to you all!",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1067
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 572 和字母"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 300000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 300000, \"c\");\n    inf.readSpace();\n    int l = inf.readInt(0, 300000, \"l\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 300000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 300000, \"c\");\n    inf.readSpace();\n    int l = inf.readInt(0, 300000, \"l\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 300000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 300000, \"c\");\n    inf.readSpace();\n    int l = inf.readInt(0, 300000, \"l\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int maxVal = opt<int>(\"maxVal\", 300000); // Maximum value for a0, b0, c0, l\n\n    int a0, b0, c0, l;\n\n    if (type == \"valid_zero_l\") {\n        // Generate a valid triangle with l = 0\n        l = 0;\n        // Generate a0, b0, c0 such that they form a non-degenerate triangle\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            // Check triangle inequality for non-degenerate triangle\n            if (a0 + b0 > c0 && a0 + c0 > b0 && b0 + c0 > a0) {\n                break;\n            }\n        }\n    } else if (type == \"valid_l\") {\n        // Generate a valid triangle with l > 0\n        l = rnd.next(1, maxVal);\n        // Generate a0, b0, c0 such that they form a non-degenerate triangle\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            if (a0 + b0 > c0 && a0 + c0 > b0 && b0 + c0 > a0) {\n                break;\n            }\n        }\n    } else if (type == \"invalid_fixable\") {\n        // Generate an invalid triangle that can be fixed by increases within l\n        l = rnd.next(1, maxVal);\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            int max_side = max({a0, b0, c0});\n            int sum_others = a0 + b0 + c0 - max_side;\n            if (max_side >= sum_others) {\n                // Required increase to satisfy triangle inequality\n                int required_increase = max_side - sum_others + 1;\n                if (required_increase <= l) {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"invalid_unfixable\") {\n        // Generate an invalid triangle that cannot be fixed even with increases\n        l = rnd.next(0, maxVal);\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            int max_side = max({a0, b0, c0});\n            int sum_others = a0 + b0 + c0 - max_side;\n            if (max_side >= sum_others) {\n                int required_increase = max_side - sum_others + 1;\n                if (required_increase > l) {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"degenerate\") {\n        // Generate a degenerate triangle (sum of two sides equals the third)\n        l = rnd.next(0, maxVal);\n        int s1 = rnd.next(1, maxVal);\n        int s2 = rnd.next(1, maxVal);\n        int s3 = s1 + s2;\n        int arr[3] = {s1, s2, s3};\n        shuffle(arr, arr + 3);\n        a0 = arr[0];\n        b0 = arr[1];\n        c0 = arr[2];\n    } else if (type == \"max\") {\n        // Max values\n        a0 = b0 = c0 = maxVal;\n        l = maxVal;\n    } else if (type == \"random\") {\n        // Random test case satisfying the constraints\n        a0 = rnd.next(1, maxVal);\n        b0 = rnd.next(1, maxVal);\n        c0 = rnd.next(1, maxVal);\n        l = rnd.next(0, maxVal);\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the generated test case\n    printf(\"%d %d %d %d\\n\", a0, b0, c0, l);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int maxVal = opt<int>(\"maxVal\", 300000); // Maximum value for a0, b0, c0, l\n\n    int a0, b0, c0, l;\n\n    if (type == \"valid_zero_l\") {\n        // Generate a valid triangle with l = 0\n        l = 0;\n        // Generate a0, b0, c0 such that they form a non-degenerate triangle\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            // Check triangle inequality for non-degenerate triangle\n            if (a0 + b0 > c0 && a0 + c0 > b0 && b0 + c0 > a0) {\n                break;\n            }\n        }\n    } else if (type == \"valid_l\") {\n        // Generate a valid triangle with l > 0\n        l = rnd.next(1, maxVal);\n        // Generate a0, b0, c0 such that they form a non-degenerate triangle\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            if (a0 + b0 > c0 && a0 + c0 > b0 && b0 + c0 > a0) {\n                break;\n            }\n        }\n    } else if (type == \"invalid_fixable\") {\n        // Generate an invalid triangle that can be fixed by increases within l\n        l = rnd.next(1, maxVal);\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            int max_side = max({a0, b0, c0});\n            int sum_others = a0 + b0 + c0 - max_side;\n            if (max_side >= sum_others) {\n                // Required increase to satisfy triangle inequality\n                int required_increase = max_side - sum_others + 1;\n                if (required_increase <= l) {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"invalid_unfixable\") {\n        // Generate an invalid triangle that cannot be fixed even with increases\n        l = rnd.next(0, maxVal);\n        while (true) {\n            a0 = rnd.next(1, maxVal);\n            b0 = rnd.next(1, maxVal);\n            c0 = rnd.next(1, maxVal);\n            int max_side = max({a0, b0, c0});\n            int sum_others = a0 + b0 + c0 - max_side;\n            if (max_side >= sum_others) {\n                int required_increase = max_side - sum_others + 1;\n                if (required_increase > l) {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"degenerate\") {\n        // Generate a degenerate triangle (sum of two sides equals the third)\n        l = rnd.next(0, maxVal);\n        int s1 = rnd.next(1, maxVal);\n        int s2 = rnd.next(1, maxVal);\n        int s3 = s1 + s2;\n        int arr[3] = {s1, s2, s3};\n        shuffle(arr, arr + 3);\n        a0 = arr[0];\n        b0 = arr[1];\n        c0 = arr[2];\n    } else if (type == \"max\") {\n        // Max values\n        a0 = b0 = c0 = maxVal;\n        l = maxVal;\n    } else if (type == \"random\") {\n        // Random test case satisfying the constraints\n        a0 = rnd.next(1, maxVal);\n        b0 = rnd.next(1, maxVal);\n        c0 = rnd.next(1, maxVal);\n        l = rnd.next(0, maxVal);\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the generated test case\n    printf(\"%d %d %d %d\\n\", a0, b0, c0, l);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type valid_zero_l\n./gen -type valid_l\n./gen -type invalid_fixable\n./gen -type invalid_unfixable\n./gen -type degenerate\n./gen -type max\n./gen -type random\n\n./gen -type valid_zero_l -maxVal 100\n./gen -type valid_l -maxVal 100\n./gen -type invalid_fixable -maxVal 100\n./gen -type invalid_unfixable -maxVal 100\n./gen -type degenerate -maxVal 100\n./gen -type random -maxVal 100\n\n./gen -type valid_zero_l -maxVal 1000\n./gen -type valid_l -maxVal 1000\n./gen -type invalid_fixable -maxVal 1000\n./gen -type invalid_unfixable -maxVal 1000\n./gen -type degenerate -maxVal 1000\n./gen -type random -maxVal 1000\n\n./gen -type valid_zero_l -maxVal 10000\n./gen -type valid_l -maxVal 10000\n./gen -type invalid_fixable -maxVal 10000\n./gen -type invalid_unfixable -maxVal 10000\n./gen -type degenerate -maxVal 10000\n./gen -type random -maxVal 10000\n\n./gen -type valid_zero_l -maxVal 100000\n./gen -type valid_l -maxVal 100000\n./gen -type invalid_fixable -maxVal 100000\n./gen -type invalid_unfixable -maxVal 100000\n./gen -type degenerate -maxVal 100000\n./gen -type random -maxVal 100000\n\n./gen -type valid_zero_l -maxVal 300000\n./gen -type valid_l -maxVal 300000\n./gen -type invalid_fixable -maxVal 300000\n./gen -type invalid_unfixable -maxVal 300000\n./gen -type degenerate -maxVal 300000\n./gen -type random -maxVal 300000\n\n./gen -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:50:59.033869",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "572/D",
      "title": "D. Minimization",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (2 ≤ n ≤ 3·105, 1 ≤ k ≤ min(5000, n - 1)). The second line contains n integers A[1], A[2], ..., A[n] ( - 109 ≤ A[i] ≤ 109), separate by spaces — elements of the array A.",
      "output_spec": "OutputPrint the minimum possible value of the sum described in the statement.",
      "sample_tests": "ExamplesInputCopy3 21 2 4OutputCopy1InputCopy5 23 -5 3 -5 3OutputCopy0InputCopy6 34 3 4 3 2 5OutputCopy3",
      "description": "D. Minimization\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, k (2 ≤ n ≤ 3·105, 1 ≤ k ≤ min(5000, n - 1)). The second line contains n integers A[1], A[2], ..., A[n] ( - 109 ≤ A[i] ≤ 109), separate by spaces — elements of the array A.\n\nOutputPrint the minimum possible value of the sum described in the statement.\n\nInputCopy3 21 2 4OutputCopy1InputCopy5 23 -5 3 -5 3OutputCopy0InputCopy6 34 3 4 3 2 5OutputCopy3\n\nInputCopy3 21 2 4\n\nOutputCopy1\n\nInputCopy5 23 -5 3 -5 3\n\nOutputCopy0\n\nInputCopy6 34 3 4 3 2 5\n\nOutputCopy3\n\nNoteIn the first test one of the optimal permutations is 1 4 2. In the second test the initial order is optimal. In the third test one of the optimal permutations is 2 3 4 4 3 5.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round 317 will take place on August, 22 at 19:30 MSK.The round is prepared by AimFund employees: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina and zeliboba.Scoring system will be static. Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Max Akhmedov (Zlobober) and Maria Belova (Delinur) for English translation.Top 200 div1 participants will be awarded t-shirts. To learn more about AimFund please refer to our previous post.This round is prepared as part of \"5 years\" Codeforces program as our present to community. This round is the first Thanks-Round devoted to companies donated significant money.We wish you good luck and high frequency rating!P.S: scoring 1 div 750-1250-1500-2000-2750. 2 div 500-1000-1750-2250-2500P.P.S. Top-20 div2 participants will be awarded t-shirts.AnalysisP.P.P.S. Dear friends. We are pleased to inform you that t shirts delivery will be under way next week. We hope you will really like them. Our sincere congrats again to you all!",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1067
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 572 和字母"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, std::min(5000, n - 1), \"k\");\n    inf.readEoln();\n    inf.readInts(n, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, std::min(5000, n - 1), \"k\");\n    inf.readEoln();\n    inf.readInts(n, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, std::min(5000, n - 1), \"k\");\n    inf.readEoln();\n    inf.readInts(n, -1000000000, 1000000000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_N = 2;\nconst int MAX_N = 300000;\nconst int MIN_A = -1000000000;\nconst int MAX_A = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and k are within constraints\n    n = max(n, MIN_N);\n    n = min(n, MAX_N);\n\n    k = max(k, 1);\n    k = min(k, min(5000, n - 1));\n\n    if (n < 2) {\n        cerr << \"Error: n must be at least 2.\" << endl;\n        return 1;\n    }\n    if (k < 1 || k > min(5000, n - 1)) {\n        cerr << \"Error: k must be between 1 and min(5000, n - 1).\" << endl;\n        return 1;\n    }\n\n    vector<int> A(n);\n\n    if (type == \"equal\") {\n        // All elements are equal\n        int val = rnd.next(MIN_A, MAX_A);\n        fill(A.begin(), A.end(), val);\n    } else if (type == \"sorted\") {\n        // Elements are in increasing order\n        A[0] = rnd.next(MIN_A, MAX_A - n);\n        for (int i = 1; i < n; ++i) {\n            A[i] = A[i - 1] + rnd.next(1, 10);\n        }\n    } else if (type == \"reversed\") {\n        // Elements are in decreasing order\n        A[0] = rnd.next(MIN_A + n, MAX_A);\n        for (int i = 1; i < n; ++i) {\n            A[i] = A[i - 1] - rnd.next(1, 10);\n        }\n    } else if (type == \"maxmin\") {\n        // Elements are either MIN_A or MAX_A\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(0, 1) == 0 ? MIN_A : MAX_A;\n        }\n    } else if (type == \"zerosum\") {\n        // Construct array where minimal sum is zero\n        for (int i = 0; i < n; ++i) {\n            if (i + k < n) {\n                A[i] = rnd.next(MIN_A, MAX_A);\n                A[i + k] = A[i];\n            } else {\n                A[i] = rnd.next(MIN_A, MAX_A);\n            }\n        }\n        // Shuffle the array to avoid being sorted\n        shuffle(A.begin(), A.end());\n    } else {\n        // Random elements\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(MIN_A, MAX_A);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output array A\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", A[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_N = 2;\nconst int MAX_N = 300000;\nconst int MIN_A = -1000000000;\nconst int MAX_A = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and k are within constraints\n    n = max(n, MIN_N);\n    n = min(n, MAX_N);\n\n    k = max(k, 1);\n    k = min(k, min(5000, n - 1));\n\n    if (n < 2) {\n        cerr << \"Error: n must be at least 2.\" << endl;\n        return 1;\n    }\n    if (k < 1 || k > min(5000, n - 1)) {\n        cerr << \"Error: k must be between 1 and min(5000, n - 1).\" << endl;\n        return 1;\n    }\n\n    vector<int> A(n);\n\n    if (type == \"equal\") {\n        // All elements are equal\n        int val = rnd.next(MIN_A, MAX_A);\n        fill(A.begin(), A.end(), val);\n    } else if (type == \"sorted\") {\n        // Elements are in increasing order\n        A[0] = rnd.next(MIN_A, MAX_A - n);\n        for (int i = 1; i < n; ++i) {\n            A[i] = A[i - 1] + rnd.next(1, 10);\n        }\n    } else if (type == \"reversed\") {\n        // Elements are in decreasing order\n        A[0] = rnd.next(MIN_A + n, MAX_A);\n        for (int i = 1; i < n; ++i) {\n            A[i] = A[i - 1] - rnd.next(1, 10);\n        }\n    } else if (type == \"maxmin\") {\n        // Elements are either MIN_A or MAX_A\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(0, 1) == 0 ? MIN_A : MAX_A;\n        }\n    } else if (type == \"zerosum\") {\n        // Construct array where minimal sum is zero\n        for (int i = 0; i < n; ++i) {\n            if (i + k < n) {\n                A[i] = rnd.next(MIN_A, MAX_A);\n                A[i + k] = A[i];\n            } else {\n                A[i] = rnd.next(MIN_A, MAX_A);\n            }\n        }\n        // Shuffle the array to avoid being sorted\n        shuffle(A.begin(), A.end());\n    } else {\n        // Random elements\n        for (int i = 0; i < n; ++i) {\n            A[i] = rnd.next(MIN_A, MAX_A);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output array A\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", A[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n and k\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 1 -type equal\n\n# Maximal n and k\n./gen -n 300000 -k 5000 -type random\n./gen -n 300000 -k 5000 -type maxmin\n\n# Various sizes with different types\n./gen -n 300000 -k 1 -type sorted\n./gen -n 300000 -k 5000 -type equal\n./gen -n 300000 -k 5000 -type zerosum\n./gen -n 50000 -k 1000 -type reversed\n./gen -n 50000 -k 1000 -type sorted\n./gen -n 50000 -k 1 -type equal\n./gen -n 50000 -k 1 -type random\n\n# Small n with larger k\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 5 -type reversed\n./gen -n 10 -k 5 -type zerosum\n\n# Maximal elements\n./gen -n 100000 -k 1000 -type maxmin\n\n# Medium n and k\n./gen -n 250000 -k 4000 -type random\n./gen -n 250000 -k 4000 -type zerosum\n\n# Edge cases for n and k\n./gen -n 299999 -k 4999 -type equal\n./gen -n 299998 -k 5000 -type reversed\n\n# Small n tests\n./gen -n 3 -k 1 -type equal\n./gen -n 3 -k 2 -type sorted\n./gen -n 3 -k 1 -type reversed\n\n# Random tests\n./gen -n 200000 -k 4000 -type random\n./gen -n 200000 -k 4999 -type random\n./gen -n 150000 -k 3000 -type random\n\n# Maximal k\n./gen -n 5001 -k 5000 -type random\n./gen -n 6000 -k 5000 -type zerosum\n\n# Tests with k = n - 1\n./gen -n 6000 -k 4999 -type random\n./gen -n 6000 -k 4999 -type equal\n\n# All elements are MIN_A\n./gen -n 300000 -k 5000 -type equal\n\n# All elements are MAX_A\n./gen -n 300000 -k 5000 -type maxmin\n\n# Random tests with various k\n./gen -n 100000 -k 2500 -type random\n./gen -n 100000 -k 2500 -type zerosum\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:00.821903",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "572/E",
      "title": "E. CNF 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and m (1 ≤ n, m ≤ 2·105) — the number of clauses and the number variables, correspondingly.Next n lines contain the descriptions of each clause. The i-th line first contains first number ki (ki ≥ 1) — the number of literals in the i-th clauses. Then follow space-separated literals vij (1 ≤ |vij| ≤ m). A literal that corresponds to vij is x|vij| either with negation, if vij is negative, or without negation otherwise.",
      "output_spec": "OutputIf CNF is not satisfiable, print a single line \"NO\" (without the quotes), otherwise print two strings: string \"YES\" (without the quotes), and then a string of m numbers zero or one — the values of variables in satisfying assignment in the order from x1 to xm.",
      "sample_tests": "ExamplesInputCopy2 22 1 -22 2 -1OutputCopyYES11InputCopy4 31 11 23 -1 -2 31 -3OutputCopyNOInputCopy5 62 1 23 1 -2 34 -3 5 4 62 -6 -41 5OutputCopyYES100010",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers n and m (1 ≤ n, m ≤ 2·105) — the number of clauses and the number variables, correspondingly.Next n lines contain the descriptions of each clause. The i-th line first contains first number ki (ki ≥ 1) — the number of literals in the i-th clauses. Then follow space-separated literals vij (1 ≤ |vij| ≤ m). A literal that corresponds to vij is x|vij| either with negation, if vij is negative, or without negation otherwise.\n\nOutputIf CNF is not satisfiable, print a single line \"NO\" (without the quotes), otherwise print two strings: string \"YES\" (without the quotes), and then a string of m numbers zero or one — the values of variables in satisfying assignment in the order from x1 to xm.\n\nInputCopy2 22 1 -22 2 -1OutputCopyYES11InputCopy4 31 11 23 -1 -2 31 -3OutputCopyNOInputCopy5 62 1 23 1 -2 34 -3 5 4 62 -6 -41 5OutputCopyYES100010\n\nInputCopy2 22 1 -22 2 -1\n\nOutputCopyYES11\n\nInputCopy4 31 11 23 -1 -2 31 -3\n\nOutputCopyNO\n\nInputCopy5 62 1 23 1 -2 34 -3 5 4 62 -6 -41 5\n\nOutputCopyYES100010\n\nNoteIn the first sample test formula is . One of possible answer is x1 = TRUE, x2 = TRUE.",
      "solutions": [
        {
          "title": "Codeforces Round #317 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round 317 will take place on August, 22 at 19:30 MSK.The round is prepared by AimFund employees: Kostroma, riadwaw, yarrr, gchebanov, ArtDitel, SirShokoladina and zeliboba.Scoring system will be static. Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Max Akhmedov (Zlobober) and Maria Belova (Delinur) for English translation.Top 200 div1 participants will be awarded t-shirts. To learn more about AimFund please refer to our previous post.This round is prepared as part of \"5 years\" Codeforces program as our present to community. This round is the first Thanks-Round devoted to companies donated significant money.We wish you good luck and high frequency rating!P.S: scoring 1 div 750-1250-1500-2000-2750. 2 div 500-1000-1750-2250-2500P.P.S. Top-20 div2 participants will be awarded t-shirts.AnalysisP.P.P.S. Dear friends. We are pleased to inform you that t shirts delivery will be under way next week. We hope you will really like them. Our sincere congrats again to you all!",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/19863",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1067
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces",
          "content": "572A - ArraysIn this problem one need to check whether it's possible to choose k elements from array A and m elements from array B so that each of chosen element in A is less than each of chosen elements in B. If it's possible then it's possible to choose k smallest elements in A and m largest elements in B. That means that in particular, k-th smallest element of A is less than m-th largest element in B. So, if A[k] < B[n - m + 1] then the answer is \"YES\" and if not, then the answer is \"NO\".Problem author: zeliboba.Problem developers: riadwaw, Kostroma.Solution code: 12873382.572B - Order BookFirst of all the problem may be solved for buy orders and sell orders separately.The easiest soultion is to use structure like std::map or java.lang.TreeMap. To aggregate orders we just add volume to the corresponding map element: aggregated[price] += volume.After that we should extract lowest (or largest) element from map s times (or while it's not empty).Complexity of this solution is O(nlogn).It is also possible to solve the problem without data structres other than an array. You should just maintain at most s best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of s. Complexity of this solution is O(sn).Problem authors and developers: ArtDitel, yarrr.Solution code: 12873385.571A - Lengthening SticksLet's count the number of ways to form a triple which can't represent triangle sides, and then we subtract this value from — the total number of ways to increase the sticks not more than l in total. This number is obtained from partition of l into 4 summands (la + lb + lc + unusedl = l), or can be counted using a for loop. Now we consider triples a + la, b + lb, c + lc, where la + lb + lc ≤ l, la, lb, lc ≥ 0. Fix the maximal side, for example it would be a + la. We'll have to do the following algo for b + lb and c + lc in the same way. The triple is not a triangle with maximal side a + la if a + la ≥ b + lb + c + lc. If we iterate over la between 0 and l, we have the following conditions on lb, lc: lb + lc ≤ a - b - c + la,  lb + lc ≤ l - la, lb, lc ≥ 0. So, non-negative integers lb, lc should be such that lb + lc ≤ min(a - b - c + la, l - la). If we denote this minimum as x than we can choose lb, lc in different ways (again we divide x into three summands: lb, lc and some unused volume). Also when we fix lb, there are x - lb + 1 ways to choose lc, so the overall number of pair lb, lc is so we obtain the same formula.To sum up, we need to iterate over the maximal side and over the addition to that side, then write these formulas, and subtract the result from the total number of different additions to the sides. The complexity of the solution is O(l).Problem author: Kostroma.Problem developers: Kostroma, riadwaw.Solution code: 12873406.571B - MinimizationWe can divide all indices [1;n] into groups by their remainder modulo k. While counting , we can consider each group separately and sum the distances between neighbouring numbers in each group. Consider one group, corresponding to some remainder i modulo k, i.e. containing aj for . Let's write down its numbers from left to right: b1, b2, ..., bm. Then this group adds to the overall sum the value We can notice that if we sort b1, ..., bm in non-decreasing order, this sum will not increase. So, in the optimal answer we can consider that numbers in each group don't decrease. Furthermore, in that case this sum is equal to |bm - b1|.Now consider two groups b1, ..., bm and c1, c2, ..., cl, both sorted in non-decreasing order. We claim that either b1 ≥ cl or bm ≤ c1, i.e. segments [b1, bm] and [c1, cl] can have common points only in their endpoints.Why is this true? These groups add |bm - b1| + |cl - c1| to the overall sum. We consider the case c1 ≥ b1, the other is symmetric. If c1 < bm, then swapping c1 and bm will not increase the values these groups add to the answer, since the right border of b group moves to the left, and the left border of c group moves to the right. So, c1 ≥ bm in that case, and the assertion is proved.Now we know that the values in each group should from a continuous segment of the sorted original array. In fact, we have groups of size (so called small groups) and groups of size (so called large groups). Consider the following dynamic programming: dp[L][S] — the minimal sum of values added to the answer by L large groups and S small groups, if we choose the elements for them from the first elements of the sorted array A. There are no more than O(k2) states, and each transition can be made in O(1): we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array. The answer for the problem will be in .The overall complexity of the solution is . We can note that in pretests was quite small, and some slower solutions could pass, but they failed on final tests.Problem author: zeliboba.Problem developers: Kostroma, riadwaw.Solution code: 12873418.571C - CNF 2Firstly let's assign values to variables occurring in our fomula only with negation or only without negation. After that we can throw away the disjuncts which contained them, since they are already true, and continue the process until it is possible. To make it run in time limit, one should use dfs or bfs algorithm to eliminate these variables and disjuncts.So now we have only variables which have both types of occurrences in disjucnts. Let's build a graph with the vertices corresponding to disjuncts, and for each varible a make an edge between the disjuncts that contain a and !a. Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge. We can notice that if some connected component of this graph is a tree, the solution is not possible: on each step we can take some leaf of this tree, and we have to orient its only edge to it, and then erase the leaf. In the end we'll have only one vertex, and it'll not have any incoming edges.Otherwise, take some cycle in the component and orient the edges between neighbouring vertices along it. Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it. It is easy to easy that after this process every vertex will have at least one incoming edge.So, we should consider cases with the variables which values can be assigned at once, than construct a graph from disjuncts and variables and find whether each connected component has a cycle. If so, we also should carefully construct the answer, assigning the remaining variables their values, looking at the directions of the edges in the graph. The overall complexity is O(n + m).Problem author: zeliboba.Problem developers: Kostroma, zeliboba, yarrr.Solution codes: 12873432 (linear solution), 12873446 (), 12873456 (matching solution).571D - CampusLet's suppose for each dormitory from Q query we already know the last raid moment.When task will be much easier: we can throw away M and Z queries and to get right answer we should subtract two values: people count in dormitory right now and same count in a last raid moment.On this basis, we have such plan: For each Q query let's find the last raid moment using M and Z queries. Find people count in two interesting moments using U and A queries. Calculcates the final answer. Let's try to solve the first part.We want to make such queries on disjoint sets: Merge two sets (M query). Assign value time for all elements in particular set (Z query). Get value for a particular element (Q query). To solve this task we'll use a well-known technique: \"merge smaller set to bigger\".We'll maintain such values: elements — set elements. set_id — for each element their set id. last_set_update_time — last moment when assign operation has occurred for each set. last_update_time — last moment when assign operation has occurred for each element. actual_time — moment of time when last_update_time was actually for the element. Let's focus on actual_time value.It's obvious that when we merge two sets each element can have a different last assign moment. But after first assignment all elements from any set will have the same value. So the answer for Q query for element i from set s: If last_set_update_time[s]=actual_time[i] then last_update_time[i] else last_set_update_time[s]For each Z query you should just update last_set_update_time array.It's easy to maintain this values when you merge two sets:Let's suppose we want to merge set from to set to. For each element from set from we already know last assign time. So just update last_update_time with this value and actual_time is equal of last assign operation for set to.The second part of the solution is the same as first one.O(n * lg(n) + m) time and O(n + m) memory.Problem author: ArtDitel.Problem developers: yarrr, gchebanov, Kostroma.Solution codes: 12873477 (solution, described in the editorail), 12873469 (solution with treaps).571E - Geometric ProgressionsIf intersection of two geometric progressions is not empty, set of common elements indexes forms arithmetic progression in each progression or consists of not more than one element. Let's intersect first progression with each other progression. If any of these intersections are empty then total intersection is empty. If some of these intersection consist of one element, then we could check only this element. Otherwise one could intersect arithmetic progressions of first progression indexes and take minimal element of this intersection. The remaining question is how intersect two geometric progression? Let's factorise all numbers in these two progressions and find set of appropriate indexes for every prime factor in both progressions. These progressions one need intersect both by values and by indexes.Problem author: zeliboba.Problem developers: zeliboba, yarrr, gchebanov.Solution code: 12873480.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19923",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 572 和字母"
          },
          "content_length": 9937
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #317 - Codeforces - Code 1",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 2",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 3",
          "code": "ll f(ll a, ll b, ll c, ll l) {\n    if (a < b + c)\n      return 0;\n    ll d = min(l, a - b - c);\n    return (d + 1) * (d + 2) / 2;\n  } \n  \n  int solve(ll a, ll b, ll c, ll l) {\n    ll ans = (l + 1) * (l + 2) * (l + 3) / 6;\n    for (int i = 0; i <= l; ++i) {\n      ans -= f(a + i, b, c, l - i);\n      ans -= f(b + i, a, c, l - i);\n      ans -= f(c + i, b, a, l - i);\n    }\n    cout<<ans;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 4",
          "code": "(l + 1)*(l + 2)*(l + 3)/6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 5",
          "code": "cnt0 = (n-cnt1*l1)/l0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 6",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 - Codeforces - Code 7",
          "code": "if (vis2[nei] && e != wh_var) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19863",
          "author": "zeliboba"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "aggregated[price] += volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "If  last_set_update_time[s]=actual_time[i]  then  last_update_time[i]  else  last_set_update_time[s]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "13 7\n-1 -1 0 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "-1 1 1 1 1 1 0 1 1 1 1 1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "-1 1 1 1 1 1 0 -1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #317 [AimFund Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "[-1, -1], [0], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/19923",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> varClauseCount(m+1, 0); // Variables are numbered from 1 to m\n\n    long long totalLiterals = 0; // Total number of literals read\n\n    for (int clause_idx = 0; clause_idx < n; clause_idx++) {\n        // Read ki\n        int ki = inf.readInt(1, m, \"k[\" + to_string(clause_idx+1) + \"]\");\n        ensuref(ki >=1 && ki <= m, \"ki must be between 1 and m, but k[%d]=%d\", clause_idx+1, ki);\n\n        totalLiterals += ki;\n        ensuref(totalLiterals <= 2LL * m, \"Total number of literals exceeds 2*m\");\n\n        inf.readSpace();\n\n        set<int> vars_in_clause; // To check duplicates in clause, store variables (absolute values)\n\n        for (int j = 0; j < ki; j++) {\n            int vij;\n\n            if (j+1 == ki) {  // Last literal\n                vij = inf.readInt(-m, m, \"v[\" + to_string(clause_idx+1) + \"][\" + to_string(j+1) + \"]\");\n                ensuref(vij != 0, \"v[%d][%d] cannot be zero\", clause_idx+1, j+1);\n            } else {\n                vij = inf.readInt(-m, m, \"v[\" + to_string(clause_idx+1) + \"][\" + to_string(j+1) + \"]\");\n                ensuref(vij != 0, \"v[%d][%d] cannot be zero\", clause_idx+1, j+1);\n                inf.readSpace();\n            }\n            int var_id = abs(vij);\n            // Check for duplicates in clause\n            ensuref(vars_in_clause.count(var_id) == 0, \"Variable %d occurs more than once in clause %d\", var_id, clause_idx+1);\n            vars_in_clause.insert(var_id);\n\n            varClauseCount[var_id]++;\n            ensuref(varClauseCount[var_id] <= 2, \"Variable %d occurs in more than two clauses\", var_id);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> varClauseCount(m+1, 0); // Variables are numbered from 1 to m\n\n    long long totalLiterals = 0; // Total number of literals read\n\n    for (int clause_idx = 0; clause_idx < n; clause_idx++) {\n        // Read ki\n        int ki = inf.readInt(1, m, \"k[\" + to_string(clause_idx+1) + \"]\");\n        ensuref(ki >=1 && ki <= m, \"ki must be between 1 and m, but k[%d]=%d\", clause_idx+1, ki);\n\n        totalLiterals += ki;\n        ensuref(totalLiterals <= 2LL * m, \"Total number of literals exceeds 2*m\");\n\n        inf.readSpace();\n\n        set<int> vars_in_clause; // To check duplicates in clause, store variables (absolute values)\n\n        for (int j = 0; j < ki; j++) {\n            int vij;\n\n            if (j+1 == ki) {  // Last literal\n                vij = inf.readInt(-m, m, \"v[\" + to_string(clause_idx+1) + \"][\" + to_string(j+1) + \"]\");\n                ensuref(vij != 0, \"v[%d][%d] cannot be zero\", clause_idx+1, j+1);\n            } else {\n                vij = inf.readInt(-m, m, \"v[\" + to_string(clause_idx+1) + \"][\" + to_string(j+1) + \"]\");\n                ensuref(vij != 0, \"v[%d][%d] cannot be zero\", clause_idx+1, j+1);\n                inf.readSpace();\n            }\n            int var_id = abs(vij);\n            // Check for duplicates in clause\n            ensuref(vars_in_clause.count(var_id) == 0, \"Variable %d occurs more than once in clause %d\", var_id, clause_idx+1);\n            vars_in_clause.insert(var_id);\n\n            varClauseCount[var_id]++;\n            ensuref(varClauseCount[var_id] <= 2, \"Variable %d occurs in more than two clauses\", var_id);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> varClauseCount(m+1, 0); // Variables are numbered from 1 to m\n\n    long long totalLiterals = 0; // Total number of literals read\n\n    for (int clause_idx = 0; clause_idx < n; clause_idx++) {\n        // Read ki\n        int ki = inf.readInt(1, m, \"k[\" + to_string(clause_idx+1) + \"]\");\n        ensuref(ki >=1 && ki <= m, \"ki must be between 1 and m, but k[%d]=%d\", clause_idx+1, ki);\n\n        totalLiterals += ki;\n        ensuref(totalLiterals <= 2LL * m, \"Total number of literals exceeds 2*m\");\n\n        inf.readSpace();\n\n        set<int> vars_in_clause; // To check duplicates in clause, store variables (absolute values)\n\n        for (int j = 0; j < ki; j++) {\n            int vij;\n\n            if (j+1 == ki) {  // Last literal\n                vij = inf.readInt(-m, m, \"v[\" + to_string(clause_idx+1) + \"][\" + to_string(j+1) + \"]\");\n                ensuref(vij != 0, \"v[%d][%d] cannot be zero\", clause_idx+1, j+1);\n            } else {\n                vij = inf.readInt(-m, m, \"v[\" + to_string(clause_idx+1) + \"][\" + to_string(j+1) + \"]\");\n                ensuref(vij != 0, \"v[%d][%d] cannot be zero\", clause_idx+1, j+1);\n                inf.readSpace();\n            }\n            int var_id = abs(vij);\n            // Check for duplicates in clause\n            ensuref(vars_in_clause.count(var_id) == 0, \"Variable %d occurs more than once in clause %d\", var_id, clause_idx+1);\n            vars_in_clause.insert(var_id);\n\n            varClauseCount[var_id]++;\n            ensuref(varClauseCount[var_id] <= 2, \"Variable %d occurs in more than two clauses\", var_id);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 200000);\n    int m = inf.readInt(1, 200000);\n    vector<vector<int>> clauses(n);\n\n    for (int i = 0; i < n; ++i) {\n        int k = inf.readInt(1, m);\n        clauses[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            clauses[i][j] = inf.readInt(-m, m);\n            if (clauses[i][j] == 0) {\n                inf.quitf(_fail, \"Variable index cannot be zero\");\n            }\n        }\n    }\n\n    string jury_answer = ans.readToken();\n    string participant_answer = ouf.readToken();\n\n    transform(jury_answer.begin(), jury_answer.end(), jury_answer.begin(), ::toupper);\n    transform(participant_answer.begin(), participant_answer.end(), participant_answer.begin(), ::toupper);\n\n    if (jury_answer == \"NO\") {\n        if (participant_answer == \"NO\") {\n            quitf(_ok, \"Correct: both found unsatisfiable\");\n        } else if (participant_answer == \"YES\") {\n            quitf(_wa, \"Participant found satisfiable assignment, but jury says unsatisfiable\");\n        } else {\n            quitf(_wa, \"Participant answer is neither YES nor NO\");\n        }\n    } else if (jury_answer == \"YES\") {\n        if (participant_answer == \"NO\") {\n            quitf(_wa, \"Participant says unsatisfiable, but jury says satisfiable\");\n        } else if (participant_answer == \"YES\") {\n            string assignment = ouf.readToken();\n            if (int(assignment.size()) != m) {\n                quitf(_wa, \"Assignment length is %d, expected %d\", (int)assignment.size(), m);\n            }\n            vector<int> vars(m + 1);\n            for (int i = 0; i < m; ++i) {\n                if (assignment[i] == '0')\n                    vars[i + 1] = 0;\n                else if (assignment[i] == '1')\n                    vars[i + 1] = 1;\n                else {\n                    quitf(_wa, \"Invalid character '%c' at position %d\", assignment[i], i + 1);\n                }\n            }\n            for (int i = 0; i < n; ++i) {\n                bool clause_satisfied = false;\n                for (int lit : clauses[i]) {\n                    int var_idx = abs(lit);\n                    int var_value = vars[var_idx];\n                    if (lit > 0 && var_value == 1) {\n                        clause_satisfied = true;\n                        break;\n                    }\n                    if (lit < 0 && var_value == 0) {\n                        clause_satisfied = true;\n                        break;\n                    }\n                }\n                if (!clause_satisfied) {\n                    quitf(_wa, \"Assignment does not satisfy clause %d\", i + 1);\n                }\n            }\n            quitf(_ok, \"Assignment satisfies the CNF\");\n        } else {\n            quitf(_wa, \"Participant answer is neither YES nor NO\");\n        }\n    } else {\n        quitf(_fail, \"Jury answer is neither YES nor NO\");\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int l_max = opt<int>(\"lmax\", 3); // Maximum number of literals per clause\n\n    // Variables occurrence counts (from 1 to m)\n    vector<int> variable_occurrences(m + 1, 0);\n\n    // Variables with less than 2 occurrences\n    vector<int> available_variables;\n    for (int i = 1; i <= m; ++i) {\n        available_variables.push_back(i);\n    }\n\n    // Total variable occurrences left\n    int total_variable_occurrences_left = 2 * m;\n\n    vector<vector<int>> clauses;\n\n    if (type == \"satisfiable\") {\n        // Generate a random assignment\n        vector<int> assignment(m + 1);\n        for (int i = 1; i <= m; ++i) {\n            assignment[i] = rnd.next(0, 1);\n        }\n\n        for (int i = 0; i < n && total_variable_occurrences_left > 0; ++i) {\n            // Decide the number of literals in the clause\n            int ki = rnd.next(1, min(l_max, total_variable_occurrences_left - (n - i - 1)));\n            total_variable_occurrences_left -= ki;\n\n            set<int> clause_vars; // To ensure variables are not duplicated in a clause\n            vector<int> clause;\n\n            // First literal to satisfy the clause under assignment\n            if (available_variables.empty()) break;\n\n            int idx = rnd.next(0, (int)available_variables.size() - 1);\n            int vi = available_variables[idx];\n            clause_vars.insert(vi);\n\n            int literal = assignment[vi] ? vi : -vi;\n            clause.push_back(literal);\n\n            variable_occurrences[vi]++;\n            if (variable_occurrences[vi] == 2) {\n                swap(available_variables[idx], available_variables.back());\n                available_variables.pop_back();\n            }\n\n            // Remaining literals\n            for (int j = 1; j < ki; ++j) {\n                if (available_variables.empty()) break;\n\n                int idx = rnd.next(0, (int)available_variables.size() - 1);\n                int vi = available_variables[idx];\n                if (clause_vars.count(vi)) {\n                    --j;\n                    continue;\n                }\n                clause_vars.insert(vi);\n\n                int literal = rnd.next(0, 1) ? vi : -vi;\n                clause.push_back(literal);\n\n                variable_occurrences[vi]++;\n                if (variable_occurrences[vi] == 2) {\n                    swap(available_variables[idx], available_variables.back());\n                    available_variables.pop_back();\n                }\n            }\n            clauses.push_back(clause);\n        }\n    } else if (type == \"unsatisfiable\") {\n        // Create contradictory clauses\n        int variables_used = min(m, n / 2);\n        for (int i = 1; i <= variables_used; ++i) {\n            if (variable_occurrences[i] < 2) {\n                vector<int> clause1 = {i};\n                clauses.push_back(clause1);\n                variable_occurrences[i]++;\n                if (variable_occurrences[i] == 2) {\n                    available_variables.erase(find(available_variables.begin(), available_variables.end(), i));\n                }\n                vector<int> clause2 = {-i};\n                clauses.push_back(clause2);\n                variable_occurrences[i]++;\n                if (variable_occurrences[i] == 2) {\n                    available_variables.erase(find(available_variables.begin(), available_variables.end(), i));\n                }\n            }\n        }\n        // Fill remaining clauses randomly\n        for (int i = clauses.size(); i < n && total_variable_occurrences_left > 0; ++i) {\n            int ki = rnd.next(1, min(l_max, total_variable_occurrences_left - (n - i - 1)));\n            total_variable_occurrences_left -= ki;\n\n            set<int> clause_vars;\n            vector<int> clause;\n\n            for (int j = 0; j < ki; ++j) {\n                if (available_variables.empty()) break;\n\n                int idx = rnd.next(0, (int)available_variables.size() - 1);\n                int vi = available_variables[idx];\n                if (clause_vars.count(vi)) {\n                    --j;\n                    continue;\n                }\n                clause_vars.insert(vi);\n\n                int literal = rnd.next(0, 1) ? vi : -vi;\n                clause.push_back(literal);\n\n                variable_occurrences[vi]++;\n                if (variable_occurrences[vi] == 2) {\n                    swap(available_variables[idx], available_variables.back());\n                    available_variables.pop_back();\n                }\n            }\n            if (!clause.empty()) clauses.push_back(clause);\n        }\n    } else { // Random type\n        for (int i = 0; i < n && total_variable_occurrences_left > 0; ++i) {\n            int ki = rnd.next(1, min(l_max, total_variable_occurrences_left - (n - i - 1)));\n            total_variable_occurrences_left -= ki;\n\n            set<int> clause_vars;\n            vector<int> clause;\n\n            for (int j = 0; j < ki; ++j) {\n                if (available_variables.empty()) break;\n\n                int idx = rnd.next(0, (int)available_variables.size() - 1);\n                int vi = available_variables[idx];\n                if (clause_vars.count(vi)) {\n                    --j;\n                    continue;\n                }\n                clause_vars.insert(vi);\n\n                int literal = rnd.next(0, 1) ? vi : -vi;\n                clause.push_back(literal);\n\n                variable_occurrences[vi]++;\n                if (variable_occurrences[vi] == 2) {\n                    swap(available_variables[idx], available_variables.back());\n                    available_variables.pop_back();\n                }\n            }\n            if (!clause.empty()) clauses.push_back(clause);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", (int)clauses.size(), m);\n    for (const auto& clause : clauses) {\n        printf(\"%d\", (int)clause.size());\n        for (int literal : clause) {\n            printf(\" %d\", literal);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int l_max = opt<int>(\"lmax\", 3); // Maximum number of literals per clause\n\n    // Variables occurrence counts (from 1 to m)\n    vector<int> variable_occurrences(m + 1, 0);\n\n    // Variables with less than 2 occurrences\n    vector<int> available_variables;\n    for (int i = 1; i <= m; ++i) {\n        available_variables.push_back(i);\n    }\n\n    // Total variable occurrences left\n    int total_variable_occurrences_left = 2 * m;\n\n    vector<vector<int>> clauses;\n\n    if (type == \"satisfiable\") {\n        // Generate a random assignment\n        vector<int> assignment(m + 1);\n        for (int i = 1; i <= m; ++i) {\n            assignment[i] = rnd.next(0, 1);\n        }\n\n        for (int i = 0; i < n && total_variable_occurrences_left > 0; ++i) {\n            // Decide the number of literals in the clause\n            int ki = rnd.next(1, min(l_max, total_variable_occurrences_left - (n - i - 1)));\n            total_variable_occurrences_left -= ki;\n\n            set<int> clause_vars; // To ensure variables are not duplicated in a clause\n            vector<int> clause;\n\n            // First literal to satisfy the clause under assignment\n            if (available_variables.empty()) break;\n\n            int idx = rnd.next(0, (int)available_variables.size() - 1);\n            int vi = available_variables[idx];\n            clause_vars.insert(vi);\n\n            int literal = assignment[vi] ? vi : -vi;\n            clause.push_back(literal);\n\n            variable_occurrences[vi]++;\n            if (variable_occurrences[vi] == 2) {\n                swap(available_variables[idx], available_variables.back());\n                available_variables.pop_back();\n            }\n\n            // Remaining literals\n            for (int j = 1; j < ki; ++j) {\n                if (available_variables.empty()) break;\n\n                int idx = rnd.next(0, (int)available_variables.size() - 1);\n                int vi = available_variables[idx];\n                if (clause_vars.count(vi)) {\n                    --j;\n                    continue;\n                }\n                clause_vars.insert(vi);\n\n                int literal = rnd.next(0, 1) ? vi : -vi;\n                clause.push_back(literal);\n\n                variable_occurrences[vi]++;\n                if (variable_occurrences[vi] == 2) {\n                    swap(available_variables[idx], available_variables.back());\n                    available_variables.pop_back();\n                }\n            }\n            clauses.push_back(clause);\n        }\n    } else if (type == \"unsatisfiable\") {\n        // Create contradictory clauses\n        int variables_used = min(m, n / 2);\n        for (int i = 1; i <= variables_used; ++i) {\n            if (variable_occurrences[i] < 2) {\n                vector<int> clause1 = {i};\n                clauses.push_back(clause1);\n                variable_occurrences[i]++;\n                if (variable_occurrences[i] == 2) {\n                    available_variables.erase(find(available_variables.begin(), available_variables.end(), i));\n                }\n                vector<int> clause2 = {-i};\n                clauses.push_back(clause2);\n                variable_occurrences[i]++;\n                if (variable_occurrences[i] == 2) {\n                    available_variables.erase(find(available_variables.begin(), available_variables.end(), i));\n                }\n            }\n        }\n        // Fill remaining clauses randomly\n        for (int i = clauses.size(); i < n && total_variable_occurrences_left > 0; ++i) {\n            int ki = rnd.next(1, min(l_max, total_variable_occurrences_left - (n - i - 1)));\n            total_variable_occurrences_left -= ki;\n\n            set<int> clause_vars;\n            vector<int> clause;\n\n            for (int j = 0; j < ki; ++j) {\n                if (available_variables.empty()) break;\n\n                int idx = rnd.next(0, (int)available_variables.size() - 1);\n                int vi = available_variables[idx];\n                if (clause_vars.count(vi)) {\n                    --j;\n                    continue;\n                }\n                clause_vars.insert(vi);\n\n                int literal = rnd.next(0, 1) ? vi : -vi;\n                clause.push_back(literal);\n\n                variable_occurrences[vi]++;\n                if (variable_occurrences[vi] == 2) {\n                    swap(available_variables[idx], available_variables.back());\n                    available_variables.pop_back();\n                }\n            }\n            if (!clause.empty()) clauses.push_back(clause);\n        }\n    } else { // Random type\n        for (int i = 0; i < n && total_variable_occurrences_left > 0; ++i) {\n            int ki = rnd.next(1, min(l_max, total_variable_occurrences_left - (n - i - 1)));\n            total_variable_occurrences_left -= ki;\n\n            set<int> clause_vars;\n            vector<int> clause;\n\n            for (int j = 0; j < ki; ++j) {\n                if (available_variables.empty()) break;\n\n                int idx = rnd.next(0, (int)available_variables.size() - 1);\n                int vi = available_variables[idx];\n                if (clause_vars.count(vi)) {\n                    --j;\n                    continue;\n                }\n                clause_vars.insert(vi);\n\n                int literal = rnd.next(0, 1) ? vi : -vi;\n                clause.push_back(literal);\n\n                variable_occurrences[vi]++;\n                if (variable_occurrences[vi] == 2) {\n                    swap(available_variables[idx], available_variables.back());\n                    available_variables.pop_back();\n                }\n            }\n            if (!clause.empty()) clauses.push_back(clause);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", (int)clauses.size(), m);\n    for (const auto& clause : clauses) {\n        printf(\"%d\", (int)clause.size());\n        for (int literal : clause) {\n            printf(\" %d\", literal);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random -lmax 2\n./gen -n 20 -m 15 -type random -lmax 3\n\n# Small satisfiable test cases\n./gen -n 5 -m 5 -type satisfiable\n./gen -n 10 -m 10 -type satisfiable -lmax 2\n./gen -n 20 -m 15 -type satisfiable -lmax 3\n\n# Small unsatisfiable test cases\n./gen -n 6 -m 5 -type unsatisfiable\n./gen -n 12 -m 10 -type unsatisfiable -lmax 2\n./gen -n 18 -m 15 -type unsatisfiable -lmax 3\n\n# Large random test cases\n./gen -n 100000 -m 100000 -type random\n./gen -n 200000 -m 100000 -type random -lmax 2\n\n# Large satisfiable test cases\n./gen -n 100000 -m 100000 -type satisfiable\n./gen -n 200000 -m 100000 -type satisfiable -lmax 2\n\n# Large unsatisfiable test cases\n./gen -n 200000 -m 100000 -type unsatisfiable\n./gen -n 200000 -m 100000 -type unsatisfiable -lmax 2\n\n# Edge cases\n# Variables not appearing at all\n./gen -n 10 -m 15 -type satisfiable -lmax 1\n\n# Variables appearing exactly twice\n./gen -n 100000 -m 50000 -type random -lmax 2\n\n# Clauses with maximum literals\n./gen -n 1000 -m 1000 -type random -lmax 10\n\n# Minimum number of clauses\n./gen -n 1 -m 100000 -type satisfiable -lmax 5\n\n# All variables with only positive literals\n./gen -n 100000 -m 100000 -type satisfiable\n\n# All variables with only negative literals\n./gen -n 100000 -m 100000 -type satisfiable\n\n# Mixed random clauses\n./gen -n 50000 -m 100000 -type random -lmax 5\n\n# Clauses with single literals (unit clauses)\n./gen -n 100000 -m 100000 -type random -lmax 1\n\n# Testing constraints\n./gen -n 200000 -m 200000 -type random\n\n# Random cases for stress testing\n./gen -n 150000 -m 150000 -type random\n./gen -n 175000 -m 150000 -type random\n\n# Test case with maximum allowed values\n./gen -n 200000 -m 200000 -type random\n\n# Test cases with varying lmax\n./gen -n 100000 -m 100000 -type random -lmax 1\n./gen -n 100000 -m 100000 -type random -lmax 2\n./gen -n 100000 -m 100000 -type random -lmax 3\n./gen -n 100000 -m 100000 -type random -lmax 4\n./gen -n 100000 -m 100000 -type random -lmax 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:02.424598",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "573/A",
      "title": "A. Bear and Poker",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of input contains an integer n (2 ≤ n ≤ 105), the number of players.The second line contains n integer numbers a1, a2, ..., an (1 ≤ ai ≤ 109) — the bids of players.",
      "output_spec": "OutputPrint \"Yes\" (without the quotes) if players can make their bids become equal, or \"No\" otherwise.",
      "sample_tests": "ExamplesInputCopy475 150 75 50OutputCopyYesInputCopy3100 150 250OutputCopyNo",
      "description": "A. Bear and Poker\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains an integer n (2 ≤ n ≤ 105), the number of players.The second line contains n integer numbers a1, a2, ..., an (1 ≤ ai ≤ 109) — the bids of players.\n\nOutputPrint \"Yes\" (without the quotes) if players can make their bids become equal, or \"No\" otherwise.\n\nInputCopy475 150 75 50OutputCopyYesInputCopy3100 150 250OutputCopyNo\n\nInputCopy475 150 75 50\n\nOutputCopyYes\n\nInputCopy3100 150 250\n\nOutputCopyNo\n\nNoteIn the first sample test first and third players should double their bids twice, second player should double his bid once and fourth player should both double and triple his bid.It can be shown that in the second sample test there is no way to make all bids equal.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        /* All numbers are equal */\n        int x = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = x;\n    } else if (type == \"same_remaining\") {\n        /* All numbers have same remaining factor after removing 2s and 3s */\n        int base = rnd.next(1, 1000000000);\n        // Remove factors of 2 and 3 from base\n        int temp = base;\n        while (temp % 2 == 0) temp /= 2;\n        while (temp % 3 == 0) temp /= 3;\n        int remaining = temp;\n        if(remaining == 0) remaining = 1;\n\n        for(int i = 0; i < n; ++i) {\n            int x = remaining;\n            // Multiply x by random powers of 2 and 3\n            int pow2 = rnd.next(0, 30);\n            int pow3 = rnd.next(0, 19);\n            for (int j = 0; j < pow2; ++j) {\n                if ((long long)x * 2 > 1e9) break;\n                x *= 2;\n            }\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n    } else if (type == \"different_remaining\") {\n        /* At least two numbers have different remaining factors after removing 2s and 3s */\n        int n1 = rnd.next(1, n-1);\n        int n2 = n - n1;\n\n        // First n1 numbers have remaining factor r1\n        int r1 = rnd.next(2, 1000);\n        while (r1 % 2 == 0 || r1 % 3 == 0) {\n            r1 = rnd.next(2, 1000);\n        }\n        // Second n2 numbers have remaining factor r2 != r1\n        int r2 = rnd.next(2, 1000);\n        while(r2 == r1 || r2 % 2 == 0 || r2 % 3 == 0) {\n            r2 = rnd.next(2, 1000);\n        }\n\n        for(int i = 0; i < n1; ++i) {\n            int x = r1;\n            // Multiply x by random powers of 2 and 3\n            int pow2 = rnd.next(0, 30);\n            int pow3 = rnd.next(0, 19);\n            for (int j = 0; j < pow2; ++j) {\n                if ((long long)x * 2 > 1e9) break;\n                x *= 2;\n            }\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n        for(int i = n1; i < n; ++i) {\n            int x = r2;\n            // Multiply x by random powers of 2 and 3\n            int pow2 = rnd.next(0, 30);\n            int pow3 = rnd.next(0, 19);\n            for (int j = 0; j < pow2; ++j) {\n                if ((long long)x * 2 > 1e9) break;\n                x *= 2;\n            }\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"random\") {\n        /* Random numbers between 1 and 1e9 */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"max\") {\n        /* All numbers are 1e9 */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"powers_of_2\") {\n        /* All numbers are powers of 2 */\n        for(int i = 0; i < n; ++i) {\n            int pow2 = rnd.next(0, 30);\n            a[i] = 1 << pow2;\n        }\n    } else if (type == \"powers_of_3\") {\n        /* All numbers are powers of 3 */\n        for(int i = 0; i < n; ++i) {\n            int pow3 = rnd.next(0,19); //3^19 is about 1e9\n            int x = 1;\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n    } else {\n        /* Default: Random numbers */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        /* All numbers are equal */\n        int x = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = x;\n    } else if (type == \"same_remaining\") {\n        /* All numbers have same remaining factor after removing 2s and 3s */\n        int base = rnd.next(1, 1000000000);\n        // Remove factors of 2 and 3 from base\n        int temp = base;\n        while (temp % 2 == 0) temp /= 2;\n        while (temp % 3 == 0) temp /= 3;\n        int remaining = temp;\n        if(remaining == 0) remaining = 1;\n\n        for(int i = 0; i < n; ++i) {\n            int x = remaining;\n            // Multiply x by random powers of 2 and 3\n            int pow2 = rnd.next(0, 30);\n            int pow3 = rnd.next(0, 19);\n            for (int j = 0; j < pow2; ++j) {\n                if ((long long)x * 2 > 1e9) break;\n                x *= 2;\n            }\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n    } else if (type == \"different_remaining\") {\n        /* At least two numbers have different remaining factors after removing 2s and 3s */\n        int n1 = rnd.next(1, n-1);\n        int n2 = n - n1;\n\n        // First n1 numbers have remaining factor r1\n        int r1 = rnd.next(2, 1000);\n        while (r1 % 2 == 0 || r1 % 3 == 0) {\n            r1 = rnd.next(2, 1000);\n        }\n        // Second n2 numbers have remaining factor r2 != r1\n        int r2 = rnd.next(2, 1000);\n        while(r2 == r1 || r2 % 2 == 0 || r2 % 3 == 0) {\n            r2 = rnd.next(2, 1000);\n        }\n\n        for(int i = 0; i < n1; ++i) {\n            int x = r1;\n            // Multiply x by random powers of 2 and 3\n            int pow2 = rnd.next(0, 30);\n            int pow3 = rnd.next(0, 19);\n            for (int j = 0; j < pow2; ++j) {\n                if ((long long)x * 2 > 1e9) break;\n                x *= 2;\n            }\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n        for(int i = n1; i < n; ++i) {\n            int x = r2;\n            // Multiply x by random powers of 2 and 3\n            int pow2 = rnd.next(0, 30);\n            int pow3 = rnd.next(0, 19);\n            for (int j = 0; j < pow2; ++j) {\n                if ((long long)x * 2 > 1e9) break;\n                x *= 2;\n            }\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"random\") {\n        /* Random numbers between 1 and 1e9 */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"max\") {\n        /* All numbers are 1e9 */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"powers_of_2\") {\n        /* All numbers are powers of 2 */\n        for(int i = 0; i < n; ++i) {\n            int pow2 = rnd.next(0, 30);\n            a[i] = 1 << pow2;\n        }\n    } else if (type == \"powers_of_3\") {\n        /* All numbers are powers of 3 */\n        for(int i = 0; i < n; ++i) {\n            int pow3 = rnd.next(0,19); //3^19 is about 1e9\n            int x = 1;\n            for (int j = 0; j < pow3; ++j) {\n                if ((long long)x * 3 > 1e9) break;\n                x *= 3;\n            }\n            a[i] = x;\n        }\n    } else {\n        /* Default: Random numbers */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type equal\n./gen -n 2 -type same_remaining\n./gen -n 2 -type different_remaining\n./gen -n 2 -type random\n./gen -n 2 -type powers_of_2\n./gen -n 2 -type powers_of_3\n./gen -n 2 -type max\n\n./gen -n 10 -type equal\n./gen -n 10 -type same_remaining\n./gen -n 10 -type different_remaining\n./gen -n 10 -type random\n\n./gen -n 100 -type equal\n./gen -n 100 -type same_remaining\n./gen -n 100 -type different_remaining\n./gen -n 100 -type random\n\n./gen -n 1000 -type equal\n./gen -n 1000 -type same_remaining\n./gen -n 1000 -type random\n\n./gen -n 10000 -type random\n./gen -n 10000 -type max\n\n./gen -n 100000 -type random\n./gen -n 100000 -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:04.381001",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "573/B",
      "title": "B. Мишка и кубики",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105).Во второй строке записано n целых чисел через пробел h1, h2, ..., hn (1 ≤ hi ≤ 109) — размеры башен.",
      "output_spec": "Выходные данныеВыведите количество операций, необходимых для уничтожения всех башен.",
      "sample_tests": "ПримерыВходные данныеСкопировать62 1 4 6 2 2Выходные данныеСкопировать3Входные данныеСкопировать73 3 3 1 3 3 3Выходные данныеСкопировать2",
      "description": "B. Мишка и кубики\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105).Во второй строке записано n целых чисел через пробел h1, h2, ..., hn (1 ≤ hi ≤ 109) — размеры башен.\n\nВходные данные\n\nВыходные данныеВыведите количество операций, необходимых для уничтожения всех башен.\n\nВыходные данные\n\nВходные данныеСкопировать62 1 4 6 2 2Выходные данныеСкопировать3Входные данныеСкопировать73 3 3 1 3 3 3Выходные данныеСкопировать2\n\nВходные данныеСкопировать62 1 4 6 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать73 3 3 1 3 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПриведенная ниже иллюстрация показывает все три операции для первого теста. Каждый раз граничные кубики окрашены красным.    После первой операции остается четыре кубика, а после второй операции остается только один. Этот последний кубик уничтожается в третьей операции.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(min_h, max_h);\n        }\n    } else if (type == \"max_heights\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n        }\n    } else if (type == \"min_heights\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        int step = max(n - 1, 1);\n        for (int i = 0; i < n; ++i) {\n            h[i] = min_h + (long long)(max_h - min_h) * i / step;\n        }\n    } else if (type == \"decreasing\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        int step = max(n - 1, 1);\n        for (int i = 0; i < n; ++i) {\n            h[i] = max_h - (long long)(max_h - min_h) * i / step;\n        }\n    } else if (type == \"alternating\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else if (type == \"all_same\") {\n        int value = opt<int>(\"value\", 1);\n        for (int i = 0; i < n; ++i) {\n            h[i] = value;\n        }\n    } else if (type == \"pyramid\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        int mid = n / 2;\n        int step = max(mid, 1);\n        for (int i = 0; i <= mid; ++i) {\n            h[i] = min_h + (long long)(max_h - min_h) * i / step;\n        }\n        for (int i = mid + 1; i < n; ++i) {\n            h[i] = h[n - 1 - i];\n        }\n    } else {\n        // Default behavior: generate random heights.\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(min_h, max_h);\n        }\n    } else if (type == \"max_heights\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n        }\n    } else if (type == \"min_heights\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        int step = max(n - 1, 1);\n        for (int i = 0; i < n; ++i) {\n            h[i] = min_h + (long long)(max_h - min_h) * i / step;\n        }\n    } else if (type == \"decreasing\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        int step = max(n - 1, 1);\n        for (int i = 0; i < n; ++i) {\n            h[i] = max_h - (long long)(max_h - min_h) * i / step;\n        }\n    } else if (type == \"alternating\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else if (type == \"all_same\") {\n        int value = opt<int>(\"value\", 1);\n        for (int i = 0; i < n; ++i) {\n            h[i] = value;\n        }\n    } else if (type == \"pyramid\") {\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 1000000000);\n        int mid = n / 2;\n        int step = max(mid, 1);\n        for (int i = 0; i <= mid; ++i) {\n            h[i] = min_h + (long long)(max_h - min_h) * i / step;\n        }\n        for (int i = mid + 1; i < n; ++i) {\n            h[i] = h[n - 1 - i];\n        }\n    } else {\n        // Default behavior: generate random heights.\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -type min_heights\n./gen -n 1 -type max_heights\n./gen -n 1 -type all_same -value 42\n\n# Medium-sized test cases\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating -h1 1 -h2 10\n\n# Edge cases with maximum size\n./gen -n 100000 -type max_heights\n./gen -n 100000 -type min_heights\n./gen -n 100000 -type all_same -value 1\n./gen -n 100000 -type all_same -value 1000000000\n\n# Random test cases with full range of heights\n./gen -n 100000 -type random -min_h 1 -max_h 1000000000\n./gen -n 100000 -type random -min_h 999999999 -max_h 1000000000\n./gen -n 100000 -type random -min_h 1 -max_h 2\n\n# Increasing and decreasing sequences\n./gen -n 100000 -type increasing -min_h 1 -max_h 1000000000\n./gen -n 100000 -type decreasing -min_h 1 -max_h 1000000000\n\n# Alternating heights\n./gen -n 100000 -type alternating -h1 1 -h2 1000000000\n./gen -n 100000 -type alternating -h1 500000000 -h2 500000001\n\n# Pyramid shapes\n./gen -n 99999 -type pyramid -min_h 1 -max_h 1000000000\n./gen -n 100000 -type pyramid -min_h 1 -max_h 1000000000\n\n# Custom test cases\n./gen -n 100000 -type all_same -value 123456789\n./gen -n 100000 -type random -min_h 1 -max_h 1\n./gen -n 100000 -type random -min_h 1000000000 -max_h 1000000000\n\n# Additional small test cases\n./gen -n 2 -type random\n./gen -n 2 -type alternating -h1 1 -h2 1000000000\n./gen -n 3 -type pyramid -min_h 1 -max_h 3\n\n# Medium random test cases\n./gen -n 50000 -type random\n./gen -n 50000 -type random -min_h 999999999 -max_h 1000000000\n./gen -n 50000 -type random -min_h 1 -max_h 100\n\n# Edge cases with n near maximum\n./gen -n 99999 -type random\n./gen -n 99999 -type increasing -min_h 1 -max_h 1000000000\n./gen -n 99999 -type decreasing -min_h 1 -max_h 1000000000\n\n# Tests with small heights\n./gen -n 100000 -type random -min_h 1 -max_h 10\n./gen -n 100000 -type alternating -h1 5 -h2 10\n\n# Tests with prime heights\n./gen -n 100000 -type all_same -value 999999937\n./gen -n 100000 -type random -min_h 2 -max_h 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:06.045446",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "573/C",
      "title": "C. Bear and Drawing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 105).Next n - 1 lines contain description of a tree. i-th of them contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) denoting an edge between vertices ai and bi. It's guaranteed that given description forms a tree.",
      "output_spec": "OutputPrint \"Yes\" (without the quotes) if Limak can draw chosen tree. Otherwise, print \"No\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy81 21 31 66 46 76 57 8OutputCopyYesInputCopy131 21 31 42 52 62 73 83 93 104 114 124 13OutputCopyNo",
      "description": "C. Bear and Drawing\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 105).Next n - 1 lines contain description of a tree. i-th of them contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) denoting an edge between vertices ai and bi. It's guaranteed that given description forms a tree.\n\nOutputPrint \"Yes\" (without the quotes) if Limak can draw chosen tree. Otherwise, print \"No\" (without the quotes).\n\nInputCopy81 21 31 66 46 76 57 8OutputCopyYesInputCopy131 21 31 42 52 62 73 83 93 104 114 124 13OutputCopyNo\n\nInputCopy81 21 31 66 46 76 57 8\n\nOutputCopyYes\n\nInputCopy131 21 31 42 52 62 73 83 93 104 114 124 13\n\nOutputCopyNo",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Edge %d has ai == bi (%d)\", i+1, ai);\n\n        int u = min(ai, bi), v = max(ai, bi);\n        ensuref(!edges.count({u, v}), \"Duplicate edge between %d and %d\", ai, bi);\n        edges.insert({u, v});\n\n        int pa = find(ai), pb = find(bi);\n        ensuref(pa != pb, \"Cycle detected on edge %d between %d and %d\", i+1, ai, bi);\n        parent[pa] = pb;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Edge %d has ai == bi (%d)\", i+1, ai);\n\n        int u = min(ai, bi), v = max(ai, bi);\n        ensuref(!edges.count({u, v}), \"Duplicate edge between %d and %d\", ai, bi);\n        edges.insert({u, v});\n\n        int pa = find(ai), pb = find(bi);\n        ensuref(pa != pb, \"Cycle detected on edge %d between %d and %d\", i+1, ai, bi);\n        parent[pa] = pb;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Edge %d has ai == bi (%d)\", i+1, ai);\n\n        int u = min(ai, bi), v = max(ai, bi);\n        ensuref(!edges.count({u, v}), \"Duplicate edge between %d and %d\", ai, bi);\n        edges.insert({u, v});\n\n        int pa = find(ai), pb = find(bi);\n        ensuref(pa != pb, \"Cycle detected on edge %d between %d and %d\", i+1, ai, bi);\n        parent[pa] = pb;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"path\") {\n        // Create a path from 1 to n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    }\n    else if (type == \"star\") {\n        // Create a star with node 1 in the center\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    }\n    else if (type == \"caterpillar\") {\n        // Create a central path with leaves\n        int spine_length = max(1, n / 3);\n        vector<int> spine_nodes;\n        for (int i = 1; i <= spine_length; ++i) {\n            spine_nodes.push_back(i);\n        }\n        for (int i = 1; i < spine_length; ++i) {\n            edges.push_back({spine_nodes[i - 1], spine_nodes[i]});\n        }\n        int next_node = spine_length + 1;\n        // Attach leaves to spine nodes\n        for (int i = 0; i < spine_length && next_node <= n; ++i) {\n            int leaves = 1; // number of leaves per spine node\n            for (int j = 0; j < leaves && next_node <= n; ++j) {\n                edges.push_back({spine_nodes[i], next_node++});\n            }\n        }\n    }\n    else if (type == \"binary\") {\n        // Generate a binary tree\n        vector<int> nodes;\n        nodes.push_back(1);\n        int next_node = 2;\n        for (size_t i = 0; i < nodes.size() && next_node <= n; ++i) {\n            int u = nodes[i];\n            // Left child\n            if (next_node <= n) {\n                edges.push_back({u, next_node});\n                nodes.push_back(next_node++);\n            }\n            // Right child\n            if (next_node <= n) {\n                edges.push_back({u, next_node});\n                nodes.push_back(next_node++);\n            }\n        }\n    }\n    else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Now shuffle node labels\n    vector<int> mapping(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        mapping[i] = i;\n    }\n    shuffle(mapping.begin() + 1, mapping.end());\n\n    for (auto& e : edges) {\n        e.first = mapping[e.first];\n        e.second = mapping[e.second];\n        if (rnd.next(0, 1)) swap(e.first, e.second);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"path\") {\n        // Create a path from 1 to n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    }\n    else if (type == \"star\") {\n        // Create a star with node 1 in the center\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    }\n    else if (type == \"caterpillar\") {\n        // Create a central path with leaves\n        int spine_length = max(1, n / 3);\n        vector<int> spine_nodes;\n        for (int i = 1; i <= spine_length; ++i) {\n            spine_nodes.push_back(i);\n        }\n        for (int i = 1; i < spine_length; ++i) {\n            edges.push_back({spine_nodes[i - 1], spine_nodes[i]});\n        }\n        int next_node = spine_length + 1;\n        // Attach leaves to spine nodes\n        for (int i = 0; i < spine_length && next_node <= n; ++i) {\n            int leaves = 1; // number of leaves per spine node\n            for (int j = 0; j < leaves && next_node <= n; ++j) {\n                edges.push_back({spine_nodes[i], next_node++});\n            }\n        }\n    }\n    else if (type == \"binary\") {\n        // Generate a binary tree\n        vector<int> nodes;\n        nodes.push_back(1);\n        int next_node = 2;\n        for (size_t i = 0; i < nodes.size() && next_node <= n; ++i) {\n            int u = nodes[i];\n            // Left child\n            if (next_node <= n) {\n                edges.push_back({u, next_node});\n                nodes.push_back(next_node++);\n            }\n            // Right child\n            if (next_node <= n) {\n                edges.push_back({u, next_node});\n                nodes.push_back(next_node++);\n            }\n        }\n    }\n    else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Now shuffle node labels\n    vector<int> mapping(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        mapping[i] = i;\n    }\n    shuffle(mapping.begin() + 1, mapping.end());\n\n    for (auto& e : edges) {\n        e.first = mapping[e.first];\n        e.second = mapping[e.second];\n        if (rnd.next(0, 1)) swap(e.first, e.second);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type path\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type caterpillar\n./gen -n 10 -type random\n\n./gen -n 50 -type path\n./gen -n 50 -type star\n./gen -n 50 -type binary\n./gen -n 50 -type caterpillar\n./gen -n 50 -type random\n\n./gen -n 1000 -type path\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type caterpillar\n./gen -n 1000 -type random\n\n./gen -n 10000 -type path\n./gen -n 10000 -type star\n./gen -n 10000 -type binary\n./gen -n 10000 -type caterpillar\n./gen -n 10000 -type random\n\n./gen -n 50000 -type path\n./gen -n 50000 -type star\n./gen -n 50000 -type binary\n./gen -n 50000 -type caterpillar\n./gen -n 50000 -type random\n\n./gen -n 99999 -type path\n./gen -n 99999 -type star\n./gen -n 99999 -type binary\n./gen -n 99999 -type caterpillar\n./gen -n 99999 -type random\n\n./gen -n 100000 -type path\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type caterpillar\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:07.915099",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "573/D",
      "title": "D. Bear and Cavalry",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers, n and q (2 ≤ n ≤ 30 000, 1 ≤ q ≤ 10 000).The second line contains n space-separated integers, w1, w2, ..., wn (1 ≤ wi ≤ 106) — strengths of warriors.The third line contains n space-separated integers, h1, h2, ..., hn (1 ≤ hi ≤ 106) — strengths of horses.Next q lines describe queries. i-th of them contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), indices of warriors who swap their horses with each other.",
      "output_spec": "OutputPrint q lines with answers to queries. In i-th line print the maximum possible strength of cavalry after first i queries.",
      "sample_tests": "ExamplesInputCopy4 21 10 100 10003 7 2 52 42 4OutputCopy57327532InputCopy3 37 11 53 2 11 21 32 3OutputCopy444852InputCopy7 41 2 4 8 16 32 6487 40 77 29 50 11 181 52 76 25 6OutputCopy9315930893159315",
      "description": "D. Bear and Cavalry\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers, n and q (2 ≤ n ≤ 30 000, 1 ≤ q ≤ 10 000).The second line contains n space-separated integers, w1, w2, ..., wn (1 ≤ wi ≤ 106) — strengths of warriors.The third line contains n space-separated integers, h1, h2, ..., hn (1 ≤ hi ≤ 106) — strengths of horses.Next q lines describe queries. i-th of them contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), indices of warriors who swap their horses with each other.\n\nOutputPrint q lines with answers to queries. In i-th line print the maximum possible strength of cavalry after first i queries.\n\nInputCopy4 21 10 100 10003 7 2 52 42 4OutputCopy57327532InputCopy3 37 11 53 2 11 21 32 3OutputCopy444852InputCopy7 41 2 4 8 16 32 6487 40 77 29 50 11 181 52 76 25 6OutputCopy9315930893159315\n\nInputCopy4 21 10 100 10003 7 2 52 42 4\n\nOutputCopy57327532\n\nInputCopy3 37 11 53 2 11 21 32 3\n\nOutputCopy444852\n\nInputCopy7 41 2 4 8 16 32 6487 40 77 29 50 11 181 52 76 25 6\n\nOutputCopy9315930893159315\n\nNoteClarification for the first sample: Warriors: 1 10 100 1000Horses:   3  7  2    5  After first query situation looks like the following: Warriors: 1 10 100 1000Horses:   3  5  2    7  We can get 1·2 + 10·3 + 100·7 + 1000·5 = 5732 (note that no hussar takes his own horse in this assignment).After second query we get back to initial situation and optimal assignment is 1·2 + 10·3 + 100·5 + 1000·7 = 7532.Clarification for the second sample. After first query: Warriors:  7 11 5Horses:    2  3 1 Optimal assignment is 7·1 + 11·2 + 5·3 = 44.Then after second query 7·3 + 11·2 + 5·1 = 48.Finally 7·2 + 11·3 + 5·1 = 52.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 30000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000, \"w\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000, \"h\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readEoln();\n\n        ensuref(a != b, \"a (%d) should not equal b (%d)\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 30000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000, \"w\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000, \"h\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readEoln();\n\n        ensuref(a != b, \"a (%d) should not equal b (%d)\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 30000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000, \"w\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000, \"h\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readEoln();\n\n        ensuref(a != b, \"a (%d) should not equal b (%d)\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int maxw = opt<int>(\"maxw\", 1000000);\n    int maxh = opt<int>(\"maxh\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<int> w(n), h(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, maxw);\n            h[i] = rnd.next(1, maxh);\n        }\n    } else if (type == \"same\") {\n        int valw = rnd.next(1, maxw);\n        int valh = rnd.next(1, maxh);\n        for (int i = 0; i < n; ++i) {\n            w[i] = valw;\n            h[i] = valh;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1 + i % maxw;\n            h[i] = 1 + i % maxh;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = maxw - (i % maxw);\n            h[i] = maxh - (i % maxh);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = maxw;\n            h[i] = maxh;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1;\n            h[i] = 1;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, maxw);\n            h[i] = rnd.next(1, maxh);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // output w\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // output h\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", h[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    vector<pair<int, int> > queries;\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"swap_same_pair\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"swap_sequences\") {\n        for (int i = 0; i < q; ++i) {\n            int a = i % n + 1;\n            int b = (a % n) + 1;\n            if(a == b) b = (b % n) + 1;\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"swap_adjacent\") {\n        for (int i = 0; i < q; ++i) {\n            int a = (i % (n - 1)) + 1;\n            int b = a + 1;\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"one_swap\") {\n        // Swap random pair once, rest queries swap the same pair back and forth\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        queries.push_back({a, b});\n        for (int i = 1; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int maxw = opt<int>(\"maxw\", 1000000);\n    int maxh = opt<int>(\"maxh\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<int> w(n), h(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, maxw);\n            h[i] = rnd.next(1, maxh);\n        }\n    } else if (type == \"same\") {\n        int valw = rnd.next(1, maxw);\n        int valh = rnd.next(1, maxh);\n        for (int i = 0; i < n; ++i) {\n            w[i] = valw;\n            h[i] = valh;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1 + i % maxw;\n            h[i] = 1 + i % maxh;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = maxw - (i % maxw);\n            h[i] = maxh - (i % maxh);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = maxw;\n            h[i] = maxh;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = 1;\n            h[i] = 1;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, maxw);\n            h[i] = rnd.next(1, maxh);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // output w\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // output h\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", h[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    vector<pair<int, int> > queries;\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"swap_same_pair\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"swap_sequences\") {\n        for (int i = 0; i < q; ++i) {\n            int a = i % n + 1;\n            int b = (a % n) + 1;\n            if(a == b) b = (b % n) + 1;\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"swap_adjacent\") {\n        for (int i = 0; i < q; ++i) {\n            int a = (i % (n - 1)) + 1;\n            int b = a + 1;\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"one_swap\") {\n        // Swap random pair once, rest queries swap the same pair back and forth\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        queries.push_back({a, b});\n        for (int i = 1; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -q 1 -type=min -qtype=random\n./gen -n 2 -q 1 -type=max -qtype=random\n./gen -n 10 -q 5 -type=same -qtype=swap_adjacent\n./gen -n 10 -q 10 -type=increasing -qtype=swap_sequences\n./gen -n 10 -q 10 -type=decreasing -qtype=swap_adjacent\n./gen -n 100 -q 50 -type=random -qtype=random\n./gen -n 1000 -q 500 -type=max -qtype=random\n./gen -n 1000 -q 500 -type=min -qtype=random\n./gen -n 1000 -q 1000 -type=same -qtype=swap_same_pair\n./gen -n 1000 -q 5000 -type=increasing -qtype=swap_adjacent\n./gen -n 30000 -q 10000 -type=random -qtype=random\n./gen -n 30000 -q 10000 -type=max -qtype=swap_same_pair\n./gen -n 30000 -q 10000 -type=min -qtype=swap_sequences\n./gen -n 30000 -q 10000 -type=increasing -qtype=random\n./gen -n 30000 -q 10000 -type=decreasing -qtype=swap_adjacent\n./gen -n 30000 -q 10000 -type=same -qtype=one_swap\n./gen -n 29999 -q 9999 -type=random -qtype=random\n./gen -n 10000 -q 10000 -type=random -qtype=swap_adjacent\n./gen -n 5000 -q 10000 -type=random -qtype=swap_sequences\n./gen -n 30000 -q 10000 -type=max -maxw=1000000 -maxh=1000000 -qtype=random\n./gen -n 30000 -q 10000 -type=min -maxw=1 -maxh=1 -qtype=random\n./gen -n 30000 -q 10000 -type=increasing -maxw=1000000 -maxh=1000000 -qtype=swap_adjacent\n./gen -n 30000 -q 10000 -type=decreasing -maxw=1000000 -maxh=1000000 -qtype=swap_adjacent\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:09.893704",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "573/E",
      "title": "E. Bear and Bowling",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 105).The second line contains n space-separated integers a1, a2, ..., an (|ai| ≤ 107) - scores for Limak's rolls.",
      "output_spec": "OutputPrint the maximum possible total score after choosing rolls to cancel.",
      "sample_tests": "ExamplesInputCopy5-2 -8 0 5 -3OutputCopy13InputCopy6-10 20 -30 40 -50 60OutputCopy400",
      "description": "E. Bear and Bowling\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 105).The second line contains n space-separated integers a1, a2, ..., an (|ai| ≤ 107) - scores for Limak's rolls.\n\nOutputPrint the maximum possible total score after choosing rolls to cancel.\n\nInputCopy5-2 -8 0 5 -3OutputCopy13InputCopy6-10 20 -30 40 -50 60OutputCopy400\n\nInputCopy5-2 -8 0 5 -3\n\nOutputCopy13\n\nInputCopy6-10 20 -30 40 -50 60\n\nOutputCopy400\n\nNoteIn first sample Limak should cancel rolls with scores  - 8 and  - 3. Then he is left with three rolls with scores  - 2, 0, 5. Total score is 1·( - 2) + 2·0 + 3·5 = 13.In second sample Limak should cancel roll with score  - 50. Total score is 1·( - 10) + 2·20 + 3·( - 30) + 4·40 + 5·60 = 400.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -10000000, 10000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -10000000, 10000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -10000000, 10000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_positive\") {\n        // All positive numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e7);\n    } else if (type == \"all_negative\") {\n        // All negative numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = -rnd.next(1, (int)1e7);\n    } else if (type == \"all_zero\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"alternating\") {\n        // Alternating positive and negative numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0 ? 1 : -1) * rnd.next(1, (int)1e7);\n    } else if (type == \"mixed\") {\n        // Mixed positive and negative numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1e7, 1e7);\n    } else if (type == \"max_positive\") {\n        // Maximize total score by not canceling any rolls\n        for(int i = 0; i < n; ++i)\n            a[i] = (int)1e7;\n    } else if (type == \"max_negative\") {\n        // Maximizing total score by canceling all rolls\n        for(int i = 0; i < n; ++i)\n            a[i] = -(int)1e7;\n    } else if (type == \"prefix_negatives\") {\n        // First k elements are negative, rest are positive\n        int k = opt<int>(\"k\", n/2); // Default to n/2\n        for(int i = 0; i < n; ++i) {\n            if (i < k)\n                a[i] = -rnd.next(1, (int)1e7); // Negative\n            else\n                a[i] = rnd.next(1, (int)1e7); // Positive\n        }\n    } else if (type == \"suffix_negatives\") {\n        // Last k elements are negative, rest are positive\n        int k = opt<int>(\"k\", n/2); // Default to n/2\n        for(int i = 0; i < n; ++i) {\n            if (i < n - k)\n                a[i] = rnd.next(1, (int)1e7); // Positive\n            else\n                a[i] = -rnd.next(1, (int)1e7); // Negative\n        }\n    } else if (type == \"single_large_positive\") {\n        // One large positive number, rest are negative small numbers\n        int pos_index = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i) {\n            if (i == pos_index)\n                a[i] = (int)1e7; // Large positive\n            else\n                a[i] = -rnd.next(1, 100); // Small negative\n        }\n    } else if (type == \"small_numbers\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10, 10);\n    } else if (type == \"many_zeroes\") {\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 99) < 50)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(-1e7, 1e7);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1e7, 1e7);\n    } else {\n        // Default case (same as random)\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1e7, 1e7);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the scores\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_positive\") {\n        // All positive numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e7);\n    } else if (type == \"all_negative\") {\n        // All negative numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = -rnd.next(1, (int)1e7);\n    } else if (type == \"all_zero\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"alternating\") {\n        // Alternating positive and negative numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0 ? 1 : -1) * rnd.next(1, (int)1e7);\n    } else if (type == \"mixed\") {\n        // Mixed positive and negative numbers\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1e7, 1e7);\n    } else if (type == \"max_positive\") {\n        // Maximize total score by not canceling any rolls\n        for(int i = 0; i < n; ++i)\n            a[i] = (int)1e7;\n    } else if (type == \"max_negative\") {\n        // Maximizing total score by canceling all rolls\n        for(int i = 0; i < n; ++i)\n            a[i] = -(int)1e7;\n    } else if (type == \"prefix_negatives\") {\n        // First k elements are negative, rest are positive\n        int k = opt<int>(\"k\", n/2); // Default to n/2\n        for(int i = 0; i < n; ++i) {\n            if (i < k)\n                a[i] = -rnd.next(1, (int)1e7); // Negative\n            else\n                a[i] = rnd.next(1, (int)1e7); // Positive\n        }\n    } else if (type == \"suffix_negatives\") {\n        // Last k elements are negative, rest are positive\n        int k = opt<int>(\"k\", n/2); // Default to n/2\n        for(int i = 0; i < n; ++i) {\n            if (i < n - k)\n                a[i] = rnd.next(1, (int)1e7); // Positive\n            else\n                a[i] = -rnd.next(1, (int)1e7); // Negative\n        }\n    } else if (type == \"single_large_positive\") {\n        // One large positive number, rest are negative small numbers\n        int pos_index = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i) {\n            if (i == pos_index)\n                a[i] = (int)1e7; // Large positive\n            else\n                a[i] = -rnd.next(1, 100); // Small negative\n        }\n    } else if (type == \"small_numbers\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10, 10);\n    } else if (type == \"many_zeroes\") {\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 99) < 50)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(-1e7, 1e7);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1e7, 1e7);\n    } else {\n        // Default case (same as random)\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1e7, 1e7);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the scores\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_positive\n./gen -n 1 -type all_negative\n./gen -n 1 -type all_zero\n./gen -n 1 -type random\n\n./gen -n 10 -type all_positive\n./gen -n 10 -type all_negative\n./gen -n 10 -type all_zero\n./gen -n 10 -type random\n./gen -n 10 -type alternating\n./gen -n 10 -type mixed\n./gen -n 10 -type small_numbers\n\n./gen -n 100 -type random\n./gen -n 100 -type prefix_negatives -k 50\n./gen -n 100 -type suffix_negatives -k 50\n./gen -n 100 -type single_large_positive\n./gen -n 100 -type many_zeroes\n\n./gen -n 1000 -type random\n./gen -n 1000 -type max_positive\n./gen -n 1000 -type max_negative\n./gen -n 1000 -type mixed\n\n./gen -n 10000 -type random\n./gen -n 10000 -type alternating\n./gen -n 10000 -type small_numbers\n./gen -n 10000 -type many_zeroes\n\n./gen -n 100000 -type random\n./gen -n 100000 -type max_positive\n./gen -n 100000 -type max_negative\n./gen -n 100000 -type prefix_negatives -k 50000\n./gen -n 100000 -type suffix_negatives -k 50000\n./gen -n 100000 -type single_large_positive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:12.174144",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "574/A",
      "title": "A. Bear and Elections",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (2 ≤ n ≤ 100) - number of candidates.The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1000) - number of votes for each candidate. Limak is candidate number 1.Note that after bribing number of votes for some candidate might be zero or might be greater than 1000.",
      "output_spec": "OutputPrint the minimum number of citizens Limak must bribe to have strictly more votes than any other candidate.",
      "sample_tests": "ExamplesInputCopy55 1 11 2 8OutputCopy4InputCopy41 8 8 8OutputCopy6InputCopy27 6OutputCopy0",
      "description": "A. Bear and Elections\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (2 ≤ n ≤ 100) - number of candidates.The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1000) - number of votes for each candidate. Limak is candidate number 1.Note that after bribing number of votes for some candidate might be zero or might be greater than 1000.\n\nOutputPrint the minimum number of citizens Limak must bribe to have strictly more votes than any other candidate.\n\nInputCopy55 1 11 2 8OutputCopy4InputCopy41 8 8 8OutputCopy6InputCopy27 6OutputCopy0\n\nInputCopy55 1 11 2 8\n\nOutputCopy4\n\nInputCopy41 8 8 8\n\nOutputCopy6\n\nInputCopy27 6\n\nOutputCopy0\n\nNoteIn the first sample Limak has 5 votes. One of the ways to achieve victory is to bribe 4 citizens who want to vote for the third candidate. Then numbers of votes would be 9, 1, 7, 2, 8 (Limak would have 9 votes). Alternatively, Limak could steal only 3 votes from the third candidate and 1 vote from the second candidate to get situation 9, 0, 8, 2, 8.In the second sample Limak will steal 2 votes from each candidate. Situation will be 7, 6, 6, 6.In the third sample Limak is a winner without bribing any citizen.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        /* Generate random votes for all candidates */\n        vector<int> a(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_already_winner\") {\n        /* Limak already has strictly more votes than any other candidate */\n        vector<int> a(n);\n        int max_other = 0;\n        for(int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            max_other = max(max_other, a[i]);\n        }\n        a[0] = max_other + 1;\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_needs_bribe\") {\n        /* Limak is behind and needs to bribe */\n        vector<int> a(n);\n        a[0] = rnd.next(1, 1000);\n        int max_other = a[0] + rnd.next(1, 10); // Ensure others have more votes\n        for(int i = 1; i < n; ++i) {\n            a[i] = max_other;\n        }\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_tied\") {\n        /* Limak is tied with other candidates */\n        vector<int> a(n);\n        a[0] = rnd.next(1, 1000);\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[0];\n        }\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_far_behind\") {\n        /* Limak is far behind and needs to bribe many voters */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = 1000;\n        }\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"min_votes\") {\n        /* All candidates have minimum votes */\n        vector<int> a(n, 1);\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"max_votes\") {\n        /* All candidates have maximum votes */\n        vector<int> a(n, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_second\") {\n        /* Limak is second highest, minimal bribes needed */\n        vector<int> a(n);\n        int limak_votes = rnd.next(1, 999);\n        a[0] = limak_votes;\n        int max_votes = limak_votes + 1;\n        a[1] = max_votes;\n        for(int i = 2; i < n; ++i) {\n            a[i] = rnd.next(1, limak_votes);\n        }\n        shuffle(a.begin() + 1, a.end());\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"one_opponent\") {\n        /* Only one opponent */\n        n = 2;\n        vector<int> a(n);\n        a[0] = rnd.next(1, 1000);\n        a[1] = rnd.next(1, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        printf(\"%d %d\\n\", a[0], a[1]);\n    } else if (type == \"all_same_votes\") {\n        /* All candidates have the same votes */\n        int votes = rnd.next(1, 1000);\n        vector<int> a(n, votes);\n        /* output */\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else {\n        /* Default random */\n        vector<int> a(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        /* Generate random votes for all candidates */\n        vector<int> a(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_already_winner\") {\n        /* Limak already has strictly more votes than any other candidate */\n        vector<int> a(n);\n        int max_other = 0;\n        for(int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            max_other = max(max_other, a[i]);\n        }\n        a[0] = max_other + 1;\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_needs_bribe\") {\n        /* Limak is behind and needs to bribe */\n        vector<int> a(n);\n        a[0] = rnd.next(1, 1000);\n        int max_other = a[0] + rnd.next(1, 10); // Ensure others have more votes\n        for(int i = 1; i < n; ++i) {\n            a[i] = max_other;\n        }\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_tied\") {\n        /* Limak is tied with other candidates */\n        vector<int> a(n);\n        a[0] = rnd.next(1, 1000);\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[0];\n        }\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_far_behind\") {\n        /* Limak is far behind and needs to bribe many voters */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = 1000;\n        }\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"min_votes\") {\n        /* All candidates have minimum votes */\n        vector<int> a(n, 1);\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"max_votes\") {\n        /* All candidates have maximum votes */\n        vector<int> a(n, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"limak_second\") {\n        /* Limak is second highest, minimal bribes needed */\n        vector<int> a(n);\n        int limak_votes = rnd.next(1, 999);\n        a[0] = limak_votes;\n        int max_votes = limak_votes + 1;\n        a[1] = max_votes;\n        for(int i = 2; i < n; ++i) {\n            a[i] = rnd.next(1, limak_votes);\n        }\n        shuffle(a.begin() + 1, a.end());\n        /* output */\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else if (type == \"one_opponent\") {\n        /* Only one opponent */\n        n = 2;\n        vector<int> a(n);\n        a[0] = rnd.next(1, 1000);\n        a[1] = rnd.next(1, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        printf(\"%d %d\\n\", a[0], a[1]);\n    } else if (type == \"all_same_votes\") {\n        /* All candidates have the same votes */\n        int votes = rnd.next(1, 1000);\n        vector<int> a(n, votes);\n        /* output */\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    } else {\n        /* Default random */\n        vector<int> a(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n        /* output */\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i)\n            printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type limak_already_winner\n./gen -n 2 -type limak_needs_bribe\n./gen -n 2 -type limak_tied\n./gen -n 2 -type random\n./gen -n 3 -type limak_already_winner\n./gen -n 3 -type limak_needs_bribe\n./gen -n 3 -type limak_tied\n./gen -n 10 -type limak_far_behind\n./gen -n 10 -type all_same_votes\n./gen -n 10 -type limak_second\n./gen -n 50 -type random\n./gen -n 99 -type random\n./gen -n 100 -type random\n./gen -n 100 -type limak_already_winner\n./gen -n 100 -type limak_needs_bribe\n./gen -n 100 -type min_votes\n./gen -n 100 -type max_votes\n./gen -n 100 -type all_same_votes\n./gen -n 100 -type limak_tied\n./gen -n 100 -type limak_far_behind\n./gen -n 100 -type limak_second\n./gen -n 2 -type max_votes\n./gen -n 2 -type min_votes\n./gen -n 2 -type one_opponent\n./gen -n 100 -type one_opponent\n./gen -n 50 -type limak_tied\n./gen -n 75 -type limak_needs_bribe\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:14.273419",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "574/B",
      "title": "B. Bear and Three Musketeers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers, n and m (3 ≤ n ≤ 4000, 0 ≤ m ≤ 4000) — respectively number of warriors and number of pairs of warriors knowing each other.i-th of the following m lines contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Warriors ai and bi know each other. Each pair of warriors will be listed at most once.",
      "output_spec": "OutputIf Richelimakieu can choose three musketeers, print the minimum possible sum of their recognitions. Otherwise, print \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy5 61 21 32 32 43 44 5OutputCopy2InputCopy7 42 13 65 11 7OutputCopy-1",
      "description": "B. Bear and Three Musketeers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers, n and m (3 ≤ n ≤ 4000, 0 ≤ m ≤ 4000) — respectively number of warriors and number of pairs of warriors knowing each other.i-th of the following m lines contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Warriors ai and bi know each other. Each pair of warriors will be listed at most once.\n\nOutputIf Richelimakieu can choose three musketeers, print the minimum possible sum of their recognitions. Otherwise, print \"-1\" (without the quotes).\n\nInputCopy5 61 21 32 32 43 44 5OutputCopy2InputCopy7 42 13 65 11 7OutputCopy-1\n\nInputCopy5 61 21 32 32 43 44 5\n\nOutputCopy2\n\nInputCopy7 42 13 65 11 7\n\nOutputCopy-1\n\nNoteIn the first sample Richelimakieu should choose a triple 1, 2, 3. The first musketeer doesn't know anyone except other two musketeers so his recognition is 0. The second musketeer has recognition 1 because he knows warrior number 4. The third musketeer also has recognition 1 because he knows warrior 4. Sum of recognitions is 0 + 1 + 1 = 2.The other possible triple is 2, 3, 4 but it has greater sum of recognitions, equal to 1 + 1 + 1 = 3.In the second sample there is no triple of warriors knowing each other.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4000, \"m\");\n    inf.readEoln();\n    \n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"ai (%d) should not be equal to bi (%d) on line %d\", a, b, i+2);\n        pair<int,int> edge = make_pair(min(a,b), max(a,b));\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d on line %d\", a, b, i+2);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4000, \"m\");\n    inf.readEoln();\n    \n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"ai (%d) should not be equal to bi (%d) on line %d\", a, b, i+2);\n        pair<int,int> edge = make_pair(min(a,b), max(a,b));\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d on line %d\", a, b, i+2);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 4000, \"m\");\n    inf.readEoln();\n    \n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"ai (%d) should not be equal to bi (%d) on line %d\", a, b, i+2);\n        pair<int,int> edge = make_pair(min(a,b), max(a,b));\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d on line %d\", a, b, i+2);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // If m is not specified, default to -1 (compute it later)\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    // Maximum possible number of edges without exceeding constraints\n    int maxEdges = n * (n - 1) / 2;\n    maxEdges = min(maxEdges, 4000); // m ≤ 4000\n    if(m == -1) m = maxEdges;\n\n    m = min(m, maxEdges);\n\n    // Set to store edges and avoid duplicates\n    set<pair<int,int>> edges;\n\n    if(type == \"triangle\") {\n        if(n < 3) {\n            printf(\"3 3\\n1 2\\n2 3\\n3 1\\n\");\n            return 0;\n        }\n        // Create a triangle among three nodes\n        int u = 1, v = 2, w = 3;\n        edges.insert({min(u,v),max(u,v)});\n        edges.insert({min(u,w),max(u,w)});\n        edges.insert({min(v,w),max(v,w)});\n\n        // Generate the rest of the edges randomly\n        int remainingEdges = m - 3;\n        while(remainingEdges > 0) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if(a == b) continue;\n            pair<int,int> edge = {min(a,b), max(a,b)};\n            if(edges.count(edge)) continue;\n            edges.insert(edge);\n            remainingEdges--;\n        }\n    } else if(type == \"no_triangle\") {\n        // Generate a bipartite graph\n        vector<int> A, B;\n        for(int i = 1; i <= n; i++) {\n            if(i % 2 == 0) A.push_back(i);\n            else B.push_back(i);\n        }\n        int totalPossibleEdges = A.size() * B.size();\n        totalPossibleEdges = min(totalPossibleEdges, 4000);\n        m = min(m, totalPossibleEdges);\n\n        // Create edges between nodes in A and nodes in B\n        vector<pair<int,int>> possibleEdges;\n        for(int a : A) {\n            for(int b : B) {\n                possibleEdges.push_back({min(a,b), max(a,b)});\n            }\n        }\n        shuffle(possibleEdges.begin(), possibleEdges.end());\n        for(int i = 0; i < m; i++) {\n            edges.insert(possibleEdges[i]);\n        }\n    } else if(type == \"clique\") {\n        m = min(m, maxEdges);\n        // Generate all possible edges for a clique\n        for(int u = 1; u <= n; u++) {\n            for(int v = u+1; v <= n; v++) {\n                edges.insert({u, v});\n                if(edges.size() >= m) break;\n            }\n            if(edges.size() >= m) break;\n        }\n    } else if(type == \"sparse\") {\n        // Generate a tree\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.insert({min(u,v), max(u,v)});\n        }\n        // Additional edges are not added to keep the graph sparse\n    } else if(type == \"dense\") {\n        // Generate as many edges as possible\n        for(int u = 1; u <= n; u++) {\n            for(int v = u+1; v <= n; v++) {\n                edges.insert({u, v});\n                if(edges.size() >= m) break;\n            }\n            if(edges.size() >= m) break;\n        }\n    } else if(type == \"recognitions_min\") {\n        if(n < 3) {\n            printf(\"3 3\\n1 2\\n2 3\\n3 1\\n\");\n            return 0;\n        }\n        // Create a triangle with minimal recognition\n        int u = 1, v = 2, w = 3;\n        edges.insert({min(u,v),max(u,v)});\n        edges.insert({min(u,w),max(u,w)});\n        edges.insert({min(v,w),max(v,w)});\n        int remainingEdges = m - 3;\n        // Add edges between other nodes\n        while(remainingEdges > 0) {\n            int a = rnd.next(4, n);\n            int b = rnd.next(4, n);\n            if(a == b) continue;\n            pair<int,int> edge = {min(a,b), max(a,b)};\n            if(edges.count(edge)) continue;\n            edges.insert(edge);\n            remainingEdges--;\n        }\n    } else if(type == \"recognitions_max\") {\n        if(n < 3) {\n            printf(\"3 3\\n1 2\\n2 3\\n3 1\\n\");\n            return 0;\n        }\n        // Create a triangle with maximal recognition\n        int u = 1, v = 2, w = 3;\n        edges.insert({min(u,v),max(u,v)});\n        edges.insert({min(u,w),max(u,w)});\n        edges.insert({min(v,w),max(v,w)});\n        for(int i = 4; i <= n; i++) {\n            edges.insert({min(u,i),max(u,i)});\n            edges.insert({min(v,i),max(v,i)});\n            edges.insert({min(w,i),max(w,i)});\n        }\n        int totalEdgesNeeded = edges.size();\n        if(totalEdgesNeeded > m) {\n            // Remove excess edges\n            vector<pair<int,int>> extraEdges;\n            for(auto e : edges) {\n                if(e.first >= 4 || e.second >= 4) {\n                    extraEdges.push_back(e);\n                }\n            }\n            int edgesToRemove = totalEdgesNeeded - m;\n            for(int i = 0; i < edgesToRemove; i++) {\n                edges.erase(extraEdges[i]);\n            }\n        } else {\n            // Add more edges between other nodes if needed\n            int remainingEdges = m - totalEdgesNeeded;\n            vector<int> restNodes;\n            for(int i = 4; i <= n; i++) {\n                restNodes.push_back(i);\n            }\n            int sz = restNodes.size();\n            for(int i = 0; i < sz && remainingEdges > 0; i++) {\n                for(int j = i+1; j < sz && remainingEdges > 0; j++) {\n                    pair<int,int> edge = {restNodes[i], restNodes[j]};\n                    if(edges.count(edge)) continue;\n                    edges.insert(edge);\n                    remainingEdges--;\n                }\n            }\n        }\n    } else {\n        // Default: generate a random graph\n        m = min(m, maxEdges);\n        vector<pair<int,int>> possibleEdges;\n        for(int u = 1; u <= n; u++) {\n            for(int v = u+1; v <= n; v++) {\n                possibleEdges.push_back({u,v});\n            }\n        }\n        shuffle(possibleEdges.begin(), possibleEdges.end());\n        for(int i = 0; i < m && i < possibleEdges.size(); i++) {\n            edges.insert(possibleEdges[i]);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // If m is not specified, default to -1 (compute it later)\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    // Maximum possible number of edges without exceeding constraints\n    int maxEdges = n * (n - 1) / 2;\n    maxEdges = min(maxEdges, 4000); // m ≤ 4000\n    if(m == -1) m = maxEdges;\n\n    m = min(m, maxEdges);\n\n    // Set to store edges and avoid duplicates\n    set<pair<int,int>> edges;\n\n    if(type == \"triangle\") {\n        if(n < 3) {\n            printf(\"3 3\\n1 2\\n2 3\\n3 1\\n\");\n            return 0;\n        }\n        // Create a triangle among three nodes\n        int u = 1, v = 2, w = 3;\n        edges.insert({min(u,v),max(u,v)});\n        edges.insert({min(u,w),max(u,w)});\n        edges.insert({min(v,w),max(v,w)});\n\n        // Generate the rest of the edges randomly\n        int remainingEdges = m - 3;\n        while(remainingEdges > 0) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if(a == b) continue;\n            pair<int,int> edge = {min(a,b), max(a,b)};\n            if(edges.count(edge)) continue;\n            edges.insert(edge);\n            remainingEdges--;\n        }\n    } else if(type == \"no_triangle\") {\n        // Generate a bipartite graph\n        vector<int> A, B;\n        for(int i = 1; i <= n; i++) {\n            if(i % 2 == 0) A.push_back(i);\n            else B.push_back(i);\n        }\n        int totalPossibleEdges = A.size() * B.size();\n        totalPossibleEdges = min(totalPossibleEdges, 4000);\n        m = min(m, totalPossibleEdges);\n\n        // Create edges between nodes in A and nodes in B\n        vector<pair<int,int>> possibleEdges;\n        for(int a : A) {\n            for(int b : B) {\n                possibleEdges.push_back({min(a,b), max(a,b)});\n            }\n        }\n        shuffle(possibleEdges.begin(), possibleEdges.end());\n        for(int i = 0; i < m; i++) {\n            edges.insert(possibleEdges[i]);\n        }\n    } else if(type == \"clique\") {\n        m = min(m, maxEdges);\n        // Generate all possible edges for a clique\n        for(int u = 1; u <= n; u++) {\n            for(int v = u+1; v <= n; v++) {\n                edges.insert({u, v});\n                if(edges.size() >= m) break;\n            }\n            if(edges.size() >= m) break;\n        }\n    } else if(type == \"sparse\") {\n        // Generate a tree\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.insert({min(u,v), max(u,v)});\n        }\n        // Additional edges are not added to keep the graph sparse\n    } else if(type == \"dense\") {\n        // Generate as many edges as possible\n        for(int u = 1; u <= n; u++) {\n            for(int v = u+1; v <= n; v++) {\n                edges.insert({u, v});\n                if(edges.size() >= m) break;\n            }\n            if(edges.size() >= m) break;\n        }\n    } else if(type == \"recognitions_min\") {\n        if(n < 3) {\n            printf(\"3 3\\n1 2\\n2 3\\n3 1\\n\");\n            return 0;\n        }\n        // Create a triangle with minimal recognition\n        int u = 1, v = 2, w = 3;\n        edges.insert({min(u,v),max(u,v)});\n        edges.insert({min(u,w),max(u,w)});\n        edges.insert({min(v,w),max(v,w)});\n        int remainingEdges = m - 3;\n        // Add edges between other nodes\n        while(remainingEdges > 0) {\n            int a = rnd.next(4, n);\n            int b = rnd.next(4, n);\n            if(a == b) continue;\n            pair<int,int> edge = {min(a,b), max(a,b)};\n            if(edges.count(edge)) continue;\n            edges.insert(edge);\n            remainingEdges--;\n        }\n    } else if(type == \"recognitions_max\") {\n        if(n < 3) {\n            printf(\"3 3\\n1 2\\n2 3\\n3 1\\n\");\n            return 0;\n        }\n        // Create a triangle with maximal recognition\n        int u = 1, v = 2, w = 3;\n        edges.insert({min(u,v),max(u,v)});\n        edges.insert({min(u,w),max(u,w)});\n        edges.insert({min(v,w),max(v,w)});\n        for(int i = 4; i <= n; i++) {\n            edges.insert({min(u,i),max(u,i)});\n            edges.insert({min(v,i),max(v,i)});\n            edges.insert({min(w,i),max(w,i)});\n        }\n        int totalEdgesNeeded = edges.size();\n        if(totalEdgesNeeded > m) {\n            // Remove excess edges\n            vector<pair<int,int>> extraEdges;\n            for(auto e : edges) {\n                if(e.first >= 4 || e.second >= 4) {\n                    extraEdges.push_back(e);\n                }\n            }\n            int edgesToRemove = totalEdgesNeeded - m;\n            for(int i = 0; i < edgesToRemove; i++) {\n                edges.erase(extraEdges[i]);\n            }\n        } else {\n            // Add more edges between other nodes if needed\n            int remainingEdges = m - totalEdgesNeeded;\n            vector<int> restNodes;\n            for(int i = 4; i <= n; i++) {\n                restNodes.push_back(i);\n            }\n            int sz = restNodes.size();\n            for(int i = 0; i < sz && remainingEdges > 0; i++) {\n                for(int j = i+1; j < sz && remainingEdges > 0; j++) {\n                    pair<int,int> edge = {restNodes[i], restNodes[j]};\n                    if(edges.count(edge)) continue;\n                    edges.insert(edge);\n                    remainingEdges--;\n                }\n            }\n        }\n    } else {\n        // Default: generate a random graph\n        m = min(m, maxEdges);\n        vector<pair<int,int>> possibleEdges;\n        for(int u = 1; u <= n; u++) {\n            for(int v = u+1; v <= n; v++) {\n                possibleEdges.push_back({u,v});\n            }\n        }\n        shuffle(possibleEdges.begin(), possibleEdges.end());\n        for(int i = 0; i < m && i < possibleEdges.size(); i++) {\n            edges.insert(possibleEdges[i]);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 0 -type no_triangle\n./gen -n 3 -type triangle\n./gen -n 3 -type recognitions_min\n./gen -n 3 -type recognitions_max\n\n./gen -n 4 -type no_triangle\n./gen -n 4 -type triangle\n\n./gen -n 5 -m 4 -type triangle\n\n./gen -n 10 -m 15 -type triangle\n./gen -n 10 -m 15 -type recognitions_min\n./gen -n 10 -m 15 -type recognitions_max\n./gen -n 10 -m 45 -type clique\n\n./gen -n 100 -m 100 -type no_triangle\n./gen -n 100 -m 990 -type triangle\n./gen -n 100 -m 990 -type dense\n\n./gen -n 500 -m 500 -type sparse\n./gen -n 500 -m 2000 -type triangle\n./gen -n 500 -m 2000 -type random\n./gen -n 500 -m 2000 -type no_triangle\n\n./gen -n 1000 -m 4000 -type random\n./gen -n 2000 -m 4000 -type triangle\n./gen -n 2000 -m 4000 -type no_triangle\n\n./gen -n 4000 -m 4000 -type triangle\n./gen -n 4000 -m 4000 -type no_triangle\n./gen -n 4000 -m 4000 -type dense\n./gen -n 4000 -m 4000 -type sparse\n\n./gen -n 4000 -m 4000 -type recognitions_min\n./gen -n 4000 -m 4000 -type recognitions_max\n\n./gen -n 3 -m 0 -type no_triangle\n./gen -n 4000 -m 4000 -type recognitions_min\n./gen -n 4000 -m 4000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:16.569578",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "574/C",
      "title": "C. Мишка и покер",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входного файла записано целое число n (2 ≤ n ≤ 105), количество игроков.Во второй строке записано n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 109) — ставки игроков.",
      "output_spec": "Выходные данныеВыведите \"Yes\" (без кавычек), если игроки смогут сделать все ставки равными, или \"No\" в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать475 150 75 50Выходные данныеСкопироватьYesВходные данныеСкопировать3100 150 250Выходные данныеСкопироватьNo",
      "description": "C. Мишка и покер\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входного файла записано целое число n (2 ≤ n ≤ 105), количество игроков.Во второй строке записано n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 109) — ставки игроков.\n\nВходные данные\n\nВыходные данныеВыведите \"Yes\" (без кавычек), если игроки смогут сделать все ставки равными, или \"No\" в противном случае.\n\nВыходные данные\n\nВходные данныеСкопировать475 150 75 50Выходные данныеСкопироватьYesВходные данныеСкопировать3100 150 250Выходные данныеСкопироватьNo\n\nВходные данныеСкопировать475 150 75 50\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYes\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3100 150 250\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте первый и третий игроки должны дважды удвоить свои ставки, второй игрок должен удвоить свою ставку один раз, а четвертый игрок должен удвоить и утроить свою ставку.Можно показать, что во втором тесте невозможно сделать все ставки равными.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"same\");\n    vector<int> a(n);\n    if (type == \"same\") {\n        // All ai are equal\n        int value = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"powers_2_and_3\") {\n        // All ai are products of 2s and 3s\n        for (int i = 0; i < n; ++i) {\n            int exp2 = rnd.next(0, 30);\n            int exp3 = rnd.next(0, 19);\n            long long value = 1;\n            for (int j = 0; j < exp2; ++j) {\n                value *= 2;\n                if (value > 1e9) break;\n            }\n            for (int j = 0; j < exp3; ++j) {\n                value *= 3;\n                if (value > 1e9) break;\n            }\n            value = min(value, (long long)1e9);\n            a[i] = (int)value;\n        }\n    } else if (type == \"random_big\") {\n        // Random big integers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    } else if (type == \"reduce_to_same\") {\n        // All ai after removing factors of 2 and 3 reduce to same number\n        int base = rnd.next(2, (int)1e9);\n        // Remove factors of 2 and 3\n        int reduced_base = base;\n        while (reduced_base % 2 == 0) reduced_base /= 2;\n        while (reduced_base % 3 == 0) reduced_base /= 3;\n        if (reduced_base == 1) reduced_base = 7; // Ensure reduced base is not 1\n        for (int i = 0; i < n; ++i) {\n            long long val = reduced_base;\n            int exp2 = rnd.next(0, 30);\n            int exp3 = rnd.next(0, 19);\n            for (int j = 0; j < exp2; ++j) {\n                val *= 2;\n                if (val > 1e9) break;\n            }\n            for (int j = 0; j < exp3; ++j) {\n                val *= 3;\n                if (val > 1e9) break;\n            }\n            val = min(val, (long long)1e9);\n            a[i] = (int)val;\n        }\n    } else if (type == \"reduce_to_different\") {\n        // All ai after removing factors of 2 and 3 reduce to different numbers\n        set<int> used_values;\n        for (int i = 0; i < n; ++i) {\n            int base = rnd.next(2, (int)1e9);\n            // Remove factors of 2 and 3\n            int reduced_base = base;\n            while (reduced_base % 2 == 0) reduced_base /= 2;\n            while (reduced_base % 3 == 0) reduced_base /= 3;\n            while (used_values.count(reduced_base) > 0 || reduced_base == 1) {\n                base = rnd.next(2, (int)1e9);\n                reduced_base = base;\n                while (reduced_base % 2 == 0) reduced_base /= 2;\n                while (reduced_base % 3 == 0) reduced_base /= 3;\n            }\n            used_values.insert(reduced_base);\n            long long val = reduced_base;\n            int exp2 = rnd.next(0, 30);\n            int exp3 = rnd.next(0, 19);\n            for (int j = 0; j < exp2; ++j) {\n                val *= 2;\n                if (val > 1e9) break;\n            }\n            for (int j = 0; j < exp3; ++j) {\n                val *= 3;\n                if (val > 1e9) break;\n            }\n            val = min(val, (long long)1e9);\n            a[i] = (int)val;\n        }\n    } else if (type == \"max_case\") {\n        // Maximum n and maximum ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)1e9;\n        }\n    } else if (type == \"all_ones\") {\n        // All ai are 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        // Random case\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"same\");\n    vector<int> a(n);\n    if (type == \"same\") {\n        // All ai are equal\n        int value = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"powers_2_and_3\") {\n        // All ai are products of 2s and 3s\n        for (int i = 0; i < n; ++i) {\n            int exp2 = rnd.next(0, 30);\n            int exp3 = rnd.next(0, 19);\n            long long value = 1;\n            for (int j = 0; j < exp2; ++j) {\n                value *= 2;\n                if (value > 1e9) break;\n            }\n            for (int j = 0; j < exp3; ++j) {\n                value *= 3;\n                if (value > 1e9) break;\n            }\n            value = min(value, (long long)1e9);\n            a[i] = (int)value;\n        }\n    } else if (type == \"random_big\") {\n        // Random big integers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    } else if (type == \"reduce_to_same\") {\n        // All ai after removing factors of 2 and 3 reduce to same number\n        int base = rnd.next(2, (int)1e9);\n        // Remove factors of 2 and 3\n        int reduced_base = base;\n        while (reduced_base % 2 == 0) reduced_base /= 2;\n        while (reduced_base % 3 == 0) reduced_base /= 3;\n        if (reduced_base == 1) reduced_base = 7; // Ensure reduced base is not 1\n        for (int i = 0; i < n; ++i) {\n            long long val = reduced_base;\n            int exp2 = rnd.next(0, 30);\n            int exp3 = rnd.next(0, 19);\n            for (int j = 0; j < exp2; ++j) {\n                val *= 2;\n                if (val > 1e9) break;\n            }\n            for (int j = 0; j < exp3; ++j) {\n                val *= 3;\n                if (val > 1e9) break;\n            }\n            val = min(val, (long long)1e9);\n            a[i] = (int)val;\n        }\n    } else if (type == \"reduce_to_different\") {\n        // All ai after removing factors of 2 and 3 reduce to different numbers\n        set<int> used_values;\n        for (int i = 0; i < n; ++i) {\n            int base = rnd.next(2, (int)1e9);\n            // Remove factors of 2 and 3\n            int reduced_base = base;\n            while (reduced_base % 2 == 0) reduced_base /= 2;\n            while (reduced_base % 3 == 0) reduced_base /= 3;\n            while (used_values.count(reduced_base) > 0 || reduced_base == 1) {\n                base = rnd.next(2, (int)1e9);\n                reduced_base = base;\n                while (reduced_base % 2 == 0) reduced_base /= 2;\n                while (reduced_base % 3 == 0) reduced_base /= 3;\n            }\n            used_values.insert(reduced_base);\n            long long val = reduced_base;\n            int exp2 = rnd.next(0, 30);\n            int exp3 = rnd.next(0, 19);\n            for (int j = 0; j < exp2; ++j) {\n                val *= 2;\n                if (val > 1e9) break;\n            }\n            for (int j = 0; j < exp3; ++j) {\n                val *= 3;\n                if (val > 1e9) break;\n            }\n            val = min(val, (long long)1e9);\n            a[i] = (int)val;\n        }\n    } else if (type == \"max_case\") {\n        // Maximum n and maximum ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)1e9;\n        }\n    } else if (type == \"all_ones\") {\n        // All ai are 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        // Random case\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n tests\n./gen -n 2 -type same\n./gen -n 2 -type all_ones\n./gen -n 2 -type powers_2_and_3\n./gen -n 2 -type reduce_to_same\n./gen -n 2 -type reduce_to_different\n./gen -n 2 -type random_big\n\n# Medium n tests\n./gen -n 10 -type same\n./gen -n 10 -type powers_2_and_3\n./gen -n 10 -type reduce_to_same\n./gen -n 10 -type reduce_to_different\n./gen -n 10 -type random_big\n\n# Large n tests\n./gen -n 100000 -type same\n./gen -n 100000 -type powers_2_and_3\n./gen -n 100000 -type reduce_to_same\n./gen -n 100000 -type reduce_to_different\n./gen -n 100000 -type random_big\n./gen -n 100000 -type max_case\n\n# Edge cases\n./gen -n 2 -type max_case\n./gen -n 2 -type all_ones\n./gen -n 100000 -type all_ones\n\n# Additional tests\n./gen -n 99999 -type reduce_to_same\n./gen -n 99998 -type reduce_to_different\n./gen -n 100000 -type random_big\n\n# Some specific small tests\n./gen -n 5 -type same\n./gen -n 5 -type reduce_to_same\n./gen -n 5 -type reduce_to_different\n./gen -n 5 -type random_big\n\n# Maximal ai \n./gen -n 100000 -type max_case\n\n# Minimal ai\n./gen -n 100000 -type all_ones\n\n# Mixed types\n./gen -n 100000 -type powers_2_and_3\n./gen -n 100000 -type random_big\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:18.503436",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "574/D",
      "title": "D. Bear and Blocks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 105).The second line contains n space-separated integers h1, h2, ..., hn (1 ≤ hi ≤ 109) — sizes of towers.",
      "output_spec": "OutputPrint the number of operations needed to destroy all towers.",
      "sample_tests": "ExamplesInputCopy62 1 4 6 2 2OutputCopy3InputCopy73 3 3 1 3 3 3OutputCopy2",
      "description": "D. Bear and Blocks\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 105).The second line contains n space-separated integers h1, h2, ..., hn (1 ≤ hi ≤ 109) — sizes of towers.\n\nOutputPrint the number of operations needed to destroy all towers.\n\nInputCopy62 1 4 6 2 2OutputCopy3InputCopy73 3 3 1 3 3 3OutputCopy2\n\nInputCopy62 1 4 6 2 2\n\nOutputCopy3\n\nInputCopy73 3 3 1 3 3 3\n\nOutputCopy2\n\nNoteThe picture below shows all three operations for the first sample test. Each time boundary blocks are marked with red color.    After first operation there are four blocks left and only one remains after second operation. This last block is destroyed in third operation.",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int MIN_H = 1;\n    int MAX_H = 1000000000;\n\n    vector<int> h(n);\n\n    if (type == \"max\") {\n        // All heights are MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MAX_H;\n    } else if (type == \"min\") {\n        // All heights are MIN_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MIN_H;\n    } else if (type == \"random\") {\n        // Heights are random between MIN_H and MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MIN_H, MAX_H);\n    } else if (type == \"increasing\") {\n        // Heights increase from MIN_H to MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MIN_H + (long long)(MAX_H - MIN_H) * i / (n - 1);\n    } else if (type == \"decreasing\") {\n        // Heights decrease from MAX_H to MIN_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MAX_H - (long long)(MAX_H - MIN_H) * i / (n - 1);\n    } else if (type == \"pyramid\") {\n        // Heights increase to midpoint and then decrease\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i)\n            h[i] = MIN_H + (long long)(MAX_H - MIN_H) * i / mid;\n        for (int i = mid + 1; i < n; ++i)\n            h[i] = h[n - 1 - i];\n    } else if (type == \"valley\") {\n        // Heights decrease to midpoint and then increase\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i)\n            h[i] = MAX_H - (long long)(MAX_H - MIN_H) * i / mid;\n        for (int i = mid + 1; i < n; ++i)\n            h[i] = h[n - 1 - i];\n    } else if (type == \"alternate\") {\n        // Heights alternate between MIN_H and MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? MIN_H : MAX_H;\n    } else if (type == \"zigzag\") {\n        // Heights zigzag between two random values\n        int h1 = rnd.next(MIN_H, MAX_H);\n        int h2 = rnd.next(MIN_H, MAX_H);\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? h1 : h2;\n    } else if (type == \"singlepeak\") {\n        // One tower of MAX_H, rest are MIN_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MIN_H;\n        int pos = rnd.next(0, n - 1);\n        h[pos] = MAX_H;\n    } else if (type == \"singlevalley\") {\n        // One tower of MIN_H, rest are MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MAX_H;\n        int pos = rnd.next(0, n - 1);\n        h[pos] = MIN_H;\n    } else if (type == \"randomsmall\") {\n        // Heights are random between MIN_H and 100\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MIN_H, 100);\n    } else if (type == \"randomlarge\") {\n        // Heights are random between MAX_H - 1e8 and MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MAX_H - 100000000, MAX_H);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MIN_H, MAX_H);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h_i\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", h[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int MIN_H = 1;\n    int MAX_H = 1000000000;\n\n    vector<int> h(n);\n\n    if (type == \"max\") {\n        // All heights are MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MAX_H;\n    } else if (type == \"min\") {\n        // All heights are MIN_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MIN_H;\n    } else if (type == \"random\") {\n        // Heights are random between MIN_H and MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MIN_H, MAX_H);\n    } else if (type == \"increasing\") {\n        // Heights increase from MIN_H to MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MIN_H + (long long)(MAX_H - MIN_H) * i / (n - 1);\n    } else if (type == \"decreasing\") {\n        // Heights decrease from MAX_H to MIN_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MAX_H - (long long)(MAX_H - MIN_H) * i / (n - 1);\n    } else if (type == \"pyramid\") {\n        // Heights increase to midpoint and then decrease\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i)\n            h[i] = MIN_H + (long long)(MAX_H - MIN_H) * i / mid;\n        for (int i = mid + 1; i < n; ++i)\n            h[i] = h[n - 1 - i];\n    } else if (type == \"valley\") {\n        // Heights decrease to midpoint and then increase\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i)\n            h[i] = MAX_H - (long long)(MAX_H - MIN_H) * i / mid;\n        for (int i = mid + 1; i < n; ++i)\n            h[i] = h[n - 1 - i];\n    } else if (type == \"alternate\") {\n        // Heights alternate between MIN_H and MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? MIN_H : MAX_H;\n    } else if (type == \"zigzag\") {\n        // Heights zigzag between two random values\n        int h1 = rnd.next(MIN_H, MAX_H);\n        int h2 = rnd.next(MIN_H, MAX_H);\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? h1 : h2;\n    } else if (type == \"singlepeak\") {\n        // One tower of MAX_H, rest are MIN_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MIN_H;\n        int pos = rnd.next(0, n - 1);\n        h[pos] = MAX_H;\n    } else if (type == \"singlevalley\") {\n        // One tower of MIN_H, rest are MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = MAX_H;\n        int pos = rnd.next(0, n - 1);\n        h[pos] = MIN_H;\n    } else if (type == \"randomsmall\") {\n        // Heights are random between MIN_H and 100\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MIN_H, 100);\n    } else if (type == \"randomlarge\") {\n        // Heights are random between MAX_H - 1e8 and MAX_H\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MAX_H - 100000000, MAX_H);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(MIN_H, MAX_H);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h_i\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", h[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type max\n./gen -n 10 -type min\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type pyramid\n./gen -n 10 -type valley\n./gen -n 10 -type alternate\n./gen -n 10 -type zigzag\n./gen -n 10 -type singlepeak\n./gen -n 10 -type singlevalley\n./gen -n 10 -type randomsmall\n./gen -n 10 -type randomlarge\n\n./gen -n 1000 -type max\n./gen -n 1000 -type min\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type pyramid\n./gen -n 1000 -type valley\n./gen -n 1000 -type alternate\n./gen -n 1000 -type zigzag\n./gen -n 1000 -type singlepeak\n./gen -n 1000 -type singlevalley\n./gen -n 1000 -type randomsmall\n./gen -n 1000 -type randomlarge\n\n./gen -n 100000 -type max\n./gen -n 100000 -type min\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type pyramid\n./gen -n 100000 -type valley\n./gen -n 100000 -type alternate\n./gen -n 100000 -type zigzag\n./gen -n 100000 -type singlepeak\n./gen -n 100000 -type singlevalley\n./gen -n 100000 -type randomsmall\n./gen -n 100000 -type randomlarge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:20.872052",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "574/E",
      "title": "E. Bear and Drawing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 105).Next n - 1 lines contain description of a tree. i-th of them contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) denoting an edge between vertices ai and bi. It's guaranteed that given description forms a tree.",
      "output_spec": "OutputPrint \"Yes\" (without the quotes) if Limak can draw chosen tree. Otherwise, print \"No\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy81 21 31 66 46 76 57 8OutputCopyYesInputCopy131 21 31 42 52 62 73 83 93 104 114 124 13OutputCopyNo",
      "description": "E. Bear and Drawing\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 105).Next n - 1 lines contain description of a tree. i-th of them contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) denoting an edge between vertices ai and bi. It's guaranteed that given description forms a tree.\n\nOutputPrint \"Yes\" (without the quotes) if Limak can draw chosen tree. Otherwise, print \"No\" (without the quotes).\n\nInputCopy81 21 31 66 46 76 57 8OutputCopyYesInputCopy131 21 31 42 52 62 73 83 93 104 114 124 13OutputCopyNo\n\nInputCopy81 21 31 66 46 76 57 8\n\nOutputCopyYes\n\nInputCopy131 21 31 42 52 62 73 83 93 104 114 124 13\n\nOutputCopyNo",
      "solutions": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces",
          "content": "Hello Codeforces community!Codeforces Round #318 (for both divisions) will take place on August, 29 at 19:30 MSK. It is the Thanks-Round devoted to Russian Code Cup. You will be given 5 problems and 2 hours to solve them. Scoring will be announced close to the round. I strongly recommend you to read all problems.RussianCodeCup is the largest open programming competiton for Russian-speaking participants by Mail.Ru Group. Its history started in 2011. And since the first championship RCC offers great problems and generous prizes. This year finals will be held on September, 19th. Wish good luck to all the finalists! Thank you, RussianCodeCup, for your gift on the 5th anniversary of Codeforces!I am honoured to be a problem setter for this round. I wouldn't do it alone. I want to thank Zlobober for his great help with problems preparation and MikeMirzayanov (and all people working on Codeforces and Polygon) for this awesome site. It's an amazing place to learn and compete. My big thanks to winger and AlexFetisov for their help with testing a round. And to Delinur for translating statements. As you see, not only a setter creates a round.It's my first Codeforces round but not my first problems here. You can check out A, C and D from VK Cup 2015 — Round 2. Also you might remember some of my problems in TC rounds. I'm very happy with finally preparing a full round for Codeforces and I hope you will enjoy it. I tried my best to prepare nice and diverse problemset, you will judge it. In all problems you will have to help Limak who is quite unusual bear.I wish you great fun and no frustrating bugs. Looking forward to seeing you!UPD: Scoring is 500-1000- 1750 -2000-2500 in div1 and 500-1000-1500-2000- 2750 in div2. Enjoy a round!UPD: EditorialUPD: Contest is over. The winners:Div1: Marcin_smu mnbvmar subscriber LoneFox Shef Div2: cescmentation_folch (5 problems solved!) fhxb520630 (5 problems solved!) bugCollector Sehnsucht okaduki1 And note from an author. There were some wrong solutions passing. Sorry for that. I tried my best to create strong tests but I failed a bit. Did you like this round? What do you think about problems?Thanks for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2177
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces",
          "content": "Div2B — Bear and Three MusketeersWarriors are vertices and \"knowing each other\" is an edge. We want to find connected triple of vertices with the lowest sum of degrees (and print sum - 6 because we don't want to count edges from one chosen vertex to another).Brute force is O(n3). We iterate over all triples a, b, c and consider them as musketeers. They must be connected by edges (they must know each other). If they are, then we consider sum of their degrees.We must notice that there is low limit for number of edges. So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex. It gives us O(n2 + nm) and it's intended solution. To check if third vertex is connected with other two, you should additionally store edges in 2D adjacency matrix.It's also possible to write it by adding \"if\" in right place in brute forces to get O(n2 + nm). Check it out in code.Div1A — Bear and PokerAny positive integer number can be factorized and written as 2a·3b·5c·7d·....We can multiply given numbers by 2 and 3 so we can increase a and b for them. So we can make all a and b equal by increasing them to the same big value (e.g. 100). But we can't change powers of other prime numbers so they must be equal from the beginning. We can check it by diving all numbers from input by two and by three as many times as possible. Then all of them must be equal. CodeAlternative solution is to calculate GCD of given numbers. Answer is \"YES\" iff we can get each number by multiplying GCD by 2 and 3. Otherwise, some number had different power of prime number other than 2 and 3. CodeDiv1B — Bear and BlocksIn one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi = min(hi - 1, hi - 1, hi + 1) where h0 = hn + 1 = 0. By using this formula two times we get height after two operations: hi = max(0, min(hi - 2, hi - 1 - 1, hi - 2, hi + 1 - 1, hi + 2)) and so on. From now I will omit max(0, ...) part to make it easier to read.After k operations we get hi = min(Left, Right) where Left = min(hi - j - (k - j)) = min(hi - j + j - k) for and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k = min(hi - j + j) — we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it.For each i we are looking for min(hi - j + j). We can iterate over i from left to right keeping some variable best: best = min(best, h[i]);\nbest is answer for i;\nbest++;We should to the same for Right and take min(Left, Right) for each i. Then final answer is maximum over answers for i. CodeDiv1C — Bear and DrawingLet's consider a tree already drawn on a strip of paper. Let's take first vertex on the left and last vertex on the right (in case of two vertices with the same x, we choose any of them). There is a path between them. Let's forget about vertices not on this path. A path divides a strip into 1D regions.What can be added to the main path? Only simple paths attached to it with one edge. So it can be one of the following structures — Y-letter or Line:Note that Y-letter can have long legs but its central part can have only one edge.How to check if given tree is a path + Y-letters + Lines? First, let's move from each leaf till we have vertex with degree at least 3, marking vertices as deleted. We don't mark last vertex (that with degree at least 3) as deleted but we increase his number of legs. Finally, for each not-deleted vertex we count his not-deleted neighbours for which degree - min(legs, 2) > 1 — otherwise this neighbour is start of Line or Y-letter. Each vertex on the main path can have at most two neighbours that also belong to the main path. There can be more neighbours but they must be in Lines or Y-letters — that's why we didn't count them. So answer is \"No\" iff for some vertex we counted more than two neighbours. CodeDiv1D — Bear and CavalryLet's sort warriors and horses separately (by strength). For a moment we forget about forbidden assignments. Inversion is a pair of warriors that stronger one is assigned to weaker horse. We don't like inversions because it's not worse to assign strong warriors to strong horses: A·B + a·b ≥ A·b + B·a for A ≥ a and B ≥ b. Note that repairing an inversion (by swapping assigned horses) decreases number of inversions — prove it by yourself (drawing a matching with intersections could be helpful). Without any restrictions the optimal matching is when we assign i-th warrior to i-th horse (indexed after sorting) — to get no inversions.Let's go back to version with forbidden connections. We have n disjoint pairs which we can't use. We will prove that there exists an optimal assignment where (for all i) i-th warrior is assigned to j-th horse where |i - j| ≤ 2.Let's take an optimal assignment. In case of ties we take the one with the lowest number of inversions. Let's assume that i is assigned to i + 3. There are at least 3 warriors j > i assigned to horses with indices lower than i + 3. So we have at least 3 inversions with edge from i to i + 3 (warriors on the left, horses on the right):Above, connection warrior-horse is an edge. Then inversions are intersections. Swapping horses for warriors i and j (where j belongs so some red edge) would decrease number of inversions and it wouldn't decrease a score. We took an optimal assignment so it means that it's impossible to swap horses for them. Hence, for each red edge we can't change pair (black, read) into the following blue edges:So one of these blue edges is forbidden. Three red edges generate three pairs of blue edges and in each pair at least one blue edge must be forbidden. Note that all six blue edges are different. All blue edges are incident to warrior i or to horse i + 3 but only one forbidden edge can be incident to warrior i and only one forbidden edge can be incident to horse i + 3. We have at most two forbidden edges incident to them so it can't be true that three blue edges are forbidden.By cases analysis we can prove something more — that there can be only three possible types of connecting in an optimal assignment. First type: i can be connected to i. Second: warrior i with horse i + 1 and warrior i + 1 with horse i. Third: warriors i, i + 1 and i + 2 are connected with horses i, i + 1, i + 2.It gives us O(nq) solution with calculating queries independently with dp[i] defined as \"what result can we get for assigning everything with indices lower than i?\". To calculate dp[i] we must know dp[i - 3], dp[i - 2] and dp[i - 1]. It wasn't intended solution because we can get better complexity.We can create a segment tree and for intervals we should keep info \"result we can get for this interval with 0/1/2 first and 0/1/2 last elements removed\". For an interval we keep matrix 3x3 and actualizing forbidden edge for single i consists of: 1. calculating values of 3x3 matrix for a small interval with i 2. actualizing a tree with times multiplying matricesComplexity is .Div1E — Bear and BowlingFIRST PART — greedy worksWe will add (take) elements to a subsequence one by one. Adding number x, when we have k - 1 taken numbers on the left, increases result by k·x + suf where suf is sum of taken numbers on the right. Let's call this added value as the Quality of element x.We will prove correctness of the following greedy algorithm. We take element with the biggest Quality till there are no elements left. For every size of a subsequence (number of taken elements) we will get optimal score.(lemma) If ai > aj and i < j, we won't take aj first.Proof. Let's consider a moment when we don't fulfill the lemma for the first time. If there are no taken numbers between ai and aj, we have Qi = k·ai + suf > k·aj + suf = Qj so ai is a better choice. For taken numbers between ai and aj — each number x changes Qi by x and Qj by aj. We'll see that x > aj so Qi will remain greater than Qj. If ai > x, the lemma (fulfilled till now) says that x wasn't taken before ai — it can't be true because x is taken and ai is not. So indeed x ≥ ai > aj.Let's assume that our greedy strategy is not correct. Let's consider first moment when we take some element aj and for some s we can't get optimal subsequence with size s by taking more elements (using any strategy). Let A denote a set of elements taken before. So there is no way to add some more elements to set A + aj and achieve optimal score with size s. But it was possible just before taking aj so there is a subset of remaining elements B that |A + B| = s and set A + B is the best among sets with size s. Note that B can't be empty.(case 1 — B contains at least one element on the left from aj) Let ai denote last element from B that i < j (here \"last\" means \"with the biggest i\"). Our strategy wanted aj before elements from B so we know from lemma that ai ≤ aj. It will turn out that replacing ai with aj (in set A + B) doesn't decrease the score so taking aj is acceptable. Note that replacing an element with another one doesn't change size of a set/subsequence.In moment of choosing aj it had the biggest quality so then Qj ≥ Qi. Now in A + B there are new elements, those in B. Let's imagine adding them to A (without ai and aj). Each new element x on the right change both Qi and Qj by x. Elements on the left change Qi by ai and Qj by aj (note that ai ≤ aj). And there are no elements between ai and aj. Now, taking ai would give us set A + B but Qj remains not less than Qi so we can take aj instead.(case 2 — B contains only elements on the right from aj) Similarly, we can replace ai with closest aj from set B. As before, elements on the right change Qi and Qj by the same value.SECOND PART — how to implement itFirst, let's understand solution. We divide a sequence into Parts. When choosing the best candidate in a Part, we want to forget about other Parts. It's enough to remember only x and suf — number of taken elements on the left (in previous Parts) and sum of elements on the right (in next Parts). x affects choosing the best element in a Part, suf doesn't (but we need this constant to add it to result for best candidate). For a Part we want to have hull with linear functions of form ai·x + b. With binary search we can find the best element in and then construct new hull for this Part in .We can remove from complexity. First, binary search can be replaced with pointers — for each Part initially we set a pointer at the beginning of Part. To find best candidate in Part, we slowly move pointer to the right (by one). Complexity is amortized . And we can sort linear functions ai·x + b by angle only once because value ai doesn't change — then constructing a hull is only . Note that when rebuilding a hull, we must set pointer to the beginning of Part.So we have . Code.There are other two correct lemmas to speed your solution up. We can take all positive numbers first (it's not so easy to prove). And we can stop when taken number doesn't increase score — next taken numbers won't increase score neither.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20040",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11147
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 1",
          "code": "#define Int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 3",
          "code": "for (int i = 0; i < n; i++)\n  b[i] = a[i] + i;\nfor (int i = 0; i < n; i++)\n  c[i] = a[i] + n - 1 - i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 4",
          "code": "{2, 1, 2, 1, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 5",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 6",
          "code": "{2, 1, 2, 1, 2}     {2, 1, 2, 1, 2}\n{0, 1, 2, 3, 4}     {4, 3, 2, 1, 0}\n_______________     _______________\n{2, 2, 4, 4, 6}     {6, 4, 4, 2, 2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 7",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 8",
          "code": "ans[i] = min(i + 1,\n             n - i,\n             a[i],\n             minimum(b, i + 1, n - 1) - i,\n             minimum(c, 0, i - 1) - n + 1 + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 9",
          "code": "max(ans[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 10",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 11",
          "code": "vector<int> q(m,0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 12",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 13",
          "code": "return 0 * printf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 14",
          "code": "return cout << \"No\", 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 15",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] - Codeforces - Code 16",
          "code": "5\n1 2 3 4\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "best = min(best, h[i]);\nbest is answer for i;\nbest++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "arr[b][a]=1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "1 + shortest_distance_of_right_neighbour,\n\n column_size)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "const __m128i v_c01 = _mm_load_si128((const __m128i *)(cur_row + j)); \nconst __m128i v_k01 = _mm_cmpgt_epi64(v_c01, v_d01);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "\"How to check it\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "12\n1 10\n11 10\n2 10\n9 10\n9 4\n9 8\n3 4\n4 5\n8 6\n8 7\n4 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "Div2B — Bear and Three Musketeers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #318 [RussianCodeCup Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "9\n0 0 0 -5 0 0 0 -3 22",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20040",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint findSet(int v) {\n    if (parent[v] != v) {\n        parent[v] = findSet(parent[v]);\n    }\n    return parent[v];\n}\n\nbool unionSet(int a, int b) {\n    a = findSet(a);\n    b = findSet(b);\n    if (a == b) {\n        // Cycle detected\n        return false;\n    }\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected at edge %d: ai = bi = %d\", i + 1, a);\n\n        bool merged = unionSet(a, b);\n        ensuref(merged, \"Cycle detected when processing edge %d: %d %d\", i + 1, a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint findSet(int v) {\n    if (parent[v] != v) {\n        parent[v] = findSet(parent[v]);\n    }\n    return parent[v];\n}\n\nbool unionSet(int a, int b) {\n    a = findSet(a);\n    b = findSet(b);\n    if (a == b) {\n        // Cycle detected\n        return false;\n    }\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected at edge %d: ai = bi = %d\", i + 1, a);\n\n        bool merged = unionSet(a, b);\n        ensuref(merged, \"Cycle detected when processing edge %d: %d %d\", i + 1, a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint findSet(int v) {\n    if (parent[v] != v) {\n        parent[v] = findSet(parent[v]);\n    }\n    return parent[v];\n}\n\nbool unionSet(int a, int b) {\n    a = findSet(a);\n    b = findSet(b);\n    if (a == b) {\n        // Cycle detected\n        return false;\n    }\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected at edge %d: ai = bi = %d\", i + 1, a);\n\n        bool merged = unionSet(a, b);\n        ensuref(merged, \"Cycle detected when processing edge %d: %d %d\", i + 1, a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if(type == \"chain\") {\n        // Generate a chain (path) tree\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({i-1, i});\n        }\n    } else if(type == \"star\") {\n        // Generate a star-shaped tree\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if(type == \"binary\") {\n        // Generate a binary tree\n        for(int i = 2; i <= n; ++i) {\n            int parent = i / 2;\n            edges.push_back({parent, i});\n        }\n    } else if(type == \"maxdegree5\") {\n        // Generate a tree with a node of degree 5\n        if(n < 6) {\n            // Can't have degree 5 node if n < 6; generate a chain instead\n            for(int i = 2; i <= n; ++i) {\n                edges.push_back({i-1, i});\n            }\n        } else {\n            int center = 1;\n            // Connect nodes 2 to 6 to the center node to make its degree 5\n            for(int i = 2; i <= 6; ++i) {\n                edges.push_back({center, i});\n            }\n            // Connect remaining nodes randomly\n            for(int i = 7; i <= n; ++i) {\n                int parent = rnd.next(2, i-1);\n                edges.push_back({parent, i});\n            }\n        }\n    } else if(type == \"multi4\") {\n        // Generate a tree with multiple nodes of degree 4 connected together\n        if(n < 9) {\n            // Can't create the intended structure if n < 9; generate a chain instead\n            for(int i = 2; i <= n; ++i) {\n                edges.push_back({i-1, i});\n            }\n        } else {\n            // Create a base chain: 1 - 2 - 3 - 4 - 5\n            edges.push_back({1,2});\n            edges.push_back({2,3});\n            edges.push_back({3,4});\n            edges.push_back({4,5});\n            // Add edges to make nodes 2 and 4 have degree 4\n            edges.push_back({2,6});\n            edges.push_back({2,7});\n            edges.push_back({4,8});\n            edges.push_back({4,9});\n            // Connect remaining nodes randomly\n            for(int i = 10; i <= n; ++i) {\n                int parent = rnd.next(1, i-1);\n                edges.push_back({parent, i});\n            }\n        }\n    } else {\n        // Default: generate a random tree\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i-1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle edges to remove any patterns\n    shuffle(edges.begin(), edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if(type == \"chain\") {\n        // Generate a chain (path) tree\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({i-1, i});\n        }\n    } else if(type == \"star\") {\n        // Generate a star-shaped tree\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if(type == \"binary\") {\n        // Generate a binary tree\n        for(int i = 2; i <= n; ++i) {\n            int parent = i / 2;\n            edges.push_back({parent, i});\n        }\n    } else if(type == \"maxdegree5\") {\n        // Generate a tree with a node of degree 5\n        if(n < 6) {\n            // Can't have degree 5 node if n < 6; generate a chain instead\n            for(int i = 2; i <= n; ++i) {\n                edges.push_back({i-1, i});\n            }\n        } else {\n            int center = 1;\n            // Connect nodes 2 to 6 to the center node to make its degree 5\n            for(int i = 2; i <= 6; ++i) {\n                edges.push_back({center, i});\n            }\n            // Connect remaining nodes randomly\n            for(int i = 7; i <= n; ++i) {\n                int parent = rnd.next(2, i-1);\n                edges.push_back({parent, i});\n            }\n        }\n    } else if(type == \"multi4\") {\n        // Generate a tree with multiple nodes of degree 4 connected together\n        if(n < 9) {\n            // Can't create the intended structure if n < 9; generate a chain instead\n            for(int i = 2; i <= n; ++i) {\n                edges.push_back({i-1, i});\n            }\n        } else {\n            // Create a base chain: 1 - 2 - 3 - 4 - 5\n            edges.push_back({1,2});\n            edges.push_back({2,3});\n            edges.push_back({3,4});\n            edges.push_back({4,5});\n            // Add edges to make nodes 2 and 4 have degree 4\n            edges.push_back({2,6});\n            edges.push_back({2,7});\n            edges.push_back({4,8});\n            edges.push_back({4,9});\n            // Connect remaining nodes randomly\n            for(int i = 10; i <= n; ++i) {\n                int parent = rnd.next(1, i-1);\n                edges.push_back({parent, i});\n            }\n        }\n    } else {\n        // Default: generate a random tree\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i-1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle edges to remove any patterns\n    shuffle(edges.begin(), edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 2 -type chain\n./gen -n 5 -type chain\n./gen -n 100 -type chain\n./gen -n 100000 -type chain\n\n./gen -n 1 -type star\n./gen -n 2 -type star\n./gen -n 5 -type star\n./gen -n 100 -type star\n./gen -n 100000 -type star\n\n./gen -n 1 -type binary\n./gen -n 2 -type binary\n./gen -n 5 -type binary\n./gen -n 100 -type binary\n./gen -n 1000 -type binary\n./gen -n 100000 -type binary\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n\n./gen -n 6 -type maxdegree5\n./gen -n 7 -type maxdegree5\n./gen -n 100 -type maxdegree5\n./gen -n 1000 -type maxdegree5\n./gen -n 100000 -type maxdegree5\n\n./gen -n 9 -type multi4\n./gen -n 10 -type multi4\n./gen -n 100 -type multi4\n./gen -n 1000 -type multi4\n./gen -n 100000 -type multi4\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:22.945877",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/A",
      "title": "A. Fibonotci",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers K and P. The second line contains a single number N. The third line contains N numbers separated by spaces, that represent the first N numbers of the sequence s. The fourth line contains a single number M, the number of values of sequence s for which . Each of the following M lines contains two numbers j and v, indicating that  and sj = v. All j-s are distinct.  1 ≤ N, M ≤ 50000  0 ≤ K ≤ 1018  1 ≤ P ≤ 109  1 ≤ si ≤ 109, for all i = 0, 1, ...N - 1  N ≤ j ≤ 1018  1 ≤ v ≤ 109  All values are integers",
      "output_spec": "OutputOutput should contain a single integer equal to .",
      "sample_tests": "ExamplesInputCopy10 831 2 127 35 4OutputCopy4",
      "description": "A. Fibonotci\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two numbers K and P. The second line contains a single number N. The third line contains N numbers separated by spaces, that represent the first N numbers of the sequence s. The fourth line contains a single number M, the number of values of sequence s for which . Each of the following M lines contains two numbers j and v, indicating that  and sj = v. All j-s are distinct.  1 ≤ N, M ≤ 50000  0 ≤ K ≤ 1018  1 ≤ P ≤ 109  1 ≤ si ≤ 109, for all i = 0, 1, ...N - 1  N ≤ j ≤ 1018  1 ≤ v ≤ 109  All values are integers\n\nOutputOutput should contain a single integer equal to .\n\nInputCopy10 831 2 127 35 4OutputCopy4\n\nInputCopy10 831 2 127 35 4\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long K = inf.readLong(0LL, 1000000000000000000LL, \"K\");\n    inf.readSpace();\n    long long P = inf.readLong(1LL, 1000000000LL, \"P\");\n    inf.readEoln();\n\n    int N = inf.readInt(1, 50000, \"N\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(N, 1, 1000000000, \"s\");\n    inf.readEoln();\n\n    int M = inf.readInt(1, 50000, \"M\");\n    inf.readEoln();\n\n    set<long long> jsSet;\n    for (int i = 0; i < M; ++i) {\n        long long j = inf.readLong(N, 1000000000000000000LL, \"j\");\n        inf.readSpace();\n        int v = inf.readInt(1, 1000000000, \"v\");\n        inf.readEoln();\n        // Ensure that j is unique\n        ensuref(jsSet.insert(j).second, \"All js must be distinct, but j=%lld occurs more than once\", j);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long K = inf.readLong(0LL, 1000000000000000000LL, \"K\");\n    inf.readSpace();\n    long long P = inf.readLong(1LL, 1000000000LL, \"P\");\n    inf.readEoln();\n\n    int N = inf.readInt(1, 50000, \"N\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(N, 1, 1000000000, \"s\");\n    inf.readEoln();\n\n    int M = inf.readInt(1, 50000, \"M\");\n    inf.readEoln();\n\n    set<long long> jsSet;\n    for (int i = 0; i < M; ++i) {\n        long long j = inf.readLong(N, 1000000000000000000LL, \"j\");\n        inf.readSpace();\n        int v = inf.readInt(1, 1000000000, \"v\");\n        inf.readEoln();\n        // Ensure that j is unique\n        ensuref(jsSet.insert(j).second, \"All js must be distinct, but j=%lld occurs more than once\", j);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long K = inf.readLong(0LL, 1000000000000000000LL, \"K\");\n    inf.readSpace();\n    long long P = inf.readLong(1LL, 1000000000LL, \"P\");\n    inf.readEoln();\n\n    int N = inf.readInt(1, 50000, \"N\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(N, 1, 1000000000, \"s\");\n    inf.readEoln();\n\n    int M = inf.readInt(1, 50000, \"M\");\n    inf.readEoln();\n\n    set<long long> jsSet;\n    for (int i = 0; i < M; ++i) {\n        long long j = inf.readLong(N, 1000000000000000000LL, \"j\");\n        inf.readSpace();\n        int v = inf.readInt(1, 1000000000, \"v\");\n        inf.readEoln();\n        // Ensure that j is unique\n        ensuref(jsSet.insert(j).second, \"All js must be distinct, but j=%lld occurs more than once\", j);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long K = opt<long long>(\"K\");\n    int P = opt<int>(\"P\");\n    int N = opt<int>(\"N\");\n    int M = opt<int>(\"M\");\n\n    string stype = opt<string>(\"stype\", \"random\");\n    string etype = opt<string>(\"etype\", \"none\");\n\n    int max_s = opt<int>(\"max_s\", 1000000000); // Maximum value for s_i\n\n    // Generate s_i according to stype\n    vector<int> s(N);\n\n    if (stype == \"random\") {\n        for (int i = 0; i < N; ++i) {\n            s[i] = rnd.next(1, max_s);\n        }\n    } else if (stype == \"constant\") {\n        int val = opt<int>(\"val\", 1); // Default value is 1\n        for (int i = 0; i < N; ++i) {\n            s[i] = val;\n        }\n    } else if (stype == \"alternating\") {\n        int val1 = opt<int>(\"val1\", 1);\n        int val2 = opt<int>(\"val2\", max_s);\n        for (int i = 0; i < N; ++i) {\n            s[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (stype == \"progression\") {\n        int start = opt<int>(\"start\", 1);\n        int diff = opt<int>(\"diff\", 1);\n        for (int i = 0; i < N; ++i) {\n            s[i] = start + i * diff;\n            if (s[i] > max_s) s[i] = s[i] % max_s + 1; // Ensure s_i ≤ max_s and s_i ≥ 1\n        }\n    } else if (stype == \"ones\") {\n        for (int i = 0; i < N; ++i) {\n            s[i] = 1;\n        }\n    } else {\n        cerr << \"Invalid stype\" << endl;\n        return 1;\n    }\n\n    // Generate exceptions according to etype\n    vector<pair<long long, int>> exceptions;\n\n    if (etype == \"none\") {\n        M = 0;\n    } else {\n        M = min(M, 50000);\n        if (etype == \"random\") {\n            set<long long> positions;\n            long long interval = (1e18 - N) / M;\n            for (int i = 0; i < M; ++i) {\n                long long base = N + i * interval;\n                long long j = base + rnd.next(0LL, interval - 1);\n                if (j > 1e18) j = 1e18;\n                while (positions.count(j)) {\n                    j = N + rnd.next(0LL, (long long)(1e18 - N));\n                }\n                positions.insert(j);\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else if (etype == \"first\") {\n            for (int i = 0; i < M; ++i) {\n                long long j = N + i;\n                if (j > 1e18) break;\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else if (etype == \"last\") {\n            for (int i = 0; i < M; ++i) {\n                if (K - i < N) break;\n                long long j = K - i;\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else if (etype == \"adjacent\") {\n            long long maxStart = 1e18 - M;\n            long long start_j = rnd.next((long long)N, maxStart);\n            for (int i = 0; i < M; ++i) {\n                long long j = start_j + i;\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else {\n            cerr << \"Invalid etype\" << endl;\n            return 1;\n        }\n    }\n\n    // Output K and P\n    cout << K << \" \" << P << \"\\n\";\n\n    // Output N\n    cout << N << \"\\n\";\n\n    // Output s[0 ... N-1]\n    for (int i = 0; i < N; ++i) {\n        cout << s[i];\n        if (i + 1 < N)\n            cout << \" \";\n        else\n            cout << \"\\n\";\n    }\n\n    // Output M\n    cout << M << \"\\n\";\n\n    // Output exceptions\n    for (auto& e : exceptions) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long K = opt<long long>(\"K\");\n    int P = opt<int>(\"P\");\n    int N = opt<int>(\"N\");\n    int M = opt<int>(\"M\");\n\n    string stype = opt<string>(\"stype\", \"random\");\n    string etype = opt<string>(\"etype\", \"none\");\n\n    int max_s = opt<int>(\"max_s\", 1000000000); // Maximum value for s_i\n\n    // Generate s_i according to stype\n    vector<int> s(N);\n\n    if (stype == \"random\") {\n        for (int i = 0; i < N; ++i) {\n            s[i] = rnd.next(1, max_s);\n        }\n    } else if (stype == \"constant\") {\n        int val = opt<int>(\"val\", 1); // Default value is 1\n        for (int i = 0; i < N; ++i) {\n            s[i] = val;\n        }\n    } else if (stype == \"alternating\") {\n        int val1 = opt<int>(\"val1\", 1);\n        int val2 = opt<int>(\"val2\", max_s);\n        for (int i = 0; i < N; ++i) {\n            s[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (stype == \"progression\") {\n        int start = opt<int>(\"start\", 1);\n        int diff = opt<int>(\"diff\", 1);\n        for (int i = 0; i < N; ++i) {\n            s[i] = start + i * diff;\n            if (s[i] > max_s) s[i] = s[i] % max_s + 1; // Ensure s_i ≤ max_s and s_i ≥ 1\n        }\n    } else if (stype == \"ones\") {\n        for (int i = 0; i < N; ++i) {\n            s[i] = 1;\n        }\n    } else {\n        cerr << \"Invalid stype\" << endl;\n        return 1;\n    }\n\n    // Generate exceptions according to etype\n    vector<pair<long long, int>> exceptions;\n\n    if (etype == \"none\") {\n        M = 0;\n    } else {\n        M = min(M, 50000);\n        if (etype == \"random\") {\n            set<long long> positions;\n            long long interval = (1e18 - N) / M;\n            for (int i = 0; i < M; ++i) {\n                long long base = N + i * interval;\n                long long j = base + rnd.next(0LL, interval - 1);\n                if (j > 1e18) j = 1e18;\n                while (positions.count(j)) {\n                    j = N + rnd.next(0LL, (long long)(1e18 - N));\n                }\n                positions.insert(j);\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else if (etype == \"first\") {\n            for (int i = 0; i < M; ++i) {\n                long long j = N + i;\n                if (j > 1e18) break;\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else if (etype == \"last\") {\n            for (int i = 0; i < M; ++i) {\n                if (K - i < N) break;\n                long long j = K - i;\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else if (etype == \"adjacent\") {\n            long long maxStart = 1e18 - M;\n            long long start_j = rnd.next((long long)N, maxStart);\n            for (int i = 0; i < M; ++i) {\n                long long j = start_j + i;\n                int v = rnd.next(1, max_s);\n                exceptions.push_back({j, v});\n            }\n        } else {\n            cerr << \"Invalid etype\" << endl;\n            return 1;\n        }\n    }\n\n    // Output K and P\n    cout << K << \" \" << P << \"\\n\";\n\n    // Output N\n    cout << N << \"\\n\";\n\n    // Output s[0 ... N-1]\n    for (int i = 0; i < N; ++i) {\n        cout << s[i];\n        if (i + 1 < N)\n            cout << \" \";\n        else\n            cout << \"\\n\";\n    }\n\n    // Output M\n    cout << M << \"\\n\";\n\n    // Output exceptions\n    for (auto& e : exceptions) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case with small K and P, no exceptions, s_i are ones\n./gen -K=0 -P=7 -N=5 -M=0 -stype=ones -etype=none\n\n# Test case with K small, P large, random s_i\n./gen -K=10 -P=1000000000 -N=5 -M=2 -stype=random -etype=random\n\n# Test case with K large, P small, constant s_i\n./gen -K=1000000000000000000 -P=1 -N=5 -M=0 -stype=constant -val=5 -etype=none\n\n# Test case with maximum N and M, random s_i, exceptions at first positions\n./gen -K=1000000000000 -P=1000000000 -N=50000 -M=50000 -stype=random -etype=first\n\n# Test case with alternating s_i, exceptions at last positions\n./gen -K=100000000 -P=999999937 -N=10000 -M=10000 -stype=alternating -val1=1 -val2=1000000000 -etype=last\n\n# Test case with progression s_i, exceptions are adjacent\n./gen -K=10000000000 -P=1000000000 -N=20000 -M=20000 -stype=progression -start=1 -diff=5 -etype=adjacent\n\n# Test case with no exceptions, s_i are random\n./gen -K=1000000 -P=1000000000 -N=100000 -M=0 -stype=random -etype=none\n\n# Test case where K is zero\n./gen -K=0 -P=100 -N=10 -M=0 -stype=random -etype=none\n\n# Test case where K equals N\n./gen -K=10000 -P=123456789 -N=10000 -M=0 -stype=random -etype=none\n\n# Test case with K slightly larger than N, random exceptions\n./gen -K=15000 -P=1000000000 -N=10000 -M=5000 -stype=random -etype=random\n\n# Test case with maximum K, s_i are ones, no exceptions\n./gen -K=1000000000000000000 -P=1000000007 -N=1 -M=0 -stype=ones -etype=none\n\n# Test case with P as 1, s_i constant\n./gen -K=1000000 -P=1 -N=100 -M=100 -stype=constant -val=1000000000 -etype=random\n\n# Test case with exceptions at arbitrary positions\n./gen -K=5000000000000 -P=987654321 -N=30000 -M=30000 -stype=random -etype=random\n\n# Test case with small N, large M, random s_i\n./gen -K=100000000 -P=1000000000 -N=10 -M=50000 -stype=random -etype=random\n\n# Test case with very large N, small M, progression s_i\n./gen -K=10000000000 -P=1000000000 -N=50000 -M=10 -stype=progression -start=100000 -diff=100000 -etype=random\n\n# Test case with alternating s_i, no exceptions\n./gen -K=10000000000 -P=1000000007 -N=50000 -M=0 -stype=alternating -val1=1 -val2=999999999 -etype=none\n\n# Test case with exceptions clustered at the end\n./gen -K=1000000000 -P=1000000000 -N=20000 -M=5000 -stype=random -etype=last\n\n# Test case with exceptions clustered at the start\n./gen -K=1000000000 -P=1000000000 -N=20000 -M=5000 -stype=random -etype=first\n\n# Test case with K equal to N-1\n./gen -K=9999 -P=1000000007 -N=10000 -M=0 -stype=random -etype=none\n\n# Test case with K equal to N+1\n./gen -K=10001 -P=1000000007 -N=10000 -M=0 -stype=random -etype=none\n\n# Test case with exceptions covering maximum positions\n./gen -K=1000000000000000000 -P=1000000000 -N=50000 -M=50000 -stype=random -etype=adjacent\n\n# Test case with K very small, M very large\n./gen -K=5 -P=1000000000 -N=5 -M=50000 -stype=random -etype=random\n\n# Test case with all s_i being maximum\n./gen -K=10000000000 -P=1000000000 -N=50000 -M=0 -stype=constant -val=1000000000 -etype=none\n\n# Test case with exceptions having same values as s_i\n./gen -K=100000000 -P=1000000000 -N=1000 -M=10000 -stype=constant -val=500000000 -etype=random\n\n# Test case with random s_i and M=0\n./gen -K=1000000000 -P=1000000007 -N=50000 -M=0 -stype=random -etype=none\n\n# Test case with K, N, M, P all at maximum\n./gen -K=1000000000000000000 -P=1000000000 -N=50000 -M=50000 -stype=random -etype=random\n\n# Test case where exceptions are at consecutive positions, s_i are ones\n./gen -K=100000 -P=1000000000 -N=1000 -M=50000 -stype=ones -etype=adjacent\n\n# Test case with K very large, P very large, s_i alternating between small and large values\n./gen -K=1000000000000000000 -P=1000000000 -N=50000 -M=50000 -stype=alternating -val1=1 -val2=1000000000 -etype=random\n\n# Test case with K small, s_i are progression, M=0\n./gen -K=10000 -P=1000000000 -N=10000 -M=0 -stype=progression -start=1 -diff=1 -etype=none\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:24.775073",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/B",
      "title": "B. Bribes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains N, the number of towns in Ruritania. The following N - 1 lines contain information regarding individual roads between towns. A road is represented by a tuple of integers (a,b,x), which are separated with a single whitespace character. The numbers a and b represent the cities connected by this particular road, and x is either 0 or 1: 0 means that the road is bidirectional, 1 means that only the a → b direction is legal. The next line contains K, the number of stops Borna has to make. The final line of input contains K positive integers s1, …, sK: the towns Borna has to visit.  1 ≤ N ≤ 105  1 ≤ K ≤ 106  1 ≤ a, b ≤ N for all roads   for all roads  1 ≤ si ≤ N for all 1 ≤ i ≤ K",
      "output_spec": "OutputThe output should contain a single number: the least amount of thousands of Ruritanian dinars Borna should allocate for bribes, modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy51 2 02 3 05 1 13 4 155 4 5 2 2OutputCopy4",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains N, the number of towns in Ruritania. The following N - 1 lines contain information regarding individual roads between towns. A road is represented by a tuple of integers (a,b,x), which are separated with a single whitespace character. The numbers a and b represent the cities connected by this particular road, and x is either 0 or 1: 0 means that the road is bidirectional, 1 means that only the a → b direction is legal. The next line contains K, the number of stops Borna has to make. The final line of input contains K positive integers s1, …, sK: the towns Borna has to visit.  1 ≤ N ≤ 105  1 ≤ K ≤ 106  1 ≤ a, b ≤ N for all roads   for all roads  1 ≤ si ≤ N for all 1 ≤ i ≤ K\n\nOutputThe output should contain a single number: the least amount of thousands of Ruritanian dinars Borna should allocate for bribes, modulo 109 + 7.\n\nInputCopy51 2 02 3 05 1 13 4 155 4 5 2 2OutputCopy4\n\nInputCopy51 2 02 3 05 1 13 4 155 4 5 2 2\n\nOutputCopy4\n\nNoteBorna first takes the route 1 → 5 and has to pay 1000 dinars. After that, he takes the route 5 → 1 → 2 → 3 → 4 and pays nothing this time. However, when he has to return via 4 → 3 → 2 → 1 → 5, he needs to prepare 3000 (1000+2000) dinars. Afterwards, getting to 2 via 5 → 1 → 2 will cost him nothing. Finally, he doesn't even have to leave town 2 to get to 2, so there is no need to prepare any additional bribe money. Hence he has to prepare 4000 dinars in total.",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n    \n    vector<tuple<int,int,int>> edgeList;\n    set<pair<int,int>> edgeSet;\n\n    vector<int> parent(N + 1);\n    for (int i = 1; i <= N; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a = inf.readInt(1, N, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, N, \"b\");\n        inf.readSpace();\n        int x = inf.readInt(0, 1, \"x\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Road cannot connect a town to itself\");\n\n        int u = min(a,b);\n        int v = max(a,b);\n        ensuref(edgeSet.find({u,v}) == edgeSet.end(), \"Duplicate edge between towns %d and %d\", u, v);\n        edgeSet.insert({u,v});\n\n        int pa = find(a);\n        int pb = find(b);\n        ensuref(pa != pb, \"The graph contains a cycle between node %d and node %d\", a, b);\n        parent[pa] = pb;\n\n        edgeList.push_back({a, b, x});\n\n    }\n\n    int K = inf.readInt(1, 1000000, \"K\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(K, 1, N, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n    \n    vector<tuple<int,int,int>> edgeList;\n    set<pair<int,int>> edgeSet;\n\n    vector<int> parent(N + 1);\n    for (int i = 1; i <= N; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a = inf.readInt(1, N, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, N, \"b\");\n        inf.readSpace();\n        int x = inf.readInt(0, 1, \"x\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Road cannot connect a town to itself\");\n\n        int u = min(a,b);\n        int v = max(a,b);\n        ensuref(edgeSet.find({u,v}) == edgeSet.end(), \"Duplicate edge between towns %d and %d\", u, v);\n        edgeSet.insert({u,v});\n\n        int pa = find(a);\n        int pb = find(b);\n        ensuref(pa != pb, \"The graph contains a cycle between node %d and node %d\", a, b);\n        parent[pa] = pb;\n\n        edgeList.push_back({a, b, x});\n\n    }\n\n    int K = inf.readInt(1, 1000000, \"K\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(K, 1, N, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n    \n    vector<tuple<int,int,int>> edgeList;\n    set<pair<int,int>> edgeSet;\n\n    vector<int> parent(N + 1);\n    for (int i = 1; i <= N; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a = inf.readInt(1, N, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, N, \"b\");\n        inf.readSpace();\n        int x = inf.readInt(0, 1, \"x\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Road cannot connect a town to itself\");\n\n        int u = min(a,b);\n        int v = max(a,b);\n        ensuref(edgeSet.find({u,v}) == edgeSet.end(), \"Duplicate edge between towns %d and %d\", u, v);\n        edgeSet.insert({u,v});\n\n        int pa = find(a);\n        int pb = find(b);\n        ensuref(pa != pb, \"The graph contains a cycle between node %d and node %d\", a, b);\n        parent[pa] = pb;\n\n        edgeList.push_back({a, b, x});\n\n    }\n\n    int K = inf.readInt(1, 1000000, \"K\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(K, 1, N, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n    vector<int> x; // x[i] is 0 or 1: 0 means bidirectional, 1 means unidirectional\n    // Build tree\n    vector<int> p(n+1); // parent\n    for (int i = 2; i <= n; ++i) {\n        p[i] = rnd.next(1, i - 1);\n    }\n\n    if (type == \"bidirectional\") {\n        // All edges are bidirectional\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i});\n            x.push_back(0); // bidirectional\n        }\n    } else if (type == \"unidirectional\") {\n        // All edges are unidirectional in random directions\n        for (int i = 2; i <= n; ++i) {\n            int a = p[i];\n            int b = i;\n            if (rnd.next(0,1)) swap(a,b);\n            edges.push_back({a, b});\n            x.push_back(1);\n        }\n    } else if (type == \"unidirectional_to_root\") {\n        // Edges point towards root\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, p[i]}); // Edge from i to parent\n            x.push_back(1);\n        }\n    } else if (type == \"unidirectional_from_root\") {\n        // Edges point away from root\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i}); // Edge from parent to i\n            x.push_back(1);\n        }\n    } else if (type == \"heavy_bribes\") {\n        // Create a chain where all edges are unidirectional against the travel direction\n        // and the stops force Borna to go back and forth over the same edge\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, i-1}); // Edge from i to i-1\n            x.push_back(1); // unidirectional\n        }\n    } else if (type == \"no_bribes\") {\n        // All edges are bidirectional, and stops are random\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i});\n            x.push_back(0); // bidirectional\n        }\n    } else if (type == \"max_bribes\") {\n        // Construct a tree where Borna must cross the same edge many times illegally\n        // Edges are unidirectional towards node 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, p[i]}); // Edge from i to parent\n            x.push_back(1);\n        }\n    } else {\n        // Random tree with random edge directions and x\n        for (int i = 2; i <= n; ++i) {\n            int a = p[i];\n            int b = i;\n            if (rnd.next(0,1)) swap(a,b);\n            edges.push_back({a, b});\n            x.push_back(rnd.next(0,1));\n        }\n    }\n\n    // Now generate the sequence of stops\n    vector<int> stops;\n    if (type == \"heavy_bribes\" || type == \"max_bribes\") {\n        // Force Borna to revisit nodes and cross edges multiple times\n        for (int i = 0; i < k; ++i) {\n            int node = n; // Always go to node n, causing revisit\n            stops.push_back(node);\n        }\n    } else if (type == \"no_bribes\"){\n        // Random stops\n        for (int i = 0; i < k; ++i) {\n            int node = rnd.next(1, n);\n            stops.push_back(node);\n        }\n    } else {\n        // Random stops\n        for (int i = 0; i < k; ++i) {\n            int node = rnd.next(1, n);\n            stops.push_back(node);\n        }\n    }\n\n    // output:\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < edges.size(); ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, x[i]);\n    }\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d\", stops[i]);\n        if (i + 1 < k)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n    vector<int> x; // x[i] is 0 or 1: 0 means bidirectional, 1 means unidirectional\n    // Build tree\n    vector<int> p(n+1); // parent\n    for (int i = 2; i <= n; ++i) {\n        p[i] = rnd.next(1, i - 1);\n    }\n\n    if (type == \"bidirectional\") {\n        // All edges are bidirectional\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i});\n            x.push_back(0); // bidirectional\n        }\n    } else if (type == \"unidirectional\") {\n        // All edges are unidirectional in random directions\n        for (int i = 2; i <= n; ++i) {\n            int a = p[i];\n            int b = i;\n            if (rnd.next(0,1)) swap(a,b);\n            edges.push_back({a, b});\n            x.push_back(1);\n        }\n    } else if (type == \"unidirectional_to_root\") {\n        // Edges point towards root\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, p[i]}); // Edge from i to parent\n            x.push_back(1);\n        }\n    } else if (type == \"unidirectional_from_root\") {\n        // Edges point away from root\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i}); // Edge from parent to i\n            x.push_back(1);\n        }\n    } else if (type == \"heavy_bribes\") {\n        // Create a chain where all edges are unidirectional against the travel direction\n        // and the stops force Borna to go back and forth over the same edge\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, i-1}); // Edge from i to i-1\n            x.push_back(1); // unidirectional\n        }\n    } else if (type == \"no_bribes\") {\n        // All edges are bidirectional, and stops are random\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i});\n            x.push_back(0); // bidirectional\n        }\n    } else if (type == \"max_bribes\") {\n        // Construct a tree where Borna must cross the same edge many times illegally\n        // Edges are unidirectional towards node 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, p[i]}); // Edge from i to parent\n            x.push_back(1);\n        }\n    } else {\n        // Random tree with random edge directions and x\n        for (int i = 2; i <= n; ++i) {\n            int a = p[i];\n            int b = i;\n            if (rnd.next(0,1)) swap(a,b);\n            edges.push_back({a, b});\n            x.push_back(rnd.next(0,1));\n        }\n    }\n\n    // Now generate the sequence of stops\n    vector<int> stops;\n    if (type == \"heavy_bribes\" || type == \"max_bribes\") {\n        // Force Borna to revisit nodes and cross edges multiple times\n        for (int i = 0; i < k; ++i) {\n            int node = n; // Always go to node n, causing revisit\n            stops.push_back(node);\n        }\n    } else if (type == \"no_bribes\"){\n        // Random stops\n        for (int i = 0; i < k; ++i) {\n            int node = rnd.next(1, n);\n            stops.push_back(node);\n        }\n    } else {\n        // Random stops\n        for (int i = 0; i < k; ++i) {\n            int node = rnd.next(1, n);\n            stops.push_back(node);\n        }\n    }\n\n    // output:\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < edges.size(); ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, x[i]);\n    }\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d\", stops[i]);\n        if (i + 1 < k)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 5 -type bidirectional\n./gen -n 5 -k 5 -type unidirectional\n./gen -n 10 -k 5 -type heavy_bribes\n./gen -n 10 -k 5 -type no_bribes\n./gen -n 100 -k 50 -type bidirectional\n./gen -n 100 -k 50 -type unidirectional_to_root\n./gen -n 1000 -k 500 -type unidirectional_from_root\n./gen -n 1000 -k 500 -type heavy_bribes\n./gen -n 10000 -k 5000 -type max_bribes\n./gen -n 10000 -k 5000 -type random\n./gen -n 100000 -k 100000 -type heavy_bribes\n./gen -n 100000 -k 100000 -type max_bribes\n./gen -n 100000 -k 100000 -type no_bribes\n./gen -n 100000 -k 100000 -type unidirectional\n./gen -n 100000 -k 100000 -type unidirectional_to_root\n./gen -n 100000 -k 100000 -type unidirectional_from_root\n./gen -n 99999 -k 99999 -type heavy_bribes\n./gen -n 99998 -k 88888 -type heavy_bribes\n./gen -n 50000 -k 50000 -type bidirectional\n./gen -n 20000 -k 20000 -type random\n./gen -n 100000 -k 1000000 -type random\n./gen -n 1 -k 1 -type bidirectional\n./gen -n 2 -k 1 -type unidirectional\n./gen -n 2 -k 2 -type unidirectional_from_root\n./gen -n 100000 -k 1000000 -type unidirectional\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:26.463443",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/C",
      "title": "C. Party",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test4 megabytes",
      "input_spec": "InputThe first line contains integer N — number of employees in MDCS.Then an N × N matrix follows, where element in i-th row and j-th column is an integer number that represents how much i-th person likes j-th club’s Friday party.Then another N × N matrix follows, where element in i-th row and j-th column is an integer number that represents how much i-th person likes j-th club’s Saturday party.  2 ≤ N ≤ 20  N is even  0 ≤  level of likeness  ≤ 106  All values are integers",
      "output_spec": "OutputOutput should contain a single integer — maximum sum of happiness possible.",
      "sample_tests": "ExamplesInputCopy41 2 3 42 3 4 13 4 1 24 1 2 35 8 7 16 9 81 355 78 1 61 1 1 1OutputCopy167",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test4 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer N — number of employees in MDCS.Then an N × N matrix follows, where element in i-th row and j-th column is an integer number that represents how much i-th person likes j-th club’s Friday party.Then another N × N matrix follows, where element in i-th row and j-th column is an integer number that represents how much i-th person likes j-th club’s Saturday party.  2 ≤ N ≤ 20  N is even  0 ≤  level of likeness  ≤ 106  All values are integers\n\nOutputOutput should contain a single integer — maximum sum of happiness possible.\n\nInputCopy41 2 3 42 3 4 13 4 1 24 1 2 35 8 7 16 9 81 355 78 1 61 1 1 1OutputCopy167\n\nInputCopy41 2 3 42 3 4 13 4 1 24 1 2 35 8 7 16 9 81 355 78 1 61 1 1 1\n\nOutputCopy167\n\nNoteHere is how we matched people with clubs:Friday: 1st person with 4th club (4 happiness) and 4th person with 1st club (4 happiness). Saturday: 2nd person with 3rd club (81 happiness) and 3rd person with 2nd club (78 happiness).4+4+81+78 = 167",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(2, 20, \"N\");\n    inf.readEoln();\n    ensuref(N % 2 == 0, \"N (%d) must be even\", N);\n\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 0, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 0, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(2, 20, \"N\");\n    inf.readEoln();\n    ensuref(N % 2 == 0, \"N (%d) must be even\", N);\n\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 0, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 0, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(2, 20, \"N\");\n    inf.readEoln();\n    ensuref(N % 2 == 0, \"N (%d) must be even\", N);\n\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 0, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 0, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is even and within the constraints\n    ensure(2 <= n && n <= 20 && n % 2 == 0);\n\n    vector<vector<int>> friday(n, vector<int>(n));\n    vector<vector<int>> saturday(n, vector<int>(n));\n\n    if (type == \"random\") {\n        // Generate random values for likeness matrices\n        int maxValue = opt<int>(\"maxValue\", 1000000);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                friday[i][j] = rnd.next(0, maxValue);\n                saturday[i][j] = rnd.next(0, maxValue);\n            }\n        }\n    } else if (type == \"max\") {\n        // Set all likeness values to maximum (1,000,000)\n        int maxValue = 1000000;\n        for (int i = 0; i < n; ++i) {\n            fill(friday[i].begin(), friday[i].end(), maxValue);\n            fill(saturday[i].begin(), saturday[i].end(), maxValue);\n        }\n    } else if (type == \"min\") {\n        // Set all likeness values to zero\n        for (int i = 0; i < n; ++i) {\n            fill(friday[i].begin(), friday[i].end(), 0);\n            fill(saturday[i].begin(), saturday[i].end(), 0);\n        }\n    } else if (type == \"one_club_zero\") {\n        // Set likeness values to zero for one club\n        int zeroClub = rnd.next(0, n-1);\n        for (int i = 0; i < n; ++i) {\n            friday[i][zeroClub] = 0;\n            saturday[i][zeroClub] = 0;\n            for (int j = 0; j < n; ++j) {\n                if (j != zeroClub) {\n                    friday[i][j] = rnd.next(1, 1000000);\n                    saturday[i][j] = rnd.next(1, 1000000);\n                }\n            }\n        }\n    } else if (type == \"high_conflict\") {\n        // Multiple people have high likeness to the same club\n        int targetClub = rnd.next(0, n-1);\n        int maxValue = 1000000;\n        int minValue = 100;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                friday[i][targetClub] = maxValue;\n                saturday[i][targetClub] = maxValue;\n            } else {\n                friday[i][targetClub] = minValue;\n                saturday[i][targetClub] = minValue;\n            }\n            for (int j = 0; j < n; ++j) {\n                if (j != targetClub) {\n                    friday[i][j] = rnd.next(minValue, maxValue - 1);\n                    saturday[i][j] = rnd.next(minValue, maxValue - 1);\n                }\n            }\n        }\n    } else if (type == \"duplicates\") {\n        // All people have the same likeness values\n        for (int i = 0; i < n; ++i) {\n            vector<int> likenessValues(n);\n            for (int j = 0; j < n; ++j) {\n                likenessValues[j] = rnd.next(0, 1000000);\n            }\n            friday[i] = likenessValues;\n            saturday[i] = likenessValues;\n        }\n    } else {\n        // By default, generate random values\n        int maxValue = 1000000;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                friday[i][j] = rnd.next(0, maxValue);\n                saturday[i][j] = rnd.next(0, maxValue);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", friday[i][j]);\n            if (j+1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", saturday[i][j]);\n            if (j+1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is even and within the constraints\n    ensure(2 <= n && n <= 20 && n % 2 == 0);\n\n    vector<vector<int>> friday(n, vector<int>(n));\n    vector<vector<int>> saturday(n, vector<int>(n));\n\n    if (type == \"random\") {\n        // Generate random values for likeness matrices\n        int maxValue = opt<int>(\"maxValue\", 1000000);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                friday[i][j] = rnd.next(0, maxValue);\n                saturday[i][j] = rnd.next(0, maxValue);\n            }\n        }\n    } else if (type == \"max\") {\n        // Set all likeness values to maximum (1,000,000)\n        int maxValue = 1000000;\n        for (int i = 0; i < n; ++i) {\n            fill(friday[i].begin(), friday[i].end(), maxValue);\n            fill(saturday[i].begin(), saturday[i].end(), maxValue);\n        }\n    } else if (type == \"min\") {\n        // Set all likeness values to zero\n        for (int i = 0; i < n; ++i) {\n            fill(friday[i].begin(), friday[i].end(), 0);\n            fill(saturday[i].begin(), saturday[i].end(), 0);\n        }\n    } else if (type == \"one_club_zero\") {\n        // Set likeness values to zero for one club\n        int zeroClub = rnd.next(0, n-1);\n        for (int i = 0; i < n; ++i) {\n            friday[i][zeroClub] = 0;\n            saturday[i][zeroClub] = 0;\n            for (int j = 0; j < n; ++j) {\n                if (j != zeroClub) {\n                    friday[i][j] = rnd.next(1, 1000000);\n                    saturday[i][j] = rnd.next(1, 1000000);\n                }\n            }\n        }\n    } else if (type == \"high_conflict\") {\n        // Multiple people have high likeness to the same club\n        int targetClub = rnd.next(0, n-1);\n        int maxValue = 1000000;\n        int minValue = 100;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                friday[i][targetClub] = maxValue;\n                saturday[i][targetClub] = maxValue;\n            } else {\n                friday[i][targetClub] = minValue;\n                saturday[i][targetClub] = minValue;\n            }\n            for (int j = 0; j < n; ++j) {\n                if (j != targetClub) {\n                    friday[i][j] = rnd.next(minValue, maxValue - 1);\n                    saturday[i][j] = rnd.next(minValue, maxValue - 1);\n                }\n            }\n        }\n    } else if (type == \"duplicates\") {\n        // All people have the same likeness values\n        for (int i = 0; i < n; ++i) {\n            vector<int> likenessValues(n);\n            for (int j = 0; j < n; ++j) {\n                likenessValues[j] = rnd.next(0, 1000000);\n            }\n            friday[i] = likenessValues;\n            saturday[i] = likenessValues;\n        }\n    } else {\n        // By default, generate random values\n        int maxValue = 1000000;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                friday[i][j] = rnd.next(0, maxValue);\n                saturday[i][j] = rnd.next(0, maxValue);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", friday[i][j]);\n            if (j+1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", saturday[i][j]);\n            if (j+1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type min\n./gen -n 2 -type max\n./gen -n 2 -type random\n\n./gen -n 4 -type random\n./gen -n 4 -type one_club_zero\n./gen -n 4 -type high_conflict\n\n./gen -n 6 -type random\n./gen -n 6 -type duplicates\n\n./gen -n 8 -type random\n./gen -n 8 -type one_club_zero\n\n./gen -n 10 -type random\n./gen -n 10 -type high_conflict\n\n./gen -n 12 -type random\n./gen -n 12 -type duplicates\n\n./gen -n 14 -type random\n\n./gen -n 16 -type random\n\n./gen -n 18 -type random\n\n./gen -n 20 -type random\n./gen -n 20 -type max\n./gen -n 20 -type min\n\n./gen -n 20 -type duplicates\n\n./gen -n 20 -type high_conflict\n\n./gen -n 20 -type one_club_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:28.767199",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/D",
      "title": "D. Tablecity",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThere is no input for this problem.",
      "output_spec": "OutputThe first line of output contains integer N – duration of police search in hours. Each of the following N lines contains exactly 4 integers Xi1, Yi1, Xi2, Yi2 separated by spaces, that represent 2 districts (Xi1, Yi1), (Xi2, Yi2) which got investigated during i-th hour. Output is given in chronological order (i-th line contains districts investigated during i-th hour) and should guarantee that the thief is caught in no more than 2015 hours, regardless of thief’s initial position and movement.  N ≤ 2015  1 ≤ X ≤ 1000  1 ≤ Y ≤ 2",
      "sample_tests": "ExamplesInputCopyВ этой задаче нет примеров ввода-вывода.This problem doesn't have sample input and output.OutputCopyСмотрите замечание ниже.See the note below.",
      "description": "D. Tablecity\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThere is no input for this problem.\n\nOutputThe first line of output contains integer N – duration of police search in hours. Each of the following N lines contains exactly 4 integers Xi1, Yi1, Xi2, Yi2 separated by spaces, that represent 2 districts (Xi1, Yi1), (Xi2, Yi2) which got investigated during i-th hour. Output is given in chronological order (i-th line contains districts investigated during i-th hour) and should guarantee that the thief is caught in no more than 2015 hours, regardless of thief’s initial position and movement.  N ≤ 2015  1 ≤ X ≤ 1000  1 ≤ Y ≤ 2\n\nInputCopyВ этой задаче нет примеров ввода-вывода.This problem doesn't have sample input and output.OutputCopyСмотрите замечание ниже.See the note below.\n\nInputCopyВ этой задаче нет примеров ввода-вывода.This problem doesn't have sample input and output.\n\nOutputCopyСмотрите замечание ниже.See the note below.\n\nNoteLet's consider the following output:25 1 50 28 1 80 2This output is not guaranteed to catch the thief and is not correct. It is given to you only to show the expected output format. There exists a combination of an initial position and a movement strategy such that the police will not catch the thief.Consider the following initial position and thief’s movement:In the first hour, the thief is located in district (1,1). Police officers will search districts (5,1) and (50,2) and will not find him.At the start of the second hour, the thief moves to district (2,2). Police officers will search districts (8,1) and (80,2) and will not find him.Since there is no further investigation by the police, the thief escaped!",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 2015, \"N\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int Xi1 = inf.readInt(1, 1000, \"Xi1\");\n        inf.readSpace();\n        int Yi1 = inf.readInt(1, 2, \"Yi1\");\n        inf.readSpace();\n        int Xi2 = inf.readInt(1, 1000, \"Xi2\");\n        inf.readSpace();\n        int Yi2 = inf.readInt(1, 2, \"Yi2\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 2015, \"N\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int Xi1 = inf.readInt(1, 1000, \"Xi1\");\n        inf.readSpace();\n        int Yi1 = inf.readInt(1, 2, \"Yi1\");\n        inf.readSpace();\n        int Xi2 = inf.readInt(1, 1000, \"Xi2\");\n        inf.readSpace();\n        int Yi2 = inf.readInt(1, 2, \"Yi2\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 2015, \"N\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int Xi1 = inf.readInt(1, 1000, \"Xi1\");\n        inf.readSpace();\n        int Yi1 = inf.readInt(1, 2, \"Yi1\");\n        inf.readSpace();\n        int Xi2 = inf.readInt(1, 1000, \"Xi2\");\n        inf.readSpace();\n        int Yi2 = inf.readInt(1, 2, \"Yi2\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_X = 1000;\nconst int MAX_Y = 2;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int N = ouf.readInt(1, 2015, \"N\");\n\n    vector<pair<int,int>> police_positions1(N);\n    vector<pair<int,int>> police_positions2(N);\n\n    for (int t = 0; t < N; ++t) {\n        int x1 = ouf.readInt(1, MAX_X, \"Xi1\");\n        int y1 = ouf.readInt(1, MAX_Y, \"Yi1\");\n        int x2 = ouf.readInt(1, MAX_X, \"Xi2\");\n        int y2 = ouf.readInt(1, MAX_Y, \"Yi2\");\n\n        police_positions1[t] = {x1, y1};\n        police_positions2[t] = {x2, y2};\n    }\n\n    // Initialize possible positions at time 0\n    vector<vector<bool>> prev_positions(MAX_X + 1, vector<bool>(MAX_Y + 1, true));\n\n    for (int t = 0; t < N; ++t) {\n        // Initialize current positions to false\n        vector<vector<bool>> curr_positions(MAX_X + 1, vector<bool>(MAX_Y + 1, false));\n\n        // For each possible position in prev_positions\n        for (int x = 1; x <= MAX_X; ++x) {\n            for (int y = 1; y <= MAX_Y; ++y) {\n                if (prev_positions[x][y]) {\n                    // Possible moves\n                    for (int dx = -1; dx <= 1; dx += 2) { // dx = -1 or 1\n                        int nx = x + dx;\n                        if (nx >=1 && nx <= MAX_X) {\n                            // Move to (nx, y)\n                            curr_positions[nx][y] = true;\n\n                            // Move to (nx, 3 - y)\n                            curr_positions[nx][3 - y] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Remove positions searched by police\n        int x1 = police_positions1[t].first;\n        int y1 = police_positions1[t].second;\n        int x2 = police_positions2[t].first;\n        int y2 = police_positions2[t].second;\n\n        curr_positions[x1][y1] = false;\n        curr_positions[x2][y2] = false;\n\n        // Check if any positions remain\n        bool any_positions = false;\n        for (int x = 1; x <= MAX_X && !any_positions; ++x) {\n            for (int y = 1; y <= MAX_Y && !any_positions; ++y) {\n                if (curr_positions[x][y]) {\n                    any_positions = true;\n                }\n            }\n        }\n        if (!any_positions) {\n            quitf(_ok, \"Thief is guaranteed to be caught in %d hours\", t+1);\n        }\n\n        // Prepare for next time step\n        prev_positions = std::move(curr_positions);\n    }\n\n    // After N steps, check if any positions remain\n    bool any_positions = false;\n    for (int x = 1; x <= MAX_X && !any_positions; ++x) {\n        for (int y = 1; y <= MAX_Y && !any_positions; ++y) {\n            if (prev_positions[x][y]) {\n                any_positions = true;\n            }\n        }\n    }\n    if (any_positions) {\n        quitf(_wa, \"Thief could avoid capture after %d hours\", N);\n    } else {\n        quitf(_ok, \"Thief is guaranteed to be caught in %d hours\", N);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\", 100);         // Default N = 100 if not specified\n    string type = opt<string>(\"type\", \"random\"); // Default type = \"random\"\n\n    // Ensure N is within the constraints\n    N = max(1, min(N, 2015));\n\n    // Adjust N for specific types if needed\n    if (type == \"minimal\") {\n        N = 1;\n    } else if (type == \"maximal\") {\n        N = 2015;\n    }\n\n    // Output N\n    printf(\"%d\\n\", N);\n\n    if (type == \"random\") {\n        // Generate random districts for each hour\n        for(int i = 0; i < N; ++i) {\n            int Xi1 = rnd.next(1, 1000);\n            int Yi1 = rnd.next(1, 2);\n            int Xi2 = rnd.next(1, 1000);\n            int Yi2 = rnd.next(1, 2);\n            printf(\"%d %d %d %d\\n\", Xi1, Yi1, Xi2, Yi2);\n        }\n    } else if (type == \"minimal\") {\n        // Output minimal districts\n        printf(\"1 1 1 1\\n\");\n    } else if (type == \"maximal\") {\n        // Output maximal districts\n        for(int i = 0; i < N; ++i) {\n            printf(\"1000 2 1000 2\\n\");\n        }\n    } else if (type == \"same_districts\") {\n        // Investigate the same district in each hour\n        int Xi = rnd.next(1, 1000);\n        int Yi = rnd.next(1, 2);\n        for(int i = 0; i < N; ++i) {\n            printf(\"%d %d %d %d\\n\", Xi, Yi, Xi, Yi);\n        }\n    } else if (type == \"opposite_districts\") {\n        // Investigate opposite districts\n        for(int i = 0; i < N; ++i) {\n            printf(\"1 1 1000 2\\n\");\n        }\n    } else if (type == \"edge_case\") {\n        // Alternate between edge districts\n        for(int i = 0; i < N; ++i) {\n            int Xi1 = (i % 2 == 0) ? 1 : 1000;\n            int Yi1 = (i % 2 == 0) ? 1 : 2;\n            int Xi2 = (i % 2 == 0) ? 1000 : 1;\n            int Yi2 = (i % 2 == 0) ? 2 : 1;\n            printf(\"%d %d %d %d\\n\", Xi1, Yi1, Xi2, Yi2);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for(int i = 0; i < N; ++i) {\n            int Xi1 = rnd.next(1, 1000);\n            int Yi1 = rnd.next(1, 2);\n            int Xi2 = rnd.next(1, 1000);\n            int Yi2 = rnd.next(1, 2);\n            printf(\"%d %d %d %d\\n\", Xi1, Yi1, Xi2, Yi2);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\", 100);         // Default N = 100 if not specified\n    string type = opt<string>(\"type\", \"random\"); // Default type = \"random\"\n\n    // Ensure N is within the constraints\n    N = max(1, min(N, 2015));\n\n    // Adjust N for specific types if needed\n    if (type == \"minimal\") {\n        N = 1;\n    } else if (type == \"maximal\") {\n        N = 2015;\n    }\n\n    // Output N\n    printf(\"%d\\n\", N);\n\n    if (type == \"random\") {\n        // Generate random districts for each hour\n        for(int i = 0; i < N; ++i) {\n            int Xi1 = rnd.next(1, 1000);\n            int Yi1 = rnd.next(1, 2);\n            int Xi2 = rnd.next(1, 1000);\n            int Yi2 = rnd.next(1, 2);\n            printf(\"%d %d %d %d\\n\", Xi1, Yi1, Xi2, Yi2);\n        }\n    } else if (type == \"minimal\") {\n        // Output minimal districts\n        printf(\"1 1 1 1\\n\");\n    } else if (type == \"maximal\") {\n        // Output maximal districts\n        for(int i = 0; i < N; ++i) {\n            printf(\"1000 2 1000 2\\n\");\n        }\n    } else if (type == \"same_districts\") {\n        // Investigate the same district in each hour\n        int Xi = rnd.next(1, 1000);\n        int Yi = rnd.next(1, 2);\n        for(int i = 0; i < N; ++i) {\n            printf(\"%d %d %d %d\\n\", Xi, Yi, Xi, Yi);\n        }\n    } else if (type == \"opposite_districts\") {\n        // Investigate opposite districts\n        for(int i = 0; i < N; ++i) {\n            printf(\"1 1 1000 2\\n\");\n        }\n    } else if (type == \"edge_case\") {\n        // Alternate between edge districts\n        for(int i = 0; i < N; ++i) {\n            int Xi1 = (i % 2 == 0) ? 1 : 1000;\n            int Yi1 = (i % 2 == 0) ? 1 : 2;\n            int Xi2 = (i % 2 == 0) ? 1000 : 1;\n            int Yi2 = (i % 2 == 0) ? 2 : 1;\n            printf(\"%d %d %d %d\\n\", Xi1, Yi1, Xi2, Yi2);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for(int i = 0; i < N; ++i) {\n            int Xi1 = rnd.next(1, 1000);\n            int Yi1 = rnd.next(1, 2);\n            int Xi2 = rnd.next(1, 1000);\n            int Yi2 = rnd.next(1, 2);\n            printf(\"%d %d %d %d\\n\", Xi1, Yi1, Xi2, Yi2);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 2015 -type random\n\n./gen -n 2015 -type maximal\n./gen -n 2015 -type same_districts\n./gen -n 2015 -type opposite_districts\n./gen -n 2015 -type edge_case\n\n./gen -n 1000 -type random\n./gen -n 1000 -type same_districts\n./gen -n 1000 -type opposite_districts\n./gen -n 1000 -type edge_case\n\n./gen -n 500 -type random\n./gen -n 500 -type same_districts\n./gen -n 500 -type opposite_districts\n./gen -n 500 -type edge_case\n\n./gen -n 100 -type random\n./gen -n 100 -type same_districts\n./gen -n 100 -type opposite_districts\n./gen -n 100 -type edge_case\n\n./gen -n 2015 -type random\n./gen -n 2000 -type random\n./gen -n 1500 -type random\n./gen -n 1000 -type random\n./gen -n 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:30.704429",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/E",
      "title": "E. Spectator Riots",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the number of fans on the field, N. The next N lines contain three integers: xi ,yi, vi. They are the x-coordinate, y-coordinate and speed of fan i at the beginning of the one second interval considered in the task.  3 ≤ N ≤ 105  0 ≤ xi, yi ≤ 105  0 ≤ vi ≤ 1000  All numbers are integers",
      "output_spec": "OutputYou need to output the three points that camera needs to select. Print them in three lines, with every line containing the x-coordinate, then y-coordinate, separated by a single space. The order of points does not matter.",
      "sample_tests": "ExamplesInputCopy31 1 11 1 11 2 1OutputCopy2 22 11 0",
      "description": "E. Spectator Riots\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains the number of fans on the field, N. The next N lines contain three integers: xi ,yi, vi. They are the x-coordinate, y-coordinate and speed of fan i at the beginning of the one second interval considered in the task.  3 ≤ N ≤ 105  0 ≤ xi, yi ≤ 105  0 ≤ vi ≤ 1000  All numbers are integers\n\nOutputYou need to output the three points that camera needs to select. Print them in three lines, with every line containing the x-coordinate, then y-coordinate, separated by a single space. The order of points does not matter.\n\nInputCopy31 1 11 1 11 2 1OutputCopy2 22 11 0\n\nInputCopy31 1 11 1 11 2 1\n\nOutputCopy2 22 11 0",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 100000, \"N\");\n    inf.readEoln();\n\n    vector<int> xs(N);\n    vector<int> ys(N);\n\n    for (int i = 0; i < N; ++i) {\n        xs[i] = inf.readInt(0, 100000);\n        inf.readSpace();\n        ys[i] = inf.readInt(0, 100000);\n        inf.readSpace();\n        int vi = inf.readInt(0, 1000);\n        inf.readEoln();\n    }\n\n    int a = 0, b = -1;\n    for (int i = 1; i < N; ++i) {\n        if (xs[i] != xs[a] || ys[i] != ys[a]) {\n            b = i;\n            break;\n        }\n    }\n    ensuref(b != -1, \"All points are the same point at (%d,%d)\", xs[a], ys[a]);\n\n    long long dx = xs[b] - xs[a];\n    long long dy = ys[b] - ys[a];\n\n    bool all_colinear = true;\n    for (int i = 0; i < N; ++i) {\n        if (i == a || i == b) continue;\n        long long xi_diff = xs[i] - xs[a];\n        long long yi_diff = ys[i] - ys[a];\n        if (dx * yi_diff != dy * xi_diff) {\n            all_colinear = false;\n            break;\n        }\n    }\n    ensuref(!all_colinear, \"All points are colinear\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 100000, \"N\");\n    inf.readEoln();\n\n    vector<int> xs(N);\n    vector<int> ys(N);\n\n    for (int i = 0; i < N; ++i) {\n        xs[i] = inf.readInt(0, 100000);\n        inf.readSpace();\n        ys[i] = inf.readInt(0, 100000);\n        inf.readSpace();\n        int vi = inf.readInt(0, 1000);\n        inf.readEoln();\n    }\n\n    int a = 0, b = -1;\n    for (int i = 1; i < N; ++i) {\n        if (xs[i] != xs[a] || ys[i] != ys[a]) {\n            b = i;\n            break;\n        }\n    }\n    ensuref(b != -1, \"All points are the same point at (%d,%d)\", xs[a], ys[a]);\n\n    long long dx = xs[b] - xs[a];\n    long long dy = ys[b] - ys[a];\n\n    bool all_colinear = true;\n    for (int i = 0; i < N; ++i) {\n        if (i == a || i == b) continue;\n        long long xi_diff = xs[i] - xs[a];\n        long long yi_diff = ys[i] - ys[a];\n        if (dx * yi_diff != dy * xi_diff) {\n            all_colinear = false;\n            break;\n        }\n    }\n    ensuref(!all_colinear, \"All points are colinear\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 100000, \"N\");\n    inf.readEoln();\n\n    vector<int> xs(N);\n    vector<int> ys(N);\n\n    for (int i = 0; i < N; ++i) {\n        xs[i] = inf.readInt(0, 100000);\n        inf.readSpace();\n        ys[i] = inf.readInt(0, 100000);\n        inf.readSpace();\n        int vi = inf.readInt(0, 1000);\n        inf.readEoln();\n    }\n\n    int a = 0, b = -1;\n    for (int i = 1; i < N; ++i) {\n        if (xs[i] != xs[a] || ys[i] != ys[a]) {\n            b = i;\n            break;\n        }\n    }\n    ensuref(b != -1, \"All points are the same point at (%d,%d)\", xs[a], ys[a]);\n\n    long long dx = xs[b] - xs[a];\n    long long dy = ys[b] - ys[a];\n\n    bool all_colinear = true;\n    for (int i = 0; i < N; ++i) {\n        if (i == a || i == b) continue;\n        long long xi_diff = xs[i] - xs[a];\n        long long yi_diff = ys[i] - ys[a];\n        if (dx * yi_diff != dy * xi_diff) {\n            all_colinear = false;\n            break;\n        }\n    }\n    ensuref(!all_colinear, \"All points are colinear\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1E-8;\nconst int MAX_COORD = 100000;\n\nstruct Fan {\n    int x, y, v;\n};\n\nint N;\nvector<Fan> fans;\n\nbool isReachable(int x, int y) {\n    if (x < 0 || x > MAX_COORD || y < 0 || y > MAX_COORD)\n        return false;\n    for (const Fan& fan : fans) {\n        int dx = abs(x - fan.x);\n        int dy = abs(y - fan.y);\n        if (dx + dy <= fan.v)\n            return true;\n    }\n    return false;\n}\n\nbool areColinear(int x1, int y1, int x2, int y2, int x3, int y3) {\n    // Compute the area of the triangle formed by the three points\n    // If area is zero, points are colinear\n    int area2 = (x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2));\n    return area2 == 0;\n}\n\ndouble computeRadius(int x1, int y1, int x2, int y2, int x3, int y3) {\n    double a = hypot(x1 - x2, y1 - y2);\n    double b = hypot(x2 - x3, y2 - y3);\n    double c = hypot(x3 - x1, y3 - y1);\n    double s = (a + b + c) / 2.0;\n    double area = sqrt(max(0.0, s * (s - a) * (s - b) * (s - c)));\n    if (area == 0.0)\n        return 1e20; // Points are colinear, radius is infinite\n    double radius = (a * b * c) / (4.0 * area);\n    return radius;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    N = inf.readInt(3, 100000, \"N\");\n    fans.resize(N);\n    for (int i = 0; i < N; i++) {\n        fans[i].x = inf.readInt(0, MAX_COORD, format(\"x[%d]\", i + 1).c_str());\n        fans[i].y = inf.readInt(0, MAX_COORD, format(\"y[%d]\", i + 1).c_str());\n        fans[i].v = inf.readInt(0, 1000, format(\"v[%d]\", i + 1).c_str());\n    }\n\n    // Read jury's answer\n    int jx[3], jy[3];\n    for (int i = 0; i < 3; i++) {\n        jx[i] = ans.readInt(); // No need to validate further\n        jy[i] = ans.readInt();\n    }\n    double radius_jury = computeRadius(jx[0], jy[0], jx[1], jy[1], jx[2], jy[2]);\n\n    // Read participant's answer\n    int px[3], py[3];\n    for (int i = 0; i < 3; i++) {\n        px[i] = ouf.readInt(0, MAX_COORD, format(\"x[%d]\", i + 1).c_str());\n        py[i] = ouf.readInt(0, MAX_COORD, format(\"y[%d]\", i + 1).c_str());\n    }\n\n    // Check that all points are reachable by some fans\n    for (int i = 0; i < 3; i++) {\n        if (!isReachable(px[i], py[i])) {\n            quitf(_wa, \"Point (%d, %d) cannot be reached by any fan\", px[i], py[i]);\n        }\n    }\n\n    // Check that points are not colinear\n    if (areColinear(px[0], py[0], px[1], py[1], px[2], py[2])) {\n        quitf(_wa, \"Participant's points are colinear\");\n    }\n\n    double radius_participant = computeRadius(px[0], py[0], px[1], py[1], px[2], py[2]);\n\n    if (radius_jury - radius_participant <= 0.01 + EPS)\n        quitf(_ok, \"Participant's radius %.10f is within 0.01 of jury's radius %.10f\", radius_participant, radius_jury);\n    else\n        quitf(_wa, \"Participant's radius %.10f is smaller than jury's radius %.10f by more than 0.01\", radius_participant, radius_jury);\n}\n\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Random positions, random speeds\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"zero_speed\") {\n        // All fans have speed zero\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = 0;\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"max_speed\") {\n        // All fans have maximum speed\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = 1000;\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"clustered\") {\n        // All fans are clustered close together\n        int cx = rnd.next(0, 100000);\n        int cy = rnd.next(0, 100000);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(max(0, cx - 5), min(100000, cx + 5));\n            int y = rnd.next(max(0, cy - 5), min(100000, cy + 5));\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"line\") {\n        // All but one fan are along a line\n        int x0 = rnd.next(0, 100000);\n        int y0 = rnd.next(0, 100000);\n        int dx = rnd.next(1, 100000);\n        int dy = rnd.next(1, 100000);\n\n        for (int i = 0; i < n - 1; ++i) {\n            int x = (x0 + dx * i) % 100001;\n            int y = (y0 + dy * i) % 100001;\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n        // Add one fan not on the line\n        while (true) {\n            int x2 = rnd.next(0, 100000);\n            int y2 = rnd.next(0, 100000);\n            // Check that (x0, y0), (x1, y1), (x2, y2) are not colinear\n            int x1 = (x0 + dx) % 100001;\n            int y1 = (y0 + dy) % 100001;\n            long long area = (long long)(x0 - x2) * (y1 - y2) - (long long)(y0 - y2) * (x1 - x2);\n            if (area != 0) {\n                int v = rnd.next(0, 1000);\n                printf(\"%d %d %d\\n\", x2, y2, v);\n                break;\n            }\n        }\n    }\n    else if (type == \"near_edge\") {\n        // Fans near edges\n        for (int i = 0; i < n; ++i) {\n            int side = rnd.next(1,4);\n            int x, y;\n            if (side ==1) {\n                x = 0;\n                y = rnd.next(0, 100000);\n            } else if (side ==2) {\n                x = 100000;\n                y = rnd.next(0, 100000);\n            } else if (side ==3) {\n                x = rnd.next(0, 100000);\n                y = 0;\n            } else {\n                x = rnd.next(0, 100000);\n                y = 100000;\n            }\n            int v = rnd.next(0,1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"duplicate_positions\") {\n        // All but one fan at the same position\n        int x = rnd.next(0, 100000);\n        int y = rnd.next(0, 100000);\n        for (int i = 0; i < n -1; ++i) {\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n        // Add one fan elsewhere\n        int x2 = x;\n        int y2 = y;\n        while(x2 == x && y2 == y){\n            x2 = rnd.next(0, 100000);\n            y2 = rnd.next(0, 100000);\n        }\n        int v = rnd.next(0, 1000);\n        printf(\"%d %d %d\\n\", x2, y2, v);\n    }\n    else if (type == \"corner_case\") {\n        // Fans in corners\n        vector<pair<int,int>> corners = { {0,0}, {0,100000}, {100000,0}, {100000,100000} };\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(0, 3);\n            int x = corners[choice].first;\n            int y = corners[choice].second;\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"max_radius\") {\n        // Generate fans to maximize the radius\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = 1000;\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Random positions, random speeds\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"zero_speed\") {\n        // All fans have speed zero\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = 0;\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"max_speed\") {\n        // All fans have maximum speed\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = 1000;\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"clustered\") {\n        // All fans are clustered close together\n        int cx = rnd.next(0, 100000);\n        int cy = rnd.next(0, 100000);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(max(0, cx - 5), min(100000, cx + 5));\n            int y = rnd.next(max(0, cy - 5), min(100000, cy + 5));\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"line\") {\n        // All but one fan are along a line\n        int x0 = rnd.next(0, 100000);\n        int y0 = rnd.next(0, 100000);\n        int dx = rnd.next(1, 100000);\n        int dy = rnd.next(1, 100000);\n\n        for (int i = 0; i < n - 1; ++i) {\n            int x = (x0 + dx * i) % 100001;\n            int y = (y0 + dy * i) % 100001;\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n        // Add one fan not on the line\n        while (true) {\n            int x2 = rnd.next(0, 100000);\n            int y2 = rnd.next(0, 100000);\n            // Check that (x0, y0), (x1, y1), (x2, y2) are not colinear\n            int x1 = (x0 + dx) % 100001;\n            int y1 = (y0 + dy) % 100001;\n            long long area = (long long)(x0 - x2) * (y1 - y2) - (long long)(y0 - y2) * (x1 - x2);\n            if (area != 0) {\n                int v = rnd.next(0, 1000);\n                printf(\"%d %d %d\\n\", x2, y2, v);\n                break;\n            }\n        }\n    }\n    else if (type == \"near_edge\") {\n        // Fans near edges\n        for (int i = 0; i < n; ++i) {\n            int side = rnd.next(1,4);\n            int x, y;\n            if (side ==1) {\n                x = 0;\n                y = rnd.next(0, 100000);\n            } else if (side ==2) {\n                x = 100000;\n                y = rnd.next(0, 100000);\n            } else if (side ==3) {\n                x = rnd.next(0, 100000);\n                y = 0;\n            } else {\n                x = rnd.next(0, 100000);\n                y = 100000;\n            }\n            int v = rnd.next(0,1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"duplicate_positions\") {\n        // All but one fan at the same position\n        int x = rnd.next(0, 100000);\n        int y = rnd.next(0, 100000);\n        for (int i = 0; i < n -1; ++i) {\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n        // Add one fan elsewhere\n        int x2 = x;\n        int y2 = y;\n        while(x2 == x && y2 == y){\n            x2 = rnd.next(0, 100000);\n            y2 = rnd.next(0, 100000);\n        }\n        int v = rnd.next(0, 1000);\n        printf(\"%d %d %d\\n\", x2, y2, v);\n    }\n    else if (type == \"corner_case\") {\n        // Fans in corners\n        vector<pair<int,int>> corners = { {0,0}, {0,100000}, {100000,0}, {100000,100000} };\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(0, 3);\n            int x = corners[choice].first;\n            int y = corners[choice].second;\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else if (type == \"max_radius\") {\n        // Generate fans to maximize the radius\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = 1000;\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            int v = rnd.next(0, 1000);\n            printf(\"%d %d %d\\n\", x, y, v);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n\n./gen -n 10 -type random\n./gen -n 10 -type zero_speed\n./gen -n 10 -type max_speed\n./gen -n 10 -type clustered\n./gen -n 10 -type line\n./gen -n 10 -type near_edge\n./gen -n 10 -type duplicate_positions\n./gen -n 10 -type corner_case\n./gen -n 10 -type max_radius\n\n./gen -n 1000 -type random\n./gen -n 1000 -type zero_speed\n./gen -n 1000 -type max_speed\n./gen -n 1000 -type clustered\n./gen -n 1000 -type line\n./gen -n 1000 -type near_edge\n./gen -n 1000 -type duplicate_positions\n./gen -n 1000 -type corner_case\n./gen -n 1000 -type max_radius\n\n./gen -n 100000 -type random\n./gen -n 100000 -type zero_speed\n./gen -n 100000 -type max_speed\n./gen -n 100000 -type clustered\n./gen -n 100000 -type line\n./gen -n 100000 -type near_edge\n./gen -n 100000 -type duplicate_positions\n./gen -n 100000 -type corner_case\n./gen -n 100000 -type max_radius\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:32.739514",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/F",
      "title": "F. Bulbo",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number of turns n and initial position x. Next n lines contain two numbers lstart and lend, which represent that all bulbs from interval [lstart, lend] are shining this turn.  1 ≤ n ≤ 5000  1 ≤ x ≤ 109  1 ≤ lstart ≤ lend ≤ 109",
      "output_spec": "OutputOutput should contain a single number which represents the best result (minimum cost) that could be obtained by playing this Bulbo game.",
      "sample_tests": "ExamplesInputCopy5 42 79 168 109 171 6OutputCopy8",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains number of turns n and initial position x. Next n lines contain two numbers lstart and lend, which represent that all bulbs from interval [lstart, lend] are shining this turn.  1 ≤ n ≤ 5000  1 ≤ x ≤ 109  1 ≤ lstart ≤ lend ≤ 109\n\nOutputOutput should contain a single number which represents the best result (minimum cost) that could be obtained by playing this Bulbo game.\n\nInputCopy5 42 79 168 109 171 6OutputCopy8\n\nInputCopy5 42 79 168 109 171 6\n\nOutputCopy8\n\nNoteBefore 1. turn move to position 5Before 2. turn move to position 9Before 5. turn move to position 8",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int lstart = inf.readInt(1, 1000000000, \"lstart\");\n        inf.readSpace();\n        int lend = inf.readInt(lstart, 1000000000, \"lend\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int lstart = inf.readInt(1, 1000000000, \"lstart\");\n        inf.readSpace();\n        int lend = inf.readInt(lstart, 1000000000, \"lend\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int lstart = inf.readInt(1, 1000000000, \"lstart\");\n        inf.readSpace();\n        int lend = inf.readInt(lstart, 1000000000, \"lend\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\");\n\n    // Generate lstart and lend arrays based on type\n    vector<int> lstart(n), lend(n);\n\n    if (type == \"random\") {\n        // Generate random intervals\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = rnd.next(1, (int)1e9);\n            lend[i] = rnd.next(lstart[i], (int)1e9);\n        }\n    } else if (type == \"same_interval\") {\n        // All intervals are the same\n        int l = rnd.next(1, (int)1e9);\n        int r = rnd.next(l, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = l;\n            lend[i] = r;\n        }\n    } else if (type == \"no_overlap\") {\n        // Intervals do not overlap\n        int curr = 1;\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = curr;\n            int maxEnd = min(curr + 10000, (int)1e9);\n            lend[i] = rnd.next(curr, maxEnd);\n            curr = lend[i] + 1;\n            if (curr > (int)1e9) {\n                curr = (int)1e9;\n            }\n        }\n    } else if (type == \"max_intervals\") {\n        // Intervals cover the entire [1, 1e9] range\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = 1;\n            lend[i] = (int)1e9;\n        }\n    } else if (type == \"min_intervals\") {\n        // Intervals are minimal, lstart == lend\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = rnd.next(1, (int)1e9);\n            lend[i] = lstart[i];\n        }\n    } else if (type == \"increasing_intervals\") {\n        // Intervals increase over time\n        int currL = 1;\n        int maxIncrement = 1e7;\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = currL;\n            lend[i] = currL + rnd.next(0, maxIncrement);\n            if (lend[i] > (int)1e9) lend[i] = (int)1e9;\n            currL = lend[i] + 1;\n            if (currL > (int)1e9) currL = (int)1e9;\n        }\n    } else if (type == \"decreasing_intervals\") {\n        // Intervals decrease over time\n        int currL = (int)1e9;\n        int maxDecrement = 1e7;\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(0, maxDecrement);\n            lend[i] = currL;\n            lstart[i] = currL - len;\n            if (lstart[i] < 1) lstart[i] = 1;\n            currL = lstart[i] - 1;\n            if (currL < 1) currL = 1;\n        }\n    } else if (type == \"overlapping_intervals\") {\n        // Intervals that overlap a lot\n        int mid = rnd.next(1, (int)1e9);\n        int maxSpread = (int)1e6;\n        for (int i = 0; i < n; ++i) {\n            int left = mid - rnd.next(0, maxSpread);\n            if (left < 1) left = 1;\n            int right = mid + rnd.next(0, maxSpread);\n            if (right > (int)1e9) right = (int)1e9;\n            lstart[i] = left;\n            lend[i] = right;\n        }\n    } else {\n        // Default to random intervals\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = rnd.next(1, (int)1e9);\n            lend[i] = rnd.next(lstart[i], (int)1e9);\n        }\n    }\n    // Print n and x\n    printf(\"%d %d\\n\", n, x);\n    // Print the intervals\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", lstart[i], lend[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\");\n\n    // Generate lstart and lend arrays based on type\n    vector<int> lstart(n), lend(n);\n\n    if (type == \"random\") {\n        // Generate random intervals\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = rnd.next(1, (int)1e9);\n            lend[i] = rnd.next(lstart[i], (int)1e9);\n        }\n    } else if (type == \"same_interval\") {\n        // All intervals are the same\n        int l = rnd.next(1, (int)1e9);\n        int r = rnd.next(l, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = l;\n            lend[i] = r;\n        }\n    } else if (type == \"no_overlap\") {\n        // Intervals do not overlap\n        int curr = 1;\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = curr;\n            int maxEnd = min(curr + 10000, (int)1e9);\n            lend[i] = rnd.next(curr, maxEnd);\n            curr = lend[i] + 1;\n            if (curr > (int)1e9) {\n                curr = (int)1e9;\n            }\n        }\n    } else if (type == \"max_intervals\") {\n        // Intervals cover the entire [1, 1e9] range\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = 1;\n            lend[i] = (int)1e9;\n        }\n    } else if (type == \"min_intervals\") {\n        // Intervals are minimal, lstart == lend\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = rnd.next(1, (int)1e9);\n            lend[i] = lstart[i];\n        }\n    } else if (type == \"increasing_intervals\") {\n        // Intervals increase over time\n        int currL = 1;\n        int maxIncrement = 1e7;\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = currL;\n            lend[i] = currL + rnd.next(0, maxIncrement);\n            if (lend[i] > (int)1e9) lend[i] = (int)1e9;\n            currL = lend[i] + 1;\n            if (currL > (int)1e9) currL = (int)1e9;\n        }\n    } else if (type == \"decreasing_intervals\") {\n        // Intervals decrease over time\n        int currL = (int)1e9;\n        int maxDecrement = 1e7;\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(0, maxDecrement);\n            lend[i] = currL;\n            lstart[i] = currL - len;\n            if (lstart[i] < 1) lstart[i] = 1;\n            currL = lstart[i] - 1;\n            if (currL < 1) currL = 1;\n        }\n    } else if (type == \"overlapping_intervals\") {\n        // Intervals that overlap a lot\n        int mid = rnd.next(1, (int)1e9);\n        int maxSpread = (int)1e6;\n        for (int i = 0; i < n; ++i) {\n            int left = mid - rnd.next(0, maxSpread);\n            if (left < 1) left = 1;\n            int right = mid + rnd.next(0, maxSpread);\n            if (right > (int)1e9) right = (int)1e9;\n            lstart[i] = left;\n            lend[i] = right;\n        }\n    } else {\n        // Default to random intervals\n        for (int i = 0; i < n; ++i) {\n            lstart[i] = rnd.next(1, (int)1e9);\n            lend[i] = rnd.next(lstart[i], (int)1e9);\n        }\n    }\n    // Print n and x\n    printf(\"%d %d\\n\", n, x);\n    // Print the intervals\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", lstart[i], lend[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, min intervals\n./gen -n 1 -x 1 -type min_intervals\n./gen -n 1 -x 1000000000 -type min_intervals\n\n# Small n, same intervals\n./gen -n 5 -x 500000000 -type same_interval\n./gen -n 5 -x 500000000 -type max_intervals\n\n# Random intervals, small n\n./gen -n 10 -x 1000 -type random\n./gen -n 10 -x 1000 -type no_overlap\n\n# Min intervals, medium n\n./gen -n 100 -x 1000000000 -type min_intervals\n./gen -n 100 -x 1 -type min_intervals\n\n# Increasing and decreasing intervals, medium n\n./gen -n 500 -x 500000000 -type increasing_intervals\n./gen -n 500 -x 500000000 -type decreasing_intervals\n\n# Random intervals, large n\n./gen -n 1000 -x 1000000 -type random\n\n# Max intervals, largest n\n./gen -n 5000 -x 1 -type max_intervals\n./gen -n 5000 -x 1000000000 -type max_intervals\n\n# No overlap intervals, largest n\n./gen -n 5000 -x 1000000000 -type no_overlap\n./gen -n 5000 -x 1 -type no_overlap\n\n# Increasing intervals, largest n\n./gen -n 5000 -x 500000000 -type increasing_intervals\n\n# Decreasing intervals, largest n\n./gen -n 5000 -x 500000000 -type decreasing_intervals\n\n# Overlapping intervals\n./gen -n 5000 -x 500000000 -type overlapping_intervals\n\n# Same intervals, largest n\n./gen -n 5000 -x 500000000 -type same_interval\n\n# Random intervals, varying x\n./gen -n 5000 -x 123456789 -type random\n./gen -n 5000 -x 987654321 -type random\n\n# Min intervals, largest n\n./gen -n 5000 -x 500000000 -type min_intervals\n\n# Edge case: x outside all intervals\n./gen -n 5000 -x 1 -type no_overlap\n\n# Edge case: x inside all intervals\n./gen -n 5000 -x 1000000000 -type decreasing_intervals\n\n# Small n random\n./gen -n 2 -x 100 -type random\n./gen -n 3 -x 999999999 -type min_intervals\n\n# Max x, min intervals\n./gen -n 5000 -x 1000000000 -type min_intervals\n\n# Max x, random intervals\n./gen -n 5000 -x 1000000000 -type random\n\n# All intervals at the same position\n./gen -n 5000 -x 1000000000 -type same_interval\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:34.703696",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/G",
      "title": "G.  Пивной путь",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входа содержится целое число N — количество городов в Пиволенде и целое число M — количество дорог в этой стране. Города пронумерованы от 0 до N - 1, где город 0— это Пивград, а город N - 1— это Пивбург. Каждая из следующих M строк содержит три целы числа, a, b (a ≠ b) и len. Эти числа обозначают, что есть двунаправленная дорога между городами a и b длины len.   2 ≤ N ≤ 105  1 ≤ M ≤ 105  0 ≤ len ≤ 9  Между двумя городами не более одной дороги",
      "output_spec": "Выходные данныеВ первой строке должно быть записано наименьшее время, необходимое на то, чтобы перейти из Пивграда в Пивбург.Во второй строке дожны быть записаны номера городов по дороге из Пивграда в Пивбург, занимающей наименьшее время. В третьей строке выхода должны быть записаны номера городов на этом маршруте в порядке посещения, разделенные пробелами.",
      "sample_tests": "ПримерыВходные данныеСкопировать8 100 1 11 2 52 7 60 3 23 7 30 4 04 5 05 7 20 6 06 7 7Выходные данныеСкопировать3230 3 7",
      "description": "G.  Пивной путь\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входа содержится целое число N — количество городов в Пиволенде и целое число M — количество дорог в этой стране. Города пронумерованы от 0 до N - 1, где город 0— это Пивград, а город N - 1— это Пивбург. Каждая из следующих M строк содержит три целы числа, a, b (a ≠ b) и len. Эти числа обозначают, что есть двунаправленная дорога между городами a и b длины len.   2 ≤ N ≤ 105  1 ≤ M ≤ 105  0 ≤ len ≤ 9  Между двумя городами не более одной дороги\n\nВходные данные\n\nВыходные данныеВ первой строке должно быть записано наименьшее время, необходимое на то, чтобы перейти из Пивграда в Пивбург.Во второй строке дожны быть записаны номера городов по дороге из Пивграда в Пивбург, занимающей наименьшее время. В третьей строке выхода должны быть записаны номера городов на этом маршруте в порядке посещения, разделенные пробелами.\n\nВыходные данные\n\nВходные данныеСкопировать8 100 1 11 2 52 7 60 3 23 7 30 4 04 5 05 7 20 6 06 7 7Выходные данныеСкопировать3230 3 7\n\nВходные данныеСкопировать8 100 1 11 2 52 7 60 3 23 7 30 4 04 5 05 7 20 6 06 7 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3230 3 7\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int N_MIN = 2;\n    const int N_MAX = 100000;\n    const int M_MIN = 1;\n    const int M_MAX = 100000;\n\n    int N = inf.readInt(N_MIN, N_MAX, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(M_MIN, M_MAX, \"M\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(N);\n    set<pair<int,int>> edge_set;\n\n    for (int i = 0; i < M; ++i) {\n        int a = inf.readInt(0, N-1, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(0, N-1, \"b\");\n        ensuref(a != b, \"Edge must connect two different nodes, but a == b == %d\", a);\n        inf.readSpace();\n        int len = inf.readInt(0, 9, \"len\");\n        inf.readEoln();\n\n        int u = min(a,b);\n        int v = max(a,b);\n        pair<int,int> edge = make_pair(u,v);\n        ensuref(!edge_set.count(edge), \"There is more than one road between cities %d and %d\", u, v);\n        edge_set.insert(edge);\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> visited(N, false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    ensuref(visited[N-1], \"City %d is not reachable from city 0\", N-1);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int N_MIN = 2;\n    const int N_MAX = 100000;\n    const int M_MIN = 1;\n    const int M_MAX = 100000;\n\n    int N = inf.readInt(N_MIN, N_MAX, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(M_MIN, M_MAX, \"M\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(N);\n    set<pair<int,int>> edge_set;\n\n    for (int i = 0; i < M; ++i) {\n        int a = inf.readInt(0, N-1, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(0, N-1, \"b\");\n        ensuref(a != b, \"Edge must connect two different nodes, but a == b == %d\", a);\n        inf.readSpace();\n        int len = inf.readInt(0, 9, \"len\");\n        inf.readEoln();\n\n        int u = min(a,b);\n        int v = max(a,b);\n        pair<int,int> edge = make_pair(u,v);\n        ensuref(!edge_set.count(edge), \"There is more than one road between cities %d and %d\", u, v);\n        edge_set.insert(edge);\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> visited(N, false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    ensuref(visited[N-1], \"City %d is not reachable from city 0\", N-1);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int N_MIN = 2;\n    const int N_MAX = 100000;\n    const int M_MIN = 1;\n    const int M_MAX = 100000;\n\n    int N = inf.readInt(N_MIN, N_MAX, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(M_MIN, M_MAX, \"M\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(N);\n    set<pair<int,int>> edge_set;\n\n    for (int i = 0; i < M; ++i) {\n        int a = inf.readInt(0, N-1, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(0, N-1, \"b\");\n        ensuref(a != b, \"Edge must connect two different nodes, but a == b == %d\", a);\n        inf.readSpace();\n        int len = inf.readInt(0, 9, \"len\");\n        inf.readEoln();\n\n        int u = min(a,b);\n        int v = max(a,b);\n        pair<int,int> edge = make_pair(u,v);\n        ensuref(!edge_set.count(edge), \"There is more than one road between cities %d and %d\", u, v);\n        edge_set.insert(edge);\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> visited(N, false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    ensuref(visited[N-1], \"City %d is not reachable from city 0\", N-1);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const string FAIL_BETTER = \n    \"Participant's solution has strictly better time or strictly fewer edges than jury's; \"\n    \"this should not happen if the jury solution is truly optimal.\";\nstatic const string FAIL_WORSE =\n    \"Participant's solution has strictly worse time or strictly more edges than an optimal solution.\";\n\n// We'll store the roads in an adjacency list for quick validation.\nstruct Edge {\n    int to;\n    int length;\n};\n\nint N, M;\nvector<vector<Edge>> adj; // adjacency list\n\n// Compare two big non-negative integers (given as decimal strings)\n// Return -1 if a < b, 0 if a == b, +1 if a > b\nint compareBig(const string &a, const string &b) {\n    if (a.size() < b.size()) return -1;\n    if (a.size() > b.size()) return 1;\n    return a.compare(b);\n}\n\n// Multiply a big decimal string by 10 (equivalent to appending '0')\nstring multiplyBy10(const string &s) {\n    // Special case: if s == \"0\", remain \"0\".\n    // Otherwise, just append '0'.\n    if (s == \"0\") return \"0\";\n    return s + \"0\";\n}\n\n// Add a small digit (0..9) to a big decimal string in place.\nvoid addDigit(string &s, int digit) {\n    // s is in normal order (e.g. \"123\"). We add 'digit' as an integer.\n    int carry = digit;\n    for (int i = s.size() - 1; i >= 0 && carry > 0; i--) {\n        int sum = (s[i] - '0') + carry;\n        s[i] = char((sum % 10) + '0');\n        carry = sum / 10;\n    }\n    while (carry > 0) {\n        s.insert(s.begin(), char((carry % 10) + '0'));\n        carry /= 10;\n    }\n    if (s == \"\") s = \"0\";\n}\n\n// This function reads and verifies one solution (either the jury's or the participant's).\n// It returns a tuple of (timeAsBigIntegerString, numberOfEdgesUsed).\n// If the path is invalid, it quits with _fail if called for the jury or _wa if called for the participant.\npair<string,int> readAns(InStream &stream, bool isJury) {\n    // 1) Read the minimal time\n    long long claimedT = stream.readLong(0, LLONG_MAX, \"claimed_time\");\n\n    // 2) Read the number of cities on the path\n    int k = stream.readInt(2, N, \"path_length\"); \n    // Must have at least 2 if we truly have a path from 0 to N-1.\n\n    // 3) Read the actual path\n    vector<int> path(k);\n    for (int i = 0; i < k; i++) {\n        path[i] = stream.readInt(0, N - 1, \n            format(\"path[%d]\", i).c_str());\n    }\n\n    // Basic checks: must start at 0 and end at N - 1\n    if (path[0] != 0) {\n        stream.quitf(isJury ? _fail : _wa, \n            \"Path does not start at city 0 (Beergrade).\");\n    }\n    if (path[k - 1] != N - 1) {\n        stream.quitf(isJury ? _fail : _wa, \n            \"Path does not end at city N-1 (Beerburg).\");\n    }\n\n    // Check validity of consecutive edges and gather their lengths:\n    vector<int> lengths;\n    for (int i = 0; i < k - 1; i++) {\n        int u = path[i];\n        int v = path[i + 1];\n\n        bool found = false;\n        int lengthUV = -1;\n        for (auto &ed : adj[u]) {\n            if (ed.to == v) {\n                found = true;\n                lengthUV = ed.length;\n                break;\n            }\n        }\n        if (!found) {\n            stream.quitf(isJury ? _fail : _wa, \n                \"No road between %d and %d.\", u, v);\n        }\n        lengths.push_back(lengthUV);\n    }\n\n    // Compute the actual time:\n    // T = sum_{i=0..(k-2)} lengths[i] * 10^i\n    // We'll build T as a big string by iterating from the last edge to the first.\n    // That way, the last edge is the highest power of 10, the first edge is the lowest power.\n    // i.e., T = length[k-2] * 10^(k-2) + ... + length[1] * 10^1 + length[0]*10^0\n    // We'll build from i = (k-2) down to 0, each step:\n    //    T = T * 10 + lengths[i].\n    string computedTime = \"0\";\n    for (int i = (k - 2); i >= 0; i--) {\n        computedTime = multiplyBy10(computedTime);\n        addDigit(computedTime, lengths[i]);\n    }\n\n    // Compare computedTime with claimedT:\n    ostringstream oss; \n    oss << claimedT;\n    string claimedStr = oss.str();\n\n    if (compareBig(computedTime, claimedStr) != 0) {\n        stream.quitf(isJury ? _fail : _wa,\n            \"Claimed time %s does not match computed time %s.\",\n            claimedStr.c_str(), computedTime.c_str());\n    }\n\n    int edgesUsed = k - 1;\n    return make_pair(computedTime, edgesUsed);\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    N = inf.readInt();\n    M = inf.readInt();\n    adj.assign(N, {});\n\n    // Read all roads\n    for (int i = 0; i < M; i++) {\n        int a = inf.readInt(0, N-1);\n        int b = inf.readInt(0, N-1);\n        int length = inf.readInt(0, 9);\n        // add bidirectional edges\n        adj[a].push_back({b, length});\n        adj[b].push_back({a, length});\n    }\n\n    // First, read jury's result\n    pair<string,int> juryAns = readAns(ans, /*isJury=*/true);\n    // Then read participant's result\n    pair<string,int> partAns = readAns(ouf, /*isJury=*/false);\n\n    // Compare times (big integers):\n    int cmp = compareBig(partAns.first, juryAns.first);\n    // If participant's time < jury's time => participant found a better solution => _fail\n    if (cmp < 0) {\n        quitf(_fail, \"%s\\nJury time = %s, participant time = %s.\",\n              FAIL_BETTER.c_str(), \n              juryAns.first.c_str(), partAns.first.c_str());\n    }\n    // If participant's time > jury's time => participant is worse => WA\n    if (cmp > 0) {\n        quitf(_wa, \"%s\\nJury time = %s, participant time = %s.\",\n              FAIL_WORSE.c_str(),\n              juryAns.first.c_str(), partAns.first.c_str());\n    }\n\n    // else times are equal, compare edges\n    if (partAns.second < juryAns.second) {\n        quitf(_fail, \n            \"%s\\nTimes are equal (%s), but participant used fewer edges (%d < %d).\",\n            FAIL_BETTER.c_str(),\n            juryAns.first.c_str(),\n            partAns.second, juryAns.second);\n    }\n    if (partAns.second > juryAns.second) {\n        quitf(_wa, \n            \"%s\\nTimes are equal (%s), but participant used more edges (%d > %d).\",\n            FAIL_WORSE.c_str(),\n            juryAns.first.c_str(),\n            partAns.second, juryAns.second);\n    }\n\n    // Otherwise edges are also the same => OK\n    quitf(_ok, \n          \"Times match at %s and edges match at %d. Accepted.\",\n          juryAns.first.c_str(), partAns.second);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\");\n    int M = opt<int>(\"m\", N - 1); // Default M is N - 1\n    string type = opt<string>(\"type\", \"random\");\n    int len_min = opt<int>(\"len_min\", 0);\n    int len_max = opt<int>(\"len_max\", 9);\n\n    // Ensure len_min and len_max are within [0, 9]\n    len_min = max(0, min(9, len_min));\n    len_max = max(0, min(9, len_max));\n    if(len_min > len_max) swap(len_min, len_max);\n\n    // Ensure M does not exceed the maximum possible number of edges\n    M = min(M, N * (N - 1) / 2);\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set; // To ensure no multiple edges\n\n    if (type == \"chain\") {\n        // Create a chain from city 0 to city N - 1\n        for (int i = 1; i < N; ++i) {\n            int u = i - 1;\n            int v = i;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (type == \"star\") {\n        // Create a star graph centered at city 0\n        for (int i = 1; i < N; ++i) {\n            int u = 0;\n            int v = i;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (type == \"random\") {\n        // Create a random connected graph (random tree + additional edges)\n        vector<int> parent(N);\n        parent[0] = -1;\n        for (int i = 1; i < N; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            int u = i;\n            int v = parent[i];\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n        while ((int)edges.size() < M) {\n            int u = rnd.next(0, N - 1);\n            int v = rnd.next(0, N - 1);\n            if (u == v) continue;\n            if (edge_set.count({u, v}) > 0) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (type == \"special\") {\n        // Create a special graph to trigger specific cases\n        // Two paths from 0 to N - 1 with the same minimal time but different number of cities\n        // Path A: 0 -> 1 -> N - 1\n        // Path B: 0 -> 2 -> 3 -> ... -> N - 2 -> N - 1\n        edges.push_back({0, 1}); edge_set.insert({0,1}); edge_set.insert({1,0});\n        edges.push_back({1, N - 1}); edge_set.insert({1,N - 1}); edge_set.insert({N - 1,1});\n        for(int i = 2; i < N - 1; ++i) {\n            edges.push_back({i, i + 1});\n            edge_set.insert({i,i + 1});\n            edge_set.insert({i + 1,i});\n        }\n        edges.push_back({0, 2}); edge_set.insert({0,2}); edge_set.insert({2,0});\n        edges.push_back({N - 2, N - 1}); edge_set.insert({N - 2,N - 1}); edge_set.insert({N - 1,N - 2});\n    } else {\n        // Default to random\n    }\n\n    // Assign random lengths to edges (len between len_min and len_max)\n    vector<int> lens(edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        lens[i] = rnd.next(len_min, len_max);\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", N, (int)edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int len = lens[i];\n        printf(\"%d %d %d\\n\", u, v, len);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\");\n    int M = opt<int>(\"m\", N - 1); // Default M is N - 1\n    string type = opt<string>(\"type\", \"random\");\n    int len_min = opt<int>(\"len_min\", 0);\n    int len_max = opt<int>(\"len_max\", 9);\n\n    // Ensure len_min and len_max are within [0, 9]\n    len_min = max(0, min(9, len_min));\n    len_max = max(0, min(9, len_max));\n    if(len_min > len_max) swap(len_min, len_max);\n\n    // Ensure M does not exceed the maximum possible number of edges\n    M = min(M, N * (N - 1) / 2);\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set; // To ensure no multiple edges\n\n    if (type == \"chain\") {\n        // Create a chain from city 0 to city N - 1\n        for (int i = 1; i < N; ++i) {\n            int u = i - 1;\n            int v = i;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (type == \"star\") {\n        // Create a star graph centered at city 0\n        for (int i = 1; i < N; ++i) {\n            int u = 0;\n            int v = i;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (type == \"random\") {\n        // Create a random connected graph (random tree + additional edges)\n        vector<int> parent(N);\n        parent[0] = -1;\n        for (int i = 1; i < N; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            int u = i;\n            int v = parent[i];\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n        while ((int)edges.size() < M) {\n            int u = rnd.next(0, N - 1);\n            int v = rnd.next(0, N - 1);\n            if (u == v) continue;\n            if (edge_set.count({u, v}) > 0) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (type == \"special\") {\n        // Create a special graph to trigger specific cases\n        // Two paths from 0 to N - 1 with the same minimal time but different number of cities\n        // Path A: 0 -> 1 -> N - 1\n        // Path B: 0 -> 2 -> 3 -> ... -> N - 2 -> N - 1\n        edges.push_back({0, 1}); edge_set.insert({0,1}); edge_set.insert({1,0});\n        edges.push_back({1, N - 1}); edge_set.insert({1,N - 1}); edge_set.insert({N - 1,1});\n        for(int i = 2; i < N - 1; ++i) {\n            edges.push_back({i, i + 1});\n            edge_set.insert({i,i + 1});\n            edge_set.insert({i + 1,i});\n        }\n        edges.push_back({0, 2}); edge_set.insert({0,2}); edge_set.insert({2,0});\n        edges.push_back({N - 2, N - 1}); edge_set.insert({N - 2,N - 1}); edge_set.insert({N - 1,N - 2});\n    } else {\n        // Default to random\n    }\n\n    // Assign random lengths to edges (len between len_min and len_max)\n    vector<int> lens(edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        lens[i] = rnd.next(len_min, len_max);\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", N, (int)edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int len = lens[i];\n        printf(\"%d %d %d\\n\", u, v, len);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small chain graph\n./gen -n 2 -type chain\n\n# Small star graph\n./gen -n 5 -type star\n\n# Small random graph\n./gen -n 5 -m 7 -type random\n\n# Special graph to check minimal steps\n./gen -n 6 -type special\n\n# Maximal chain graph\n./gen -n 100000 -type chain\n\n# Maximal star graph\n./gen -n 100000 -type star\n\n# Maximal random graph\n./gen -n 100000 -m 100000 -type random\n\n# Random graph with zero-length edges\n./gen -n 100000 -m 100000 -type random -len_min 0 -len_max 0\n\n# Random graph with maximum-length edges\n./gen -n 100000 -m 100000 -type random -len_min 9 -len_max 9\n\n# Random graph with random edge lengths between 0 and 9\n./gen -n 100000 -m 100000 -type random -len_min 0 -len_max 9\n\n# Special graph to test multiple paths with equal minimal time\n./gen -n 1000 -type special\n\n# Random graph with minimal N and M\n./gen -n 2 -m 1 -type random\n\n# Random graph with N=1000, M=5000\n./gen -n 1000 -m 5000 -type random\n\n# Random graph with N=10000, M=50000\n./gen -n 10000 -m 50000 -type random\n\n# Chain graph with maximum edge lengths\n./gen -n 1000 -type chain -len_min 9 -len_max 9\n\n# Chain graph with zero edge lengths\n./gen -n 1000 -type chain -len_min 0 -len_max 0\n\n# Star graph with edge lengths alternating between 0 and 9\n./gen -n 20 -type star -len_min 0 -len_max 9\n\n# Random graph with edges possibly having zero length\n./gen -n 5000 -m 10000 -type random -len_min 0 -len_max 5\n\n# Random graph with edges having maximum lengths\n./gen -n 5000 -m 10000 -type random -len_min 5 -len_max 9\n\n# Special graph with maximal N to test time limit\n./gen -n 100000 -type special\n\n# Random graph with N=50000, M=100000 to test time limit\n./gen -n 50000 -m 100000 -type random\n\n# Random graph with edges of length 1\n./gen -n 100000 -m 100000 -type random -len_min 1 -len_max 1\n\n# Random graph with uniform edge lengths\n./gen -n 100000 -m 100000 -type random -len_min 4 -len_max 4\n\n# Random graph with varying edge lengths\n./gen -n 80000 -m 150000 -type random -len_min 1 -len_max 8\n\n# Random graph with N=2, M=1\n./gen -n 2 -m 1 -type random -len_min 5 -len_max 5\n\n# Chain graph with N=10, varying edge lengths\n./gen -n 10 -type chain -len_min 0 -len_max 9\n\n# Star graph with N=10, random edge lengths\n./gen -n 10 -type star -len_min 0 -len_max 9\n\n# Random graph with N=100, M=500\n./gen -n 100 -m 500 -type random -len_min 0 -len_max 9\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:36.661253",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/H",
      "title": "H. Боты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой и единственной строке записано целое число N.  1 ≤ N ≤ 106",
      "output_spec": "Выходные данныеВывод должен содержать единственное целое число – количество возможных состояний по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать2Выходные данныеСкопировать19",
      "description": "ограничение по времени на тест1.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой и единственной строке записано целое число N.  1 ≤ N ≤ 106\n\nВходные данные\n\nВыходные данныеВывод должен содержать единственное целое число – количество возможных состояний по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать2Выходные данныеСкопировать19\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать19\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеНачало: Игра в состоянии A.   Ход 1: Любой бот может ходить (первый бот красный, а второй бот синий), так что есть два возможных состояния после первого хода – B и C.  Ход 2: В обоих состояниях, B и C, любой бот может снова сделать ход, так что список возможных состояний расширяется и включает в себя D, E, F и G.  Ход 3: Красный бот уже совершил N=2 движений в состоянии D, так что отсюда он больше не может делать ходов. Он может совершать ходы в состояниях E, F и G, так что состояния I, K и M добавляются в список. Аналогичным образом, синий бот не может совершать ходы в состоянии G, но может в D, E и F, так что добавляются состояния H, J и L.  Ход 4: Красный бот точка уже совершил N=2 шага в состояниях H, I и K, он может двигаться только в J, L и M, так что добавляются состояния P, R и S. Синий бот не может двигаться в состояниях J, L и M, а только в H, I и K, так что добавляются состояния N, O и Q. Всего образуется 19 различных состояний игры, необходимых в анализе алгоритма.",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"N\");\n\n    if (N < 1 || N > 1000000) {\n        cerr << \"Error: N must be between 1 and 1,000,000 inclusive.\" << endl;\n        return 1;\n    }\n\n    printf(\"%d\\n\", N);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"N\");\n\n    if (N < 1 || N > 1000000) {\n        cerr << \"Error: N must be between 1 and 1,000,000 inclusive.\" << endl;\n        return 1;\n    }\n\n    printf(\"%d\\n\", N);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum value of N\n./gen -N 1\n\n# Sample input value\n./gen -N 2\n\n# Small values of N\n./gen -N 3\n./gen -N 4\n./gen -N 5\n./gen -N 10\n./gen -N 20\n\n# Medium values of N\n./gen -N 50\n./gen -N 100\n./gen -N 500\n./gen -N 1000\n./gen -N 5000\n./gen -N 10000\n\n# Large values of N\n./gen -N 50000\n./gen -N 100000\n./gen -N 200000\n./gen -N 500000\n./gen -N 750000\n./gen -N 999999\n./gen -N 1000000\n\n# Special cases (powers of 2)\n./gen -N 64\n./gen -N 1024\n./gen -N 32768\n./gen -N 262144\n./gen -N 524288\n\n# Randomly chosen values within the limits\n./gen -N 123456\n./gen -N 654321\n./gen -N 111111\n./gen -N 222222\n./gen -N 333333\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:38.898373",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "575/I",
      "title": "I. Robots protection",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains integer N — width and height of the land, and integer Q — number of queries to handle.Next Q lines contain queries you need to process.Two types of queries:   1 dir x y len — add a robot to protect a triangle. Depending on the value of dir, the values of x, y and len represent a different triangle:   dir = 1: Triangle is defined by the points (x, y), (x + len, y), (x, y + len)  dir = 2: Triangle is defined by the points (x, y), (x + len, y), (x, y - len)  dir = 3: Triangle is defined by the points (x, y), (x - len, y), (x, y + len)  dir = 4: Triangle is defined by the points (x, y), (x - len, y), (x, y - len)   2 x y — output how many robots guard this point (robot guards a point if the point is inside or on the border of its triangle)   1 ≤ N ≤ 5000  1 ≤ Q ≤ 105  1 ≤ dir ≤ 4  All points of triangles are within range [1, N]  All numbers are positive integers",
      "output_spec": "OutputFor each second type query output how many robots guard this point. Each answer should be in a separate line.",
      "sample_tests": "ExamplesInputCopy17 101 1 3 2 41 3 10 3 71 2 6 8 21 3 9 4 22 4 41 4 15 10 62 7 72 9 42 12 22 13 8OutputCopy22201",
      "description": "I. Robots protection\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer N — width and height of the land, and integer Q — number of queries to handle.Next Q lines contain queries you need to process.Two types of queries:   1 dir x y len — add a robot to protect a triangle. Depending on the value of dir, the values of x, y and len represent a different triangle:   dir = 1: Triangle is defined by the points (x, y), (x + len, y), (x, y + len)  dir = 2: Triangle is defined by the points (x, y), (x + len, y), (x, y - len)  dir = 3: Triangle is defined by the points (x, y), (x - len, y), (x, y + len)  dir = 4: Triangle is defined by the points (x, y), (x - len, y), (x, y - len)   2 x y — output how many robots guard this point (robot guards a point if the point is inside or on the border of its triangle)   1 ≤ N ≤ 5000  1 ≤ Q ≤ 105  1 ≤ dir ≤ 4  All points of triangles are within range [1, N]  All numbers are positive integers\n\nOutputFor each second type query output how many robots guard this point. Each answer should be in a separate line.\n\nInputCopy17 101 1 3 2 41 3 10 3 71 2 6 8 21 3 9 4 22 4 41 4 15 10 62 7 72 9 42 12 22 13 8OutputCopy22201\n\nInputCopy17 101 1 3 2 41 3 10 3 71 2 6 8 21 3 9 4 22 4 41 4 15 10 62 7 72 9 42 12 22 13 8\n\nOutputCopy22201",
      "solutions": [
        {
          "title": "Bubble Cup 8 — Finals - Codeforces",
          "content": "Hello Codeforces,In less than a two weeks, finals of 8th edition of Bubble Cup will be held in Belgrade, organized by Microsoft Development Center Serbia.Unfortunately, there wont be Bubble Run contest this year (which was held last two years for university students in the same tame as BCup, and it was a 24h marathon style contest), but only ACM-style 5 hour long contest for both university and high school teams in the same category. You can read more about contest on the official website, and read tasks and solutions from past years in the booklets. (There are some very interesting tasks, especially from Run contests, so I encourge you all to take a look at them).Usually, the contest was interesting only to teams from Serbia and it's region, but every year we can see more and more teams from other countries participating in qualifications, and now there will be teams from 7 different countries from Eastern Europe participating in the finals, which is the most I think. Certanly, it will be the toughest Bubble Cup ever, and that's the reason why I'm listing teams here. I hope there will be even more strong teams from other countries next year!The new cool thing this year will be a BC conference where we will hear talks about competitive programming and maybe something more, from Psyho (Psyho), misof and MikeMirzayanov! (I can't wait for this! :D). Also, there will be a big party after the contest as MDCS celebrates 10 years anniversary.For teams and guests who will come to the finals: Hope you will enjoy Belgrade and Serbia, and if you want to go to some fun places here, hang out, or maybe even spend few more days in this beautiful city, I'll be glad to help you :) If you have any questions, just post it in the comments, or send me a message. See you soon!Teams (sorted by bonus penalty time): Team name University Members Penalty Wroclaw Cheetahs University of Wrocław kostka, Solaris, bardek -72 3/4 IOI Polish Team High school znirzej, yarek, przemekkoz -64 unusual University of Latvia nvilcins, KarlisS, gen -64 Програмерски Моћан Факултет у Нишу University of Niš ivan100sic, lazar06, k0cc4 -56 Me[N]talci Corp. High school zDule98, MeinKraft, randomusername -49 Air Penguins Belarusian State University CherryTree, shef_2318, IFLED -49 Booleans High school VladaMG98, FilipVesovic, iprove -49 rozochocone szczerzożerzączki High school Radewoosh, Myez, oroko -42 XYZ University of Zagreb mislav_bradac, Dgleich, mgradicek -42 Nulla dies sine AC High school Mihaell, tonkosi, bfilipovic -42 Papirnate maramice High school isego, lbarisic, kstef -42 Mastovito ime High school DBradac, nherceg, stjepanp -42 Bubblecup Cunningsnatch University of Zagreb Nino, ipaljak, Martin -42 Team2015 University of Novi Sad Srki, luxa, stanoje -42 LNU Penguins Lviv National University RomaWhite, witua, Andrew_Makar -36 RAF RAF GSM Union university pimpke, DuX, FreezingCool -36 Lazo i prijatelji High school abeker, IvL, dpaleka -36 Frozen Heart SPb AU Tehnar, ComradePetr, Nikitosh -36 Spacemen Union University TajniAgent, Ivan95, xgrizx1 -36 Is there anybunny there? High school dd__, NNSpasic, Stefan -36 Gimnazija Sombor High school akatsuki555, digaa, micamat -25 UPD: Unfortunately, the only team from Bulgaria \"...\" (ha1vanka, Enchom, vanessa) can't come to finals, but they will be replaced by the next best scored team from qualifications — Frozen Heart, which will be the first team from Russia on BC :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/19957",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3435
        },
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces",
          "content": "In the very beginning of this post I would like to thank everyone who contributed to make this contest happen — both onsite and online versions. For many of us it was practically the first contest we really took part in preparing of — we all loved working on it and hope you liked it too.I would also like to mention that 2864 teams (about 4k people!) registered to this contest, 1025 actually took part in it, 637 managed to solve at least one problem and there were 4 teams that solved all the problems before contest ended. Congratulations to everybody! Ok, so here is top 10 of Codeforces version of Bubble cup: 1tourist 2Nizhny Novgorod SU: mike_live, vepifanov 3SPb ITMO University 1: antonkov, enot110, subscriber 4Dreadnought: TankEngineer, rowdark, BaconLi 5nedrharmsw: AntiForest, rnsiehemt, JoeyWheeler 6Orz!: zcz, KFDong, ExfJoe 7-XraY- 8Saratov SU Daemons: danilka.pro, Edvard, kuviman 9Omogen Heap: Gullesnuffs, simonlindholm 10Bsuir_power: andrew.volchek, teleport All of them will get T-shirst. But apart from them, as we promised, there will be 10 T-shirts more sent to randomly chosen teams, here they are: 22 HellKitsune 40 tmt514 77 Saratov SU 3: Perforator, Oleg_Smirnov, Roms 82 Greed_for_Speed: m17, aditya_kakarot, shiva_r31 89 LNU_Hallo_World: felix, Trumen For those who are interested here is a link to results of onsite competition.Since editorial is pretty big I think it is more reasonable to share link to file here than posting it all here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20176",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1472
        }
      ],
      "code_examples": [
        {
          "title": "Bubble Cup finals 2015 Results and Editorial - Codeforces - Code 1",
          "code": "PD(3) = 2 * C(3,3) = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20176",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 5000, \"N\");\n    inf.readSpace();\n    int Q = inf.readInt(1, 100000, \"Q\");\n    inf.readEoln();\n\n    for (int i = 0; i < Q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int dir = inf.readInt(1, 4, \"dir\");\n            inf.readSpace();\n            int x = inf.readInt(1, N, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, N, \"y\");\n            inf.readSpace();\n            int len = inf.readInt(1, N, \"len\");\n            inf.readEoln();\n\n            int len_max = 0;\n            if (dir == 1) {\n                len_max = min(N - x, N - y);\n            } else if (dir == 2) {\n                len_max = min(N - x, y - 1);\n            } else if (dir == 3) {\n                len_max = min(x - 1, N - y);\n            } else if (dir == 4) {\n                len_max = min(x - 1, y - 1);\n            }\n            ensuref(len_max >= 1, \"Invalid triangle at query %d: len_max < 1\", i + 1);\n            ensuref(len >= 1 && len <= len_max, \"Invalid len at query %d: len = %d, len_max = %d\", i + 1, len, len_max);\n\n        } else if (t == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, N, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, N, \"y\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 5000, \"N\");\n    inf.readSpace();\n    int Q = inf.readInt(1, 100000, \"Q\");\n    inf.readEoln();\n\n    for (int i = 0; i < Q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int dir = inf.readInt(1, 4, \"dir\");\n            inf.readSpace();\n            int x = inf.readInt(1, N, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, N, \"y\");\n            inf.readSpace();\n            int len = inf.readInt(1, N, \"len\");\n            inf.readEoln();\n\n            int len_max = 0;\n            if (dir == 1) {\n                len_max = min(N - x, N - y);\n            } else if (dir == 2) {\n                len_max = min(N - x, y - 1);\n            } else if (dir == 3) {\n                len_max = min(x - 1, N - y);\n            } else if (dir == 4) {\n                len_max = min(x - 1, y - 1);\n            }\n            ensuref(len_max >= 1, \"Invalid triangle at query %d: len_max < 1\", i + 1);\n            ensuref(len >= 1 && len <= len_max, \"Invalid len at query %d: len = %d, len_max = %d\", i + 1, len, len_max);\n\n        } else if (t == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, N, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, N, \"y\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 5000, \"N\");\n    inf.readSpace();\n    int Q = inf.readInt(1, 100000, \"Q\");\n    inf.readEoln();\n\n    for (int i = 0; i < Q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int dir = inf.readInt(1, 4, \"dir\");\n            inf.readSpace();\n            int x = inf.readInt(1, N, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, N, \"y\");\n            inf.readSpace();\n            int len = inf.readInt(1, N, \"len\");\n            inf.readEoln();\n\n            int len_max = 0;\n            if (dir == 1) {\n                len_max = min(N - x, N - y);\n            } else if (dir == 2) {\n                len_max = min(N - x, y - 1);\n            } else if (dir == 3) {\n                len_max = min(x - 1, N - y);\n            } else if (dir == 4) {\n                len_max = min(x - 1, y - 1);\n            }\n            ensuref(len_max >= 1, \"Invalid triangle at query %d: len_max < 1\", i + 1);\n            ensuref(len >= 1 && len <= len_max, \"Invalid len at query %d: len = %d, len_max = %d\", i + 1, len, len_max);\n\n        } else if (t == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, N, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, N, \"y\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Query {\n    int type; // 1 or 2\n    int dir; // For type 1\n    int x, y, len; // For type 1\n    // For type 2, we use x, y\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int N = opt<int>(\"N\"); // Grid size\n    int Q = opt<int>(\"Q\"); // Number of queries\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    int num_type1 = min(opt<int>(\"num_type1\", Q / 2), Q);\n\n    assert(1 <= N && N <= 5000);\n    assert(1 <= Q && Q <= 100000);\n    if (type == \"random\") {\n        vector<Query> queries;\n        int num_type2 = Q - num_type1;\n\n        // Generate type 1 queries\n        for (int i = 0; i < num_type1; ++i) {\n            Query q;\n            q.type = 1;\n            q.dir = rnd.next(1, 4);\n\n            int x_min, x_max, y_min, y_max, len_max;\n            if (q.dir == 1) {\n                x_min = 1;\n                x_max = N - 1;\n                y_min = 1;\n                y_max = N - 1;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(N - q.x, N - q.y);\n                len_max = max(len_max, 1);\n            } else if (q.dir == 2) {\n                x_min = 1;\n                x_max = N - 1;\n                y_min = 2;\n                y_max = N;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(N - q.x, q.y - 1);\n                len_max = max(len_max, 1);\n            } else if (q.dir == 3) {\n                x_min = 2;\n                x_max = N;\n                y_min = 1;\n                y_max = N - 1;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(q.x - 1, N - q.y);\n                len_max = max(len_max, 1);\n            } else if (q.dir == 4) {\n                x_min = 2;\n                x_max = N;\n                y_min = 2;\n                y_max = N;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(q.x - 1, q.y - 1);\n                len_max = max(len_max, 1);\n            }\n            q.len = rnd.next(1, len_max);\n            queries.push_back(q);\n        }\n\n        // Generate type 2 queries\n        for (int i = 0; i < num_type2; ++i) {\n            Query q;\n            q.type = 2;\n            q.x = rnd.next(1, N);\n            q.y = rnd.next(1, N);\n            queries.push_back(q);\n        }\n\n        // Shuffle the queries\n        shuffle(queries.begin(), queries.end());\n\n        // Output data\n        printf(\"%d %d\\n\", N, Q);\n        for (const Query& q : queries) {\n            if (q.type == 1) {\n                printf(\"%d %d %d %d %d\\n\", q.type, q.dir, q.x, q.y, q.len);\n            } else {\n                printf(\"%d %d %d\\n\", q.type, q.x, q.y);\n            }\n        }\n    } else if (type == \"max_overlap\") {\n        // All robots cover the entire grid\n        vector<Query> robots;\n        for (int dir = 1; dir <= 4; dir++) {\n            Query q;\n            q.type = 1;\n            q.dir = dir;\n            if (dir == 1) {\n                q.x = 1;\n                q.y = 1;\n                q.len = N - 1;\n            } else if (dir == 2) {\n                q.x = 1;\n                q.y = N;\n                q.len = N - 1;\n            } else if (dir == 3) {\n                q.x = N;\n                q.y = 1;\n                q.len = N - 1;\n            } else if (dir == 4) {\n                q.x = N;\n                q.y = N;\n                q.len = N - 1;\n            }\n            robots.push_back(q);\n        }\n\n        // Now, generate Q - 4 queries of type 2, covering various points\n        vector<Query> queries;\n        for (int i = 0; i < Q - 4; ++i) {\n            Query q;\n            q.type = 2;\n            q.x = rnd.next(1, N);\n            q.y = rnd.next(1, N);\n            queries.push_back(q);\n        }\n\n        // Combine robots and queries\n        vector<Query> all_queries = robots;\n        all_queries.insert(all_queries.end(), queries.begin(), queries.end());\n\n        // Shuffle queries\n        shuffle(all_queries.begin(), all_queries.end());\n\n        // Output\n        printf(\"%d %d\\n\", N, Q);\n        for (const Query& q : all_queries) {\n            if (q.type == 1) {\n                printf(\"%d %d %d %d %d\\n\", q.type, q.dir, q.x, q.y, q.len);\n            } else {\n                printf(\"%d %d %d\\n\", q.type, q.x, q.y);\n            }\n        }\n    } else if (type == \"empty\") {\n        // No robots, only queries\n        printf(\"%d %d\\n\", N, Q);\n        for (int i = 0; i < Q; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, N);\n            printf(\"2 %d %d\\n\", x, y);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Query {\n    int type; // 1 or 2\n    int dir; // For type 1\n    int x, y, len; // For type 1\n    // For type 2, we use x, y\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int N = opt<int>(\"N\"); // Grid size\n    int Q = opt<int>(\"Q\"); // Number of queries\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    int num_type1 = min(opt<int>(\"num_type1\", Q / 2), Q);\n\n    assert(1 <= N && N <= 5000);\n    assert(1 <= Q && Q <= 100000);\n    if (type == \"random\") {\n        vector<Query> queries;\n        int num_type2 = Q - num_type1;\n\n        // Generate type 1 queries\n        for (int i = 0; i < num_type1; ++i) {\n            Query q;\n            q.type = 1;\n            q.dir = rnd.next(1, 4);\n\n            int x_min, x_max, y_min, y_max, len_max;\n            if (q.dir == 1) {\n                x_min = 1;\n                x_max = N - 1;\n                y_min = 1;\n                y_max = N - 1;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(N - q.x, N - q.y);\n                len_max = max(len_max, 1);\n            } else if (q.dir == 2) {\n                x_min = 1;\n                x_max = N - 1;\n                y_min = 2;\n                y_max = N;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(N - q.x, q.y - 1);\n                len_max = max(len_max, 1);\n            } else if (q.dir == 3) {\n                x_min = 2;\n                x_max = N;\n                y_min = 1;\n                y_max = N - 1;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(q.x - 1, N - q.y);\n                len_max = max(len_max, 1);\n            } else if (q.dir == 4) {\n                x_min = 2;\n                x_max = N;\n                y_min = 2;\n                y_max = N;\n                q.x = rnd.next(x_min, x_max);\n                q.y = rnd.next(y_min, y_max);\n                len_max = min(q.x - 1, q.y - 1);\n                len_max = max(len_max, 1);\n            }\n            q.len = rnd.next(1, len_max);\n            queries.push_back(q);\n        }\n\n        // Generate type 2 queries\n        for (int i = 0; i < num_type2; ++i) {\n            Query q;\n            q.type = 2;\n            q.x = rnd.next(1, N);\n            q.y = rnd.next(1, N);\n            queries.push_back(q);\n        }\n\n        // Shuffle the queries\n        shuffle(queries.begin(), queries.end());\n\n        // Output data\n        printf(\"%d %d\\n\", N, Q);\n        for (const Query& q : queries) {\n            if (q.type == 1) {\n                printf(\"%d %d %d %d %d\\n\", q.type, q.dir, q.x, q.y, q.len);\n            } else {\n                printf(\"%d %d %d\\n\", q.type, q.x, q.y);\n            }\n        }\n    } else if (type == \"max_overlap\") {\n        // All robots cover the entire grid\n        vector<Query> robots;\n        for (int dir = 1; dir <= 4; dir++) {\n            Query q;\n            q.type = 1;\n            q.dir = dir;\n            if (dir == 1) {\n                q.x = 1;\n                q.y = 1;\n                q.len = N - 1;\n            } else if (dir == 2) {\n                q.x = 1;\n                q.y = N;\n                q.len = N - 1;\n            } else if (dir == 3) {\n                q.x = N;\n                q.y = 1;\n                q.len = N - 1;\n            } else if (dir == 4) {\n                q.x = N;\n                q.y = N;\n                q.len = N - 1;\n            }\n            robots.push_back(q);\n        }\n\n        // Now, generate Q - 4 queries of type 2, covering various points\n        vector<Query> queries;\n        for (int i = 0; i < Q - 4; ++i) {\n            Query q;\n            q.type = 2;\n            q.x = rnd.next(1, N);\n            q.y = rnd.next(1, N);\n            queries.push_back(q);\n        }\n\n        // Combine robots and queries\n        vector<Query> all_queries = robots;\n        all_queries.insert(all_queries.end(), queries.begin(), queries.end());\n\n        // Shuffle queries\n        shuffle(all_queries.begin(), all_queries.end());\n\n        // Output\n        printf(\"%d %d\\n\", N, Q);\n        for (const Query& q : all_queries) {\n            if (q.type == 1) {\n                printf(\"%d %d %d %d %d\\n\", q.type, q.dir, q.x, q.y, q.len);\n            } else {\n                printf(\"%d %d %d\\n\", q.type, q.x, q.y);\n            }\n        }\n    } else if (type == \"empty\") {\n        // No robots, only queries\n        printf(\"%d %d\\n\", N, Q);\n        for (int i = 0; i < Q; ++i) {\n            int x = rnd.next(1, N);\n            int y = rnd.next(1, N);\n            printf(\"2 %d %d\\n\", x, y);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with small N and Q\n./gen -N 5 -Q 10\n./gen -N 10 -Q 50\n./gen -N 50 -Q 100\n\n# Random test cases with moderate N and Q\n./gen -N 200 -Q 1000\n./gen -N 500 -Q 2000\n\n# Random test cases with large N and Q\n./gen -N 5000 -Q 100000\n./gen -N 5000 -Q 100000 -num_type1 80000\n\n# Random test cases with all type 1 queries\n./gen -N 5000 -Q 100000 -num_type1 100000\n\n# Random test cases with all type 2 queries\n./gen -N 5000 -Q 100000 -num_type1 0\n\n# Max overlap test case, small N and Q\n./gen -N 5 -Q 10 -type max_overlap\n\n# Max overlap test case, moderate N and Q\n./gen -N 500 -Q 1000 -type max_overlap\n\n# Max overlap test case, large N and Q\n./gen -N 5000 -Q 100000 -type max_overlap\n\n# Empty test cases (no robots)\n./gen -N 5 -Q 10 -type empty\n./gen -N 5000 -Q 100000 -type empty\n\n# Minimal N and Q\n./gen -N 1 -Q 1\n./gen -N 1 -Q 1 -type empty\n\n# N small, Q large\n./gen -N 10 -Q 100000\n./gen -N 10 -Q 100000 -num_type1 50000\n\n# N large, Q small\n./gen -N 5000 -Q 10\n\n# Various percentage of type 1 queries\n./gen -N 5000 -Q 100000 -num_type1 50000\n./gen -N 5000 -Q 100000 -num_type1 25000\n./gen -N 5000 -Q 100000 -num_type1 75000\n\n# Random test cases without specifying num_type1 (default is Q/2)\n./gen -N 5000 -Q 100000\n\n# Edge case: N=5000, Q=100000, num_type1=1\n./gen -N 5000 -Q 100000 -num_type1 1\n\n# Edge case: N=5000, Q=100000, num_type1=99999\n./gen -N 5000 -Q 100000 -num_type1 99999\n\n# Test with N at maximum, Q at minimum\n./gen -N 5000 -Q 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:40.754593",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "576/A",
      "title": "A. Vasya and Petya's Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains number n (1 ≤ n ≤ 103).",
      "output_spec": "OutputPrint the length of the sequence of questions k (0 ≤ k ≤ n), followed by k numbers — the questions yi (1 ≤ yi ≤ n).If there are several correct sequences of questions of the minimum length, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy4OutputCopy32 4 3 InputCopy6OutputCopy42 4 3 5",
      "description": "A. Vasya and Petya's Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputA single line contains number n (1 ≤ n ≤ 103).\n\nOutputPrint the length of the sequence of questions k (0 ≤ k ≤ n), followed by k numbers — the questions yi (1 ≤ yi ≤ n).If there are several correct sequences of questions of the minimum length, you are allowed to print any of them.\n\nInputCopy4OutputCopy32 4 3 InputCopy6OutputCopy42 4 3 5\n\nOutputCopy32 4 3\n\nOutputCopy42 4 3 5\n\nNoteThe sequence from the answer to the first sample test is actually correct.If the unknown number is not divisible by one of the sequence numbers, it is equal to 1.If the unknown number is divisible by 4, it is 4.If the unknown number is divisible by 3, then the unknown number is 3.Otherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Hey there!Today at 19.30, Moscow time there will be Codeforces Round #319 and it's strongly disadvised to skip it.I'm the author of this round, my name is Dima Gorbunov and it's my first round on Codeforces. I really hope you're going to like it and everyone will find a satisfying problem. In order to increase the probability of finding that task, please read all of the problem statements.As usual, I'd like to thank Zlobober for his invaluable help and his special sense of humour, sankear for coding additional solutions, Delinur for the English statements and MikeMirzayanov for amazing systems Codeforces and Polygon.You're going to have two hours to solve 5 problems. Good luck!UPD. The scores in first division are 500-1250-1250-2000-2750.In second division — 500-1250-1500-2250-2250,UPD2. Because of large size tests for some of the problems, system testing will be slow (it's possible that it will take several hours). Thanks for your patience!UPD3. English editorial is also accessible. UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826A special respect to al13n for correct solution of Div1.E during the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1189
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces",
          "content": "Task A. Div2.It's easy to see that number x can appear in column i only once — in row x / i. For every column i, let's check that x divides i and x / i ≤ n. If all requirements are met, we'll update the answer.The complexity is O(n)SourceTask B. Div2.Let's consider two cases: n > m and n ≤ m.If n > m, let's look at prefix sums. By pigeonhole principle, there are two equals sums modulo m. Assume Slmodm = Srmodm. Then the sum on segment [l + 1, r] equals zero modulo m, that means the answer is definitely \"YES\".If n ≤ m, we'll solve this task using dynamic programming in O(m2) time. Assume can[i][r] means if we can achieve the sum equal to r modulo m using only first i - 1 items. The updates in this dynamic programming are obvious: we either take number ai and go to the state can[i + 1][(r + ai) mod m] or not, then we'll get to the state can[i + 1][r].The complexity is O(m2).SourceTask A. Div1.If Petya didn't ask pk, where p is prime and k ≥ 1, he would not be able to distinguish pk - 1 and pk.That means, he should ask all the numbers pk. It's easy to prove that this sequence actually guesses all the numbers from 1 to nThe complexity is O(N1.5) or O(NloglogN) depending on primality test.SourceTask B. Div1.Let's look at the answer. It's easy to notice, that centers of that tree must turn into centers after applying the permutation. That means, permutation must have cycle with length 1 or 2 since there're at most two centers. If permutation has cycle with length 1, we can connect all the other vertices to it.For example, let's look at the permutation (4, 2, 1, 3). 2 is a cycle with length 2, so let's connect all the other vertices to it. The resulting tree edges would be (1, 2), (2, 3), (2, 4).If answer has two centers, let's remove the edge between them. The tree will split into two connected parts. It's easy to see that they will turn into each other after applying permutation. That means, all cycles should be even. It's easy to come up with answer with these restrictions. Let's connect vertices from the cycles with length 2. Then, let's connect vertices with odd position in cycles to first of these and vetices with even cycles to second one.For example, let's consider permutation (6, 5, 4, 3, 1, 2). There are two cycles: (3, 4) и (1, 6, 2, 5). We add edge (3, 4), all other vertices we connect to these two, obtaining edges (1, 3), (6, 4), (2, 3), (5, 4).The complexity is O(N).SourceTask C. Div1.Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.Let's calculate the maximum length of such a way. The coordinates are independent. By y-coordinate we're passing 1000 rectangles from 0 to 106, 109 in total. By x-coordinate we're spending 1000 to get to the next point of current rectangle and 2000 to get to next rectangle. That means, 2 * 109 + 2000000 in total, which perfectly fits.The complexity is O(n * log(n))SourceTask D. Div1.Let's optimize the first solution that comes to mind: O(m * dmax), let's calculate can[t][v] — can we get to the vertice v, while passing exactly t edges.Now, it's easy to find out that the set of edges we are able to go through changed only m times. Let's sort these edges in increasing order of di, that means for each i di ≤ di + 1. Let's calculate can[t][v] only for t = di. We can calculate can[di + 1] using can[di] by raising the adjacency matrix to the di + 1 - di power and applying it to can[di].Next step is to fix an edge with maximal di on our shortest path, let it be i. We know all the vertices we can be at moment di, so we need to calculate the shortest path to n - 1 using edges we can go through. We can even use Floyd algorithm to calculate that.The complexity of this solution is O(m * n3 * log(dmax)) and it's not enough.Next observation is that adjacency matrix contains only zeroes or ones, so we can multiply these matrixes using bitsets in O(n3 / 32).This makes complexity O(m * n3 * log(dmax) / 32), which gets accepted.SourceTask E. Div1.Let's solve an easier task first: independent of bipartivity, the color of edge changes.Then we could write a solution, which is pretty similar to solution of Dynamic Connectivity Offline task in O(nlog2n).Let's consider only cases, where edges are not being deleted from the color graph. Then, we could use DSU with storing parity of the way to the parent along with parent. Now we can find parity of the path to the root by jumping through parents and xoring the parities. Also, we can connect two components by accurately calculating the parity of the path from one root to another.Now edges are being deleted. For each edge and each color we know the segments of requests, when this edge will be in the graph of specified color. Let's build a segment tree on requests, in each vertex of the tree we store list of edges which exist on the subsegment. Every segment will be split into log parts, so, totally there would be n * log small parts.Now we can dfs this segment tree with DSU. We get inside the vertex, apply all the requests inside it, go through the children and revert DSU to initial state. We also answer requests in leafs of the segment tree.Let's return to initial task. We can't use this technique, because we don't know the exact segments of edge existence.Instead, let's do following. Initially we add each edge right until the first appearance of this edge in requests. Now, when we're in some leaf, we found out which color this edge would be right until the next appearance of this edge. So, let's update this edge on that segment. For each leaf we're going to make an update at most once, so the complexity is O(nlog2n).SourceIf anything is unclear or bad-written, ask any questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5926
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 1",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 2",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 3",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 4",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 6",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 7",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 8",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from the input file\n    int n = inf.readInt(1, 1000);\n\n    // Read contestant's output\n    int k = ouf.readInt(0, n, \"k\");\n    vector<int> y(k);\n    for (int i = 0; i < k; ++i) {\n        y[i] = ouf.readInt(1, n, format(\"y[%d]\", i + 1).c_str());\n    }\n\n    // Now check the validity of the output\n\n    // For each number x from 1 to n, calculate the sequence of answers\n    // Vasya would give to the questions y_i\n    map<vector<int>, int> answer_map; // Map from answer patterns to x\n    for (int x = 1; x <= n; ++x) {\n        vector<int> answers(k);\n        for (int i = 0; i < k; ++i) {\n            answers[i] = (x % y[i] == 0) ? 1 : 0;\n        }\n        if (answer_map.count(answers)) {\n            int other_x = answer_map[answers];\n            // Two different numbers correspond to the same answer pattern\n            quitf(_wa, \"Numbers %d and %d correspond to the same answers\", other_x, x);\n        } else {\n            answer_map[answers] = x;\n        }\n    }\n\n    if ((int)answer_map.size() != n) {\n        quitf(_wa, \"Not all numbers from 1 to %d are distinguishable\", n);\n    }\n\n    // If we reach this point, the contestant's output is valid\n    quitf(_ok, \"Correct output with k = %d\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n != -1) {\n        // If n is specified, use it, but make sure it fulfills the constraints\n        ensure(1 <= n && n <= 1000);\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n\n    string nsize = opt<string>(\"nsize\", \"small\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"power2\") {\n        int k = rnd.next(0, 10);\n        n = 1 << k;\n        n = min(n, 1000);\n        n = max(n, 1); // Ensure n >= 1\n    } else if (type == \"prime\") {\n        // Generate a random prime number less than or equal to 1000\n        vector<int> primes;\n        vector<bool> is_prime(1001, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= 1000; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for(int j = i * 2; j <= 1000; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else {\n        if (nsize == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (nsize == \"medium\") {\n            n = rnd.next(100, 500);\n        } else if (nsize == \"large\") {\n            n = rnd.next(900, 1000);\n        } else {\n            n = rnd.next(1, 1000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n != -1) {\n        // If n is specified, use it, but make sure it fulfills the constraints\n        ensure(1 <= n && n <= 1000);\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n\n    string nsize = opt<string>(\"nsize\", \"small\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"power2\") {\n        int k = rnd.next(0, 10);\n        n = 1 << k;\n        n = min(n, 1000);\n        n = max(n, 1); // Ensure n >= 1\n    } else if (type == \"prime\") {\n        // Generate a random prime number less than or equal to 1000\n        vector<int> primes;\n        vector<bool> is_prime(1001, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= 1000; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for(int j = i * 2; j <= 1000; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else {\n        if (nsize == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (nsize == \"medium\") {\n            n = rnd.next(100, 500);\n        } else if (nsize == \"large\") {\n            n = rnd.next(900, 1000);\n        } else {\n            n = rnd.next(1, 1000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n\n./gen -n 1\n\n# Small n\n./gen -nsize small\n./gen -nsize small\n./gen -nsize small\n\n# n = 2\n./gen -n 2\n\n# n = 3\n./gen -n 3\n\n# n = 4\n./gen -n 4\n\n# Medium n\n./gen -nsize medium\n./gen -nsize medium\n./gen -nsize medium\n\n# n = 500\n./gen -n 500\n\n# Large n\n./gen -nsize large\n./gen -nsize large\n./gen -nsize large\n\n# Maximum n\n./gen -n 1000\n\n# n is a power of 2\n./gen -type power2\n./gen -type power2\n./gen -type power2\n\n# n is prime\n./gen -type prime\n./gen -type prime\n./gen -type prime\n\n# Random n\n./gen\n./gen\n./gen\n\n# Edge cases around 999\n./gen -n 999\n\n# Edge cases around 998\n./gen -n 998\n\n# Edge cases for n = 100\n./gen -n 100\n\n# n is square\n./gen -n 961\n\n# n is factorial of k (6! = 720)\n./gen -n 720\n\n# n is triangular number (n=990)\n./gen -n 990\n\n# Random n\n./gen\n\n# Random n\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:42.903750",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "576/B",
      "title": "B. Инвариантность дерева",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке дано число n (1 ≤ n ≤ 105) — размер перестановки (совпадающий с размером искомого дерева).Во второй строке дана сама перестановка pi (1 ≤ pi ≤ n).",
      "output_spec": "Выходные данныеЕсли искомого дерева не существует, то выведите «NO» (без кавычек).Иначе выведите «YES», а затем выведите n - 1 строку, в каждой из которых находится по два целых числа — концы очередного ребра искомого дерева. Вершины нумеруются с единицы, порядок следования рёбер и порядок следования вершин внутри ребра не имеет значения.Если решений несколько, выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать44 3 2 1Выходные данныеСкопироватьYES4 14 21 3Входные данныеСкопировать33 1 2Выходные данныеСкопироватьNO",
      "description": "B. Инвариантность дерева\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке дано число n (1 ≤ n ≤ 105) — размер перестановки (совпадающий с размером искомого дерева).Во второй строке дана сама перестановка pi (1 ≤ pi ≤ n).\n\nВходные данные\n\nВыходные данныеЕсли искомого дерева не существует, то выведите «NO» (без кавычек).Иначе выведите «YES», а затем выведите n - 1 строку, в каждой из которых находится по два целых числа — концы очередного ребра искомого дерева. Вершины нумеруются с единицы, порядок следования рёбер и порядок следования вершин внутри ребра не имеет значения.Если решений несколько, выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать44 3 2 1Выходные данныеСкопироватьYES4 14 21 3Входные данныеСкопировать33 1 2Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать44 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES4 14 21 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать33 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия, при применении к ребру перестановки, ребро (4, 1) перейдет в ребро (1, 4), ребро (4, 2) перейдет в ребро (1, 3), а ребро (1, 3) перейдет в ребро (4, 2). Все эти ребра есть в ответе.Можно заметить, что во втором тесте из условия, ни одно дерево не подходит под ограничения.",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Всем привет!Сегодня в 19.30 по московскому времени состоится Codeforces Round #319, который настоятельно не рекомендуется кому-либо пропускать.Автор раунда — я, меня зовут Дима Горбунов, и это мой первый раунд на Codeforces. Я очень надеюсь, что вам понравится раунд, и каждый найдет себе задачу по вкусу. Для того, чтобы увеличить вероятность этого события, пожалуйста, прочтите все задачи этого контеста.Как всегда, благодарю Zlobober за неоценимую помощь при подготовке контеста и утонченный юмор, sankear за написание перекрестных решений, Delinur за перевод условий на английский язык и MikeMirzayanov за потрясающие системы Codeforces и Polygon.У вас будет два часа на то, чтобы решить 5 задач. Успехов!UPD. Разбалловка в первом дивизионе — 500-1250-1250-2000-2750.Во втором — 500-1250-1500-2250-2250.UPD2. Из-за тестов большого размера по некоторым задачам, системное тестирование будет идти медленно (возможно, займёт несколько часов). Благодарим за терпение!UPD3. Разбор можно найти по ссылке.UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826Отдельный респект al13n за правильное решение задачи Div1.E во время контеста!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1193
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces",
          "content": "Задача A. Div2.Заметим, что число x может встречаться в столбце i только один раз — в строке x / i. Переберем столбец i, проверим, что x делится нацело на i, а также x / i ≤ n. Если все условия выполнены, обновим ответ.Асимптотика — O(n)КодЗадача B. Div2.Рассмотрим два случая: n > m и n ≤ m.Пусть n > m, рассмотрим суммы на префиксах. По принципу Дирихле, найдутся две равные суммы по модулю m. Пусть Slmodm = Srmodm. Тогда сумма чисел на отрезке с l + 1 по r по модулю m равна нулю, то есть ответ точно \"YES\".Пусть n ≤ m, то решим задачу динамикой за O(m2). Пусть can[i][r] — можем ли мы, используя первые i предметов, получить остаток r от деления на m. Переходы в динамике понятны: либо мы берем предмет и переходим в состояние can[i + 1][(r + ai) mod m], либо не берем и переходим в состояние can[i + 1][r].Асимптотика — O(m2).КодЗадача A. Div1.Пусть Петя не спросил число pk, где p — простое, а k ≥ 1. Тогда, Петя не сможет отличить число pk - 1 от числа pk.Значит, нужно спросить все числа вида pk, где p — простое, а k ≥ 1. Несложно убедиться, что это позволит угадать и все остальные числа.Асимптотика O(N1.5) или O(NloglogN) в зависимости от теста на простоту.КодЗадачи B. Div1.Рассмотрим дерево-ответ. Заметим, что центры этого дерева могут перейти только в центры при применении перестановки. Это означает, что в перестановке обязательно должен быть цикл длины 1 или 2.Пусть в перестановке есть неподвижная точка. Тогда мы можем подсоединить ребрами к этой вершине все остальные. Несложно убедиться, что это корректный ответ.Например, пусть дана перестановка (4, 2, 1, 3). В перестановке есть неподвижная точка 2, поэтому подсоединим ко второй вершине все остальные. Получатся ребра дерева (1, 2), (2, 3), (2, 4).Пусть в дереве-ответе есть два центра. Удалим ребро между ними, дерево разобьется на две компоненты. Несложно понять, что они должны перейти друг в друга при применении перестановки. Это означает, что все циклы перестановки должны быть четной длины. Понятно, как построить ответ, если все циклы четной длины, и есть цикл длины два. Проведем ребро между вершинами из цикла длины два, вершины всех остальных циклов будем присоединять по очереди к центрам.Например, рассмотрим перестановку (6, 5, 4, 3, 1, 2). В перестановке есть два цикла: (3, 4) и (1, 6, 2, 5). Соединим ребром вершины (3, 4), все вершины другого цикла присоединим по очереди к этим двум вершинам, получим ребра (1, 3), (6, 4), (2, 3), (5, 4).Асимптотика — O(N).КодЗадача C. Div1.Разобьем квадрат 106 × 106 вертикальными линиями на 1000 прямоугольников 103 × 106. Пронумеруем эти прямоугольники от 1 до n в порядке слева направо. Обойдем их тоже слева направо, а внутри каждого прямоугольника обойдем точки по возрастанию y-координаты, если это четный по номеру прямоугольник, и по убыванию, если нечетный.Посчитаем длину такого пути, будем считать независимо по каждой координате. По y-координате мы пройдем суммарно 1000 прямоугольников от 0 до 106, то есть суммарно 109, По x-координате, чтобы дойти до следующей точки внутри прямоугольника, мы потратим не более 1000 на точку, и 1000 раз пройдем не более 2000 до следующего прямоугольника, то есть суммарно 109 + 2000000.Итого, длина пути не более 2 * 109 + 2000000, что подходит под ограничения на длину.Асимптотика — O(n * log(n))КодЗадача D. Div1.Будем оптимизировать первое же решение, которое приходит в голову за O(m * dmax): посчитаем can[t][v] — можно ли добраться до вершины v, пройдя по ровно t ребрам.Теперь заметим, что множество ребер, по которому мы можем ходить меняется только m раз. Отсортируем ребра в порядке возрастания di, т.е. для всех i di ≤ di + 1. Будем считать динамику can[t][v] только для t = di. Пусть мы хотим перейти от can[di] к can[di + 1]. Поскольку набор ребер не меняется с момента di до di + 1, мы можем возвести матрицу смежности в степень di + 1 - di и применить ее к can[di]. Пусть мы насчитали все can[di][v]. Теперь зафиксирует ребро с максимальным di, по которому мы пройдем в нашем кратчайшем пути. Мы знаем все вершины, в которых мы можем находиться в момент di, далее нужно найти кратчайший путь из них в вершину m по открытым для нас ребрам и обновить ответ. Матрицу кратчайших расстояний можно посчитать Флойдом, поэтому обновление ответа не составит труда.Получилось решение за O(m * n3 * log(dmax)), которое, к сожалению, работает долго.Далее нужно заметить, что матрица смежности состоит из ноликов и единичек, поэтому её можно возводить в степень битовым сжатием за O(n3 / 32). Это дает решение за O(m * n3 * log(dmax) / 32), что спокойно заходит по времени.КодЗадача E. Div1.Сначала решим чуть более простую задачу: пусть вне зависимости от двудольности/недвудольности запросы выполняются, а от нас требуется лишь ответить, будет ли граф двудольным/недвудольным после запроса.Тогда мы могли бы применить решение, похожее на решение задачи Dynamic Connectivity Offline за O(nlog2n). Опишем его подробнее:Вначале пусть ребра только добавляются. Тогда можно воспользоваться системой непересекающихся множеств, где, кроме предка, будем хранить четность пути до предка, а также флаг двудольности текущего графа. Теперь мы можем найти четность пути до корня — просто пропрыгать до предка, проксорить четности. Теперь, когда мы проводим ребро между двумя компонентами, мы можем посчитать четность путей до вершин этой ребра, а значит, и установить четность прыжка из корня одной компоненты в корень другой компоненты. Если ребро проходит внутри одной компоненты и четности пути до корня совпадают, нужно убрать флаг двудольности текущего графа.Теперь пусть ребра иногда удаляются. Для каждого ребра и каждого цвета мы знаем отрезки запросов, когда это ребро будет в графе заданного цвета. Давайте построим дерево отрезков на запросах, в каждой вершине будем хранить список ребер, которые будут включены на этом подотрезке. Каждый отрезок дерево отрезков разобьет на log кусочков, поэтому в сумме количество добавлений ребер на кусочке будет порядка n * log.Теперь, можно обойти это дерево отрезков в глубину с системой непересекающихся множеств с откатами. Мы входим в вершины, применяем все запросы добавления ребра в данной вершине, обходим потомков, а затем откатываем снм до состояния, в котором оно было на входе в эту вершину. Когда мы находимся в листе, отвечаем на соответствующий запрос.Вернемся к нашей задаче. Вышеописанную технику в явном виде мы применить не можем, потому что не знаем точно, на каких отрезках запросов ребра будут существовать.Зато мы можем сделать следующее. Изначально применим операцию до первого момента появления ребра в запросах. Теперь, когда мы находимся в листе, мы узнали, какого цвета это ребро будет до следующего его появления в запросах. Поэтому, давайте сделаем обновление на отрезке со следующего запроса до следующего появления этого ребра. Для каждого листа мы сделаем не более одного обновления, поэтому суммарное время работы O(nlog2n).Асимптотика — O(nlog2n).КодЕсли что-то неясно, непонятно или невнятно написано, задавайте любые вопросы.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6982
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 1",
          "code": "a += b;\nif (a >= mod) a -= mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 2",
          "code": "a += b;\nif (a >= mod) a -= mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 3",
          "code": "a = (a + b) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 4",
          "code": "a = (a + b) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 6",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 7",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 8",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 9",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 10",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 11",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 12",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        p[i] = inf.readInt(1, n, (\"p[\" + to_string(i+1) + \"]\").c_str());\n    }\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int x = p[i];\n        ensuref(!seen[x], \"p_i is not a permutation, value %d appears multiple times\", x);\n        seen[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        p[i] = inf.readInt(1, n, (\"p[\" + to_string(i+1) + \"]\").c_str());\n    }\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int x = p[i];\n        ensuref(!seen[x], \"p_i is not a permutation, value %d appears multiple times\", x);\n        seen[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        p[i] = inf.readInt(1, n, (\"p[\" + to_string(i+1) + \"]\").c_str());\n    }\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int x = p[i];\n        ensuref(!seen[x], \"p_i is not a permutation, value %d appears multiple times\", x);\n        seen[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) data structure to check for cycles and connectivity\nclass DSU {\npublic:\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n + 1);\n        for (int i = 1; i <= n; i++)\n            parent[i] = i;\n    }\n    int find(int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    bool unite(int u, int v) {\n        int pu = find(u);\n        int pv = find(v);\n        if (pu == pv)\n            return false; // Cycle detected\n        parent[pu] = pv;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int n = inf.readInt(1, 100000, \"n\");\n    vector<int> p(n + 1);\n    for (int i = 1; i <= n; i++) {\n        p[i] = inf.readInt(1, n, format(\"p[%d]\", i).c_str());\n    }\n\n    // Read jury's answer from ans\n    string ans_first_word = ans.readWord();\n    bool ans_says_no = false;\n    if (ans_first_word == \"NO\") {\n        ans_says_no = true;\n    } else if (ans_first_word == \"YES\") {\n        ans_says_no = false;\n        // We don't need to read the jury's tree edges\n    } else {\n        ans.quitf(_fail, \"Jury's answer is neither YES nor NO\");\n    }\n\n    // Read participant's answer from ouf\n    string ouf_first_word = ouf.readWord();\n    bool participant_says_no = false;\n    if (ouf_first_word == \"NO\") {\n        participant_says_no = true;\n    } else if (ouf_first_word == \"YES\") {\n        participant_says_no = false;\n    } else {\n        ouf.quitf(_pe, \"Your answer is neither YES nor NO\");\n    }\n\n    if (ans_says_no) {\n        if (participant_says_no) {\n            // Both say \"NO\" - Accepted\n            quitf(_ok, \"Correct: both outputs are NO\");\n        } else {\n            // Participant says \"YES\", but correct answer is \"NO\"\n            quitf(_wa, \"Participant output YES, but correct answer is NO\");\n        }\n    } else {\n        if (participant_says_no) {\n            // Participant says \"NO\", but correct answer is \"YES\"\n            quitf(_wa, \"Participant output NO, but correct answer is YES\");\n        } else {\n            // Both say \"YES\" - Need to check the participant's tree\n            // Read participant's tree\n            vector<pair<int, int>> edges;\n            for (int i = 0; i < n - 1; i++) {\n                int u = ouf.readInt(1, n, format(\"Edge %d vertex u\", i + 1).c_str());\n                int v = ouf.readInt(1, n, format(\"Edge %d vertex v\", i + 1).c_str());\n                if (u == v)\n                    ouf.quitf(_wa, \"Edge %d connects vertex to itself (%d)\", i + 1, u);\n                edges.push_back({min(u, v), max(u, v)});\n            }\n\n            // Check if the edges form a valid tree (connected and acyclic)\n            DSU dsu(n);\n            for (int i = 0; i < n - 1; i++) {\n                int u = edges[i].first;\n                int v = edges[i].second;\n                if (!dsu.unite(u, v)) {\n                    ouf.quitf(_wa, \"Cycle detected in the tree at edge (%d, %d)\", u, v);\n                }\n            }\n            // Check connectivity\n            int root = dsu.find(1);\n            for (int i = 2; i <= n; i++) {\n                if (dsu.find(i) != root) {\n                    ouf.quitf(_wa, \"The tree is not connected\");\n                }\n            }\n\n            // Check invariance under permutation p\n            set<pair<int, int>> edge_set(edges.begin(), edges.end());\n            set<pair<int, int>> permuted_edge_set;\n            for (const auto& edge : edges) {\n                int u = p[edge.first];\n                int v = p[edge.second];\n                permuted_edge_set.insert({min(u, v), max(u, v)});\n            }\n            if (edge_set != permuted_edge_set) {\n                ouf.quitf(_wa, \"The tree is not invariant under the given permutation\");\n            }\n\n            // All checks passed\n            quitf(_ok, \"Correct\");\n        }\n    }\n    // Should not reach here\n    quitf(_fail, \"Unexpected end of checker\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_derangement(int n) {\n    if (n == 1)\n        quitf(_fail, \"Cannot generate derangement for n=1\");\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1;\n    for (int i = n - 1; i > 0; --i) {\n        int j = rnd.next(0, i - 1);\n        swap(p[i], p[j]);\n    }\n    return p;\n}\n\nvector<int> generate_involution(int n) {\n    vector<int> p(n, -1);\n    vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    shuffle(idx.begin(), idx.end());\n    int i = 0;\n    while (i < n) {\n        if (i + 1 < n && rnd.next(2)) {\n            // Pair idx[i] with idx[i+1]\n            p[idx[i]] = idx[i+1] + 1;\n            p[idx[i+1]] = idx[i] + 1;\n            i += 2;\n        } else {\n            // Fixed point at idx[i]\n            p[idx[i]] = idx[i] + 1;\n            ++i;\n        }\n    }\n    return p;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    if (type == \"sorted\" || type == \"identity\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else if (type == \"involution\") {\n        p = generate_involution(n);\n    } else if (type == \"fixed_point_free\" || type == \"derangement\") {\n        p = generate_derangement(n);\n    } else if (type == \"k_cycle\") {\n        int k = opt<int>(\"k\", n);\n        if (k > n) k = n;\n        vector<int> cycle(k);\n        for (int i = 0; i < k; ++i)\n            cycle[i] = i + 1;\n        shuffle(cycle.begin(), cycle.end());\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        for (int i = 0; i < k; ++i)\n            p[cycle[i]-1] = cycle[(i + 1) % k];\n    } else {\n        quitf(_fail, \"Unknown type parameter: %s\", type.c_str());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_derangement(int n) {\n    if (n == 1)\n        quitf(_fail, \"Cannot generate derangement for n=1\");\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1;\n    for (int i = n - 1; i > 0; --i) {\n        int j = rnd.next(0, i - 1);\n        swap(p[i], p[j]);\n    }\n    return p;\n}\n\nvector<int> generate_involution(int n) {\n    vector<int> p(n, -1);\n    vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    shuffle(idx.begin(), idx.end());\n    int i = 0;\n    while (i < n) {\n        if (i + 1 < n && rnd.next(2)) {\n            // Pair idx[i] with idx[i+1]\n            p[idx[i]] = idx[i+1] + 1;\n            p[idx[i+1]] = idx[i] + 1;\n            i += 2;\n        } else {\n            // Fixed point at idx[i]\n            p[idx[i]] = idx[i] + 1;\n            ++i;\n        }\n    }\n    return p;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    if (type == \"sorted\" || type == \"identity\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else if (type == \"involution\") {\n        p = generate_involution(n);\n    } else if (type == \"fixed_point_free\" || type == \"derangement\") {\n        p = generate_derangement(n);\n    } else if (type == \"k_cycle\") {\n        int k = opt<int>(\"k\", n);\n        if (k > n) k = n;\n        vector<int> cycle(k);\n        for (int i = 0; i < k; ++i)\n            cycle[i] = i + 1;\n        shuffle(cycle.begin(), cycle.end());\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        for (int i = 0; i < k; ++i)\n            p[cycle[i]-1] = cycle[(i + 1) % k];\n    } else {\n        quitf(_fail, \"Unknown type parameter: %s\", type.c_str());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted\n./gen -n 1 -type reversed\n./gen -n 1 -type random\n\n./gen -n 2 -type sorted\n./gen -n 2 -type reversed\n./gen -n 2 -type random\n./gen -n 2 -type involution\n./gen -n 2 -type derangement\n\n./gen -n 5 -type sorted\n./gen -n 5 -type reversed\n./gen -n 5 -type random\n./gen -n 5 -type involution\n./gen -n 5 -type derangement\n./gen -n 5 -type k_cycle -k 3\n./gen -n 5 -type k_cycle -k 5\n\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type random\n./gen -n 10 -type involution\n./gen -n 10 -type derangement\n\n./gen -n 100 -type random\n./gen -n 100 -type involution\n./gen -n 100 -type derangement\n\n./gen -n 1000 -type random\n./gen -n 1000 -type involution\n./gen -n 1000 -type derangement\n\n./gen -n 10000 -type random\n./gen -n 10000 -type involution\n./gen -n 10000 -type derangement\n\n./gen -n 100000 -type random\n./gen -n 100000 -type involution\n./gen -n 100000 -type derangement\n\n./gen -n 99999 -type k_cycle -k 50000\n./gen -n 100000 -type k_cycle -k 1\n./gen -n 100000 -type k_cycle -k 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:45.194097",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "576/C",
      "title": "C. Points on Plane",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106).The i + 1-th line contains the coordinates of the i-th point: xi and yi (0 ≤ xi, yi ≤ 106).It is guaranteed that no two points coincide.",
      "output_spec": "OutputPrint the permutation of numbers pi from 1 to n — the sought Hamiltonian path. The permutation must meet the inequality .If there are multiple possible answers, print any of them.It is guaranteed that the answer exists.",
      "sample_tests": "ExamplesInputCopy50 78 103 45 09 12OutputCopy4 3 1 2 5",
      "description": "C. Points on Plane\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 106).The i + 1-th line contains the coordinates of the i-th point: xi and yi (0 ≤ xi, yi ≤ 106).It is guaranteed that no two points coincide.\n\nOutputPrint the permutation of numbers pi from 1 to n — the sought Hamiltonian path. The permutation must meet the inequality .If there are multiple possible answers, print any of them.It is guaranteed that the answer exists.\n\nInputCopy50 78 103 45 09 12OutputCopy4 3 1 2 5\n\nInputCopy50 78 103 45 09 12\n\nOutputCopy4 3 1 2 5\n\nNoteIn the sample test the total distance is:(|5 - 3| + |0 - 4|) + (|3 - 0| + |4 - 7|) + (|0 - 8| + |7 - 10|) + (|8 - 9| + |10 - 12|) = 2 + 4 + 3 + 3 + 8 + 3 + 1 + 2 = 26",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Hey there!Today at 19.30, Moscow time there will be Codeforces Round #319 and it's strongly disadvised to skip it.I'm the author of this round, my name is Dima Gorbunov and it's my first round on Codeforces. I really hope you're going to like it and everyone will find a satisfying problem. In order to increase the probability of finding that task, please read all of the problem statements.As usual, I'd like to thank Zlobober for his invaluable help and his special sense of humour, sankear for coding additional solutions, Delinur for the English statements and MikeMirzayanov for amazing systems Codeforces and Polygon.You're going to have two hours to solve 5 problems. Good luck!UPD. The scores in first division are 500-1250-1250-2000-2750.In second division — 500-1250-1500-2250-2250,UPD2. Because of large size tests for some of the problems, system testing will be slow (it's possible that it will take several hours). Thanks for your patience!UPD3. English editorial is also accessible. UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826A special respect to al13n for correct solution of Div1.E during the contest!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1189
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces",
          "content": "Task A. Div2.It's easy to see that number x can appear in column i only once — in row x / i. For every column i, let's check that x divides i and x / i ≤ n. If all requirements are met, we'll update the answer.The complexity is O(n)SourceTask B. Div2.Let's consider two cases: n > m and n ≤ m.If n > m, let's look at prefix sums. By pigeonhole principle, there are two equals sums modulo m. Assume Slmodm = Srmodm. Then the sum on segment [l + 1, r] equals zero modulo m, that means the answer is definitely \"YES\".If n ≤ m, we'll solve this task using dynamic programming in O(m2) time. Assume can[i][r] means if we can achieve the sum equal to r modulo m using only first i - 1 items. The updates in this dynamic programming are obvious: we either take number ai and go to the state can[i + 1][(r + ai) mod m] or not, then we'll get to the state can[i + 1][r].The complexity is O(m2).SourceTask A. Div1.If Petya didn't ask pk, where p is prime and k ≥ 1, he would not be able to distinguish pk - 1 and pk.That means, he should ask all the numbers pk. It's easy to prove that this sequence actually guesses all the numbers from 1 to nThe complexity is O(N1.5) or O(NloglogN) depending on primality test.SourceTask B. Div1.Let's look at the answer. It's easy to notice, that centers of that tree must turn into centers after applying the permutation. That means, permutation must have cycle with length 1 or 2 since there're at most two centers. If permutation has cycle with length 1, we can connect all the other vertices to it.For example, let's look at the permutation (4, 2, 1, 3). 2 is a cycle with length 2, so let's connect all the other vertices to it. The resulting tree edges would be (1, 2), (2, 3), (2, 4).If answer has two centers, let's remove the edge between them. The tree will split into two connected parts. It's easy to see that they will turn into each other after applying permutation. That means, all cycles should be even. It's easy to come up with answer with these restrictions. Let's connect vertices from the cycles with length 2. Then, let's connect vertices with odd position in cycles to first of these and vetices with even cycles to second one.For example, let's consider permutation (6, 5, 4, 3, 1, 2). There are two cycles: (3, 4) и (1, 6, 2, 5). We add edge (3, 4), all other vertices we connect to these two, obtaining edges (1, 3), (6, 4), (2, 3), (5, 4).The complexity is O(N).SourceTask C. Div1.Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.Let's calculate the maximum length of such a way. The coordinates are independent. By y-coordinate we're passing 1000 rectangles from 0 to 106, 109 in total. By x-coordinate we're spending 1000 to get to the next point of current rectangle and 2000 to get to next rectangle. That means, 2 * 109 + 2000000 in total, which perfectly fits.The complexity is O(n * log(n))SourceTask D. Div1.Let's optimize the first solution that comes to mind: O(m * dmax), let's calculate can[t][v] — can we get to the vertice v, while passing exactly t edges.Now, it's easy to find out that the set of edges we are able to go through changed only m times. Let's sort these edges in increasing order of di, that means for each i di ≤ di + 1. Let's calculate can[t][v] only for t = di. We can calculate can[di + 1] using can[di] by raising the adjacency matrix to the di + 1 - di power and applying it to can[di].Next step is to fix an edge with maximal di on our shortest path, let it be i. We know all the vertices we can be at moment di, so we need to calculate the shortest path to n - 1 using edges we can go through. We can even use Floyd algorithm to calculate that.The complexity of this solution is O(m * n3 * log(dmax)) and it's not enough.Next observation is that adjacency matrix contains only zeroes or ones, so we can multiply these matrixes using bitsets in O(n3 / 32).This makes complexity O(m * n3 * log(dmax) / 32), which gets accepted.SourceTask E. Div1.Let's solve an easier task first: independent of bipartivity, the color of edge changes.Then we could write a solution, which is pretty similar to solution of Dynamic Connectivity Offline task in O(nlog2n).Let's consider only cases, where edges are not being deleted from the color graph. Then, we could use DSU with storing parity of the way to the parent along with parent. Now we can find parity of the path to the root by jumping through parents and xoring the parities. Also, we can connect two components by accurately calculating the parity of the path from one root to another.Now edges are being deleted. For each edge and each color we know the segments of requests, when this edge will be in the graph of specified color. Let's build a segment tree on requests, in each vertex of the tree we store list of edges which exist on the subsegment. Every segment will be split into log parts, so, totally there would be n * log small parts.Now we can dfs this segment tree with DSU. We get inside the vertex, apply all the requests inside it, go through the children and revert DSU to initial state. We also answer requests in leafs of the segment tree.Let's return to initial task. We can't use this technique, because we don't know the exact segments of edge existence.Instead, let's do following. Initially we add each edge right until the first appearance of this edge in requests. Now, when we're in some leaf, we found out which color this edge would be right until the next appearance of this edge. So, let's update this edge on that segment. For each leaf we're going to make an update at most once, so the complexity is O(nlog2n).SourceIf anything is unclear or bad-written, ask any questions.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5926
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 1",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 2",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 3",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 4",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 6",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 7",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 8",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    set< pair<int,int> > points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000, \"yi\");\n        inf.readEoln();\n\n        auto res = points.insert( make_pair( xi, yi ) );\n        ensuref( res.second, \"Point (%d, %d) occurs more than once\", xi, yi );\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    set< pair<int,int> > points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000, \"yi\");\n        inf.readEoln();\n\n        auto res = points.insert( make_pair( xi, yi ) );\n        ensuref( res.second, \"Point (%d, %d) occurs more than once\", xi, yi );\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    set< pair<int,int> > points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000, \"yi\");\n        inf.readEoln();\n\n        auto res = points.insert( make_pair( xi, yi ) );\n        ensuref( res.second, \"Point (%d, %d) occurs more than once\", xi, yi );\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt();\n        int yi = inf.readInt();\n        points[i] = make_pair(xi, yi);\n    }\n\n    // Read the permutation from the contestant's output\n    vector<int> pi = ouf.readInts(n, 1, n, \"pi\");\n\n    // Check that pi is a valid permutation of numbers from 1 to n\n    vector<bool> used(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int v = pi[i];\n        if (used[v]) {\n            ouf.quitf(_wa, \"Number %d appears more than once in the permutation\", v);\n        }\n        used[v] = true;\n    }\n\n    // Calculate the total length of the Hamiltonian path\n    long long total_length = 0;\n    for (int i = 0; i < n - 1; ++i) {\n        int a_index = pi[i] - 1;\n        int b_index = pi[i + 1] - 1;\n        int dx = abs(points[a_index].first - points[b_index].first);\n        int dy = abs(points[a_index].second - points[b_index].second);\n        total_length += dx + dy;\n\n        if (total_length > 2500000000LL) {\n            ouf.quitf(_wa, \"Total path length %lld exceeds 25×10^8 after %d steps\", total_length, i + 1);\n        }\n    }\n\n    if (total_length > 2500000000LL) {\n        ouf.quitf(_wa, \"Total path length %lld exceeds 25×10^8\", total_length);\n    } else {\n        quitf(_ok, \"Total path length %lld within limit\", total_length);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> points;\n\n    if (type == \"min\") {\n        // Generate minimal input with n=1\n        int x = rnd.next(0, 1000000);\n        int y = rnd.next(0, 1000000);\n        points.push_back({x,y});\n    } else if (type == \"random\") {\n        // Generate n random points\n        set<pair<int,int>> used_points;\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else if (type == \"line_h\") {\n        // Points along a horizontal line\n        int y = rnd.next(0, 1000000);\n        set<int> xs;\n        while (xs.size() < n) {\n            int x = rnd.next(0, 1000000);\n            xs.insert(x);\n        }\n        for (int x : xs) {\n            points.push_back({x, y});\n        } \n    } else if (type == \"line_v\") {\n        // Points along a vertical line\n        int x = rnd.next(0, 1000000);\n        set<int> ys;\n        while (ys.size() < n) {\n            int y = rnd.next(0, 1000000);\n            ys.insert(y);\n        }\n        for (int y : ys) {\n            points.push_back({x, y});\n        } \n    } else if (type == \"line_d\") {\n        // Points along the line x = y\n        set<int> xs;\n        while (xs.size() < n) {\n            int x = rnd.next(0, 1000000);\n            xs.insert(x);\n        }\n        for (int x : xs) {\n            points.push_back({x, x});\n        }\n    } else if (type == \"clustered\") {\n        // Points in clusters\n        int k = opt<int>(\"k\", 10); // number of clusters\n        int per_cluster = n / k;\n        int remaining = n - per_cluster * k;\n        set<pair<int,int>> used_points;\n        for (int i = 0; i < k; ++i) {\n            int cx = rnd.next(0, 1000000);\n            int cy = rnd.next(0, 1000000);\n            for (int j = 0; j < per_cluster; ++j) {\n                int x = cx + rnd.next(-1000, 1000);\n                int y = cy + rnd.next(-1000, 1000);\n                x = max(0, min(1000000, x));\n                y = max(0, min(1000000, y));\n                if (used_points.count({x,y}) == 0) {\n                    used_points.insert({x,y});\n                    points.push_back({x,y});\n                } else {\n                    --j;\n                }\n            } \n        }\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else if (type == \"grid\") {\n        // Points forming a grid\n        int side = (int)sqrt(n);\n        if (side * side > n) side--;\n        vector<int> xs, ys;\n        int stride = 1000000 / max(1, side - 1);\n        for (int i = 0; i < side; ++i) {\n            xs.push_back(i * stride);\n            ys.push_back(i * stride);\n        }\n        for (int i = 0; i < side && points.size() < n; ++i) {\n            for (int j = 0; j < side && points.size() < n; ++j) {\n                points.push_back({xs[i], ys[j]});\n            }\n        }\n        set<pair<int,int>> used_points(points.begin(), points.end());\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else if (type == \"max_coordinates\") {\n        // Points near (1e6, 1e6)\n        set<pair<int,int>> used_points;\n        while (points.size() < n) {\n            int x = 1000000 - rnd.next(0, 1000);\n            int y = 1000000 - rnd.next(0, 1000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else {\n        // Default to random\n        set<pair<int,int>> used_points;\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> points;\n\n    if (type == \"min\") {\n        // Generate minimal input with n=1\n        int x = rnd.next(0, 1000000);\n        int y = rnd.next(0, 1000000);\n        points.push_back({x,y});\n    } else if (type == \"random\") {\n        // Generate n random points\n        set<pair<int,int>> used_points;\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else if (type == \"line_h\") {\n        // Points along a horizontal line\n        int y = rnd.next(0, 1000000);\n        set<int> xs;\n        while (xs.size() < n) {\n            int x = rnd.next(0, 1000000);\n            xs.insert(x);\n        }\n        for (int x : xs) {\n            points.push_back({x, y});\n        } \n    } else if (type == \"line_v\") {\n        // Points along a vertical line\n        int x = rnd.next(0, 1000000);\n        set<int> ys;\n        while (ys.size() < n) {\n            int y = rnd.next(0, 1000000);\n            ys.insert(y);\n        }\n        for (int y : ys) {\n            points.push_back({x, y});\n        } \n    } else if (type == \"line_d\") {\n        // Points along the line x = y\n        set<int> xs;\n        while (xs.size() < n) {\n            int x = rnd.next(0, 1000000);\n            xs.insert(x);\n        }\n        for (int x : xs) {\n            points.push_back({x, x});\n        }\n    } else if (type == \"clustered\") {\n        // Points in clusters\n        int k = opt<int>(\"k\", 10); // number of clusters\n        int per_cluster = n / k;\n        int remaining = n - per_cluster * k;\n        set<pair<int,int>> used_points;\n        for (int i = 0; i < k; ++i) {\n            int cx = rnd.next(0, 1000000);\n            int cy = rnd.next(0, 1000000);\n            for (int j = 0; j < per_cluster; ++j) {\n                int x = cx + rnd.next(-1000, 1000);\n                int y = cy + rnd.next(-1000, 1000);\n                x = max(0, min(1000000, x));\n                y = max(0, min(1000000, y));\n                if (used_points.count({x,y}) == 0) {\n                    used_points.insert({x,y});\n                    points.push_back({x,y});\n                } else {\n                    --j;\n                }\n            } \n        }\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else if (type == \"grid\") {\n        // Points forming a grid\n        int side = (int)sqrt(n);\n        if (side * side > n) side--;\n        vector<int> xs, ys;\n        int stride = 1000000 / max(1, side - 1);\n        for (int i = 0; i < side; ++i) {\n            xs.push_back(i * stride);\n            ys.push_back(i * stride);\n        }\n        for (int i = 0; i < side && points.size() < n; ++i) {\n            for (int j = 0; j < side && points.size() < n; ++j) {\n                points.push_back({xs[i], ys[j]});\n            }\n        }\n        set<pair<int,int>> used_points(points.begin(), points.end());\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else if (type == \"max_coordinates\") {\n        // Points near (1e6, 1e6)\n        set<pair<int,int>> used_points;\n        while (points.size() < n) {\n            int x = 1000000 - rnd.next(0, 1000);\n            int y = 1000000 - rnd.next(0, 1000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    } else {\n        // Default to random\n        set<pair<int,int>> used_points;\n        while (points.size() < n) {\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            if (used_points.count({x,y}) == 0) {\n                used_points.insert({x,y});\n                points.push_back({x,y});\n            }\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n\n./gen -n 10 -type random\n./gen -n 10 -type line_h\n./gen -n 10 -type line_v\n./gen -n 10 -type line_d\n./gen -n 10 -type clustered -k 2\n./gen -n 10 -type grid\n\n./gen -n 100 -type random\n./gen -n 100 -type line_h\n./gen -n 100 -type line_v\n./gen -n 100 -type line_d\n./gen -n 100 -type clustered -k 5\n./gen -n 100 -type grid\n\n./gen -n 1000 -type random\n./gen -n 1000 -type line_h\n./gen -n 1000 -type line_v\n./gen -n 1000 -type line_d\n./gen -n 1000 -type clustered -k 10\n./gen -n 1000 -type grid\n\n./gen -n 100000 -type random\n./gen -n 100000 -type line_h\n./gen -n 100000 -type line_v\n./gen -n 100000 -type line_d\n./gen -n 100000 -type clustered -k 20\n./gen -n 100000 -type grid\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type line_h\n./gen -n 1000000 -type line_v\n./gen -n 1000000 -type line_d\n./gen -n 1000000 -type clustered -k 100\n./gen -n 1000000 -type grid\n./gen -n 1000000 -type max_coordinates\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:46.922822",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "576/D",
      "title": "D. Flights for Regular Customers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and m (2 ≤ n ≤ 150, 1 ≤ m ≤ 150) — the number of cities in the country and the number of flights the company provides.Next m lines contain numbers ai, bi, di (1 ≤ ai, bi ≤ n, 0 ≤ di ≤ 109), representing flight number i from city ai to city bi, accessible to only the clients who have made at least di flights.",
      "output_spec": "OutputPrint \"Impossible\" (without the quotes), if it is impossible to get from city 1 to city n using the airways.But if there is at least one way, print a single integer — the minimum number of flights you need to make to get to the destination point.",
      "sample_tests": "ExamplesInputCopy3 21 2 02 3 1OutputCopy2InputCopy2 11 2 100500OutputCopyImpossibleInputCopy3 32 1 02 3 61 2 0OutputCopy8",
      "description": "D. Flights for Regular Customers\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers, n and m (2 ≤ n ≤ 150, 1 ≤ m ≤ 150) — the number of cities in the country and the number of flights the company provides.Next m lines contain numbers ai, bi, di (1 ≤ ai, bi ≤ n, 0 ≤ di ≤ 109), representing flight number i from city ai to city bi, accessible to only the clients who have made at least di flights.\n\nOutputPrint \"Impossible\" (without the quotes), if it is impossible to get from city 1 to city n using the airways.But if there is at least one way, print a single integer — the minimum number of flights you need to make to get to the destination point.\n\nInputCopy3 21 2 02 3 1OutputCopy2InputCopy2 11 2 100500OutputCopyImpossibleInputCopy3 32 1 02 3 61 2 0OutputCopy8\n\nInputCopy3 21 2 02 3 1\n\nOutputCopy2\n\nInputCopy2 11 2 100500\n\nOutputCopyImpossible\n\nInputCopy3 32 1 02 3 61 2 0\n\nOutputCopy8",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Hey there!Today at 19.30, Moscow time there will be Codeforces Round #319 and it's strongly disadvised to skip it.I'm the author of this round, my name is Dima Gorbunov and it's my first round on Codeforces. I really hope you're going to like it and everyone will find a satisfying problem. In order to increase the probability of finding that task, please read all of the problem statements.As usual, I'd like to thank Zlobober for his invaluable help and his special sense of humour, sankear for coding additional solutions, Delinur for the English statements and MikeMirzayanov for amazing systems Codeforces and Polygon.You're going to have two hours to solve 5 problems. Good luck!UPD. The scores in first division are 500-1250-1250-2000-2750.In second division — 500-1250-1500-2250-2250,UPD2. Because of large size tests for some of the problems, system testing will be slow (it's possible that it will take several hours). Thanks for your patience!UPD3. English editorial is also accessible. UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826A special respect to al13n for correct solution of Div1.E during the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1189
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces",
          "content": "Task A. Div2.It's easy to see that number x can appear in column i only once — in row x / i. For every column i, let's check that x divides i and x / i ≤ n. If all requirements are met, we'll update the answer.The complexity is O(n)SourceTask B. Div2.Let's consider two cases: n > m and n ≤ m.If n > m, let's look at prefix sums. By pigeonhole principle, there are two equals sums modulo m. Assume Slmodm = Srmodm. Then the sum on segment [l + 1, r] equals zero modulo m, that means the answer is definitely \"YES\".If n ≤ m, we'll solve this task using dynamic programming in O(m2) time. Assume can[i][r] means if we can achieve the sum equal to r modulo m using only first i - 1 items. The updates in this dynamic programming are obvious: we either take number ai and go to the state can[i + 1][(r + ai) mod m] or not, then we'll get to the state can[i + 1][r].The complexity is O(m2).SourceTask A. Div1.If Petya didn't ask pk, where p is prime and k ≥ 1, he would not be able to distinguish pk - 1 and pk.That means, he should ask all the numbers pk. It's easy to prove that this sequence actually guesses all the numbers from 1 to nThe complexity is O(N1.5) or O(NloglogN) depending on primality test.SourceTask B. Div1.Let's look at the answer. It's easy to notice, that centers of that tree must turn into centers after applying the permutation. That means, permutation must have cycle with length 1 or 2 since there're at most two centers. If permutation has cycle with length 1, we can connect all the other vertices to it.For example, let's look at the permutation (4, 2, 1, 3). 2 is a cycle with length 2, so let's connect all the other vertices to it. The resulting tree edges would be (1, 2), (2, 3), (2, 4).If answer has two centers, let's remove the edge between them. The tree will split into two connected parts. It's easy to see that they will turn into each other after applying permutation. That means, all cycles should be even. It's easy to come up with answer with these restrictions. Let's connect vertices from the cycles with length 2. Then, let's connect vertices with odd position in cycles to first of these and vetices with even cycles to second one.For example, let's consider permutation (6, 5, 4, 3, 1, 2). There are two cycles: (3, 4) и (1, 6, 2, 5). We add edge (3, 4), all other vertices we connect to these two, obtaining edges (1, 3), (6, 4), (2, 3), (5, 4).The complexity is O(N).SourceTask C. Div1.Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.Let's calculate the maximum length of such a way. The coordinates are independent. By y-coordinate we're passing 1000 rectangles from 0 to 106, 109 in total. By x-coordinate we're spending 1000 to get to the next point of current rectangle and 2000 to get to next rectangle. That means, 2 * 109 + 2000000 in total, which perfectly fits.The complexity is O(n * log(n))SourceTask D. Div1.Let's optimize the first solution that comes to mind: O(m * dmax), let's calculate can[t][v] — can we get to the vertice v, while passing exactly t edges.Now, it's easy to find out that the set of edges we are able to go through changed only m times. Let's sort these edges in increasing order of di, that means for each i di ≤ di + 1. Let's calculate can[t][v] only for t = di. We can calculate can[di + 1] using can[di] by raising the adjacency matrix to the di + 1 - di power and applying it to can[di].Next step is to fix an edge with maximal di on our shortest path, let it be i. We know all the vertices we can be at moment di, so we need to calculate the shortest path to n - 1 using edges we can go through. We can even use Floyd algorithm to calculate that.The complexity of this solution is O(m * n3 * log(dmax)) and it's not enough.Next observation is that adjacency matrix contains only zeroes or ones, so we can multiply these matrixes using bitsets in O(n3 / 32).This makes complexity O(m * n3 * log(dmax) / 32), which gets accepted.SourceTask E. Div1.Let's solve an easier task first: independent of bipartivity, the color of edge changes.Then we could write a solution, which is pretty similar to solution of Dynamic Connectivity Offline task in O(nlog2n).Let's consider only cases, where edges are not being deleted from the color graph. Then, we could use DSU with storing parity of the way to the parent along with parent. Now we can find parity of the path to the root by jumping through parents and xoring the parities. Also, we can connect two components by accurately calculating the parity of the path from one root to another.Now edges are being deleted. For each edge and each color we know the segments of requests, when this edge will be in the graph of specified color. Let's build a segment tree on requests, in each vertex of the tree we store list of edges which exist on the subsegment. Every segment will be split into log parts, so, totally there would be n * log small parts.Now we can dfs this segment tree with DSU. We get inside the vertex, apply all the requests inside it, go through the children and revert DSU to initial state. We also answer requests in leafs of the segment tree.Let's return to initial task. We can't use this technique, because we don't know the exact segments of edge existence.Instead, let's do following. Initially we add each edge right until the first appearance of this edge in requests. Now, when we're in some leaf, we found out which color this edge would be right until the next appearance of this edge. So, let's update this edge on that segment. For each leaf we're going to make an update at most once, so the complexity is O(nlog2n).SourceIf anything is unclear or bad-written, ask any questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5926
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 1",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 2",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 3",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 4",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 6",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 7",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 8",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and m\n    int n = inf.readInt(2, 150, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 150, \"m\");\n    inf.readEoln();\n\n    // Read m lines\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int di = inf.readInt(0, 1000000000, \"di\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and m\n    int n = inf.readInt(2, 150, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 150, \"m\");\n    inf.readEoln();\n\n    // Read m lines\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int di = inf.readInt(0, 1000000000, \"di\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and m\n    int n = inf.readInt(2, 150, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 150, \"m\");\n    inf.readEoln();\n\n    // Read m lines\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int di = inf.readInt(0, 1000000000, \"di\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within the problem constraints\n    n = max(2, min(n, 150));\n    if (m == -1) m = n;\n    m = max(1, min(m, 150));\n\n    vector<tuple<int, int, int>> flights;\n\n    if (type == \"chain\") {\n        /* Create a chain from city 1 to city n */\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int d = 0; // No prior flights needed\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"star\") {\n        /* Star topology with city 1 as the hub */\n        m = n - 1;\n        for (int i = 2; i <= n; ++i) {\n            int a = 1;\n            int b = i;\n            int d = 0; // No prior flights needed\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"impossible\") {\n        /* Generate a graph where it's impossible to reach city n from city 1 */\n        m = n - 2;\n        for (int i = 1; i < n - 1; ++i) {\n            int a = i;\n            int b = i + 1;\n            int d = 0;\n            flights.push_back(make_tuple(a, b, d));\n        }\n        // No flights leading to city n\n    } else if (type == \"max_di\") {\n        /* Flights require maximum prior flights */\n        m = n - 1;\n        int max_d = 1e9;\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int d = max_d; // Maximum di\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"self_loop\") {\n        /* Include self-loops */\n        m = n;\n        for (int i = 1; i <= n; ++i) {\n            int a = i;\n            int b = i;\n            int d = rnd.next(0, int(1e9));\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"trap\") {\n        /* Create a graph with a tempting but impossible path */\n        n = 4;\n        m = 5;\n        flights.push_back(make_tuple(1, 2, 0));\n        flights.push_back(make_tuple(2, 4, 10));\n        flights.push_back(make_tuple(1, 3, 0));\n        flights.push_back(make_tuple(3, 4, 1));\n        flights.push_back(make_tuple(2, 3, 0));\n    } else if (type == \"zero_di\") {\n        /* All flights have di = 0 */\n        m = min(n * (n - 1), 150);\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int d = 0;\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else {\n        /* Random graph with ensured connectivity */\n        m = min(m, 150);\n        vector<int> nodes(n);\n        for (int i = 1; i <= n; ++i) nodes[i - 1] = i;\n        shuffle(nodes.begin(), nodes.end());\n\n        // Create a random spanning tree\n        for (int i = 1; i < n; ++i) {\n            int a = nodes[rnd.next(0, i - 1)];\n            int b = nodes[i];\n            int d = rnd.next(0, int(1e9));\n            flights.push_back(make_tuple(a, b, d));\n        }\n\n        // Add additional random flights\n        while ((int)flights.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int d = rnd.next(0, int(1e9));\n            flights.push_back(make_tuple(a, b, d));\n        }\n        shuffle(flights.begin(), flights.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (auto flight : flights) {\n        int a, b, d;\n        tie(a, b, d) = flight;\n        printf(\"%d %d %d\\n\", a, b, d);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within the problem constraints\n    n = max(2, min(n, 150));\n    if (m == -1) m = n;\n    m = max(1, min(m, 150));\n\n    vector<tuple<int, int, int>> flights;\n\n    if (type == \"chain\") {\n        /* Create a chain from city 1 to city n */\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int d = 0; // No prior flights needed\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"star\") {\n        /* Star topology with city 1 as the hub */\n        m = n - 1;\n        for (int i = 2; i <= n; ++i) {\n            int a = 1;\n            int b = i;\n            int d = 0; // No prior flights needed\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"impossible\") {\n        /* Generate a graph where it's impossible to reach city n from city 1 */\n        m = n - 2;\n        for (int i = 1; i < n - 1; ++i) {\n            int a = i;\n            int b = i + 1;\n            int d = 0;\n            flights.push_back(make_tuple(a, b, d));\n        }\n        // No flights leading to city n\n    } else if (type == \"max_di\") {\n        /* Flights require maximum prior flights */\n        m = n - 1;\n        int max_d = 1e9;\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int d = max_d; // Maximum di\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"self_loop\") {\n        /* Include self-loops */\n        m = n;\n        for (int i = 1; i <= n; ++i) {\n            int a = i;\n            int b = i;\n            int d = rnd.next(0, int(1e9));\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else if (type == \"trap\") {\n        /* Create a graph with a tempting but impossible path */\n        n = 4;\n        m = 5;\n        flights.push_back(make_tuple(1, 2, 0));\n        flights.push_back(make_tuple(2, 4, 10));\n        flights.push_back(make_tuple(1, 3, 0));\n        flights.push_back(make_tuple(3, 4, 1));\n        flights.push_back(make_tuple(2, 3, 0));\n    } else if (type == \"zero_di\") {\n        /* All flights have di = 0 */\n        m = min(n * (n - 1), 150);\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int d = 0;\n            flights.push_back(make_tuple(a, b, d));\n        }\n    } else {\n        /* Random graph with ensured connectivity */\n        m = min(m, 150);\n        vector<int> nodes(n);\n        for (int i = 1; i <= n; ++i) nodes[i - 1] = i;\n        shuffle(nodes.begin(), nodes.end());\n\n        // Create a random spanning tree\n        for (int i = 1; i < n; ++i) {\n            int a = nodes[rnd.next(0, i - 1)];\n            int b = nodes[i];\n            int d = rnd.next(0, int(1e9));\n            flights.push_back(make_tuple(a, b, d));\n        }\n\n        // Add additional random flights\n        while ((int)flights.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int d = rnd.next(0, int(1e9));\n            flights.push_back(make_tuple(a, b, d));\n        }\n        shuffle(flights.begin(), flights.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (auto flight : flights) {\n        int a, b, d;\n        tie(a, b, d) = flight;\n        printf(\"%d %d %d\\n\", a, b, d);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type chain\n./gen -n 5 -m 5 -type star\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type impossible\n./gen -n 5 -m 5 -type max_di\n./gen -n 5 -m 5 -type self_loop\n./gen -n 5 -m 5 -type trap\n./gen -n 5 -m 5 -type zero_di\n\n./gen -n 50 -m 75 -type chain\n./gen -n 50 -m 75 -type star\n./gen -n 50 -m 75 -type random\n./gen -n 50 -m 75 -type impossible\n./gen -n 50 -m 75 -type max_di\n./gen -n 50 -m 75 -type self_loop\n./gen -n 50 -m 75 -type trap\n./gen -n 50 -m 75 -type zero_di\n\n./gen -n 150 -m 150 -type chain\n./gen -n 150 -m 150 -type star\n./gen -n 150 -m 150 -type random\n./gen -n 150 -m 150 -type impossible\n./gen -n 150 -m 150 -type max_di\n./gen -n 150 -m 150 -type self_loop\n./gen -n 150 -m 150 -type trap\n./gen -n 150 -m 150 -type zero_di\n\n./gen -n 10 -m 15 -type random\n./gen -n 20 -m 30 -type random\n./gen -n 30 -m 45 -type random\n./gen -n 40 -m 60 -type random\n./gen -n 100 -m 120 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:49.056315",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "576/E",
      "title": "E. Покраска ребер",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест6 секунд",
      "memory_limit": "ограничение по памяти на тест600 мегабайт",
      "input_spec": "Входные данныеВ первой строке даны числа n, m, k, q (2 ≤ n ≤ 5·105, 1 ≤ m, q ≤ 5·105, 1 ≤ k ≤ 50) — число вершин, число ребер, количество цветов и количество запросов. Далее даны m ребер графа в формате ai, bi (1 ≤ ai, bi ≤ n). Далее даны q запросов в формате ei, ci (1 ≤ ei ≤ m, 1 ≤ ci ≤ k).Гарантируется, что в графе нет кратных ребер и петель.",
      "output_spec": "Выходные данныеДля каждого запроса выведите «YES» (без кавычек), если он корректен, либо «NO» (без кавычек), если этот запрос нарушит двудольность графа, образованного ребрами какого-либо цвета.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3 2 51 22 31 31 12 13 23 12 2Выходные данныеСкопироватьYESYESYESNOYES",
      "description": "E. Покраска ребер\n\nограничение по времени на тест6 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест600 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке даны числа n, m, k, q (2 ≤ n ≤ 5·105, 1 ≤ m, q ≤ 5·105, 1 ≤ k ≤ 50) — число вершин, число ребер, количество цветов и количество запросов. Далее даны m ребер графа в формате ai, bi (1 ≤ ai, bi ≤ n). Далее даны q запросов в формате ei, ci (1 ≤ ei ≤ m, 1 ≤ ci ≤ k).Гарантируется, что в графе нет кратных ребер и петель.\n\nВходные данные\n\nВыходные данныеДля каждого запроса выведите «YES» (без кавычек), если он корректен, либо «NO» (без кавычек), если этот запрос нарушит двудольность графа, образованного ребрами какого-либо цвета.\n\nВыходные данные\n\nВходные данныеСкопировать3 3 2 51 22 31 31 12 13 23 12 2Выходные данныеСкопироватьYESYESYESNOYES\n\nВходные данныеСкопировать3 3 2 51 22 31 31 12 13 23 12 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYESYESYESNOYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Всем привет!Сегодня в 19.30 по московскому времени состоится Codeforces Round #319, который настоятельно не рекомендуется кому-либо пропускать.Автор раунда — я, меня зовут Дима Горбунов, и это мой первый раунд на Codeforces. Я очень надеюсь, что вам понравится раунд, и каждый найдет себе задачу по вкусу. Для того, чтобы увеличить вероятность этого события, пожалуйста, прочтите все задачи этого контеста.Как всегда, благодарю Zlobober за неоценимую помощь при подготовке контеста и утонченный юмор, sankear за написание перекрестных решений, Delinur за перевод условий на английский язык и MikeMirzayanov за потрясающие системы Codeforces и Polygon.У вас будет два часа на то, чтобы решить 5 задач. Успехов!UPD. Разбалловка в первом дивизионе — 500-1250-1250-2000-2750.Во втором — 500-1250-1500-2250-2250.UPD2. Из-за тестов большого размера по некоторым задачам, системное тестирование будет идти медленно (возможно, займёт несколько часов). Благодарим за терпение!UPD3. Разбор можно найти по ссылке.UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826Отдельный респект al13n за правильное решение задачи Div1.E во время контеста!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1193
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces",
          "content": "Задача A. Div2.Заметим, что число x может встречаться в столбце i только один раз — в строке x / i. Переберем столбец i, проверим, что x делится нацело на i, а также x / i ≤ n. Если все условия выполнены, обновим ответ.Асимптотика — O(n)КодЗадача B. Div2.Рассмотрим два случая: n > m и n ≤ m.Пусть n > m, рассмотрим суммы на префиксах. По принципу Дирихле, найдутся две равные суммы по модулю m. Пусть Slmodm = Srmodm. Тогда сумма чисел на отрезке с l + 1 по r по модулю m равна нулю, то есть ответ точно \"YES\".Пусть n ≤ m, то решим задачу динамикой за O(m2). Пусть can[i][r] — можем ли мы, используя первые i предметов, получить остаток r от деления на m. Переходы в динамике понятны: либо мы берем предмет и переходим в состояние can[i + 1][(r + ai) mod m], либо не берем и переходим в состояние can[i + 1][r].Асимптотика — O(m2).КодЗадача A. Div1.Пусть Петя не спросил число pk, где p — простое, а k ≥ 1. Тогда, Петя не сможет отличить число pk - 1 от числа pk.Значит, нужно спросить все числа вида pk, где p — простое, а k ≥ 1. Несложно убедиться, что это позволит угадать и все остальные числа.Асимптотика O(N1.5) или O(NloglogN) в зависимости от теста на простоту.КодЗадачи B. Div1.Рассмотрим дерево-ответ. Заметим, что центры этого дерева могут перейти только в центры при применении перестановки. Это означает, что в перестановке обязательно должен быть цикл длины 1 или 2.Пусть в перестановке есть неподвижная точка. Тогда мы можем подсоединить ребрами к этой вершине все остальные. Несложно убедиться, что это корректный ответ.Например, пусть дана перестановка (4, 2, 1, 3). В перестановке есть неподвижная точка 2, поэтому подсоединим ко второй вершине все остальные. Получатся ребра дерева (1, 2), (2, 3), (2, 4).Пусть в дереве-ответе есть два центра. Удалим ребро между ними, дерево разобьется на две компоненты. Несложно понять, что они должны перейти друг в друга при применении перестановки. Это означает, что все циклы перестановки должны быть четной длины. Понятно, как построить ответ, если все циклы четной длины, и есть цикл длины два. Проведем ребро между вершинами из цикла длины два, вершины всех остальных циклов будем присоединять по очереди к центрам.Например, рассмотрим перестановку (6, 5, 4, 3, 1, 2). В перестановке есть два цикла: (3, 4) и (1, 6, 2, 5). Соединим ребром вершины (3, 4), все вершины другого цикла присоединим по очереди к этим двум вершинам, получим ребра (1, 3), (6, 4), (2, 3), (5, 4).Асимптотика — O(N).КодЗадача C. Div1.Разобьем квадрат 106 × 106 вертикальными линиями на 1000 прямоугольников 103 × 106. Пронумеруем эти прямоугольники от 1 до n в порядке слева направо. Обойдем их тоже слева направо, а внутри каждого прямоугольника обойдем точки по возрастанию y-координаты, если это четный по номеру прямоугольник, и по убыванию, если нечетный.Посчитаем длину такого пути, будем считать независимо по каждой координате. По y-координате мы пройдем суммарно 1000 прямоугольников от 0 до 106, то есть суммарно 109, По x-координате, чтобы дойти до следующей точки внутри прямоугольника, мы потратим не более 1000 на точку, и 1000 раз пройдем не более 2000 до следующего прямоугольника, то есть суммарно 109 + 2000000.Итого, длина пути не более 2 * 109 + 2000000, что подходит под ограничения на длину.Асимптотика — O(n * log(n))КодЗадача D. Div1.Будем оптимизировать первое же решение, которое приходит в голову за O(m * dmax): посчитаем can[t][v] — можно ли добраться до вершины v, пройдя по ровно t ребрам.Теперь заметим, что множество ребер, по которому мы можем ходить меняется только m раз. Отсортируем ребра в порядке возрастания di, т.е. для всех i di ≤ di + 1. Будем считать динамику can[t][v] только для t = di. Пусть мы хотим перейти от can[di] к can[di + 1]. Поскольку набор ребер не меняется с момента di до di + 1, мы можем возвести матрицу смежности в степень di + 1 - di и применить ее к can[di]. Пусть мы насчитали все can[di][v]. Теперь зафиксирует ребро с максимальным di, по которому мы пройдем в нашем кратчайшем пути. Мы знаем все вершины, в которых мы можем находиться в момент di, далее нужно найти кратчайший путь из них в вершину m по открытым для нас ребрам и обновить ответ. Матрицу кратчайших расстояний можно посчитать Флойдом, поэтому обновление ответа не составит труда.Получилось решение за O(m * n3 * log(dmax)), которое, к сожалению, работает долго.Далее нужно заметить, что матрица смежности состоит из ноликов и единичек, поэтому её можно возводить в степень битовым сжатием за O(n3 / 32). Это дает решение за O(m * n3 * log(dmax) / 32), что спокойно заходит по времени.КодЗадача E. Div1.Сначала решим чуть более простую задачу: пусть вне зависимости от двудольности/недвудольности запросы выполняются, а от нас требуется лишь ответить, будет ли граф двудольным/недвудольным после запроса.Тогда мы могли бы применить решение, похожее на решение задачи Dynamic Connectivity Offline за O(nlog2n). Опишем его подробнее:Вначале пусть ребра только добавляются. Тогда можно воспользоваться системой непересекающихся множеств, где, кроме предка, будем хранить четность пути до предка, а также флаг двудольности текущего графа. Теперь мы можем найти четность пути до корня — просто пропрыгать до предка, проксорить четности. Теперь, когда мы проводим ребро между двумя компонентами, мы можем посчитать четность путей до вершин этой ребра, а значит, и установить четность прыжка из корня одной компоненты в корень другой компоненты. Если ребро проходит внутри одной компоненты и четности пути до корня совпадают, нужно убрать флаг двудольности текущего графа.Теперь пусть ребра иногда удаляются. Для каждого ребра и каждого цвета мы знаем отрезки запросов, когда это ребро будет в графе заданного цвета. Давайте построим дерево отрезков на запросах, в каждой вершине будем хранить список ребер, которые будут включены на этом подотрезке. Каждый отрезок дерево отрезков разобьет на log кусочков, поэтому в сумме количество добавлений ребер на кусочке будет порядка n * log.Теперь, можно обойти это дерево отрезков в глубину с системой непересекающихся множеств с откатами. Мы входим в вершины, применяем все запросы добавления ребра в данной вершине, обходим потомков, а затем откатываем снм до состояния, в котором оно было на входе в эту вершину. Когда мы находимся в листе, отвечаем на соответствующий запрос.Вернемся к нашей задаче. Вышеописанную технику в явном виде мы применить не можем, потому что не знаем точно, на каких отрезках запросов ребра будут существовать.Зато мы можем сделать следующее. Изначально применим операцию до первого момента появления ребра в запросах. Теперь, когда мы находимся в листе, мы узнали, какого цвета это ребро будет до следующего его появления в запросах. Поэтому, давайте сделаем обновление на отрезке со следующего запроса до следующего появления этого ребра. Для каждого листа мы сделаем не более одного обновления, поэтому суммарное время работы O(nlog2n).Асимптотика — O(nlog2n).КодЕсли что-то неясно, непонятно или невнятно написано, задавайте любые вопросы.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6982
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 1",
          "code": "a += b;\nif (a >= mod) a -= mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 2",
          "code": "a += b;\nif (a >= mod) a -= mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 3",
          "code": "a = (a + b) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 4",
          "code": "a = (a + b) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 6",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 7",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 8",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 9",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 10",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 11",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 12",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readSpace();\n\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readSpace();\n\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readSpace();\n\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    // To store edges and check for duplicates\n    set<pair<int,int>> edgeSet;\n    for (int i = 1; i <= m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a loop (%d, %d)\", i, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Duplicate edge (%d, %d)\", u, v);\n\n        edgeSet.insert(edge);\n    }\n\n    for (int i = 1; i <= q; ++i) {\n        int ei = inf.readInt(1, m, \"e_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, k, \"c_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readSpace();\n\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readSpace();\n\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readSpace();\n\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    // To store edges and check for duplicates\n    set<pair<int,int>> edgeSet;\n    for (int i = 1; i <= m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a loop (%d, %d)\", i, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Duplicate edge (%d, %d)\", u, v);\n\n        edgeSet.insert(edge);\n    }\n\n    for (int i = 1; i <= q; ++i) {\n        int ei = inf.readInt(1, m, \"e_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, k, \"c_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readSpace();\n\n    int m = inf.readInt(1, 500000, \"m\");\n    inf.readSpace();\n\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readSpace();\n\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    // To store edges and check for duplicates\n    set<pair<int,int>> edgeSet;\n    for (int i = 1; i <= m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a loop (%d, %d)\", i, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Duplicate edge (%d, %d)\", u, v);\n\n        edgeSet.insert(edge);\n    }\n\n    for (int i = 1; i <= q; ++i) {\n        int ei = inf.readInt(1, m, \"e_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, k, \"c_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int q = opt<int>(\"q\");\n    string graphType = opt<string>(\"graphType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Constraints checking\n    ensure(2 <= n && n <= 500000);\n    ensure(1 <= m && m <= 500000);\n    ensure(1 <= k && k <= 50);\n    ensure(1 <= q && q <= 500000);\n\n    // Generate the edges according to graphType\n    vector<pair<int,int>> edges;\n    set<pair<int,int>> edgeSet;\n\n    if (graphType == \"random\") {\n        // Random edges\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue; // no loops\n            if (a > b) swap(a, b); // normalize to avoid duplicates\n            if (edgeSet.count({a,b})) continue; // no multiple edges\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    } else if (graphType == \"cycle\") {\n        // Generate a cycle\n        ensure(n >= 3 && m >= n);\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n            edgeSet.insert({i, i+1});\n        }\n        edges.push_back({n, 1});\n        edgeSet.insert({1, n});\n        // Add random edges if m > n\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            if (edgeSet.count({a,b})) continue;\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    } else if (graphType == \"bipartite\") {\n        // Generate a bipartite graph\n        // Partition nodes into two sets\n        vector<int> part(n+1);\n        for (int i = 1; i <= n; ++i) {\n            part[i] = rnd.next(0,1); // 0 or 1\n        }\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (part[a] == part[b]) continue; // skip same part to ensure bipartite\n            if (a > b) swap(a,b);\n            if (edgeSet.count({a,b})) continue;\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    } else if (graphType == \"complete\") {\n        ensure(m <= 1LL*n*(n-1)/2);\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a+1; b <= n; ++b) {\n                edges.push_back({a,b});\n                if (edges.size() == m) break;\n            }\n            if (edges.size() == m) break;\n        }\n    } else {\n        // Default to random\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue; // no loops\n            if (a > b) swap(a, b); // normalize to avoid duplicates\n            if (edgeSet.count({a,b})) continue; // no multiple edges\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    }\n\n    // Output n m k q\n    printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n    // Output the edges\n    for (auto p : edges) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    // Generate the queries according to queryType\n    vector<pair<int,int>> queries;\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int ei = rnd.next(1, m);\n            int ci = rnd.next(1, k);\n            queries.push_back({ei, ci});\n        }\n    } else if (queryType == \"acceptAll\") {\n        // Generate queries that will always be accepted\n        for (int i = 0; i < q; ++i) {\n            int ei = (i % m) +1;\n            int ci = (i % k) +1;\n            queries.push_back({ei, ci});\n        }\n    } else if (queryType == \"alternating\") {\n        // Try to generate queries that alternately get accepted and possibly rejected\n        int currColor = 1;\n        for (int i = 0; i < q; ++i) {\n            int ei = (i % m) +1;\n            int ci;\n            if (i % 2 == 0) {\n                ci = currColor;\n            } else {\n                ci = (currColor % k) +1;\n                currColor = ci;\n            }\n            queries.push_back({ei, ci});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int ei = rnd.next(1, m);\n            int ci = rnd.next(1, k);\n            queries.push_back({ei, ci});\n        }\n    }\n\n    // Output the queries\n    for (auto p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int q = opt<int>(\"q\");\n    string graphType = opt<string>(\"graphType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Constraints checking\n    ensure(2 <= n && n <= 500000);\n    ensure(1 <= m && m <= 500000);\n    ensure(1 <= k && k <= 50);\n    ensure(1 <= q && q <= 500000);\n\n    // Generate the edges according to graphType\n    vector<pair<int,int>> edges;\n    set<pair<int,int>> edgeSet;\n\n    if (graphType == \"random\") {\n        // Random edges\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue; // no loops\n            if (a > b) swap(a, b); // normalize to avoid duplicates\n            if (edgeSet.count({a,b})) continue; // no multiple edges\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    } else if (graphType == \"cycle\") {\n        // Generate a cycle\n        ensure(n >= 3 && m >= n);\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n            edgeSet.insert({i, i+1});\n        }\n        edges.push_back({n, 1});\n        edgeSet.insert({1, n});\n        // Add random edges if m > n\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            if (edgeSet.count({a,b})) continue;\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    } else if (graphType == \"bipartite\") {\n        // Generate a bipartite graph\n        // Partition nodes into two sets\n        vector<int> part(n+1);\n        for (int i = 1; i <= n; ++i) {\n            part[i] = rnd.next(0,1); // 0 or 1\n        }\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (part[a] == part[b]) continue; // skip same part to ensure bipartite\n            if (a > b) swap(a,b);\n            if (edgeSet.count({a,b})) continue;\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    } else if (graphType == \"complete\") {\n        ensure(m <= 1LL*n*(n-1)/2);\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a+1; b <= n; ++b) {\n                edges.push_back({a,b});\n                if (edges.size() == m) break;\n            }\n            if (edges.size() == m) break;\n        }\n    } else {\n        // Default to random\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue; // no loops\n            if (a > b) swap(a, b); // normalize to avoid duplicates\n            if (edgeSet.count({a,b})) continue; // no multiple edges\n            edges.push_back({a,b});\n            edgeSet.insert({a,b});\n        }\n    }\n\n    // Output n m k q\n    printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n    // Output the edges\n    for (auto p : edges) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    // Generate the queries according to queryType\n    vector<pair<int,int>> queries;\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int ei = rnd.next(1, m);\n            int ci = rnd.next(1, k);\n            queries.push_back({ei, ci});\n        }\n    } else if (queryType == \"acceptAll\") {\n        // Generate queries that will always be accepted\n        for (int i = 0; i < q; ++i) {\n            int ei = (i % m) +1;\n            int ci = (i % k) +1;\n            queries.push_back({ei, ci});\n        }\n    } else if (queryType == \"alternating\") {\n        // Try to generate queries that alternately get accepted and possibly rejected\n        int currColor = 1;\n        for (int i = 0; i < q; ++i) {\n            int ei = (i % m) +1;\n            int ci;\n            if (i % 2 == 0) {\n                ci = currColor;\n            } else {\n                ci = (currColor % k) +1;\n                currColor = ci;\n            }\n            queries.push_back({ei, ci});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int ei = rnd.next(1, m);\n            int ci = rnd.next(1, k);\n            queries.push_back({ei, ci});\n        }\n    }\n\n    // Output the queries\n    for (auto p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 15 -k 3 -q 20 -graphType random -queryType random\n./gen -n 10 -m 20 -k 5 -q 25 -graphType cycle -queryType random\n./gen -n 10 -m 15 -k 2 -q 10 -graphType bipartite -queryType random\n./gen -n 1000 -m 5000 -k 50 -q 5000 -graphType random -queryType random\n./gen -n 10000 -m 100000 -k 1 -q 100000 -graphType random -queryType acceptAll\n./gen -n 100000 -m 500000 -k 2 -q 500000 -graphType random -queryType random\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType random -queryType random\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType bipartite -queryType random\n./gen -n 500000 -m 500000 -k 1 -q 500000 -graphType cycle -queryType random\n./gen -n 500000 -m 500000 -k 2 -q 500000 -graphType random -queryType acceptAll\n./gen -n 500000 -m 500000 -k 5 -q 500000 -graphType random -queryType acceptAll\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType random -queryType acceptAll\n./gen -n 500000 -m 500000 -k 3 -q 500000 -graphType bipartite -queryType random\n./gen -n 500000 -m 500000 -k 3 -q 500000 -graphType random -queryType random\n./gen -n 2 -m 1 -k 1 -q 1 -graphType random -queryType random\n./gen -n 3 -m 3 -k 2 -q 5 -graphType cycle -queryType random\n./gen -n 4 -m 3 -k 2 -q 5 -graphType random -queryType random\n./gen -n 100 -m 500 -k 10 -q 1000 -graphType random -queryType random\n./gen -n 1000 -m 2000 -k 30 -q 5000 -graphType random -queryType random\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType complete -queryType random\n./gen -n 5 -m 10 -k 2 -q 10 -graphType cycle -queryType random\n./gen -n 100 -m 200 -k 5 -q 500 -graphType bipartite -queryType acceptAll\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType random -queryType alternating\n./gen -n 500000 -m 500000 -k 1 -q 500000 -graphType cycle -queryType alternating\n./gen -n 500000 -m 500000 -k 1 -q 500000 -graphType random -queryType acceptAll\n./gen -n 500000 -m 500000 -k 1 -q 500000 -graphType complete -queryType acceptAll\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType bipartite -queryType alternating\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType bipartite -queryType acceptAll\n./gen -n 500000 -m 500000 -k 50 -q 500000 -graphType bipartite -queryType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:51.011723",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "577/A",
      "title": "A. Multiplication Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains numbers n and x (1 ≤ n ≤ 105, 1 ≤ x ≤ 109) — the size of the table and the number that we are looking for in the table.",
      "output_spec": "OutputPrint a single number: the number of times x occurs in the table.",
      "sample_tests": "ExamplesInputCopy10 5OutputCopy2InputCopy6 12OutputCopy4InputCopy5 13OutputCopy0",
      "description": "A. Multiplication Table\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe single line contains numbers n and x (1 ≤ n ≤ 105, 1 ≤ x ≤ 109) — the size of the table and the number that we are looking for in the table.\n\nOutputPrint a single number: the number of times x occurs in the table.\n\nInputCopy10 5OutputCopy2InputCopy6 12OutputCopy4InputCopy5 13OutputCopy0\n\nInputCopy10 5\n\nOutputCopy2\n\nInputCopy6 12\n\nOutputCopy4\n\nInputCopy5 13\n\nOutputCopy0\n\nNoteA table for the second sample test is given below. The occurrences of number 12 are marked bold.",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Hey there!Today at 19.30, Moscow time there will be Codeforces Round #319 and it's strongly disadvised to skip it.I'm the author of this round, my name is Dima Gorbunov and it's my first round on Codeforces. I really hope you're going to like it and everyone will find a satisfying problem. In order to increase the probability of finding that task, please read all of the problem statements.As usual, I'd like to thank Zlobober for his invaluable help and his special sense of humour, sankear for coding additional solutions, Delinur for the English statements and MikeMirzayanov for amazing systems Codeforces and Polygon.You're going to have two hours to solve 5 problems. Good luck!UPD. The scores in first division are 500-1250-1250-2000-2750.In second division — 500-1250-1500-2250-2250,UPD2. Because of large size tests for some of the problems, system testing will be slow (it's possible that it will take several hours). Thanks for your patience!UPD3. English editorial is also accessible. UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826A special respect to al13n for correct solution of Div1.E during the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1189
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces",
          "content": "Task A. Div2.It's easy to see that number x can appear in column i only once — in row x / i. For every column i, let's check that x divides i and x / i ≤ n. If all requirements are met, we'll update the answer.The complexity is O(n)SourceTask B. Div2.Let's consider two cases: n > m and n ≤ m.If n > m, let's look at prefix sums. By pigeonhole principle, there are two equals sums modulo m. Assume Slmodm = Srmodm. Then the sum on segment [l + 1, r] equals zero modulo m, that means the answer is definitely \"YES\".If n ≤ m, we'll solve this task using dynamic programming in O(m2) time. Assume can[i][r] means if we can achieve the sum equal to r modulo m using only first i - 1 items. The updates in this dynamic programming are obvious: we either take number ai and go to the state can[i + 1][(r + ai) mod m] or not, then we'll get to the state can[i + 1][r].The complexity is O(m2).SourceTask A. Div1.If Petya didn't ask pk, where p is prime and k ≥ 1, he would not be able to distinguish pk - 1 and pk.That means, he should ask all the numbers pk. It's easy to prove that this sequence actually guesses all the numbers from 1 to nThe complexity is O(N1.5) or O(NloglogN) depending on primality test.SourceTask B. Div1.Let's look at the answer. It's easy to notice, that centers of that tree must turn into centers after applying the permutation. That means, permutation must have cycle with length 1 or 2 since there're at most two centers. If permutation has cycle with length 1, we can connect all the other vertices to it.For example, let's look at the permutation (4, 2, 1, 3). 2 is a cycle with length 2, so let's connect all the other vertices to it. The resulting tree edges would be (1, 2), (2, 3), (2, 4).If answer has two centers, let's remove the edge between them. The tree will split into two connected parts. It's easy to see that they will turn into each other after applying permutation. That means, all cycles should be even. It's easy to come up with answer with these restrictions. Let's connect vertices from the cycles with length 2. Then, let's connect vertices with odd position in cycles to first of these and vetices with even cycles to second one.For example, let's consider permutation (6, 5, 4, 3, 1, 2). There are two cycles: (3, 4) и (1, 6, 2, 5). We add edge (3, 4), all other vertices we connect to these two, obtaining edges (1, 3), (6, 4), (2, 3), (5, 4).The complexity is O(N).SourceTask C. Div1.Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.Let's calculate the maximum length of such a way. The coordinates are independent. By y-coordinate we're passing 1000 rectangles from 0 to 106, 109 in total. By x-coordinate we're spending 1000 to get to the next point of current rectangle and 2000 to get to next rectangle. That means, 2 * 109 + 2000000 in total, which perfectly fits.The complexity is O(n * log(n))SourceTask D. Div1.Let's optimize the first solution that comes to mind: O(m * dmax), let's calculate can[t][v] — can we get to the vertice v, while passing exactly t edges.Now, it's easy to find out that the set of edges we are able to go through changed only m times. Let's sort these edges in increasing order of di, that means for each i di ≤ di + 1. Let's calculate can[t][v] only for t = di. We can calculate can[di + 1] using can[di] by raising the adjacency matrix to the di + 1 - di power and applying it to can[di].Next step is to fix an edge with maximal di on our shortest path, let it be i. We know all the vertices we can be at moment di, so we need to calculate the shortest path to n - 1 using edges we can go through. We can even use Floyd algorithm to calculate that.The complexity of this solution is O(m * n3 * log(dmax)) and it's not enough.Next observation is that adjacency matrix contains only zeroes or ones, so we can multiply these matrixes using bitsets in O(n3 / 32).This makes complexity O(m * n3 * log(dmax) / 32), which gets accepted.SourceTask E. Div1.Let's solve an easier task first: independent of bipartivity, the color of edge changes.Then we could write a solution, which is pretty similar to solution of Dynamic Connectivity Offline task in O(nlog2n).Let's consider only cases, where edges are not being deleted from the color graph. Then, we could use DSU with storing parity of the way to the parent along with parent. Now we can find parity of the path to the root by jumping through parents and xoring the parities. Also, we can connect two components by accurately calculating the parity of the path from one root to another.Now edges are being deleted. For each edge and each color we know the segments of requests, when this edge will be in the graph of specified color. Let's build a segment tree on requests, in each vertex of the tree we store list of edges which exist on the subsegment. Every segment will be split into log parts, so, totally there would be n * log small parts.Now we can dfs this segment tree with DSU. We get inside the vertex, apply all the requests inside it, go through the children and revert DSU to initial state. We also answer requests in leafs of the segment tree.Let's return to initial task. We can't use this technique, because we don't know the exact segments of edge existence.Instead, let's do following. Initially we add each edge right until the first appearance of this edge in requests. Now, when we're in some leaf, we found out which color this edge would be right until the next appearance of this edge. So, let's update this edge on that segment. For each leaf we're going to make an update at most once, so the complexity is O(nlog2n).SourceIf anything is unclear or bad-written, ask any questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5926
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 1",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 2",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 3",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 4",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 6",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 7",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 8",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x = -1; // We will determine x based on the type\n\n    if (type == \"random\") {\n        x = rnd.next(1LL, 1LL * n * n);\n    } else if (type == \"max_n_random_x\") {\n        n = 100000; // Max value of n\n        x = rnd.next(1LL, 1LL * n * n);\n    } else if (type == \"large_x_small_n\") {\n        n = rnd.next(1, 10); // Small n\n        x = rnd.next(1e8, 1e9); // Large x\n    } else if (type == \"x_is_n_squared\") {\n        x = 1LL * n * n;\n    } else if (type == \"x_is_prime\") {\n        // Generate a random prime x in [2, min(1e9, n^2)]\n        vector<long long> primes;\n        long long max_x = min(1000000000LL, 1LL * n * n);\n        long long min_x = max(2LL, max_x - 1000); // Check last 1000 numbers for primes\n        for (long long i = min_x; i <= max_x; ++i) {\n            bool is_prime = true;\n            for (long long j = 2; j * j <= i; ++j) {\n                if (i % j == 0) { is_prime = false; break; }\n            }\n            if (is_prime) primes.push_back(i);\n        }\n        if (primes.empty())\n            x = max_x;\n        else\n            x = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"x_has_high_divisors\") {\n        // Choose x as the product of small primes to have many divisors\n        vector<int> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n        int k = rnd.next(2, min(n, 5)); // Choose up to 5 primes\n        x = 1;\n        for (int i = 0; i < k; ++i) {\n            int p = small_primes[i];\n            x *= p;\n            if (x > 1e9) {\n                x /= p;\n                break;\n            }\n        }\n    } else if (type == \"x_gt_n_squared\") {\n        x = 1LL * n * n + rnd.next(1LL, 1000LL); // x greater than n^2\n        if (x > 1e9) x = 1e9;\n    } else if (type == \"x_eq_n\") {\n        x = n;\n    } else if (type == \"x_eq_n_minus_1\") {\n        x = n - 1;\n    } else if (type == \"x_is_1\") {\n       x = 1;\n    } else if (type == \"x_is_n_over_2\") {\n       x = n / 2;\n    } else if (type == \"x_is_square_number\") {\n       int s = rnd.next(1, n);\n       x = 1LL * s * s;\n    } else {\n        // Default to random\n        x = rnd.next(1LL, 1LL * n * n);\n    }\n\n    printf(\"%d %lld\\n\", n, x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x = -1; // We will determine x based on the type\n\n    if (type == \"random\") {\n        x = rnd.next(1LL, 1LL * n * n);\n    } else if (type == \"max_n_random_x\") {\n        n = 100000; // Max value of n\n        x = rnd.next(1LL, 1LL * n * n);\n    } else if (type == \"large_x_small_n\") {\n        n = rnd.next(1, 10); // Small n\n        x = rnd.next(1e8, 1e9); // Large x\n    } else if (type == \"x_is_n_squared\") {\n        x = 1LL * n * n;\n    } else if (type == \"x_is_prime\") {\n        // Generate a random prime x in [2, min(1e9, n^2)]\n        vector<long long> primes;\n        long long max_x = min(1000000000LL, 1LL * n * n);\n        long long min_x = max(2LL, max_x - 1000); // Check last 1000 numbers for primes\n        for (long long i = min_x; i <= max_x; ++i) {\n            bool is_prime = true;\n            for (long long j = 2; j * j <= i; ++j) {\n                if (i % j == 0) { is_prime = false; break; }\n            }\n            if (is_prime) primes.push_back(i);\n        }\n        if (primes.empty())\n            x = max_x;\n        else\n            x = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"x_has_high_divisors\") {\n        // Choose x as the product of small primes to have many divisors\n        vector<int> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n        int k = rnd.next(2, min(n, 5)); // Choose up to 5 primes\n        x = 1;\n        for (int i = 0; i < k; ++i) {\n            int p = small_primes[i];\n            x *= p;\n            if (x > 1e9) {\n                x /= p;\n                break;\n            }\n        }\n    } else if (type == \"x_gt_n_squared\") {\n        x = 1LL * n * n + rnd.next(1LL, 1000LL); // x greater than n^2\n        if (x > 1e9) x = 1e9;\n    } else if (type == \"x_eq_n\") {\n        x = n;\n    } else if (type == \"x_eq_n_minus_1\") {\n        x = n - 1;\n    } else if (type == \"x_is_1\") {\n       x = 1;\n    } else if (type == \"x_is_n_over_2\") {\n       x = n / 2;\n    } else if (type == \"x_is_square_number\") {\n       int s = rnd.next(1, n);\n       x = 1LL * s * s;\n    } else {\n        // Default to random\n        x = rnd.next(1LL, 1LL * n * n);\n    }\n\n    printf(\"%d %lld\\n\", n, x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type x_is_1\n./gen -n 1 -type x_is_n_squared\n./gen -n 1 -type random\n./gen -n 2 -type x_is_n_squared\n./gen -n 2 -type x_is_prime\n./gen -n 2 -type x_eq_n\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 10 -type x_is_n_squared\n./gen -n 10 -type x_is_square_number\n./gen -n 10 -type x_has_high_divisors\n./gen -n 10 -type x_eq_n\n./gen -n 10 -type x_eq_n_minus_1\n./gen -n 100 -type random\n./gen -n 100 -type x_is_prime\n./gen -n 1000 -type random\n./gen -n 1000 -type x_has_high_divisors\n./gen -n 100000 -type max_n_random_x\n./gen -n 100000 -type x_is_n_squared\n./gen -n 100000 -type x_gt_n_squared\n./gen -n 100000 -type x_eq_n\n./gen -n 100000 -type x_eq_n_minus_1\n./gen -n 99999 -type x_is_1\n./gen -n 1 -type x_gt_n_squared\n./gen -n 100000 -type x_is_square_number\n./gen -n 100000 -type x_is_prime\n./gen -n 99999 -type x_is_n_over_2\n./gen -n 99998 -type x_is_square_number\n./gen -n 2 -type large_x_small_n\n./gen -n 5 -type large_x_small_n\n./gen -n 10 -type large_x_small_n\n./gen -n 50 -type x_is_1\n./gen -n 50 -type x_is_n_over_2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:52.823316",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "577/B",
      "title": "B. Modulo Sum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers, n and m (1 ≤ n ≤ 106, 2 ≤ m ≤ 103) — the size of the original sequence and the number such that sum should be divisible by it.The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 109).",
      "output_spec": "OutputIn the single line print either \"YES\" (without the quotes) if there exists the sought subsequence, or \"NO\" (without the quotes), if such subsequence doesn't exist.",
      "sample_tests": "ExamplesInputCopy3 51 2 3OutputCopyYESInputCopy1 65OutputCopyNOInputCopy4 63 1 1 3OutputCopyYESInputCopy6 65 5 5 5 5 5OutputCopyYES",
      "description": "B. Modulo Sum\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two numbers, n and m (1 ≤ n ≤ 106, 2 ≤ m ≤ 103) — the size of the original sequence and the number such that sum should be divisible by it.The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 109).\n\nOutputIn the single line print either \"YES\" (without the quotes) if there exists the sought subsequence, or \"NO\" (without the quotes), if such subsequence doesn't exist.\n\nInputCopy3 51 2 3OutputCopyYESInputCopy1 65OutputCopyNOInputCopy4 63 1 1 3OutputCopyYESInputCopy6 65 5 5 5 5 5OutputCopyYES\n\nInputCopy3 51 2 3\n\nOutputCopyYES\n\nInputCopy1 65\n\nOutputCopyNO\n\nInputCopy4 63 1 1 3\n\nOutputCopyYES\n\nInputCopy6 65 5 5 5 5 5\n\nOutputCopyYES\n\nNoteIn the first sample test you can choose numbers 2 and 3, the sum of which is divisible by 5.In the second sample test the single non-empty subsequence of numbers is a single number 5. Number 5 is not divisible by 6, that is, the sought subsequence doesn't exist.In the third sample test you need to choose two numbers 3 on the ends.In the fourth sample test you can take the whole subsequence.",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Hey there!Today at 19.30, Moscow time there will be Codeforces Round #319 and it's strongly disadvised to skip it.I'm the author of this round, my name is Dima Gorbunov and it's my first round on Codeforces. I really hope you're going to like it and everyone will find a satisfying problem. In order to increase the probability of finding that task, please read all of the problem statements.As usual, I'd like to thank Zlobober for his invaluable help and his special sense of humour, sankear for coding additional solutions, Delinur for the English statements and MikeMirzayanov for amazing systems Codeforces and Polygon.You're going to have two hours to solve 5 problems. Good luck!UPD. The scores in first division are 500-1250-1250-2000-2750.In second division — 500-1250-1500-2250-2250,UPD2. Because of large size tests for some of the problems, system testing will be slow (it's possible that it will take several hours). Thanks for your patience!UPD3. English editorial is also accessible. UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826A special respect to al13n for correct solution of Div1.E during the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1189
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces",
          "content": "Task A. Div2.It's easy to see that number x can appear in column i only once — in row x / i. For every column i, let's check that x divides i and x / i ≤ n. If all requirements are met, we'll update the answer.The complexity is O(n)SourceTask B. Div2.Let's consider two cases: n > m and n ≤ m.If n > m, let's look at prefix sums. By pigeonhole principle, there are two equals sums modulo m. Assume Slmodm = Srmodm. Then the sum on segment [l + 1, r] equals zero modulo m, that means the answer is definitely \"YES\".If n ≤ m, we'll solve this task using dynamic programming in O(m2) time. Assume can[i][r] means if we can achieve the sum equal to r modulo m using only first i - 1 items. The updates in this dynamic programming are obvious: we either take number ai and go to the state can[i + 1][(r + ai) mod m] or not, then we'll get to the state can[i + 1][r].The complexity is O(m2).SourceTask A. Div1.If Petya didn't ask pk, where p is prime and k ≥ 1, he would not be able to distinguish pk - 1 and pk.That means, he should ask all the numbers pk. It's easy to prove that this sequence actually guesses all the numbers from 1 to nThe complexity is O(N1.5) or O(NloglogN) depending on primality test.SourceTask B. Div1.Let's look at the answer. It's easy to notice, that centers of that tree must turn into centers after applying the permutation. That means, permutation must have cycle with length 1 or 2 since there're at most two centers. If permutation has cycle with length 1, we can connect all the other vertices to it.For example, let's look at the permutation (4, 2, 1, 3). 2 is a cycle with length 2, so let's connect all the other vertices to it. The resulting tree edges would be (1, 2), (2, 3), (2, 4).If answer has two centers, let's remove the edge between them. The tree will split into two connected parts. It's easy to see that they will turn into each other after applying permutation. That means, all cycles should be even. It's easy to come up with answer with these restrictions. Let's connect vertices from the cycles with length 2. Then, let's connect vertices with odd position in cycles to first of these and vetices with even cycles to second one.For example, let's consider permutation (6, 5, 4, 3, 1, 2). There are two cycles: (3, 4) и (1, 6, 2, 5). We add edge (3, 4), all other vertices we connect to these two, obtaining edges (1, 3), (6, 4), (2, 3), (5, 4).The complexity is O(N).SourceTask C. Div1.Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.Let's calculate the maximum length of such a way. The coordinates are independent. By y-coordinate we're passing 1000 rectangles from 0 to 106, 109 in total. By x-coordinate we're spending 1000 to get to the next point of current rectangle and 2000 to get to next rectangle. That means, 2 * 109 + 2000000 in total, which perfectly fits.The complexity is O(n * log(n))SourceTask D. Div1.Let's optimize the first solution that comes to mind: O(m * dmax), let's calculate can[t][v] — can we get to the vertice v, while passing exactly t edges.Now, it's easy to find out that the set of edges we are able to go through changed only m times. Let's sort these edges in increasing order of di, that means for each i di ≤ di + 1. Let's calculate can[t][v] only for t = di. We can calculate can[di + 1] using can[di] by raising the adjacency matrix to the di + 1 - di power and applying it to can[di].Next step is to fix an edge with maximal di on our shortest path, let it be i. We know all the vertices we can be at moment di, so we need to calculate the shortest path to n - 1 using edges we can go through. We can even use Floyd algorithm to calculate that.The complexity of this solution is O(m * n3 * log(dmax)) and it's not enough.Next observation is that adjacency matrix contains only zeroes or ones, so we can multiply these matrixes using bitsets in O(n3 / 32).This makes complexity O(m * n3 * log(dmax) / 32), which gets accepted.SourceTask E. Div1.Let's solve an easier task first: independent of bipartivity, the color of edge changes.Then we could write a solution, which is pretty similar to solution of Dynamic Connectivity Offline task in O(nlog2n).Let's consider only cases, where edges are not being deleted from the color graph. Then, we could use DSU with storing parity of the way to the parent along with parent. Now we can find parity of the path to the root by jumping through parents and xoring the parities. Also, we can connect two components by accurately calculating the parity of the path from one root to another.Now edges are being deleted. For each edge and each color we know the segments of requests, when this edge will be in the graph of specified color. Let's build a segment tree on requests, in each vertex of the tree we store list of edges which exist on the subsegment. Every segment will be split into log parts, so, totally there would be n * log small parts.Now we can dfs this segment tree with DSU. We get inside the vertex, apply all the requests inside it, go through the children and revert DSU to initial state. We also answer requests in leafs of the segment tree.Let's return to initial task. We can't use this technique, because we don't know the exact segments of edge existence.Instead, let's do following. Initially we add each edge right until the first appearance of this edge in requests. Now, when we're in some leaf, we found out which color this edge would be right until the next appearance of this edge. So, let's update this edge on that segment. For each leaf we're going to make an update at most once, so the complexity is O(nlog2n).SourceIf anything is unclear or bad-written, ask any questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5926
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 1",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 2",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 3",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 4",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 6",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 7",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 8",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    // Read n integers a1 to an\n    vector<int> ai = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    // Read n integers a1 to an\n    vector<int> ai = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    // Read n integers a1 to an\n    vector<int> ai = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n); // The sequence a_i\n    \n    if (type == \"all_zero\") {\n        // All elements are zero\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"same_number\") {\n        // All elements are the same random number\n        int val = rnd.next(0, 1'000'000'000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"sum_less_than_m\") {\n        // Sum of all elements is less than m\n        long long sum = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            if (sum + a[i] >= m) {\n                a[i] = 0;\n            }\n            sum += a[i];\n        }\n    } else if (type == \"sum_mod_zero\") {\n        // The sum of elements is divisible by m\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(0, 1'000'000'000);\n            sum = (sum + a[i]) % m;\n        }\n        // Set last element to make total sum divisible by m\n        a[n - 1] = (m - sum % m) % m;\n    } else if (type == \"edge_case\") {\n        // Edge case, e.g., a_i = i % m\n        for (int i = 0; i < n; ++i)\n            a[i] = i % m;\n    } else if (type == \"max_size\") {\n        // Max size test case with random elements\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1'000'000'000);\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1'000'000'000);\n    }\n    \n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n); // The sequence a_i\n    \n    if (type == \"all_zero\") {\n        // All elements are zero\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"same_number\") {\n        // All elements are the same random number\n        int val = rnd.next(0, 1'000'000'000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"sum_less_than_m\") {\n        // Sum of all elements is less than m\n        long long sum = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            if (sum + a[i] >= m) {\n                a[i] = 0;\n            }\n            sum += a[i];\n        }\n    } else if (type == \"sum_mod_zero\") {\n        // The sum of elements is divisible by m\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(0, 1'000'000'000);\n            sum = (sum + a[i]) % m;\n        }\n        // Set last element to make total sum divisible by m\n        a[n - 1] = (m - sum % m) % m;\n    } else if (type == \"edge_case\") {\n        // Edge case, e.g., a_i = i % m\n        for (int i = 0; i < n; ++i)\n            a[i] = i % m;\n    } else if (type == \"max_size\") {\n        // Max size test case with random elements\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1'000'000'000);\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1'000'000'000);\n    }\n    \n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 5 -type random\n./gen -n 1 -m 6 -type random\n./gen -n 4 -m 6 -type random\n./gen -n 6 -m 6 -type random\n./gen -n 1 -m 2 -type all_zero\n./gen -n 10 -m 10 -type all_zero\n./gen -n 1000 -m 2 -type all_zero\n./gen -n 1000000 -m 1000 -type all_zero\n./gen -n 3 -m 5 -type same_number\n./gen -n 10 -m 1000 -type same_number\n./gen -n 1000000 -m 1000 -type same_number\n./gen -n 10 -m 10 -type sum_less_than_m\n./gen -n 1000 -m 500 -type sum_less_than_m\n./gen -n 3 -m 5 -type sum_mod_zero\n./gen -n 10 -m 500 -type sum_mod_zero\n./gen -n 1000 -m 1000 -type sum_mod_zero\n./gen -n 1000000 -m 2 -type sum_mod_zero\n./gen -n 10 -m 10 -type edge_case\n./gen -n 1000 -m 100 -type edge_case\n./gen -n 1000000 -m 1000 -type edge_case\n./gen -n 1000000 -m 1000 -type max_size\n./gen -n 1000000 -m 2 -type max_size\n./gen -n 1000000 -m 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:54.481578",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "577/C",
      "title": "C. Игра Васи и Пети",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано число n (1 ≤ n ≤ 103).",
      "output_spec": "Выходные данныеВыведите длину искомой последовательности вопросов k (0 ≤ k ≤ n), а затем k чисел — саму последовательность вопросов yi (1 ≤ yi ≤ n).Если существует несколько корректных последовательностей вопросов минимальной длины, то разрешается вывести любую.",
      "sample_tests": "ПримерыВходные данныеСкопировать4Выходные данныеСкопировать32 4 3 Входные данныеСкопировать6Выходные данныеСкопировать42 4 3 5",
      "description": "C. Игра Васи и Пети\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке записано число n (1 ≤ n ≤ 103).\n\nВходные данные\n\nВыходные данныеВыведите длину искомой последовательности вопросов k (0 ≤ k ≤ n), а затем k чисел — саму последовательность вопросов yi (1 ≤ yi ≤ n).Если существует несколько корректных последовательностей вопросов минимальной длины, то разрешается вывести любую.\n\nВыходные данные\n\nВходные данныеСкопировать4Выходные данныеСкопировать32 4 3 Входные данныеСкопировать6Выходные данныеСкопировать42 4 3 5\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32 4 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать42 4 3 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПоследовательность из ответа на первый тест из условия действительно корректна. Если загаданное число не делится ни на одно из чисел последовательности, то оно равно 1.Если же загаданное число делится на 4, то оно равно 4.Если загаданное число делится на 3, то загаданное число равно 3.Иначе, оно равно 2. Стало быть, эта последовательность вопросов действительно угадывает загаданное число. Можно показать, что не существует последовательности вопросов состоящей из менее, чем трёх вопросов, удовлетворяющей условию.",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Всем привет!Сегодня в 19.30 по московскому времени состоится Codeforces Round #319, который настоятельно не рекомендуется кому-либо пропускать.Автор раунда — я, меня зовут Дима Горбунов, и это мой первый раунд на Codeforces. Я очень надеюсь, что вам понравится раунд, и каждый найдет себе задачу по вкусу. Для того, чтобы увеличить вероятность этого события, пожалуйста, прочтите все задачи этого контеста.Как всегда, благодарю Zlobober за неоценимую помощь при подготовке контеста и утонченный юмор, sankear за написание перекрестных решений, Delinur за перевод условий на английский язык и MikeMirzayanov за потрясающие системы Codeforces и Polygon.У вас будет два часа на то, чтобы решить 5 задач. Успехов!UPD. Разбалловка в первом дивизионе — 500-1250-1250-2000-2750.Во втором — 500-1250-1500-2250-2250.UPD2. Из-за тестов большого размера по некоторым задачам, системное тестирование будет идти медленно (возможно, займёт несколько часов). Благодарим за терпение!UPD3. Разбор можно найти по ссылке.UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826Отдельный респект al13n за правильное решение задачи Div1.E во время контеста!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1193
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces",
          "content": "Задача A. Div2.Заметим, что число x может встречаться в столбце i только один раз — в строке x / i. Переберем столбец i, проверим, что x делится нацело на i, а также x / i ≤ n. Если все условия выполнены, обновим ответ.Асимптотика — O(n)КодЗадача B. Div2.Рассмотрим два случая: n > m и n ≤ m.Пусть n > m, рассмотрим суммы на префиксах. По принципу Дирихле, найдутся две равные суммы по модулю m. Пусть Slmodm = Srmodm. Тогда сумма чисел на отрезке с l + 1 по r по модулю m равна нулю, то есть ответ точно \"YES\".Пусть n ≤ m, то решим задачу динамикой за O(m2). Пусть can[i][r] — можем ли мы, используя первые i предметов, получить остаток r от деления на m. Переходы в динамике понятны: либо мы берем предмет и переходим в состояние can[i + 1][(r + ai) mod m], либо не берем и переходим в состояние can[i + 1][r].Асимптотика — O(m2).КодЗадача A. Div1.Пусть Петя не спросил число pk, где p — простое, а k ≥ 1. Тогда, Петя не сможет отличить число pk - 1 от числа pk.Значит, нужно спросить все числа вида pk, где p — простое, а k ≥ 1. Несложно убедиться, что это позволит угадать и все остальные числа.Асимптотика O(N1.5) или O(NloglogN) в зависимости от теста на простоту.КодЗадачи B. Div1.Рассмотрим дерево-ответ. Заметим, что центры этого дерева могут перейти только в центры при применении перестановки. Это означает, что в перестановке обязательно должен быть цикл длины 1 или 2.Пусть в перестановке есть неподвижная точка. Тогда мы можем подсоединить ребрами к этой вершине все остальные. Несложно убедиться, что это корректный ответ.Например, пусть дана перестановка (4, 2, 1, 3). В перестановке есть неподвижная точка 2, поэтому подсоединим ко второй вершине все остальные. Получатся ребра дерева (1, 2), (2, 3), (2, 4).Пусть в дереве-ответе есть два центра. Удалим ребро между ними, дерево разобьется на две компоненты. Несложно понять, что они должны перейти друг в друга при применении перестановки. Это означает, что все циклы перестановки должны быть четной длины. Понятно, как построить ответ, если все циклы четной длины, и есть цикл длины два. Проведем ребро между вершинами из цикла длины два, вершины всех остальных циклов будем присоединять по очереди к центрам.Например, рассмотрим перестановку (6, 5, 4, 3, 1, 2). В перестановке есть два цикла: (3, 4) и (1, 6, 2, 5). Соединим ребром вершины (3, 4), все вершины другого цикла присоединим по очереди к этим двум вершинам, получим ребра (1, 3), (6, 4), (2, 3), (5, 4).Асимптотика — O(N).КодЗадача C. Div1.Разобьем квадрат 106 × 106 вертикальными линиями на 1000 прямоугольников 103 × 106. Пронумеруем эти прямоугольники от 1 до n в порядке слева направо. Обойдем их тоже слева направо, а внутри каждого прямоугольника обойдем точки по возрастанию y-координаты, если это четный по номеру прямоугольник, и по убыванию, если нечетный.Посчитаем длину такого пути, будем считать независимо по каждой координате. По y-координате мы пройдем суммарно 1000 прямоугольников от 0 до 106, то есть суммарно 109, По x-координате, чтобы дойти до следующей точки внутри прямоугольника, мы потратим не более 1000 на точку, и 1000 раз пройдем не более 2000 до следующего прямоугольника, то есть суммарно 109 + 2000000.Итого, длина пути не более 2 * 109 + 2000000, что подходит под ограничения на длину.Асимптотика — O(n * log(n))КодЗадача D. Div1.Будем оптимизировать первое же решение, которое приходит в голову за O(m * dmax): посчитаем can[t][v] — можно ли добраться до вершины v, пройдя по ровно t ребрам.Теперь заметим, что множество ребер, по которому мы можем ходить меняется только m раз. Отсортируем ребра в порядке возрастания di, т.е. для всех i di ≤ di + 1. Будем считать динамику can[t][v] только для t = di. Пусть мы хотим перейти от can[di] к can[di + 1]. Поскольку набор ребер не меняется с момента di до di + 1, мы можем возвести матрицу смежности в степень di + 1 - di и применить ее к can[di]. Пусть мы насчитали все can[di][v]. Теперь зафиксирует ребро с максимальным di, по которому мы пройдем в нашем кратчайшем пути. Мы знаем все вершины, в которых мы можем находиться в момент di, далее нужно найти кратчайший путь из них в вершину m по открытым для нас ребрам и обновить ответ. Матрицу кратчайших расстояний можно посчитать Флойдом, поэтому обновление ответа не составит труда.Получилось решение за O(m * n3 * log(dmax)), которое, к сожалению, работает долго.Далее нужно заметить, что матрица смежности состоит из ноликов и единичек, поэтому её можно возводить в степень битовым сжатием за O(n3 / 32). Это дает решение за O(m * n3 * log(dmax) / 32), что спокойно заходит по времени.КодЗадача E. Div1.Сначала решим чуть более простую задачу: пусть вне зависимости от двудольности/недвудольности запросы выполняются, а от нас требуется лишь ответить, будет ли граф двудольным/недвудольным после запроса.Тогда мы могли бы применить решение, похожее на решение задачи Dynamic Connectivity Offline за O(nlog2n). Опишем его подробнее:Вначале пусть ребра только добавляются. Тогда можно воспользоваться системой непересекающихся множеств, где, кроме предка, будем хранить четность пути до предка, а также флаг двудольности текущего графа. Теперь мы можем найти четность пути до корня — просто пропрыгать до предка, проксорить четности. Теперь, когда мы проводим ребро между двумя компонентами, мы можем посчитать четность путей до вершин этой ребра, а значит, и установить четность прыжка из корня одной компоненты в корень другой компоненты. Если ребро проходит внутри одной компоненты и четности пути до корня совпадают, нужно убрать флаг двудольности текущего графа.Теперь пусть ребра иногда удаляются. Для каждого ребра и каждого цвета мы знаем отрезки запросов, когда это ребро будет в графе заданного цвета. Давайте построим дерево отрезков на запросах, в каждой вершине будем хранить список ребер, которые будут включены на этом подотрезке. Каждый отрезок дерево отрезков разобьет на log кусочков, поэтому в сумме количество добавлений ребер на кусочке будет порядка n * log.Теперь, можно обойти это дерево отрезков в глубину с системой непересекающихся множеств с откатами. Мы входим в вершины, применяем все запросы добавления ребра в данной вершине, обходим потомков, а затем откатываем снм до состояния, в котором оно было на входе в эту вершину. Когда мы находимся в листе, отвечаем на соответствующий запрос.Вернемся к нашей задаче. Вышеописанную технику в явном виде мы применить не можем, потому что не знаем точно, на каких отрезках запросов ребра будут существовать.Зато мы можем сделать следующее. Изначально применим операцию до первого момента появления ребра в запросах. Теперь, когда мы находимся в листе, мы узнали, какого цвета это ребро будет до следующего его появления в запросах. Поэтому, давайте сделаем обновление на отрезке со следующего запроса до следующего появления этого ребра. Для каждого листа мы сделаем не более одного обновления, поэтому суммарное время работы O(nlog2n).Асимптотика — O(nlog2n).КодЕсли что-то неясно, непонятно или невнятно написано, задавайте любые вопросы.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6982
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 1",
          "code": "a += b;\nif (a >= mod) a -= mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 2",
          "code": "a += b;\nif (a >= mod) a -= mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 3",
          "code": "a = (a + b) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 4",
          "code": "a = (a + b) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 6",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 7",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 8",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 9",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 10",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 11",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #319 - Codeforces - Code 12",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to check if the provided questions uniquely identify each number from 1 to n.\nbool is_valid(int n, int k, const vector<int>& yis) {\n    map<vector<int>, int> signature_to_number;\n    for (int x = 1; x <= n; ++x) {\n        vector<int> signature(k);\n        for (int i = 0; i < k; ++i) {\n            signature[i] = (x % yis[i] == 0) ? 1 : 0;\n        }\n        if (signature_to_number.count(signature)) {\n            // Two numbers have the same signature; cannot uniquely identify x.\n            return false;\n        } else {\n            signature_to_number[signature] = x;\n        }\n    }\n    return true;\n}\n\n// Function to read and validate the answer from a stream (InStream&).\nint readAns(InStream& stream, int n, int& k, vector<int>& yis) {\n    k = stream.readInt(0, n, \"k\");\n    yis.resize(k);\n    for (int i = 0; i < k; ++i) {\n        yis[i] = stream.readInt(1, n, format(\"y[%d]\", i + 1).c_str());\n    }\n    if (!is_valid(n, k, yis)) {\n        stream.quitf(_wa, \"The provided questions do not uniquely identify the number.\");\n    }\n    return k;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    int k_jury, k_participant;\n    vector<int> yis_jury, yis_participant;\n\n    // Read and validate the jury's answer.\n    readAns(ans, n, k_jury, yis_jury);\n\n    // Read and validate the participant's answer.\n    readAns(ouf, n, k_participant, yis_participant);\n\n    if (k_participant > k_jury) {\n        quitf(_wa, \"Participant's k (%d) is greater than the minimal k (%d).\", k_participant, k_jury);\n    } else if (k_participant == k_jury) {\n        quitf(_ok, \"Correct answer with minimal k = %d.\", k_participant);\n    } else { // k_participant < k_jury\n        quitf(_fail, \"Participant found a better solution with k = %d, minimal k in jury's answer is %d.\", k_participant, k_jury);\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for(int i=2;i*i<=n;i++) {\n        if(n%i==0)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n != -1) {\n        // Ensure n is within [1, 1000]\n        ensure(1 <= n && n <= 1000);\n    } else if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        n = rnd.next(990, 1000);\n    } else if (type == \"prime\") {\n        vector<int> primes;\n        for(int i = 2; i <= 1000; i++) {\n            if(is_prime(i))\n                primes.push_back(i);\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"composite\") {\n        vector<int> composites;\n        for(int i = 4; i <= 1000; i++) {\n            if(!is_prime(i))\n                composites.push_back(i);\n        }\n        n = composites[rnd.next(0, (int)composites.size() - 1)];\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000);\n    } else {\n        n = rnd.next(1, 1000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for(int i=2;i*i<=n;i++) {\n        if(n%i==0)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n != -1) {\n        // Ensure n is within [1, 1000]\n        ensure(1 <= n && n <= 1000);\n    } else if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        n = rnd.next(990, 1000);\n    } else if (type == \"prime\") {\n        vector<int> primes;\n        for(int i = 2; i <= 1000; i++) {\n            if(is_prime(i))\n                primes.push_back(i);\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"composite\") {\n        vector<int> composites;\n        for(int i = 4; i <= 1000; i++) {\n            if(!is_prime(i))\n                composites.push_back(i);\n        }\n        n = composites[rnd.next(0, (int)composites.size() - 1)];\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000);\n    } else {\n        n = rnd.next(1, 1000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 10\n./gen -n 50\n./gen -n 100\n./gen -n 500\n./gen -n 999\n./gen -n 1000\n./gen -type min\n./gen -type max\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type large\n./gen -type large\n./gen -type large\n./gen -type prime\n./gen -type prime\n./gen -type prime\n./gen -type composite\n./gen -type composite\n./gen -type composite\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:56.174570",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "577/D",
      "title": "Problem 577/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<bool> used(n+1,false);\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        if (used[pi]) {\n            quitf(_fail, \"number %d appears more than once in permutation p\", pi);\n        }\n        used[pi] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<bool> used(n+1,false);\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        if (used[pi]) {\n            quitf(_fail, \"number %d appears more than once in permutation p\", pi);\n        }\n        used[pi] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<bool> used(n+1,false);\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        if (used[pi]) {\n            quitf(_fail, \"number %d appears more than once in permutation p\", pi);\n        }\n        used[pi] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> p; // permutation p[1..n]\n\nstruct UnionFind {\n    vector<int> parent;\n    UnionFind(int n): parent(n+1) {\n        for (int i = 1; i <= n; i++) parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    bool unite(int x, int y) {\n        int fx = find(x);\n        int fy = find(y);\n        if (fx == fy) return false; // Cycle detected\n        parent[fx] = fy;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    p.resize(n+1); // 1-based indexing\n    for (int i = 1; i <= n; i++) {\n        p[i] = inf.readInt();\n    }\n\n    string jury_ans = ans.readToken();\n    string part_ans = ouf.readToken();\n\n    transform(jury_ans.begin(), jury_ans.end(), jury_ans.begin(), ::toupper);\n    transform(part_ans.begin(), part_ans.end(), part_ans.begin(), ::toupper);\n\n    if (jury_ans != \"YES\" && jury_ans != \"NO\") {\n        quitf(_fail, \"Jury answer is neither YES nor NO\");\n    }\n    if (part_ans != \"YES\" && part_ans != \"NO\") {\n        quitf(_pe, \"Participant output is neither YES nor NO\");\n    }\n\n    if (jury_ans == \"NO\") {\n        if (part_ans == \"NO\") {\n            quitf(_ok, \"Correct: both outputs are NO\");\n        } else if (part_ans == \"YES\") {\n            // Participant outputs a solution, but jury says no solution exists\n            // We need to check if the participant's output is indeed a valid solution\n            // If participant's solution is valid, the jury is wrong (fail)\n            // Else, participant's solution is wrong (WA)\n            vector<pair<int, int>> edges;\n\n            for (int i = 0; i < n - 1; i++) {\n                int u = ouf.readInt(1, n, \"u\");\n                int v = ouf.readInt(1, n, \"v\");\n                edges.emplace_back(u, v);\n            }\n            // Check if there is extra output\n            if (!ouf.seekEof())\n                quitf(_pe, \"Extra output after reading n-1 edges\");\n\n            // Now, verify participant's tree\n            // Check valid tree\n            UnionFind uf(n);\n            for (const auto& e : edges) {\n                if (!uf.unite(e.first, e.second)) {\n                    quitf(_wa, \"Participant's solution contains a cycle\");\n                }\n            }\n            int root = uf.find(1);\n            for (int i = 2; i <= n; i++) {\n                if (uf.find(i) != root) {\n                    quitf(_wa, \"Participant's solution is not connected\");\n                }\n            }\n            // Check invariance under permutation\n            set<pair<int, int>> edge_set;\n            for (const auto& e : edges) {\n                int u = min(e.first, e.second);\n                int v = max(e.first, e.second);\n                edge_set.insert({u, v});\n            }\n            set<pair<int, int>> permuted_edge_set;\n            for (const auto& e : edges) {\n                int pu = p[e.first];\n                int pv = p[e.second];\n                int u = min(pu, pv);\n                int v = max(pu, pv);\n                permuted_edge_set.insert({u, v});\n            }\n            if (edge_set != permuted_edge_set) {\n                quitf(_wa, \"Participant's tree is not invariant under permutation p\");\n            }\n            quitf(_fail, \"Participant found a valid solution, but jury says no solution exists\");\n        } else {\n            quitf(_pe, \"Participant output is neither YES nor NO\");\n        }\n    } else if (jury_ans == \"YES\") {\n        if (part_ans == \"NO\") {\n            quitf(_wa, \"Participant outputs NO, but a solution exists\");\n        } else if (part_ans == \"YES\") {\n            vector<pair<int, int>> edges;\n\n            for (int i = 0; i < n - 1; i++) {\n                int u = ouf.readInt(1, n, \"u\");\n                int v = ouf.readInt(1, n, \"v\");\n                edges.emplace_back(u, v);\n            }\n            // Check if there is extra output\n            if (!ouf.seekEof())\n                quitf(_pe, \"Extra output after reading n-1 edges\");\n\n            // Now, verify participant's tree\n            // Check valid tree\n            UnionFind uf(n);\n            for (const auto& e : edges) {\n                if (!uf.unite(e.first, e.second)) {\n                    quitf(_wa, \"Participant's solution contains a cycle\");\n                }\n            }\n            int root = uf.find(1);\n            for (int i = 2; i <= n; i++) {\n                if (uf.find(i) != root) {\n                    quitf(_wa, \"Participant's solution is not connected\");\n                }\n            }\n            // Check invariance under permutation\n            set<pair<int, int>> edge_set;\n            for (const auto& e : edges) {\n                int u = min(e.first, e.second);\n                int v = max(e.first, e.second);\n                edge_set.insert({u, v});\n            }\n            set<pair<int, int>> permuted_edge_set;\n            for (const auto& e : edges) {\n                int pu = p[e.first];\n                int pv = p[e.second];\n                int u = min(pu, pv);\n                int v = max(pu, pv);\n                permuted_edge_set.insert({u, v});\n            }\n            if (edge_set != permuted_edge_set) {\n                quitf(_wa, \"Participant's tree is not invariant under permutation p\");\n            }\n            quitf(_ok, \"Participant's solution is correct\");\n        } else {\n            quitf(_pe, \"Participant output is neither YES nor NO\");\n        }\n    } else {\n        quitf(_fail, \"Jury answer is neither YES nor NO\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"identity\") {\n        // Identity permutation: p_i = i\n        for(int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        // Reverse permutation: p_i = n - i\n        for(int i = 0; i < n; ++i) {\n            p[i] = n - i;\n        }\n    } else if (type == \"random\") {\n        // Random permutation\n        for(int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"shift\") {\n        // Shift permutation: p_i = (i + k) mod n + 1\n        int k = opt<int>(\"k\", 1);\n        for(int i = 0; i < n; ++i) {\n            p[i] = ((i + k) % n) + 1;\n        }\n    } else if (type == \"cycle\") {\n        // Single cycle permutation: p_i = (i + 1) mod n + 1\n        for(int i = 0; i < n; ++i) {\n            p[i] = (i + 1) % n + 1;\n        }\n    } else if (type == \"fixed_point\") {\n        // Permutation with one fixed point\n        int fixed = opt<int>(\"fixed\", -1);\n        if (fixed == -1) fixed = rnd.next(1, n); // Random position to fix\n        for(int i = 0; i < n; ++i) {\n            if (i + 1 == fixed) {\n                p[i] = i + 1;\n            } else {\n                p[i] = rnd.next(1, n);\n                while(p[i] == i + 1) {\n                    p[i] = rnd.next(1, n);\n                }\n            }\n        }\n    } else {\n        // Default to random permutation\n        for(int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output permutation p\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"identity\") {\n        // Identity permutation: p_i = i\n        for(int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        // Reverse permutation: p_i = n - i\n        for(int i = 0; i < n; ++i) {\n            p[i] = n - i;\n        }\n    } else if (type == \"random\") {\n        // Random permutation\n        for(int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"shift\") {\n        // Shift permutation: p_i = (i + k) mod n + 1\n        int k = opt<int>(\"k\", 1);\n        for(int i = 0; i < n; ++i) {\n            p[i] = ((i + k) % n) + 1;\n        }\n    } else if (type == \"cycle\") {\n        // Single cycle permutation: p_i = (i + 1) mod n + 1\n        for(int i = 0; i < n; ++i) {\n            p[i] = (i + 1) % n + 1;\n        }\n    } else if (type == \"fixed_point\") {\n        // Permutation with one fixed point\n        int fixed = opt<int>(\"fixed\", -1);\n        if (fixed == -1) fixed = rnd.next(1, n); // Random position to fix\n        for(int i = 0; i < n; ++i) {\n            if (i + 1 == fixed) {\n                p[i] = i + 1;\n            } else {\n                p[i] = rnd.next(1, n);\n                while(p[i] == i + 1) {\n                    p[i] = rnd.next(1, n);\n                }\n            }\n        }\n    } else {\n        // Default to random permutation\n        for(int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output permutation p\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type identity\n./gen -n 5 -type reverse\n./gen -n 5 -type random\n\n./gen -n 10 -type shift -k 1\n./gen -n 10 -type shift -k 3\n./gen -n 10 -type shift -k 5\n\n./gen -n 100 -type cycle\n\n./gen -n 100 -type fixed_point -fixed 50\n\n./gen -n 1000 -type identity\n./gen -n 1000 -type reverse\n./gen -n 1000 -type random\n\n./gen -n 5000 -type shift -k 2500\n\n./gen -n 10000 -type random\n\n./gen -n 20000 -type shift -k 10000\n\n./gen -n 50000 -type cycle\n\n./gen -n 75000 -type fixed_point\n\n./gen -n 99999 -type reverse\n\n./gen -n 100000 -type identity\n./gen -n 100000 -type random\n./gen -n 100000 -type shift -k 99999\n./gen -n 100000 -type shift -k 12345\n./gen -n 100000 -type fixed_point -fixed 50000\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type reverse\n\n./gen -n 100000 -type cycle\n\n./gen -n 100000 -type shift -k 0\n\n./gen -n 100000 -type shift -k 1\n\n./gen -n 100000 -type shift -k 50000\n\n./gen -n 100000 -type shift -k 99999\n\n./gen -n 100000 -type fixed_point\n\n./gen -n 100000 -type fixed_point\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:51:57.984571",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "577/E",
      "title": "E. Points on Plane",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106).The i + 1-th line contains the coordinates of the i-th point: xi and yi (0 ≤ xi, yi ≤ 106).It is guaranteed that no two points coincide.",
      "output_spec": "OutputPrint the permutation of numbers pi from 1 to n — the sought Hamiltonian path. The permutation must meet the inequality .If there are multiple possible answers, print any of them.It is guaranteed that the answer exists.",
      "sample_tests": "ExamplesInputCopy50 78 103 45 09 12OutputCopy4 3 1 2 5",
      "description": "E. Points on Plane\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 106).The i + 1-th line contains the coordinates of the i-th point: xi and yi (0 ≤ xi, yi ≤ 106).It is guaranteed that no two points coincide.\n\nOutputPrint the permutation of numbers pi from 1 to n — the sought Hamiltonian path. The permutation must meet the inequality .If there are multiple possible answers, print any of them.It is guaranteed that the answer exists.\n\nInputCopy50 78 103 45 09 12OutputCopy4 3 1 2 5\n\nInputCopy50 78 103 45 09 12\n\nOutputCopy4 3 1 2 5\n\nNoteIn the sample test the total distance is:(|5 - 3| + |0 - 4|) + (|3 - 0| + |4 - 7|) + (|0 - 8| + |7 - 10|) + (|8 - 9| + |10 - 12|) = 2 + 4 + 3 + 3 + 8 + 3 + 1 + 2 = 26",
      "solutions": [
        {
          "title": "Codeforces Round #319 - Codeforces",
          "content": "Hey there!Today at 19.30, Moscow time there will be Codeforces Round #319 and it's strongly disadvised to skip it.I'm the author of this round, my name is Dima Gorbunov and it's my first round on Codeforces. I really hope you're going to like it and everyone will find a satisfying problem. In order to increase the probability of finding that task, please read all of the problem statements.As usual, I'd like to thank Zlobober for his invaluable help and his special sense of humour, sankear for coding additional solutions, Delinur for the English statements and MikeMirzayanov for amazing systems Codeforces and Polygon.You're going to have two hours to solve 5 problems. Good luck!UPD. The scores in first division are 500-1250-1250-2000-2750.In second division — 500-1250-1500-2250-2250,UPD2. Because of large size tests for some of the problems, system testing will be slow (it's possible that it will take several hours). Thanks for your patience!UPD3. English editorial is also accessible. UPD4. Winners!Div1:1). Marcin_smu2). mnbvmar3). I_love_Tanya_RomanovaDiv2:1). latisel2). wrong_order3). ntitry826A special respect to al13n for correct solution of Div1.E during the contest!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20225",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1189
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces",
          "content": "Task A. Div2.It's easy to see that number x can appear in column i only once — in row x / i. For every column i, let's check that x divides i and x / i ≤ n. If all requirements are met, we'll update the answer.The complexity is O(n)SourceTask B. Div2.Let's consider two cases: n > m and n ≤ m.If n > m, let's look at prefix sums. By pigeonhole principle, there are two equals sums modulo m. Assume Slmodm = Srmodm. Then the sum on segment [l + 1, r] equals zero modulo m, that means the answer is definitely \"YES\".If n ≤ m, we'll solve this task using dynamic programming in O(m2) time. Assume can[i][r] means if we can achieve the sum equal to r modulo m using only first i - 1 items. The updates in this dynamic programming are obvious: we either take number ai and go to the state can[i + 1][(r + ai) mod m] or not, then we'll get to the state can[i + 1][r].The complexity is O(m2).SourceTask A. Div1.If Petya didn't ask pk, where p is prime and k ≥ 1, he would not be able to distinguish pk - 1 and pk.That means, he should ask all the numbers pk. It's easy to prove that this sequence actually guesses all the numbers from 1 to nThe complexity is O(N1.5) or O(NloglogN) depending on primality test.SourceTask B. Div1.Let's look at the answer. It's easy to notice, that centers of that tree must turn into centers after applying the permutation. That means, permutation must have cycle with length 1 or 2 since there're at most two centers. If permutation has cycle with length 1, we can connect all the other vertices to it.For example, let's look at the permutation (4, 2, 1, 3). 2 is a cycle with length 2, so let's connect all the other vertices to it. The resulting tree edges would be (1, 2), (2, 3), (2, 4).If answer has two centers, let's remove the edge between them. The tree will split into two connected parts. It's easy to see that they will turn into each other after applying permutation. That means, all cycles should be even. It's easy to come up with answer with these restrictions. Let's connect vertices from the cycles with length 2. Then, let's connect vertices with odd position in cycles to first of these and vetices with even cycles to second one.For example, let's consider permutation (6, 5, 4, 3, 1, 2). There are two cycles: (3, 4) и (1, 6, 2, 5). We add edge (3, 4), all other vertices we connect to these two, obtaining edges (1, 3), (6, 4), (2, 3), (5, 4).The complexity is O(N).SourceTask C. Div1.Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.Let's calculate the maximum length of such a way. The coordinates are independent. By y-coordinate we're passing 1000 rectangles from 0 to 106, 109 in total. By x-coordinate we're spending 1000 to get to the next point of current rectangle and 2000 to get to next rectangle. That means, 2 * 109 + 2000000 in total, which perfectly fits.The complexity is O(n * log(n))SourceTask D. Div1.Let's optimize the first solution that comes to mind: O(m * dmax), let's calculate can[t][v] — can we get to the vertice v, while passing exactly t edges.Now, it's easy to find out that the set of edges we are able to go through changed only m times. Let's sort these edges in increasing order of di, that means for each i di ≤ di + 1. Let's calculate can[t][v] only for t = di. We can calculate can[di + 1] using can[di] by raising the adjacency matrix to the di + 1 - di power and applying it to can[di].Next step is to fix an edge with maximal di on our shortest path, let it be i. We know all the vertices we can be at moment di, so we need to calculate the shortest path to n - 1 using edges we can go through. We can even use Floyd algorithm to calculate that.The complexity of this solution is O(m * n3 * log(dmax)) and it's not enough.Next observation is that adjacency matrix contains only zeroes or ones, so we can multiply these matrixes using bitsets in O(n3 / 32).This makes complexity O(m * n3 * log(dmax) / 32), which gets accepted.SourceTask E. Div1.Let's solve an easier task first: independent of bipartivity, the color of edge changes.Then we could write a solution, which is pretty similar to solution of Dynamic Connectivity Offline task in O(nlog2n).Let's consider only cases, where edges are not being deleted from the color graph. Then, we could use DSU with storing parity of the way to the parent along with parent. Now we can find parity of the path to the root by jumping through parents and xoring the parities. Also, we can connect two components by accurately calculating the parity of the path from one root to another.Now edges are being deleted. For each edge and each color we know the segments of requests, when this edge will be in the graph of specified color. Let's build a segment tree on requests, in each vertex of the tree we store list of edges which exist on the subsegment. Every segment will be split into log parts, so, totally there would be n * log small parts.Now we can dfs this segment tree with DSU. We get inside the vertex, apply all the requests inside it, go through the children and revert DSU to initial state. We also answer requests in leafs of the segment tree.Let's return to initial task. We can't use this technique, because we don't know the exact segments of edge existence.Instead, let's do following. Initially we add each edge right until the first appearance of this edge in requests. Now, when we're in some leaf, we found out which color this edge would be right until the next appearance of this edge. So, let's update this edge on that segment. For each leaf we're going to make an update at most once, so the complexity is O(nlog2n).SourceIf anything is unclear or bad-written, ask any questions.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20226",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5926
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #319 - Codeforces - Code 1",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 2",
          "code": "4 6\n3 1 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 4",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 5",
          "code": "printf (\"%d %d\\n\", nod1, nod2);\nfor (int i=2; i<=N; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 6",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #319 - Codeforces - Code 7",
          "code": "for(int j=1;j<= ht[i];j++)\n  sum = (sum + i);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20225",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 1",
          "code": "if(n > m) //pigeonhole principle  {   //answer is always yes   cout << \"YES\\n\";   return 0;  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 2",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 3",
          "code": "if(!mod and take) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 4",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 5",
          "code": "if(!mod) return true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 6",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 7",
          "code": "if (idx == n)\n        return (cnt > 0 && sum % m == 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #319 - Codeforces - Code 8",
          "code": "It's easy to notice, that centers of that tree must turn into centers after applying the permutation.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20226",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = int(1e6);\n    const int MAX_COORD = int(1e6);\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    unordered_set<long long> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, MAX_COORD, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, MAX_COORD, \"yi\");\n        inf.readEoln();\n\n        long long key = ((long long) xi) * (MAX_COORD + 1) + yi;\n        ensuref(points.count(key) == 0, \"Duplicate point (%d, %d) detected at line %d\", xi, yi, i + 2);\n        points.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = int(1e6);\n    const int MAX_COORD = int(1e6);\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    unordered_set<long long> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, MAX_COORD, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, MAX_COORD, \"yi\");\n        inf.readEoln();\n\n        long long key = ((long long) xi) * (MAX_COORD + 1) + yi;\n        ensuref(points.count(key) == 0, \"Duplicate point (%d, %d) detected at line %d\", xi, yi, i + 2);\n        points.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = int(1e6);\n    const int MAX_COORD = int(1e6);\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    unordered_set<long long> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, MAX_COORD, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, MAX_COORD, \"yi\");\n        inf.readEoln();\n\n        long long key = ((long long) xi) * (MAX_COORD + 1) + yi;\n        ensuref(points.count(key) == 0, \"Duplicate point (%d, %d) detected at line %d\", xi, yi, i + 2);\n        points.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Reading n from inf\n    int n = inf.readInt(1, 1000000, \"n\");\n\n    // Reading the points\n    vector<int> x(n + 1), y(n + 1); // 1-based indexing\n    set<pair<int, int>> point_set;\n    for (int i = 1; i <= n; ++i) {\n        x[i] = inf.readInt(0, 1000000, format(\"x[%d]\", i).c_str());\n        y[i] = inf.readInt(0, 1000000, format(\"y[%d]\", i).c_str());\n        if (point_set.count(make_pair(x[i], y[i]))) {\n            quitf(_fail, \"Duplicate points found in input: (%d, %d)\", x[i], y[i]); // Should not happen as per problem\n        }\n        point_set.insert(make_pair(x[i], y[i]));\n    }\n\n    // Reading permutation pi from ouf\n    vector<int> pi = ouf.readInts(n, 1, n, \"pi\");\n\n    // Check that pi is a valid permutation\n    vector<int> cnt(n + 1, 0); // 1-based indexing\n    for (int i = 0; i < n; ++i) {\n        int val = pi[i];\n        if (cnt[val] != 0) {\n            quitf(_wa, \"Duplicate value %d in permutation\", val);\n        }\n        cnt[val] = 1;\n    }\n\n    // Compute total_length\n    long long total_length = 0;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = pi[i];\n        int v = pi[i + 1];\n        total_length += abs(x[u] - x[v]) + abs(y[u] - y[v]);\n    }\n\n    if (total_length > 25LL * 100000000) {\n        quitf(_wa, \"Total length %lld exceeds limit 2500000000\", total_length);\n    } else {\n        quitf(_ok, \"Total length %lld\", total_length);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> pts;\n\n    if (type == \"random\") {\n        // For small n, generate completely random points\n        if (n <= 10000) {\n            set<pair<int,int>> points;\n            while ((int)pts.size() < n) {\n                int x = rnd.next(0, 1000000);\n                int y = rnd.next(0, 1000000);\n                if (points.count({x, y}) == 0) {\n                    points.insert({x, y});\n                    pts.push_back({x, y});\n                }\n            }\n        } else {\n            // For larger n, generate points ensuring the total path length is under the limit\n            // Adjust the maximum per-edge distance\n            long long total_length_limit = 2500000000LL;\n            long long L_max = (total_length_limit + n - 2) / (n - 1); // Ceiling division\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            pts.push_back({x, y});\n            set<pair<int,int>> points;\n            points.insert({x, y});\n            for (int i = 1; i < n; ++i) {\n                int maxDelta = min((int)L_max, 1000000);\n                int dx = rnd.next(-maxDelta, maxDelta);\n                int dy_limit = maxDelta - abs(dx);\n                int dymin = -dy_limit;\n                int dymax = dy_limit;\n                int dy = rnd.next(dymin, dymax);\n                int new_x = x + dx;\n                int new_y = y + dy;\n\n                // Keep points within bounds\n                new_x = max(0, min(1000000, new_x));\n                new_y = max(0, min(1000000, new_y));\n\n                // Ensure no duplicate points\n                while (points.count({new_x, new_y})) {\n                    dx = rnd.next(-maxDelta, maxDelta);\n                    dy_limit = maxDelta - abs(dx);\n                    dymin = -dy_limit;\n                    dymax = dy_limit;\n                    dy = rnd.next(dymin, dymax);\n                    new_x = x + dx;\n                    new_y = y + dy;\n                    new_x = max(0, min(1000000, new_x));\n                    new_y = max(0, min(1000000, new_y));\n                }\n\n                pts.push_back({new_x, new_y});\n                points.insert({new_x, new_y});\n                x = new_x;\n                y = new_y;\n            }\n        }\n    } else if (type == \"clustered\") {\n        // Generate points clustered in a small area\n        int K = 5000; // Cluster size\n        set<pair<int,int>> points;\n        int x0 = rnd.next(0, 1000000 - K);\n        int y0 = rnd.next(0, 1000000 - K);\n        while ((int)pts.size() < n) {\n            int x = rnd.next(x0, x0 + K);\n            int y = rnd.next(y0, y0 + K);\n            if (points.count({x, y}) == 0) {\n                points.insert({x, y});\n                pts.push_back({x, y});\n            }\n        }\n    } else if (type == \"line\") {\n        // Generate points along a straight line\n        int x = rnd.next(0, 1000000 - n + 1);\n        int y = rnd.next(0, 1000000);\n        for (int i = 0; i < n; ++i) {\n            pts.push_back({x + i, y});\n        }\n    } else if (type == \"grid\") {\n        // Generate points in a grid pattern\n        int gridSize = sqrt(n);\n        if (gridSize * gridSize < n) gridSize++;\n        int x0 = rnd.next(0, 1000000 - gridSize);\n        int y0 = rnd.next(0, 1000000 - gridSize);\n        for (int i = 0; i < gridSize && (int)pts.size() < n; ++i) {\n            for (int j = 0; j < gridSize && (int)pts.size() < n; ++j) {\n                int x = x0 + i;\n                int y = y0 + j;\n                pts.push_back({x, y});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& p : pts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> pts;\n\n    if (type == \"random\") {\n        // For small n, generate completely random points\n        if (n <= 10000) {\n            set<pair<int,int>> points;\n            while ((int)pts.size() < n) {\n                int x = rnd.next(0, 1000000);\n                int y = rnd.next(0, 1000000);\n                if (points.count({x, y}) == 0) {\n                    points.insert({x, y});\n                    pts.push_back({x, y});\n                }\n            }\n        } else {\n            // For larger n, generate points ensuring the total path length is under the limit\n            // Adjust the maximum per-edge distance\n            long long total_length_limit = 2500000000LL;\n            long long L_max = (total_length_limit + n - 2) / (n - 1); // Ceiling division\n            int x = rnd.next(0, 1000000);\n            int y = rnd.next(0, 1000000);\n            pts.push_back({x, y});\n            set<pair<int,int>> points;\n            points.insert({x, y});\n            for (int i = 1; i < n; ++i) {\n                int maxDelta = min((int)L_max, 1000000);\n                int dx = rnd.next(-maxDelta, maxDelta);\n                int dy_limit = maxDelta - abs(dx);\n                int dymin = -dy_limit;\n                int dymax = dy_limit;\n                int dy = rnd.next(dymin, dymax);\n                int new_x = x + dx;\n                int new_y = y + dy;\n\n                // Keep points within bounds\n                new_x = max(0, min(1000000, new_x));\n                new_y = max(0, min(1000000, new_y));\n\n                // Ensure no duplicate points\n                while (points.count({new_x, new_y})) {\n                    dx = rnd.next(-maxDelta, maxDelta);\n                    dy_limit = maxDelta - abs(dx);\n                    dymin = -dy_limit;\n                    dymax = dy_limit;\n                    dy = rnd.next(dymin, dymax);\n                    new_x = x + dx;\n                    new_y = y + dy;\n                    new_x = max(0, min(1000000, new_x));\n                    new_y = max(0, min(1000000, new_y));\n                }\n\n                pts.push_back({new_x, new_y});\n                points.insert({new_x, new_y});\n                x = new_x;\n                y = new_y;\n            }\n        }\n    } else if (type == \"clustered\") {\n        // Generate points clustered in a small area\n        int K = 5000; // Cluster size\n        set<pair<int,int>> points;\n        int x0 = rnd.next(0, 1000000 - K);\n        int y0 = rnd.next(0, 1000000 - K);\n        while ((int)pts.size() < n) {\n            int x = rnd.next(x0, x0 + K);\n            int y = rnd.next(y0, y0 + K);\n            if (points.count({x, y}) == 0) {\n                points.insert({x, y});\n                pts.push_back({x, y});\n            }\n        }\n    } else if (type == \"line\") {\n        // Generate points along a straight line\n        int x = rnd.next(0, 1000000 - n + 1);\n        int y = rnd.next(0, 1000000);\n        for (int i = 0; i < n; ++i) {\n            pts.push_back({x + i, y});\n        }\n    } else if (type == \"grid\") {\n        // Generate points in a grid pattern\n        int gridSize = sqrt(n);\n        if (gridSize * gridSize < n) gridSize++;\n        int x0 = rnd.next(0, 1000000 - gridSize);\n        int y0 = rnd.next(0, 1000000 - gridSize);\n        for (int i = 0; i < gridSize && (int)pts.size() < n; ++i) {\n            for (int j = 0; j < gridSize && (int)pts.size() < n; ++j) {\n                int x = x0 + i;\n                int y = y0 + j;\n                pts.push_back({x, y});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& p : pts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n\n./gen -n 100000 -type line\n./gen -n 100000 -type clustered\n./gen -n 100000 -type random\n\n./gen -n 999999 -type random\n./gen -n 500000 -type clustered\n./gen -n 500000 -type grid\n\n./gen -n 1000000 -type line\n./gen -n 1000000 -type clustered\n./gen -n 1000000 -type grid\n\n./gen -n 123456 -type random\n./gen -n 654321 -type line\n\n./gen -n 10 -type grid\n./gen -n 100 -type grid\n./gen -n 1000 -type grid\n./gen -n 5000 -type grid\n./gen -n 100000 -type grid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:00.259310",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "578/A",
      "title": "A. A Problem about Polyline",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputOnly one line containing two positive integers a and b (1 ≤ a, b ≤ 109).",
      "output_spec": "OutputOutput the only line containing the answer. Your answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9. If there is no such x then output  - 1 as the answer.",
      "sample_tests": "ExamplesInputCopy3 1OutputCopy1.000000000000InputCopy1 3OutputCopy-1InputCopy4 1OutputCopy1.250000000000",
      "description": "A. A Problem about Polyline\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputOnly one line containing two positive integers a and b (1 ≤ a, b ≤ 109).\n\nOutputOutput the only line containing the answer. Your answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9. If there is no such x then output  - 1 as the answer.\n\nInputCopy3 1OutputCopy1.000000000000InputCopy1 3OutputCopy-1InputCopy4 1OutputCopy1.250000000000\n\nInputCopy3 1\n\nOutputCopy1.000000000000\n\nInputCopy1 3\n\nOutputCopy-1\n\nInputCopy4 1\n\nOutputCopy1.250000000000\n\nNoteYou can see following graphs for sample 1 and sample 3.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    /* Read command-line options */\n    string type = opt<string>(\"type\", \"random_with_solution\");\n    int tvalue = opt<int>(\"t\", -1);\n\n    if (type == \"random_with_solution\") {\n        /* Randomly generate t (even or odd) and x */\n        int t = rnd.next(0, 100000);\n        if (tvalue != -1)\n            t = tvalue;\n        if (t % 2 == 0) {\n            /* t is even */\n            int x_max = t == 0 ? int(1e9) : int((1e9 - 1) / t);\n            int x = rnd.next(1, x_max);\n            int b = rnd.next(1, x - 1);\n            int a = t * x + b;\n            if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n                /* Adjust x and b */\n                x = 1;\n                b = 1;\n                a = t * x + b;\n            }\n            printf(\"%d %d\\n\", a, b);\n        } else {\n            /* t is odd */\n            int x_max = int((1e9 - 1) / (t + 1));\n            int x = rnd.next(1, x_max);\n            int b = rnd.next(1, x - 1);\n            int a = (t + 1) * x - b;\n            if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n                /* Adjust x and b */\n                x = 1;\n                b = 1;\n                a = (t + 1) * x - b;\n            }\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"t_even\") {\n        int t = tvalue;\n        if (t % 2 != 0 || t < 0) {\n            fprintf(stderr, \"t must be even and non-negative\\n\");\n            exit(1);\n        }\n        int x_max = t == 0 ? int(1e9) : int((1e9 - 1) / t);\n        int x = rnd.next(1, x_max);\n        int b = rnd.next(1, x - 1);\n        int a = t * x + b;\n        if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n            x = 1;\n            b = 1;\n            a = t * x + b;\n        }\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"t_odd\") {\n        int t = tvalue;\n        if (t % 2 != 1 || t < 1) {\n            fprintf(stderr, \"t must be odd and positive\\n\");\n            exit(1);\n        }\n        int x_max = int((1e9 - 1) / (t + 1));\n        int x = rnd.next(1, x_max);\n        int b = rnd.next(1, x - 1);\n        int a = (t + 1) * x - b;\n        if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n            x = 1;\n            b = 1;\n            a = (t + 1) * x - b;\n        }\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"t_zero\") {\n        /* t = 0 */\n        int a = rnd.next(1, int(1e9 - 1));\n        int b = a;\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"nosolution\") {\n        int a = rnd.next(1, int(1e9));\n        int b = rnd.next(1, int(1e9));\n        /* Ensure that a != b to avoid t=0 case */\n        if (a == b) a = (a % int(1e9)) + 1;\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"random\") {\n        int a = rnd.next(1, int(1e9));\n        int b = rnd.next(1, int(1e9));\n        printf(\"%d %d\\n\", a, b);\n    } else {\n        fprintf(stderr, \"Invalid type\\n\");\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    /* Read command-line options */\n    string type = opt<string>(\"type\", \"random_with_solution\");\n    int tvalue = opt<int>(\"t\", -1);\n\n    if (type == \"random_with_solution\") {\n        /* Randomly generate t (even or odd) and x */\n        int t = rnd.next(0, 100000);\n        if (tvalue != -1)\n            t = tvalue;\n        if (t % 2 == 0) {\n            /* t is even */\n            int x_max = t == 0 ? int(1e9) : int((1e9 - 1) / t);\n            int x = rnd.next(1, x_max);\n            int b = rnd.next(1, x - 1);\n            int a = t * x + b;\n            if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n                /* Adjust x and b */\n                x = 1;\n                b = 1;\n                a = t * x + b;\n            }\n            printf(\"%d %d\\n\", a, b);\n        } else {\n            /* t is odd */\n            int x_max = int((1e9 - 1) / (t + 1));\n            int x = rnd.next(1, x_max);\n            int b = rnd.next(1, x - 1);\n            int a = (t + 1) * x - b;\n            if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n                /* Adjust x and b */\n                x = 1;\n                b = 1;\n                a = (t + 1) * x - b;\n            }\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"t_even\") {\n        int t = tvalue;\n        if (t % 2 != 0 || t < 0) {\n            fprintf(stderr, \"t must be even and non-negative\\n\");\n            exit(1);\n        }\n        int x_max = t == 0 ? int(1e9) : int((1e9 - 1) / t);\n        int x = rnd.next(1, x_max);\n        int b = rnd.next(1, x - 1);\n        int a = t * x + b;\n        if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n            x = 1;\n            b = 1;\n            a = t * x + b;\n        }\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"t_odd\") {\n        int t = tvalue;\n        if (t % 2 != 1 || t < 1) {\n            fprintf(stderr, \"t must be odd and positive\\n\");\n            exit(1);\n        }\n        int x_max = int((1e9 - 1) / (t + 1));\n        int x = rnd.next(1, x_max);\n        int b = rnd.next(1, x - 1);\n        int a = (t + 1) * x - b;\n        if (a > int(1e9) || b > int(1e9) || a < 1 || b < 1) {\n            x = 1;\n            b = 1;\n            a = (t + 1) * x - b;\n        }\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"t_zero\") {\n        /* t = 0 */\n        int a = rnd.next(1, int(1e9 - 1));\n        int b = a;\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"nosolution\") {\n        int a = rnd.next(1, int(1e9));\n        int b = rnd.next(1, int(1e9));\n        /* Ensure that a != b to avoid t=0 case */\n        if (a == b) a = (a % int(1e9)) + 1;\n        printf(\"%d %d\\n\", a, b);\n    } else if (type == \"random\") {\n        int a = rnd.next(1, int(1e9));\n        int b = rnd.next(1, int(1e9));\n        printf(\"%d %d\\n\", a, b);\n    } else {\n        fprintf(stderr, \"Invalid type\\n\");\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type t_zero\n\n./gen -type t_even -t 0\n./gen -type t_even -t 2\n./gen -type t_even -t 100\n./gen -type t_even -t 1000\n./gen -type t_even -t 10000\n\n./gen -type t_odd -t 1\n./gen -type t_odd -t 3\n./gen -type t_odd -t 99\n./gen -type t_odd -t 999\n./gen -type t_odd -t 9999\n\n./gen -type random_with_solution\n./gen -type random_with_solution\n./gen -type random_with_solution\n./gen -type random_with_solution\n./gen -type random_with_solution\n\n./gen -type nosolution\n./gen -type nosolution\n./gen -type nosolution\n./gen -type nosolution\n./gen -type nosolution\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type t_even -t 0\n./gen -type t_even -t 2\n./gen -type t_even -t 4\n./gen -type t_even -t 6\n./gen -type t_even -t 8\n./gen -type t_even -t 10\n\n./gen -type t_odd -t 1\n./gen -type t_odd -t 3\n./gen -type t_odd -t 5\n./gen -type t_odd -t 7\n./gen -type t_odd -t 9\n\n./gen -type nosolution\n./gen -type nosolution\n./gen -type nosolution\n./gen -type nosolution\n./gen -type nosolution\n\n./gen -type t_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:02.169224",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}