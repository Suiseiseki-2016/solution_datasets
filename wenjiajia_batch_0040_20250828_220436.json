{
  "metadata": {
    "batch_number": 40,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.415683",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "360/E",
      "title": "E. Левко и игра",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано три целых числа n, m и k (1 ≤ n, m ≤ 104, 1 ≤ k ≤ 100). Во второй строке записано три целых числа s1, s2 и f (1 ≤ s1, s2, f ≤ n).В следующих m строках записаны дороги, длины которых нельзя менять. В каждой строке записано три целых числа ai, bi и ci (1 ≤ ai, bi ≤ n, 1 ≤ ci ≤ 109), обозначающих дорогу, ведущую из перекрестка ai в перекресток bi длины ci.В следующих k строках записаны дороги, длины которых можно менять. В каждой строке записано по четыре целых числа ai, bi, li и ri (1 ≤ ai, bi ≤ n, 1 ≤ li ≤ ri ≤ 109), обозначающих, что есть дорога из перекрестка ai в перекресток bi, длину которой Левко может установить в пределах [li, ri].Считайте, что перекрестки пронумерованы от 1 до n. Гарантируется, что из перекрестков s1 и s2 можно добраться до перекрестка f.",
      "output_spec": "Выходные данныеВ первой строке выведите строку «WIN» (без кавычек) — если Левко может победить в этой игре, «DRAW» (без кавычек) — если Левко может достичь ничьи и «LOSE» (без кавычек), если он точно проиграет.Если ответ «WIN» или «DRAW» во второй строке выведите k целых чисел через пробел — длины дорог, которые устанавливает Левко. Длины для дорог выводите в порядке следования дорог во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 1 31 3 43 2 21 2 1 32 4 1 33 4 1 3Выходные данныеСкопироватьWIN1 1 3 Входные данныеСкопировать4 1 31 3 43 2 21 2 1 32 4 1 33 4 1 2Выходные данныеСкопироватьDRAW1 1 2 Входные данныеСкопировать5 4 21 2 51 3 31 4 42 3 22 4 33 5 1 54 5 4 7Выходные данныеСкопироватьLOSE",
      "description": "E. Левко и игра\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано три целых числа n, m и k (1 ≤ n, m ≤ 104, 1 ≤ k ≤ 100). Во второй строке записано три целых числа s1, s2 и f (1 ≤ s1, s2, f ≤ n).В следующих m строках записаны дороги, длины которых нельзя менять. В каждой строке записано три целых числа ai, bi и ci (1 ≤ ai, bi ≤ n, 1 ≤ ci ≤ 109), обозначающих дорогу, ведущую из перекрестка ai в перекресток bi длины ci.В следующих k строках записаны дороги, длины которых можно менять. В каждой строке записано по четыре целых числа ai, bi, li и ri (1 ≤ ai, bi ≤ n, 1 ≤ li ≤ ri ≤ 109), обозначающих, что есть дорога из перекрестка ai в перекресток bi, длину которой Левко может установить в пределах [li, ri].Считайте, что перекрестки пронумерованы от 1 до n. Гарантируется, что из перекрестков s1 и s2 можно добраться до перекрестка f.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите строку «WIN» (без кавычек) — если Левко может победить в этой игре, «DRAW» (без кавычек) — если Левко может достичь ничьи и «LOSE» (без кавычек), если он точно проиграет.Если ответ «WIN» или «DRAW» во второй строке выведите k целых чисел через пробел — длины дорог, которые устанавливает Левко. Длины для дорог выводите в порядке следования дорог во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать4 1 31 3 43 2 21 2 1 32 4 1 33 4 1 3Выходные данныеСкопироватьWIN1 1 3 Входные данныеСкопировать4 1 31 3 43 2 21 2 1 32 4 1 33 4 1 2Выходные данныеСкопироватьDRAW1 1 2 Входные данныеСкопировать5 4 21 2 51 3 31 4 42 3 22 4 33 5 1 54 5 4 7Выходные данныеСкопироватьLOSE\n\nВходные данныеСкопировать4 1 31 3 43 2 21 2 1 32 4 1 33 4 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьWIN1 1 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 1 31 3 43 2 21 2 1 32 4 1 33 4 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьDRAW1 1 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 4 21 2 51 3 31 4 42 3 22 4 33 5 1 54 5 4 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьLOSE\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 360\\s*E"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\n\nbool is_reachable(int s, int f, int n) {\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (u == f) return true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    \n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int f = inf.readInt(1, n, \"f\");\n    inf.readEoln();\n    \n    adj.resize(n + 1);  // Nodes are numbered from 1 to n\n    \n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n        \n        adj[ai].push_back(bi);\n    }\n    \n    for (int i = 0; i < k; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n        \n        adj[ai].push_back(bi);\n    }\n    \n    ensuref(is_reachable(s1, f, n), \"There is no path from s1=%d to f=%d\", s1, f);\n    ensuref(is_reachable(s2, f, n), \"There is no path from s2=%d to f=%d\", s2, f);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\n\nbool is_reachable(int s, int f, int n) {\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (u == f) return true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    \n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int f = inf.readInt(1, n, \"f\");\n    inf.readEoln();\n    \n    adj.resize(n + 1);  // Nodes are numbered from 1 to n\n    \n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n        \n        adj[ai].push_back(bi);\n    }\n    \n    for (int i = 0; i < k; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n        \n        adj[ai].push_back(bi);\n    }\n    \n    ensuref(is_reachable(s1, f, n), \"There is no path from s1=%d to f=%d\", s1, f);\n    ensuref(is_reachable(s2, f, n), \"There is no path from s2=%d to f=%d\", s2, f);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\n\nbool is_reachable(int s, int f, int n) {\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (u == f) return true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    \n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int f = inf.readInt(1, n, \"f\");\n    inf.readEoln();\n    \n    adj.resize(n + 1);  // Nodes are numbered from 1 to n\n    \n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n        \n        adj[ai].push_back(bi);\n    }\n    \n    for (int i = 0; i < k; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n        \n        adj[ai].push_back(bi);\n    }\n    \n    ensuref(is_reachable(s1, f, n), \"There is no path from s1=%d to f=%d\", s1, f);\n    ensuref(is_reachable(s2, f, n), \"There is no path from s2=%d to f=%d\", s2, f);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF LLONG_MAX\n\nstruct Edge {\n    int to;\n    long long length;\n};\n\nint n, m, k;\nint s1, s2, f;\nvector<vector<Edge>> graphFixed;\nvector<vector<Edge>> graphAdjusted;\nvector<pair<int, int>> adjustableEdges; // stores (li, ri)\nvector<pair<int, int>> adjustableEdgesNodes; // stores (u, v)\n\nvector<long long> dijkstra(int start, const vector<vector<Edge>> &graph) {\n    vector<long long> dist(n + 1, INF);\n    dist[start] = 0;\n    set<pair<long long, int>> q;\n    q.insert({0, start});\n    while (!q.empty()) {\n        auto [d, v] = *q.begin();\n        q.erase(q.begin());\n        if (dist[v] < d) continue;\n        for (auto &edge : graph[v]) {\n            int to = edge.to;\n            long long len = edge.length;\n            if (dist[v] + len < dist[to]) {\n                dist[to] = dist[v] + len;\n                q.insert({dist[to], to});\n            }\n        }\n    }\n    return dist;\n}\n\nint verdictToInt(string verdict) {\n    if (verdict == \"WIN\") return 2;\n    if (verdict == \"DRAW\") return 1;\n    if (verdict == \"LOSE\") return 0;\n    return -1; // Invalid verdict\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Reading input data\n    n = inf.readInt(1, 10000);\n    m = inf.readInt(1, 10000);\n    k = inf.readInt(1, 100);\n    s1 = inf.readInt(1, n);\n    s2 = inf.readInt(1, n);\n    f = inf.readInt(1, n);\n\n    graphFixed.resize(n + 1);\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n);\n        int b = inf.readInt(1, n);\n        long long c = inf.readLong(1, 1000000000LL);\n        graphFixed[a].push_back({b, c});\n    }\n\n    adjustableEdges.resize(k);\n    adjustableEdgesNodes.resize(k);\n\n    for (int i = 0; i < k; i++) {\n        int a = inf.readInt(1, n);\n        int b = inf.readInt(1, n);\n        int li = inf.readInt(1, 1000000000);\n        int ri = inf.readInt(li, 1000000000);\n        adjustableEdgesNodes[i] = {a, b};\n        adjustableEdges[i] = {li, ri};\n    }\n\n    // Reading jury's answer\n    string juryVerdict = ans.readToken();\n    if (verdictToInt(juryVerdict) == -1)\n        quitf(_fail, \"Jury output verdict is invalid: '%s'\", juryVerdict.c_str());\n\n    vector<long long> juryAdjustments;\n    if (juryVerdict != \"LOSE\") {\n        for (int i = 0; i < k; i++) {\n            long long x = ans.readLong(1, 1000000000LL);\n            juryAdjustments.push_back(x);\n        }\n    }\n\n    // Reading participant's answer\n    string participantVerdict = ouf.readToken();\n    if (verdictToInt(participantVerdict) == -1)\n        quitf(_pe, \"Participant output verdict is invalid: '%s'\", participantVerdict.c_str());\n\n    vector<long long> participantAdjustments;\n    if (participantVerdict != \"LOSE\") {\n        for (int i = 0; i < k; i++) {\n            long long x = ouf.readLong(1, 1000000000LL, format(\"adjusted_length[%d]\", i+1).c_str());\n            participantAdjustments.push_back(x);\n            // Check if x is within allowed ranges\n            long long li = adjustableEdges[i].first;\n            long long ri = adjustableEdges[i].second;\n            if (x < li || x > ri)\n                quitf(_wa, \"Participant adjusted length %lld is out of range [%lld, %lld] for edge %d\", x, li, ri, i+1);\n        }\n    }\n\n    int juryVerdictValue = verdictToInt(juryVerdict);\n    int participantVerdictValue = verdictToInt(participantVerdict);\n\n    // Now, we need to process the participant's answer\n    // Build the adjusted graph with participant's adjustments\n    graphAdjusted = graphFixed;\n    if (participantVerdict != \"LOSE\") {\n        for (int i = 0; i < k; i++) {\n            int a = adjustableEdgesNodes[i].first;\n            int b = adjustableEdgesNodes[i].second;\n            long long c = participantAdjustments[i];\n            graphAdjusted[a].push_back({b, c});\n        }\n\n        // Compute distances\n        vector<long long> dist1 = dijkstra(s1, graphAdjusted);\n        vector<long long> dist2 = dijkstra(s2, graphAdjusted);\n        long long distLevko = dist1[f];\n        long long distZenyk = dist2[f];\n\n        if (distLevko < distZenyk && participantVerdict != \"WIN\") {\n            quitf(_wa, \"Participant should output 'WIN' but output '%s'\", participantVerdict.c_str());\n        } else if (distLevko == distZenyk && participantVerdict != \"DRAW\") {\n            quitf(_wa, \"Participant should output 'DRAW' but output '%s'\", participantVerdict.c_str());\n        } else if (distLevko > distZenyk) {\n            quitf(_wa, \"Participant cannot lose with adjustments provided\");\n        }\n    } else {\n        // Participant outputs 'LOSE'\n        // Check if jury's verdict is 'LOSE'\n        if (juryVerdictValue > participantVerdictValue) {\n            quitf(_wa, \"Participant says 'LOSE', but jury says '%s'\", juryVerdict.c_str());\n        } else {\n            // Accept participant's output of 'LOSE'\n            quitf(_ok, \"Participant outputs 'LOSE' correctly\");\n        }\n    }\n\n    // Now, compare participant's verdict with jury's verdict\n    if (participantVerdictValue < juryVerdictValue) {\n        // Participant's verdict is worse than jury's verdict\n        quitf(_wa, \"Participant's verdict '%s' is worse than jury's verdict '%s'\", participantVerdict.c_str(), juryVerdict.c_str());\n    } else if (participantVerdictValue == juryVerdictValue) {\n        // Participant's verdict matches jury's verdict\n        quitf(_ok, \"Participant's verdict '%s' matches jury's verdict\", participantVerdict.c_str());\n    } else {\n        // Participant's verdict is better than jury's verdict\n        quitf(_fail, \"Participant's verdict '%s' is better than jury's verdict '%s'\", participantVerdict.c_str(), juryVerdict.c_str());\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int s1 = opt<int>(\"s1\", 1);\n    int s2 = opt<int>(\"s2\", 2);\n    int f = opt<int>(\"f\", n);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that s1, s2, f are within [1, n]\n    s1 = max(1, min(n, s1));\n    s2 = max(1, min(n, s2));\n    f = max(1, min(n, f));\n\n    if (type == \"random\") {\n        vector<pair<int, int>> m_edges; // Edges that cannot be changed\n        vector<tuple<int, int, int, int>> k_edges; // Edges that can be changed with [li, ri]\n\n        // Ensure that s1 and s2 can reach f\n        // For simplicity, we create direct edges from s1 and s2 to f\n\n        // Initialize m_edges with edges from s1 to f and s2 to f\n        int edges_in_paths = 0;\n\n        if (s1 != f) {\n            m_edges.push_back({s1, f});\n            edges_in_paths++;\n        }\n\n        if (s2 != f && s2 != s1) {\n            m_edges.push_back({s2, f});\n            edges_in_paths++;\n        }\n\n        // Fill the rest of m_edges with random edges\n        for (int i = edges_in_paths; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            m_edges.push_back({u, v});\n        }\n\n        // Ensure we have exactly m edges\n        m_edges.resize(m);\n\n        // Generate k variable edges\n        for (int i = 0; i < k; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int li = rnd.next(1, (int)1e9);\n            int ri = rnd.next(li, (int)1e9);\n            k_edges.push_back({u, v, li, ri});\n        }\n\n        // Output according to the required format\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"%d %d %d\\n\", s1, s2, f);\n\n        // Output the m edges with random lengths\n        for (int i = 0; i < m; ++i) {\n            int u = m_edges[i].first;\n            int v = m_edges[i].second;\n            int c = rnd.next(1, (int)1e9);\n            printf(\"%d %d %d\\n\", u, v, c);\n        }\n\n        // Output the k variable edges\n        for (int i = 0; i < k; ++i) {\n            int u = get<0>(k_edges[i]);\n            int v = get<1>(k_edges[i]);\n            int li = get<2>(k_edges[i]);\n            int ri = get<3>(k_edges[i]);\n            printf(\"%d %d %d %d\\n\", u, v, li, ri);\n        }\n    } else {\n        // For simplicity, other types are treated as random in this example\n        // You may implement other types (e.g., winning, losing) as needed\n        // ...\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int s1 = opt<int>(\"s1\", 1);\n    int s2 = opt<int>(\"s2\", 2);\n    int f = opt<int>(\"f\", n);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that s1, s2, f are within [1, n]\n    s1 = max(1, min(n, s1));\n    s2 = max(1, min(n, s2));\n    f = max(1, min(n, f));\n\n    if (type == \"random\") {\n        vector<pair<int, int>> m_edges; // Edges that cannot be changed\n        vector<tuple<int, int, int, int>> k_edges; // Edges that can be changed with [li, ri]\n\n        // Ensure that s1 and s2 can reach f\n        // For simplicity, we create direct edges from s1 and s2 to f\n\n        // Initialize m_edges with edges from s1 to f and s2 to f\n        int edges_in_paths = 0;\n\n        if (s1 != f) {\n            m_edges.push_back({s1, f});\n            edges_in_paths++;\n        }\n\n        if (s2 != f && s2 != s1) {\n            m_edges.push_back({s2, f});\n            edges_in_paths++;\n        }\n\n        // Fill the rest of m_edges with random edges\n        for (int i = edges_in_paths; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            m_edges.push_back({u, v});\n        }\n\n        // Ensure we have exactly m edges\n        m_edges.resize(m);\n\n        // Generate k variable edges\n        for (int i = 0; i < k; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int li = rnd.next(1, (int)1e9);\n            int ri = rnd.next(li, (int)1e9);\n            k_edges.push_back({u, v, li, ri});\n        }\n\n        // Output according to the required format\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"%d %d %d\\n\", s1, s2, f);\n\n        // Output the m edges with random lengths\n        for (int i = 0; i < m; ++i) {\n            int u = m_edges[i].first;\n            int v = m_edges[i].second;\n            int c = rnd.next(1, (int)1e9);\n            printf(\"%d %d %d\\n\", u, v, c);\n        }\n\n        // Output the k variable edges\n        for (int i = 0; i < k; ++i) {\n            int u = get<0>(k_edges[i]);\n            int v = get<1>(k_edges[i]);\n            int li = get<2>(k_edges[i]);\n            int ri = get<3>(k_edges[i]);\n            printf(\"%d %d %d %d\\n\", u, v, li, ri);\n        }\n    } else {\n        // For simplicity, other types are treated as random in this example\n        // You may implement other types (e.g., winning, losing) as needed\n        // ...\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 4 -k 2 -s1 1 -s2 2 -f 5 -type random\n./gen -n 10 -m 15 -k 3 -type random\n./gen -n 50 -m 100 -k 10 -type random\n./gen -n 100 -m 200 -k 20 -type random\n./gen -n 500 -m 1000 -k 50 -type random\n./gen -n 1000 -m 5000 -k 100 -type random\n./gen -n 10000 -m 10000 -k 100 -type random\n./gen -n 10000 -m 5000 -k 100 -type random\n./gen -n 10000 -m 10000 -k 100 -type winning\n./gen -n 10000 -m 10000 -k 100 -type losing\n./gen -n 10000 -m 10000 -k 100 -type draw\n\n./gen -n 1 -m 1 -k 1 -s1 1 -s2 1 -f 1 -type random\n./gen -n 2 -m 1 -k 1 -type random\n./gen -n 3 -m 2 -k 1 -type random\n./gen -n 100 -m 10000 -k 100 -type random\n./gen -n 10000 -m 1 -k 1 -type random\n./gen -n 10000 -m 0 -k 100 -type random\n\n./gen -n 5000 -m 5000 -k 50 -type random\n./gen -n 10000 -m 10000 -k 0 -type random\n./gen -n 10000 -m 10000 -k 100 -type multiple_edges\n./gen -n 10000 -m 10000 -k 100 -type self_loops\n\n./gen -n 1000 -m 5000 -k 100 -s1 1 -s2 1 -f 1 -type random\n./gen -n 1000 -m 5000 -k 100 -s1 1 -s2 1 -f 2 -type random\n./gen -n 1000 -m 5000 -k 100 -s1 1 -s2 2 -f 1 -type random\n\n./gen -n 10000 -m 10000 -k 100 -type random\n\n# Cases with heavy edge weights\n./gen -n 1000 -m 5000 -k 100 -type random\n\n# Cases with minimal edge lengths\n./gen -n 1000 -m 5000 -k 100 -type random\n\n# Cases with edge length ranges tight\n./gen -n 1000 -m 5000 -k 100 -type random\n\n# Cases with edge length ranges from 1 to 1e9\n./gen -n 1000 -m 5000 -k 100 -type random\n\n# Cases where m = n^2 (remember m up to 1e4)\n./gen -n 100 -m 10000 -k 100 -type random\n\n# Additional cases\n./gen -n 9999 -m 9999 -k 99 -type random\n./gen -n 10000 -m 10000 -k 100 -type random\n./gen -n 10000 -m 10000 -k 1 -type random\n./gen -n 5000 -m 5000 -k 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:15.648488",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "361/A",
      "title": "A. Левко и таблица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке задано два целых числа n и k (1 ≤ n ≤ 100, 1 ≤ k ≤ 1000).",
      "output_spec": "Выходные данныеВыведите любую красивую таблицу. Левко не любит очень большие числа, поэтому все элементы таблицы не должны превышать по своему абсолютному значению 1000.Если существует несколько подходящих таблиц, разрешается вывести любую.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 4Выходные данныеСкопировать1 33 1Входные данныеСкопировать4 7Выходные данныеСкопировать2 1 0 44 0 2 11 3 3 00 3 2 2",
      "description": "A. Левко и таблица\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке задано два целых числа n и k (1 ≤ n ≤ 100, 1 ≤ k ≤ 1000).\n\nВходные данные\n\nВыходные данныеВыведите любую красивую таблицу. Левко не любит очень большие числа, поэтому все элементы таблицы не должны превышать по своему абсолютному значению 1000.Если существует несколько подходящих таблиц, разрешается вывести любую.\n\nВыходные данные\n\nВходные данныеСкопировать2 4Выходные данныеСкопировать1 33 1Входные данныеСкопировать4 7Выходные данныеСкопировать2 1 0 44 0 2 11 3 3 00 3 2 2\n\nВходные данныеСкопировать2 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 33 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1 0 44 0 2 11 3 3 00 3 2 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере сумма в первой строке 1 + 3 = 4, во второй строке 3 + 1 = 4, в первом столбце 1 + 3 = 4 и во втором столбце 3 + 1 = 4. Существуют и другие красивые таблицы для этого примера.Во втором примере сумма элементов в каждой строке и каждом столбце равна 7. Также возможны и другие таблицы, удовлетворяющие условию.",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 361\\s*A"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt();\n    int k = inf.readInt();\n\n    vector<vector<int>> table(n, vector<int>(n));\n\n    // Read the contestant's output table\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            // Read each element and ensure it's within the allowed range\n            table[i][j] = ouf.readInt(-1000, 1000, format(\"table[%d][%d]\", i + 1, j + 1));\n        }\n    }\n\n    // Check that the sum of each row equals k\n    for (int i = 0; i < n; ++i)\n    {\n        long long row_sum = 0;\n        for (int j = 0; j < n; ++j)\n            row_sum += table[i][j];\n        if (row_sum != k)\n            quitf(_wa, \"sum of row %d is %lld, expected %d\", i + 1, row_sum, k);\n    }\n\n    // Check that the sum of each column equals k\n    for (int j = 0; j < n; ++j)\n    {\n        long long col_sum = 0;\n        for (int i = 0; i < n; ++i)\n            col_sum += table[i][j];\n        if (col_sum != k)\n            quitf(_wa, \"sum of column %d is %lld, expected %d\", j + 1, col_sum, k);\n    }\n\n    // If all checks pass, the output is correct\n    quitf(_ok, \"Found a valid table for n = %d and k = %d\", n, k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If n or k not provided, set defaults\n    if (n == -1) n = rnd.next(1, 100);\n    if (k == -1) k = rnd.next(1, 1000);\n    \n    if (type == \"max_n\") {\n        n = 100;\n        k = rnd.next(1, 1000);\n    } else if (type == \"min_n\") {\n        n = 1;\n        k = rnd.next(1, 1000);\n    } else if (type == \"edge_k\") {\n        n = rnd.next(1, 100);\n        if (rnd.next(2)) k = 1;\n        else k = 1000;\n    } else if (type == \"k_div_n\") {\n        n = rnd.next(1, 100);\n        int m = rnd.next(1, 1000 / n);\n        k = n * m; // k divisible by n and within 1..1000\n    } else if (type == \"k_not_div_n\") {\n        n = rnd.next(2, 100);\n        do {\n            k = rnd.next(1, 1000);\n        } while (k % n == 0);\n    } else if (type == \"requires_negative\") {\n        n = rnd.next(2, 100); // n at least 2\n        k = rnd.next(1, n - 1); // k less than n\n    } else if (type == \"max_k\") {\n        n = rnd.next(1, 100);\n        k = 1000;\n    } else if (type == \"min_k\") {\n        n = rnd.next(1, 100);\n        k = 1;\n    } else if (type == \"random\") {\n        // n and k already set randomly\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If n or k not provided, set defaults\n    if (n == -1) n = rnd.next(1, 100);\n    if (k == -1) k = rnd.next(1, 1000);\n    \n    if (type == \"max_n\") {\n        n = 100;\n        k = rnd.next(1, 1000);\n    } else if (type == \"min_n\") {\n        n = 1;\n        k = rnd.next(1, 1000);\n    } else if (type == \"edge_k\") {\n        n = rnd.next(1, 100);\n        if (rnd.next(2)) k = 1;\n        else k = 1000;\n    } else if (type == \"k_div_n\") {\n        n = rnd.next(1, 100);\n        int m = rnd.next(1, 1000 / n);\n        k = n * m; // k divisible by n and within 1..1000\n    } else if (type == \"k_not_div_n\") {\n        n = rnd.next(2, 100);\n        do {\n            k = rnd.next(1, 1000);\n        } while (k % n == 0);\n    } else if (type == \"requires_negative\") {\n        n = rnd.next(2, 100); // n at least 2\n        k = rnd.next(1, n - 1); // k less than n\n    } else if (type == \"max_k\") {\n        n = rnd.next(1, 100);\n        k = 1000;\n    } else if (type == \"min_k\") {\n        n = rnd.next(1, 100);\n        k = 1;\n    } else if (type == \"random\") {\n        // n and k already set randomly\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type max_n\n./gen -type min_n\n./gen -type edge_k\n./gen -type k_div_n\n./gen -type k_not_div_n\n./gen -type requires_negative\n./gen -type max_k\n./gen -type min_k\n./gen -type k_div_n\n./gen -type k_not_div_n\n\n# Fixed n and varying k\n./gen -n 100 -type random\n./gen -n 1 -type random\n./gen -n 50 -type max_k\n./gen -n 50 -type min_k\n./gen -n 50 -type requires_negative\n\n# Fixed k and varying n\n./gen -k 1000 -type random\n./gen -k 1 -type random\n./gen -k 500 -type max_n\n./gen -k 500 -type min_n\n\n# Varying both n and k\n./gen -n 100 -k 1000 -type random\n./gen -n 50 -k 25 -type k_not_div_n\n./gen -n 99 -k 199 -type requires_negative\n\n# Additional random cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:17.483658",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "361/B",
      "title": "B. Левко и перестановка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записаны два целых числа n и k (1 ≤ n ≤ 105, 0 ≤ k ≤ n).",
      "output_spec": "Выходные данныеВ единственной строке выведите любую красивую перестановку или -1, если такой не существует.Если существует несколько подходящих перестановок, разрешается вывести любую.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 2Выходные данныеСкопировать2 4 3 1Входные данныеСкопировать1 1Выходные данныеСкопировать-1",
      "description": "B. Левко и перестановка\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записаны два целых числа n и k (1 ≤ n ≤ 105, 0 ≤ k ≤ n).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите любую красивую перестановку или -1, если такой не существует.Если существует несколько подходящих перестановок, разрешается вывести любую.\n\nВыходные данные\n\nВходные данныеСкопировать4 2Выходные данныеСкопировать2 4 3 1Входные данныеСкопировать1 1Выходные данныеСкопировать-1\n\nВходные данныеСкопировать4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 4 3 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере элементы 4 и 3 являются хорошими, потому что gcd(2, 4) = 2 > 1 и gcd(3, 3) = 3 > 1, а элементы 2 и 1 — нет, потому что gcd(1, 2) = 1 и gcd(4, 1) = 1. Так как хороших элементов ровно 2, перестановка является красивой.Во втором примере не существует красивой перестановки.",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 361\\s*B"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt();\n    int k = inf.readInt();\n\n    string contestantOutput = ouf.readLine();\n\n    // Remove leading and trailing whitespaces\n    contestantOutput = trim(contestantOutput);\n\n    if (contestantOutput == \"-1\") {\n        // Check if -1 is acceptable\n        if ((n == 1 && k == 1) || k == n) {\n            // Impossible cases, accept -1\n            quitf(_ok, \"Correct: impossible, contestant outputs -1\");\n        } else {\n            // Possible cases, -1 is incorrect\n            quitf(_wa, \"Contestant outputs -1 but a solution exists\");\n        }\n    } else {\n        // Attempt to read n integers from contestantOutput\n        istringstream iss(contestantOutput);\n        vector<int> p;\n        int x;\n        while (iss >> x) {\n            p.push_back(x);\n        }\n        if (p.size() != n) {\n            quitf(_wa, \"Contestant outputs wrong number of elements: expected %d, found %d\", n, p.size());\n        }\n        // Check that p is a permutation of [1..n]\n        vector<bool> used(n + 1, false); // Index from 1 to n\n        for (int i = 0; i < n; ++i) {\n            int pi = p[i];\n            if (pi < 1 || pi > n) {\n                quitf(_wa, \"pi[%d] = %d is out of range\", i + 1, pi);\n            }\n            if (used[pi]) {\n                quitf(_wa, \"pi[%d] = %d is repeated\", i + 1, pi);\n            }\n            used[pi] = true;\n        }\n        // Compute the number of good elements\n        int countGood = 0;\n        for (int i = 0; i < n; ++i) {\n            int pi = p[i];\n            int g = __gcd(i + 1, pi);\n            if (g > 1) {\n                countGood++;\n            }\n        }\n        if (countGood != k) {\n            quitf(_wa, \"Number of good elements is %d, expected %d\", countGood, k);\n        }\n        // Accept the answer as correct\n        quitf(_ok, \"Correct, number of good elements is %d\", k);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) n = rnd.next(1, 100000);\n\n    if (type == \"min_n\") {\n        n = 1;\n        if (k == -1) k = rnd.next(0, n);\n    } else if (type == \"max_n\") {\n        n = 100000;\n        if (k == -1) k = rnd.next(0, n - 1);\n    } else if (type == \"k_zero\") {\n        if (k == -1) k = 0;\n    } else if (type == \"k_equals_n_minus_1\") {\n        k = n - 1;\n    } else if (type == \"k_equals_n\") {\n        k = n;\n    } else if (type == \"impossible\") {\n        // According to problem constraints, when k = n, it's impossible to have such a permutation\n        k = n;\n    } else if (type == \"random\") {\n        if (k == -1) k = rnd.next(0, n - 1);\n    } else {\n        // Undefined type\n        cerr << \"Undefined type: \" << type << endl;\n        exit(1);\n    }\n\n    if (k < 0 || k > n) {\n        cerr << \"Invalid k: \" << k << endl;\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) n = rnd.next(1, 100000);\n\n    if (type == \"min_n\") {\n        n = 1;\n        if (k == -1) k = rnd.next(0, n);\n    } else if (type == \"max_n\") {\n        n = 100000;\n        if (k == -1) k = rnd.next(0, n - 1);\n    } else if (type == \"k_zero\") {\n        if (k == -1) k = 0;\n    } else if (type == \"k_equals_n_minus_1\") {\n        k = n - 1;\n    } else if (type == \"k_equals_n\") {\n        k = n;\n    } else if (type == \"impossible\") {\n        // According to problem constraints, when k = n, it's impossible to have such a permutation\n        k = n;\n    } else if (type == \"random\") {\n        if (k == -1) k = rnd.next(0, n - 1);\n    } else {\n        // Undefined type\n        cerr << \"Undefined type: \" << type << endl;\n        exit(1);\n    }\n\n    if (k < 0 || k > n) {\n        cerr << \"Invalid k: \" << k << endl;\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n\n./gen -type min_n -k 0\n./gen -type min_n -k 1\n\n./gen -type max_n\n./gen -type max_n -k 0\n./gen -type max_n -k 99999\n\n./gen -type k_zero -n 1\n./gen -type k_zero -n 1000\n./gen -type k_zero -n 50000\n./gen -type k_zero -n 100000\n\n./gen -type k_equals_n_minus_1 -n 10\n./gen -type k_equals_n_minus_1 -n 100\n./gen -type k_equals_n_minus_1 -n 1000\n./gen -type k_equals_n_minus_1 -n 100000\n\n./gen -type k_equals_n\n./gen -type k_equals_n -n 1\n./gen -type k_equals_n -n 2\n./gen -type k_equals_n -n 50000\n./gen -type k_equals_n -n 100000\n\n./gen -type impossible\n./gen -type impossible -n 1\n./gen -type impossible -n 2\n./gen -type impossible -n 99999\n./gen -type impossible -n 100000\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random -n 1000\n./gen -type random -n 50000\n./gen -type random -n 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:19.718346",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "361/C",
      "title": "C. Levko and Array Recovery",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000) — the size of the array and the number of operations in Levko's records, correspondingly.Next m lines describe the operations, the i-th line describes the i-th operation. The first integer in the i-th line is integer ti (1 ≤ ti ≤ 2) that describes the operation type. If ti = 1, then it is followed by three integers li, ri and di (1 ≤ li ≤ ri ≤ n,  - 104 ≤ di ≤ 104) — the description of the operation of the first type. If ti = 2, then it is followed by three integers li, ri and mi (1 ≤ li ≤ ri ≤ n,  - 5·107 ≤ mi ≤ 5·107) — the description of the operation of the second type.The operations are given in the order Levko performed them on his array.",
      "output_spec": "OutputIn the first line print \"YES\" (without the quotes), if the solution exists and \"NO\" (without the quotes) otherwise.If the solution exists, then on the second line print n integers a1, a2, ... , an (|ai| ≤ 109) — the recovered array.",
      "sample_tests": "ExamplesInputCopy4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 8OutputCopyYES4 7 4 7InputCopy4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 13OutputCopyNO",
      "description": "C. Levko and Array Recovery\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000) — the size of the array and the number of operations in Levko's records, correspondingly.Next m lines describe the operations, the i-th line describes the i-th operation. The first integer in the i-th line is integer ti (1 ≤ ti ≤ 2) that describes the operation type. If ti = 1, then it is followed by three integers li, ri and di (1 ≤ li ≤ ri ≤ n,  - 104 ≤ di ≤ 104) — the description of the operation of the first type. If ti = 2, then it is followed by three integers li, ri and mi (1 ≤ li ≤ ri ≤ n,  - 5·107 ≤ mi ≤ 5·107) — the description of the operation of the second type.The operations are given in the order Levko performed them on his array.\n\nOutputIn the first line print \"YES\" (without the quotes), if the solution exists and \"NO\" (without the quotes) otherwise.If the solution exists, then on the second line print n integers a1, a2, ... , an (|ai| ≤ 109) — the recovered array.\n\nInputCopy4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 8OutputCopyYES4 7 4 7InputCopy4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 13OutputCopyNO\n\nInputCopy4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 8\n\nOutputCopyYES4 7 4 7\n\nInputCopy4 51 2 3 12 1 2 82 3 4 71 1 3 32 3 4 13\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Hello!Codeforces Round #210 will take place on November 10 at 21.00 MSK and I am the author of the problems.This is my first round on Codeforces and I hope everything will be well. I would like to thank Gerald Agapov(Gerald) and Vitalii Aksenov(Aksenov239) for helping me to prepare the round.Good luck!UPD. Score distribution in first division: 500-1000-1500-1500-2000.Score distribution in second division: 500-1000-1500-2000-2500.UPD.Congratulations to the winners!First division: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Second division: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD.Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 623
        },
        {
          "title": "Codeforces Round #210 editorial - Codeforces",
          "content": "361A - Levko and TableMatrix,in which all diagonal elements equal k and other elements equal 0, satisfied all conditions.For example, if n = 4 and k = 7, our matrix will be7 0 0 00 7 0 00 0 7 00 0 0 7361B - Levko and Permutationgcd(1, m) = 1, so if n = k, there is no suitable permutation.It is well known that gcd(m, m - 1) = 1. Lets construct following permutation. It has exactly k good elements.n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Levko and Array RecoveryLet's find such value b[i] that a[i] ≤ b[i] for all indeces i. Let's simulate all operations and diff[i] will be the difference between current value of i-th element and its initial value. If we have operation of first type, we change values of diff[i]. If we have operation of second type, we know that a[i] + diff[i] ≤ m[i], so a[i] ≤ m[i] - diff[i]. We will get array b when we union all this inequalities.Let's prove that either b satisfied all conditions or there is no such array. It can be two cases, why b does not suit: — it's impossible due to construction of array b. — b[i] is a maximal possible value of a[i], so can't be bigger. 360B - Levko and ArrayLet's solve this problem using binary search. We need to check whether we can achieve an array, when c(a) will be at most x. Lets make dp. dp[i] means minimal number of elements with indeces less than i, which we need to change, but we don't change i-th element. Let's iterate next element j, which we don't change. Then we know that we can change all elements between i and j. It is equivalent to such condition |aj - ai| ≤ (j - i)·xDifference between neighboring elements can be at most x. The maximal possible difference increases by x exactly j - i times between elements i and j, so this inequality is correct. 360C - Levko and StringsLet's count amount of such substrings of t that are bigger than corresponding substring of s and begin at the position i. If t[i] < s[i], this amount equals 0. If t[i] > s[i], this amount equals n - i. If t[i] = s[i], then let's find such nearest position j,  j > i , that t[j] ≠ s[j]. If t[j] > s[j], needed amount of substrings will be n - j. If t[j] < s[j], needed amount of substrings will be 0. We can rephrase this: If t[i] > s[i], it will be (1 + pref)·(n - i) new substrings, where pref means how many last elements in s and t is equal.Let's make dp. dp[i][sum] means that we viewed i positions, have sum needed substrings and s[i] ≠ t[i]. Lets iterate their common prefix pref.If t[i] < s[i], dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — we can count this value using partial sums.If t[i] > s[i], dp[i][sum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Let's iterate pref. Let's note that sum - pref·(n - i) ≥ 0, so pref ≤ sum / (n - i) and pref ≤ k / (n - i). This means that third cycle will make at most k / (n - i) iterations when we find value of dp[i][sum]. Let's count total number of iterations:  =   <  k·(n + k·log  k).360D - Levko and Setsp is prime, so there exist primitive root g modulo p(We don't need to find it, but we know that it exists). We can write ai = gri. Note, that i-th set consists of all numbers , where cj ≥ 0, or we can write it as .By Fermat's little theorem ap - 1 = 1 mod p we have that ak mod p = ak mod (p - 1) mod p. So can be equal to all values k·t modulo p - 1, where t = gcd(b1, b2, ... , bm, p - 1). Note that t doesn't depend on ri, so we can assign g = gt. Then all elements of i-th set will be gri·k, where k ≥ 0. Now we can replace bi by qi, where qi = gcd(ri, p - 1), as we do with bi at the beginning. Then all elements of i-th set will be gqi·k, where k ≥ 0. This means that if we write all values g0, g1, ..., gp - 2 in a line, i-th set will contain every qi-th element.Now we need to find union of this sets.Let's do it using inclusion-exclusion principle. All our numbers are divisors of p - 1. Let's dpi be the coefficient near i in inclusion-exclusion principle(i is a divisor of p - 1) and we can find this values, adding all qi alternatively.Also we need to find qi. Let's find volume of the i-th set. It is equal to . From the other side it is equal to such minimal number di, that aidi = 1 mod p (di is a cycle). From aip - 1 = 1 mod p we have that p - 1 is divisible by di. So we can find di as a divisor of p - 1. And .360E - Levko and GameAlgorithm:Firstly we will solve problem if first player can win.Let's make all roads that we can change equal to r[i] and do two Dijkstra's algorithms from vertices s1 and s2. Let's d1[i] be the distance from s1 to i, d2[i] be the distance from s2 to i. Consider a road, that we can change, from a to b. If d1[a] < d2[a], we will set length of such road equal to l[i] and do two Dijkstra's algorithms again. We run such process until any road changes its length. If d1[f] < d2[f] after all changes then first player wins.If we replace condition d1[a] < d2[a] by d1[a] ≤ d2[a], we can check if Levko can end this game with a draw.Proof:Let's call \"edges\" only roads which Levko can change. When we do Dijkstra's algorithm we use all roads, not only edges. Let's prove that if there exist such edges values that first player wins, there exist values of edges such that first player wins and all this values equal either l[i] or r[i]. Consider shortest pathes of both players.If only first player goes on edge from a to b, we can set its value l[i]. Proof: there must hold d1[a] < d2[a] because first player goes on it and wins. This condition holds after change of value of this edge. If second player goes on this edge, he loses because d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f]. If second player doesn't go on this edge, he loses because shortest path of first player became smaller(d(x, y) — shortest path from x to y).If only second player goes on edge from a to b, we can set its value r[i]. Proof: Shortest path of the first player doesn't change and shortest path of second player can only become larger.If no player go on edge, we can set its value r[i]. Proof: Shortest pathes of both players doesn't change.If both players go on edge from a to b, we can set its value l[i]. Proof: Shortest pathes of both players decrease by (initial value of this edge — l[i]).After every such operation first player wins again and all edges become either l[i] or r[i]. Consider result of our algorithm. Let's call edge \"good\" if its value is equal to l[i] and \"bad\" if its value equals r[i].(a) Let's prove that after performing all operations we will have d1[a] < d2[a] for all good edges (a, b). If we have d1[a1] < d2[a1] for edge (a1, b1) and after changing value of (a2, b2) this condition doesn't hold. We have d1[a1] >  = d2[a1], d1[a2] < d2[a2]. We change only one edge and shortest path from s2 to f become shorter so edge (a2, b2) lies on this path.d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Contradiction. (b) Let's prove that after performing all operations we will have d1[a] ≥ d2[a] for all bad edges. We can continue our procces otherwise.(c) Let's prove that if condition d1[a] < d2[a] holds for some edge but we doesn't change it on this iteration, this continion holds after this iteration. Proof is same as in (a).(d) Let's prove that if any subset of good edges is equal to l[i] and d1[a] < d2[a], ift also holds when we make all good edges equal l[i]. Let's simulate all procces and use (c). Lets prove that for all edges values(not necessary only l[i] or r[i]), d1[a] ≥ d2[a] for all bad edges (a, b).Assume that we have such edge. Consider shortest path of first player to its beginning. If there exist bad edges (a1, b1) on this path, there must holds inequality d1[a1] < d2[a1]. Consider first of this bad edges (a, b). Then shortest path of first player to a doesn't consist any bad edge. Consider problem,m which is equivalent to our problem but finish is in vertex a. good and bad edges will be same. Let's change all value of edges as we do in item 1. Note? that all bad edges will be equal to r[i]. So only subset of good edges can be equal to l[i] and d1[a1] < d2[a1]. By (d) we have that we can set all good edges l[i] and condition d1[a1] < d2[a1] will be satisfied. So we have contradiction thst this edge is bad. This means that if first player goes on any bad edge, he loses. So we can set r[i] to all this edges. So we can set l[i] to some subset of good edges. By (d) we have that if we have d1[f] < d2[f] for some subset of good edges, this condition will be true if we set all good edges l[i]. Note that proof will be same if we want to check whether Levko can end a game with a draw.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 361 和字母"
          },
          "content_length": 8617
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int t_i = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        if (t_i == 1) {\n            int d_i = inf.readInt(-10000, 10000, \"d_i\");\n        } else { // t_i == 2\n            int m_i = inf.readInt(-50000000, 50000000, \"m_i\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int t_i = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        if (t_i == 1) {\n            int d_i = inf.readInt(-10000, 10000, \"d_i\");\n        } else { // t_i == 2\n            int m_i = inf.readInt(-50000000, 50000000, \"m_i\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int t_i = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        if (t_i == 1) {\n            int d_i = inf.readInt(-10000, 10000, \"d_i\");\n        } else { // t_i == 2\n            int m_i = inf.readInt(-50000000, 50000000, \"m_i\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    int n = inf.readInt();\n    int m = inf.readInt();\n    vector<int> t(m), l(m), r(m), d_or_m(m);\n    for (int i = 0; i < m; ++i) {\n        t[i] = inf.readInt();\n        l[i] = inf.readInt();\n        r[i] = inf.readInt();\n        d_or_m[i] = inf.readInt();\n    }\n\n    // Read jury's output\n    string jVerdict = ans.readToken();\n    if (jVerdict != \"YES\" && jVerdict != \"NO\")\n        quitf(_fail, \"Jury output is neither YES nor NO\");\n\n    // Read contestant's output\n    string pVerdict = ouf.readToken();\n    if (pVerdict != \"YES\" && pVerdict != \"NO\")\n        quitf(_pe, \"Contestant output is neither YES nor NO\");\n\n    if (jVerdict == \"NO\") {\n        if (pVerdict == \"NO\") {\n            quitf(_ok, \"Answer is NO\");\n        } else {\n            // Jury says NO, contestant says YES\n            quitf(_fail, \"Jury says NO, but contestant outputs YES\");\n        }\n    } else { // Jury says YES\n        if (pVerdict == \"NO\") {\n            quitf(_wa, \"Jury says YES, but contestant outputs NO\");\n        } else { // Both say YES\n            // Read contestant's array\n            vector<ll> a(n);\n            for (int i = 0; i < n; ++i) {\n                a[i] = ouf.readLong(-1000000000ll, 1000000000ll, format(\"a[%d]\", i+1).c_str());\n            }\n            // Simulate the operations\n            vector<ll> current_a = a;\n            for (int i = 0; i < m; ++i) {\n                int op_t = t[i];\n                int op_l = l[i]-1; // zero-based index\n                int op_r = r[i]-1;\n                int op_d = d_or_m[i];\n                if (op_t == 1) {\n                    int d = op_d;\n                    for (int j = op_l; j <= op_r; ++j)\n                        current_a[j] += d;\n                } else if (op_t == 2) {\n                    int expected_m = op_d;\n                    ll max_a = *max_element(current_a.begin() + op_l, current_a.begin() + op_r + 1);\n                    if (max_a != expected_m)\n                        quitf(_wa, \"In operation %d, expected max %d, found %lld\", i+1, expected_m, max_a);\n                } else {\n                    quitf(_fail, \"Invalid operation type %d in input\", op_t);\n                }\n            }\n            quitf(_ok, \"Correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> a(n, 0); // Initial array (not outputted, used internally)\n    vector<tuple<int, int, int, int>> operations; // Store operations\n\n    if (type == \"random\") {\n        // Generate random operations\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = rnd.next(-10000, 10000);\n                operations.emplace_back(t, l, r, d);\n                // Apply increment to the array\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                }\n            } else {\n                // Prepare mi based on current array\n                int mi = *max_element(a.begin() + l - 1, a.begin() + r);\n                // Add some randomness to mi within allowed bounds\n                int delta = rnd.next(-100, 100);\n                mi = max(-50000000, min(50000000, mi + delta));\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"max_values\") {\n        // Operations with maximum allowed values\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = 10000 * (rnd.next(0, 1) ? 1 : -1);\n                operations.emplace_back(t, l, r, d);\n                // Apply increment\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                    a[j] = max(-1000000000, min(1000000000, a[j]));\n                }\n            } else {\n                int mi;\n                if (rnd.next(0, 1)) {\n                    mi = 50000000;\n                } else {\n                    mi = -50000000;\n                }\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"negative_increments\") {\n        // Operations with negative increments\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = rnd.next(-10000, -1);\n                operations.emplace_back(t, l, r, d);\n                // Apply increment\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                }\n            } else {\n                int mi = *max_element(a.begin() + l - 1, a.begin() + r);\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"conflicting_queries\") {\n        // Generate conflicting maximum queries to produce 'NO' cases\n        for (int i = 0; i < m / 2; ++i) {\n            // First, set maximums to a certain value\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int mi = rnd.next(-50000000, 50000000);\n            operations.emplace_back(2, l, r, mi);\n        }\n        for (int i = m / 2; i < m; ++i) {\n            // Then, create conflicting maximums\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int mi = rnd.next(-50000000, 50000000);\n            // Ensure conflict\n            if (i % 2 == 0) mi += 1000000;\n            else mi -= 1000000;\n            operations.emplace_back(2, l, r, mi);\n        }\n    } else if (type == \"tight_constraints\") {\n        // Generate increments and maximums that push variables to their limits\n        fill(a.begin(), a.end(), 0);\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = rnd.next(9990, 10000) * (rnd.next(0, 1) ? 1 : -1);\n                operations.emplace_back(t, l, r, d);\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                    a[j] = max(-1000000000, min(1000000000, a[j]));\n                }\n            } else {\n                // mi is the exact maximum in the range\n                int mi = *max_element(a.begin() + l - 1, a.begin() + r);\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate 'NO' cases by setting impossible maximums\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int mi = rnd.next(-50000000, 50000000);\n            operations.emplace_back(2, l, r, mi);\n            // Apply a conflicting maximum\n            operations.emplace_back(2, l, r, mi - rnd.next(1, 10000));\n        }\n    } else if (type == \"edge_case\") {\n        // Edge cases with n = 1 and m = 1\n        n = 1;\n        m = 1;\n        printf(\"%d %d\\n\", n, m);\n        int t = 2; // Maximum query\n        int l = 1, r = 1;\n        int mi = rnd.next(-50000000, 50000000);\n        operations.emplace_back(t, l, r, mi);\n    }\n\n    // Output the operations\n    for (auto op : operations) {\n        int t = get<0>(op);\n        int l = get<1>(op);\n        int r = get<2>(op);\n        int d_or_mi = get<3>(op);\n        if (t == 1) {\n            // Increment operation\n            printf(\"1 %d %d %d\\n\", l, r, d_or_mi);\n        } else {\n            // Maximum query\n            printf(\"2 %d %d %d\\n\", l, r, d_or_mi);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> a(n, 0); // Initial array (not outputted, used internally)\n    vector<tuple<int, int, int, int>> operations; // Store operations\n\n    if (type == \"random\") {\n        // Generate random operations\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = rnd.next(-10000, 10000);\n                operations.emplace_back(t, l, r, d);\n                // Apply increment to the array\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                }\n            } else {\n                // Prepare mi based on current array\n                int mi = *max_element(a.begin() + l - 1, a.begin() + r);\n                // Add some randomness to mi within allowed bounds\n                int delta = rnd.next(-100, 100);\n                mi = max(-50000000, min(50000000, mi + delta));\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"max_values\") {\n        // Operations with maximum allowed values\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = 10000 * (rnd.next(0, 1) ? 1 : -1);\n                operations.emplace_back(t, l, r, d);\n                // Apply increment\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                    a[j] = max(-1000000000, min(1000000000, a[j]));\n                }\n            } else {\n                int mi;\n                if (rnd.next(0, 1)) {\n                    mi = 50000000;\n                } else {\n                    mi = -50000000;\n                }\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"negative_increments\") {\n        // Operations with negative increments\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = rnd.next(-10000, -1);\n                operations.emplace_back(t, l, r, d);\n                // Apply increment\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                }\n            } else {\n                int mi = *max_element(a.begin() + l - 1, a.begin() + r);\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"conflicting_queries\") {\n        // Generate conflicting maximum queries to produce 'NO' cases\n        for (int i = 0; i < m / 2; ++i) {\n            // First, set maximums to a certain value\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int mi = rnd.next(-50000000, 50000000);\n            operations.emplace_back(2, l, r, mi);\n        }\n        for (int i = m / 2; i < m; ++i) {\n            // Then, create conflicting maximums\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int mi = rnd.next(-50000000, 50000000);\n            // Ensure conflict\n            if (i % 2 == 0) mi += 1000000;\n            else mi -= 1000000;\n            operations.emplace_back(2, l, r, mi);\n        }\n    } else if (type == \"tight_constraints\") {\n        // Generate increments and maximums that push variables to their limits\n        fill(a.begin(), a.end(), 0);\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            if (t == 1) {\n                int d = rnd.next(9990, 10000) * (rnd.next(0, 1) ? 1 : -1);\n                operations.emplace_back(t, l, r, d);\n                for (int j = l - 1; j <= r - 1; ++j) {\n                    a[j] += d;\n                    a[j] = max(-1000000000, min(1000000000, a[j]));\n                }\n            } else {\n                // mi is the exact maximum in the range\n                int mi = *max_element(a.begin() + l - 1, a.begin() + r);\n                operations.emplace_back(t, l, r, mi);\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate 'NO' cases by setting impossible maximums\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int mi = rnd.next(-50000000, 50000000);\n            operations.emplace_back(2, l, r, mi);\n            // Apply a conflicting maximum\n            operations.emplace_back(2, l, r, mi - rnd.next(1, 10000));\n        }\n    } else if (type == \"edge_case\") {\n        // Edge cases with n = 1 and m = 1\n        n = 1;\n        m = 1;\n        printf(\"%d %d\\n\", n, m);\n        int t = 2; // Maximum query\n        int l = 1, r = 1;\n        int mi = rnd.next(-50000000, 50000000);\n        operations.emplace_back(t, l, r, mi);\n    }\n\n    // Output the operations\n    for (auto op : operations) {\n        int t = get<0>(op);\n        int l = get<1>(op);\n        int r = get<2>(op);\n        int d_or_mi = get<3>(op);\n        if (t == 1) {\n            // Increment operation\n            printf(\"1 %d %d %d\\n\", l, r, d_or_mi);\n        } else {\n            // Maximum query\n            printf(\"2 %d %d %d\\n\", l, r, d_or_mi);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with small n and m\n./gen -n 10 -m 20 -type random\n./gen -n 50 -m 100 -type random\n\n# Random test cases with medium n and m\n./gen -n 1000 -m 1000 -type random\n./gen -n 2000 -m 2000 -type random\n\n# Random test cases with maximum n and m\n./gen -n 5000 -m 5000 -type random\n\n# Test cases with maximum allowed values\n./gen -n 5000 -m 5000 -type max_values\n\n# Test cases with negative increments\n./gen -n 1000 -m 1000 -type negative_increments\n./gen -n 5000 -m 5000 -type negative_increments\n\n# Test cases designed to produce 'NO' outputs due to conflicting queries\n./gen -n 1000 -m 1000 -type conflicting_queries\n./gen -n 5000 -m 5000 -type conflicting_queries\n\n# Test cases with tight constraints on maximum values\n./gen -n 1000 -m 1000 -type tight_constraints\n./gen -n 5000 -m 5000 -type tight_constraints\n\n# Impossible test cases where no solution exists\n./gen -n 1000 -m 1000 -type impossible\n./gen -n 5000 -m 5000 -type impossible\n\n# Edge case with n = 1 and m = 1\n./gen -n 1 -m 1 -type edge_case\n\n# Edge case with n = 1 and m = 5000\n./gen -n 1 -m 5000 -type random\n\n# Edge case with n = 5000 and m = 1\n./gen -n 5000 -m 1 -type random\n\n# Mixed types for thorough testing\n./gen -n 1000 -m 2000 -type random\n./gen -n 2000 -m 3000 -type negative_increments\n./gen -n 3000 -m 4000 -type tight_constraints\n./gen -n 4000 -m 5000 -type conflicting_queries\n\n# Test cases with minimal increments and decrements\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type negative_increments\n\n# Test cases with only maximum queries\n./gen -n 1000 -m 1000 -type impossible\n\n# Test cases to check the lower bounds\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 3 -m 3 -type random\n\n# Test cases to check the upper bounds\n./gen -n 5000 -m 5000 -type random\n./gen -n 5000 -m 5000 -type max_values\n\n# Large test cases mixing types to simulate real-world usage\n./gen -n 5000 -m 5000 -type random\n./gen -n 5000 -m 5000 -type negative_increments\n./gen -n 5000 -m 5000 -type tight_constraints\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:21.580653",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "361/D",
      "title": "D. Левко и массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и k (1 ≤ k ≤ n ≤ 2000). Во второй строке через пробел записаны целые числа a1, a2, ... , an ( - 109 ≤ ai ≤ 109).",
      "output_spec": "Выходные данныеЕдинственное число — минимальное значение c(a), которое может получить Левко.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 24 7 4 7 4Выходные данныеСкопировать0Входные данныеСкопировать3 1-100 0 100Выходные данныеСкопировать100Входные данныеСкопировать6 31 2 3 7 8 9Выходные данныеСкопировать1",
      "description": "D. Левко и массив\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и k (1 ≤ k ≤ n ≤ 2000). Во второй строке через пробел записаны целые числа a1, a2, ... , an ( - 109 ≤ ai ≤ 109).\n\nВходные данные\n\nВыходные данныеЕдинственное число — минимальное значение c(a), которое может получить Левко.\n\nВыходные данные\n\nВходные данныеСкопировать5 24 7 4 7 4Выходные данныеСкопировать0Входные данныеСкопировать3 1-100 0 100Выходные данныеСкопировать100Входные данныеСкопировать6 31 2 3 7 8 9Выходные данныеСкопировать1\n\nВходные данныеСкопировать5 24 7 4 7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 1-100 0 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать100\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 31 2 3 7 8 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Левко может изменить второй и четвертый элементы и получить массив: 4, 4, 4, 4, 4.В третьем примере он может получить массив: 1, 2, 3, 4, 5, 6.",
      "solutions": [
        {
          "title": "Codeforces Round #210 - Codeforces",
          "content": "Всем привет!Скоро, 10 ноября в 21.00 MSK состоится Codeforces Round #210 и его автором буду я. Это мой первый раунд на Codeforces и я очень надеюсь, что все пройдет хорошо. Спасибо Геральду Агапову (Gerald) и Виталию Аксенову(Aksenov239) за помощь в подготовке раунда.Удачи!UPD. Разбалловка в первом дивизионе: 500-1000-1500-1500-2000.Разбалловка во втором дивизионе: 500-1000-1500-2000-2500.UPD.Поздравляем победителей!Первый дивизион: Egor PavelKunyavskiy scott_wu Dmitry_Egorov mmaxio enot110 sevenkplus Второй дивизион: _ZigZig_ budalnik Ilya_Yakovlev Neodym UPD. Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 574
        },
        {
          "title": "Разбор Codeforces Round #210 - Codeforces",
          "content": "361A - Левко и таблицаМатрица, у которой все диагональные элементы равны k, а другие 0 удовлетворяет условие. Например для n = 4, k = 7 она будет такой:7 0 0 00 7 0 00 0 7 00 0 0 7361B - Левко и перестановкаТак, как gcd(1, m) = 1, то при n = k ответа не существует.Воспользуемся фактом, что gcd(m, m - 1) = 1 и построим такую перестановку:n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Левко и восстановление массиваНайдем для каждой позиции i такое значение b[i], что a[i] ≤ b[i]. Что бы найти эти значения, будем симулировать операции, поддерживая массив diff[i] — разница между теперешним значением i-ого элемента и его начальным значением. Если операция первого типа, то меняем нужные значения delta[i], иначе мы знаем, что a[i] + diff[i] ≤ m[i], из этого следует, что a[i] ≤ m[i] - diff[i]. Объединим все эти неравенства и мы получим массив b.Докажем, что либо b удовлетворяет условие, либо такого массива не существует. Возможны два варианта не выполнения операции второго типа: — но это невозможно из построения массива b. — но мы взяли на каждой позиции максимум, то есть мы не можем получить значение больше и чтобы при этом выполнялись все другие условия. 360B - Левко и массивСделаем бинпоиск по ответу. Чтобы проверить можно ли достичь ответа x, сделаем дп.dp[i] — это минимальное количество элементов, которые нужно изменить до i-ого, и при том i-ый элемент мы не меняем. Перебираем следующий элемент j, который мы не меняем. Тогда мы знаем, что элементы i и j мы не меняем, а все остальные между ними можем менять. Чтобы проверить можем ли мы так сделать, нужно всего лишь, чтобы выполнялось условие |aj - ai| ≤ (j - i)·xЭто так, потому что между соседними разница может быть максимум x, а между элементами i и j ровно j - i раз разница может увеличиваться на x.360C - Левко и строкиПосчитаем количество таких подстрок t, которые больше соответствующих подстрок s и начинаются в позиции i. Если t[i] < s[i], то 0. Если t[i] > s[i], то n - i. Если t[i] = s[i], то найдем ближайшую позицию j,  j > i , такую, что t[j] ≠ s[j]. Если t[j] > s[j], то нужное количество подстрок будет n - j. Если t[j] < s[j], то 0.Это мы можем переформулировать так: Если t[i] > s[i], то будет (1 + pref)·(n - i) новых подстрок, где pref означает сколько последних перед i элементов из s и t равны.Сделаем дп. dp[i][sum] — значит, что мы просмотрели i позиций и набрали sum нужных подстрок, при этом значение t и s в i-ой позиции отличаются. Будем делать ее назад. Переберем общий префикс pref этих строк и то больше или меньше t[i].Если t[i] < s[i], то dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — это посчитаем частичными сумами.Если t[i] > s[i], то dp[i][smum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Будем перебирать pref. Заметим, что sum - pref·(n - i) ≥ 0, то есть pref ≤ sum / (n - i) и pref ≤ k / (n - i). Это значит, что при нахождении значения dp[i][sum] третий цикл выполнит не больше k / (n - i) итераций. Посчитаем общее количество итераций:  =   <  k·(n + k·log  k).360D - Левко и множестваТак, как число p — простое, то должен существовать первообразный корень g по модулю p(Явно мы его не находим, пусть просто он есть). Тогда запишем каждое ai = gri. Заметим, что в i-ом множестве будут находиться все числа вида , где cj ≥ 0. Это можно записать как .Малая теорема Ферма — ap - 1 = 1 mod p. Это также значит, что ak mod p = ak mod (p - 1) mod p. Из этого следует, что может принимать все значения k·t по модулю p - 1, где t = gcd(b1, b2, ... , bm, p - 1). Заметим, что t никак не зависит от ri, поэтому мы можем сделать g = gt. Тогда все элементы с i-ого множества будут выглядить, как gri·k, где k ≥ 0. Заметим, что мы получили приктически такой же запис как и с bi в начале, сделаем то же. Заменим ri на qi, где qi = gcd(ri, p - 1). Тогда все элементы с i-ого множества будут выглядить, как gqi·k, где k ≥ 0. Это значит, что если мы запишем значения g0, g1, ..., gp - 2 в строку, то в i-ом множестве будет каждый qi-ый.Теперь чтобы найти объединение этих множеств, нам нужно применить принцип включения-исключения. Так как все числа, которые мы маем — делители p - 1, то мы можем добавлять qi по одному, поддержывая dpi — коефициэнт возле i в принцыпе включения-исключения.Нам осталось найти qi. Рассмотрим количество элементов в i-ом множестве. С одной стороны оно равно . С другой стороны это количество равно минимальному такому значению di, что aidi = 1 mod p (di — цыкл). Из того что aip - 1 = 1 mod p маем, что p - 1 делится на di. Найдем di среди делителей p - 1. Теперь .360E - Левко и играАлгоритм:Сначала будем решать задачу, может ли первый победить.Сделаем все дороги, которые можно менять, равными r[i] и запустим две Дейкстры из вершын s1 и s2. Пусть массив d1[i] — расстояное от s1 до i, d2[i] — расстояние от s2 до i. Рассмотрим дорогу из a в b, которую можно менять. Если d1[a] < d2[a], то поставим длину этой дороги равной l[i] и опять запустим две Дейкстры. Так делаем пока мы можем изменить значение хотя бы одной дороги.Если в конце у нас получилось d1[f] < d2[f], то первый может победить.Дальше повторим тоже самое, только условие d1[a] < d2[a] меняем на d1[a] ≤ d2[a]. Это нам даст, может ли первый игрок достичь ничьи.Доказательство:Будем называть ребрами только те дороги, которые Левко может менять. Причем, если мы запускаем Дейкстру из какой-то вершины, то мы учитываем все дороги. Докажем, что если существует расклад значений ребер, при котором первый игрок выигрывает, то существует такой, при котором он выигрывает и все ребра равны либо l[i], либо r[i]. Возьмем кратчайшие пути первого и второго игрока из данного расклада.Тогда если по ребру из a в b проходит только первый, то мы можем установить его значение l[i]. Доказательство: для этого ребра должно выполняться d1[a] < d2[a], потому что первому выгодно по нему проходить и он выигрывает. Это условие выполняться и после изменения значения ребра. Тогда второй либо идет по нему и проигрывает потому, что d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f] , либо не идет и тоже проигрывает потому, что расстояние первого уменьшилось, а его нет(d(x, y) — кратчайшее расстояние между x и y).Если по ребру проходит только второй, то можем поставить r[i]. Доказательство: Первый по нему проходить и так не будет, а путь второго от этого меньше не станет.Если по ребру не проходит ни один игрок поставим его равным r[i]. Доказательство: Пути игроков никак не изменяться.Если по ребру проходят оба игрока, то поставим l[i]. Доказательство: Пути обоих игроков уменьшаться на (предыдущее значение — l[i]).После каждой из этих операций если первый выигрывал, то он и продолжает выигрывать, но в конце у нас получаться все ребра равными либо l[i], либо r[i]. Рассмотрим результат выполнения алгоритма: некоторые ребра будут равны l[i], а некоторые r[i]. Назовем ребра хорошими если на них теперь стоит l[i] и плохими — если r[i].(a) Докажем, что в конце для всех хороших ребер выполняется условие d1[a] < d2[a]. Докажем от супротивного. Пусть у нас для ребра (a1, b1) выполнялось d1[a1] < d2[a1], а после нескольких итераций перестало выполняться. Пусть оно перестало выполняться, после изменения ребра (a2, b2). Тогда мы маем такие неравенства d1[a1] >  = d2[a1], d1[a2] < d2[a2]. Так как мы изменили только одно ребро и расстояние второго игрока до а1 уменьшилось, то на кратчайшем от него до а1 он идет по ребру (a2, b2).d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Получили противоречие.(b) Докажем, что в конце для всех плохих ребер выполняется условие d1[a] ≥ d2[a]. Если бы оно не выполнялось, то мы продолжили бы наш процесс.(c) Докажем, что если для какого-то ребра стало выполняться условие d1[a] < d2[a], но на этом шаге мы его не изменили(изменили другое), то это условие не может перестать выполняться. Оно доказывается аналогично (a).(d) Докажем, что если у нас какое-то подмножество хороших ребер равны l[i] и для ребра (a, b) выполняется условие, то оно не может перестать выполняться после того, как мы поставим все хорошие ребра поставить равными l[i]. Для этого просто симулируем весь процесс, применяя (c). Докажем, что при любом раскладе ребер(даже не обязательно только l[i] или r[i]) мы не можем получить ситуации, в которой для плохого ребра (a, b) выполняется условие d1[a] < d2[a].Докажем от супротивного. Пусть у нас существует такое ребро. Рассмотрит путь первого до его начала. Если на этом пути есть плохие ребра (a1, b1), то для них тоже должно выполняться условие d1[a1] < d2[a1] (Если не выполняется , то d2[a] ≤ d2[a1] + d(a1, b1) + d(b1, a) ≤ d1[a1] + d(a1, b1) + d(b1, a) = d1[a]. Противоречие.) . Возьмем первое из них. Тогда путь первого до его начала может содержать только хорошие ребра. Рассмотрим задачу, аналогичную нашей, но с финишем в вершине a1 вместо f. Плохие и хорошие ребра будут такими же, потому что они не зависят от финиша. У нас должен победить первый игрок. Изменим все ребра на l[i] и r[i] так, как мы это делали в первом пункте. Заметим, что все плохие ребра будут равными r[i], потому что первый в кратчайшем пути по них не проходит. То есть у нас получилось, что у нас только подмножество хороших ребер равны l[i] и для ребра (a1, b1) выполняется условие d1[a1] < d2[a1]. С (d) получается, что условие для этого ребра должно выполняться и после того, как мы все хорошие ребра поставим равными l[i]. А это противоречит тому, что это ребро плохое. Это значит, что при любом раскладе первому не выгодно идти через плохие ребра. Поэтому мы можем всем им поставить r[i]. Теперь l[i] мы можем поставить только подмножеству хороших ребер. Пусть для него у нас выполняется d1[F] < d2[F]. Но за свойством (d) у нас это будет выполняться и если мы все хорошие ребра поставим равными l[i]. Заметим, что у нас доказательство практически не измениться, если Левко хочет завершить игру ничьей.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 361 和字母"
          },
          "content_length": 9841
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #210 - Codeforces - Code 1",
          "code": "Несложно доказать, что либо массив b будет удовлетворять условие, либо такого массива не существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9529",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"same\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"two_values\") {\n        int val1 = rnd.next(-1000000000, 1000000000);\n        int val2 = rnd.next(-1000000000, 1000000000);\n        while (val2 == val1)\n            val2 = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (type == \"ascending\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"descending\") {\n        int start = rnd.next(-1000000000 + n, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"extreme_values\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? -1000000000 : 1000000000;\n    } else if (type == \"constant\") {\n        int val = opt<int>(\"value\");\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_range\") {\n        int val = rnd.next(-10000, 10000);\n        int range = opt<int>(\"range\", 5);\n        for (int i = 0; i < n; ++i)\n            a[i] = val + rnd.next(-range, range);\n    } else if (type == \"few_unique\") {\n        int unique = opt<int>(\"unique\", 3);\n        vector<int> values;\n        for (int i = 0; i < unique; ++i)\n            values.push_back(rnd.next(-1000000000, 1000000000));\n        for (int i = 0; i < n; ++i)\n            a[i] = values[rnd.next(0, unique-1)];\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"same\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"two_values\") {\n        int val1 = rnd.next(-1000000000, 1000000000);\n        int val2 = rnd.next(-1000000000, 1000000000);\n        while (val2 == val1)\n            val2 = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (type == \"ascending\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"descending\") {\n        int start = rnd.next(-1000000000 + n, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"extreme_values\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? -1000000000 : 1000000000;\n    } else if (type == \"constant\") {\n        int val = opt<int>(\"value\");\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_range\") {\n        int val = rnd.next(-10000, 10000);\n        int range = opt<int>(\"range\", 5);\n        for (int i = 0; i < n; ++i)\n            a[i] = val + rnd.next(-range, range);\n    } else if (type == \"few_unique\") {\n        int unique = opt<int>(\"unique\", 3);\n        vector<int> values;\n        for (int i = 0; i < unique; ++i)\n            values.push_back(rnd.next(-1000000000, 1000000000));\n        for (int i = 0; i < n; ++i)\n            a[i] = values[rnd.next(0, unique-1)];\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n./gen -n 1 -k 1 -type random\n\n./gen -n 10 -k 0 -type same\n./gen -n 10 -k 5 -type same\n\n./gen -n 10 -k 3 -type two_values\n\n./gen -n 10 -k 3 -type ascending\n\n./gen -n 10 -k 3 -type descending\n\n./gen -n 10 -k 5 -type extreme_values\n\n./gen -n 100 -k 5 -type small_range -range 2\n\n./gen -n 100 -k 10 -type few_unique -unique 2\n\n./gen -n 2000 -k 0 -type random\n./gen -n 2000 -k 1000 -type random\n./gen -n 2000 -k 2000 -type random\n\n./gen -n 2000 -k 1000 -type extreme_values\n\n./gen -n 2000 -k 1000 -type ascending\n\n./gen -n 2000 -k 1000 -type descending\n\n./gen -n 2000 -k 0 -type same\n\n./gen -n 2000 -k 1000 -type two_values\n\n./gen -n 2000 -k 500 -type small_range -range 1\n\n./gen -n 2000 -k 500 -type few_unique -unique 5\n\n./gen -n 2000 -k 0 -type random\n\n./gen -n 2000 -k 2000 -type random\n\n./gen -n 10 -k 10 -type random\n\n./gen -n 50 -k 25 -type random\n./gen -n 100 -k 50 -type random\n\n./gen -n 1 -k 1 -type same\n./gen -n 2 -k 1 -type extreme_values\n\n./gen -n 2000 -k 1000 -type extreme_values\n\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 500 -type few_unique -unique 10\n./gen -n 1000 -k 500 -type small_range -range 1000\n\n./gen -n 2000 -k 1000 -type constant -value 0\n\n./gen -n 2000 -k 1000 -type ascending\n\n./gen -n 2000 -k 1000 -type descending\n\n./gen -n 2000 -k 500 -type constant -value 999999999\n\n./gen -n 2000 -k 500 -type constant -value -999999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:23.535078",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "361/E",
      "title": "E. Levko and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 2000).The second line contains a non-empty string s of length n. String s consists only of lowercase English letters.",
      "output_spec": "OutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy2 2yzOutputCopy26InputCopy2 3yxOutputCopy2InputCopy4 7abcdOutputCopy21962",
      "description": "E. Levko and Strings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 2000).The second line contains a non-empty string s of length n. String s consists only of lowercase English letters.\n\nOutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy2 2yzOutputCopy26InputCopy2 3yxOutputCopy2InputCopy4 7abcdOutputCopy21962\n\nInputCopy2 2yz\n\nOutputCopy26\n\nInputCopy2 3yx\n\nOutputCopy2\n\nInputCopy4 7abcd\n\nOutputCopy21962",
      "solutions": [
        {
          "title": "codeforces.com | 524: A timeout occurred",
          "content": "codeforces.com | 524: A timeout occurred A timeout occurred Error code 524 Visit cloudflare.com for more information. 2025-08-22 03:21:18 UTC You Browser Working Singapore Cloudflare Working codeforces.com Host Error What happened? The origin web server timed out responding to this request.The likely cause is an overloaded background task, database or application, stressing the resources on the host web server. What can I do? If you're a visitor of this website: Please try again in a few minutes. If you're the owner of this website: Please refer to the Error 524 article: Contact your hosting provider; check for long-running processes or an overloaded web server. Use status polling of large HTTP processes to avoid this error. Run the long-running scripts on a grey-clouded subdomain. Enterprise customers can increase the timeout setting globally or for specific requests using Cache Rules. Cloudflare Ray ID: 972f3ad22988fe1f • Your IP: Click to reveal 137.132.214.135 • Performance &amp; security by Cloudflare",
          "author": "Unknown",
          "url": "https://codeforces.com/blog/entry/9526",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1021
        },
        {
          "title": "Codeforces Round #210 editorial - Codeforces",
          "content": "361A - Levko and TableMatrix,in which all diagonal elements equal k and other elements equal 0, satisfied all conditions.For example, if n = 4 and k = 7, our matrix will be7 0 0 00 7 0 00 0 7 00 0 0 7361B - Levko and Permutationgcd(1, m) = 1, so if n = k, there is no suitable permutation.It is well known that gcd(m, m - 1) = 1. Lets construct following permutation. It has exactly k good elements.n - k  1  2  3  ...   n - k - 1  n - k + 1  n - k + 2  ...   n 360A - Levko and Array RecoveryLet's find such value b[i] that a[i] ≤ b[i] for all indeces i. Let's simulate all operations and diff[i] will be the difference between current value of i-th element and its initial value. If we have operation of first type, we change values of diff[i]. If we have operation of second type, we know that a[i] + diff[i] ≤ m[i], so a[i] ≤ m[i] - diff[i]. We will get array b when we union all this inequalities.Let's prove that either b satisfied all conditions or there is no such array. It can be two cases, why b does not suit: — it's impossible due to construction of array b. — b[i] is a maximal possible value of a[i], so can't be bigger. 360B - Levko and ArrayLet's solve this problem using binary search. We need to check whether we can achieve an array, when c(a) will be at most x. Lets make dp. dp[i] means minimal number of elements with indeces less than i, which we need to change, but we don't change i-th element. Let's iterate next element j, which we don't change. Then we know that we can change all elements between i and j. It is equivalent to such condition |aj - ai| ≤ (j - i)·xDifference between neighboring elements can be at most x. The maximal possible difference increases by x exactly j - i times between elements i and j, so this inequality is correct. 360C - Levko and StringsLet's count amount of such substrings of t that are bigger than corresponding substring of s and begin at the position i. If t[i] < s[i], this amount equals 0. If t[i] > s[i], this amount equals n - i. If t[i] = s[i], then let's find such nearest position j,  j > i , that t[j] ≠ s[j]. If t[j] > s[j], needed amount of substrings will be n - j. If t[j] < s[j], needed amount of substrings will be 0. We can rephrase this: If t[i] > s[i], it will be (1 + pref)·(n - i) new substrings, where pref means how many last elements in s and t is equal.Let's make dp. dp[i][sum] means that we viewed i positions, have sum needed substrings and s[i] ≠ t[i]. Lets iterate their common prefix pref.If t[i] < s[i], dp[i][sum] +  = dp[i - pref - 1][sum]·(s[i] - 'a') — we can count this value using partial sums.If t[i] > s[i], dp[i][sum] +  = dp[i - pref - 1][sum - (1 + pref)·(n - i)]·('z' - s[i]). Let's iterate pref. Let's note that sum - pref·(n - i) ≥ 0, so pref ≤ sum / (n - i) and pref ≤ k / (n - i). This means that third cycle will make at most k / (n - i) iterations when we find value of dp[i][sum]. Let's count total number of iterations:  =   <  k·(n + k·log  k).360D - Levko and Setsp is prime, so there exist primitive root g modulo p(We don't need to find it, but we know that it exists). We can write ai = gri. Note, that i-th set consists of all numbers , where cj ≥ 0, or we can write it as .By Fermat's little theorem ap - 1 = 1 mod p we have that ak mod p = ak mod (p - 1) mod p. So can be equal to all values k·t modulo p - 1, where t = gcd(b1, b2, ... , bm, p - 1). Note that t doesn't depend on ri, so we can assign g = gt. Then all elements of i-th set will be gri·k, where k ≥ 0. Now we can replace bi by qi, where qi = gcd(ri, p - 1), as we do with bi at the beginning. Then all elements of i-th set will be gqi·k, where k ≥ 0. This means that if we write all values g0, g1, ..., gp - 2 in a line, i-th set will contain every qi-th element.Now we need to find union of this sets.Let's do it using inclusion-exclusion principle. All our numbers are divisors of p - 1. Let's dpi be the coefficient near i in inclusion-exclusion principle(i is a divisor of p - 1) and we can find this values, adding all qi alternatively.Also we need to find qi. Let's find volume of the i-th set. It is equal to . From the other side it is equal to such minimal number di, that aidi = 1 mod p (di is a cycle). From aip - 1 = 1 mod p we have that p - 1 is divisible by di. So we can find di as a divisor of p - 1. And .360E - Levko and GameAlgorithm:Firstly we will solve problem if first player can win.Let's make all roads that we can change equal to r[i] and do two Dijkstra's algorithms from vertices s1 and s2. Let's d1[i] be the distance from s1 to i, d2[i] be the distance from s2 to i. Consider a road, that we can change, from a to b. If d1[a] < d2[a], we will set length of such road equal to l[i] and do two Dijkstra's algorithms again. We run such process until any road changes its length. If d1[f] < d2[f] after all changes then first player wins.If we replace condition d1[a] < d2[a] by d1[a] ≤ d2[a], we can check if Levko can end this game with a draw.Proof:Let's call \"edges\" only roads which Levko can change. When we do Dijkstra's algorithm we use all roads, not only edges. Let's prove that if there exist such edges values that first player wins, there exist values of edges such that first player wins and all this values equal either l[i] or r[i]. Consider shortest pathes of both players.If only first player goes on edge from a to b, we can set its value l[i]. Proof: there must hold d1[a] < d2[a] because first player goes on it and wins. This condition holds after change of value of this edge. If second player goes on this edge, he loses because d1[f] ≤ d1[a] + d(a, b) + d(b, f) < d2[a] + d(a, b) + d(b, F) = d2[f]. If second player doesn't go on this edge, he loses because shortest path of first player became smaller(d(x, y) — shortest path from x to y).If only second player goes on edge from a to b, we can set its value r[i]. Proof: Shortest path of the first player doesn't change and shortest path of second player can only become larger.If no player go on edge, we can set its value r[i]. Proof: Shortest pathes of both players doesn't change.If both players go on edge from a to b, we can set its value l[i]. Proof: Shortest pathes of both players decrease by (initial value of this edge — l[i]).After every such operation first player wins again and all edges become either l[i] or r[i]. Consider result of our algorithm. Let's call edge \"good\" if its value is equal to l[i] and \"bad\" if its value equals r[i].(a) Let's prove that after performing all operations we will have d1[a] < d2[a] for all good edges (a, b). If we have d1[a1] < d2[a1] for edge (a1, b1) and after changing value of (a2, b2) this condition doesn't hold. We have d1[a1] >  = d2[a1], d1[a2] < d2[a2]. We change only one edge and shortest path from s2 to f become shorter so edge (a2, b2) lies on this path.d2[a1] = d2[a2] + d(a2, b2) + d(b2, a1) > d1[a2] + d(a2, b2) + d(b2, a1) ≥ d1[a1]. Contradiction. (b) Let's prove that after performing all operations we will have d1[a] ≥ d2[a] for all bad edges. We can continue our procces otherwise.(c) Let's prove that if condition d1[a] < d2[a] holds for some edge but we doesn't change it on this iteration, this continion holds after this iteration. Proof is same as in (a).(d) Let's prove that if any subset of good edges is equal to l[i] and d1[a] < d2[a], ift also holds when we make all good edges equal l[i]. Let's simulate all procces and use (c). Lets prove that for all edges values(not necessary only l[i] or r[i]), d1[a] ≥ d2[a] for all bad edges (a, b).Assume that we have such edge. Consider shortest path of first player to its beginning. If there exist bad edges (a1, b1) on this path, there must holds inequality d1[a1] < d2[a1]. Consider first of this bad edges (a, b). Then shortest path of first player to a doesn't consist any bad edge. Consider problem,m which is equivalent to our problem but finish is in vertex a. good and bad edges will be same. Let's change all value of edges as we do in item 1. Note? that all bad edges will be equal to r[i]. So only subset of good edges can be equal to l[i] and d1[a1] < d2[a1]. By (d) we have that we can set all good edges l[i] and condition d1[a1] < d2[a1] will be satisfied. So we have contradiction thst this edge is bad. This means that if first player goes on any bad edge, he loses. So we can set r[i] to all this edges. So we can set l[i] to some subset of good edges. By (d) we have that if we have d1[f] < d2[f] for some subset of good edges, this condition will be true if we set all good edges l[i]. Note that proof will be same if we want to check whether Levko can end a game with a draw.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9529",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 361 和字母"
          },
          "content_length": 8617
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 2000, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    ensuref((int)s.length() == n, \"Length of s must be %d, but it is %d\", n, int(s.length()));\n\n    for (char c : s) {\n        ensuref(c >= 'a' && c <= 'z', \"s contains invalid character: %c\", c);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 2000, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    ensuref((int)s.length() == n, \"Length of s must be %d, but it is %d\", n, int(s.length()));\n\n    for (char c : s) {\n        ensuref(c >= 'a' && c <= 'z', \"s contains invalid character: %c\", c);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 2000, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    ensuref((int)s.length() == n, \"Length of s must be %d, but it is %d\", n, int(s.length()));\n\n    for (char c : s) {\n        ensuref(c >= 'a' && c <= 'z', \"s contains invalid character: %c\", c);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and k are within the constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(0 <= k && k <= 2000);\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    } else if (type == \"identical\") {\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"increasing\") {\n        s.resize(n);\n        char c = 'a';\n        for (int i = 0; i < n; ++i) {\n            s[i] = c;\n            if (c < 'z') ++c;\n        }\n    } else if (type == \"decreasing\") {\n        s.resize(n);\n        char c = 'z';\n        for (int i = 0; i < n; ++i) {\n            s[i] = c;\n            if (c > 'a') --c;\n        }\n    } else if (type == \"palindrome\") {\n        s.resize(n);\n        for (int i = 0; i < (n + 1) / 2; ++i)\n            s[i] = s[n - 1 - i] = rnd.next('a', 'z');\n    } else if (type == \"alternating\") {\n        char c1 = rnd.next('a', 'z');\n        char c2 = rnd.next('a', 'z');\n        while (c2 == c1) c2 = rnd.next('a', 'z');\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? c1 : c2;\n    } else {\n        // Default to random if type is unrecognized\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and k are within the constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(0 <= k && k <= 2000);\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    } else if (type == \"identical\") {\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"increasing\") {\n        s.resize(n);\n        char c = 'a';\n        for (int i = 0; i < n; ++i) {\n            s[i] = c;\n            if (c < 'z') ++c;\n        }\n    } else if (type == \"decreasing\") {\n        s.resize(n);\n        char c = 'z';\n        for (int i = 0; i < n; ++i) {\n            s[i] = c;\n            if (c > 'a') --c;\n        }\n    } else if (type == \"palindrome\") {\n        s.resize(n);\n        for (int i = 0; i < (n + 1) / 2; ++i)\n            s[i] = s[n - 1 - i] = rnd.next('a', 'z');\n    } else if (type == \"alternating\") {\n        char c1 = rnd.next('a', 'z');\n        char c2 = rnd.next('a', 'z');\n        while (c2 == c1) c2 = rnd.next('a', 'z');\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? c1 : c2;\n    } else {\n        // Default to random if type is unrecognized\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type identical\n./gen -n 1 -k 1 -type identical\n./gen -n 1 -k 1 -type random\n\n./gen -n 2 -k 0 -type increasing\n./gen -n 2 -k 0 -type decreasing\n./gen -n 2 -k 1 -type palindrome\n./gen -n 2 -k 2 -type alternating\n./gen -n 2 -k 2000 -type random\n\n./gen -n 10 -k 0 -type identical\n./gen -n 10 -k 50 -type random\n./gen -n 10 -k 100 -type random\n./gen -n 10 -k 0 -type increasing\n./gen -n 10 -k 0 -type decreasing\n./gen -n 10 -k 2000 -type random\n\n./gen -n 100 -k 0 -type increasing\n./gen -n 100 -k 0 -type decreasing\n./gen -n 100 -k 500 -type palindrome\n./gen -n 100 -k 1000 -type alternating\n./gen -n 100 -k 2000 -type random\n\n./gen -n 500 -k 0 -type palindrome\n./gen -n 500 -k 1000 -type random\n./gen -n 500 -k 2000 -type random\n\n./gen -n 1000 -k 0 -type identical\n./gen -n 1000 -k 1000 -type random\n./gen -n 1000 -k 2000 -type random\n\n./gen -n 2000 -k 0 -type increasing\n./gen -n 2000 -k 0 -type decreasing\n./gen -n 2000 -k 1000 -type palindrome\n./gen -n 2000 -k 1500 -type alternating\n./gen -n 2000 -k 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:25.250257",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "362/A",
      "title": "A. Two Semiknights Meet",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number t (1 ≤ t ≤ 50) — the number of boards. Each board is described by a matrix of characters, consisting of 8 rows and 8 columns. The matrix consists of characters \".\", \"#\", \"K\", representing an empty good square, a bad square and the semiknight's position, correspondingly. It is guaranteed that matrix contains exactly 2 semiknights. The semiknight's squares are considered good for the meeting. The tests are separated by empty line.",
      "output_spec": "OutputFor each test, print on a single line the answer to the problem: \"YES\", if the semiknights can meet and \"NO\" otherwise.",
      "sample_tests": "ExamplesInputCopy2......................#.K..##..#.......#...##..#......#.K.........................#.......#..#....####.....##...............K#K#OutputCopyYESNO",
      "description": "A. Two Semiknights Meet\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number t (1 ≤ t ≤ 50) — the number of boards. Each board is described by a matrix of characters, consisting of 8 rows and 8 columns. The matrix consists of characters \".\", \"#\", \"K\", representing an empty good square, a bad square and the semiknight's position, correspondingly. It is guaranteed that matrix contains exactly 2 semiknights. The semiknight's squares are considered good for the meeting. The tests are separated by empty line.\n\nOutputFor each test, print on a single line the answer to the problem: \"YES\", if the semiknights can meet and \"NO\" otherwise.\n\nInputCopy2......................#.K..##..#.......#...##..#......#.K.........................#.......#..#....####.....##...............K#K#OutputCopyYESNO\n\nInputCopy2......................#.K..##..#.......#...##..#......#.K.........................#.......#..#....####.....##...............K#K#\n\nOutputCopyYESNO\n\nNoteConsider the first board from the sample. We will assume the rows and columns of the matrix to be numbered 1 through 8 from top to bottom and from left to right, correspondingly. The knights can meet, for example, in square (2, 7). The semiknight from square (4, 1) goes to square (2, 3) and the semiknight goes from square (8, 1) to square (6, 3). Then both semiknights go to (4, 5) but this square is bad, so they move together to square (2, 7).On the second board the semiknights will never meet.",
      "solutions": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces",
          "content": "Hello everyone!November 14, 19:30 MSK will take place Codeforces Round #212 (Div. 2), which was prepared by group of authors from Saratov State University: Artem Sedanov (FunkyCat), Sergey Sukhov (Serega), Olga Chikatueva (Helga), Dmitriy Zaycev (My-my).We thank coordinator of Codeforces rounds Gerald Agapov (Gerald) for useful hints and Maria Belova (Delinur) for translation of problem's statements into English.Good luck and high rating to all!UPD1. In this round will be used dynamic scoring system (see here).UPD2. Tutorial is published here.UPD3. Rating is updated. We congratulate the winners who solved four problems: CleRIC i_must_learn_matan Dshavn gzh1998n",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9550",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 669
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces",
          "content": "362A - Two Semiknights MeetAutors have proposed different solutions. One can notice that if semiknights did not have a meeting after first step (it is not necessary they have a meeting in \"good\" square), they will not meet at all. This fact appears from board size and possible semiknight's moves. As the initial semiknight's squares are considered good for the meeting the semiknights have arrived to the one square and then they move together to one of the initial squares and meeting will count. 362B - Petya and StaircasesOne has to note that the number of dirty stairs  ≤ 3000. Petya can reach stair number n if the first and the last stairs are not dirty and there are not three or more dirty stairs in a row. So let sort the array of dirty stairs and go through it, checking for three or more consecutive dirty stairs. Also one need to check if the first or the last stair is in this array.362C - Insertion SortThe number of times swap is called equals the number of inversions in the input permutation. It’s easy to see that it is reasonable to swap only such elements ai, aj that i < j and ai > aj (otherwise the number of inversions will increase). Let di, j be the number of permutation of elements with indices from 0 to i inclusive which are strictly less than j. Then, after swapping elements with indices i and j, the number of inversions will be old - 2 * (di, ai + dj, aj - di, aj - dj, ai) - 1, where old is the number of inversions in the initial permutation. It is sufficient to search all pairs of elements and pick those which help to minimize the number of inversions. The reader may prove the correctness of the formula as a supplementary task.362D - Fools and Foolproof RoadsIf the given graph contains less than q connectivity components, then there’s no solution. Otherwise it’s optimal at first add edges that connect different components and afterwards all remaining edges (they will be connect edges from one component). For the first phase you can use greedy algorithm: each time you select two components, current weight of which is minimal, and connect them with an edge. For example, you can store weights of all components in the current graph in some data structure (like set in С++). For the second phase it’s enough to find any component that contains two or more vertices (because loops are forbidden) and add all remaining edges between some two vertices of this component. If some action cannot be successfully executed (for example, you added all the edges and number of connectivity components if greater than q), then there’s no solution. Asymptotics — O(n + m + plogn).362E - Petya and PipesConstruct the following flow network. Water tank 1 is the source, water tank n is the sink. Every pipe from water tank u to water tank v is presented as two arcs — the first one with capacity cuv and cost 0 and the second one with infinite capacity and cost 1. Thus, the answer is the maximum flow with cost not greater than k. It can be found by standard augmenting paths algorithm.UPD1. Tutorial for problems A and B added. UPD2. Tutorial for problem C added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9584",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 362\\s*A"
          },
          "content_length": 3097
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 1",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 2",
          "code": "`if(!m){` `  puts(\"YES\");` `  return 0;` `}`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 3",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 4",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 5",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 6",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 7",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 8",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 9",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 10",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 11",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 12",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 13",
          "code": "5 1 3 4 0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 14",
          "code": "5 1 3 0 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 1",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 2",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 50, \"t\");\n    inf.readEoln();\n\n    for (int test = 1; test <= t; ++test) {\n        int k_count = 0;\n        for (int line_no = 1; line_no <= 8; ++line_no) {\n            string s = inf.readLine();\n            ensuref((int)s.length() == 8, \"Line %d in test case %d should have length 8\", line_no, test);\n            for (int i = 0; i < 8; ++i) {\n                char c = s[i];\n                ensuref(c == '.' || c == '#' || c == 'K', \"Invalid character '%c' in line %d of test case %d\", c, line_no, test);\n                if (c == 'K') {\n                    ++k_count;\n                }\n            }\n        }\n        ensuref(k_count == 2, \"Test case %d should contain exactly 2 'K's, found %d\", test, k_count);\n        if (test < t) {\n            string s = inf.readLine();\n            ensuref(s.empty(), \"Expected empty line after test case %d\", test);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 50, \"t\");\n    inf.readEoln();\n\n    for (int test = 1; test <= t; ++test) {\n        int k_count = 0;\n        for (int line_no = 1; line_no <= 8; ++line_no) {\n            string s = inf.readLine();\n            ensuref((int)s.length() == 8, \"Line %d in test case %d should have length 8\", line_no, test);\n            for (int i = 0; i < 8; ++i) {\n                char c = s[i];\n                ensuref(c == '.' || c == '#' || c == 'K', \"Invalid character '%c' in line %d of test case %d\", c, line_no, test);\n                if (c == 'K') {\n                    ++k_count;\n                }\n            }\n        }\n        ensuref(k_count == 2, \"Test case %d should contain exactly 2 'K's, found %d\", test, k_count);\n        if (test < t) {\n            string s = inf.readLine();\n            ensuref(s.empty(), \"Expected empty line after test case %d\", test);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 50, \"t\");\n    inf.readEoln();\n\n    for (int test = 1; test <= t; ++test) {\n        int k_count = 0;\n        for (int line_no = 1; line_no <= 8; ++line_no) {\n            string s = inf.readLine();\n            ensuref((int)s.length() == 8, \"Line %d in test case %d should have length 8\", line_no, test);\n            for (int i = 0; i < 8; ++i) {\n                char c = s[i];\n                ensuref(c == '.' || c == '#' || c == 'K', \"Invalid character '%c' in line %d of test case %d\", c, line_no, test);\n                if (c == 'K') {\n                    ++k_count;\n                }\n            }\n        }\n        ensuref(k_count == 2, \"Test case %d should contain exactly 2 'K's, found %d\", test, k_count);\n        if (test < t) {\n            string s = inf.readLine();\n            ensuref(s.empty(), \"Expected empty line after test case %d\", test);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMeet(char grid[8][8], int x1, int y1, int x2, int y2) {\n    // Returns true if the semiknights starting from (x1,y1) and (x2,y2)\n    // can meet on a good square.\n\n    bool visited[8][8][8][8] = {};\n    queue<tuple<int,int,int,int>> q;\n\n    visited[x1][y1][x2][y2] = true;\n    q.push(make_tuple(x1,y1,x2,y2));\n\n    int dx[4] = {-2, -2, 2, 2};\n    int dy[4] = {-2, 2, -2, 2};\n\n    while(!q.empty()) {\n        int a1, b1, a2, b2;\n        tie(a1, b1, a2, b2) = q.front();\n        q.pop();\n\n        // If semiknights are on the same square and it's a good square, they have met\n        if (a1 == a2 && b1 == b2 && grid[a1][b1] != '#') {\n            return true;\n        }\n\n        // Generate next positions\n        vector<pair<int,int>> moves1;\n        vector<pair<int,int>> moves2;\n\n        for(int i = 0; i < 4; ++i) {\n            int na1 = a1 + dx[i];\n            int nb1 = b1 + dy[i];\n            if (na1 >= 0 && na1 <8 && nb1 >= 0 && nb1 <8) {\n                moves1.emplace_back(na1, nb1);\n            }\n        }\n\n        for(int i = 0; i < 4; ++i) {\n            int na2 = a2 + dx[i];\n            int nb2 = b2 + dy[i];\n            if (na2 >= 0 && na2 <8 && nb2 >= 0 && nb2 <8) {\n                moves2.emplace_back(na2, nb2);\n            }\n        }\n\n        // For all combinations of next moves\n        for(auto& m1 : moves1) {\n            for(auto& m2 : moves2) {\n                int na1 = m1.first;\n                int nb1 = m1.second;\n                int na2 = m2.first;\n                int nb2 = m2.second;\n\n                if (!visited[na1][nb1][na2][nb2]) {\n                    visited[na1][nb1][na2][nb2] = true;\n                    q.push(make_tuple(na1, nb1, na2, nb2));\n                }\n            }\n        }\n    }\n\n    return false; // Cannot meet\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string ans = opt<string>(\"ans\", \"random\"); // 'yes', 'no', or 'random'\n    int badPercentage = opt<int>(\"bad\", 20); // Percentage of bad squares (0-100)\n\n    for(int testCase = 0; testCase < t; testCase++) {\n        char grid[8][8];\n        int x1, y1, x2, y2;\n        int attempts = 0;\n        const int MAX_ATTEMPTS = 1000;\n        bool ok = false;\n\n        while(attempts < MAX_ATTEMPTS) {\n            attempts++;\n\n            // Initialize grid with '.'\n            for(int i = 0; i < 8; ++i)\n                for(int j = 0; j < 8; ++j)\n                    grid[i][j] = '.';\n\n            // Place the semiknights at random positions\n            x1 = rnd.next(8);\n            y1 = rnd.next(8);\n            do {\n                x2 = rnd.next(8);\n                y2 = rnd.next(8);\n            } while (x1 == x2 && y1 == y2);\n\n            grid[x1][y1] = 'K';\n            grid[x2][y2] = 'K';\n\n            // Place bad squares\n            int totalSquares = 64 - 2; // Exclude semiknight positions\n            int numBadSquares = totalSquares * badPercentage / 100;\n\n            vector<pair<int,int>> cells;\n            for(int i = 0; i < 8; ++i)\n                for(int j = 0; j < 8; ++j)\n                    if (!(i == x1 && j == y1) && !(i == x2 && j == y2))\n                        cells.emplace_back(i, j);\n\n            shuffle(cells.begin(), cells.end());\n\n            for(int i = 0; i < numBadSquares && i < (int)cells.size(); ++i) {\n                int xi = cells[i].first;\n                int yi = cells[i].second;\n                grid[xi][yi] = '#';\n            }\n\n            bool can_meet = canMeet(grid, x1, y1, x2, y2);\n\n            // Determine if this test case matches the desired answer\n            if (ans == \"yes\" && can_meet) {\n                ok = true;\n                break;\n            } else if (ans == \"no\" && !can_meet) {\n                ok = true;\n                break;\n            } else if (ans == \"random\") {\n                ok = true;\n                break;\n            }\n            // Else, retry\n        }\n\n        if (!ok) {\n            // Failed to generate the desired test case after many attempts\n            // You can adjust the parameters or handle this case differently\n            testCase--;\n            continue;\n        }\n\n        // Output test case\n        // If it's not the first test case, print an empty line to separate tests\n        if (testCase > 0) {\n            printf(\"\\n\");\n        }\n        // Number of test cases will be printed at the beginning\n        if (testCase == 0) {\n            printf(\"%d\\n\", t);\n        }\n\n        for(int i = 0; i < 8; ++i) {\n            for(int j = 0; j <8; ++j) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMeet(char grid[8][8], int x1, int y1, int x2, int y2) {\n    // Returns true if the semiknights starting from (x1,y1) and (x2,y2)\n    // can meet on a good square.\n\n    bool visited[8][8][8][8] = {};\n    queue<tuple<int,int,int,int>> q;\n\n    visited[x1][y1][x2][y2] = true;\n    q.push(make_tuple(x1,y1,x2,y2));\n\n    int dx[4] = {-2, -2, 2, 2};\n    int dy[4] = {-2, 2, -2, 2};\n\n    while(!q.empty()) {\n        int a1, b1, a2, b2;\n        tie(a1, b1, a2, b2) = q.front();\n        q.pop();\n\n        // If semiknights are on the same square and it's a good square, they have met\n        if (a1 == a2 && b1 == b2 && grid[a1][b1] != '#') {\n            return true;\n        }\n\n        // Generate next positions\n        vector<pair<int,int>> moves1;\n        vector<pair<int,int>> moves2;\n\n        for(int i = 0; i < 4; ++i) {\n            int na1 = a1 + dx[i];\n            int nb1 = b1 + dy[i];\n            if (na1 >= 0 && na1 <8 && nb1 >= 0 && nb1 <8) {\n                moves1.emplace_back(na1, nb1);\n            }\n        }\n\n        for(int i = 0; i < 4; ++i) {\n            int na2 = a2 + dx[i];\n            int nb2 = b2 + dy[i];\n            if (na2 >= 0 && na2 <8 && nb2 >= 0 && nb2 <8) {\n                moves2.emplace_back(na2, nb2);\n            }\n        }\n\n        // For all combinations of next moves\n        for(auto& m1 : moves1) {\n            for(auto& m2 : moves2) {\n                int na1 = m1.first;\n                int nb1 = m1.second;\n                int na2 = m2.first;\n                int nb2 = m2.second;\n\n                if (!visited[na1][nb1][na2][nb2]) {\n                    visited[na1][nb1][na2][nb2] = true;\n                    q.push(make_tuple(na1, nb1, na2, nb2));\n                }\n            }\n        }\n    }\n\n    return false; // Cannot meet\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string ans = opt<string>(\"ans\", \"random\"); // 'yes', 'no', or 'random'\n    int badPercentage = opt<int>(\"bad\", 20); // Percentage of bad squares (0-100)\n\n    for(int testCase = 0; testCase < t; testCase++) {\n        char grid[8][8];\n        int x1, y1, x2, y2;\n        int attempts = 0;\n        const int MAX_ATTEMPTS = 1000;\n        bool ok = false;\n\n        while(attempts < MAX_ATTEMPTS) {\n            attempts++;\n\n            // Initialize grid with '.'\n            for(int i = 0; i < 8; ++i)\n                for(int j = 0; j < 8; ++j)\n                    grid[i][j] = '.';\n\n            // Place the semiknights at random positions\n            x1 = rnd.next(8);\n            y1 = rnd.next(8);\n            do {\n                x2 = rnd.next(8);\n                y2 = rnd.next(8);\n            } while (x1 == x2 && y1 == y2);\n\n            grid[x1][y1] = 'K';\n            grid[x2][y2] = 'K';\n\n            // Place bad squares\n            int totalSquares = 64 - 2; // Exclude semiknight positions\n            int numBadSquares = totalSquares * badPercentage / 100;\n\n            vector<pair<int,int>> cells;\n            for(int i = 0; i < 8; ++i)\n                for(int j = 0; j < 8; ++j)\n                    if (!(i == x1 && j == y1) && !(i == x2 && j == y2))\n                        cells.emplace_back(i, j);\n\n            shuffle(cells.begin(), cells.end());\n\n            for(int i = 0; i < numBadSquares && i < (int)cells.size(); ++i) {\n                int xi = cells[i].first;\n                int yi = cells[i].second;\n                grid[xi][yi] = '#';\n            }\n\n            bool can_meet = canMeet(grid, x1, y1, x2, y2);\n\n            // Determine if this test case matches the desired answer\n            if (ans == \"yes\" && can_meet) {\n                ok = true;\n                break;\n            } else if (ans == \"no\" && !can_meet) {\n                ok = true;\n                break;\n            } else if (ans == \"random\") {\n                ok = true;\n                break;\n            }\n            // Else, retry\n        }\n\n        if (!ok) {\n            // Failed to generate the desired test case after many attempts\n            // You can adjust the parameters or handle this case differently\n            testCase--;\n            continue;\n        }\n\n        // Output test case\n        // If it's not the first test case, print an empty line to separate tests\n        if (testCase > 0) {\n            printf(\"\\n\");\n        }\n        // Number of test cases will be printed at the beginning\n        if (testCase == 0) {\n            printf(\"%d\\n\", t);\n        }\n\n        for(int i = 0; i < 8; ++i) {\n            for(int j = 0; j <8; ++j) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 5 -ans yes -bad 0\n./gen -t 5 -ans no -bad 0\n./gen -t 5 -ans yes -bad 20\n./gen -t 5 -ans no -bad 20\n./gen -t 5 -ans yes -bad 50\n./gen -t 5 -ans no -bad 50\n./gen -t 5 -ans yes -bad 80\n./gen -t 5 -ans no -bad 80\n\n./gen -t 10 -ans random -bad 0\n./gen -t 10 -ans random -bad 10\n./gen -t 10 -ans random -bad 20\n./gen -t 10 -ans random -bad 30\n\n./gen -t 1 -ans yes -bad 0\n./gen -t 1 -ans no -bad 0\n./gen -t 1 -ans yes -bad 100\n./gen -t 1 -ans no -bad 100\n\n./gen -t 15 -ans yes -bad 25\n./gen -t 15 -ans no -bad 25\n\n./gen -t 20 -ans yes -bad 0\n./gen -t 20 -ans no -bad 0\n\n./gen -t 50 -ans random -bad 15\n\n./gen -t 5 -ans yes -bad 5\n./gen -t 5 -ans no -bad 95\n\n./gen -t 3 -ans yes -bad 70\n./gen -t 3 -ans no -bad 70\n\n./gen -t 2 -ans random -bad 50\n./gen -t 2 -ans yes -bad 50\n./gen -t 2 -ans no -bad 50\n\n./gen -t 10 -ans random -bad 100\n\n./gen -t 5 -ans yes -bad 10\n./gen -t 5 -ans no -bad 90\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:27.167637",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "362/B",
      "title": "B. Petya and Staircases",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 109, 0 ≤ m ≤ 3000) — the number of stairs in the staircase and the number of dirty stairs, correspondingly. The second line contains m different space-separated integers d1, d2, ..., dm (1 ≤ di ≤ n) — the numbers of the dirty stairs (in an arbitrary order).",
      "output_spec": "OutputPrint \"YES\" if Petya can reach stair number n, stepping only on the clean stairs. Otherwise print \"NO\".",
      "sample_tests": "ExamplesInputCopy10 52 4 8 3 6OutputCopyNOInputCopy10 52 4 5 7 9OutputCopyYES",
      "description": "B. Petya and Staircases\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 109, 0 ≤ m ≤ 3000) — the number of stairs in the staircase and the number of dirty stairs, correspondingly. The second line contains m different space-separated integers d1, d2, ..., dm (1 ≤ di ≤ n) — the numbers of the dirty stairs (in an arbitrary order).\n\nOutputPrint \"YES\" if Petya can reach stair number n, stepping only on the clean stairs. Otherwise print \"NO\".\n\nInputCopy10 52 4 8 3 6OutputCopyNOInputCopy10 52 4 5 7 9OutputCopyYES\n\nInputCopy10 52 4 8 3 6\n\nOutputCopyNO\n\nInputCopy10 52 4 5 7 9\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces",
          "content": "Hello everyone!November 14, 19:30 MSK will take place Codeforces Round #212 (Div. 2), which was prepared by group of authors from Saratov State University: Artem Sedanov (FunkyCat), Sergey Sukhov (Serega), Olga Chikatueva (Helga), Dmitriy Zaycev (My-my).We thank coordinator of Codeforces rounds Gerald Agapov (Gerald) for useful hints and Maria Belova (Delinur) for translation of problem's statements into English.Good luck and high rating to all!UPD1. In this round will be used dynamic scoring system (see here).UPD2. Tutorial is published here.UPD3. Rating is updated. We congratulate the winners who solved four problems: CleRIC i_must_learn_matan Dshavn gzh1998n",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9550",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 669
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces",
          "content": "362A - Two Semiknights MeetAutors have proposed different solutions. One can notice that if semiknights did not have a meeting after first step (it is not necessary they have a meeting in \"good\" square), they will not meet at all. This fact appears from board size and possible semiknight's moves. As the initial semiknight's squares are considered good for the meeting the semiknights have arrived to the one square and then they move together to one of the initial squares and meeting will count. 362B - Petya and StaircasesOne has to note that the number of dirty stairs  ≤ 3000. Petya can reach stair number n if the first and the last stairs are not dirty and there are not three or more dirty stairs in a row. So let sort the array of dirty stairs and go through it, checking for three or more consecutive dirty stairs. Also one need to check if the first or the last stair is in this array.362C - Insertion SortThe number of times swap is called equals the number of inversions in the input permutation. It’s easy to see that it is reasonable to swap only such elements ai, aj that i < j and ai > aj (otherwise the number of inversions will increase). Let di, j be the number of permutation of elements with indices from 0 to i inclusive which are strictly less than j. Then, after swapping elements with indices i and j, the number of inversions will be old - 2 * (di, ai + dj, aj - di, aj - dj, ai) - 1, where old is the number of inversions in the initial permutation. It is sufficient to search all pairs of elements and pick those which help to minimize the number of inversions. The reader may prove the correctness of the formula as a supplementary task.362D - Fools and Foolproof RoadsIf the given graph contains less than q connectivity components, then there’s no solution. Otherwise it’s optimal at first add edges that connect different components and afterwards all remaining edges (they will be connect edges from one component). For the first phase you can use greedy algorithm: each time you select two components, current weight of which is minimal, and connect them with an edge. For example, you can store weights of all components in the current graph in some data structure (like set in С++). For the second phase it’s enough to find any component that contains two or more vertices (because loops are forbidden) and add all remaining edges between some two vertices of this component. If some action cannot be successfully executed (for example, you added all the edges and number of connectivity components if greater than q), then there’s no solution. Asymptotics — O(n + m + plogn).362E - Petya and PipesConstruct the following flow network. Water tank 1 is the source, water tank n is the sink. Every pipe from water tank u to water tank v is presented as two arcs — the first one with capacity cuv and cost 0 and the second one with infinite capacity and cost 1. Thus, the answer is the maximum flow with cost not greater than k. It can be found by standard augmenting paths algorithm.UPD1. Tutorial for problems A and B added. UPD2. Tutorial for problem C added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9584",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 362\\s*B"
          },
          "content_length": 3097
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 1",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 2",
          "code": "`if(!m){` `  puts(\"YES\");` `  return 0;` `}`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 3",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 4",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 5",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 6",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 7",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 8",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 9",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 10",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 11",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 12",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 13",
          "code": "5 1 3 4 0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 14",
          "code": "5 1 3 0 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 1",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 2",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(m, 1, n, \"d_i\");\n    inf.readEoln();\n\n    set<int> s(d.begin(), d.end());\n    ensuref((int)s.size() == m, \"Dirty stairs must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(m, 1, n, \"d_i\");\n    inf.readEoln();\n\n    set<int> s(d.begin(), d.end());\n    ensuref((int)s.size() == m, \"Dirty stairs must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(m, 1, n, \"d_i\");\n    inf.readEoln();\n\n    set<int> s(d.begin(), d.end());\n    ensuref((int)s.size() == m, \"Dirty stairs must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    long long n = opt<long long>(\"n\", 10); // default to 10\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> dirty;\n\n    if (type == \"random\") {\n        // Random dirty stairs, excluding stairs 1 and n\n        set<long long> dirty_set;\n\n        if (n >= 3) {\n            int max_m = min((long long)m, n - 2);\n            while ((int)dirty_set.size() < max_m) {\n                long long d = rnd.next(2LL, n - 1LL);\n                dirty_set.insert(d);\n            }\n            dirty.assign(dirty_set.begin(), dirty_set.end());\n            m = max_m;\n        } else {\n            m = 0;\n        }\n    } else if (type == \"consecutive\") {\n        // Generate cases with 3 consecutive dirty stairs\n        if (n >= 5) {\n            long long start = rnd.next(2LL, n - 3LL);\n            dirty.push_back(start);\n            dirty.push_back(start + 1);\n            dirty.push_back(start + 2);\n        } else if (n >= 3) {\n            dirty.push_back(2LL);\n            dirty.push_back(3LL);\n        }\n        m = dirty.size();\n    } else if (type == \"edge_dirty\") {\n        // Dirty the first or last stair\n        int choice = rnd.next(1, 2);\n        if (choice == 1) {\n            dirty.push_back(1LL);\n        } else {\n            dirty.push_back(n);\n        }\n        m = 1;\n    } else if (type == \"first_last_dirty\") {\n        // Dirty both the first and last stairs\n        dirty.push_back(1LL);\n        dirty.push_back(n);\n        m = 2;\n    } else if (type == \"no_dirty\") {\n        // No dirty stairs\n        m = 0;\n    } else if (type == \"all_dirty\") {\n        // Dirty all stairs except the first and last\n        if (n >= 3) {\n            for (long long i = 2LL; i <= n - 1LL; ++i) {\n                dirty.push_back(i);\n            }\n            m = n - 2;\n        } else {\n            m = 0;\n        }\n    } else if (type == \"dirty_just_before_end\") {\n        // Dirty stairs at positions n-3, n-2, n-1\n        if (n >= 5) {\n            dirty.push_back(n - 3LL);\n            dirty.push_back(n - 2LL);\n            dirty.push_back(n - 1LL);\n        }\n        m = dirty.size();\n    } else if (type == \"dirty_just_after_start\") {\n        // Dirty stairs at positions 2, 3, 4\n        if (n >= 5) {\n            dirty.push_back(2LL);\n            dirty.push_back(3LL);\n            dirty.push_back(4LL);\n        } else {\n            for (long long i = 2LL; i <= n - 1LL; ++i) {\n                dirty.push_back(i);\n            }\n        }\n        m = dirty.size();\n    } else if (type == \"max_m_random\") {\n        // Maximum number of dirty stairs up to 3000\n        m = min((long long)3000, n >= 3 ? n - 2 : 0);\n        set<long long> dirty_set;\n        while ((int)dirty_set.size() < m) {\n            long long d = rnd.next(2LL, n - 1LL);\n            dirty_set.insert(d);\n        }\n        dirty.assign(dirty_set.begin(), dirty_set.end());\n    } else if (type == \"max_n\") {\n        // Set n to maximum value 1e9\n        n = 1000000000LL;\n        m = min(m, 3000);\n        set<long long> dirty_set;\n        while ((int)dirty_set.size() < m) {\n            long long d = rnd.next(2LL, n - 1LL);\n            dirty_set.insert(d);\n        }\n        dirty.assign(dirty_set.begin(), dirty_set.end());\n    } else {\n        // Default to no dirty stairs\n        m = 0;\n    }\n\n    // Shuffle dirty stairs before output\n    shuffle(dirty.begin(), dirty.end());\n\n    // Output n and m\n    printf(\"%lld %d\\n\", n, m);\n\n    // Output dirty stairs\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld\", dirty[i]);\n        if (i + 1 < m)\n            printf(\" \");\n    }\n    if (m > 0)\n        printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    long long n = opt<long long>(\"n\", 10); // default to 10\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> dirty;\n\n    if (type == \"random\") {\n        // Random dirty stairs, excluding stairs 1 and n\n        set<long long> dirty_set;\n\n        if (n >= 3) {\n            int max_m = min((long long)m, n - 2);\n            while ((int)dirty_set.size() < max_m) {\n                long long d = rnd.next(2LL, n - 1LL);\n                dirty_set.insert(d);\n            }\n            dirty.assign(dirty_set.begin(), dirty_set.end());\n            m = max_m;\n        } else {\n            m = 0;\n        }\n    } else if (type == \"consecutive\") {\n        // Generate cases with 3 consecutive dirty stairs\n        if (n >= 5) {\n            long long start = rnd.next(2LL, n - 3LL);\n            dirty.push_back(start);\n            dirty.push_back(start + 1);\n            dirty.push_back(start + 2);\n        } else if (n >= 3) {\n            dirty.push_back(2LL);\n            dirty.push_back(3LL);\n        }\n        m = dirty.size();\n    } else if (type == \"edge_dirty\") {\n        // Dirty the first or last stair\n        int choice = rnd.next(1, 2);\n        if (choice == 1) {\n            dirty.push_back(1LL);\n        } else {\n            dirty.push_back(n);\n        }\n        m = 1;\n    } else if (type == \"first_last_dirty\") {\n        // Dirty both the first and last stairs\n        dirty.push_back(1LL);\n        dirty.push_back(n);\n        m = 2;\n    } else if (type == \"no_dirty\") {\n        // No dirty stairs\n        m = 0;\n    } else if (type == \"all_dirty\") {\n        // Dirty all stairs except the first and last\n        if (n >= 3) {\n            for (long long i = 2LL; i <= n - 1LL; ++i) {\n                dirty.push_back(i);\n            }\n            m = n - 2;\n        } else {\n            m = 0;\n        }\n    } else if (type == \"dirty_just_before_end\") {\n        // Dirty stairs at positions n-3, n-2, n-1\n        if (n >= 5) {\n            dirty.push_back(n - 3LL);\n            dirty.push_back(n - 2LL);\n            dirty.push_back(n - 1LL);\n        }\n        m = dirty.size();\n    } else if (type == \"dirty_just_after_start\") {\n        // Dirty stairs at positions 2, 3, 4\n        if (n >= 5) {\n            dirty.push_back(2LL);\n            dirty.push_back(3LL);\n            dirty.push_back(4LL);\n        } else {\n            for (long long i = 2LL; i <= n - 1LL; ++i) {\n                dirty.push_back(i);\n            }\n        }\n        m = dirty.size();\n    } else if (type == \"max_m_random\") {\n        // Maximum number of dirty stairs up to 3000\n        m = min((long long)3000, n >= 3 ? n - 2 : 0);\n        set<long long> dirty_set;\n        while ((int)dirty_set.size() < m) {\n            long long d = rnd.next(2LL, n - 1LL);\n            dirty_set.insert(d);\n        }\n        dirty.assign(dirty_set.begin(), dirty_set.end());\n    } else if (type == \"max_n\") {\n        // Set n to maximum value 1e9\n        n = 1000000000LL;\n        m = min(m, 3000);\n        set<long long> dirty_set;\n        while ((int)dirty_set.size() < m) {\n            long long d = rnd.next(2LL, n - 1LL);\n            dirty_set.insert(d);\n        }\n        dirty.assign(dirty_set.begin(), dirty_set.end());\n    } else {\n        // Default to no dirty stairs\n        m = 0;\n    }\n\n    // Shuffle dirty stairs before output\n    shuffle(dirty.begin(), dirty.end());\n\n    // Output n and m\n    printf(\"%lld %d\\n\", n, m);\n\n    // Output dirty stairs\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld\", dirty[i]);\n        if (i + 1 < m)\n            printf(\" \");\n    }\n    if (m > 0)\n        printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -n 1 -type no_dirty\n./gen -n 1 -type edge_dirty\n\n./gen -n 2 -type no_dirty\n./gen -n 2 -type edge_dirty\n\n./gen -n 3 -type no_dirty\n./gen -n 3 -type consecutive\n./gen -n 3 -type all_dirty\n\n./gen -n 5 -type dirty_just_after_start\n./gen -n 5 -type dirty_just_before_end\n./gen -n 5 -type all_dirty\n\n# Medium n values\n./gen -n 10 -m 3 -type random\n./gen -n 10 -type no_dirty\n./gen -n 10 -type edge_dirty\n./gen -n 10 -type consecutive\n\n# Random m and n\n./gen -n 100 -m 10 -type random\n./gen -n 1000 -m 100 -type random\n./gen -n 10000 -m 1000 -type random\n\n# Large m and n\n./gen -n 1000000 -m 3000 -type max_m_random\n./gen -n 1000000 -m 3000 -type random\n\n# Maximum n\n./gen -n 1000000000 -m 3000 -type max_n\n\n# Edge dirty\n./gen -n 1000000 -type edge_dirty\n./gen -n 1000000 -type first_last_dirty\n\n# All dirty\n./gen -n 1000 -type all_dirty\n\n# Consecutive dirty stairs\n./gen -n 1000 -type consecutive\n./gen -n 1000 -type dirty_just_after_start\n./gen -n 1000 -type dirty_just_before_end\n\n# No dirty stairs\n./gen -n 1000000 -type no_dirty\n\n# Random with default m\n./gen -n 1000000 -type random\n\n# Edge cases\n./gen -n 2 -type first_last_dirty\n./gen -n 3 -type first_last_dirty\n\n# All dirty except first and last\n./gen -n 10000 -type all_dirty\n\n# Random with high m\n./gen -n 10000 -m 3000 -type random\n./gen -n 10000 -m 3000 -type max_m_random\n\n# Dirty at specific positions\n./gen -n 1000000 -type dirty_just_after_start\n./gen -n 1000000 -type dirty_just_before_end\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:29.479166",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "362/C",
      "title": "C. Сортировка вставками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 5000) — количество чисел в перестановке. Во второй строке содержатся n различных целых чисел от 0 до n - 1 включительно — сама перестановка.",
      "output_spec": "Выходные данныеВыведите два целых числа: минимальное количество вызовов функции swap и количество таких пар (i, j), что обмен элементов входной перестановки с индексами i и j позволяет достичь этого минимального количества вызовов.",
      "sample_tests": "ПримерыВходные данныеСкопировать54 0 3 1 2Выходные данныеСкопировать3 2Входные данныеСкопировать51 2 3 4 0Выходные данныеСкопировать3 4",
      "description": "C. Сортировка вставками\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 5000) — количество чисел в перестановке. Во второй строке содержатся n различных целых чисел от 0 до n - 1 включительно — сама перестановка.\n\nВходные данные\n\nВыходные данныеВыведите два целых числа: минимальное количество вызовов функции swap и количество таких пар (i, j), что обмен элементов входной перестановки с индексами i и j позволяет достичь этого минимального количества вызовов.\n\nВыходные данные\n\nВходные данныеСкопировать54 0 3 1 2Выходные данныеСкопировать3 2Входные данныеСкопировать51 2 3 4 0Выходные данныеСкопировать3 4\n\nВходные данныеСкопировать54 0 3 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 2 3 4 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере подходят пары (0, 3) и (0, 4).Во втором примере подходят пары (0, 4), (1, 4), (2, 4) и (3, 4).",
      "solutions": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces",
          "content": "Всем привет!14 ноября, 19:30 MSK состоится Codeforces Round #212 (Div. 2), который был подготовлен коллективом авторов из Саратовского государственного университета в составе: Артем Седанов (FunkyCat), Сергей Сухов (Serega), Ольга Чикатуева (Helga), Дмитрий Зайцев (My-my).Выражаем благодарность координатору раундов Геральду Агапову (Gerald) за полезные советы и Марии Беловой (Delinur) за перевод условий на английский язык.Всем удачи и высокого рейтинга!UPD1. В раунде будет использована динамическая система оценки сложности задач (см. здесь).UPD2. Разбор задач опубликован здесь.UPD3. Рейтинг обновлен. Поздравляем победителей, решивших по 4 задачи: CleRIC i_must_learn_matan Dshavn gzh1998n",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9550",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 696
        },
        {
          "title": "Разбор Codeforces Round #212 (Div. 2). Часть 1. - Codeforces",
          "content": "362A - Встреча полуконейАвторами были предложены различные варианты решения. Порисовав примеры, можно заметить, что если полукони не встретятся за один ход (причем не важно, если они встретятся на \"плохой\" клетке), то они не встретятся никогда. Это следует из ограничений на размеры поля и самих вариантов движения полуконя. Поскольку клетки, где изначально стояли полукони, считаются хорошими, то мы можем считать, что попав в одну клетку (пусть даже и плохую) за первый ход, полукони могут вместе перейти в одну из начальных позиций, и там уже встреча состоится. Таким образом, достаточно проверить, смогут ли полукони встретиться за один ход. 362B - Петя и лестницыОбратим внимание на то, что число грязных ступенек  ≤ 3000. Для того, чтобы решение существовало, необходимо проверить, что ступенька с номером 1 и ступенька с номером n чистые, а также что в отсортированном массиве не встречается больше двух подряд идущих ступенек. Отсортируем массив, и проходом по нему узнаем нет ли трех подряд идущих номеров грязных ступенек, а также проверим, не являются ли ступеньки 1 и n грязными.362C - Сортировка вставкамиКоличество выполнений функции swap — это количество инверсий во входной перестановке. Несложно заметить, что менять местами имеет смысл только такие элементы ai, aj, что i < j и ai > aj (иначе количество инверсий только увеличится). Пусть di, j — количество таких элементов перестановки с индексами от 0 до i включительно, которые строго меньше j. Тогда при обмене элементов c индексами i и j количество инверсий станет равным old - 2 * (di, ai + dj, aj - di, aj - dj, ai) - 1, где old — количество инверсий в исходной перестановке. Достаточно перебрать все пары элементов и выбрать из них те, которые позволяют минимизировать количество инверсий. Доказательство этой формулы оставим читателю в качеству упражнения.362D - Дураки и дорогиЕсли исходный граф состоит менее чем из q компонент связности, то решения не существует. В противном случае, очевидно, выгодно сначала добавлять ребра, которые будут соединять разные компоненты, а затем ребра в пределах одной компоненты. Первый этап можно выполнять жадно: каждый раз брать две компоненты, текущий вес которых минимален, и соединять их ребром, объединяя в одну компоненту. Для этого, например, все компоненты связности текущего графа можно хранить в структуре set. Для выполнения второго этапа достаточно найти любую компоненту, состоящую более чем из одной вершины (т.к. петли запрещены), и добавить все оставшиеся ребра между любыми двумя её вершинами. Если какое-то действие выполнить невозможно (например, были добавлены все ребра, а количество компонент связности все равно больше требуемого), то решения также не существует.Асимптотика — O(n + m + plogn).362E - Петя и трубопроводПредставим данную задачу как задачу нахождения максимального потока минимальной стоимости. Построим следующую сеть. Истоком будет 1-ый резервуар, стоком — n-ый резервуар. Каждая труба из резервуара u в резервуар v в сети будет представлена двумя дугами из вершины u в вершину v — первое ребро будет иметь пропускную способность cuv и стоимость 0, второе — бесконечную пропускную способность и стоимость 1. Таким образом, ответом на задачу будет величина максимального потока в этой сети стоимости не более чем k. Ее можно найти стандартным алгоритмом увеличивающих путей.UPD1. Добавлен разбор задач A и B. UPD2. Добавлен разбор задачи C.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9584",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 362\\s*C"
          },
          "content_length": 3394
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 1",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 2",
          "code": "`if(!m){` `  puts(\"YES\");` `  return 0;` `}`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 3",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 4",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 5",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 6",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 7",
          "code": "if (a[j] < a[i]) d--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 8",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 9",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 10",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 11",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 12",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 13",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 14",
          "code": "5 1 3 4 0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 15",
          "code": "5 1 3 0 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #212 (Div. 2). Часть 1. - Codeforces - Code 1",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #212 (Div. 2). Часть 1. - Codeforces - Code 2",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n\n    // Check that all elements are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements in permutation are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n\n    // Check that all elements are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements in permutation are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n\n    // Check that all elements are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements in permutation are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i) perm[i] = i;\n\n    if (type == \"random\") {\n        // Generate a random permutation\n        shuffle(perm.begin(), perm.end());\n    } else if (type == \"sorted\") {\n        // Already sorted in increasing order\n        // Do nothing\n    } else if (type == \"reverse_sorted\") {\n        // Sorted in decreasing order\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"almost_sorted\") {\n        // Swap a few elements in an otherwise sorted permutation\n        int swaps = rnd.next(1, min(n / 5, 10)); // Swap up to 10 elements\n        for (int i = 0; i < swaps; ++i) {\n            int pos1 = rnd.next(0, n - 2);\n            swap(perm[pos1], perm[pos1 + 1]);\n        }\n    } else if (type == \"single_inversion\") {\n        // Create a permutation with exactly one inversion\n        int pos = rnd.next(0, n - 2);\n        swap(perm[pos], perm[pos + 1]);\n    } else if (type == \"max_inversions\") {\n        // Reverse sorted permutation to maximize inversions\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"special_case\") {\n        // Create a special permutation with certain properties\n        int mid = n / 2;\n        for(int i = 0; i < mid; ++i) perm[i] = i;\n        for(int i = mid; i < n; ++i) perm[i] = n - (i - mid) - 1;\n    } else {\n        // Default to random permutation\n        shuffle(perm.begin(), perm.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the permutation\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i) perm[i] = i;\n\n    if (type == \"random\") {\n        // Generate a random permutation\n        shuffle(perm.begin(), perm.end());\n    } else if (type == \"sorted\") {\n        // Already sorted in increasing order\n        // Do nothing\n    } else if (type == \"reverse_sorted\") {\n        // Sorted in decreasing order\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"almost_sorted\") {\n        // Swap a few elements in an otherwise sorted permutation\n        int swaps = rnd.next(1, min(n / 5, 10)); // Swap up to 10 elements\n        for (int i = 0; i < swaps; ++i) {\n            int pos1 = rnd.next(0, n - 2);\n            swap(perm[pos1], perm[pos1 + 1]);\n        }\n    } else if (type == \"single_inversion\") {\n        // Create a permutation with exactly one inversion\n        int pos = rnd.next(0, n - 2);\n        swap(perm[pos], perm[pos + 1]);\n    } else if (type == \"max_inversions\") {\n        // Reverse sorted permutation to maximize inversions\n        reverse(perm.begin(), perm.end());\n    } else if (type == \"special_case\") {\n        // Create a special permutation with certain properties\n        int mid = n / 2;\n        for(int i = 0; i < mid; ++i) perm[i] = i;\n        for(int i = mid; i < n; ++i) perm[i] = n - (i - mid) - 1;\n    } else {\n        // Default to random permutation\n        shuffle(perm.begin(), perm.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the permutation\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type sorted\n./gen -n 2 -type reverse_sorted\n./gen -n 2 -type random\n./gen -n 2 -type single_inversion\n./gen -n 2 -type special_case\n\n./gen -n 5 -type sorted\n./gen -n 5 -type reverse_sorted\n./gen -n 5 -type random\n./gen -n 5 -type almost_sorted\n./gen -n 5 -type single_inversion\n./gen -n 5 -type special_case\n\n./gen -n 10 -type random\n./gen -n 10 -type almost_sorted\n./gen -n 10 -type special_case\n\n./gen -n 100 -type sorted\n./gen -n 100 -type reverse_sorted\n./gen -n 100 -type random\n./gen -n 100 -type almost_sorted\n./gen -n 100 -type single_inversion\n./gen -n 100 -type special_case\n\n./gen -n 500 -type random\n./gen -n 500 -type almost_sorted\n./gen -n 500 -type special_case\n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reverse_sorted\n./gen -n 1000 -type random\n./gen -n 1000 -type almost_sorted\n./gen -n 1000 -type single_inversion\n./gen -n 1000 -type special_case\n\n./gen -n 2000 -type random\n./gen -n 2000 -type almost_sorted\n./gen -n 2000 -type special_case\n\n./gen -n 5000 -type sorted\n./gen -n 5000 -type reverse_sorted\n./gen -n 5000 -type random\n./gen -n 5000 -type almost_sorted\n./gen -n 5000 -type single_inversion\n./gen -n 5000 -type special_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:31.490228",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "362/D",
      "title": "D. Fools and Foolproof Roads",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers n (1 ≤ n ≤ 105), m (0 ≤ m ≤ 105), p (0 ≤ p ≤ 105), q (1 ≤ q ≤ n) — the number of cities in the Foolland, the number of existing roads, the number of roads that are planned to construct and the required number of regions.Next m lines describe the roads that exist by the moment upgrading of the roads begun. Each of these lines contains three integers xi, yi, li: xi, yi — the numbers of the cities connected by this road (1 ≤ xi, yi ≤ n, xi ≠ yi), li — length of the road (1 ≤ li ≤ 109). Note that one pair of cities can be connected with multiple roads.",
      "output_spec": "OutputIf constructing the roads in the required way is impossible, print a single string \"NO\" (without the quotes). Otherwise, in the first line print word \"YES\" (without the quotes), and in the next p lines print the road construction plan. Each line of the plan must consist of two distinct integers, giving the numbers of the cities connected by a road. The road must occur in the plan in the order they need to be constructed. If there are multiple optimal solutions, you can print any of them.",
      "sample_tests": "ExamplesInputCopy9 6 2 21 2 23 2 14 6 201 3 87 8 35 7 2OutputCopyYES9 51 9InputCopy2 0 1 2OutputCopyNOInputCopy2 0 0 2OutputCopyYES",
      "description": "D. Fools and Foolproof Roads\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four integers n (1 ≤ n ≤ 105), m (0 ≤ m ≤ 105), p (0 ≤ p ≤ 105), q (1 ≤ q ≤ n) — the number of cities in the Foolland, the number of existing roads, the number of roads that are planned to construct and the required number of regions.Next m lines describe the roads that exist by the moment upgrading of the roads begun. Each of these lines contains three integers xi, yi, li: xi, yi — the numbers of the cities connected by this road (1 ≤ xi, yi ≤ n, xi ≠ yi), li — length of the road (1 ≤ li ≤ 109). Note that one pair of cities can be connected with multiple roads.\n\nOutputIf constructing the roads in the required way is impossible, print a single string \"NO\" (without the quotes). Otherwise, in the first line print word \"YES\" (without the quotes), and in the next p lines print the road construction plan. Each line of the plan must consist of two distinct integers, giving the numbers of the cities connected by a road. The road must occur in the plan in the order they need to be constructed. If there are multiple optimal solutions, you can print any of them.\n\nInputCopy9 6 2 21 2 23 2 14 6 201 3 87 8 35 7 2OutputCopyYES9 51 9InputCopy2 0 1 2OutputCopyNOInputCopy2 0 0 2OutputCopyYES\n\nInputCopy9 6 2 21 2 23 2 14 6 201 3 87 8 35 7 2\n\nOutputCopyYES9 51 9\n\nInputCopy2 0 1 2\n\nOutputCopyNO\n\nInputCopy2 0 0 2\n\nOutputCopyYES\n\nNoteConsider the first sample. Before the reform the Foolland consists of four regions. The first region includes cities 1, 2, 3, the second region has cities 4 and 6, the third region has cities 5, 7, 8, the fourth region has city 9. The total length of the roads in these cities is 11, 20, 5 and 0, correspondingly. According to the plan, we first build the road of length 6 between cities 5 and 9, then the road of length 23 between cities 1 and 9. Thus, the total length of the built roads equals 29.",
      "solutions": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces",
          "content": "Hello everyone!November 14, 19:30 MSK will take place Codeforces Round #212 (Div. 2), which was prepared by group of authors from Saratov State University: Artem Sedanov (FunkyCat), Sergey Sukhov (Serega), Olga Chikatueva (Helga), Dmitriy Zaycev (My-my).We thank coordinator of Codeforces rounds Gerald Agapov (Gerald) for useful hints and Maria Belova (Delinur) for translation of problem's statements into English.Good luck and high rating to all!UPD1. In this round will be used dynamic scoring system (see here).UPD2. Tutorial is published here.UPD3. Rating is updated. We congratulate the winners who solved four problems: CleRIC i_must_learn_matan Dshavn gzh1998n",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9550",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 669
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces",
          "content": "362A - Two Semiknights MeetAutors have proposed different solutions. One can notice that if semiknights did not have a meeting after first step (it is not necessary they have a meeting in \"good\" square), they will not meet at all. This fact appears from board size and possible semiknight's moves. As the initial semiknight's squares are considered good for the meeting the semiknights have arrived to the one square and then they move together to one of the initial squares and meeting will count. 362B - Petya and StaircasesOne has to note that the number of dirty stairs  ≤ 3000. Petya can reach stair number n if the first and the last stairs are not dirty and there are not three or more dirty stairs in a row. So let sort the array of dirty stairs and go through it, checking for three or more consecutive dirty stairs. Also one need to check if the first or the last stair is in this array.362C - Insertion SortThe number of times swap is called equals the number of inversions in the input permutation. It’s easy to see that it is reasonable to swap only such elements ai, aj that i < j and ai > aj (otherwise the number of inversions will increase). Let di, j be the number of permutation of elements with indices from 0 to i inclusive which are strictly less than j. Then, after swapping elements with indices i and j, the number of inversions will be old - 2 * (di, ai + dj, aj - di, aj - dj, ai) - 1, where old is the number of inversions in the initial permutation. It is sufficient to search all pairs of elements and pick those which help to minimize the number of inversions. The reader may prove the correctness of the formula as a supplementary task.362D - Fools and Foolproof RoadsIf the given graph contains less than q connectivity components, then there’s no solution. Otherwise it’s optimal at first add edges that connect different components and afterwards all remaining edges (they will be connect edges from one component). For the first phase you can use greedy algorithm: each time you select two components, current weight of which is minimal, and connect them with an edge. For example, you can store weights of all components in the current graph in some data structure (like set in С++). For the second phase it’s enough to find any component that contains two or more vertices (because loops are forbidden) and add all remaining edges between some two vertices of this component. If some action cannot be successfully executed (for example, you added all the edges and number of connectivity components if greater than q), then there’s no solution. Asymptotics — O(n + m + plogn).362E - Petya and PipesConstruct the following flow network. Water tank 1 is the source, water tank n is the sink. Every pipe from water tank u to water tank v is presented as two arcs — the first one with capacity cuv and cost 0 and the second one with infinite capacity and cost 1. Thus, the answer is the maximum flow with cost not greater than k. It can be found by standard augmenting paths algorithm.UPD1. Tutorial for problems A and B added. UPD2. Tutorial for problem C added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9584",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 362\\s*D"
          },
          "content_length": 3097
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 1",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 2",
          "code": "`if(!m){` `  puts(\"YES\");` `  return 0;` `}`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 3",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 4",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 5",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 6",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 7",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 8",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 9",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 10",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 11",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 12",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 13",
          "code": "5 1 3 4 0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 14",
          "code": "5 1 3 0 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 1",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 2",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(0, 100000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, n, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        ensuref(xi != yi, \"xi != yi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(0, 100000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, n, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        ensuref(xi != yi, \"xi != yi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(0, 100000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, n, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        ensuref(xi != yi, \"xi != yi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DSU {\n    int n;\n    vector<int> p, sz;\n    // sumOfRoads[i] will store the total length of roads in the connected component\n    // whose DSU representative is i\n    vector<long long> sumOfRoads;\n    \n    DSU(int n) : n(n), p(n), sz(n, 1), sumOfRoads(n, 0LL) {\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n        }\n    }\n    \n    int findSet(int v) {\n        if (p[v] == v) return v;\n        return p[v] = findSet(p[v]);\n    }\n    \n    long long getSum(int v) {\n        return sumOfRoads[findSet(v)];\n    }\n    \n    // merges sets of a and b, adding cost c to the merged set's sumOfRoads\n    void unionSet(int a, int b, long long c) {\n        a = findSet(a);\n        b = findSet(b);\n        if (a != b) {\n            if (sz[a] < sz[b]) swap(a, b);\n            p[b] = a;\n            sz[a] += sz[b];\n            sumOfRoads[a] += sumOfRoads[b];\n            sumOfRoads[a] += c; // new road is also included\n        } else {\n            // same set: we just add 0 to reflect that it doesn't alter sumOfRoads \n            // (since the plan says cost is 1000, but that cost goes into \"built roads\" sum,\n            // not into the region's \"existing roads\" sum for subsequent merges).\n        }\n    }\n};\n\nlong long readAndCheckSolution(\n    InStream &stream, \n    DSU &dsu,         // For region merges\n    int n,            // number of cities\n    int p,            // number of roads to build\n    int q,            // final required regions\n    bool juryVersion, // true if reading from \"ans\" \n    bool &isNo        // will store if the read solution was \"NO\"\n) {\n    // We'll read the first token, could be \"YES\" or \"NO\".\n    string first = stream.readToken(\"^(YES|NO)$\");\n    if (first == \"NO\") {\n        // The solution says it's impossible\n        isNo = true;\n        // No roads to read\n        return -1; // We use -1 to denote \"NO\" solution's cost\n    }\n    \n    // If we reach here, it's \"YES\"\n    isNo = false;\n    \n    // We read exactly p lines of roads\n    // We'll compute the total built cost\n    long long totalBuiltCost = 0LL;\n    \n    for (int i = 0; i < p; i++) {\n        int u = stream.readInt(1, n, \"road_u\");\n        int v = stream.readInt(1, n, \"road_v\");\n        if (u == v) {\n            // Invalid: can't build a road between the same city\n            stream.quitf(juryVersion ? _fail : _wa,\n                         \"invalid road between the same city %d\", u);\n        }\n        // DSU is 0-indexed, but cities are 1-indexed\n        int ru = dsu.findSet(u - 1);\n        int rv = dsu.findSet(v - 1);\n        if (ru == rv) {\n            // Cost = 1000 if same region\n            totalBuiltCost += 1000;\n            // no merge\n        } else {\n            // cost = min(10^9, sumOfRoads[uSet] + sumOfRoads[vSet] + 1)\n            long long sU = dsu.getSum(ru);\n            long long sV = dsu.getSum(rv);\n            long long s = sU + sV;\n            long long cost = min((long long)1000000000, s + 1);\n            totalBuiltCost += cost;\n            dsu.unionSet(ru, rv, cost);\n        }\n    }\n    \n    // now check the number of regions\n    // count how many distinct DSU representatives\n    unordered_set<int> st;\n    for (int i = 0; i < n; i++) {\n        st.insert(dsu.findSet(i));\n    }\n    int regions = (int) st.size();\n    if (regions != q) {\n        stream.quitf(\n            juryVersion ? _fail : _wa,\n            \"the plan results in %d regions, but %d expected\",\n            regions, q\n        );\n    }\n    \n    return totalBuiltCost;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // read input\n    int n = inf.readInt(1, 100000, \"n\");\n    int m = inf.readInt(0, 100000, \"m\");\n    int p = inf.readInt(0, 100000, \"p\");\n    int q = inf.readInt(1, n, \"q\");\n    \n    // We'll find the initial connected components of the given graph\n    // and the sum of roads in each component.\n    DSU dsuJ(n), dsuP(n); // We'll keep 2 DSUs, one for jury-solution checking, one for participant\n    \n    // We'll read the existing roads and union their endpoints:\n    // For each union, we add the road length to the new set's sumOfRoads\n    // if it merges two different sets.\n    vector<int> parentJ(n), parentP(n);\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(1, n);\n        int y = inf.readInt(1, n);\n        long long l = inf.readLong(1, 1000000000LL);\n        // union for jury\n        int rxJ = dsuJ.findSet(x - 1);\n        int ryJ = dsuJ.findSet(y - 1);\n        if (rxJ != ryJ) {\n            // merging\n            dsuJ.unionSet(rxJ, ryJ, l);\n        } else {\n            // same set => do nothing\n        }\n        // union for participant\n        int rxP = dsuP.findSet(x - 1);\n        int ryP = dsuP.findSet(y - 1);\n        if (rxP != ryP) {\n            dsuP.unionSet(rxP, ryP, l);\n        }\n    }\n    \n    bool jurySaysNo = false, partSaysNo = false;\n    \n    // read the jury solution\n    // we pass a fresh copy of DSU for jury\n    // store total cost of building in Tjury\n    long long Tjury = readAndCheckSolution(ans, dsuJ, n, p, q, /*juryVersion=*/true, jurySaysNo);\n    \n    // read participant solution\n    long long Tpart = readAndCheckSolution(ouf, dsuP, n, p, q, /*juryVersion=*/false, partSaysNo);\n\n    // Now compare:\n    // if jury says NO\n    if (jurySaysNo) {\n        // if participant says NO => OK\n        // if participant says YES => participant found a solution while jury says impossible -> _fail\n        if (!partSaysNo) {\n            quitf(_fail, \"Participant found a solution, but jury says no solution exists.\");\n        } else {\n            quitf(_ok, \"Both jury and participant say NO.\");\n        }\n    } else {\n        // jury says YES\n        // if participant says NO => WA\n        if (partSaysNo) {\n            quitf(_wa, \"Jury found a solution, but participant claims NO.\");\n        }\n        // both say YES:\n        // we compare Tjury vs Tpart\n        if (Tpart > Tjury) {\n            quitf(_wa,\n                  \"Participant's total cost %lld is worse than jury's %lld.\",\n                  Tpart, Tjury);\n        } else if (Tpart < Tjury) {\n            quitf(_fail,\n                  \"Participant's total cost %lld is better than jury's %lld.\",\n                  Tpart, Tjury);\n        } else {\n            quitf(_ok, \"Costs match: %lld.\", Tpart);\n        }\n    }\n    return 0; \n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint parent[100005];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[u] = v;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // Number of existing edges\n    int p = opt<int>(\"p\", 0); // Number of edges to build\n    int q = opt<int>(\"q\", n); // Desired number of regions\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int>> edges;\n\n    if (type == \"random\") {\n        // Generate m random edges\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n        }\n\n    } else if (type == \"no_edges\") {\n        // m = 0\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        m = 0;\n\n    } else if (type == \"fully_connected\") {\n        // Create connected graph\n        // Generate n-1 edges to form a tree\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n        }\n        m = n - 1;\n\n    } else if (type == \"impossible\") {\n        // Generate a test case where it's impossible to reach q regions\n        // Let's set m = 0, tot = n\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        m = 0;\n        // tot = n\n        // Let's set p = 0\n        p = 0;\n        if (n > 1)\n            q = n - 1;\n        else\n            q = 1; // But tot - p = n > q\n\n        // Condition tot - p > q holds because n - 0 > q\n    } else if (type == \"multiple_edges\") {\n        // Generate multiple edges between nodes\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n            // Allow multiple edges between the same pair\n            int num_extra_edges = rnd.next(0, 3);\n            for (int j = 0; j < num_extra_edges; ++j) {\n                li = rnd.next(1, 1000000000);\n                edges.push_back(make_tuple(u, v, li));\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n        }\n    }\n\n    // Compute number of connected components (tot)\n    set<int> components;\n    for (int i = 1; i <= n; ++i) {\n        components.insert(find(i));\n    }\n    int tot = components.size();\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, p, q);\n    for (auto e : edges) {\n        int u, v, li;\n        tie(u, v, li) = e;\n        printf(\"%d %d %d\\n\", u, v, li);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint parent[100005];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[u] = v;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // Number of existing edges\n    int p = opt<int>(\"p\", 0); // Number of edges to build\n    int q = opt<int>(\"q\", n); // Desired number of regions\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int>> edges;\n\n    if (type == \"random\") {\n        // Generate m random edges\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n        }\n\n    } else if (type == \"no_edges\") {\n        // m = 0\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        m = 0;\n\n    } else if (type == \"fully_connected\") {\n        // Create connected graph\n        // Generate n-1 edges to form a tree\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n        }\n        m = n - 1;\n\n    } else if (type == \"impossible\") {\n        // Generate a test case where it's impossible to reach q regions\n        // Let's set m = 0, tot = n\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        m = 0;\n        // tot = n\n        // Let's set p = 0\n        p = 0;\n        if (n > 1)\n            q = n - 1;\n        else\n            q = 1; // But tot - p = n > q\n\n        // Condition tot - p > q holds because n - 0 > q\n    } else if (type == \"multiple_edges\") {\n        // Generate multiple edges between nodes\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n            // Allow multiple edges between the same pair\n            int num_extra_edges = rnd.next(0, 3);\n            for (int j = 0; j < num_extra_edges; ++j) {\n                li = rnd.next(1, 1000000000);\n                edges.push_back(make_tuple(u, v, li));\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            int li = rnd.next(1, 1000000000);\n            edges.push_back(make_tuple(u, v, li));\n            unite(u, v);\n        }\n    }\n\n    // Compute number of connected components (tot)\n    set<int> components;\n    for (int i = 1; i <= n; ++i) {\n        components.insert(find(i));\n    }\n    int tot = components.size();\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, p, q);\n    for (auto e : edges) {\n        int u, v, li;\n        tie(u, v, li) = e;\n        printf(\"%d %d %d\\n\", u, v, li);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 9 -p 0 -q 1 -type fully_connected\n./gen -n 100 -m 0 -p 0 -q 100 -type no_edges\n./gen -n 1000 -m 999 -p 0 -q 1 -type fully_connected\n./gen -n 1000 -m 1000 -p 0 -q 1 -type random\n./gen -n 1000 -m 0 -p 0 -q 999 -type impossible\n./gen -n 1000 -m 0 -p 0 -q 500 -type impossible\n./gen -n 1000 -m 0 -p 1 -q 1000 -type impossible\n./gen -n 1000 -m 0 -p 500 -q 1 -type impossible\n./gen -n 10000 -m 5000 -p 1000 -q 1 -type random\n./gen -n 10000 -m 0 -p 0 -q 10000 -type no_edges\n./gen -n 10000 -m 0 -p 0 -q 1 -type impossible\n./gen -n 100000 -m 100000 -p 0 -q 1 -type random\n./gen -n 100000 -m 0 -p 0 -q 100000 -type no_edges\n./gen -n 100000 -m 0 -p 100000 -q 1 -type impossible\n./gen -n 100000 -m 100000 -p 100000 -q 1 -type random\n./gen -n 100000 -m 0 -p 0 -q 100000 -type impossible\n./gen -n 100000 -m 99999 -p 1 -q 1 -type fully_connected\n./gen -n 100000 -m 0 -p 0 -q 1 -type impossible\n./gen -n 1000 -m 0 -p 0 -q 1 -type multiple_edges\n./gen -n 50000 -m 50000 -p 0 -q 1 -type fully_connected\n./gen -n 50000 -m 50000 -p 0 -q 1 -type random\n./gen -n 100000 -m 0 -p 0 -q 100000 -type no_edges\n./gen -n 2 -m 1 -p 0 -q 1 -type random\n./gen -n 2 -m 0 -p 0 -q 2 -type no_edges\n./gen -n 1 -m 0 -p 0 -q 1 -type impossible\n./gen -n 3 -m 0 -p 0 -q 2 -type impossible\n./gen -n 100 -m 50 -p 0 -q 1 -type multiple_edges\n./gen -n 100000 -m 0 -p 0 -q 100000 -type no_edges\n./gen -n 10000 -m 3000 -p 7000 -q 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:33.754931",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "362/E",
      "title": "E. Petya and Pipes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (2 ≤ n ≤ 50, 0 ≤ k ≤ 1000). Then follow n lines, each line contains n integers separated by single spaces. The i + 1-th row and j-th column contain number cij — the width of the pipe that goes from tank i to tank j (0 ≤ cij ≤ 106, cii = 0). If cij = 0, then there is no pipe from tank i to tank j.",
      "output_spec": "OutputPrint a single integer — the maximum amount of water that can be transmitted from the main tank to the sewer tank per a unit of time.",
      "sample_tests": "ExamplesInputCopy5 70 1 0 2 00 0 4 10 00 0 0 0 50 0 0 0 100 0 0 0 0OutputCopy10InputCopy5 100 1 0 0 00 0 2 0 00 0 0 3 00 0 0 0 4100 0 0 0 0OutputCopy5",
      "description": "E. Petya and Pipes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (2 ≤ n ≤ 50, 0 ≤ k ≤ 1000). Then follow n lines, each line contains n integers separated by single spaces. The i + 1-th row and j-th column contain number cij — the width of the pipe that goes from tank i to tank j (0 ≤ cij ≤ 106, cii = 0). If cij = 0, then there is no pipe from tank i to tank j.\n\nOutputPrint a single integer — the maximum amount of water that can be transmitted from the main tank to the sewer tank per a unit of time.\n\nInputCopy5 70 1 0 2 00 0 4 10 00 0 0 0 50 0 0 0 100 0 0 0 0OutputCopy10InputCopy5 100 1 0 0 00 0 2 0 00 0 0 3 00 0 0 0 4100 0 0 0 0OutputCopy5\n\nInputCopy5 70 1 0 2 00 0 4 10 00 0 0 0 50 0 0 0 100 0 0 0 0\n\nOutputCopy10\n\nInputCopy5 100 1 0 0 00 0 2 0 00 0 0 3 00 0 0 0 4100 0 0 0 0\n\nOutputCopy5\n\nNoteIn the first test Petya can increase width of the pipe that goes from the 1st to the 2nd water tank by 7 units.In the second test Petya can increase width of the pipe that goes from the 1st to the 2nd water tank by 4 units, from the 2nd to the 3rd water tank by 3 units, from the 3rd to the 4th water tank by 2 units and from the 4th to 5th water tank by 1 unit.",
      "solutions": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces",
          "content": "Hello everyone!November 14, 19:30 MSK will take place Codeforces Round #212 (Div. 2), which was prepared by group of authors from Saratov State University: Artem Sedanov (FunkyCat), Sergey Sukhov (Serega), Olga Chikatueva (Helga), Dmitriy Zaycev (My-my).We thank coordinator of Codeforces rounds Gerald Agapov (Gerald) for useful hints and Maria Belova (Delinur) for translation of problem's statements into English.Good luck and high rating to all!UPD1. In this round will be used dynamic scoring system (see here).UPD2. Tutorial is published here.UPD3. Rating is updated. We congratulate the winners who solved four problems: CleRIC i_must_learn_matan Dshavn gzh1998n",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9550",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 669
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces",
          "content": "362A - Two Semiknights MeetAutors have proposed different solutions. One can notice that if semiknights did not have a meeting after first step (it is not necessary they have a meeting in \"good\" square), they will not meet at all. This fact appears from board size and possible semiknight's moves. As the initial semiknight's squares are considered good for the meeting the semiknights have arrived to the one square and then they move together to one of the initial squares and meeting will count. 362B - Petya and StaircasesOne has to note that the number of dirty stairs  ≤ 3000. Petya can reach stair number n if the first and the last stairs are not dirty and there are not three or more dirty stairs in a row. So let sort the array of dirty stairs and go through it, checking for three or more consecutive dirty stairs. Also one need to check if the first or the last stair is in this array.362C - Insertion SortThe number of times swap is called equals the number of inversions in the input permutation. It’s easy to see that it is reasonable to swap only such elements ai, aj that i < j and ai > aj (otherwise the number of inversions will increase). Let di, j be the number of permutation of elements with indices from 0 to i inclusive which are strictly less than j. Then, after swapping elements with indices i and j, the number of inversions will be old - 2 * (di, ai + dj, aj - di, aj - dj, ai) - 1, where old is the number of inversions in the initial permutation. It is sufficient to search all pairs of elements and pick those which help to minimize the number of inversions. The reader may prove the correctness of the formula as a supplementary task.362D - Fools and Foolproof RoadsIf the given graph contains less than q connectivity components, then there’s no solution. Otherwise it’s optimal at first add edges that connect different components and afterwards all remaining edges (they will be connect edges from one component). For the first phase you can use greedy algorithm: each time you select two components, current weight of which is minimal, and connect them with an edge. For example, you can store weights of all components in the current graph in some data structure (like set in С++). For the second phase it’s enough to find any component that contains two or more vertices (because loops are forbidden) and add all remaining edges between some two vertices of this component. If some action cannot be successfully executed (for example, you added all the edges and number of connectivity components if greater than q), then there’s no solution. Asymptotics — O(n + m + plogn).362E - Petya and PipesConstruct the following flow network. Water tank 1 is the source, water tank n is the sink. Every pipe from water tank u to water tank v is presented as two arcs — the first one with capacity cuv and cost 0 and the second one with infinite capacity and cost 1. Thus, the answer is the maximum flow with cost not greater than k. It can be found by standard augmenting paths algorithm.UPD1. Tutorial for problems A and B added. UPD2. Tutorial for problem C added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9584",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 362\\s*E"
          },
          "content_length": 3097
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 1",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 2",
          "code": "`if(!m){` `  puts(\"YES\");` `  return 0;` `}`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 3",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 4",
          "code": "if(s[0]==1||s[m-1]==n)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 5",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 6",
          "code": "if(s[m-1]==n||s[0]==1)\n{\n    cout<<\"NO\\n\";\n    return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 7",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 8",
          "code": "........\n........\n........\n........\n........\n..K.....\n........\nK.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 9",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 10",
          "code": "K###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 11",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 12",
          "code": ".###.###\n########\n##K####.\n#.######\n########\n########\n########\n#######.\n\n.###K###\n########\n#######.\n#.######\n########\n########\n########\n#######.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 13",
          "code": "5 1 3 4 0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2) - Codeforces - Code 14",
          "code": "5 1 3 0 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9550",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 1",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #212 (Div. 2). Tutorial. Part 1. - Codeforces - Code 2",
          "code": "1\n........\n........\n......#.\nK..##..#\n.......#\n..K##..#\n......#.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9584",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            string varName = \"c[\" + to_string(i+1) + \"][\" + to_string(j+1) + \"]\";\n            int cij = inf.readInt(0, 1000000, varName);\n            if (i == j) {\n                ensuref(cij == 0, \"c[%d][%d] must be zero, but is %d\", i+1, j+1, cij);\n            }\n            if (j < n - 1) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            string varName = \"c[\" + to_string(i+1) + \"][\" + to_string(j+1) + \"]\";\n            int cij = inf.readInt(0, 1000000, varName);\n            if (i == j) {\n                ensuref(cij == 0, \"c[%d][%d] must be zero, but is %d\", i+1, j+1, cij);\n            }\n            if (j < n - 1) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            string varName = \"c[\" + to_string(i+1) + \"][\" + to_string(j+1) + \"]\";\n            int cij = inf.readInt(0, 1000000, varName);\n            if (i == j) {\n                ensuref(cij == 0, \"c[%d][%d] must be zero, but is %d\", i+1, j+1, cij);\n            }\n            if (j < n - 1) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    const int maxCapacity = 1000000; // Maximum capacity (1e6)\n\n    // Initialize the capacity matrix with zeros\n    vector<vector<int>> c(n, vector<int>(n, 0));\n\n    // Ensure no self-loops\n    for(int i = 0; i < n; ++i) {\n        c[i][i] = 0;\n    }\n\n    if(type == \"chain\") {\n        // Create a chain from node 1 to node n\n        for(int i = 0; i < n - 1; ++i) {\n            c[i][i + 1] = rnd.next(1, maxCapacity);\n        }\n    } else if(type == \"star\") {\n        // Create a star with node 1 connected to all other nodes\n        for(int i = 1; i < n; ++i) {\n            c[0][i] = rnd.next(1, maxCapacity);\n        }\n    } else if(type == \"cycle\") {\n        // Create a cycle connecting nodes in order\n        for(int i = 0; i < n; ++i) {\n            int to = (i + 1) % n;\n            if(to != i) {\n                c[i][to] = rnd.next(1, maxCapacity);\n            }\n        }\n    } else if(type == \"random\") {\n        // Randomly add edges between nodes based on edge probability\n        double edgeProb = opt<double>(\"edgeProb\", 0.3);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i != j && rnd.next() < edgeProb) {\n                    c[i][j] = rnd.next(1, maxCapacity);\n                }\n            }\n        }\n    } else if(type == \"dense\") {\n        // Fully connect the graph excluding self-loops\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i != j) {\n                    c[i][j] = rnd.next(1, maxCapacity);\n                }\n            }\n        }\n    } else if(type == \"sparse\") {\n        // Create a sparse graph with minimal edges to connect from node 1 to n\n        vector<int> perm(n);\n        iota(perm.begin(), perm.end(), 0);\n        shuffle(perm.begin(), perm.end());\n        for(int i = 0; i < n - 1; ++i) {\n            int u = perm[i];\n            int v = perm[i + 1];\n            c[u][v] = rnd.next(1, maxCapacity);\n        }\n        // Optionally add extra random edges\n        int extraEdges = opt<int>(\"extraEdges\", 0);\n        for(int e = 0; e < extraEdges; ++e) {\n            int u = rnd.next(n);\n            int v = rnd.next(n);\n            if(u != v && c[u][v] == 0) {\n                c[u][v] = rnd.next(1, maxCapacity);\n            }\n        }\n    } else {\n        // Default to random if type is not recognized\n        double edgeProb = opt<double>(\"edgeProb\", 0.3);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i != j && rnd.next() < edgeProb) {\n                    c[i][j] = rnd.next(1, maxCapacity);\n                }\n            }\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the capacity matrix\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", c[i][j]);\n            if(j != n - 1) {\n                printf(\" \");\n            }\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    const int maxCapacity = 1000000; // Maximum capacity (1e6)\n\n    // Initialize the capacity matrix with zeros\n    vector<vector<int>> c(n, vector<int>(n, 0));\n\n    // Ensure no self-loops\n    for(int i = 0; i < n; ++i) {\n        c[i][i] = 0;\n    }\n\n    if(type == \"chain\") {\n        // Create a chain from node 1 to node n\n        for(int i = 0; i < n - 1; ++i) {\n            c[i][i + 1] = rnd.next(1, maxCapacity);\n        }\n    } else if(type == \"star\") {\n        // Create a star with node 1 connected to all other nodes\n        for(int i = 1; i < n; ++i) {\n            c[0][i] = rnd.next(1, maxCapacity);\n        }\n    } else if(type == \"cycle\") {\n        // Create a cycle connecting nodes in order\n        for(int i = 0; i < n; ++i) {\n            int to = (i + 1) % n;\n            if(to != i) {\n                c[i][to] = rnd.next(1, maxCapacity);\n            }\n        }\n    } else if(type == \"random\") {\n        // Randomly add edges between nodes based on edge probability\n        double edgeProb = opt<double>(\"edgeProb\", 0.3);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i != j && rnd.next() < edgeProb) {\n                    c[i][j] = rnd.next(1, maxCapacity);\n                }\n            }\n        }\n    } else if(type == \"dense\") {\n        // Fully connect the graph excluding self-loops\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i != j) {\n                    c[i][j] = rnd.next(1, maxCapacity);\n                }\n            }\n        }\n    } else if(type == \"sparse\") {\n        // Create a sparse graph with minimal edges to connect from node 1 to n\n        vector<int> perm(n);\n        iota(perm.begin(), perm.end(), 0);\n        shuffle(perm.begin(), perm.end());\n        for(int i = 0; i < n - 1; ++i) {\n            int u = perm[i];\n            int v = perm[i + 1];\n            c[u][v] = rnd.next(1, maxCapacity);\n        }\n        // Optionally add extra random edges\n        int extraEdges = opt<int>(\"extraEdges\", 0);\n        for(int e = 0; e < extraEdges; ++e) {\n            int u = rnd.next(n);\n            int v = rnd.next(n);\n            if(u != v && c[u][v] == 0) {\n                c[u][v] = rnd.next(1, maxCapacity);\n            }\n        }\n    } else {\n        // Default to random if type is not recognized\n        double edgeProb = opt<double>(\"edgeProb\", 0.3);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i != j && rnd.next() < edgeProb) {\n                    c[i][j] = rnd.next(1, maxCapacity);\n                }\n            }\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the capacity matrix\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", c[i][j]);\n            if(j != n - 1) {\n                printf(\" \");\n            }\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 7 -type chain\n./gen -n 5 -k 10 -type chain\n./gen -n 5 -k 7 -type star\n./gen -n 5 -k 10 -type star\n./gen -n 10 -k 20 -type chain\n./gen -n 10 -k 50 -type star\n./gen -n 15 -k 100 -type cycle\n./gen -n 20 -k 0 -type chain\n./gen -n 20 -k 1000 -type star\n./gen -n 30 -k 500 -type random -edgeProb 0.5\n./gen -n 40 -k 1000 -type dense\n./gen -n 50 -k 0 -type sparse\n./gen -n 50 -k 1000 -type random -edgeProb 0.1\n./gen -n 50 -k 1000 -type random -edgeProb 0.9\n./gen -n 50 -k 500 -type random -edgeProb 0.3\n./gen -n 50 -k 100 -type sparse -extraEdges 50\n./gen -n 2 -k 0 -type chain\n./gen -n 2 -k 1000 -type chain\n./gen -n 25 -k 250 -type cycle\n./gen -n 35 -k 750 -type star\n./gen -n 45 -k 1000 -type chain\n./gen -n 50 -k 1000 -type cycle\n./gen -n 50 -k 500 -type random -edgeProb 0.2\n./gen -n 50 -k 0 -type random -edgeProb 0.5\n./gen -n 50 -k 0 -type dense\n./gen -n 50 -k 1000 -type dense\n./gen -n 50 -k 1000 -type sparse -extraEdges 100\n./gen -n 50 -k 500 -type sparse -extraEdges 100\n./gen -n 3 -k 1 -type chain\n./gen -n 4 -k 1000 -type random -edgeProb 1.0\n./gen -n 20 -k 50 -type sparse -extraEdges 10\n./gen -n 25 -k 0 -type chain\n./gen -n 30 -k 200 -type random -edgeProb 0.4\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:35.874242",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "363/A",
      "title": "A. Соробан",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (0 ≤ n < 109).",
      "output_spec": "Выходные данныеВыведите описание десятичных разрядов числа n в порядке от младших к старшим, по одному в строке. При выводе костяшки обозначайте заглавной латинской буквой 'O', части спицы символом '-', а перегородку символом '|'. Выводите столько разрядов, сколько цифр содержится в десятичной записи числа n без лидирующих нулей. Считается, что у числа 0 лидирующих нулей нет.",
      "sample_tests": "ПримерыВходные данныеСкопировать2Выходные данныеСкопироватьO-|OO-OOВходные данныеСкопировать13Выходные данныеСкопироватьO-|OOO-OO-|O-OOOВходные данныеСкопировать720Выходные данныеСкопироватьO-|-OOOOO-|OO-OO-O|OO-OO",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (0 ≤ n < 109).\n\nВходные данные\n\nВыходные данныеВыведите описание десятичных разрядов числа n в порядке от младших к старшим, по одному в строке. При выводе костяшки обозначайте заглавной латинской буквой 'O', части спицы символом '-', а перегородку символом '|'. Выводите столько разрядов, сколько цифр содержится в десятичной записи числа n без лидирующих нулей. Считается, что у числа 0 лидирующих нулей нет.\n\nВыходные данные\n\nВходные данныеСкопировать2Выходные данныеСкопироватьO-|OO-OOВходные данныеСкопировать13Выходные данныеСкопироватьO-|OOO-OO-|O-OOOВходные данныеСкопировать720Выходные данныеСкопироватьO-|-OOOOO-|OO-OO-O|OO-OO\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьO-|OO-OO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать13\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьO-|OOO-OO-|O-OOO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать720\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьO-|-OOOOO-|OO-OO-O|OO-OO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!I'm glad to announce that we again decided to introduce a round based on one of the programming olympiads for schoolchidren in Saratov. This time it is a round for participants from Division II. Round will start at unusual time for Codeforces: 12:00 MSK.The problems were prepared by MikeMirzayanov and me, while Fefer_Ivan and Gerald helped us with writing alternative solutions.Members of the first division can participate out of competition, as usual.Scoring distribution is standard: 500-1000-1500-2000-2500.UPD: tutorial can be found here.UPD 2: The model solution for problem E (unfortunately, there were only one model solution) was incorrect. But, the answers for all pretests were correct. After the round we fixed the solution. All submits for problem E were rejudged.UPD 3: Results are final, ratings are updated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 863
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, сообщество Codeforces!Рад Вам сообщить, что мы в очередной раз делаем раунд из задач одной из олимпиад для саратовских школьников. На этот раз — раунд для второго дивизиона. Раунд начнется в необычное для Codeforces время: 11 ноября в 12:00 MSKЗадачи были подготовлены MikeMirzayanov и мной, в написании альтернативных решений нам помогали Fefer_Ivan и Gerald.Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Разбалловка стандартная: 500-1000-1500-2000-2500.UPD: Опубликован разбор на английском.UPD 2: В задаче E изначальное авторское решение (оно, к сожалению, было одно) было неправильным. Однако, ответы ко всем претестам были корректные. После контеста авторское решение было исправлено, все решения по задаче E были перетестированы.UPD 3: Появились окончательные результаты, рейтинг обновлен.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 849
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces",
          "content": "363A - СоробанNot so much to say about this problem. You need to extract the digits of the given number (read it as string or repeteadly divide by 10 and take the remainders). Then carefully do the mapping of digits to its' representation.363B - ЗаборAnother easy problem. We need to calculate the sum of every consequtive segment of k planks. One way to do this is to calculate partial prefix sums: . Then the sum of heights of the planks i, i + 1, ..., i + k - 1 is si + k - 1 - si - 1. The other approach is to calculate the sum of the first k planks: h1 + h2 + ... + hk. By subtracting h1 and adding hk + 1 we get sum of k planks starting from the second plank. Then, by subtracting h2 and adding hk + 2 we get sum of k planks starting from the third plank, and so on.363C - Исправление опечатокThe general idea of the solution is the following: while there are three consequtive equal characters, remove any one of them. After that we can only have typos of the second type. So, if we have one couple of equal characters immediately after another couple of equal characters (xxyy), we need to decide which character to remove, x or y? Let's find the leftmost typo of the second type in the string. It is easy to see that we can always remove the character from the second couple.All these can be done in a single pass. Go through the characters of the given string and build the resulting string ans. Let's denote the current character as ch. If ch is equal to the last two characters of ans, skip ch. If ch is equal to the last character of ans and ans[length(ans) - 2] = ans[length(ans) - 3] (assume that ans is 1-indexed), skip ch. Otherwise, append ch to ans.363D - Прокат велосипедовLet's do a binary search over the number of boys that can rent a bike. So let's say that we want to check whether it possible for k boys to rent bikes. If some k boys can rent a bike, then the k \"richest\" boys (with the most amount of personal money) also can do that. It is easy to see that if they can rent bikes, they can rent k cheapest bikes (if we first sort the bikes in increasing order of price, it will be just the first k bikes).So, take k richest boys and try to match them with k cheapest bikes, spending as much common budget as possible. The following algorithm works (try to understand and prove it before asking questions): take the boy with least number of money (of course, among the considered k richest) and try to give him the cheapest bike. If the boy has ehough personal money to rent this bike, use his money to do this. Otherwise, use all his money and take some money from the common budget. Continue this process with the second cheapest bike and the second \"poorest among the richest\" boys. This process can end in two ways: we will either run out of budget and fail to rent k bikes, or we will successfully rent these bikes. 363E - Два кругаAt first, for each valid center cell (i, j) calculate circleSum[i][j] — sum of values inside the circle with center at (i, j). This can be done with the code like that: for (int i0 = r; i0 + r < n; i0++) {\n for (int j0 = r; j0 + r < m; j0++) {\n int sum = 0;\n int lj = j0, rj = j0;\n for (int i = i0 - r; i <= i0 + r; i++) {\n while (dist2(i0, j0, i, lj) > r * r) lj++;\n while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n while (dist2(i0, j0, i, rj) > r * r) rj--;\n while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n sum += rowSum[i][rj + 1] - rowSum[i][lj];\n }\n circleSum[i0][j0] = sum;\n }\n }This code iterates over all rows from top to bottom and keeps lj and rj — the leftmost and the rightmost columns in current row i that are inside the circle with center at (i0, j0). The function dist2 returns squared distance between two cells, rowSum[i][j] is equal to sum of first j cells in row i. In total, values lj and rj will be changed O(n + m) times, so the complexity of this part is O(nm(n + m)).In the second part of the solution, for each row i we calculate several values: leftMax[i][j] — maximum of circleSum[i][k] for k ≤ i cntLeftMax[i][j] — the number of corresponding maximum values rightMax[i][j] — maximum of circleSum[i][k] for k ≥ i cntRightMax[i][j] — the number of corresponding maximum values All these values can be calculated in O(nm) time.The third part of the solution is the most tricky one. Let's say that the cell (i, j) is boundary cell for the circle centered at (i0, j0) if it belongs to this circle and is the leftmost or the rightmost such point in row i. It is easy to see that two circles A and B intersect if and only if there exists a boundary cell of the circle A that belongs to the circle B. As long as we have O(n + m) boundary cells for each circle, checking whether two given circles intersect can be done in linear time. Now, for each pair (di, dj), which means the relative position of one center to the other, we can determine if such two circles intersect. There are O(nm) pairs (di, dj), so the total complexity of this part is O(nm(n + m)).And, finally, in the fourth part we are going to calculate the answer. Let's iterate over all triples of values (i0, j0, i), where (i0, j0) is a valid center cell and i is a row number. Consider the set of cells (i, j) in the row i such that the circle centered at (i, j) intersects with the circle at (i0, j0). It is clear that this set is consists of some (possibly zero) consequtive cells in a row. Let's assume that these cells are (i, lj), (i, lj + 1), ..., (i, rj), values lj and rj can be found in the third part of the solution. We are interested in cell that are not in this set: (i, j) with j < lj or j > rj. To find the maximum sum in such circles in O(1), we use arrays computed in the second part. Overall complexity of the solution is O(nm(n + m)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9537",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 363\\s*A"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 5",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 6",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 1",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 2",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 3",
          "code": "(x2, y1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 4",
          "code": "(x2, y1 + k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 5",
          "code": "(x2, r + 1 ... y1 - 1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 6",
          "code": "(x2, y1 + 1 + k ... n - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 7",
          "code": "a_1, a_2 ... a_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 8",
          "code": "b_1, b_2...b_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 9",
          "code": "a_i boy buys b_i bike",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 10",
          "code": "Case 1: if b_i <= a_i,  then a_i, a_j >= b_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 11",
          "code": "it is always better using a_j buy b_j as a_i can afford b_i by himself --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 12",
          "code": "Case 2: if b_i > a_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 13",
          "code": "no matter b_i > a_j or b_i <= a_j, swapping them won't able to make result better --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 14",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 15",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 16",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 17",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"0|[1-9][0-9]{0,8}\", \"n\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"0|[1-9][0-9]{0,8}\", \"n\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"0|[1-9][0-9]{0,8}\", \"n\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long string_to_number(const string& s) {\n    long long res = 0;\n    for (char c : s) {\n        res = res * 10 + (c - '0');\n    }\n    return res;\n}\n\nint get_num_digits(long long num) {\n    int numDigits = 0;\n    do {\n        numDigits++;\n        num /= 10;\n    } while (num > 0);\n    return numDigits;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long maxN = opt<long long>(\"maxN\", 999999999);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n;\n\n    // Compute number of digits in maxN\n    int numDigits = get_num_digits(maxN);\n\n    if (type == \"zero\") {\n        n = 0;\n    } else if (type == \"max\") {\n        n = maxN;\n    } else if (type == \"random\") {\n        n = rnd.next(0LL, maxN);\n    } else if (type == \"all_digits\") {\n        string digits = \"9876543210\";\n        int len = min(numDigits, 10);\n        string s = digits.substr(0, len);\n        shuffle(s.begin(), s.end());\n        if (s[0] == '0' && len > 1) {\n            swap(s[0], s[1]); // Avoid leading zero\n        }\n        n = string_to_number(s);\n        if (n > maxN) {\n            sort(s.begin(), s.end());\n            n = string_to_number(s);\n        }\n        if (n > maxN) {\n            sort(s.rbegin(), s.rend());\n            n = string_to_number(s);\n        }\n        if (n > maxN) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"palindrome\") {\n        bool found = false;\n        for (int tries = 0; tries < 1000 && !found; ++tries) {\n            int len = rnd.next(1, numDigits);\n            string half = \"\";\n            for (int i = 0; i < (len + 1) / 2; ++i) {\n                int d = rnd.next(0, 9);\n                if (i == 0 && len > 1 && d == 0) {\n                    d = rnd.next(1, 9); // Avoid leading zero\n                }\n                half += char('0' + d);\n            }\n            string rev_half = half;\n            if (len %2 == 1) rev_half.pop_back();\n            reverse(rev_half.begin(), rev_half.end());\n            string s = half + rev_half;\n            n = string_to_number(s);\n            if (n <= maxN) {\n                found = true;\n            }\n        }\n        if (!found) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"repeat_digit\") {\n        bool found = false;\n        for (int tries = 0; tries < 1000 && !found; ++tries) {\n            int len = rnd.next(1, numDigits);\n            int d = rnd.next(0, 9);\n            if (d == 0 && len > 1) {\n                d = rnd.next(1,9); // Avoid leading zeros\n            }\n            string s(len, char('0' + d));\n            n = string_to_number(s);\n            if (n <= maxN) {\n                found = true;\n            }\n        }\n        if (!found) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"alternating\") {\n        bool found = false;\n        for (int tries = 0; tries < 1000 && !found; ++tries) {\n            int len = rnd.next(2, numDigits);\n            int d1 = rnd.next(0, 9);\n            int d2 = rnd.next(0, 9);\n            while (d2 == d1) {\n                d2 = rnd.next(0, 9);\n            }\n            if (d1 == 0 && len > 1) {\n                d1 = rnd.next(1,9);\n            }\n            string s = \"\";\n            for (int i = 0; i < len; ++i) {\n                if (i %2 == 0) s += char('0' + d1);\n                else s += char('0' + d2);\n            }\n            n = string_to_number(s);\n            if (n <= maxN) {\n                found = true;\n            }\n        }\n        if (!found) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"ascending\") {\n        string digits = \"123456789\";\n        int len = min(numDigits, 9);\n        string s = digits.substr(0, len);\n        n = string_to_number(s);\n        if (n > maxN) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"descending\") {\n        string digits = \"9876543210\";\n        int len = min(numDigits, 10);\n        string s = digits.substr(0, len);\n        n = string_to_number(s);\n        while (n > maxN && len > 0) {\n            len--;\n            s = s.substr(0, len);\n            n = string_to_number(s);\n        }\n        if (n > maxN) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else {\n        // Default to random\n        n = rnd.next(0LL, maxN);\n    }\n\n    // Output n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long string_to_number(const string& s) {\n    long long res = 0;\n    for (char c : s) {\n        res = res * 10 + (c - '0');\n    }\n    return res;\n}\n\nint get_num_digits(long long num) {\n    int numDigits = 0;\n    do {\n        numDigits++;\n        num /= 10;\n    } while (num > 0);\n    return numDigits;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long maxN = opt<long long>(\"maxN\", 999999999);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n;\n\n    // Compute number of digits in maxN\n    int numDigits = get_num_digits(maxN);\n\n    if (type == \"zero\") {\n        n = 0;\n    } else if (type == \"max\") {\n        n = maxN;\n    } else if (type == \"random\") {\n        n = rnd.next(0LL, maxN);\n    } else if (type == \"all_digits\") {\n        string digits = \"9876543210\";\n        int len = min(numDigits, 10);\n        string s = digits.substr(0, len);\n        shuffle(s.begin(), s.end());\n        if (s[0] == '0' && len > 1) {\n            swap(s[0], s[1]); // Avoid leading zero\n        }\n        n = string_to_number(s);\n        if (n > maxN) {\n            sort(s.begin(), s.end());\n            n = string_to_number(s);\n        }\n        if (n > maxN) {\n            sort(s.rbegin(), s.rend());\n            n = string_to_number(s);\n        }\n        if (n > maxN) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"palindrome\") {\n        bool found = false;\n        for (int tries = 0; tries < 1000 && !found; ++tries) {\n            int len = rnd.next(1, numDigits);\n            string half = \"\";\n            for (int i = 0; i < (len + 1) / 2; ++i) {\n                int d = rnd.next(0, 9);\n                if (i == 0 && len > 1 && d == 0) {\n                    d = rnd.next(1, 9); // Avoid leading zero\n                }\n                half += char('0' + d);\n            }\n            string rev_half = half;\n            if (len %2 == 1) rev_half.pop_back();\n            reverse(rev_half.begin(), rev_half.end());\n            string s = half + rev_half;\n            n = string_to_number(s);\n            if (n <= maxN) {\n                found = true;\n            }\n        }\n        if (!found) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"repeat_digit\") {\n        bool found = false;\n        for (int tries = 0; tries < 1000 && !found; ++tries) {\n            int len = rnd.next(1, numDigits);\n            int d = rnd.next(0, 9);\n            if (d == 0 && len > 1) {\n                d = rnd.next(1,9); // Avoid leading zeros\n            }\n            string s(len, char('0' + d));\n            n = string_to_number(s);\n            if (n <= maxN) {\n                found = true;\n            }\n        }\n        if (!found) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"alternating\") {\n        bool found = false;\n        for (int tries = 0; tries < 1000 && !found; ++tries) {\n            int len = rnd.next(2, numDigits);\n            int d1 = rnd.next(0, 9);\n            int d2 = rnd.next(0, 9);\n            while (d2 == d1) {\n                d2 = rnd.next(0, 9);\n            }\n            if (d1 == 0 && len > 1) {\n                d1 = rnd.next(1,9);\n            }\n            string s = \"\";\n            for (int i = 0; i < len; ++i) {\n                if (i %2 == 0) s += char('0' + d1);\n                else s += char('0' + d2);\n            }\n            n = string_to_number(s);\n            if (n <= maxN) {\n                found = true;\n            }\n        }\n        if (!found) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"ascending\") {\n        string digits = \"123456789\";\n        int len = min(numDigits, 9);\n        string s = digits.substr(0, len);\n        n = string_to_number(s);\n        if (n > maxN) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else if (type == \"descending\") {\n        string digits = \"9876543210\";\n        int len = min(numDigits, 10);\n        string s = digits.substr(0, len);\n        n = string_to_number(s);\n        while (n > maxN && len > 0) {\n            len--;\n            s = s.substr(0, len);\n            n = string_to_number(s);\n        }\n        if (n > maxN) {\n            n = rnd.next(0LL, maxN);\n        }\n    } else {\n        // Default to random\n        n = rnd.next(0LL, maxN);\n    }\n\n    // Output n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type zero\n\n./gen -type max -maxN 0\n./gen -type max -maxN 1\n./gen -type max -maxN 10\n./gen -type max -maxN 100\n./gen -type max -maxN 999999999\n\n./gen -type random -maxN 0\n./gen -type random -maxN 1\n./gen -type random -maxN 10\n./gen -type random -maxN 100\n./gen -type random -maxN 1000\n./gen -type random -maxN 1000000\n./gen -type random -maxN 999999999\n\n./gen -type palindrome -maxN 10\n./gen -type palindrome -maxN 100\n./gen -type palindrome -maxN 1000\n./gen -type palindrome -maxN 1000000\n./gen -type palindrome -maxN 999999999\n\n./gen -type repeat_digit -maxN 10\n./gen -type repeat_digit -maxN 100\n./gen -type repeat_digit -maxN 1000\n./gen -type repeat_digit -maxN 1000000\n./gen -type repeat_digit -maxN 999999999\n\n./gen -type alternating -maxN 10\n./gen -type alternating -maxN 100\n./gen -type alternating -maxN 1000\n./gen -type alternating -maxN 1000000\n./gen -type alternating -maxN 999999999\n\n./gen -type ascending -maxN 999999999\n./gen -type descending -maxN 999999999\n./gen -type all_digits -maxN 999999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:37.887696",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "363/B",
      "title": "B. Забор",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных содержатся целые числа n и k (1 ≤ n ≤ 1.5·105, 1 ≤ k ≤ n) — количество досок в заборе и ширина проема для рояля. Вторая строка содержит последовательность целых чисел h1, h2, ..., hn (1 ≤ hi ≤ 100), где hi — высота i-ой доски забора.",
      "output_spec": "Выходные данныеВыведите такое j, что сумма высот досок j, j + 1, ..., j + k - 1 — наименьшая возможная. Если таких j несколько, то выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать7 31 2 6 1 1 7 1Выходные данныеСкопировать3",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных содержатся целые числа n и k (1 ≤ n ≤ 1.5·105, 1 ≤ k ≤ n) — количество досок в заборе и ширина проема для рояля. Вторая строка содержит последовательность целых чисел h1, h2, ..., hn (1 ≤ hi ≤ 100), где hi — высота i-ой доски забора.\n\nВходные данные\n\nВыходные данныеВыведите такое j, что сумма высот досок j, j + 1, ..., j + k - 1 — наименьшая возможная. Если таких j несколько, то выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать7 31 2 6 1 1 7 1Выходные данныеСкопировать3\n\nВходные данныеСкопировать7 31 2 6 1 1 7 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ примере требуется найти три последовательные доски с минимальной суммой высот. В данном случае три доски с номерами 3, 4 и 5 обладают требуемым свойством и имеют суммарную высоту 8.",
      "solutions": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!I'm glad to announce that we again decided to introduce a round based on one of the programming olympiads for schoolchidren in Saratov. This time it is a round for participants from Division II. Round will start at unusual time for Codeforces: 12:00 MSK.The problems were prepared by MikeMirzayanov and me, while Fefer_Ivan and Gerald helped us with writing alternative solutions.Members of the first division can participate out of competition, as usual.Scoring distribution is standard: 500-1000-1500-2000-2500.UPD: tutorial can be found here.UPD 2: The model solution for problem E (unfortunately, there were only one model solution) was incorrect. But, the answers for all pretests were correct. After the round we fixed the solution. All submits for problem E were rejudged.UPD 3: Results are final, ratings are updated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 863
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, сообщество Codeforces!Рад Вам сообщить, что мы в очередной раз делаем раунд из задач одной из олимпиад для саратовских школьников. На этот раз — раунд для второго дивизиона. Раунд начнется в необычное для Codeforces время: 11 ноября в 12:00 MSKЗадачи были подготовлены MikeMirzayanov и мной, в написании альтернативных решений нам помогали Fefer_Ivan и Gerald.Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Разбалловка стандартная: 500-1000-1500-2000-2500.UPD: Опубликован разбор на английском.UPD 2: В задаче E изначальное авторское решение (оно, к сожалению, было одно) было неправильным. Однако, ответы ко всем претестам были корректные. После контеста авторское решение было исправлено, все решения по задаче E были перетестированы.UPD 3: Появились окончательные результаты, рейтинг обновлен.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 849
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces",
          "content": "363A - СоробанNot so much to say about this problem. You need to extract the digits of the given number (read it as string or repeteadly divide by 10 and take the remainders). Then carefully do the mapping of digits to its' representation.363B - ЗаборAnother easy problem. We need to calculate the sum of every consequtive segment of k planks. One way to do this is to calculate partial prefix sums: . Then the sum of heights of the planks i, i + 1, ..., i + k - 1 is si + k - 1 - si - 1. The other approach is to calculate the sum of the first k planks: h1 + h2 + ... + hk. By subtracting h1 and adding hk + 1 we get sum of k planks starting from the second plank. Then, by subtracting h2 and adding hk + 2 we get sum of k planks starting from the third plank, and so on.363C - Исправление опечатокThe general idea of the solution is the following: while there are three consequtive equal characters, remove any one of them. After that we can only have typos of the second type. So, if we have one couple of equal characters immediately after another couple of equal characters (xxyy), we need to decide which character to remove, x or y? Let's find the leftmost typo of the second type in the string. It is easy to see that we can always remove the character from the second couple.All these can be done in a single pass. Go through the characters of the given string and build the resulting string ans. Let's denote the current character as ch. If ch is equal to the last two characters of ans, skip ch. If ch is equal to the last character of ans and ans[length(ans) - 2] = ans[length(ans) - 3] (assume that ans is 1-indexed), skip ch. Otherwise, append ch to ans.363D - Прокат велосипедовLet's do a binary search over the number of boys that can rent a bike. So let's say that we want to check whether it possible for k boys to rent bikes. If some k boys can rent a bike, then the k \"richest\" boys (with the most amount of personal money) also can do that. It is easy to see that if they can rent bikes, they can rent k cheapest bikes (if we first sort the bikes in increasing order of price, it will be just the first k bikes).So, take k richest boys and try to match them with k cheapest bikes, spending as much common budget as possible. The following algorithm works (try to understand and prove it before asking questions): take the boy with least number of money (of course, among the considered k richest) and try to give him the cheapest bike. If the boy has ehough personal money to rent this bike, use his money to do this. Otherwise, use all his money and take some money from the common budget. Continue this process with the second cheapest bike and the second \"poorest among the richest\" boys. This process can end in two ways: we will either run out of budget and fail to rent k bikes, or we will successfully rent these bikes. 363E - Два кругаAt first, for each valid center cell (i, j) calculate circleSum[i][j] — sum of values inside the circle with center at (i, j). This can be done with the code like that: for (int i0 = r; i0 + r < n; i0++) {\n for (int j0 = r; j0 + r < m; j0++) {\n int sum = 0;\n int lj = j0, rj = j0;\n for (int i = i0 - r; i <= i0 + r; i++) {\n while (dist2(i0, j0, i, lj) > r * r) lj++;\n while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n while (dist2(i0, j0, i, rj) > r * r) rj--;\n while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n sum += rowSum[i][rj + 1] - rowSum[i][lj];\n }\n circleSum[i0][j0] = sum;\n }\n }This code iterates over all rows from top to bottom and keeps lj and rj — the leftmost and the rightmost columns in current row i that are inside the circle with center at (i0, j0). The function dist2 returns squared distance between two cells, rowSum[i][j] is equal to sum of first j cells in row i. In total, values lj and rj will be changed O(n + m) times, so the complexity of this part is O(nm(n + m)).In the second part of the solution, for each row i we calculate several values: leftMax[i][j] — maximum of circleSum[i][k] for k ≤ i cntLeftMax[i][j] — the number of corresponding maximum values rightMax[i][j] — maximum of circleSum[i][k] for k ≥ i cntRightMax[i][j] — the number of corresponding maximum values All these values can be calculated in O(nm) time.The third part of the solution is the most tricky one. Let's say that the cell (i, j) is boundary cell for the circle centered at (i0, j0) if it belongs to this circle and is the leftmost or the rightmost such point in row i. It is easy to see that two circles A and B intersect if and only if there exists a boundary cell of the circle A that belongs to the circle B. As long as we have O(n + m) boundary cells for each circle, checking whether two given circles intersect can be done in linear time. Now, for each pair (di, dj), which means the relative position of one center to the other, we can determine if such two circles intersect. There are O(nm) pairs (di, dj), so the total complexity of this part is O(nm(n + m)).And, finally, in the fourth part we are going to calculate the answer. Let's iterate over all triples of values (i0, j0, i), where (i0, j0) is a valid center cell and i is a row number. Consider the set of cells (i, j) in the row i such that the circle centered at (i, j) intersects with the circle at (i0, j0). It is clear that this set is consists of some (possibly zero) consequtive cells in a row. Let's assume that these cells are (i, lj), (i, lj + 1), ..., (i, rj), values lj and rj can be found in the third part of the solution. We are interested in cell that are not in this set: (i, j) with j < lj or j > rj. To find the maximum sum in such circles in O(1), we use arrays computed in the second part. Overall complexity of the solution is O(nm(n + m)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9537",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 363\\s*B"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 5",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 6",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 1",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 2",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 3",
          "code": "(x2, y1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 4",
          "code": "(x2, y1 + k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 5",
          "code": "(x2, r + 1 ... y1 - 1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 6",
          "code": "(x2, y1 + 1 + k ... n - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 7",
          "code": "a_1, a_2 ... a_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 8",
          "code": "b_1, b_2...b_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 9",
          "code": "a_i boy buys b_i bike",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 10",
          "code": "Case 1: if b_i <= a_i,  then a_i, a_j >= b_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 11",
          "code": "it is always better using a_j buy b_j as a_i can afford b_i by himself --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 12",
          "code": "Case 2: if b_i > a_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 13",
          "code": "no matter b_i > a_j or b_i <= a_j, swapping them won't able to make result better --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 14",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 15",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 16",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 17",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 100, \"h_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 100, \"h_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 100, \"h_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Checker for the problem: Given a sequence and a length k, find the starting index of k consecutive elements with minimal sum.\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and k from the input file\n    int n = inf.readInt();\n    int k = inf.readInt();\n\n    // Read the sequence h[1..n]\n    vector<int> h(n + 1); // 1-based indexing\n    vector<long long> prefix(n + 1, 0); // Prefix sums\n    for (int i = 1; i <= n; ++i) {\n        h[i] = inf.readInt();\n        prefix[i] = prefix[i - 1] + h[i];\n    }\n\n    // Compute the minimal sum of any k consecutive elements\n    long long minSum = LLONG_MAX;\n    for (int i = 1; i <= n - k + 1; ++i) {\n        long long sum = prefix[i + k - 1] - prefix[i - 1];\n        if (sum < minSum) {\n            minSum = sum;\n        }\n    }\n\n    // Read participant's output\n    int j = ouf.readInt(1, n - k + 1, \"j\");\n\n    // Compute the sum of the subsequence starting at position j\n    long long participantSum = prefix[j + k - 1] - prefix[j - 1];\n\n    // Check if the participant's sum matches the minimal sum\n    if (participantSum != minSum) {\n        quitf(_wa, \"Sum at position %d is %lld, but minimal sum is %lld\", j, participantSum, minSum);\n    } else {\n        quitf(_ok, \"Sum at position %d is minimal sum %lld\", j, participantSum);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n); // default to n\n    string type = opt<string>(\"type\", \"random\");\n    int minH = opt<int>(\"minH\", 1);\n    int maxH = opt<int>(\"maxH\", 100);\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 150000);\n    ensure(1 <= k && k <= n);\n    ensure(1 <= minH && minH <= maxH && maxH <= 100);\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(minH, maxH);\n    } else if (type == \"constant\") {\n        int val = minH; // Use minH as the constant value\n        for (int i = 0; i < n; ++i)\n            h[i] = val;\n    } else if (type == \"increasing\") {\n        int range = maxH - minH + 1;\n        for (int i = 0; i < n; ++i)\n            h[i] = minH + i % range;\n    } else if (type == \"decreasing\") {\n        int range = maxH - minH + 1;\n        for (int i = 0; i < n; ++i)\n            h[i] = maxH - i % range;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? minH : maxH;\n    } else if (type == \"multi_min\") {\n        // Create multiple intervals with the same minimal sum\n        for (int i = 0; i < n; ++i)\n            h[i] = maxH;\n        for (int i = 0; i + k <= n; i += k) {\n            for (int j = i; j < i + k; ++j)\n                h[j] = minH;\n        }\n    } else if (type == \"maxsum\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = maxH;\n    } else if (type == \"minsum\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = minH;\n    } else {\n        // Unknown type\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output h[1..n]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n); // default to n\n    string type = opt<string>(\"type\", \"random\");\n    int minH = opt<int>(\"minH\", 1);\n    int maxH = opt<int>(\"maxH\", 100);\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 150000);\n    ensure(1 <= k && k <= n);\n    ensure(1 <= minH && minH <= maxH && maxH <= 100);\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = rnd.next(minH, maxH);\n    } else if (type == \"constant\") {\n        int val = minH; // Use minH as the constant value\n        for (int i = 0; i < n; ++i)\n            h[i] = val;\n    } else if (type == \"increasing\") {\n        int range = maxH - minH + 1;\n        for (int i = 0; i < n; ++i)\n            h[i] = minH + i % range;\n    } else if (type == \"decreasing\") {\n        int range = maxH - minH + 1;\n        for (int i = 0; i < n; ++i)\n            h[i] = maxH - i % range;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = (i % 2 == 0) ? minH : maxH;\n    } else if (type == \"multi_min\") {\n        // Create multiple intervals with the same minimal sum\n        for (int i = 0; i < n; ++i)\n            h[i] = maxH;\n        for (int i = 0; i + k <= n; i += k) {\n            for (int j = i; j < i + k; ++j)\n                h[j] = minH;\n        }\n    } else if (type == \"maxsum\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = maxH;\n    } else if (type == \"minsum\") {\n        for (int i = 0; i < n; ++i)\n            h[i] = minH;\n    } else {\n        // Unknown type\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output h[1..n]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random h_i\n./gen -n 1 -k 1 -type random\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 2 -type random\n\n# k = n\n./gen -n 1000 -k 1000 -type random\n./gen -n 150000 -k 150000 -type random\n\n# k = 1\n./gen -n 1000 -k 1 -type random\n./gen -n 150000 -k 1 -type random\n\n# k = n / 2\n./gen -n 10 -k 5 -type random\n./gen -n 1000 -k 500 -type random\n./gen -n 150000 -k 75000 -type random\n\n# All h_i are minimum\n./gen -n 1000 -k 500 -type minsum -minH 1\n./gen -n 150000 -k 75000 -type minsum -minH 1\n\n# All h_i are maximum\n./gen -n 1000 -k 500 -type maxsum -maxH 100\n./gen -n 150000 -k 75000 -type maxsum -maxH 100\n\n# h_i increasing\n./gen -n 1000 -k 500 -type increasing -minH 1 -maxH 100\n./gen -n 150000 -k 75000 -type increasing -minH 1 -maxH 100\n\n# h_i decreasing\n./gen -n 1000 -k 500 -type decreasing -minH 1 -maxH 100\n./gen -n 150000 -k 75000 -type decreasing -minH 1 -maxH 100\n\n# h_i alternating\n./gen -n 1000 -k 500 -type alternating -minH 1 -maxH 100\n./gen -n 150000 -k 75000 -type alternating -minH 1 -maxH 100\n\n# h_i random in small range\n./gen -n 1000 -k 500 -type random -minH 50 -maxH 51\n./gen -n 150000 -k 75000 -type random -minH 50 -maxH 51\n\n# h_i random in full range\n./gen -n 1000 -k 500 -type random -minH 1 -maxH 100\n./gen -n 150000 -k 75000 -type random -minH 1 -maxH 100\n\n# Multiple minimal sums\n./gen -n 1000 -k 10 -type multi_min -minH 1 -maxH 100\n./gen -n 150000 -k 1000 -type multi_min -minH 1 -maxH 100\n\n# Extreme case: n = 1\n./gen -n 1 -k 1 -type random -minH 1 -maxH 100\n\n# Extreme case: k = n = 1\n./gen -n 1 -k 1 -type constant -minH 50 -maxH 50\n\n# Edge case: n = max, k = 1\n./gen -n 150000 -k 1 -type random -minH 1 -maxH 100\n\n# Edge case: n = max, k = n\n./gen -n 150000 -k 150000 -type random -minH 1 -maxH 100\n\n# Edge case: Prime n and k\n./gen -n 99991 -k 9973 -type random -minH 1 -maxH 100\n\n# Edge case: k larger than n / 2\n./gen -n 1000 -k 900 -type random -minH 1 -maxH 100\n\n# Edge case: k small compared to n\n./gen -n 150000 -k 2 -type random -minH 1 -maxH 100\n\n# Edge case: k = 1\n./gen -n 1000 -k 1 -type random -minH 1 -maxH 100\n\n# Edge case: k = n - 1\n./gen -n 1000 -k 999 -type random -minH 1 -maxH 100\n\n# All h_i = 1\n./gen -n 10000 -k 5000 -type constant -minH 1 -maxH 1\n\n# All h_i = 100\n./gen -n 10000 -k 5000 -type constant -minH 100 -maxH 100\n\n# h_i random with minH = maxH\n./gen -n 1000 -k 500 -type random -minH 42 -maxH 42\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:39.632020",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "363/C",
      "title": "C. Исправление опечаток",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных записано слово s длиной от 1 до 200000 символов. Заданное слово s состоит из строчных букв латинского алфавита.",
      "output_spec": "Выходные данныеВыведите такое слово t, которое не содержит описанных в условии задачи опечаток и получено из s удалением наименьшего количества букв.Если решений несколько, выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопироватьhellooВыходные данныеСкопироватьhelloВходные данныеСкопироватьwoooooowВыходные данныеСкопироватьwoow",
      "description": "C. Исправление опечаток\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных записано слово s длиной от 1 до 200000 символов. Заданное слово s состоит из строчных букв латинского алфавита.\n\nВходные данные\n\nВыходные данныеВыведите такое слово t, которое не содержит описанных в условии задачи опечаток и получено из s удалением наименьшего количества букв.Если решений несколько, выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопироватьhellooВыходные данныеСкопироватьhelloВходные данныеСкопироватьwoooooowВыходные данныеСкопироватьwoow\n\nВходные данныеСкопироватьhelloo\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьhello\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьwoooooow\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьwoow\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВторым допустимым ответом на тест из условия является вывод «heloo».",
      "solutions": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!I'm glad to announce that we again decided to introduce a round based on one of the programming olympiads for schoolchidren in Saratov. This time it is a round for participants from Division II. Round will start at unusual time for Codeforces: 12:00 MSK.The problems were prepared by MikeMirzayanov and me, while Fefer_Ivan and Gerald helped us with writing alternative solutions.Members of the first division can participate out of competition, as usual.Scoring distribution is standard: 500-1000-1500-2000-2500.UPD: tutorial can be found here.UPD 2: The model solution for problem E (unfortunately, there were only one model solution) was incorrect. But, the answers for all pretests were correct. After the round we fixed the solution. All submits for problem E were rejudged.UPD 3: Results are final, ratings are updated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 863
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, сообщество Codeforces!Рад Вам сообщить, что мы в очередной раз делаем раунд из задач одной из олимпиад для саратовских школьников. На этот раз — раунд для второго дивизиона. Раунд начнется в необычное для Codeforces время: 11 ноября в 12:00 MSKЗадачи были подготовлены MikeMirzayanov и мной, в написании альтернативных решений нам помогали Fefer_Ivan и Gerald.Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Разбалловка стандартная: 500-1000-1500-2000-2500.UPD: Опубликован разбор на английском.UPD 2: В задаче E изначальное авторское решение (оно, к сожалению, было одно) было неправильным. Однако, ответы ко всем претестам были корректные. После контеста авторское решение было исправлено, все решения по задаче E были перетестированы.UPD 3: Появились окончательные результаты, рейтинг обновлен.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 849
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces",
          "content": "363A - СоробанNot so much to say about this problem. You need to extract the digits of the given number (read it as string or repeteadly divide by 10 and take the remainders). Then carefully do the mapping of digits to its' representation.363B - ЗаборAnother easy problem. We need to calculate the sum of every consequtive segment of k planks. One way to do this is to calculate partial prefix sums: . Then the sum of heights of the planks i, i + 1, ..., i + k - 1 is si + k - 1 - si - 1. The other approach is to calculate the sum of the first k planks: h1 + h2 + ... + hk. By subtracting h1 and adding hk + 1 we get sum of k planks starting from the second plank. Then, by subtracting h2 and adding hk + 2 we get sum of k planks starting from the third plank, and so on.363C - Исправление опечатокThe general idea of the solution is the following: while there are three consequtive equal characters, remove any one of them. After that we can only have typos of the second type. So, if we have one couple of equal characters immediately after another couple of equal characters (xxyy), we need to decide which character to remove, x or y? Let's find the leftmost typo of the second type in the string. It is easy to see that we can always remove the character from the second couple.All these can be done in a single pass. Go through the characters of the given string and build the resulting string ans. Let's denote the current character as ch. If ch is equal to the last two characters of ans, skip ch. If ch is equal to the last character of ans and ans[length(ans) - 2] = ans[length(ans) - 3] (assume that ans is 1-indexed), skip ch. Otherwise, append ch to ans.363D - Прокат велосипедовLet's do a binary search over the number of boys that can rent a bike. So let's say that we want to check whether it possible for k boys to rent bikes. If some k boys can rent a bike, then the k \"richest\" boys (with the most amount of personal money) also can do that. It is easy to see that if they can rent bikes, they can rent k cheapest bikes (if we first sort the bikes in increasing order of price, it will be just the first k bikes).So, take k richest boys and try to match them with k cheapest bikes, spending as much common budget as possible. The following algorithm works (try to understand and prove it before asking questions): take the boy with least number of money (of course, among the considered k richest) and try to give him the cheapest bike. If the boy has ehough personal money to rent this bike, use his money to do this. Otherwise, use all his money and take some money from the common budget. Continue this process with the second cheapest bike and the second \"poorest among the richest\" boys. This process can end in two ways: we will either run out of budget and fail to rent k bikes, or we will successfully rent these bikes. 363E - Два кругаAt first, for each valid center cell (i, j) calculate circleSum[i][j] — sum of values inside the circle with center at (i, j). This can be done with the code like that: for (int i0 = r; i0 + r < n; i0++) {\n for (int j0 = r; j0 + r < m; j0++) {\n int sum = 0;\n int lj = j0, rj = j0;\n for (int i = i0 - r; i <= i0 + r; i++) {\n while (dist2(i0, j0, i, lj) > r * r) lj++;\n while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n while (dist2(i0, j0, i, rj) > r * r) rj--;\n while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n sum += rowSum[i][rj + 1] - rowSum[i][lj];\n }\n circleSum[i0][j0] = sum;\n }\n }This code iterates over all rows from top to bottom and keeps lj and rj — the leftmost and the rightmost columns in current row i that are inside the circle with center at (i0, j0). The function dist2 returns squared distance between two cells, rowSum[i][j] is equal to sum of first j cells in row i. In total, values lj and rj will be changed O(n + m) times, so the complexity of this part is O(nm(n + m)).In the second part of the solution, for each row i we calculate several values: leftMax[i][j] — maximum of circleSum[i][k] for k ≤ i cntLeftMax[i][j] — the number of corresponding maximum values rightMax[i][j] — maximum of circleSum[i][k] for k ≥ i cntRightMax[i][j] — the number of corresponding maximum values All these values can be calculated in O(nm) time.The third part of the solution is the most tricky one. Let's say that the cell (i, j) is boundary cell for the circle centered at (i0, j0) if it belongs to this circle and is the leftmost or the rightmost such point in row i. It is easy to see that two circles A and B intersect if and only if there exists a boundary cell of the circle A that belongs to the circle B. As long as we have O(n + m) boundary cells for each circle, checking whether two given circles intersect can be done in linear time. Now, for each pair (di, dj), which means the relative position of one center to the other, we can determine if such two circles intersect. There are O(nm) pairs (di, dj), so the total complexity of this part is O(nm(n + m)).And, finally, in the fourth part we are going to calculate the answer. Let's iterate over all triples of values (i0, j0, i), where (i0, j0) is a valid center cell and i is a row number. Consider the set of cells (i, j) in the row i such that the circle centered at (i, j) intersects with the circle at (i0, j0). It is clear that this set is consists of some (possibly zero) consequtive cells in a row. Let's assume that these cells are (i, lj), (i, lj + 1), ..., (i, rj), values lj and rj can be found in the third part of the solution. We are interested in cell that are not in this set: (i, j) with j < lj or j > rj. To find the maximum sum in such circles in O(1), we use arrays computed in the second part. Overall complexity of the solution is O(nm(n + m)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9537",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 363\\s*C"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 5",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 6",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 1",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 2",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 3",
          "code": "(x2, y1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 4",
          "code": "(x2, y1 + k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 5",
          "code": "(x2, r + 1 ... y1 - 1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 6",
          "code": "(x2, y1 + 1 + k ... n - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 7",
          "code": "a_1, a_2 ... a_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 8",
          "code": "b_1, b_2...b_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 9",
          "code": "a_i boy buys b_i bike",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 10",
          "code": "Case 1: if b_i <= a_i,  then a_i, a_j >= b_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 11",
          "code": "it is always better using a_j buy b_j as a_i can afford b_i by himself --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 12",
          "code": "Case 2: if b_i > a_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 13",
          "code": "no matter b_i > a_j or b_i <= a_j, swapping them won't able to make result better --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 14",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 15",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 16",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 17",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 200000, \"Length of s must be between 1 and 200000, but is %d\", (int)s.length());\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"All characters in s must be lowercase English letters\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 200000, \"Length of s must be between 1 and 200000, but is %d\", (int)s.length());\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"All characters in s must be lowercase English letters\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 200000, \"Length of s must be between 1 and 200000, but is %d\", (int)s.length());\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"All characters in s must be lowercase English letters\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring fix(string s) {\n    string res;\n    for (char c : s) {\n        res.push_back(c);\n        int len = res.size();\n        if (len >= 3 && res[len - 1] == res[len - 2] && res[len - 2] == res[len - 3]) {\n            res.pop_back();\n        } else if (len >= 4 && res[len - 1] == res[len - 2] && res[len - 3] == res[len - 4] && res[len - 2] != res[len - 3]) {\n            res.pop_back();\n        }\n    }\n    return res;\n}\n\nbool isSubsequence(const string& s, const string& t) {\n    int n = s.size(), m = t.size();\n    int j = 0;\n    for (int i = 0; i < n && j < m; ++i) {\n        if (s[i] == t[j]) ++j;\n    }\n    return j == m;\n}\n\nbool hasTypos(const string& t) {\n    int len = t.size();\n    for (int i = 0; i < len; ++i) {\n        if (i >= 2 && t[i] == t[i - 1] && t[i - 1] == t[i - 2]) {\n            return true;\n        }\n        if (i >= 3 && t[i] == t[i - 1] && t[i - 2] == t[i - 3] && t[i - 1] != t[i - 2]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    string s = inf.readLine();\n    string t = ouf.readLine();\n\n    if (t.empty()) {\n        quitf(_wa, \"Contestant's output is empty\");\n    }\n\n    string t_max = fix(s);\n\n    if (t.size() != t_max.size()) {\n        quitf(_wa, \"Your correction is not minimal, expected length %d, found %d\", (int)t_max.size(), (int)t.size());\n    }\n\n    if (!isSubsequence(s, t)) {\n        quitf(_wa, \"Your output word is not a subsequence of the input word\");\n    }\n\n    if (hasTypos(t)) {\n        quitf(_wa, \"Your output word still contains typos\");\n    }\n\n    quitf(_ok, \"Correct word of length %d\", (int)t.size());\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n\n    if(n == -1) {\n        // Error, n is required\n        cerr << \"Parameter n is required.\" << endl;\n        return 1;\n    }\n\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if(type == \"random\") {\n        // Generate a random string of length n, letters from 'a' to 'z'\n\n        s = \"\";\n\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n\n    } else if(type == \"no_typos\") {\n        // Generate a random string of length n that contains no typos.\n\n        s = \"\";\n        char prev1 = 0, prev2 = 0;\n\n        for(int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = rnd.next('a', 'z');\n            } while ((i >= 2 && s[i-1] == s[i-2] && s[i-2] == c) ||\n                     (i >= 3 && s[i-3] == s[i-2] && s[i-1] == c));\n\n            s += c;\n        }\n\n    } else if(type == \"maximal_typos\") {\n        // Generate a string of length n containing maximal typos.\n\n        s = \"\";\n        int i = 0;\n\n        while (i < n) {\n            if (n - i >= 4) {\n                // Add 'aabb' pattern\n                char c = rnd.next('a', 'z');\n                char d;\n                do {\n                    d = rnd.next('a', 'z');\n                } while (d == c);\n                s += c; s += c; s += d; s += d;\n                i += 4;\n            } else if (n - i >= 3) {\n                // Add 'aaa' pattern\n                char c = rnd.next('a', 'z');\n                s += c; s += c; s += c;\n                i += 3;\n            } else {\n                // Fill the rest with random letters\n                s += rnd.next('a', 'z');\n                i += 1;\n            }\n        }\n\n    } else if(type == \"typo_triple\") {\n        // Generate a string with many triple repeats (aaa, bbb, etc.)\n\n        s = \"\";\n        for(int i = 0; i + 2 < n; i += 3) {\n            char c = rnd.next('a', 'z');\n            s += c; s += c; s += c;\n        }\n\n        // Fill the rest\n        while((int)s.length() < n) {\n            s += rnd.next('a', 'z');\n        }\n\n    } else if(type == \"typo_pairs\") {\n        // Generate a string with many pairs of identical letters followed by another pair\n\n        s = \"\";\n        for(int i = 0; i + 3 < n; i += 4) {\n            char c = rnd.next('a', 'z');\n            char d;\n            do {\n                d = rnd.next('a', 'z');\n            } while(d == c);\n            s += c; s += c; s += d; s += d;\n        }\n\n        // Fill the rest\n        while((int)s.length() < n) {\n            s += rnd.next('a', 'z');\n        }\n\n    } else if(type == \"overlap_typos\") {\n        // Generate overlapping typos\n\n        s = \"\";\n\n        // For example: aaabaaabaaa\n\n        char c = rnd.next('a', 'z');\n        int i = 0;\n        while(i < n) {\n            if(n - i >= 3) {\n                s += c; s += c; s += c;\n                i += 3;\n            } else {\n                s += c;\n                i += 1;\n            }\n        }\n\n    } else if(type == \"alternating\") {\n        // Alternate between two letters, possibly introducing typos\n\n        s = \"\";\n        char c1 = rnd.next('a', 'z');\n        char c2;\n        do {\n            c2 = rnd.next('a', 'z');\n        } while(c2 == c1);\n\n        for(int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n\n    } else if(type == \"single_letter\") {\n        // Generate a string with a single letter repeated\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n\n    } else if(type == \"max_characters\") {\n        // Use 'a's to maximize repeated letters\n\n        s = string(n, 'a');\n\n    } else if(type == \"typo_at_start\") {\n        // Generate a string with a typo at the start\n\n        s = \"\";\n\n        if(n >= 3) {\n            char c = rnd.next('a', 'z');\n            s += c; s += c; s += c;\n            for(int i = 3; i < n; ++i)\n                s += rnd.next('a', 'z');\n        } else {\n            for(int i = 0; i < n; ++i)\n                s += rnd.next('a', 'z');\n        }\n\n    } else if(type == \"typo_at_end\") {\n        // Generate a string with a typo at the end\n\n        s = \"\";\n\n        for(int i = 0; i < n - 3; ++i)\n            s += rnd.next('a', 'z');\n\n        if(n >= 3) {\n            char c = rnd.next('a', 'z');\n            s += c; s += c; s += c;\n        } else {\n            for(int i = (int)s.length(); i < n; ++i)\n                s += rnd.next('a', 'z');\n        }\n\n    } else {\n        // Default to random\n        s = \"\";\n\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    }\n\n    // Output the generated string\n\n    printf(\"%s\\n\", s.c_str());\n\n    // Optional: If needed, we can check that s.length() == n\n    if((int)s.length() != n) {\n        cerr << \"Generated string length mismatch: expected \" << n << \", got \" << s.length() << endl;\n        return 1;\n    }\n\n    // Also make sure that s only contains lowercase letters 'a'-'z'\n    for(char c : s) {\n        if(c < 'a' || c > 'z') {\n            cerr << \"Generated string contains invalid character: \" << c << endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n\n    if(n == -1) {\n        // Error, n is required\n        cerr << \"Parameter n is required.\" << endl;\n        return 1;\n    }\n\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if(type == \"random\") {\n        // Generate a random string of length n, letters from 'a' to 'z'\n\n        s = \"\";\n\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n\n    } else if(type == \"no_typos\") {\n        // Generate a random string of length n that contains no typos.\n\n        s = \"\";\n        char prev1 = 0, prev2 = 0;\n\n        for(int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = rnd.next('a', 'z');\n            } while ((i >= 2 && s[i-1] == s[i-2] && s[i-2] == c) ||\n                     (i >= 3 && s[i-3] == s[i-2] && s[i-1] == c));\n\n            s += c;\n        }\n\n    } else if(type == \"maximal_typos\") {\n        // Generate a string of length n containing maximal typos.\n\n        s = \"\";\n        int i = 0;\n\n        while (i < n) {\n            if (n - i >= 4) {\n                // Add 'aabb' pattern\n                char c = rnd.next('a', 'z');\n                char d;\n                do {\n                    d = rnd.next('a', 'z');\n                } while (d == c);\n                s += c; s += c; s += d; s += d;\n                i += 4;\n            } else if (n - i >= 3) {\n                // Add 'aaa' pattern\n                char c = rnd.next('a', 'z');\n                s += c; s += c; s += c;\n                i += 3;\n            } else {\n                // Fill the rest with random letters\n                s += rnd.next('a', 'z');\n                i += 1;\n            }\n        }\n\n    } else if(type == \"typo_triple\") {\n        // Generate a string with many triple repeats (aaa, bbb, etc.)\n\n        s = \"\";\n        for(int i = 0; i + 2 < n; i += 3) {\n            char c = rnd.next('a', 'z');\n            s += c; s += c; s += c;\n        }\n\n        // Fill the rest\n        while((int)s.length() < n) {\n            s += rnd.next('a', 'z');\n        }\n\n    } else if(type == \"typo_pairs\") {\n        // Generate a string with many pairs of identical letters followed by another pair\n\n        s = \"\";\n        for(int i = 0; i + 3 < n; i += 4) {\n            char c = rnd.next('a', 'z');\n            char d;\n            do {\n                d = rnd.next('a', 'z');\n            } while(d == c);\n            s += c; s += c; s += d; s += d;\n        }\n\n        // Fill the rest\n        while((int)s.length() < n) {\n            s += rnd.next('a', 'z');\n        }\n\n    } else if(type == \"overlap_typos\") {\n        // Generate overlapping typos\n\n        s = \"\";\n\n        // For example: aaabaaabaaa\n\n        char c = rnd.next('a', 'z');\n        int i = 0;\n        while(i < n) {\n            if(n - i >= 3) {\n                s += c; s += c; s += c;\n                i += 3;\n            } else {\n                s += c;\n                i += 1;\n            }\n        }\n\n    } else if(type == \"alternating\") {\n        // Alternate between two letters, possibly introducing typos\n\n        s = \"\";\n        char c1 = rnd.next('a', 'z');\n        char c2;\n        do {\n            c2 = rnd.next('a', 'z');\n        } while(c2 == c1);\n\n        for(int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n\n    } else if(type == \"single_letter\") {\n        // Generate a string with a single letter repeated\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n\n    } else if(type == \"max_characters\") {\n        // Use 'a's to maximize repeated letters\n\n        s = string(n, 'a');\n\n    } else if(type == \"typo_at_start\") {\n        // Generate a string with a typo at the start\n\n        s = \"\";\n\n        if(n >= 3) {\n            char c = rnd.next('a', 'z');\n            s += c; s += c; s += c;\n            for(int i = 3; i < n; ++i)\n                s += rnd.next('a', 'z');\n        } else {\n            for(int i = 0; i < n; ++i)\n                s += rnd.next('a', 'z');\n        }\n\n    } else if(type == \"typo_at_end\") {\n        // Generate a string with a typo at the end\n\n        s = \"\";\n\n        for(int i = 0; i < n - 3; ++i)\n            s += rnd.next('a', 'z');\n\n        if(n >= 3) {\n            char c = rnd.next('a', 'z');\n            s += c; s += c; s += c;\n        } else {\n            for(int i = (int)s.length(); i < n; ++i)\n                s += rnd.next('a', 'z');\n        }\n\n    } else {\n        // Default to random\n        s = \"\";\n\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    }\n\n    // Output the generated string\n\n    printf(\"%s\\n\", s.c_str());\n\n    // Optional: If needed, we can check that s.length() == n\n    if((int)s.length() != n) {\n        cerr << \"Generated string length mismatch: expected \" << n << \", got \" << s.length() << endl;\n        return 1;\n    }\n\n    // Also make sure that s only contains lowercase letters 'a'-'z'\n    for(char c : s) {\n        if(c < 'a' || c > 'z') {\n            cerr << \"Generated string contains invalid character: \" << c << endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type no_typos\n./gen -n 1 -type maximal_typos\n./gen -n 2 -type random\n./gen -n 2 -type typo_triple\n./gen -n 2 -type typo_pairs\n./gen -n 3 -type typo_triple\n./gen -n 3 -type typo_at_start\n./gen -n 3 -type typo_at_end\n./gen -n 10 -type random\n./gen -n 10 -type no_typos\n./gen -n 10 -type maximal_typos\n./gen -n 10 -type overlap_typos\n./gen -n 50 -type typo_triple\n./gen -n 50 -type typo_pairs\n./gen -n 100 -type random\n./gen -n 100 -type no_typos\n./gen -n 100 -type maximal_typos\n./gen -n 100 -type single_letter\n./gen -n 200000 -type random\n./gen -n 200000 -type no_typos\n./gen -n 200000 -type maximal_typos\n./gen -n 200000 -type typo_triple\n./gen -n 200000 -type typo_pairs\n./gen -n 200000 -type overlap_typos\n./gen -n 200000 -type single_letter\n./gen -n 200000 -type max_characters\n./gen -n 200000 -type alternating\n./gen -n 200000 -type typo_at_start\n./gen -n 200000 -type typo_at_end\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:41.363587",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "363/D",
      "title": "D. Прокат велосипедов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны три целых числа n, m и a (1 ≤ n, m ≤ 105; 0 ≤ a ≤ 109). Вторая строка содержит последовательность целых чисел b1, b2, ..., bn (1 ≤ bi ≤ 104), где bi — количество личных денег у i-го школьника. Третья строка содержит последовательность целых чисел p1, p2, ..., pm (1 ≤ pj ≤ 109), где pj — стоимость проката j-го велосипеда.",
      "output_spec": "Выходные данныеВыведите два целых числа r и s, где r — максимальное количество школьников, которые смогут взять напрокат велосипед, а s — минимальный суммарный расход личных денег для аренды r велосипедов. Если школьники не могут взять напрокат ни одного велосипеда, то r = s = 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 105 57 6Выходные данныеСкопировать2 3Входные данныеСкопировать4 5 28 1 1 26 3 7 5 2Выходные данныеСкопировать3 8",
      "description": "D. Прокат велосипедов\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записаны три целых числа n, m и a (1 ≤ n, m ≤ 105; 0 ≤ a ≤ 109). Вторая строка содержит последовательность целых чисел b1, b2, ..., bn (1 ≤ bi ≤ 104), где bi — количество личных денег у i-го школьника. Третья строка содержит последовательность целых чисел p1, p2, ..., pm (1 ≤ pj ≤ 109), где pj — стоимость проката j-го велосипеда.\n\nВходные данные\n\nВыходные данныеВыведите два целых числа r и s, где r — максимальное количество школьников, которые смогут взять напрокат велосипед, а s — минимальный суммарный расход личных денег для аренды r велосипедов. Если школьники не могут взять напрокат ни одного велосипеда, то r = s = 0.\n\nВыходные данные\n\nВходные данныеСкопировать2 2 105 57 6Выходные данныеСкопировать2 3Входные данныеСкопировать4 5 28 1 1 26 3 7 5 2Выходные данныеСкопировать3 8\n\nВходные данныеСкопировать2 2 105 57 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 5 28 1 1 26 3 7 5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере оба школьника могут взять напрокат велосипед. Например, они могут поделить общий бюджет пополам (по 5 рублей каждому). В этом случае одному из них придется доплатить 1 рубль из личных средств, а другому — 2 рубля. В сумме из личных средств будет потрачено 3 рубля. Такой вариант траты денег минимизирует расход личных средств.",
      "solutions": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!I'm glad to announce that we again decided to introduce a round based on one of the programming olympiads for schoolchidren in Saratov. This time it is a round for participants from Division II. Round will start at unusual time for Codeforces: 12:00 MSK.The problems were prepared by MikeMirzayanov and me, while Fefer_Ivan and Gerald helped us with writing alternative solutions.Members of the first division can participate out of competition, as usual.Scoring distribution is standard: 500-1000-1500-2000-2500.UPD: tutorial can be found here.UPD 2: The model solution for problem E (unfortunately, there were only one model solution) was incorrect. But, the answers for all pretests were correct. After the round we fixed the solution. All submits for problem E were rejudged.UPD 3: Results are final, ratings are updated.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9533?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 863
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, сообщество Codeforces!Рад Вам сообщить, что мы в очередной раз делаем раунд из задач одной из олимпиад для саратовских школьников. На этот раз — раунд для второго дивизиона. Раунд начнется в необычное для Codeforces время: 11 ноября в 12:00 MSKЗадачи были подготовлены MikeMirzayanov и мной, в написании альтернативных решений нам помогали Fefer_Ivan и Gerald.Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Разбалловка стандартная: 500-1000-1500-2000-2500.UPD: Опубликован разбор на английском.UPD 2: В задаче E изначальное авторское решение (оно, к сожалению, было одно) было неправильным. Однако, ответы ко всем претестам были корректные. После контеста авторское решение было исправлено, все решения по задаче E были перетестированы.UPD 3: Появились окончательные результаты, рейтинг обновлен.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9533?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 849
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces",
          "content": "363A - СоробанNot so much to say about this problem. You need to extract the digits of the given number (read it as string or repeteadly divide by 10 and take the remainders). Then carefully do the mapping of digits to its' representation.363B - ЗаборAnother easy problem. We need to calculate the sum of every consequtive segment of k planks. One way to do this is to calculate partial prefix sums: . Then the sum of heights of the planks i, i + 1, ..., i + k - 1 is si + k - 1 - si - 1. The other approach is to calculate the sum of the first k planks: h1 + h2 + ... + hk. By subtracting h1 and adding hk + 1 we get sum of k planks starting from the second plank. Then, by subtracting h2 and adding hk + 2 we get sum of k planks starting from the third plank, and so on.363C - Исправление опечатокThe general idea of the solution is the following: while there are three consequtive equal characters, remove any one of them. After that we can only have typos of the second type. So, if we have one couple of equal characters immediately after another couple of equal characters (xxyy), we need to decide which character to remove, x or y? Let's find the leftmost typo of the second type in the string. It is easy to see that we can always remove the character from the second couple.All these can be done in a single pass. Go through the characters of the given string and build the resulting string ans. Let's denote the current character as ch. If ch is equal to the last two characters of ans, skip ch. If ch is equal to the last character of ans and ans[length(ans) - 2] = ans[length(ans) - 3] (assume that ans is 1-indexed), skip ch. Otherwise, append ch to ans.363D - Прокат велосипедовLet's do a binary search over the number of boys that can rent a bike. So let's say that we want to check whether it possible for k boys to rent bikes. If some k boys can rent a bike, then the k \"richest\" boys (with the most amount of personal money) also can do that. It is easy to see that if they can rent bikes, they can rent k cheapest bikes (if we first sort the bikes in increasing order of price, it will be just the first k bikes).So, take k richest boys and try to match them with k cheapest bikes, spending as much common budget as possible. The following algorithm works (try to understand and prove it before asking questions): take the boy with least number of money (of course, among the considered k richest) and try to give him the cheapest bike. If the boy has ehough personal money to rent this bike, use his money to do this. Otherwise, use all his money and take some money from the common budget. Continue this process with the second cheapest bike and the second \"poorest among the richest\" boys. This process can end in two ways: we will either run out of budget and fail to rent k bikes, or we will successfully rent these bikes. 363E - Два кругаAt first, for each valid center cell (i, j) calculate circleSum[i][j] — sum of values inside the circle with center at (i, j). This can be done with the code like that: for (int i0 = r; i0 + r < n; i0++) {\n for (int j0 = r; j0 + r < m; j0++) {\n int sum = 0;\n int lj = j0, rj = j0;\n for (int i = i0 - r; i <= i0 + r; i++) {\n while (dist2(i0, j0, i, lj) > r * r) lj++;\n while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n while (dist2(i0, j0, i, rj) > r * r) rj--;\n while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n sum += rowSum[i][rj + 1] - rowSum[i][lj];\n }\n circleSum[i0][j0] = sum;\n }\n }This code iterates over all rows from top to bottom and keeps lj and rj — the leftmost and the rightmost columns in current row i that are inside the circle with center at (i0, j0). The function dist2 returns squared distance between two cells, rowSum[i][j] is equal to sum of first j cells in row i. In total, values lj and rj will be changed O(n + m) times, so the complexity of this part is O(nm(n + m)).In the second part of the solution, for each row i we calculate several values: leftMax[i][j] — maximum of circleSum[i][k] for k ≤ i cntLeftMax[i][j] — the number of corresponding maximum values rightMax[i][j] — maximum of circleSum[i][k] for k ≥ i cntRightMax[i][j] — the number of corresponding maximum values All these values can be calculated in O(nm) time.The third part of the solution is the most tricky one. Let's say that the cell (i, j) is boundary cell for the circle centered at (i0, j0) if it belongs to this circle and is the leftmost or the rightmost such point in row i. It is easy to see that two circles A and B intersect if and only if there exists a boundary cell of the circle A that belongs to the circle B. As long as we have O(n + m) boundary cells for each circle, checking whether two given circles intersect can be done in linear time. Now, for each pair (di, dj), which means the relative position of one center to the other, we can determine if such two circles intersect. There are O(nm) pairs (di, dj), so the total complexity of this part is O(nm(n + m)).And, finally, in the fourth part we are going to calculate the answer. Let's iterate over all triples of values (i0, j0, i), where (i0, j0) is a valid center cell and i is a row number. Consider the set of cells (i, j) in the row i such that the circle centered at (i, j) intersects with the circle at (i0, j0). It is clear that this set is consists of some (possibly zero) consequtive cells in a row. Let's assume that these cells are (i, lj), (i, lj + 1), ..., (i, rj), values lj and rj can be found in the third part of the solution. We are interested in cell that are not in this set: (i, j) with j < lj or j > rj. To find the maximum sum in such circles in O(1), we use arrays computed in the second part. Overall complexity of the solution is O(nm(n + m)).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9537",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 363\\s*D"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 5",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 6",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 1",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 2",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 3",
          "code": "(x2, y1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 4",
          "code": "(x2, y1 + k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 5",
          "code": "(x2, r + 1 ... y1 - 1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 6",
          "code": "(x2, y1 + 1 + k ... n - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 7",
          "code": "a_1, a_2 ... a_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 8",
          "code": "b_1, b_2...b_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 9",
          "code": "a_i boy buys b_i bike",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 10",
          "code": "Case 1: if b_i <= a_i,  then a_i, a_j >= b_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 11",
          "code": "it is always better using a_j buy b_j as a_i can afford b_i by himself --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 12",
          "code": "Case 2: if b_i > a_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 13",
          "code": "no matter b_i > a_j or b_i <= a_j, swapping them won't able to make result better --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 14",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 15",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 16",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 17",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 1, 10000, \"bi\");\n    inf.readEoln();\n\n    vector<int> pj = inf.readInts(m, 1, 1000000000, \"pj\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 1, 10000, \"bi\");\n    inf.readEoln();\n\n    vector<int> pj = inf.readInts(m, 1, 1000000000, \"pj\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 1, 10000, \"bi\");\n    inf.readEoln();\n\n    vector<int> pj = inf.readInts(m, 1, 1000000000, \"pj\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> b(n);\n    vector<int> p(m);\n\n    if (type == \"random\") {\n        /* Randomly generate bi in [1, 1e4] */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        /* Randomly generate pj in [1, 1e9] */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n        /* 'a' is provided as an argument */\n    } else if (type == \"max_shared\") {\n        /* Set a = 1e9 */\n        a = 1000000000;\n        /* Generate bi randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        /* Generate pj randomly */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"a_zero\") {\n        /* Set a = 0 */\n        a = 0;\n        /* Generate bi randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        /* Generate pj randomly */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"bi_big\") {\n        /* Set bi = 1e4 */\n        for (int i = 0; i < n; ++i) {\n            b[i] = 10000;\n        }\n        /* Generate pj randomly */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"pj_big\") {\n        /* Set pj = 1e9 */\n        for (int i = 0; i < m; ++i) {\n            p[i] = 1000000000;\n        }\n        /* Generate bi randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"n_equals_m\") {\n        n = m;\n        /* Generate bi and pj randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"n_greater_m\") {\n        if (n <= m) n = m + 10;\n        /* Generate bi and pj randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"m_greater_n\") {\n        if (m <= n) m = n + 10;\n        /* Generate bi and pj randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"impossible\") {\n        /* Set bi and a such that no boy can rent any bike */\n        a = 0;\n        for (int i = 0; i < n; ++i) {\n            b[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = 1000000000;\n        }\n    } else if (type == \"exact_match\") {\n        /* Create a scenario where only certain boys can rent bikes */\n        int k = min(n, m);\n        for (int i = 0; i < n; ++i) {\n            if (i < k) b[i] = 10000;\n            else b[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            if (i < k) p[i] = 10000;\n            else p[i] = 1000000000;\n        }\n        a = 0;\n    } else {\n        /* Default: random */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    /* Output n, m, a */\n    printf(\"%d %d %d\\n\", n, m, a);\n    /* Output bi */\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n    /* Output pj */\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> b(n);\n    vector<int> p(m);\n\n    if (type == \"random\") {\n        /* Randomly generate bi in [1, 1e4] */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        /* Randomly generate pj in [1, 1e9] */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n        /* 'a' is provided as an argument */\n    } else if (type == \"max_shared\") {\n        /* Set a = 1e9 */\n        a = 1000000000;\n        /* Generate bi randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        /* Generate pj randomly */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"a_zero\") {\n        /* Set a = 0 */\n        a = 0;\n        /* Generate bi randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        /* Generate pj randomly */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"bi_big\") {\n        /* Set bi = 1e4 */\n        for (int i = 0; i < n; ++i) {\n            b[i] = 10000;\n        }\n        /* Generate pj randomly */\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"pj_big\") {\n        /* Set pj = 1e9 */\n        for (int i = 0; i < m; ++i) {\n            p[i] = 1000000000;\n        }\n        /* Generate bi randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"n_equals_m\") {\n        n = m;\n        /* Generate bi and pj randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"n_greater_m\") {\n        if (n <= m) n = m + 10;\n        /* Generate bi and pj randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"m_greater_n\") {\n        if (m <= n) m = n + 10;\n        /* Generate bi and pj randomly */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"impossible\") {\n        /* Set bi and a such that no boy can rent any bike */\n        a = 0;\n        for (int i = 0; i < n; ++i) {\n            b[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = 1000000000;\n        }\n    } else if (type == \"exact_match\") {\n        /* Create a scenario where only certain boys can rent bikes */\n        int k = min(n, m);\n        for (int i = 0; i < n; ++i) {\n            if (i < k) b[i] = 10000;\n            else b[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            if (i < k) p[i] = 10000;\n            else p[i] = 1000000000;\n        }\n        a = 0;\n    } else {\n        /* Default: random */\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    /* Output n, m, a */\n    printf(\"%d %d %d\\n\", n, m, a);\n    /* Output bi */\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n    /* Output pj */\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -a 10 -type small\n./gen -n 5 -m 5 -a 0 -type a_zero\n./gen -n 1000 -m 1000 -a 1000000000 -type max_shared\n./gen -n 100000 -m 100000 -a 500000000 -type random\n./gen -n 100000 -m 100000 -a 0 -type a_zero\n./gen -n 100000 -m 100000 -a 1000000000 -type max_shared\n./gen -n 100000 -m 50000 -a 1000000000 -type n_greater_m\n./gen -n 50000 -m 100000 -a 1000000000 -type m_greater_n\n./gen -n 100000 -m 100000 -a 1000000000 -type bi_big\n./gen -n 100000 -m 100000 -a 1000000000 -type pj_big\n./gen -n 10000 -m 10000 -a 500000000 -type exact_match\n./gen -n 100000 -m 100000 -a 0 -type impossible\n./gen -n 1 -m 1 -a 1 -type small\n./gen -n 2 -m 3 -a 10 -type small\n./gen -n 3 -m 2 -a 20 -type small\n./gen -n 50000 -m 50000 -a 0 -type random\n./gen -n 50000 -m 50000 -a 1 -type random\n./gen -n 100000 -m 100000 -a 1 -type random\n./gen -n 100000 -m 100000 -a 1000000000 -type random\n./gen -n 100000 -m 100000 -a 1000000000 -type n_equals_m\n./gen -n 100000 -m 100000 -a 1000000000 -type n_greater_m\n./gen -n 100000 -m 100000 -a 1000000000 -type m_greater_n\n./gen -n 1 -m 100000 -a 1000000000 -type m_greater_n\n./gen -n 100000 -m 1 -a 1000000000 -type n_greater_m\n./gen -n 100000 -m 100000 -a 500000000 -type random\n./gen -n 100000 -m 100000 -a 0 -type bi_big\n./gen -n 100000 -m 100000 -a 1000000000 -type pj_big\n./gen -n 100000 -m 100000 -a 500000000 -type exact_match\n./gen -n 50000 -m 50000 -a 250000000 -type exact_match\n./gen -n 100000 -m 100000 -a 0 -type exact_match\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:43.899083",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "363/E",
      "title": "E. Two Circles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and r (2 ≤ n, m ≤ 500, r ≥ 0). Each of the following n lines contains m integers from 1 to 1000 each — the elements of the table. The rows of the table are listed from top to bottom at the elements in the rows are listed from left to right. It is guaranteed that there is at least one circle of radius r, not going beyond the table limits.",
      "output_spec": "OutputPrint two integers — the maximum sum of numbers in the cells that are located into two non-intersecting circles and the number of pairs of non-intersecting circles with the maximum sum. If there isn't a single pair of non-intersecting circles, print 0 0.",
      "sample_tests": "ExamplesInputCopy2 2 01 22 4OutputCopy6 2InputCopy5 6 14 2 1 3 2 62 3 2 4 7 25 2 2 1 1 31 4 3 3 6 45 1 4 2 3 2OutputCopy34 3InputCopy3 3 11 2 34 5 67 8 9OutputCopy0 0",
      "description": "E. Two Circles\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and r (2 ≤ n, m ≤ 500, r ≥ 0). Each of the following n lines contains m integers from 1 to 1000 each — the elements of the table. The rows of the table are listed from top to bottom at the elements in the rows are listed from left to right. It is guaranteed that there is at least one circle of radius r, not going beyond the table limits.\n\nOutputPrint two integers — the maximum sum of numbers in the cells that are located into two non-intersecting circles and the number of pairs of non-intersecting circles with the maximum sum. If there isn't a single pair of non-intersecting circles, print 0 0.\n\nInputCopy2 2 01 22 4OutputCopy6 2InputCopy5 6 14 2 1 3 2 62 3 2 4 7 25 2 2 1 1 31 4 3 3 6 45 1 4 2 3 2OutputCopy34 3InputCopy3 3 11 2 34 5 67 8 9OutputCopy0 0\n\nInputCopy2 2 01 22 4\n\nOutputCopy6 2\n\nInputCopy5 6 14 2 1 3 2 62 3 2 4 7 25 2 2 1 1 31 4 3 3 6 45 1 4 2 3 2\n\nOutputCopy34 3\n\nInputCopy3 3 11 2 34 5 67 8 9\n\nOutputCopy0 0",
      "solutions": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!I'm glad to announce that we again decided to introduce a round based on one of the programming olympiads for schoolchidren in Saratov. This time it is a round for participants from Division II. Round will start at unusual time for Codeforces: 12:00 MSK.The problems were prepared by MikeMirzayanov and me, while Fefer_Ivan and Gerald helped us with writing alternative solutions.Members of the first division can participate out of competition, as usual.Scoring distribution is standard: 500-1000-1500-2000-2500.UPD: tutorial can be found here.UPD 2: The model solution for problem E (unfortunately, there were only one model solution) was incorrect. But, the answers for all pretests were correct. After the round we fixed the solution. All submits for problem E were rejudged.UPD 3: Results are final, ratings are updated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 863
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, сообщество Codeforces!Рад Вам сообщить, что мы в очередной раз делаем раунд из задач одной из олимпиад для саратовских школьников. На этот раз — раунд для второго дивизиона. Раунд начнется в необычное для Codeforces время: 11 ноября в 12:00 MSKЗадачи были подготовлены MikeMirzayanov и мной, в написании альтернативных решений нам помогали Fefer_Ivan и Gerald.Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Разбалловка стандартная: 500-1000-1500-2000-2500.UPD: Опубликован разбор на английском.UPD 2: В задаче E изначальное авторское решение (оно, к сожалению, было одно) было неправильным. Однако, ответы ко всем претестам были корректные. После контеста авторское решение было исправлено, все решения по задаче E были перетестированы.UPD 3: Появились окончательные результаты, рейтинг обновлен.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9533?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 849
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces",
          "content": "363A - СоробанNot so much to say about this problem. You need to extract the digits of the given number (read it as string or repeteadly divide by 10 and take the remainders). Then carefully do the mapping of digits to its' representation.363B - ЗаборAnother easy problem. We need to calculate the sum of every consequtive segment of k planks. One way to do this is to calculate partial prefix sums: . Then the sum of heights of the planks i, i + 1, ..., i + k - 1 is si + k - 1 - si - 1. The other approach is to calculate the sum of the first k planks: h1 + h2 + ... + hk. By subtracting h1 and adding hk + 1 we get sum of k planks starting from the second plank. Then, by subtracting h2 and adding hk + 2 we get sum of k planks starting from the third plank, and so on.363C - Исправление опечатокThe general idea of the solution is the following: while there are three consequtive equal characters, remove any one of them. After that we can only have typos of the second type. So, if we have one couple of equal characters immediately after another couple of equal characters (xxyy), we need to decide which character to remove, x or y? Let's find the leftmost typo of the second type in the string. It is easy to see that we can always remove the character from the second couple.All these can be done in a single pass. Go through the characters of the given string and build the resulting string ans. Let's denote the current character as ch. If ch is equal to the last two characters of ans, skip ch. If ch is equal to the last character of ans and ans[length(ans) - 2] = ans[length(ans) - 3] (assume that ans is 1-indexed), skip ch. Otherwise, append ch to ans.363D - Прокат велосипедовLet's do a binary search over the number of boys that can rent a bike. So let's say that we want to check whether it possible for k boys to rent bikes. If some k boys can rent a bike, then the k \"richest\" boys (with the most amount of personal money) also can do that. It is easy to see that if they can rent bikes, they can rent k cheapest bikes (if we first sort the bikes in increasing order of price, it will be just the first k bikes).So, take k richest boys and try to match them with k cheapest bikes, spending as much common budget as possible. The following algorithm works (try to understand and prove it before asking questions): take the boy with least number of money (of course, among the considered k richest) and try to give him the cheapest bike. If the boy has ehough personal money to rent this bike, use his money to do this. Otherwise, use all his money and take some money from the common budget. Continue this process with the second cheapest bike and the second \"poorest among the richest\" boys. This process can end in two ways: we will either run out of budget and fail to rent k bikes, or we will successfully rent these bikes. 363E - Два кругаAt first, for each valid center cell (i, j) calculate circleSum[i][j] — sum of values inside the circle with center at (i, j). This can be done with the code like that: for (int i0 = r; i0 + r < n; i0++) {\n for (int j0 = r; j0 + r < m; j0++) {\n int sum = 0;\n int lj = j0, rj = j0;\n for (int i = i0 - r; i <= i0 + r; i++) {\n while (dist2(i0, j0, i, lj) > r * r) lj++;\n while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n while (dist2(i0, j0, i, rj) > r * r) rj--;\n while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n sum += rowSum[i][rj + 1] - rowSum[i][lj];\n }\n circleSum[i0][j0] = sum;\n }\n }This code iterates over all rows from top to bottom and keeps lj and rj — the leftmost and the rightmost columns in current row i that are inside the circle with center at (i0, j0). The function dist2 returns squared distance between two cells, rowSum[i][j] is equal to sum of first j cells in row i. In total, values lj and rj will be changed O(n + m) times, so the complexity of this part is O(nm(n + m)).In the second part of the solution, for each row i we calculate several values: leftMax[i][j] — maximum of circleSum[i][k] for k ≤ i cntLeftMax[i][j] — the number of corresponding maximum values rightMax[i][j] — maximum of circleSum[i][k] for k ≥ i cntRightMax[i][j] — the number of corresponding maximum values All these values can be calculated in O(nm) time.The third part of the solution is the most tricky one. Let's say that the cell (i, j) is boundary cell for the circle centered at (i0, j0) if it belongs to this circle and is the leftmost or the rightmost such point in row i. It is easy to see that two circles A and B intersect if and only if there exists a boundary cell of the circle A that belongs to the circle B. As long as we have O(n + m) boundary cells for each circle, checking whether two given circles intersect can be done in linear time. Now, for each pair (di, dj), which means the relative position of one center to the other, we can determine if such two circles intersect. There are O(nm) pairs (di, dj), so the total complexity of this part is O(nm(n + m)).And, finally, in the fourth part we are going to calculate the answer. Let's iterate over all triples of values (i0, j0, i), where (i0, j0) is a valid center cell and i is a row number. Consider the set of cells (i, j) in the row i such that the circle centered at (i, j) intersects with the circle at (i0, j0). It is clear that this set is consists of some (possibly zero) consequtive cells in a row. Let's assume that these cells are (i, lj), (i, lj + 1), ..., (i, rj), values lj and rj can be found in the third part of the solution. We are interested in cell that are not in this set: (i, j) with j < lj or j > rj. To find the maximum sum in such circles in O(1), we use arrays computed in the second part. Overall complexity of the solution is O(nm(n + m)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9537",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 363\\s*E"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 1",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 2",
          "code": "t = t + s[i - 1] + s[i - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 3",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 4",
          "code": "t+=s[0];\nt+=s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 5",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211 (Div. 2) - Codeforces - Code 6",
          "code": "ans += s[0];\nans += s[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9533?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 1",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 2",
          "code": "for (int i0 = r; i0 + r < n; i0++) {\n            for (int j0 = r; j0 + r < m; j0++) {\n                int sum = 0;\n                int lj = j0, rj = j0;\n                for (int i = i0 - r; i <= i0 + r; i++) {\n                    while (dist2(i0, j0, i, lj) > r * r) lj++;\n                    while (dist2(i0, j0, i, lj - 1) <= r * r) lj--;\n                    while (dist2(i0, j0, i, rj) > r * r) rj--;\n                    while (dist2(i0, j0, i, rj + 1) <= r * r) rj++;\n                    sum += rowSum[i][rj + 1] - rowSum[i][lj];\n                }\n                circleSum[i0][j0] = sum;\n            }\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 3",
          "code": "(x2, y1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 4",
          "code": "(x2, y1 + k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 5",
          "code": "(x2, r + 1 ... y1 - 1 - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 6",
          "code": "(x2, y1 + 1 + k ... n - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 7",
          "code": "a_1, a_2 ... a_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 8",
          "code": "b_1, b_2...b_k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 9",
          "code": "a_i boy buys b_i bike",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 10",
          "code": "Case 1: if b_i <= a_i,  then a_i, a_j >= b_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 11",
          "code": "it is always better using a_j buy b_j as a_i can afford b_i by himself --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 12",
          "code": "Case 2: if b_i > a_i,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 13",
          "code": "no matter b_i > a_j or b_i <= a_j, swapping them won't able to make result better --> No swapping",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 14",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 15",
          "code": "3 3 10\n5 5 4\n7 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 16",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #211: tutorial - Codeforces - Code 17",
          "code": "n_sum = sum;\nwhile(end<n){\n        sum=sum-a[st]+a[end];\n        st++;\n        end++;\n        if(sum<n_sum){\n            n_sum=sum;\n            start=st;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9537",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(0, 500, \"r\");\n    inf.readEoln();\n\n    ensuref(2 * r + 1 <= n, \"No circle of radius r can fit in n rows: 2*r+1=%d > n=%d\", 2*r+1, n);\n    ensuref(2 * r + 1 <= m, \"No circle of radius r can fit in m columns: 2*r+1=%d > m=%d\", 2*r+1, m);\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 1, 1000);\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(0, 500, \"r\");\n    inf.readEoln();\n\n    ensuref(2 * r + 1 <= n, \"No circle of radius r can fit in n rows: 2*r+1=%d > n=%d\", 2*r+1, n);\n    ensuref(2 * r + 1 <= m, \"No circle of radius r can fit in m columns: 2*r+1=%d > m=%d\", 2*r+1, m);\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 1, 1000);\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(0, 500, \"r\");\n    inf.readEoln();\n\n    ensuref(2 * r + 1 <= n, \"No circle of radius r can fit in n rows: 2*r+1=%d > n=%d\", 2*r+1, n);\n    ensuref(2 * r + 1 <= m, \"No circle of radius r can fit in m columns: 2*r+1=%d > m=%d\", 2*r+1, m);\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 1, 1000);\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n    int value = opt<int>(\"value\", -1);\n\n    // Calculate maximum possible radius\n    int max_r = (min(n, m) - 1) / 2;\n    ensuref(r >= 0 && r <= max_r, \"Invalid radius r = %d for grid size %d x %d\", r, n, m);\n\n    // Initialize the grid\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Fill grid with random numbers between 1 and 1000\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"max\") {\n        // Fill grid with maximum value 1000\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1000);\n        }\n    } else if (type == \"min\") {\n        // Fill grid with minimum value 1\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n    } else if (type == \"same\") {\n        // Fill grid with the specified value\n        ensuref(value >= 1 && value <= 1000, \"Invalid value = %d\", value);\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), value);\n        }\n    } else if (type == \"overlap\") {\n        // Fill grid to create overlapping circles scenario\n        // Initialize with low values\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n        // Place high values in the overlapping area\n        int i0 = n / 2;\n        int j0 = m / 2;\n        int i1 = i0;\n        int j1 = j0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                double dist = sqrt((i - i0) * (i - i0) + (j - j0) * (j - j0));\n                if (dist <= r + 1e-6) {\n                    grid[i][j] = 1000;\n                }\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Output n, m, r\n    printf(\"%d %d %d\\n\", n, m, r);\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            printf(\"%d\", grid[i][j]);\n            if (j < m - 1)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n    int value = opt<int>(\"value\", -1);\n\n    // Calculate maximum possible radius\n    int max_r = (min(n, m) - 1) / 2;\n    ensuref(r >= 0 && r <= max_r, \"Invalid radius r = %d for grid size %d x %d\", r, n, m);\n\n    // Initialize the grid\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Fill grid with random numbers between 1 and 1000\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"max\") {\n        // Fill grid with maximum value 1000\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1000);\n        }\n    } else if (type == \"min\") {\n        // Fill grid with minimum value 1\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n    } else if (type == \"same\") {\n        // Fill grid with the specified value\n        ensuref(value >= 1 && value <= 1000, \"Invalid value = %d\", value);\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), value);\n        }\n    } else if (type == \"overlap\") {\n        // Fill grid to create overlapping circles scenario\n        // Initialize with low values\n        for (int i = 0; i < n; i++) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n        // Place high values in the overlapping area\n        int i0 = n / 2;\n        int j0 = m / 2;\n        int i1 = i0;\n        int j1 = j0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                double dist = sqrt((i - i0) * (i - i0) + (j - j0) * (j - j0));\n                if (dist <= r + 1e-6) {\n                    grid[i][j] = 1000;\n                }\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Output n, m, r\n    printf(\"%d %d %d\\n\", n, m, r);\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            printf(\"%d\", grid[i][j]);\n            if (j < m - 1)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -r 0 -type random\n./gen -n 2 -m 2 -r 0 -type max\n./gen -n 2 -m 2 -r 0 -type min\n./gen -n 3 -m 3 -r 1 -type overlap\n./gen -n 5 -m 5 -r 2 -type random\n./gen -n 10 -m 10 -r 3 -type random\n./gen -n 20 -m 20 -r 5 -type same -value 500\n./gen -n 50 -m 50 -r 10 -type max\n./gen -n 100 -m 100 -r 20 -type min\n./gen -n 200 -m 200 -r 40 -type random\n./gen -n 400 -m 400 -r 100 -type random\n./gen -n 500 -m 500 -r 249 -type random\n./gen -n 500 -m 500 -r 249 -type max\n./gen -n 500 -m 500 -r 249 -type min\n./gen -n 100 -m 500 -r 49 -type random\n./gen -n 500 -m 100 -r 49 -type random\n./gen -n 100 -m 100 -r 0 -type random\n./gen -n 100 -m 100 -r 49 -type max\n./gen -n 200 -m 300 -r 99 -type random\n./gen -n 150 -m 150 -r 74 -type same -value 1000\n./gen -n 150 -m 150 -r 74 -type same -value 1\n./gen -n 300 -m 300 -r 149 -type overlap\n./gen -n 4 -m 4 -r 1 -type random\n./gen -n 7 -m 8 -r 2 -type random\n./gen -n 8 -m 7 -r 2 -type random\n./gen -n 6 -m 6 -r 2 -type same -value 999\n./gen -n 8 -m 8 -r 3 -type overlap\n./gen -n 10 -m 10 -r 4 -type random\n./gen -n 500 -m 500 -r 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:46.117770",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "364/A",
      "title": "A. Matrix",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer a (0 ≤ a ≤ 109), the second line contains a string of decimal integers s (1 ≤ |s| ≤ 4000).",
      "output_spec": "OutputPrint a single integer — the answer to a problem.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy1012345OutputCopy6InputCopy16439873893693495623498263984765OutputCopy40",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer a (0 ≤ a ≤ 109), the second line contains a string of decimal integers s (1 ≤ |s| ≤ 4000).\n\nOutputPrint a single integer — the answer to a problem.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy1012345OutputCopy6InputCopy16439873893693495623498263984765OutputCopy40\n\nInputCopy1012345\n\nOutputCopy6\n\nInputCopy16439873893693495623498263984765\n\nOutputCopy40",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n    string s = inf.readLine(\"[0-9]{1,4000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n    string s = inf.readLine(\"[0-9]{1,4000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n    string s = inf.readLine(\"[0-9]{1,4000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"all_zero\") {\n        s = string(n, '0');\n    } else if (type == \"all_nine\") {\n        s = string(n, '9');\n    } else if (type == \"all_one\") {\n        s = string(n, '1');\n    } else if (type == \"ascending\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + (i % 10);\n    } else if (type == \"descending\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '9' - (i % 10);\n    } else if (type == \"alternating01\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + (i % 2);\n    } else if (type == \"alternating12\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '1' + (i % 2);\n    } else if (type == \"palindrome\") {\n        s = \"\";\n        for(int i = 0; i < (n + 1)/2; ++i)\n            s += '0' + rnd.next(10);\n        string t = s;\n        reverse(t.begin(), t.end());\n        if(n % 2 == 1) t = t.substr(1);\n        s += t;\n    } else if (type == \"random\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + rnd.next(10);\n    } else {\n        // Default to random\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + rnd.next(10);\n    }\n\n    // Output 'a' and 's'\n    printf(\"%d\\n\", a);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"all_zero\") {\n        s = string(n, '0');\n    } else if (type == \"all_nine\") {\n        s = string(n, '9');\n    } else if (type == \"all_one\") {\n        s = string(n, '1');\n    } else if (type == \"ascending\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + (i % 10);\n    } else if (type == \"descending\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '9' - (i % 10);\n    } else if (type == \"alternating01\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + (i % 2);\n    } else if (type == \"alternating12\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '1' + (i % 2);\n    } else if (type == \"palindrome\") {\n        s = \"\";\n        for(int i = 0; i < (n + 1)/2; ++i)\n            s += '0' + rnd.next(10);\n        string t = s;\n        reverse(t.begin(), t.end());\n        if(n % 2 == 1) t = t.substr(1);\n        s += t;\n    } else if (type == \"random\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + rnd.next(10);\n    } else {\n        // Default to random\n        s = \"\";\n        for(int i = 0; i < n; ++i)\n            s += '0' + rnd.next(10);\n    }\n\n    // Output 'a' and 's'\n    printf(\"%d\\n\", a);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -a 0 -type all_zero\n./gen -n 1 -a 0 -type all_one\n./gen -n 1 -a 0 -type all_nine\n\n./gen -n 10 -a 0 -type all_zero\n./gen -n 10 -a 100 -type all_one\n./gen -n 10 -a 8100 -type all_nine\n\n./gen -n 50 -a 2500 -type all_one\n./gen -n 50 -a 0 -type all_zero\n\n./gen -n 100 -a 10000 -type all_one\n./gen -n 100 -a 810000 -type all_nine\n\n./gen -n 3333 -a 900000000 -type all_nine\n./gen -n 4000 -a 0 -type all_zero\n./gen -n 4000 -a 1 -type all_one\n\n./gen -n 4000 -a 1000000 -type random\n./gen -n 4000 -a 1000000 -type alternating01\n./gen -n 4000 -a 1000000 -type alternating12\n./gen -n 4000 -a 1000000 -type palindrome\n./gen -n 4000 -a 1000000 -type ascending\n./gen -n 4000 -a 1000000 -type descending\n\n./gen -n 1 -a 0 -type random\n./gen -n 1 -a 1000000000 -type random\n./gen -n 4000 -a 0 -type random\n./gen -n 4000 -a 1000000000 -type random\n\n./gen -n 4000 -a 10 -type random\n./gen -n 4000 -a 123456789 -type random\n./gen -n 1000 -a 500000000 -type random\n\n./gen -n 4000 -a 999999999 -type random\n./gen -n 2000 -a 444444444 -type alternating12\n./gen -n 3000 -a 555555555 -type alternating01\n\n./gen -n 4000 -a 1000000 -type random\n./gen -n 4000 -a 800000000 -type random\n./gen -n 4000 -a 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:48.266560",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "364/B",
      "title": "B. Free Market",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, d (1 ≤ n ≤ 50, 1 ≤ d ≤ 104) — the number of items on the market and John's sense of justice value, correspondingly. The second line contains n space-separated integers ci (1 ≤ ci ≤ 104).",
      "output_spec": "OutputPrint two space-separated integers: the maximum possible price in the set of items John can get and the minimum number of days needed to get such set.",
      "sample_tests": "ExamplesInputCopy3 21 3 10OutputCopy4 3InputCopy3 51 2 3OutputCopy6 2InputCopy10 1000010000 9999 1 10000 10000 10000 1 2 3 4OutputCopy50010 6",
      "description": "B. Free Market\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, d (1 ≤ n ≤ 50, 1 ≤ d ≤ 104) — the number of items on the market and John's sense of justice value, correspondingly. The second line contains n space-separated integers ci (1 ≤ ci ≤ 104).\n\nOutputPrint two space-separated integers: the maximum possible price in the set of items John can get and the minimum number of days needed to get such set.\n\nInputCopy3 21 3 10OutputCopy4 3InputCopy3 51 2 3OutputCopy6 2InputCopy10 1000010000 9999 1 10000 10000 10000 1 2 3 4OutputCopy50010 6\n\nInputCopy3 21 3 10\n\nOutputCopy4 3\n\nInputCopy3 51 2 3\n\nOutputCopy6 2\n\nInputCopy10 1000010000 9999 1 10000 10000 10000 1 2 3 4\n\nOutputCopy50010 6\n\nNoteIn the first sample John can act like this:   Take the first item (1 - 0 ≤ 2).  Exchange the first item for the second one (3 - 1 ≤ 2).  Take the first item (1 - 0 ≤ 2).",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(n, 1, 10000, \"ci\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(n, 1, 10000, \"ci\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(n, 1, 10000, \"ci\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n == -1) n = rnd.next(1,50);\n    else n = min(max(1, n), 50);\n\n    int d = opt<int>(\"d\", -1);\n    if (d == -1) d = rnd.next(1,10000);\n    else d = min(max(1, d), 10000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ci(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min\") {\n        // set ci[i] = 1\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n    } else if (type == \"max\") {\n        // set ci[i] = 10000\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 10000;\n        }\n    } else if (type == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n            val = min(val + rnd.next(1, 1000), 10000);\n        }\n    } else if (type == \"decreasing\") {\n        int val = 10000;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n            val = max(val - rnd.next(1, 1000), 1);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = (i % 2 == 0) ? rnd.next(1, 5000) : rnd.next(5001, 10000);\n        }\n    } else if (type == \"bigsmall\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n/2)\n                ci[i] = rnd.next(1, 5000);\n            else\n                ci[i] = rnd.next(5001, 10000);\n        }\n    } else if (type == \"smallbig\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n/2)\n                ci[i] = rnd.next(5001, 10000);\n            else\n                ci[i] = rnd.next(1, 5000);\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"ci\", -1);\n        if (val == -1) val = rnd.next(1,10000);\n        else val = min(max(1, val), 10000);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n        }\n    } else if (type == \"onebig\") {\n        // One big value, rest small\n        ci[0] = 10000;\n        for (int i = 1; i < n; ++i) {\n            ci[i] = 1;\n        }\n        shuffle(ci.begin(), ci.end());\n    } else if (type == \"onesmall\") {\n        // One small value, rest big\n        ci[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            ci[i] = 10000;\n        }\n        shuffle(ci.begin(), ci.end());\n    } else if (type == \"duplicate\") {\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 10000);\n        }\n    }\n\n    // Output n and d\n    printf(\"%d %d\\n\", n, d);\n\n    // Output ci\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%s\", ci[i], i == n - 1 ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n == -1) n = rnd.next(1,50);\n    else n = min(max(1, n), 50);\n\n    int d = opt<int>(\"d\", -1);\n    if (d == -1) d = rnd.next(1,10000);\n    else d = min(max(1, d), 10000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ci(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min\") {\n        // set ci[i] = 1\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n    } else if (type == \"max\") {\n        // set ci[i] = 10000\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 10000;\n        }\n    } else if (type == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n            val = min(val + rnd.next(1, 1000), 10000);\n        }\n    } else if (type == \"decreasing\") {\n        int val = 10000;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n            val = max(val - rnd.next(1, 1000), 1);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = (i % 2 == 0) ? rnd.next(1, 5000) : rnd.next(5001, 10000);\n        }\n    } else if (type == \"bigsmall\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n/2)\n                ci[i] = rnd.next(1, 5000);\n            else\n                ci[i] = rnd.next(5001, 10000);\n        }\n    } else if (type == \"smallbig\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n/2)\n                ci[i] = rnd.next(5001, 10000);\n            else\n                ci[i] = rnd.next(1, 5000);\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"ci\", -1);\n        if (val == -1) val = rnd.next(1,10000);\n        else val = min(max(1, val), 10000);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n        }\n    } else if (type == \"onebig\") {\n        // One big value, rest small\n        ci[0] = 10000;\n        for (int i = 1; i < n; ++i) {\n            ci[i] = 1;\n        }\n        shuffle(ci.begin(), ci.end());\n    } else if (type == \"onesmall\") {\n        // One small value, rest big\n        ci[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            ci[i] = 10000;\n        }\n        shuffle(ci.begin(), ci.end());\n    } else if (type == \"duplicate\") {\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = val;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 10000);\n        }\n    }\n\n    // Output n and d\n    printf(\"%d %d\\n\", n, d);\n\n    // Output ci\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%s\", ci[i], i == n - 1 ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 1 -type min\n./gen -n 1 -d 10000 -type max\n./gen -n 50 -d 1 -type random\n./gen -n 50 -d 10000 -type random\n./gen -n 50 -d 10000 -type min\n./gen -n 50 -d 1 -type max\n./gen -n 50 -d 5000 -type increasing\n./gen -n 50 -d 5000 -type decreasing\n./gen -n 50 -d 5000 -type alternating\n./gen -n 50 -d 1 -type alternating\n./gen -n 50 -d 10000 -type alternating\n./gen -n 50 -d 10000 -type bigsmall\n./gen -n 50 -d 10000 -type smallbig\n./gen -n 50 -d 1 -type bigsmall\n./gen -n 50 -d 1 -type smallbig\n./gen -n 50 -d 5000 -type equal -ci 10000\n./gen -n 50 -d 5000 -type equal -ci 1\n./gen -n 50 -d 5000 -type equal -ci 5000\n./gen -n 50 -d 2500 -type equal -ci 2500\n./gen -n 50 -d 5000 -type onebig\n./gen -n 50 -d 5000 -type onesmall\n./gen -n 50 -d 5000 -type duplicate\n./gen -n 50 -d 1 -type onebig\n./gen -n 50 -d 1 -type onesmall\n./gen -n 50 -d 1 -type duplicate\n./gen -n 25 -d 10000 -type random\n./gen -n 25 -d 1 -type random\n./gen -n 25 -d 5000 -type random\n./gen -n 2 -d 1 -type random\n./gen -n 2 -d 10000 -type random\n./gen -n 50 -d 4999 -type min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:50.545448",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "364/C",
      "title": "C. Beautiful Set",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer k (10 ≤ k ≤ 5000) that shows how many numbers the required beautiful set should have.",
      "output_spec": "OutputIn the first line print k space-separated integers that are a beautiful set. If there are multiple such sets, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy10OutputCopy16 18 24 27 36 48 54 72 108 144",
      "description": "C. Beautiful Set\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer k (10 ≤ k ≤ 5000) that shows how many numbers the required beautiful set should have.\n\nOutputIn the first line print k space-separated integers that are a beautiful set. If there are multiple such sets, you are allowed to print any of them.\n\nInputCopy10OutputCopy16 18 24 27 36 48 54 72 108 144\n\nInputCopy10\n\nOutputCopy16 18 24 27 36 48 54 72 108 144",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(10, 5000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(10, 5000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(10, 5000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int k = inf.readInt(10, 5000);\n    long long max_n = 2LL * k * k;\n\n    vector<long long> numbers = ouf.readLongs(k, 1LL, max_n, \"numbers\");\n\n    // Collect all primes that divide any of the numbers\n    set<int> primes;\n    vector< set<int> > number_factors(k);\n\n    for (int i = 0; i < k; ++i) {\n        long long n = numbers[i];\n\n        set<int> factors;\n        long long temp_n = n;\n        for (int p = 2; (long long)p * p <= temp_n; ++p) {\n            if (temp_n % p == 0) {\n                factors.insert(p);\n                while (temp_n % p == 0) temp_n /= p;\n            }\n        }\n        if (temp_n > 1) {\n            factors.insert((int)temp_n);\n        }\n        number_factors[i] = factors;\n        primes.insert(factors.begin(), factors.end());\n    }\n\n    // Check the beautiful condition for each prime\n    for (int p : primes) {\n        int count = 0;\n        for (int i = 0; i < k; ++i) {\n            if (numbers[i] % p == 0) count++;\n        }\n        if (count > 0 && count < (k + 1) / 2) {\n            quitf(_wa, \"Prime %d divides some numbers, but less than half of the numbers (%d out of %d)\", p, count, k);\n        }\n    }\n\n    // If all conditions are satisfied\n    quitf(_ok, \"Found a beautiful set of %d numbers\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int minK = opt<int>(\"minK\", 10);\n    int maxK = opt<int>(\"maxK\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k;\n    if (type == \"min\") {\n        k = 10;\n    } else if (type == \"max\") {\n        k = 5000;\n    } else if (type == \"prime\") {\n        // Generate a random prime between minK and maxK\n        vector<int> primes;\n        // Generate list of primes between minK and maxK\n        vector<bool> is_prime(maxK + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i=2; i<=maxK; ++i) {\n            if (is_prime[i]) {\n                if (i>=minK)\n                    primes.push_back(i);\n                for (int j=2*i; j<=maxK; j+=i)\n                    is_prime[j] = false;\n            }\n        }\n        if (primes.empty()) {\n            k = minK;\n        } else {\n            k = primes[rnd.next((int)primes.size())];\n        }\n    } else if (type == \"power2\") {\n        // Generate a power of 2 between minK and maxK\n        vector<int> powers2;\n        for (int i=1; i<=13; ++i) {  // 2^13 = 8192\n            int p = 1<<i;\n            if (p>=minK && p<=maxK)\n                powers2.push_back(p);\n        }\n        if (powers2.empty()) {\n            k = minK;\n        } else {\n            k = powers2[rnd.next((int)powers2.size())];\n        }\n    } else {\n        // Random k between minK and maxK\n        k = rnd.next(minK, maxK);\n    }\n\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int minK = opt<int>(\"minK\", 10);\n    int maxK = opt<int>(\"maxK\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k;\n    if (type == \"min\") {\n        k = 10;\n    } else if (type == \"max\") {\n        k = 5000;\n    } else if (type == \"prime\") {\n        // Generate a random prime between minK and maxK\n        vector<int> primes;\n        // Generate list of primes between minK and maxK\n        vector<bool> is_prime(maxK + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i=2; i<=maxK; ++i) {\n            if (is_prime[i]) {\n                if (i>=minK)\n                    primes.push_back(i);\n                for (int j=2*i; j<=maxK; j+=i)\n                    is_prime[j] = false;\n            }\n        }\n        if (primes.empty()) {\n            k = minK;\n        } else {\n            k = primes[rnd.next((int)primes.size())];\n        }\n    } else if (type == \"power2\") {\n        // Generate a power of 2 between minK and maxK\n        vector<int> powers2;\n        for (int i=1; i<=13; ++i) {  // 2^13 = 8192\n            int p = 1<<i;\n            if (p>=minK && p<=maxK)\n                powers2.push_back(p);\n        }\n        if (powers2.empty()) {\n            k = minK;\n        } else {\n            k = powers2[rnd.next((int)powers2.size())];\n        }\n    } else {\n        // Random k between minK and maxK\n        k = rnd.next(minK, maxK);\n    }\n\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type prime -minK 10 -maxK 50\n./gen -type prime -minK 100 -maxK 200\n./gen -type prime -minK 500 -maxK 1000\n./gen -type prime -minK 1000 -maxK 2000\n./gen -type prime -minK 2000 -maxK 3000\n./gen -type prime -minK 4000 -maxK 5000\n./gen -type power2\n./gen -type random -minK 10 -maxK 20\n./gen -type random -minK 21 -maxK 100\n./gen -type random -minK 101 -maxK 500\n./gen -type random -minK 501 -maxK 1000\n./gen -type random -minK 1001 -maxK 1500\n./gen -type random -minK 1501 -maxK 2000\n./gen -type random -minK 2001 -maxK 2500\n./gen -type random -minK 2501 -maxK 3000\n./gen -type random -minK 3001 -maxK 3500\n./gen -type random -minK 3501 -maxK 4000\n./gen -type random -minK 4001 -maxK 4500\n./gen -type random -minK 4501 -maxK 5000\n./gen -type random -minK 10 -maxK 5000\n./gen -type random -minK 10 -maxK 5000\n./gen -type random -minK 10 -maxK 5000\n./gen -type random -minK 10 -maxK 5000\n./gen -type random -minK 10 -maxK 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:52.800994",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "364/D",
      "title": "D. Ghd",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 106) showing how many numbers are in set a. The second line contains space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1012). Please note, that given set can contain equal numbers.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the %I64d specifier.",
      "output_spec": "OutputPrint a single integer g — the Ghd of set a.",
      "sample_tests": "ExamplesInputCopy66 2 3 4 5 6OutputCopy3InputCopy55 5 6 10 15OutputCopy5",
      "description": "time limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 106) showing how many numbers are in set a. The second line contains space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1012). Please note, that given set can contain equal numbers.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the %I64d specifier.\n\nOutputPrint a single integer g — the Ghd of set a.\n\nInputCopy66 2 3 4 5 6OutputCopy3InputCopy55 5 6 10 15OutputCopy5\n\nInputCopy66 2 3 4 5 6\n\nOutputCopy3\n\nInputCopy55 5 6 10 15\n\nOutputCopy5",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        long long ai = inf.readLong(1LL, 1000000000000LL, \"a[\" + to_string(i+1) + \"]\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        long long ai = inf.readLong(1LL, 1000000000000LL, \"a[\" + to_string(i+1) + \"]\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        long long ai = inf.readLong(1LL, 1000000000000LL, \"a[\" + to_string(i+1) + \"]\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_A = 1000000000000LL; // 1e12\nconst int MAX_N = 1000000; // 1e6\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a;\n\n    if (type == \"random\") {\n        // Generate random numbers\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, MAX_A);\n    } else if (type == \"all_same\") {\n        // All numbers are the same\n        long long val = rnd.next(1LL, MAX_A);\n        a.assign(n, val);\n    } else if (type == \"all_ones\") {\n        // All numbers are 1\n        a.assign(n, 1LL);\n    } else if (type == \"half_same_large_divisor\") {\n        // Half numbers divisible by a large number, rest are not.\n        long long g = rnd.next(MAX_A / 2, MAX_A);\n        int half_n = n / 2;\n        a.resize(n);\n        for(int i = 0; i < half_n; ++i)\n            a[i] = g * rnd.next(1LL, MAX_A / g);\n        for(int i = half_n; i < n; ++i) {\n            // Generate numbers not divisible by g\n            long long val;\n            do {\n                val = rnd.next(1LL, MAX_A);\n            } while(val % g == 0);\n            a[i] = val;\n        }\n    } else if (type == \"common_large_divisor\") {\n        // All numbers share a common large divisor\n        long long g = rnd.next(MAX_A / 2, MAX_A);\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = g * rnd.next(1LL, MAX_A / g);\n    } else if (type == \"small_n\") {\n        // n is small, numbers random\n        if (n > 100) n = 100; // cap n to 100\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, MAX_A);\n    } else if (type == \"maximum_n\") {\n        // n is maximum, numbers random\n        n = MAX_N;\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, MAX_A);\n    } else if (type == \"exactly_half_divisible_by_1\") {\n        // Half numbers are 1, rest are large primes (approximated)\n        int half_n = n / 2;\n        a.resize(n);\n        for(int i = 0; i < half_n; ++i)\n            a[i] = 1LL;\n        for(int i = half_n; i < n; ++i) {\n            // Generate large numbers\n            a[i] = rnd.next(MAX_A / 2, MAX_A);\n        }\n    } else if (type == \"multiple_potential_divisors\") {\n        // Numbers constructed to have multiple possible Ghd candidates\n        a.resize(n);\n        int cnt = 0;\n        // Divisible by 2\n        for (; cnt < n / 3; ++cnt)\n            a[cnt] = 2 * rnd.next(1LL, MAX_A / 2);\n        // Divisible by 3\n        for (; cnt < 2 * n / 3; ++cnt)\n            a[cnt] = 3 * rnd.next(1LL, MAX_A / 3);\n        // Divisible by 5\n        for (; cnt < n; ++cnt)\n            a[cnt] = 5 * rnd.next(1LL, MAX_A / 5);\n        // Shuffle the array\n        shuffle(a.begin(), a.end());\n    } else if (type == \"powers_of_two\") {\n        // Numbers are powers of two\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            int exp = rnd.next(0, 39); // 2^39 ~ 5.5e11\n            a[i] = 1LL << exp;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output numbers\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], \" \\n\"[i == n-1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_A = 1000000000000LL; // 1e12\nconst int MAX_N = 1000000; // 1e6\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a;\n\n    if (type == \"random\") {\n        // Generate random numbers\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, MAX_A);\n    } else if (type == \"all_same\") {\n        // All numbers are the same\n        long long val = rnd.next(1LL, MAX_A);\n        a.assign(n, val);\n    } else if (type == \"all_ones\") {\n        // All numbers are 1\n        a.assign(n, 1LL);\n    } else if (type == \"half_same_large_divisor\") {\n        // Half numbers divisible by a large number, rest are not.\n        long long g = rnd.next(MAX_A / 2, MAX_A);\n        int half_n = n / 2;\n        a.resize(n);\n        for(int i = 0; i < half_n; ++i)\n            a[i] = g * rnd.next(1LL, MAX_A / g);\n        for(int i = half_n; i < n; ++i) {\n            // Generate numbers not divisible by g\n            long long val;\n            do {\n                val = rnd.next(1LL, MAX_A);\n            } while(val % g == 0);\n            a[i] = val;\n        }\n    } else if (type == \"common_large_divisor\") {\n        // All numbers share a common large divisor\n        long long g = rnd.next(MAX_A / 2, MAX_A);\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = g * rnd.next(1LL, MAX_A / g);\n    } else if (type == \"small_n\") {\n        // n is small, numbers random\n        if (n > 100) n = 100; // cap n to 100\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, MAX_A);\n    } else if (type == \"maximum_n\") {\n        // n is maximum, numbers random\n        n = MAX_N;\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, MAX_A);\n    } else if (type == \"exactly_half_divisible_by_1\") {\n        // Half numbers are 1, rest are large primes (approximated)\n        int half_n = n / 2;\n        a.resize(n);\n        for(int i = 0; i < half_n; ++i)\n            a[i] = 1LL;\n        for(int i = half_n; i < n; ++i) {\n            // Generate large numbers\n            a[i] = rnd.next(MAX_A / 2, MAX_A);\n        }\n    } else if (type == \"multiple_potential_divisors\") {\n        // Numbers constructed to have multiple possible Ghd candidates\n        a.resize(n);\n        int cnt = 0;\n        // Divisible by 2\n        for (; cnt < n / 3; ++cnt)\n            a[cnt] = 2 * rnd.next(1LL, MAX_A / 2);\n        // Divisible by 3\n        for (; cnt < 2 * n / 3; ++cnt)\n            a[cnt] = 3 * rnd.next(1LL, MAX_A / 3);\n        // Divisible by 5\n        for (; cnt < n; ++cnt)\n            a[cnt] = 5 * rnd.next(1LL, MAX_A / 5);\n        // Shuffle the array\n        shuffle(a.begin(), a.end());\n    } else if (type == \"powers_of_two\") {\n        // Numbers are powers of two\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            int exp = rnd.next(0, 39); // 2^39 ~ 5.5e11\n            a[i] = 1LL << exp;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output numbers\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], \" \\n\"[i == n-1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with random numbers\n./gen -n 1 -type small_n\n./gen -n 2 -type small_n\n./gen -n 10 -type small_n\n./gen -n 100 -type small_n\n\n# Random numbers with increasing n\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n./gen -n 1000000 -type random\n\n# All numbers are the same\n./gen -n 100000 -type all_same\n./gen -n 1000000 -type all_same\n\n# All numbers are 1\n./gen -n 1000000 -type all_ones\n\n# Half numbers have the same large divisor\n./gen -n 1000 -type half_same_large_divisor\n./gen -n 100000 -type half_same_large_divisor\n./gen -n 1000000 -type half_same_large_divisor\n\n# All numbers share a common large divisor\n./gen -n 1000000 -type common_large_divisor\n\n# Numbers constructed to have multiple potential Ghd candidates\n./gen -n 999999 -type multiple_potential_divisors\n./gen -n 1000000 -type multiple_potential_divisors\n\n# Half numbers are 1, rest are large numbers\n./gen -n 1000000 -type exactly_half_divisible_by_1\n\n# Numbers are powers of two\n./gen -n 10 -type powers_of_two\n./gen -n 100 -type powers_of_two\n./gen -n 1000000 -type powers_of_two\n\n# Maximum n with random numbers\n./gen -n 1000000 -type maximum_n\n\n# Edge cases with n=1\n./gen -n 1 -type all_ones\n./gen -n 1 -type all_same\n./gen -n 1 -type random\n\n# Edge cases where n is odd\n./gen -n 999999 -type random\n\n# Edge cases where n is maximum\n./gen -n 1000000 -type random\n\n# Small n with half numbers sharing a large divisor\n./gen -n 10 -type half_same_large_divisor\n./gen -n 100 -type half_same_large_divisor\n\n# Small n with multiple potential Ghd candidates\n./gen -n 10 -type multiple_potential_divisors\n./gen -n 100 -type multiple_potential_divisors\n\n# Large n with random numbers\n./gen -n 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:54.975576",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "364/E",
      "title": "E. Empty Rectangles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test12 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m and k (1 ≤ n, m ≤ 2500, 0 ≤ k ≤ 6) — the sizes of the table and the required number of numbers one.Next n lines each contains m characters \"0\" or \"1\". The i-th character of the j-th line corresponds to the character that is in the j-th row and the i-th column of the table.",
      "output_spec": "OutputPrint a single number — the number of rectangles that contain exactly k numbers one.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy3 3 2101000101OutputCopy8InputCopy5 5 10000000000001000000000000OutputCopy81InputCopy5 5 60101010101010101010101010OutputCopy12InputCopy3 3 0001010000OutputCopy15InputCopy4 4 00000010100000000OutputCopy52",
      "description": "E. Empty Rectangles\n\ntime limit per test12 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m and k (1 ≤ n, m ≤ 2500, 0 ≤ k ≤ 6) — the sizes of the table and the required number of numbers one.Next n lines each contains m characters \"0\" or \"1\". The i-th character of the j-th line corresponds to the character that is in the j-th row and the i-th column of the table.\n\nOutputPrint a single number — the number of rectangles that contain exactly k numbers one.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy3 3 2101000101OutputCopy8InputCopy5 5 10000000000001000000000000OutputCopy81InputCopy5 5 60101010101010101010101010OutputCopy12InputCopy3 3 0001010000OutputCopy15InputCopy4 4 00000010100000000OutputCopy52\n\nInputCopy3 3 2101000101\n\nOutputCopy8\n\nInputCopy5 5 10000000000001000000000000\n\nOutputCopy81\n\nInputCopy5 5 60101010101010101010101010\n\nOutputCopy12\n\nInputCopy3 3 0001010000\n\nOutputCopy15\n\nInputCopy4 4 00000010100000000\n\nOutputCopy52",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2500, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 6, \"k\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i));\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2500, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 6, \"k\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2500, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 6, \"k\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '0'));\n\n    if (type == \"all_zero\") {\n        // Grid already initialized with '0's\n    } else if (type == \"all_one\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), '1');\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2);\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2) ? '1' : '0';\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < min(n, m); ++i)\n            grid[i][i] = '1';\n    } else if (type == \"corners\") {\n        grid[0][0] = '1';\n        grid[0][m-1] = '1';\n        grid[n-1][0] = '1';\n        grid[n-1][m-1] = '1';\n    } else if (type == \"edges\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = '1';\n            grid[i][m-1] = '1';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '1';\n            grid[n-1][j] = '1';\n        }\n    } else if (type == \"clustered\") {\n        int cluster_n = min(n, n / 10 + 1);\n        int cluster_m = min(m, m / 10 + 1);\n        int start_i = rnd.next(0, n - cluster_n);\n        int start_j = rnd.next(0, m - cluster_m);\n        for (int i = start_i; i < start_i + cluster_n; ++i)\n            for (int j = start_j; j < start_j + cluster_m; ++j)\n                grid[i][j] = '1';\n    } else if (type == \"sparse\") {\n        int total_ones = rnd.next(0, min(6, n * m));\n        for (int cnt = 0; cnt < total_ones; ) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            if (grid[i][j] == '0') {\n                grid[i][j] = '1';\n                ++cnt;\n            }\n        }\n    } else if (type == \"dense\") {\n        int total_ones = rnd.next(n * m * 9 / 10, n * m);\n        for (int cnt = 0; cnt < total_ones; ) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            if (grid[i][j] == '0') {\n                grid[i][j] = '1';\n                ++cnt;\n            }\n        }\n    } else {\n        // Unknown type, default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '0'));\n\n    if (type == \"all_zero\") {\n        // Grid already initialized with '0's\n    } else if (type == \"all_one\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), '1');\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2);\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2) ? '1' : '0';\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < min(n, m); ++i)\n            grid[i][i] = '1';\n    } else if (type == \"corners\") {\n        grid[0][0] = '1';\n        grid[0][m-1] = '1';\n        grid[n-1][0] = '1';\n        grid[n-1][m-1] = '1';\n    } else if (type == \"edges\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = '1';\n            grid[i][m-1] = '1';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '1';\n            grid[n-1][j] = '1';\n        }\n    } else if (type == \"clustered\") {\n        int cluster_n = min(n, n / 10 + 1);\n        int cluster_m = min(m, m / 10 + 1);\n        int start_i = rnd.next(0, n - cluster_n);\n        int start_j = rnd.next(0, m - cluster_m);\n        for (int i = start_i; i < start_i + cluster_n; ++i)\n            for (int j = start_j; j < start_j + cluster_m; ++j)\n                grid[i][j] = '1';\n    } else if (type == \"sparse\") {\n        int total_ones = rnd.next(0, min(6, n * m));\n        for (int cnt = 0; cnt < total_ones; ) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            if (grid[i][j] == '0') {\n                grid[i][j] = '1';\n                ++cnt;\n            }\n        }\n    } else if (type == \"dense\") {\n        int total_ones = rnd.next(n * m * 9 / 10, n * m);\n        for (int cnt = 0; cnt < total_ones; ) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            if (grid[i][j] == '0') {\n                grid[i][j] = '1';\n                ++cnt;\n            }\n        }\n    } else {\n        // Unknown type, default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grids\n\n./gen -n 1 -m 1 -k 0 -type all_zero\n./gen -n 1 -m 1 -k 1 -type all_one\n./gen -n 1 -m 1 -k 0 -type random\n./gen -n 2 -m 2 -k 0 -type diagonal\n./gen -n 3 -m 3 -k 1 -type corners\n./gen -n 3 -m 3 -k 2 -type edges\n./gen -n 5 -m 5 -k 3 -type checkerboard\n./gen -n 5 -m 5 -k 2 -type clustered\n./gen -n 5 -m 5 -k 2 -type sparse\n./gen -n 5 -m 5 -k 2 -type dense\n\n# Medium grids\n\n./gen -n 50 -m 50 -k 4 -type random\n./gen -n 100 -m 100 -k 5 -type checkerboard\n./gen -n 100 -m 100 -k 0 -type all_zero\n./gen -n 100 -m 100 -k 6 -type all_one\n./gen -n 100 -m 100 -k 2 -type diagonal\n./gen -n 100 -m 200 -k 3 -type edges\n\n# Large grids\n\n./gen -n 2500 -m 2500 -k 0 -type all_zero\n./gen -n 2500 -m 2500 -k 6 -type all_one\n./gen -n 2500 -m 2500 -k 3 -type random\n./gen -n 2500 -m 2500 -k 4 -type sparse\n./gen -n 2000 -m 1000 -k 2 -type clustered\n./gen -n 2500 -m 2500 -k 1 -type dense\n\n# Edge cases\n\n./gen -n 1 -m 2500 -k 1 -type diagonal\n./gen -n 2500 -m 1 -k 1 -type edges\n./gen -n 1 -m 2500 -k 0 -type all_zero\n./gen -n 2500 -m 1 -k 6 -type all_one\n./gen -n 1000 -m 1500 -k 5 -type checkerboard\n./gen -n 1999 -m 1999 -k 5 -type random\n\n# Special patterns\n\n./gen -n 2500 -m 2500 -k 6 -type checkerboard\n./gen -n 100 -m 100 -k 6 -type sparse\n./gen -n 2000 -m 2000 -k 0 -type clustered\n./gen -n 1234 -m 2345 -k 3 -type random\n\n# Verify zero ones in grid when k=0\n\n./gen -n 100 -m 100 -k 0 -type all_one\n\n# Verify more ones than possible\n\n./gen -n 2 -m 3 -k 6 -type sparse\n\n# Negative test: Verify when k > total number of ones\n\n./gen -n 10 -m 10 -k 6 -type sparse\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:57.192946",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "365/A",
      "title": "A. Good Number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and k (1 ≤ n ≤ 100, 0 ≤ k ≤ 9). The i-th of the following n lines contains integer ai without leading zeroes (1 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint a single integer — the number of k-good numbers in a.",
      "sample_tests": "ExamplesInputCopy10 61234560123456012345601234560123456012345601234560123456012345601234560OutputCopy10InputCopy2 1110OutputCopy1",
      "description": "A. Good Number\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and k (1 ≤ n ≤ 100, 0 ≤ k ≤ 9). The i-th of the following n lines contains integer ai without leading zeroes (1 ≤ ai ≤ 109).\n\nOutputPrint a single integer — the number of k-good numbers in a.\n\nInputCopy10 61234560123456012345601234560123456012345601234560123456012345601234560OutputCopy10InputCopy2 1110OutputCopy1\n\nInputCopy10 61234560123456012345601234560123456012345601234560123456012345601234560\n\nOutputCopy10\n\nInputCopy2 1110\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 9, \"k\");\n    inf.readEoln();\n    \n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 9, \"k\");\n    inf.readEoln();\n    \n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 9, \"k\");\n    inf.readEoln();\n    \n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long generate_k_good_number(int k) {\n    set<int> digits_set;\n    // Include all digits from 0 to k\n    for (int d = 0; d <= k; ++d)\n        digits_set.insert(d);\n    // Possibly add extra digits\n    int extra_digits = rnd.next(0, 9); // Up to 9 additional digits\n    for (int i = 0; i < extra_digits; ++i)\n        digits_set.insert(rnd.next(0, 9));\n    // Build a number from these digits\n    vector<int> digits(digits_set.begin(), digits_set.end());\n    shuffle(digits.begin(), digits.end());\n    long long num = 0;\n    for (int d : digits)\n        num = num * 10 + d;\n    if (num == 0) num = 1; // Ensure num ≥ 1\n    return min(num, 1000000000LL); // Ensure num ≤ 1e9\n}\n\nlong long generate_not_k_good_number(int k) {\n    // Exclude at least one digit from 0 to k\n    vector<int> digits_0_to_k;\n    for (int d = 0; d <= k; ++d)\n        digits_0_to_k.push_back(d);\n    int digits_to_exclude = rnd.next(1, k + 1);\n    shuffle(digits_0_to_k.begin(), digits_0_to_k.end());\n    set<int> used_digits;\n    for (int i = digits_to_exclude; i <= k; ++i)\n        used_digits.insert(digits_0_to_k[i]);\n    // Add some random digits from 0 to 9\n    int extra_digits = rnd.next(1, 9);\n    for (int i = 0; i < extra_digits; ++i)\n        used_digits.insert(rnd.next(0, 9));\n    vector<int> digits(used_digits.begin(), used_digits.end());\n    shuffle(digits.begin(), digits.end());\n    long long num = 0;\n    for (int d : digits)\n        num = num * 10 + d;\n    if (num == 0) num = 1;\n    return min(num, 1000000000LL);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"mixed\");\n    int good_percent = opt<int>(\"good_percent\", 50);\n\n    // Ensure constraints\n    assert(1 <= n && n <= 100);\n    assert(0 <= k && k <= 9);\n    assert(0 <= good_percent && good_percent <= 100);\n\n    vector<long long> a(n);\n    if (type == \"all_good\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = generate_k_good_number(k);\n    } else if (type == \"all_bad\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = generate_not_k_good_number(k);\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int rnd_percent = rnd.next(0, 100);\n            if (rnd_percent < good_percent)\n                a[i] = generate_k_good_number(k);\n            else\n                a[i] = generate_not_k_good_number(k);\n        }\n    } else if (type == \"max_numbers\") {\n        long long max_num = 1000000000LL;\n        for (int i = 0; i < n; ++i)\n            a[i] = max_num;\n    } else if (type == \"min_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"special\") {\n        for (int i = 0; i < n; ++i) {\n            if (k == 0) {\n                // Generate numbers without digit 0\n                int num = 0;\n                while (num == 0) {\n                    num = rnd.next(1, 1000000000);\n                    string s = to_string(num);\n                    if (s.find('0') != string::npos)\n                        num = 0;\n                }\n                a[i] = num;\n            } else {\n                // Generate numbers missing digit k\n                set<int> digits;\n                for (int d = 0; d <= 9; ++d)\n                    if (d != k)\n                        digits.insert(d);\n                vector<int> digits_vec(digits.begin(), digits.end());\n                int num_digits = rnd.next(1, 9);\n                shuffle(digits_vec.begin(), digits_vec.end());\n                long long num = 0;\n                for (int j = 0; j < num_digits; ++j)\n                    num = num * 10 + digits_vec[j % digits_vec.size()];\n                a[i] = min(max(num, 1LL), 1000000000LL);\n            }\n        }\n    } else {\n        // Default to random numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld\\n\", a[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long generate_k_good_number(int k) {\n    set<int> digits_set;\n    // Include all digits from 0 to k\n    for (int d = 0; d <= k; ++d)\n        digits_set.insert(d);\n    // Possibly add extra digits\n    int extra_digits = rnd.next(0, 9); // Up to 9 additional digits\n    for (int i = 0; i < extra_digits; ++i)\n        digits_set.insert(rnd.next(0, 9));\n    // Build a number from these digits\n    vector<int> digits(digits_set.begin(), digits_set.end());\n    shuffle(digits.begin(), digits.end());\n    long long num = 0;\n    for (int d : digits)\n        num = num * 10 + d;\n    if (num == 0) num = 1; // Ensure num ≥ 1\n    return min(num, 1000000000LL); // Ensure num ≤ 1e9\n}\n\nlong long generate_not_k_good_number(int k) {\n    // Exclude at least one digit from 0 to k\n    vector<int> digits_0_to_k;\n    for (int d = 0; d <= k; ++d)\n        digits_0_to_k.push_back(d);\n    int digits_to_exclude = rnd.next(1, k + 1);\n    shuffle(digits_0_to_k.begin(), digits_0_to_k.end());\n    set<int> used_digits;\n    for (int i = digits_to_exclude; i <= k; ++i)\n        used_digits.insert(digits_0_to_k[i]);\n    // Add some random digits from 0 to 9\n    int extra_digits = rnd.next(1, 9);\n    for (int i = 0; i < extra_digits; ++i)\n        used_digits.insert(rnd.next(0, 9));\n    vector<int> digits(used_digits.begin(), used_digits.end());\n    shuffle(digits.begin(), digits.end());\n    long long num = 0;\n    for (int d : digits)\n        num = num * 10 + d;\n    if (num == 0) num = 1;\n    return min(num, 1000000000LL);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"mixed\");\n    int good_percent = opt<int>(\"good_percent\", 50);\n\n    // Ensure constraints\n    assert(1 <= n && n <= 100);\n    assert(0 <= k && k <= 9);\n    assert(0 <= good_percent && good_percent <= 100);\n\n    vector<long long> a(n);\n    if (type == \"all_good\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = generate_k_good_number(k);\n    } else if (type == \"all_bad\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = generate_not_k_good_number(k);\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int rnd_percent = rnd.next(0, 100);\n            if (rnd_percent < good_percent)\n                a[i] = generate_k_good_number(k);\n            else\n                a[i] = generate_not_k_good_number(k);\n        }\n    } else if (type == \"max_numbers\") {\n        long long max_num = 1000000000LL;\n        for (int i = 0; i < n; ++i)\n            a[i] = max_num;\n    } else if (type == \"min_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"special\") {\n        for (int i = 0; i < n; ++i) {\n            if (k == 0) {\n                // Generate numbers without digit 0\n                int num = 0;\n                while (num == 0) {\n                    num = rnd.next(1, 1000000000);\n                    string s = to_string(num);\n                    if (s.find('0') != string::npos)\n                        num = 0;\n                }\n                a[i] = num;\n            } else {\n                // Generate numbers missing digit k\n                set<int> digits;\n                for (int d = 0; d <= 9; ++d)\n                    if (d != k)\n                        digits.insert(d);\n                vector<int> digits_vec(digits.begin(), digits.end());\n                int num_digits = rnd.next(1, 9);\n                shuffle(digits_vec.begin(), digits_vec.end());\n                long long num = 0;\n                for (int j = 0; j < num_digits; ++j)\n                    num = num * 10 + digits_vec[j % digits_vec.size()];\n                a[i] = min(max(num, 1LL), 1000000000LL);\n            }\n        }\n    } else {\n        // Default to random numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld\\n\", a[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type all_good\n./gen -n 1 -k 0 -type all_bad\n./gen -n 1 -k 9 -type all_good\n./gen -n 1 -k 9 -type all_bad\n./gen -n 1 -k 5 -type mixed -good_percent 0\n./gen -n 1 -k 5 -type mixed -good_percent 100\n\n./gen -n 10 -k 0 -type mixed -good_percent 50\n./gen -n 10 -k 1 -type mixed -good_percent 50\n./gen -n 10 -k 5 -type mixed -good_percent 50\n./gen -n 10 -k 9 -type mixed -good_percent 50\n\n./gen -n 50 -k 0 -type all_good\n./gen -n 50 -k 0 -type all_bad\n./gen -n 50 -k 9 -type all_good\n./gen -n 50 -k 9 -type all_bad\n./gen -n 50 -k 5 -type mixed -good_percent 30\n./gen -n 50 -k 5 -type mixed -good_percent 70\n\n./gen -n 100 -k 0 -type special\n./gen -n 100 -k 1 -type special\n./gen -n 100 -k 5 -type special\n./gen -n 100 -k 9 -type special\n\n./gen -n 100 -k 0 -type max_numbers\n./gen -n 100 -k 9 -type max_numbers\n./gen -n 100 -k 0 -type min_numbers\n./gen -n 100 -k 9 -type min_numbers\n\n./gen -n 100 -k 0 -type mixed -good_percent 50\n./gen -n 100 -k 1 -type mixed -good_percent 50\n./gen -n 100 -k 5 -type mixed -good_percent 50\n./gen -n 100 -k 9 -type mixed -good_percent 50\n\n./gen -n 100 -k 5 -type mixed -good_percent 0\n./gen -n 100 -k 5 -type mixed -good_percent 100\n\n./gen -n 100 -k 5 -type all_good\n./gen -n 100 -k 5 -type all_bad\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:14:59.173461",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "365/B",
      "title": "B. The Fibonacci Segment",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of elements in the array. The second line contains integers: a1, a2, ..., an (0 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint the length of the longest good segment in array a.",
      "sample_tests": "ExamplesInputCopy101 2 3 5 8 13 21 34 55 89OutputCopy10InputCopy51 1 1 1 1OutputCopy2",
      "description": "B. The Fibonacci Segment\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of elements in the array. The second line contains integers: a1, a2, ..., an (0 ≤ ai ≤ 109).\n\nOutputPrint the length of the longest good segment in array a.\n\nInputCopy101 2 3 5 8 13 21 34 55 89OutputCopy10InputCopy51 1 1 1 1OutputCopy2\n\nInputCopy101 2 3 5 8 13 21 34 55 89\n\nOutputCopy10\n\nInputCopy51 1 1 1 1\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MAX_A = 1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<ll> a(n);\n    if (type == \"all_equal\") {\n        /* Generate array where all elements are equal */\n        ll val = rnd.next(0LL, MAX_A);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"zeroes\") {\n        /* Generate array of zeros */\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"fibonacci\") {\n        /* Generate Fibonacci-like sequence */\n        a[0] = 0;\n        if (n > 1)\n            a[1] = 1;\n        int i = 2;\n        for(; i < n; ++i) {\n            ll next = a[i-1] + a[i-2];\n            if (next > MAX_A) break;\n            a[i] = next;\n        }\n        /* Fill the rest with random numbers */\n        for(; i < n; ++i)\n            a[i] = rnd.next(0LL, MAX_A);\n    } else if (type == \"one_good\") {\n        /* Generate array with one long good segment */\n        int len = rnd.next(3, n);\n        int start = rnd.next(0, n - len);\n        ll a0 = rnd.next(0LL, MAX_A);\n        ll a1 = rnd.next(0LL, MAX_A);\n        a[start] = a0;\n        a[start+1] = a1;\n        for(int i = start + 2; i < start + len; ++i) {\n            ll next = a[i-1] + a[i-2];\n            if (next > MAX_A) break;\n            a[i] = next;\n        }\n        for(int i = 0; i < n; ++i) {\n            if (i < start || i >= start + len)\n                a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"random\") {\n        /* Generate random array */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0LL, MAX_A);\n    } else {\n        /* Default: Random array */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0LL, MAX_A);\n    }\n    \n    /* Output the array */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MAX_A = 1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<ll> a(n);\n    if (type == \"all_equal\") {\n        /* Generate array where all elements are equal */\n        ll val = rnd.next(0LL, MAX_A);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"zeroes\") {\n        /* Generate array of zeros */\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"fibonacci\") {\n        /* Generate Fibonacci-like sequence */\n        a[0] = 0;\n        if (n > 1)\n            a[1] = 1;\n        int i = 2;\n        for(; i < n; ++i) {\n            ll next = a[i-1] + a[i-2];\n            if (next > MAX_A) break;\n            a[i] = next;\n        }\n        /* Fill the rest with random numbers */\n        for(; i < n; ++i)\n            a[i] = rnd.next(0LL, MAX_A);\n    } else if (type == \"one_good\") {\n        /* Generate array with one long good segment */\n        int len = rnd.next(3, n);\n        int start = rnd.next(0, n - len);\n        ll a0 = rnd.next(0LL, MAX_A);\n        ll a1 = rnd.next(0LL, MAX_A);\n        a[start] = a0;\n        a[start+1] = a1;\n        for(int i = start + 2; i < start + len; ++i) {\n            ll next = a[i-1] + a[i-2];\n            if (next > MAX_A) break;\n            a[i] = next;\n        }\n        for(int i = 0; i < n; ++i) {\n            if (i < start || i >= start + len)\n                a[i] = rnd.next(0LL, MAX_A);\n        }\n    } else if (type == \"random\") {\n        /* Generate random array */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0LL, MAX_A);\n    } else {\n        /* Default: Random array */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0LL, MAX_A);\n    }\n    \n    /* Output the array */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_equal\n./gen -n 1 -type zeroes\n\n./gen -n 2 -type random\n./gen -n 2 -type all_equal\n./gen -n 2 -type zeroes\n\n./gen -n 3 -type random\n./gen -n 3 -type all_equal\n./gen -n 3 -type zeroes\n\n./gen -n 10 -type random\n./gen -n 10 -type all_equal\n./gen -n 10 -type zeroes\n./gen -n 10 -type fibonacci\n./gen -n 10 -type one_good\n\n./gen -n 50 -type fibonacci\n./gen -n 50 -type one_good\n./gen -n 50 -type random\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_equal\n./gen -n 1000 -type zeroes\n./gen -n 1000 -type fibonacci\n./gen -n 1000 -type one_good\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_equal\n./gen -n 100000 -type zeroes\n./gen -n 100000 -type one_good\n\n./gen -n 99999 -type one_good\n./gen -n 100000 -type fibonacci\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:01.344080",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "365/C",
      "title": "C. Matrix",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer a (0 ≤ a ≤ 109), the second line contains a string of decimal integers s (1 ≤ |s| ≤ 4000).",
      "output_spec": "OutputPrint a single integer — the answer to a problem.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy1012345OutputCopy6InputCopy16439873893693495623498263984765OutputCopy40",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer a (0 ≤ a ≤ 109), the second line contains a string of decimal integers s (1 ≤ |s| ≤ 4000).\n\nOutputPrint a single integer — the answer to a problem.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy1012345OutputCopy6InputCopy16439873893693495623498263984765OutputCopy40\n\nInputCopy1012345\n\nOutputCopy6\n\nInputCopy16439873893693495623498263984765\n\nOutputCopy40",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9]{1,4000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9]{1,4000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9]{1,4000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int a = opt<int>(\"a\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 4000) {\n        cerr << \"n must be between 1 and 4000\\n\";\n        return 1;\n    }\n\n    if (a < 0 || a > 1000000000) {\n        cerr << \"a must be between 0 and 1e9\\n\";\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"all_ones\") {\n        s = string(n, '1');\n    } else if (type == \"all_zeros\") {\n        s = string(n, '0');\n    } else if (type == \"alternating_zeros_ones\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += '0' + (i % 2);\n        }\n    } else if (type == \"max_digits\") {\n        s = string(n, '9');\n    } else if (type == \"palindrome\") {\n        s = \"\";\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char digit = '0' + rnd.next(0,9);\n            s += digit;\n        }\n        string rev = s.substr(0, n/2);\n        reverse(rev.begin(), rev.end());\n        s += rev;\n    } else if (type == \"single_non_zero\") {\n        s = string(n, '0');\n        int pos = rnd.next(0, n-1);\n        int digit = rnd.next(1, 9);\n        s[pos] = '0' + digit;\n    } else if (type == \"few_non_zero\") {\n        s = string(n, '0');\n        int k = opt<int>(\"k\", 10); // Number of non-zero digits\n        for (int i = 0; i < k; ++i) {\n            int pos = rnd.next(0, n-1);\n            int digit = rnd.next(1, 9);\n            s[pos] = '0' + digit;\n        }\n    } else if (type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += '0' + rnd.next(0,9);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", a);\n    cout << s << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int a = opt<int>(\"a\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 4000) {\n        cerr << \"n must be between 1 and 4000\\n\";\n        return 1;\n    }\n\n    if (a < 0 || a > 1000000000) {\n        cerr << \"a must be between 0 and 1e9\\n\";\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"all_ones\") {\n        s = string(n, '1');\n    } else if (type == \"all_zeros\") {\n        s = string(n, '0');\n    } else if (type == \"alternating_zeros_ones\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += '0' + (i % 2);\n        }\n    } else if (type == \"max_digits\") {\n        s = string(n, '9');\n    } else if (type == \"palindrome\") {\n        s = \"\";\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char digit = '0' + rnd.next(0,9);\n            s += digit;\n        }\n        string rev = s.substr(0, n/2);\n        reverse(rev.begin(), rev.end());\n        s += rev;\n    } else if (type == \"single_non_zero\") {\n        s = string(n, '0');\n        int pos = rnd.next(0, n-1);\n        int digit = rnd.next(1, 9);\n        s[pos] = '0' + digit;\n    } else if (type == \"few_non_zero\") {\n        s = string(n, '0');\n        int k = opt<int>(\"k\", 10); // Number of non-zero digits\n        for (int i = 0; i < k; ++i) {\n            int pos = rnd.next(0, n-1);\n            int digit = rnd.next(1, 9);\n            s[pos] = '0' + digit;\n        }\n    } else if (type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += '0' + rnd.next(0,9);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", a);\n    cout << s << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -a 10 -type all_ones\n./gen -n 5 -a 0 -type all_zeros\n./gen -n 5 -a 4 -type alternating_zeros_ones\n./gen -n 5 -a 0 -type random\n\n./gen -n 10 -a 15 -type palindrome\n./gen -n 10 -a 99 -type max_digits\n./gen -n 10 -a 0 -type single_non_zero\n\n./gen -n 100 -a 0 -type all_zeros\n./gen -n 100 -a 10000 -type all_ones\n./gen -n 100 -a 1000 -type random\n./gen -n 100 -a 1000 -type few_non_zero -k 10\n./gen -n 100 -a 5000 -type max_digits\n\n./gen -n 1000 -a 1000000 -type random\n./gen -n 1000 -a 0 -type single_non_zero\n./gen -n 1000 -a 500000 -type few_non_zero -k 100\n\n./gen -n 4000 -a 1000000000 -type random\n./gen -n 4000 -a 0 -type all_zeros\n./gen -n 4000 -a 16000000 -type all_ones\n./gen -n 4000 -a 123456789 -type max_digits\n./gen -n 4000 -a 10000 -type palindrome\n\n./gen -n 4000 -a 0 -type few_non_zero -k 1\n./gen -n 4000 -a 100 -type few_non_zero -k 5\n./gen -n 4000 -a 1000 -type few_non_zero -k 10\n\n./gen -n 4000 -a 0 -type alternating_zeros_ones\n./gen -n 4000 -a 2000000 -type all_ones\n./gen -n 4000 -a 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:03.402207",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "365/D",
      "title": "D. Free Market",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, d (1 ≤ n ≤ 50, 1 ≤ d ≤ 104) — the number of items on the market and John's sense of justice value, correspondingly. The second line contains n space-separated integers ci (1 ≤ ci ≤ 104).",
      "output_spec": "OutputPrint two space-separated integers: the maximum possible price in the set of items John can get and the minimum number of days needed to get such set.",
      "sample_tests": "ExamplesInputCopy3 21 3 10OutputCopy4 3InputCopy3 51 2 3OutputCopy6 2InputCopy10 1000010000 9999 1 10000 10000 10000 1 2 3 4OutputCopy50010 6",
      "description": "D. Free Market\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, d (1 ≤ n ≤ 50, 1 ≤ d ≤ 104) — the number of items on the market and John's sense of justice value, correspondingly. The second line contains n space-separated integers ci (1 ≤ ci ≤ 104).\n\nOutputPrint two space-separated integers: the maximum possible price in the set of items John can get and the minimum number of days needed to get such set.\n\nInputCopy3 21 3 10OutputCopy4 3InputCopy3 51 2 3OutputCopy6 2InputCopy10 1000010000 9999 1 10000 10000 10000 1 2 3 4OutputCopy50010 6\n\nInputCopy3 21 3 10\n\nOutputCopy4 3\n\nInputCopy3 51 2 3\n\nOutputCopy6 2\n\nInputCopy10 1000010000 9999 1 10000 10000 10000 1 2 3 4\n\nOutputCopy50010 6\n\nNoteIn the first sample John can act like this:   Take the first item (1 - 0 ≤ 2).  Exchange the first item for the second one (3 - 1 ≤ 2).  Take the first item (1 - 0 ≤ 2).",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 10000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 10000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 10000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", rnd.next(1, 10000));\n    string ci_type = opt<string>(\"ci_type\", \"random\");\n\n    vector<int> ci(n);\n\n    if (ci_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 10000);\n        }\n    } else if (ci_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n    } else if (ci_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 10000;\n        }\n    } else if (ci_type == \"asc\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1 + (9999LL * i) / (n - 1); // ranges from 1 to 10000\n        }\n    } else if (ci_type == \"desc\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 10000 - (9999LL * i) / (n - 1); // ranges from 10000 down to 1\n        }\n    } else if (ci_type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = (i % 2 == 0) ? 1 : 10000;\n        }\n    } else {\n        // Try to parse ci_type as integer\n        int value = stoi(ci_type);\n        value = max(1, min(value, 10000)); // ensure ci stays within [1, 10000]\n        for (int i = 0; i < n; ++i) {\n            ci[i] = value;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, d);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ci[i], i + 1 == n ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", rnd.next(1, 10000));\n    string ci_type = opt<string>(\"ci_type\", \"random\");\n\n    vector<int> ci(n);\n\n    if (ci_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 10000);\n        }\n    } else if (ci_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n        }\n    } else if (ci_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 10000;\n        }\n    } else if (ci_type == \"asc\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1 + (9999LL * i) / (n - 1); // ranges from 1 to 10000\n        }\n    } else if (ci_type == \"desc\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 10000 - (9999LL * i) / (n - 1); // ranges from 10000 down to 1\n        }\n    } else if (ci_type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = (i % 2 == 0) ? 1 : 10000;\n        }\n    } else {\n        // Try to parse ci_type as integer\n        int value = stoi(ci_type);\n        value = max(1, min(value, 10000)); // ensure ci stays within [1, 10000]\n        for (int i = 0; i < n; ++i) {\n            ci[i] = value;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, d);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ci[i], i + 1 == n ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 1 -ci_type min\n./gen -n 1 -d 10000 -ci_type max\n./gen -n 1 -d 5000 -ci_type random\n\n./gen -n 2 -d 1 -ci_type min\n./gen -n 2 -d 10000 -ci_type max\n./gen -n 2 -d 5000 -ci_type alternate\n\n./gen -n 10 -d 1 -ci_type asc\n./gen -n 10 -d 10000 -ci_type desc\n./gen -n 10 -d 5000 -ci_type random\n\n./gen -n 20 -d 1 -ci_type min\n./gen -n 20 -d 10000 -ci_type max\n./gen -n 20 -d 5000 -ci_type random\n\n./gen -n 30 -d 1 -ci_type alternate\n./gen -n 30 -d 10000 -ci_type alternate\n./gen -n 30 -d 5000 -ci_type asc\n\n./gen -n 40 -d 1 -ci_type desc\n./gen -n 40 -d 10000 -ci_type asc\n./gen -n 40 -d 5000 -ci_type random\n\n./gen -n 50 -d 1 -ci_type random\n./gen -n 50 -d 10000 -ci_type random\n./gen -n 50 -d 5000 -ci_type random\n\n./gen -n 50 -d 1 -ci_type min\n./gen -n 50 -d 1 -ci_type max\n./gen -n 50 -d 10000 -ci_type min\n./gen -n 50 -d 10000 -ci_type max\n\n./gen -n 50 -d 5000 -ci_type asc\n./gen -n 50 -d 5000 -ci_type desc\n\n./gen -n 50 -d 2500 -ci_type asc\n./gen -n 50 -d 2500 -ci_type desc\n\n./gen -n 50 -d 1 -ci_type max\n\n./gen -n 50 -d 10000 -ci_type min\n\n./gen -n 50 -d 5000 -ci_type 1000\n./gen -n 50 -d 5000 -ci_type 5000\n\n./gen -n 50 -ci_type random\n\n./gen -n 50\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:05.009814",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "365/E",
      "title": "E. Beautiful Set",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer k (10 ≤ k ≤ 5000) that shows how many numbers the required beautiful set should have.",
      "output_spec": "OutputIn the first line print k space-separated integers that are a beautiful set. If there are multiple such sets, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy10OutputCopy16 18 24 27 36 48 54 72 108 144",
      "description": "E. Beautiful Set\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer k (10 ≤ k ≤ 5000) that shows how many numbers the required beautiful set should have.\n\nOutputIn the first line print k space-separated integers that are a beautiful set. If there are multiple such sets, you are allowed to print any of them.\n\nInputCopy10OutputCopy16 18 24 27 36 48 54 72 108 144\n\nInputCopy10\n\nOutputCopy16 18 24 27 36 48 54 72 108 144",
      "solutions": [
        {
          "title": "Codeforces Round #213 - Codeforces",
          "content": "Hi all! This round is prepared by me, caustique, el_sanchez, KAN, malcolm. I thank Gerald, who has organised our work and helped us with tricky situations, MikeMirzayanov for the system of organasing contest Delinur for the translation.I hope that all problems will be OK and everyone will find intersesting problem for him/her.Winners: div1: lovelymoon niyaznigmatul cerealguy ainu7 cgy4ever div2: dotato netman kybconnor_4 I apologise for the mistakes in statements. I will be more careful in the next time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9625",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 509
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces",
          "content": "That's a part of final editorial. I'm sorry for delay. Please, report me about mistakes and unclear moments in solutions and in my english. A div2Task was to find the least digit, that is not contained in the given number and compare with given k.B div2Good sequence may contain only zeroes or contain some positive number. In the second case such a sequence is not longer than sequence {0, 1, 1, 2, 3, 5, 8, ..., x, y} where y > 109 and x ≤ 109. That's possible to find it using dummy algorithm. In the first case you may use binary search of two pointers.A div1Let's notice that sum in the rectangle (x1, y1, x2, y2) is sum(x1, x2)·sum(y1, y2). Where sum(l, r) = sl + sl + 1 + ... + sr. Then, we have to calc sum(l, r) for every pair (l, r) and count how many segments give us sum x for any possible x (0 ≤ x ≤ 9·|s|). In the end we should enumerate sum on segemnt [x1, x2] and find . There is corner case a = 0.B div1We may assume that John may exchange any subset of his items x to any other subset y, such as s(x) + d ≥ s(y) (it does not matter if x intersects y). We can find all possible sums in subset of elements of the given set of items using standard dp (knapsack problem). John should always exchange all his current set of items to another, because if he had exchanged some subset of x (current set) z to y, we can say that he had exchanged x to . So, we have to find shortest sequence of sets a, such as s(ai + 1) - d ≥ s(ai) for any possible i and a0 = {}. This subtask could be solved using following greedy algorithm. ai, i > 0 is maximal correct sum such as ai ≤ ai - 1 + d. Consider optimal answer c and our answer a. Let k is the first position where ak ≠ ck obiviously ak > ck (because ak selected as maximal as possible). Then consider q such as qi = ci for i ≠ k and qk = ak. q is either optimal. Applying similar operations we will obtain a. So, a is optimal. C div1We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts. Consider the set of divisors of number k. One can check that it's beautiful set. If factorisation of k has the form where αi ≥ 3 and pi is distinct primes, set of divisors of k which is less than is also beautiful. How to prove item 2? Consider set A of pairs of divisors of k (ai, bi) such as ai·bi = k and ai < bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k pα such as and it is not true that . Let f(x) is maximal number s such as . f(ai) + f(bi) = α. For every q such as numbers q, q·p, ..., q·pα will be divisors of k. That implies that where d is number of divisors of . So in pairs both numbers are divisible by p. So set {a0, ..., a|A|} is beautiful. But there are some pairs with f(ai) = α. is equivalent approval. It's always possible to find such k as number of it's divisors is bigger than 2·w where w is number of elements in required set. You may write following dp to find it. dp[i][j] is minimal k which is constructed of first i primes ans has j divisors. About 10 primes is enough to cover all k. Now we can construct beautiful sets with more than k elements. Using item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements. Last items is not strict, but one can check it with his computer.D div1 Consider random element ar of a. With probabillity where g is ghd of a. Let xi = gcd(ai, ar). There are no more than d distinct xi where d is number of divisors of ar. We can find number of ai such as for every k in O(d2). (D is set of divisors of ar) Repeat item 1 x times we will get correct solution with probabillity 1 - 2 - x. There is the way to solve this problem O(n·plog + d·2plog) for iteration where plog is the maximal number of distinct primes in factorisation of ar.E div1 Let's find number of rectangles whick consist k ones and intersect in cartesian coordinate system. It's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the and enumareate all segments [l, r] such as 1 ≤ l ≤ r ≤ n and find closest k ones on the top and on the bottom of the segments merging results for rows. If we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross on [l, r] in O(k). Then we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on. for square-shaped tables. At the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k = 2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #213 - Codeforces - Code 1",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 2",
          "code": "(int) vv.size()==k+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 3",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 4",
          "code": "while(n > 0) {\n    if((n % 10) > k)\n        return false;\n    n /= 10;\n}\n\nreturn true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 5",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 6",
          "code": "1 6\n01234567",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 7",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 8",
          "code": "1 6\n12345670",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 9",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 10",
          "code": "a[i] (1 ≤ a[i] ≤ 10^9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 11",
          "code": "{} -> {1,2}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 12",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 13",
          "code": "typedef int li;",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 14",
          "code": "#define int li",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 15",
          "code": "typedef long long li",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 16",
          "code": "Let's call a number k-good if it contains all digits not exceeding k (0, ..., k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 17",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 18",
          "code": "for (int i = 0; i < d.size(); i++) {\n         for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) cnt[d[j]] += cnt[d[i]]; \n         }\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 19",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 20",
          "code": "if(a%(it->first) ==0 && m.find(a/(it->first))!=m.end() ){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 21",
          "code": "a%(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 - Codeforces - Code 22",
          "code": "a/(it->first)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9625",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 1",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 2",
          "code": "1   - 216\n2   - 108\n3   - 72\n4   - 54\n6   - 36\n8   - 27\n9   - 24\n12  - 18",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 3",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 4",
          "code": "10\n10010 6006 4290 2730 2310 17 19 23 29 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 5",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #213 Editorial - Codeforces - Code 6",
          "code": "a[1] = 3 * 5 * 7\na[2] = 2 * 5 * 7\na[3] = 2 * 3 * 7\ngcd(a[1], a[2]) = 35, gcd(a[2], a[3]) = 14, gcd(a[1], a[3]) = 21. \nHowever gcd(a[1], a[2], a[3]) = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9657",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(10, 5000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(10, 5000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(10, 5000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <=1)\n        return false;\n    if (n ==2 || n == 3)\n        return true;\n    if (n%2 ==0 || n%3==0)\n        return false;\n    for (int i=5; i*i<=n;i+=6){\n        if (n%i==0 || n%(i+2)==0)\n            return false;\n    }\n    return true;\n}\n\nvoid factorize(int n, set<int>& factors) {\n    while (n%2 == 0) {\n        factors.insert(2);\n        n /= 2;\n    }\n    while (n%3 == 0) {\n        factors.insert(3);\n        n /=3;\n    }\n    for (int i =5; i*i<=n; i+=6) {\n        while (n % i == 0) {\n            factors.insert(i);\n            n /= i;\n        }\n        while (n % (i+2) == 0) {\n            factors.insert(i+2);\n            n /= (i+2);\n        }\n    }\n    if (n >1) {\n        factors.insert(n);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int k = inf.readInt(10, 5000, \"k\");\n\n    vector<int> S = ouf.readInts(k, 1, 2*k*k, \"S\");\n    \n    map<int, int> prime_counts;\n    for (int i = 0; i < k; i++) {\n        int n = S[i];\n        set<int> factors;\n        factorize(n, factors);\n        for (int p : factors) {\n            if (!is_prime(p)) {\n                quitf(_wa, \"Found non-prime factor %d in number %d\", p, n);\n            }\n            prime_counts[p]++;\n        }\n    }\n\n    int required = (k + 1) / 2;\n    for (auto &entry : prime_counts) {\n        int p = entry.first;\n        int count = entry.second;\n        if (count < required) {\n            quitf(_wa, \"Prime %d divides %d numbers, less than required %d\", p, count, required);\n        }\n    }\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int min_k = 10;\n    int max_k = 5000;\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        if (type == \"min\") {\n            k = min_k;\n        } else if (type == \"max\") {\n            k = max_k;\n        } else if (type == \"random\") {\n            k = rnd.next(min_k, max_k);\n        } else if (type == \"power2\") {\n            int exponent = rnd.next(4, 12); // 2^4=16 to 2^12=4096 within the range\n            k = 1 << exponent;\n            if (k < min_k) k = min_k;\n            if (k > max_k) k = max_k;\n        } else if (type == \"prime\") {\n            // Generate a random prime number within min_k and max_k\n            vector<int> primes;\n            for (int num = min_k; num <= max_k; ++num) {\n                bool is_prime = true;\n                for (int i = 2; i * i <= num; ++i) {\n                    if (num % i == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n                if (is_prime)\n                    primes.push_back(num);\n            }\n            if (!primes.empty())\n                k = primes[rnd.next((int)primes.size())];\n            else\n                k = min_k; // Default if no prime found\n        } else {\n            k = rnd.next(min_k, max_k);\n        }\n    } else {\n        // Ensure k is within limits\n        if (k < min_k) k = min_k;\n        if (k > max_k) k = max_k;\n    }\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int min_k = 10;\n    int max_k = 5000;\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        if (type == \"min\") {\n            k = min_k;\n        } else if (type == \"max\") {\n            k = max_k;\n        } else if (type == \"random\") {\n            k = rnd.next(min_k, max_k);\n        } else if (type == \"power2\") {\n            int exponent = rnd.next(4, 12); // 2^4=16 to 2^12=4096 within the range\n            k = 1 << exponent;\n            if (k < min_k) k = min_k;\n            if (k > max_k) k = max_k;\n        } else if (type == \"prime\") {\n            // Generate a random prime number within min_k and max_k\n            vector<int> primes;\n            for (int num = min_k; num <= max_k; ++num) {\n                bool is_prime = true;\n                for (int i = 2; i * i <= num; ++i) {\n                    if (num % i == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n                if (is_prime)\n                    primes.push_back(num);\n            }\n            if (!primes.empty())\n                k = primes[rnd.next((int)primes.size())];\n            else\n                k = min_k; // Default if no prime found\n        } else {\n            k = rnd.next(min_k, max_k);\n        }\n    } else {\n        // Ensure k is within limits\n        if (k < min_k) k = min_k;\n        if (k > max_k) k = max_k;\n    }\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum k\n./gen -type min\n\n# Maximum k\n./gen -type max\n\n# Random k values\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# k as powers of two\n./gen -type power2\n\n# k as a prime number\n./gen -type prime\n\n# Specific k values to test edge cases\n./gen -k 10\n./gen -k 11\n./gen -k 4999\n./gen -k 5000\n\n# Random k values within the allowed range\n./gen -k 100\n./gen -k 500\n./gen -k 1000\n./gen -k 2000\n./gen -k 3000\n./gen -k 4000\n./gen -k 4500\n\n# Random k values with specified types\n./gen -type power2\n./gen -type prime\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Testing k values just below and above certain thresholds\n./gen -k 999\n./gen -k 1001\n./gen -k 1999\n./gen -k 2001\n./gen -k 2999\n./gen -k 3001\n\n# Edge k values around powers of two\n./gen -k 1023\n./gen -k 1024\n./gen -k 1025\n./gen -k 2047\n./gen -k 2048\n./gen -k 2049\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:07.380521",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "366/A",
      "title": "A. Дима и вахта",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит целое число n (1 ≤ n ≤ 105) — количество денег, которое хочет потратить Дима. Далее следуют четыре строки, описывающие вахты. Каждая строка содержит по четыре целых числа a, b, c, d (1 ≤ a, b, c, d ≤ 105) — минимальная цена шоколадки и минимальная цена сока для первой вахтерши, минимальная цена шоколадки и минимальная цена сока для второй вахтерши соответственно.",
      "output_spec": "Выходные данныеВ единственной строке выходных данных через пробел выведите три целых числа: номер вахты, стоимость первого угощения и стоимость второго угощения. Если нет вахты, через которую Дима может провести Инну при таких условиях, в единственной строке выведите -1. Вахты нумеруются от 1 до 4 в соответствии с порядком, указанном во входных данных.Если существует несколько решений, разрешается вывести любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать105 6 5 66 6 7 75 8 6 69 9 9 9Выходные данныеСкопировать1 5 5Входные данныеСкопировать106 6 6 67 7 7 74 4 4 48 8 8 8Выходные данныеСкопировать3 4 6Входные данныеСкопировать53 3 3 33 3 3 33 3 3 33 3 3 3Выходные данныеСкопировать-1",
      "description": "A. Дима и вахта\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит целое число n (1 ≤ n ≤ 105) — количество денег, которое хочет потратить Дима. Далее следуют четыре строки, описывающие вахты. Каждая строка содержит по четыре целых числа a, b, c, d (1 ≤ a, b, c, d ≤ 105) — минимальная цена шоколадки и минимальная цена сока для первой вахтерши, минимальная цена шоколадки и минимальная цена сока для второй вахтерши соответственно.\n\nВходные данные\n\nВыходные данныеВ единственной строке выходных данных через пробел выведите три целых числа: номер вахты, стоимость первого угощения и стоимость второго угощения. Если нет вахты, через которую Дима может провести Инну при таких условиях, в единственной строке выведите -1. Вахты нумеруются от 1 до 4 в соответствии с порядком, указанном во входных данных.Если существует несколько решений, разрешается вывести любое.\n\nВыходные данные\n\nВходные данныеСкопировать105 6 5 66 6 7 75 8 6 69 9 9 9Выходные данныеСкопировать1 5 5Входные данныеСкопировать106 6 6 67 7 7 74 4 4 48 8 8 8Выходные данныеСкопировать3 4 6Входные данныеСкопировать53 3 3 33 3 3 33 3 3 33 3 3 3Выходные данныеСкопировать-1\n\nВходные данныеСкопировать105 6 5 66 6 7 75 8 6 69 9 9 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 5 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать106 6 6 67 7 7 74 4 4 48 8 8 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 4 6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать53 3 3 33 3 3 33 3 3 33 3 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснение к примеру 1.Единственным способом потратить 10 рублей, купив угощения, которые будут не меньше установленной вахтой цен, будет купить обоим вахтершам из первой вахты шоколадку по 5 рублей.Пояснение к примеру 2.Чтобы задобрить первую вахту, нужно 12 рублей, вторую — 14, четвертую — 16. Поэтому, единственная вахта, которую мы можем задобрить — третья. Собственно, мы можем купить шоколадку за 4 рубля первой вахтерше и сок за 6 рублей второй.",
      "solutions": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Доброго времени суток! Скоро состоится мероприятие под названием Codeforces Round #214 (Div. 2), автором которого являюсь я, Дмитрий Березин. Это мой второй раунд, и Сережа надеется, что последний :)Личная жизнь — такое дело, в котором много счастья не бывает, поэтому вам снова нужно будет помочь Диме и Инне. И да, Сережа вовсе не выступает в роли негативного персонажа, скорее, в роли обстоятельств, с которыми вам придется порой бороться...Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда, Марии Беловой (Delinur) за перевод задач, и Сереже Нагину (Sereja) за то, что любезно (покидает комнату) согласился помочь в тестировании.Сережа передает привет, и настоятельно рекомендует прочитать условия ВСЕХ задач.Разбалловку скажу, честно. А разбалловка 500-1000-1500-2000-2500.Спасибо за внимание, хорошего раунда!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 837
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Доброго времени суток! Скоро состоится мероприятие под названием Codeforces Round #214 (Div. 2), автором которого являюсь я, Дмитрий Березин. Это мой второй раунд, и Сережа надеется, что последний :)Личная жизнь — такое дело, в котором много счастья не бывает, поэтому вам снова нужно будет помочь Диме и Инне. И да, Сережа вовсе не выступает в роли негативного персонажа, скорее, в роли обстоятельств, с которыми вам придется порой бороться...Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда, Марии Беловой (Delinur) за перевод задач, и Сереже Нагину (Sereja) за то, что любезно (покидает комнату) согласился помочь в тестировании.Сережа передает привет, и настоятельно рекомендует прочитать условия ВСЕХ задач.Разбалловку скажу, честно. А разбалловка 500-1000-1500-2000-2500.Спасибо за внимание, хорошего раунда!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 837
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces",
          "content": "366A — Дима и вахтаЗаметим, что решения не существует, если самый дешевый способ стоит больше n. В противном случае всегда можно доплатить за любое угощение, дополнив суммарную стоимость до n.Найдем самый дешевый способ. Очевидно, что каждой вахтерше лучше покупать то угощение, минимальная цена которого меньше. То есть, если есть вахта с параметрами a b c d, то стоимость минимального подкупа будет min(a, b) + min(c, d). Выберем вахту с наименьшей минимальной стоимость подкупа. Если она больше n, ответ -1. Иначе, ответом может быть, к примеру: Номер вахты, min(a, b), n–min(a, b).366B — Дима и делаДима успевает сделать спокойно k–1 дело, то есть Инна всегда ругает его за k-ое дело, начиная с выбранного Димой первого дела. Таким образом, ответ для дел с одинаковым остатком от деления на k будет одинаковым, вывести нужно ответ с минимальным номером первого дела, поэтому достаточно посчитать суммы “руганий” для дел 0, 1... k–1. Это можно сделать к примеру так: Завести массив int sum[k]. И при считывании числа сразу определять его в соответствующую ячейку:sum[I mod k] +  = a[i]. Теперь осталось выбрать первое i такое, что sum[i] минимальное. Сложность решения O(N).366C — Дима и салатБудем поддерживать динамику d[num][balance] где num – последний рассмотренный фрукт, balance – разница между суммами выбранных калорийностей и вкусностей. Умножим все b на k. Тогда ответом будет d[n][0]. d[num][balance] = максимально возможной сумме вкусностей.Переход: из d[num][balance] можно осуществить так:d[num + 1][balance] = max(d[num + 1][balance], d[num][balance]) – если мы не берем фрукт.d[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance + a[i] - b[i]·k], d[num][balance] + a[i]) – если берем.На самом деле, баланс может быть отрицательным, поэтому в языках программирования, не поддерживающих отрицательную индексацию, индексы баланса нужно сдвинуть на самое большое отрицательное число, которым может стать баланс. Если баланс – сумма каллорийностей минус сумма вкусностей, то это сумма всех вкусностей всех фруктов.366D — Дима и граф-ловушкаОчевидно, что лояльность пути – это ширина диапазона, с которым его можно пройти, а диапазон этот – пересечение диапазонов ребер пути. Это выплывает из того, что числа является валидным для пути, если с ним можно пройти через все ребра. Переберем все ребра графа, пусть левая граница диапазона на ребре – это левая граница пересечения. Это значит, что мы не можем использовать ребра, у которых левая граница не больше нашей. Переберем все правые границы, считая ответом диапазон с зафиксированной ранее левой границей и выбранной нами правой. Такой ответ существует, если можно пройти из первой вершины в последнюю с выбранными ограничениями. Проверим граф на связность выбирая только ребра с левой границей не больше нашей, и правой границей не меньше нашей. Если граф связный, обновляем ответ. Заметим, что правую границу можно перебирать с помощью бин поиска, таким образом итоговая сложность решения O(M2·logM).366E — Дима и волшебная гитараЗадача имеет несколько решений. Опишу авторское, с остальными вы можете ознакомиться, посмотрев решения участников. Очевидно, что для нахождения ответа нужно посчитать матрицу maxDis[k][k], где maxDis[i][j] – максимальная сложность перехода между нотами i и j. Тогда останется пройтись по песне, и обновлять ответ для каждой пары соседних нот. Давайте подумаем, как можно быстро посчитать матрицу.Для каждого места (x1, y1) на гитаре переберем все места (x2, y2) такие, что y2 ≤ y1. Если (x2 ≤ x1) расстояние будет x1–x2 + y1–y2. И значит, нас интересует минимальное значение x2 + y2 в подматрице от (0, 0) до (x, y).Если (x2 ≥ x1) расстояние будет x2–x1 + y1–y2. И значит, нас интересует максимальное значение x2–y2 в подматрице от (n–1, 0) до (x, y).Будем считать эти значения для каждой ноты. Памяти нужно слишком много, но можно хранить только предыдущую строчку динамики для каждой ноты. Для каждой ячейки обновим динамику для всех нот, и для нашей ноты (которая и лежит в этой ячейке) сравним значение (i + j) или (i–j) с текущим в динамике.Сложность O(N·M·K)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 366\\s*A"
          },
          "content_length": 4073
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 1",
          "code": "1 5 4 3\n4 1 2 4 3\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 2",
          "code": "1 5 4 3\n4 1 2 4 3\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 3",
          "code": "a[i+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 4",
          "code": "dp[i][balance+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 5",
          "code": "3 3  \n1 2 1 1  \n1 2 2 2  \n2 3 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 6",
          "code": "3 3  \n1 2 1 1  \n1 2 2 2  \n2 3 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 7",
          "code": "d[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance + a[i] - b[i]·k], d[num][balance] + a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 8",
          "code": "d[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance + a[i] - b[i]·k], d[num][balance] + a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 9",
          "code": "d[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance], d[num][balance + a[i] - b[i]·k] + a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 10",
          "code": "d[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance], d[num][balance + a[i] - b[i]·k] + a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 11",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 12",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 13",
          "code": "dp[i+1][summation + a[i]]<<=b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Разбор - Codeforces - Code 14",
          "code": "we will shift every summation of calories by b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < 4; ++i) {\n        int a = inf.readInt(1, 100000);\n        inf.readSpace();\n        int b = inf.readInt(1, 100000);\n        inf.readSpace();\n        int c = inf.readInt(1, 100000);\n        inf.readSpace();\n        int d = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < 4; ++i) {\n        int a = inf.readInt(1, 100000);\n        inf.readSpace();\n        int b = inf.readInt(1, 100000);\n        inf.readSpace();\n        int c = inf.readInt(1, 100000);\n        inf.readSpace();\n        int d = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < 4; ++i) {\n        int a = inf.readInt(1, 100000);\n        inf.readSpace();\n        int b = inf.readInt(1, 100000);\n        inf.readSpace();\n        int c = inf.readInt(1, 100000);\n        inf.readSpace();\n        int d = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Guardpost {\n    int minChoc[2];\n    int minJuice[2];\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n\n    Guardpost guardposts[4];\n    for (int i = 0; i < 4; i++) {\n        int a = inf.readInt(1, 100000, \"a\");\n        int b = inf.readInt(1, 100000, \"b\");\n        int c = inf.readInt(1, 100000, \"c\");\n        int d = inf.readInt(1, 100000, \"d\");\n        guardposts[i].minChoc[0] = a;\n        guardposts[i].minJuice[0] = b;\n        guardposts[i].minChoc[1] = c;\n        guardposts[i].minJuice[1] = d;\n    }\n\n    int ansGuardpost = ans.readInt(-1, 4, \"ansGuardpost\");\n    if (ansGuardpost != -1) {\n        ans.readInt(1, 100000, \"ansGift1\");\n        ans.readInt(1, 100000, \"ansGift2\");\n    }\n\n    int oufGuardpost = ouf.readInt(-1, 4, \"guardpost number\");\n\n    if (oufGuardpost == -1) {\n        if (ansGuardpost == -1) {\n            quitf(_ok, \"No solution as expected\");\n        } else {\n            quitf(_wa, \"Participant reports no solution, but a solution exists\");\n        }\n    } else {\n        // Participant outputs a solution, need to validate it\n        if (oufGuardpost < 1 || oufGuardpost > 4) {\n            quitf(_wa, \"Invalid guardpost number: %d\", oufGuardpost);\n        }\n        int gift1 = ouf.readInt(1, n, \"gift1\");\n        int gift2 = ouf.readInt(1, n, \"gift2\");\n\n        if (gift1 + gift2 != n) {\n            quitf(_wa, \"The sum of gifts is not equal to n: %d + %d != %d\", gift1, gift2, n);\n        }\n\n        Guardpost gp = guardposts[oufGuardpost - 1];\n\n        bool guard0_ok = (gift1 >= gp.minChoc[0]) || (gift1 >= gp.minJuice[0]);\n        bool guard1_ok = (gift2 >= gp.minChoc[1]) || (gift2 >= gp.minJuice[1]);\n\n        if (!guard0_ok) {\n            quitf(_wa, \"First gift does not satisfy minimum acceptable price for guard 1 of guardpost %d\", oufGuardpost);\n        }\n\n        if (!guard1_ok) {\n            quitf(_wa, \"Second gift does not satisfy minimum acceptable price for guard 2 of guardpost %d\", oufGuardpost);\n        }\n\n        if (ansGuardpost == -1) {\n            quitf(_fail, \"Participant found a solution where jury says impossible\");\n        } else {\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<array<int, 4>> guardposts(4);\n\n    if (type == \"possible_exact\") {\n        // Guardpost 1: total minimal prices sum to n\n        int min_choc1 = rnd.next(1, n - 1);\n        int min_choc2 = n - min_choc1;\n        int big = n + rnd.next(1, 10000);\n        // Guardpost 1\n        guardposts[0][0] = min_choc1; // a\n        guardposts[0][1] = big;       // b\n        guardposts[0][2] = min_choc2; // c\n        guardposts[0][3] = big;       // d\n\n        // Other guardposts: impossible\n        for (int i = 1; i < 4; ++i) {\n            int big_min = n + rnd.next(1, 10000);\n            guardposts[i][0] = big_min;\n            guardposts[i][1] = big_min;\n            guardposts[i][2] = big_min;\n            guardposts[i][3] = big_min;\n        }\n    } else if (type == \"possible_over\") {\n        // Guardpost 1: minimal prices sum less than n\n        int min_choc1 = rnd.next(1, n / 2);\n        int min_choc2 = rnd.next(1, n / 2);\n        while (min_choc1 + min_choc2 >= n) {\n            min_choc1 = rnd.next(1, n / 2);\n            min_choc2 = rnd.next(1, n / 2);\n        }\n        int big = n + rnd.next(1, 10000);\n        guardposts[0][0] = min_choc1; // a\n        guardposts[0][1] = big;       // b\n        guardposts[0][2] = min_choc2; // c\n        guardposts[0][3] = big;       // d\n\n        // Other guardposts: impossible\n        for (int i = 1; i < 4; ++i) {\n            int big_min = n + rnd.next(1, 10000);\n            guardposts[i][0] = big_min;\n            guardposts[i][1] = big_min;\n            guardposts[i][2] = big_min;\n            guardposts[i][3] = big_min;\n        }\n    } else if (type == \"impossible\") {\n        // All guardposts impossible\n        int min_price = n / 2 + 1;\n        for (int i = 0; i < 4; ++i) {\n            guardposts[i][0] = min_price;\n            guardposts[i][1] = min_price;\n            guardposts[i][2] = min_price;\n            guardposts[i][3] = min_price;\n        }\n    } else if (type == \"edge_n_min\") {\n        n = 1; // Override n\n        // Guardpost 1: possible\n        guardposts[0][0] = 1;\n        guardposts[0][1] = 1;\n        guardposts[0][2] = 1;\n        guardposts[0][3] = 1;\n        // Other guardposts: impossible\n        int big = 2;\n        for (int i = 1; i < 4; ++i) {\n            guardposts[i][0] = big;\n            guardposts[i][1] = big;\n            guardposts[i][2] = big;\n            guardposts[i][3] = big;\n        }\n    } else if (type == \"edge_n_max\") {\n        n = 100000; // Override n\n        int min_choc1 = rnd.next(1, n / 2);\n        int min_choc2 = n - min_choc1 - rnd.next(1, n / 10);\n        if (min_choc2 < 1) min_choc2 = 1;\n        guardposts[0][0] = min_choc1; // a\n        guardposts[0][1] = n + rnd.next(1, 10000); // b\n        guardposts[0][2] = min_choc2; // c\n        guardposts[0][3] = n + rnd.next(1, 10000); // d\n\n        // Other guardposts: impossible\n        for (int i = 1; i < 4; ++i) {\n            int big_min = n + rnd.next(1, 10000);\n            guardposts[i][0] = big_min;\n            guardposts[i][1] = big_min;\n            guardposts[i][2] = big_min;\n            guardposts[i][3] = big_min;\n        }\n    } else if (type == \"random\") {\n        // Generate random minimal acceptable prices\n        for (int i = 0; i < 4; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                guardposts[i][j] = rnd.next(1, min(n, 100000));\n            }\n        }\n    } else {\n        // Default: output impossible case\n        int min_price = n / 2 + 1;\n        for (int i = 0; i < 4; ++i) {\n            guardposts[i][0] = min_price;\n            guardposts[i][1] = min_price;\n            guardposts[i][2] = min_price;\n            guardposts[i][3] = min_price;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output guardposts\n    for (int i = 0; i < 4; ++i) {\n        printf(\"%d %d %d %d\\n\",\n               guardposts[i][0], guardposts[i][1],\n               guardposts[i][2], guardposts[i][3]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<array<int, 4>> guardposts(4);\n\n    if (type == \"possible_exact\") {\n        // Guardpost 1: total minimal prices sum to n\n        int min_choc1 = rnd.next(1, n - 1);\n        int min_choc2 = n - min_choc1;\n        int big = n + rnd.next(1, 10000);\n        // Guardpost 1\n        guardposts[0][0] = min_choc1; // a\n        guardposts[0][1] = big;       // b\n        guardposts[0][2] = min_choc2; // c\n        guardposts[0][3] = big;       // d\n\n        // Other guardposts: impossible\n        for (int i = 1; i < 4; ++i) {\n            int big_min = n + rnd.next(1, 10000);\n            guardposts[i][0] = big_min;\n            guardposts[i][1] = big_min;\n            guardposts[i][2] = big_min;\n            guardposts[i][3] = big_min;\n        }\n    } else if (type == \"possible_over\") {\n        // Guardpost 1: minimal prices sum less than n\n        int min_choc1 = rnd.next(1, n / 2);\n        int min_choc2 = rnd.next(1, n / 2);\n        while (min_choc1 + min_choc2 >= n) {\n            min_choc1 = rnd.next(1, n / 2);\n            min_choc2 = rnd.next(1, n / 2);\n        }\n        int big = n + rnd.next(1, 10000);\n        guardposts[0][0] = min_choc1; // a\n        guardposts[0][1] = big;       // b\n        guardposts[0][2] = min_choc2; // c\n        guardposts[0][3] = big;       // d\n\n        // Other guardposts: impossible\n        for (int i = 1; i < 4; ++i) {\n            int big_min = n + rnd.next(1, 10000);\n            guardposts[i][0] = big_min;\n            guardposts[i][1] = big_min;\n            guardposts[i][2] = big_min;\n            guardposts[i][3] = big_min;\n        }\n    } else if (type == \"impossible\") {\n        // All guardposts impossible\n        int min_price = n / 2 + 1;\n        for (int i = 0; i < 4; ++i) {\n            guardposts[i][0] = min_price;\n            guardposts[i][1] = min_price;\n            guardposts[i][2] = min_price;\n            guardposts[i][3] = min_price;\n        }\n    } else if (type == \"edge_n_min\") {\n        n = 1; // Override n\n        // Guardpost 1: possible\n        guardposts[0][0] = 1;\n        guardposts[0][1] = 1;\n        guardposts[0][2] = 1;\n        guardposts[0][3] = 1;\n        // Other guardposts: impossible\n        int big = 2;\n        for (int i = 1; i < 4; ++i) {\n            guardposts[i][0] = big;\n            guardposts[i][1] = big;\n            guardposts[i][2] = big;\n            guardposts[i][3] = big;\n        }\n    } else if (type == \"edge_n_max\") {\n        n = 100000; // Override n\n        int min_choc1 = rnd.next(1, n / 2);\n        int min_choc2 = n - min_choc1 - rnd.next(1, n / 10);\n        if (min_choc2 < 1) min_choc2 = 1;\n        guardposts[0][0] = min_choc1; // a\n        guardposts[0][1] = n + rnd.next(1, 10000); // b\n        guardposts[0][2] = min_choc2; // c\n        guardposts[0][3] = n + rnd.next(1, 10000); // d\n\n        // Other guardposts: impossible\n        for (int i = 1; i < 4; ++i) {\n            int big_min = n + rnd.next(1, 10000);\n            guardposts[i][0] = big_min;\n            guardposts[i][1] = big_min;\n            guardposts[i][2] = big_min;\n            guardposts[i][3] = big_min;\n        }\n    } else if (type == \"random\") {\n        // Generate random minimal acceptable prices\n        for (int i = 0; i < 4; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                guardposts[i][j] = rnd.next(1, min(n, 100000));\n            }\n        }\n    } else {\n        // Default: output impossible case\n        int min_price = n / 2 + 1;\n        for (int i = 0; i < 4; ++i) {\n            guardposts[i][0] = min_price;\n            guardposts[i][1] = min_price;\n            guardposts[i][2] = min_price;\n            guardposts[i][3] = min_price;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output guardposts\n    for (int i = 0; i < 4; ++i) {\n        printf(\"%d %d %d %d\\n\",\n               guardposts[i][0], guardposts[i][1],\n               guardposts[i][2], guardposts[i][3]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type possible_exact\n./gen -n 20 -type possible_exact\n./gen -n 99999 -type possible_exact\n./gen -n 1000 -type possible_exact\n\n./gen -n 10 -type possible_over\n./gen -n 1000 -type possible_over\n./gen -n 99999 -type possible_over\n./gen -n 50000 -type possible_over\n\n./gen -n 5 -type impossible\n./gen -n 100 -type impossible\n./gen -n 100000 -type impossible\n./gen -n 50000 -type impossible\n\n./gen -n 1 -type edge_n_min\n\n./gen -n 100000 -type edge_n_max\n\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n\n./gen -n 1000 -type random\n./gen -n 2000 -type random\n./gen -n 5000 -type random\n./gen -n 10000 -type random\n\n# The following commands generate more random test cases\n./gen -n 99999 -type random\n./gen -n 12345 -type random\n./gen -n 54321 -type random\n./gen -n 67890 -type random\n./gen -n 98765 -type random\n./gen -n 24680 -type random\n./gen -n 13579 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:09.948135",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "366/B",
      "title": "B. Dima and To-do List",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n, k (1 ≤ k ≤ n ≤ 105). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 103), where ai is the power Inna tells Dima off with if she is present in the room while he is doing the i-th task.It is guaranteed that n is divisible by k.",
      "output_spec": "OutputIn a single line print the number of the task Dima should start with to get told off with as little power as possible. If there are multiple solutions, print the one with the minimum number of the first task to do.",
      "sample_tests": "ExamplesInputCopy6 23 2 1 6 5 4OutputCopy1InputCopy10 51 3 5 7 9 9 4 1 8 5OutputCopy3",
      "description": "B. Dima and To-do List\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n, k (1 ≤ k ≤ n ≤ 105). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 103), where ai is the power Inna tells Dima off with if she is present in the room while he is doing the i-th task.It is guaranteed that n is divisible by k.\n\nOutputIn a single line print the number of the task Dima should start with to get told off with as little power as possible. If there are multiple solutions, print the one with the minimum number of the first task to do.\n\nInputCopy6 23 2 1 6 5 4OutputCopy1InputCopy10 51 3 5 7 9 9 4 1 8 5OutputCopy3\n\nInputCopy6 23 2 1 6 5 4\n\nOutputCopy1\n\nInputCopy10 51 3 5 7 9 9 4 1 8 5\n\nOutputCopy3\n\nNoteExplanation of the first example.If Dima starts from the first task, Inna tells him off with power 3, then Dima can do one more task (as k = 2), then Inna tells him off for the third task with power 1, then she tells him off for the fifth task with power 5. Thus, Dima gets told off with total power 3 + 1 + 5 = 9. If Dima started from the second task, for example, then Inna would tell him off for tasks 2, 4 and 6 with power 2 + 6 + 4 = 12. Explanation of the second example.In the second example k = 5, thus, Dima manages to complete 4 tasks in-between the telling off sessions. Thus, Inna tells Dima off for tasks number 1 and 6 (if he starts from 1 or 6), 2 and 7 (if he starts from 2 or 7) and so on. The optimal answer is to start from task 3 or 8, 3 has a smaller number, so the answer is 3.",
      "solutions": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces",
          "content": "366A — Dima and GuardsThe solution doesn't exist only if the mimimal way to bribe is grater than n. Otherwise we can increase the gift price to make price1 + price2 = n.Let's find the miminal way to bribe. We should buy that gift for old lady which costs less. It means, if we have 2 guards with params a b c d, then minimum bribe price will be min(a, b) + min(c, d). Let's choose the guard with the minimal bribe price. If the minimal bribe price is greater than n, answer -1. Otherwise, the possible answer is, for example: Guard number, min(a, b), n–min(a, b).366B — Dima and To-do ListDima can make k–1 tasks, so Inna always tells him off for each k-th taks, beginning from the chosen place. So for the numbers with same modulo by k the answer will be the same. We should find the answer with minimal first task number so it is eniugh to calculate the sums of “tellings of” for tasks 0, 1... k–1. We can do it in such way: Determine the array int sum[k]. And put the number into appropriate bucket while reading:sum[I mod k] +  = a[i]. Now we should simply find first i with minimal sum[i].Complexity: O(N).366C — Dima and SaladLet's calculate dinamic: d[num][balance] where num – last looked fruit, balance — difference between sum of colories and sum of tastes. Let's multiply each b by k. The answer will be d[n][0]. d[num][balance] = maximal possible sum of tastes under conditions.Step: from d[num][balance] we can relax answers:d[num + 1][balance] = max(d[num + 1][balance], d[num][balance]) – if we don't choose a fruitd[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance + a[i] - b[i]·k], d[num][balance] + a[i]) – if we choose a fruit.Balance can be negative, so in programming languages which don't support negative indexation, indexes should be shifted by the biggest negative number for balance. If we determine the balance as sum(b·k) - sum(a) it will be the sum of all tastes.366D — Dima and Trap GraphThe answer for some path is a range under which we can go all the way, and this range is the intersection of all the ranges on the path. We can conclude it because the number is valid for path if it is valid for all ranges in the path. We will iterate all ribs. Let the left board of range on a rib is the left board of our intersection. It means we can't use ribs whith left board greater than ours. Lets iterate all right boards, determining the answer as the range from fixed left board to the chosen right. This answer exists if we have any path from the first node to the last. Let's check if the graph is connected if we leave only ribs with left board not greater than our and right board not less than our. If the graph is connected — let's update the answer. Right board can be found by binary search so the complexity is O(M2·logM).366E — Dima and Magic GuitarThere are many solutions for this task. I will describe my, you can deal with other by looking participants code. To find the answer we should calculate maxDis[k][k], where maxDis[i][j] – maximal complexity from note i to note j. Now we should only iterate the song updating answer for each pair of adjacent notes. Let's think how we can calculate the matrix.For each place (x1, y1) on the guitar let's iterate pairs (x2, y2) with y2 ≤ y1. If (x2 ≤ x1) distance will be x1–x2 + y1–y2. So we should find minimal x2 + y2 in submatrix from (0, 0) to (x, y).If (x2 ≥ x1) distance will be x2–x1 + y1–y2. So we should find maximal x2–y2 in submatrix from (n–1, 0) до (x, y).We will calculate this values for each note. We need too much memory so we should memorize only one previous row for each note. For each place we will update dinamics for both variants according to already calculated and for our own note (which is in this cell) we will also compare (i + j) or (i–j) with current value in the cell.Complexity O(N·M·K)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 366\\s*B"
          },
          "content_length": 3816
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "a[i+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "dp[i][balance+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i+1][summation + a[i]]<<=b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "we will shift every summation of calories by b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    ensuref(n % k == 0, \"n must be divisible by k\");\n    inf.readInts(n, 1, 1000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    ensuref(n % k == 0, \"n must be divisible by k\");\n    inf.readInts(n, 1, 1000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    ensuref(n % k == 0, \"n must be divisible by k\");\n    inf.readInts(n, 1, 1000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string t = opt<string>(\"t\", \"random\");\n\n    // Ensure constraints: 1 ≤ k ≤ n ≤ 1e5, n divisible by k\n    ensure(1 <= k && k <= n && n <= 100000);\n    ensure(n % k == 0);\n\n    vector<int> a(n);\n\n    if (t == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if (t == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000;\n        }\n    } else if (t == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (t == \"same\") {\n        int val = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (t == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = min(val + rnd.next(0, 10), 1000);\n        }\n    } else if (t == \"decreasing\") {\n        int val = 1000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = max(val - rnd.next(0, 10), 1);\n        }\n    } else if (t == \"bigFirst\") {\n        a[0] = 1000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (t == \"bigLast\") {\n        for (int i = 0; i < n -1; ++i) {\n            a[i] = 1;\n        }\n        a[n-1] = 1000;\n    } else {\n        cerr << \"Unknown type: \" << t << endl;\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output ai values\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string t = opt<string>(\"t\", \"random\");\n\n    // Ensure constraints: 1 ≤ k ≤ n ≤ 1e5, n divisible by k\n    ensure(1 <= k && k <= n && n <= 100000);\n    ensure(n % k == 0);\n\n    vector<int> a(n);\n\n    if (t == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if (t == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000;\n        }\n    } else if (t == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (t == \"same\") {\n        int val = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (t == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = min(val + rnd.next(0, 10), 1000);\n        }\n    } else if (t == \"decreasing\") {\n        int val = 1000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = max(val - rnd.next(0, 10), 1);\n        }\n    } else if (t == \"bigFirst\") {\n        a[0] = 1000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (t == \"bigLast\") {\n        for (int i = 0; i < n -1; ++i) {\n            a[i] = 1;\n        }\n        a[n-1] = 1000;\n    } else {\n        cerr << \"Unknown type: \" << t << endl;\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output ai values\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random ai\n./gen -n 6 -k 1 -t random\n./gen -n 6 -k 2 -t random\n./gen -n 6 -k 3 -t random\n./gen -n 6 -k 6 -t random\n\n# Small n, same ai\n./gen -n 6 -k 2 -t same\n\n# Small n, min ai\n./gen -n 6 -k 2 -t min\n\n# Small n, max ai\n./gen -n 6 -k 2 -t max\n\n# Small n, increasing ai\n./gen -n 6 -k 2 -t increasing\n\n# Small n, decreasing ai\n./gen -n 6 -k 2 -t decreasing\n\n# Small n, bigFirst\n./gen -n 6 -k 2 -t bigFirst\n\n# Small n, bigLast\n./gen -n 6 -k 2 -t bigLast\n\n# Medium n = 1000, various k\n\n# Random ai\n./gen -n 1000 -k 1 -t random\n./gen -n 1000 -k 10 -t random\n./gen -n 1000 -k 100 -t random\n./gen -n 1000 -k 250 -t random\n./gen -n 1000 -k 500 -t random\n./gen -n 1000 -k 1000 -t random\n\n# Max ai\n./gen -n 1000 -k 1 -t max\n./gen -n 1000 -k 1000 -t max\n\n# Min ai\n./gen -n 1000 -k 1 -t min\n./gen -n 1000 -k 1000 -t min\n\n# Same ai\n./gen -n 1000 -k 100 -t same\n\n# Increasing ai\n./gen -n 1000 -k 100 -t increasing\n\n# Decreasing ai\n./gen -n 1000 -k 100 -t decreasing\n\n# bigFirst\n./gen -n 1000 -k 100 -t bigFirst\n\n# bigLast\n./gen -n 1000 -k 100 -t bigLast\n\n# Large n = 100000, various k\n\n# Random ai\n./gen -n 100000 -k 1 -t random\n./gen -n 100000 -k 2 -t random\n./gen -n 100000 -k 50000 -t random\n./gen -n 100000 -k 100000 -t random\n\n# Max ai\n./gen -n 100000 -k 1 -t max\n./gen -n 100000 -k 100000 -t max\n\n# Min ai\n./gen -n 100000 -k 1 -t min\n./gen -n 100000 -k 100000 -t min\n\n# Same ai\n./gen -n 100000 -k 25000 -t same\n\n# Increasing ai\n./gen -n 100000 -k 10000 -t increasing\n\n# Decreasing ai\n./gen -n 100000 -k 10000 -t decreasing\n\n# bigFirst\n./gen -n 100000 -k 10000 -t bigFirst\n\n# bigLast\n./gen -n 100000 -k 10000 -t bigLast\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:12.283163",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "366/C",
      "title": "C. Dima and Salad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n, k (1 ≤ n ≤ 100, 1 ≤ k ≤ 10). The second line of the input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the fruits' tastes. The third line of the input contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100) — the fruits' calories. Fruit number i has taste ai and calories bi.",
      "output_spec": "OutputIf there is no way Inna can choose the fruits for the salad, print in the single line number -1. Otherwise, print a single integer — the maximum possible sum of the taste values of the chosen fruits.",
      "sample_tests": "ExamplesInputCopy3 210 8 12 7 1OutputCopy18InputCopy5 34 4 4 4 42 2 2 2 2OutputCopy-1",
      "description": "C. Dima and Salad\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n, k (1 ≤ n ≤ 100, 1 ≤ k ≤ 10). The second line of the input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the fruits' tastes. The third line of the input contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100) — the fruits' calories. Fruit number i has taste ai and calories bi.\n\nOutputIf there is no way Inna can choose the fruits for the salad, print in the single line number -1. Otherwise, print a single integer — the maximum possible sum of the taste values of the chosen fruits.\n\nInputCopy3 210 8 12 7 1OutputCopy18InputCopy5 34 4 4 4 42 2 2 2 2OutputCopy-1\n\nInputCopy3 210 8 12 7 1\n\nOutputCopy18\n\nInputCopy5 34 4 4 4 42 2 2 2 2\n\nOutputCopy-1\n\nNoteIn the first test sample we can get the total taste of the fruits equal to 18 if we choose fruit number 1 and fruit number 2, then the total calories will equal 9. The condition  fulfills, that's exactly what Inna wants.In the second test sample we cannot choose the fruits so as to follow Inna's principle.",
      "solutions": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces",
          "content": "366A — Dima and GuardsThe solution doesn't exist only if the mimimal way to bribe is grater than n. Otherwise we can increase the gift price to make price1 + price2 = n.Let's find the miminal way to bribe. We should buy that gift for old lady which costs less. It means, if we have 2 guards with params a b c d, then minimum bribe price will be min(a, b) + min(c, d). Let's choose the guard with the minimal bribe price. If the minimal bribe price is greater than n, answer -1. Otherwise, the possible answer is, for example: Guard number, min(a, b), n–min(a, b).366B — Dima and To-do ListDima can make k–1 tasks, so Inna always tells him off for each k-th taks, beginning from the chosen place. So for the numbers with same modulo by k the answer will be the same. We should find the answer with minimal first task number so it is eniugh to calculate the sums of “tellings of” for tasks 0, 1... k–1. We can do it in such way: Determine the array int sum[k]. And put the number into appropriate bucket while reading:sum[I mod k] +  = a[i]. Now we should simply find first i with minimal sum[i].Complexity: O(N).366C — Dima and SaladLet's calculate dinamic: d[num][balance] where num – last looked fruit, balance — difference between sum of colories and sum of tastes. Let's multiply each b by k. The answer will be d[n][0]. d[num][balance] = maximal possible sum of tastes under conditions.Step: from d[num][balance] we can relax answers:d[num + 1][balance] = max(d[num + 1][balance], d[num][balance]) – if we don't choose a fruitd[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance + a[i] - b[i]·k], d[num][balance] + a[i]) – if we choose a fruit.Balance can be negative, so in programming languages which don't support negative indexation, indexes should be shifted by the biggest negative number for balance. If we determine the balance as sum(b·k) - sum(a) it will be the sum of all tastes.366D — Dima and Trap GraphThe answer for some path is a range under which we can go all the way, and this range is the intersection of all the ranges on the path. We can conclude it because the number is valid for path if it is valid for all ranges in the path. We will iterate all ribs. Let the left board of range on a rib is the left board of our intersection. It means we can't use ribs whith left board greater than ours. Lets iterate all right boards, determining the answer as the range from fixed left board to the chosen right. This answer exists if we have any path from the first node to the last. Let's check if the graph is connected if we leave only ribs with left board not greater than our and right board not less than our. If the graph is connected — let's update the answer. Right board can be found by binary search so the complexity is O(M2·logM).366E — Dima and Magic GuitarThere are many solutions for this task. I will describe my, you can deal with other by looking participants code. To find the answer we should calculate maxDis[k][k], where maxDis[i][j] – maximal complexity from note i to note j. Now we should only iterate the song updating answer for each pair of adjacent notes. Let's think how we can calculate the matrix.For each place (x1, y1) on the guitar let's iterate pairs (x2, y2) with y2 ≤ y1. If (x2 ≤ x1) distance will be x1–x2 + y1–y2. So we should find minimal x2 + y2 in submatrix from (0, 0) to (x, y).If (x2 ≥ x1) distance will be x2–x1 + y1–y2. So we should find maximal x2–y2 in submatrix from (n–1, 0) до (x, y).We will calculate this values for each note. We need too much memory so we should memorize only one previous row for each note. For each place we will update dinamics for both variants according to already calculated and for our own note (which is in this cell) we will also compare (i + j) or (i–j) with current value in the cell.Complexity O(N·M·K)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 366\\s*C"
          },
          "content_length": 3816
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "a[i+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "dp[i][balance+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i+1][summation + a[i]]<<=b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "we will shift every summation of calories by b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"impossible\") {\n        // Generate ai and bi such that no subset sums to 0\n        // Ensure all ai - k * bi have the same sign and are not zero\n        for(int i = 0; i < n; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, 100);\n                bi = rnd.next(1, 100);\n            } while (ai - k * bi >= 0);\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else if (type == \"possible\") {\n        // Generate ai and bi such that there is a subset where sum(ai - k * bi) == 0\n        // Create a subset where ai - k * bi == 0\n        int subset_size = rnd.next(1, n);\n        vector<int> indices(n);\n        for(int i = 0; i < n; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n\n        // Assign ai - k * bi == 0 for the selected subset\n        for(int i = 0; i < subset_size; ++i) {\n            b[indices[i]] = rnd.next(1, 100);\n            a[indices[i]] = k * b[indices[i]];\n        }\n\n        // Assign ai - k * bi != 0 for the remaining elements\n        for(int i = subset_size; i < n; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, 100);\n                bi = rnd.next(1, 100);\n            } while (ai - k * bi == 0);\n            a[indices[i]] = ai;\n            b[indices[i]] = bi;\n        }\n    } else if (type == \"max_taste\") {\n        // All ai - k * bi == 0, so selecting all items satisfies the condition\n        for(int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 100);\n            a[i] = k * b[i];\n        }\n    } else if (type == \"min_taste\") {\n        // Only a minimal subset satisfies the condition\n        int selected = rnd.next(1, n / 2);\n        for (int i = 0; i < selected; ++i) {\n            b[i] = rnd.next(1, 100);\n            a[i] = k * b[i];\n        }\n        for(int i = selected; i < n; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, 100);\n                bi = rnd.next(1, 100);\n            } while (ai - k * bi == 0);\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"impossible\") {\n        // Generate ai and bi such that no subset sums to 0\n        // Ensure all ai - k * bi have the same sign and are not zero\n        for(int i = 0; i < n; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, 100);\n                bi = rnd.next(1, 100);\n            } while (ai - k * bi >= 0);\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else if (type == \"possible\") {\n        // Generate ai and bi such that there is a subset where sum(ai - k * bi) == 0\n        // Create a subset where ai - k * bi == 0\n        int subset_size = rnd.next(1, n);\n        vector<int> indices(n);\n        for(int i = 0; i < n; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n\n        // Assign ai - k * bi == 0 for the selected subset\n        for(int i = 0; i < subset_size; ++i) {\n            b[indices[i]] = rnd.next(1, 100);\n            a[indices[i]] = k * b[indices[i]];\n        }\n\n        // Assign ai - k * bi != 0 for the remaining elements\n        for(int i = subset_size; i < n; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, 100);\n                bi = rnd.next(1, 100);\n            } while (ai - k * bi == 0);\n            a[indices[i]] = ai;\n            b[indices[i]] = bi;\n        }\n    } else if (type == \"max_taste\") {\n        // All ai - k * bi == 0, so selecting all items satisfies the condition\n        for(int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, 100);\n            a[i] = k * b[i];\n        }\n    } else if (type == \"min_taste\") {\n        // Only a minimal subset satisfies the condition\n        int selected = rnd.next(1, n / 2);\n        for (int i = 0; i < selected; ++i) {\n            b[i] = rnd.next(1, 100);\n            a[i] = k * b[i];\n        }\n        for(int i = selected; i < n; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, 100);\n                bi = rnd.next(1, 100);\n            } while (ai - k * bi == 0);\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type small\n./gen -n 2 -k 2 -type small\n./gen -n 3 -k 3 -type possible\n./gen -n 3 -k 3 -type impossible\n\n./gen -n 10 -k 2 -type random\n./gen -n 10 -k 3 -type random\n./gen -n 10 -k 4 -type random\n\n./gen -n 15 -k 5 -type possible\n./gen -n 15 -k 5 -type impossible\n./gen -n 15 -k 5 -type max_taste\n./gen -n 15 -k 5 -type min_taste\n\n./gen -n 30 -k 6 -type random\n./gen -n 30 -k 6 -type possible\n./gen -n 30 -k 6 -type impossible\n\n./gen -n 50 -k 7 -type random\n./gen -n 50 -k 7 -type possible\n./gen -n 50 -k 7 -type impossible\n\n./gen -n 75 -k 8 -type random\n./gen -n 75 -k 8 -type possible\n./gen -n 75 -k 8 -type impossible\n\n./gen -n 100 -k 9 -type random\n./gen -n 100 -k 9 -type possible\n./gen -n 100 -k 9 -type impossible\n./gen -n 100 -k 9 -type max_taste\n./gen -n 100 -k 9 -type min_taste\n\n./gen -n 100 -k 10 -type random\n./gen -n 100 -k 10 -type possible\n./gen -n 100 -k 10 -type impossible\n\n./gen -n 99 -k 1 -type random\n./gen -n 98 -k 2 -type random\n./gen -n 97 -k 3 -type random\n./gen -n 96 -k 4 -type random\n./gen -n 95 -k 5 -type random\n\n./gen -n 100 -k 5 -type possible\n./gen -n 100 -k 5 -type impossible\n./gen -n 100 -k 5 -type max_taste\n./gen -n 100 -k 5 -type min_taste\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:15.346925",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "366/D",
      "title": "D. Dima and Trap Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (2 ≤ n ≤ 103, 0 ≤ m ≤ 3·103). Then follow m lines describing the edges. Each line contains four integers ak, bk, lk and rk (1 ≤ ak, bk ≤ n, 1 ≤ lk ≤ rk ≤ 106). The numbers mean that in the trap graph the k-th edge connects nodes ak and bk, this edge corresponds to the range of integers from lk to rk.Note that the given graph can have loops and multiple edges.",
      "output_spec": "OutputIn a single line of the output print an integer — the maximum loyalty among all paths from the first node to the n-th one. If such paths do not exist or the maximum loyalty equals 0, print in a single line \"Nice work, Dima!\" without the quotes.",
      "sample_tests": "ExamplesInputCopy4 41 2 1 102 4 3 51 3 1 52 4 2 7OutputCopy6InputCopy5 61 2 1 102 5 11 201 4 2 51 3 10 113 4 12 100004 5 6 6OutputCopyNice work, Dima!",
      "description": "D. Dima and Trap Graph\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m (2 ≤ n ≤ 103, 0 ≤ m ≤ 3·103). Then follow m lines describing the edges. Each line contains four integers ak, bk, lk and rk (1 ≤ ak, bk ≤ n, 1 ≤ lk ≤ rk ≤ 106). The numbers mean that in the trap graph the k-th edge connects nodes ak and bk, this edge corresponds to the range of integers from lk to rk.Note that the given graph can have loops and multiple edges.\n\nOutputIn a single line of the output print an integer — the maximum loyalty among all paths from the first node to the n-th one. If such paths do not exist or the maximum loyalty equals 0, print in a single line \"Nice work, Dima!\" without the quotes.\n\nInputCopy4 41 2 1 102 4 3 51 3 1 52 4 2 7OutputCopy6InputCopy5 61 2 1 102 5 11 201 4 2 51 3 10 113 4 12 100004 5 6 6OutputCopyNice work, Dima!\n\nInputCopy4 41 2 1 102 4 3 51 3 1 52 4 2 7\n\nOutputCopy6\n\nInputCopy5 61 2 1 102 5 11 201 4 2 51 3 10 113 4 12 100004 5 6 6\n\nOutputCopyNice work, Dima!\n\nNoteExplanation of the first example.Overall, we have 2 ways to get from node 1 to node 4: first you must go along the edge 1-2 with range [1-10], then along one of the two edges 2-4. One of them contains range [3-5], that is, we can pass through with numbers 3, 4, 5. So the loyalty of such path is 3.If we go along edge 2-4 with range [2-7], then we can pass through with numbers 2, 3, 4, 5, 6, 7. The loyalty is 6. That is the answer.The edge 1-2 have no influence on the answer because its range includes both ranges of the following edges.",
      "solutions": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces",
          "content": "366A — Dima and GuardsThe solution doesn't exist only if the mimimal way to bribe is grater than n. Otherwise we can increase the gift price to make price1 + price2 = n.Let's find the miminal way to bribe. We should buy that gift for old lady which costs less. It means, if we have 2 guards with params a b c d, then minimum bribe price will be min(a, b) + min(c, d). Let's choose the guard with the minimal bribe price. If the minimal bribe price is greater than n, answer -1. Otherwise, the possible answer is, for example: Guard number, min(a, b), n–min(a, b).366B — Dima and To-do ListDima can make k–1 tasks, so Inna always tells him off for each k-th taks, beginning from the chosen place. So for the numbers with same modulo by k the answer will be the same. We should find the answer with minimal first task number so it is eniugh to calculate the sums of “tellings of” for tasks 0, 1... k–1. We can do it in such way: Determine the array int sum[k]. And put the number into appropriate bucket while reading:sum[I mod k] +  = a[i]. Now we should simply find first i with minimal sum[i].Complexity: O(N).366C — Dima and SaladLet's calculate dinamic: d[num][balance] where num – last looked fruit, balance — difference between sum of colories and sum of tastes. Let's multiply each b by k. The answer will be d[n][0]. d[num][balance] = maximal possible sum of tastes under conditions.Step: from d[num][balance] we can relax answers:d[num + 1][balance] = max(d[num + 1][balance], d[num][balance]) – if we don't choose a fruitd[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance + a[i] - b[i]·k], d[num][balance] + a[i]) – if we choose a fruit.Balance can be negative, so in programming languages which don't support negative indexation, indexes should be shifted by the biggest negative number for balance. If we determine the balance as sum(b·k) - sum(a) it will be the sum of all tastes.366D — Dima and Trap GraphThe answer for some path is a range under which we can go all the way, and this range is the intersection of all the ranges on the path. We can conclude it because the number is valid for path if it is valid for all ranges in the path. We will iterate all ribs. Let the left board of range on a rib is the left board of our intersection. It means we can't use ribs whith left board greater than ours. Lets iterate all right boards, determining the answer as the range from fixed left board to the chosen right. This answer exists if we have any path from the first node to the last. Let's check if the graph is connected if we leave only ribs with left board not greater than our and right board not less than our. If the graph is connected — let's update the answer. Right board can be found by binary search so the complexity is O(M2·logM).366E — Dima and Magic GuitarThere are many solutions for this task. I will describe my, you can deal with other by looking participants code. To find the answer we should calculate maxDis[k][k], where maxDis[i][j] – maximal complexity from note i to note j. Now we should only iterate the song updating answer for each pair of adjacent notes. Let's think how we can calculate the matrix.For each place (x1, y1) on the guitar let's iterate pairs (x2, y2) with y2 ≤ y1. If (x2 ≤ x1) distance will be x1–x2 + y1–y2. So we should find minimal x2 + y2 in submatrix from (0, 0) to (x, y).If (x2 ≥ x1) distance will be x2–x1 + y1–y2. So we should find maximal x2–y2 in submatrix from (n–1, 0) до (x, y).We will calculate this values for each note. We need too much memory so we should memorize only one previous row for each note. For each place we will update dinamics for both variants according to already calculated and for our own note (which is in this cell) we will also compare (i + j) or (i–j) with current value in the cell.Complexity O(N·M·K)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 366\\s*D"
          },
          "content_length": 3816
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "a[i+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "dp[i][balance+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i+1][summation + a[i]]<<=b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "we will shift every summation of calories by b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000000, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, 1000000, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000000, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, 1000000, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000000, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, 1000000, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m;\n\n    if (type == \"random\") {\n        // For random type, accept m as optional parameter\n        m = opt<int>(\"m\", min(3000, n * (n + 1) / 2));\n        m = min(m, 3000);\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int lk = rnd.next(1, 1000000);\n            int rk = rnd.next(lk, 1000000);\n\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"path_max\") {\n        m = n - 1;\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int lk = 1;\n            int rk = 1000000;\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n\n    } else if (type == \"path_min\") {\n        m = n - 1;\n\n        int x = rnd.next(1, 1000000);\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i +1;\n            int lk = x;\n            int rk = x;\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"disconnected\") {\n        // Ensure that node n is disconnected from node 1\n\n        // Let's check that n ≥ 2\n\n        if (n < 2) {\n            fprintf(stderr, \"n must be at least 2 for type disconnected.\\n\");\n            exit(1);\n        }\n\n        m = opt<int>(\"m\", min(3000, (n - 1) * (n - 2) / 2 + (n - 1)));\n        m = min(m, 3000);\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        // Build a connected component among nodes 1 to n-1\n\n        for (int i = 1; i < n - 1; ++i) {\n            int a = i;\n            int b = i + 1;\n            int lk = rnd.next(1, 1000000);\n            int rk = rnd.next(lk, 1000000);\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        int edges_needed = m - (n - 2);\n\n        for (int i = 0; i < edges_needed; ++i) {\n            int a = rnd.next(1, n - 1);\n            int b = rnd.next(1, n - 1);\n            int lk = rnd.next(1, 1000000);\n            int rk = rnd.next(lk, 1000000);\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"no_path\") {\n        m = n - 1;\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        int current_lk = 1;\n\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int lk = current_lk;\n            int rk = current_lk;\n            edges.push_back({{a, b}, {lk, rk}});\n            current_lk += rnd.next(1, 10);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"full\") {\n        m = n * (n - 1) / 2;\n\n        if (m > 3000) {\n            n = int((1 + sqrt(1 + 8 * 3000)) / 2);\n            m = n * (n - 1) / 2;\n        }\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a + 1; b <= n; ++b) {\n                int lk = rnd.next(1, 1000000);\n                int rk = rnd.next(lk, 1000000);\n                edges.push_back({{a, b}, {lk, rk}});\n                if ((int)edges.size() >= 3000) {\n                    break;\n                }\n            }\n            if ((int)edges.size() >= 3000) {\n                break;\n            }\n        }\n\n        m = edges.size();\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m;\n\n    if (type == \"random\") {\n        // For random type, accept m as optional parameter\n        m = opt<int>(\"m\", min(3000, n * (n + 1) / 2));\n        m = min(m, 3000);\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int lk = rnd.next(1, 1000000);\n            int rk = rnd.next(lk, 1000000);\n\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"path_max\") {\n        m = n - 1;\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int lk = 1;\n            int rk = 1000000;\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n\n    } else if (type == \"path_min\") {\n        m = n - 1;\n\n        int x = rnd.next(1, 1000000);\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i +1;\n            int lk = x;\n            int rk = x;\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"disconnected\") {\n        // Ensure that node n is disconnected from node 1\n\n        // Let's check that n ≥ 2\n\n        if (n < 2) {\n            fprintf(stderr, \"n must be at least 2 for type disconnected.\\n\");\n            exit(1);\n        }\n\n        m = opt<int>(\"m\", min(3000, (n - 1) * (n - 2) / 2 + (n - 1)));\n        m = min(m, 3000);\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        // Build a connected component among nodes 1 to n-1\n\n        for (int i = 1; i < n - 1; ++i) {\n            int a = i;\n            int b = i + 1;\n            int lk = rnd.next(1, 1000000);\n            int rk = rnd.next(lk, 1000000);\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        int edges_needed = m - (n - 2);\n\n        for (int i = 0; i < edges_needed; ++i) {\n            int a = rnd.next(1, n - 1);\n            int b = rnd.next(1, n - 1);\n            int lk = rnd.next(1, 1000000);\n            int rk = rnd.next(lk, 1000000);\n            edges.push_back({{a, b}, {lk, rk}});\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"no_path\") {\n        m = n - 1;\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        int current_lk = 1;\n\n        for (int i = 1; i < n; ++i) {\n            int a = i;\n            int b = i + 1;\n            int lk = current_lk;\n            int rk = current_lk;\n            edges.push_back({{a, b}, {lk, rk}});\n            current_lk += rnd.next(1, 10);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else if (type == \"full\") {\n        m = n * (n - 1) / 2;\n\n        if (m > 3000) {\n            n = int((1 + sqrt(1 + 8 * 3000)) / 2);\n            m = n * (n - 1) / 2;\n        }\n\n        vector<pair<pair<int,int>, pair<int,int>>> edges;\n\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a + 1; b <= n; ++b) {\n                int lk = rnd.next(1, 1000000);\n                int rk = rnd.next(lk, 1000000);\n                edges.push_back({{a, b}, {lk, rk}});\n                if ((int)edges.size() >= 3000) {\n                    break;\n                }\n            }\n            if ((int)edges.size() >= 3000) {\n                break;\n            }\n        }\n\n        m = edges.size();\n\n        printf(\"%d %d\\n\", n, m);\n\n        for (auto edge : edges) {\n            printf(\"%d %d %d %d\\n\", edge.first.first, edge.first.second, edge.second.first, edge.second.second);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type path_max\n./gen -n 2 -type path_min\n./gen -n 2 -type disconnected\n./gen -n 2 -type no_path\n\n./gen -n 10 -type random\n./gen -n 10 -type path_max\n./gen -n 10 -type path_min\n./gen -n 10 -type disconnected\n./gen -n 10 -type no_path\n\n./gen -n 100 -type random\n./gen -n 100 -type path_max\n./gen -n 100 -type path_min\n./gen -n 100 -type disconnected\n./gen -n 100 -type no_path\n\n./gen -n 500 -type random\n./gen -n 500 -type path_max\n./gen -n 500 -type path_min\n./gen -n 500 -type disconnected\n./gen -n 500 -type no_path\n\n./gen -n 1000 -type random\n./gen -n 1000 -type path_max\n./gen -n 1000 -type path_min\n./gen -n 1000 -type disconnected\n./gen -n 1000 -type no_path\n\n# For random type with custom m\n./gen -n 1000 -type random -m 1000\n./gen -n 1000 -type random -m 2000\n./gen -n 1000 -type random -m 3000\n\n# For \"full\" type, n will be adjusted inside generator to not exceed m=3000\n./gen -n 1000 -type full\n./gen -n 100 -type full\n./gen -n 50 -type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:17.564557",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "366/E",
      "title": "E. Dima and Magic Guitar",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four integers n, m, k and s (1 ≤ n, m ≤ 2000, 1 ≤ k ≤ 9, 2 ≤ s ≤ 105). Then follow n lines, each containing m integers aij (1 ≤ aij ≤ k). The number in the i-th row and the j-th column (aij) means a note that the guitar produces on the i-th string and the j-th fret.The last line of the input contains s integers qi (1 ≤ qi ≤ k) — the sequence of notes of the song.",
      "output_spec": "OutputIn a single line print a single number — the maximum possible complexity of the song.",
      "sample_tests": "ExamplesInputCopy4 6 5 73 1 2 2 3 13 2 2 2 5 54 2 2 2 5 33 2 2 1 4 32 3 1 4 1 5 1OutputCopy8InputCopy4 4 9 54 7 9 51 2 1 78 3 4 95 7 7 27 1 9 2 5OutputCopy4",
      "description": "E. Dima and Magic Guitar\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains four integers n, m, k and s (1 ≤ n, m ≤ 2000, 1 ≤ k ≤ 9, 2 ≤ s ≤ 105). Then follow n lines, each containing m integers aij (1 ≤ aij ≤ k). The number in the i-th row and the j-th column (aij) means a note that the guitar produces on the i-th string and the j-th fret.The last line of the input contains s integers qi (1 ≤ qi ≤ k) — the sequence of notes of the song.\n\nOutputIn a single line print a single number — the maximum possible complexity of the song.\n\nInputCopy4 6 5 73 1 2 2 3 13 2 2 2 5 54 2 2 2 5 33 2 2 1 4 32 3 1 4 1 5 1OutputCopy8InputCopy4 4 9 54 7 9 51 2 1 78 3 4 95 7 7 27 1 9 2 5OutputCopy4\n\nInputCopy4 6 5 73 1 2 2 3 13 2 2 2 5 54 2 2 2 5 33 2 2 1 4 32 3 1 4 1 5 1\n\nOutputCopy8\n\nInputCopy4 4 9 54 7 9 51 2 1 78 3 4 95 7 7 27 1 9 2 5\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces",
          "content": "Good day! The event named Codeforces Round #214 (Div. 2) will take place soon. My name is Dmytro Berezin and i am the author. This is my second round and Sereja hopes that this is the last one :)Private life — is such thing, which can't contains too much happiness, so you should help Dima and Inna again. In addition, Sereja is not a negative character! He is rather some kind of circumstances you should fight with... Sometimes.I want to thank Gerald Agapov (Gerald) for his help in round preparation, Maria Belova (Delinur) for statements translations, and Sergii Nagin (Sereja) for the fact he kindly (leaves the room sometimes) agreed to help in testing.Sergii sends greetings and strongly recomend to read ALL tasks.Point distributions will be announced. Honestly. And the distribution is: 500-1000-1500-2000-2500Thank you for your time, have a nice round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 862
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces",
          "content": "366A — Dima and GuardsThe solution doesn't exist only if the mimimal way to bribe is grater than n. Otherwise we can increase the gift price to make price1 + price2 = n.Let's find the miminal way to bribe. We should buy that gift for old lady which costs less. It means, if we have 2 guards with params a b c d, then minimum bribe price will be min(a, b) + min(c, d). Let's choose the guard with the minimal bribe price. If the minimal bribe price is greater than n, answer -1. Otherwise, the possible answer is, for example: Guard number, min(a, b), n–min(a, b).366B — Dima and To-do ListDima can make k–1 tasks, so Inna always tells him off for each k-th taks, beginning from the chosen place. So for the numbers with same modulo by k the answer will be the same. We should find the answer with minimal first task number so it is eniugh to calculate the sums of “tellings of” for tasks 0, 1... k–1. We can do it in such way: Determine the array int sum[k]. And put the number into appropriate bucket while reading:sum[I mod k] +  = a[i]. Now we should simply find first i with minimal sum[i].Complexity: O(N).366C — Dima and SaladLet's calculate dinamic: d[num][balance] where num – last looked fruit, balance — difference between sum of colories and sum of tastes. Let's multiply each b by k. The answer will be d[n][0]. d[num][balance] = maximal possible sum of tastes under conditions.Step: from d[num][balance] we can relax answers:d[num + 1][balance] = max(d[num + 1][balance], d[num][balance]) – if we don't choose a fruitd[num + 1][balance + a[i] - b[i]·k] = max(d[num + 1][balance + a[i] - b[i]·k], d[num][balance] + a[i]) – if we choose a fruit.Balance can be negative, so in programming languages which don't support negative indexation, indexes should be shifted by the biggest negative number for balance. If we determine the balance as sum(b·k) - sum(a) it will be the sum of all tastes.366D — Dima and Trap GraphThe answer for some path is a range under which we can go all the way, and this range is the intersection of all the ranges on the path. We can conclude it because the number is valid for path if it is valid for all ranges in the path. We will iterate all ribs. Let the left board of range on a rib is the left board of our intersection. It means we can't use ribs whith left board greater than ours. Lets iterate all right boards, determining the answer as the range from fixed left board to the chosen right. This answer exists if we have any path from the first node to the last. Let's check if the graph is connected if we leave only ribs with left board not greater than our and right board not less than our. If the graph is connected — let's update the answer. Right board can be found by binary search so the complexity is O(M2·logM).366E — Dima and Magic GuitarThere are many solutions for this task. I will describe my, you can deal with other by looking participants code. To find the answer we should calculate maxDis[k][k], where maxDis[i][j] – maximal complexity from note i to note j. Now we should only iterate the song updating answer for each pair of adjacent notes. Let's think how we can calculate the matrix.For each place (x1, y1) on the guitar let's iterate pairs (x2, y2) with y2 ≤ y1. If (x2 ≤ x1) distance will be x1–x2 + y1–y2. So we should find minimal x2 + y2 in submatrix from (0, 0) to (x, y).If (x2 ≥ x1) distance will be x2–x1 + y1–y2. So we should find maximal x2–y2 in submatrix from (n–1, 0) до (x, y).We will calculate this values for each note. We need too much memory so we should memorize only one previous row for each note. For each place we will update dinamics for both variants according to already calculated and for our own note (which is in this cell) we will also compare (i + j) or (i–j) with current value in the cell.Complexity O(N·M·K)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 366\\s*E"
          },
          "content_length": 3816
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 1",
          "code": "2 2\n1 2 1 2\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) - Codeforces - Code 2",
          "code": "2 2\n1 2 1 3\n1 2 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "a[i+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "dp[i][balance+100000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "C can be solved with use of dp with bitmasks \ndp state: dp[i][summation of tastes][summation of calories] \nand if we want add new taste it will be",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i+1][summation + a[i]]<<=b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #214 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "we will shift every summation of calories by b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 9, \"k\");\n    inf.readSpace();\n    int s = inf.readInt(2, 100000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> a = inf.readInts(m, 1, k, \"a_i\");\n        inf.readEoln();\n    }\n\n    vector<int> q = inf.readInts(s, 1, k, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 9, \"k\");\n    inf.readSpace();\n    int s = inf.readInt(2, 100000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> a = inf.readInts(m, 1, k, \"a_i\");\n        inf.readEoln();\n    }\n\n    vector<int> q = inf.readInts(s, 1, k, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 9, \"k\");\n    inf.readSpace();\n    int s = inf.readInt(2, 100000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> a = inf.readInts(m, 1, k, \"a_i\");\n        inf.readEoln();\n    }\n\n    vector<int> q = inf.readInts(s, 1, k, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int s = opt<int>(\"s\");\n\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\"\n\n    // Ensure that n, m, k, s are within the constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(1 <= m && m <= 2000);\n    ensure(1 <= k && k <= 9);\n    ensure(2 <= s && s <= 100000);\n\n    vector<vector<int>> a(n, vector<int>(m));\n    vector<int> q(s);\n\n    if (type == \"random\") {\n        // Generate random a_{ij} in [1, k]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, k);\n        // Generate random q_i in [1, k]\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, k);\n    } else if (type == \"same_notes\") {\n        // Set all a_{ij} to the same note, say 1\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n        // Generate random q_i in [1, k]\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, k);\n    } else if (type == \"constant_song\") {\n        // Generate random a_{ij} in [1, k]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, k);\n        // Set all q_i to the same note, say 1\n        for (int i = 0; i < s; ++i)\n            q[i] = 1;\n    } else if (type == \"min_k\") {\n        // k must be 1\n        ensure(k == 1);\n        // Set all a_{ij} to 1\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n        // Set all q_i to 1\n        fill(q.begin(), q.end(), 1);\n    } else if (type == \"max_k\") {\n        // k must be 9\n        ensure(k == 9);\n        // Generate random a_{ij} in [1, 9]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, 9);\n        // Generate random q_i in [1, 9]\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, 9);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, k);\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, k);\n    }\n\n    // Output n, m, k, s\n    printf(\"%d %d %d %d\\n\", n, m, k, s);\n\n    // Output a_{ij}\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    // Output q_i\n    for (int i = 0; i < s; ++i) {\n        printf(\"%d\", q[i]);\n        if (i + 1 < s)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int s = opt<int>(\"s\");\n\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\"\n\n    // Ensure that n, m, k, s are within the constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(1 <= m && m <= 2000);\n    ensure(1 <= k && k <= 9);\n    ensure(2 <= s && s <= 100000);\n\n    vector<vector<int>> a(n, vector<int>(m));\n    vector<int> q(s);\n\n    if (type == \"random\") {\n        // Generate random a_{ij} in [1, k]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, k);\n        // Generate random q_i in [1, k]\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, k);\n    } else if (type == \"same_notes\") {\n        // Set all a_{ij} to the same note, say 1\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n        // Generate random q_i in [1, k]\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, k);\n    } else if (type == \"constant_song\") {\n        // Generate random a_{ij} in [1, k]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, k);\n        // Set all q_i to the same note, say 1\n        for (int i = 0; i < s; ++i)\n            q[i] = 1;\n    } else if (type == \"min_k\") {\n        // k must be 1\n        ensure(k == 1);\n        // Set all a_{ij} to 1\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n        // Set all q_i to 1\n        fill(q.begin(), q.end(), 1);\n    } else if (type == \"max_k\") {\n        // k must be 9\n        ensure(k == 9);\n        // Generate random a_{ij} in [1, 9]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, 9);\n        // Generate random q_i in [1, 9]\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, 9);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, k);\n        for (int i = 0; i < s; ++i)\n            q[i] = rnd.next(1, k);\n    }\n\n    // Output n, m, k, s\n    printf(\"%d %d %d %d\\n\", n, m, k, s);\n\n    // Output a_{ij}\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    // Output q_i\n    for (int i = 0; i < s; ++i) {\n        printf(\"%d\", q[i]);\n        if (i + 1 < s)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -s 2 -type min_n_m\n./gen -n 2000 -m 2000 -k 9 -s 100000 -type random\n\n./gen -n 100 -m 100 -k 1 -s 1000 -type same_notes\n./gen -n 100 -m 100 -k 9 -s 1000 -type random\n\n./gen -n 1000 -m 1000 -k 9 -s 100000 -type random\n./gen -n 1 -m 2000 -k 9 -s 100 -type random\n./gen -n 2000 -m 1 -k 9 -s 100 -type random\n\n./gen -n 2000 -m 2000 -k 9 -s 2 -type random\n./gen -n 50 -m 50 -k 5 -s 50000 -type constant_song\n\n./gen -n 2000 -m 2000 -k 9 -s 100000 -type max_k\n./gen -n 1000 -m 1000 -k 1 -s 100000 -type min_k\n\n./gen -n 1000 -m 1000 -k 9 -s 100000 -type constant_song\n./gen -n 1000 -m 1000 -k 9 -s 100000 -type same_notes\n\n./gen -n 2000 -m 2000 -k 1 -s 2 -type min_k\n./gen -n 2000 -m 2000 -k 9 -s 100000 -type random\n\n./gen -n 2000 -m 2000 -k 9 -s 99999 -type random\n./gen -n 999 -m 999 -k 9 -s 99999 -type random\n\n./gen -n 1 -m 1 -k 9 -s 2 -type random\n./gen -n 2000 -m 2000 -k 5 -s 50000 -type random\n\n./gen -n 2000 -m 2000 -k 5 -s 50000 -type constant_song\n./gen -n 2000 -m 2000 -k 5 -s 50000 -type same_notes\n\n./gen -n 2000 -m 2000 -k 5 -s 50000 -type random\n./gen -n 2000 -m 2000 -k 9 -s 100000 -type constant_song\n\n./gen -n 1999 -m 1999 -k 9 -s 99999 -type random\n./gen -n 2 -m 2 -k 2 -s 2 -type random\n\n./gen -n 2000 -m 2000 -k 3 -s 99999 -type random\n./gen -n 2000 -m 2000 -k 4 -s 99999 -type random\n\n./gen -n 1000 -m 1000 -k 9 -s 100000 -type same_notes\n./gen -n 1000 -m 1000 -k 9 -s 100000 -type constant_song\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:20.085275",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "367/A",
      "title": "A. Sereja and Algorithm",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains non-empty string s, its length (n) doesn't exceed 105. It is guaranteed that string s only contains characters: 'x', 'y', 'z'.The second line contains integer m (1 ≤ m ≤ 105) — the number of tests. Next m lines contain the tests. The i-th line contains a pair of integers li, ri (1 ≤ li ≤ ri ≤ n).",
      "output_spec": "OutputFor each test, print \"YES\" (without the quotes) if the algorithm works correctly on the corresponding test and \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopyzyxxxxxxyyz55 51 31 111 43 6OutputCopyYESYESNOYESNO",
      "description": "A. Sereja and Algorithm\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains non-empty string s, its length (n) doesn't exceed 105. It is guaranteed that string s only contains characters: 'x', 'y', 'z'.The second line contains integer m (1 ≤ m ≤ 105) — the number of tests. Next m lines contain the tests. The i-th line contains a pair of integers li, ri (1 ≤ li ≤ ri ≤ n).\n\nOutputFor each test, print \"YES\" (without the quotes) if the algorithm works correctly on the corresponding test and \"NO\" (without the quotes) otherwise.\n\nInputCopyzyxxxxxxyyz55 51 31 111 43 6OutputCopyYESYESNOYESNO\n\nInputCopyzyxxxxxxyyz55 51 31 111 43 6\n\nOutputCopyYESYESNOYESNO\n\nNoteIn the first example, in test one and two the algorithm will always be terminated in one step. In the fourth test you can get string \"xzyx\" on which the algorithm will terminate. In all other tests the algorithm doesn't work correctly.",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 367\\s*A"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[xyz]{1,100000}\", \"s\");\n\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[xyz]{1,100000}\", \"s\");\n\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[xyz]{1,100000}\", \"s\");\n\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)]; // random letter from 'x', 'y', 'z'\n        }\n    } else if (type == \"forbidden_only\") {\n        // Construct s where all length-3 substrings are forbidden (\"zyx\", \"xzy\", \"yxz\")\n        string forbidden[] = {\"zyx\", \"xzy\", \"yxz\"};\n        while (s.size() + 3 <= n) {\n            int idx = rnd.next(3);\n            s += forbidden[idx];\n        }\n        // Fill the remaining characters if any\n        if (s.size() < n) {\n            s += \"x\"; // Fill with 'x' to reach length n\n            while (s.size() < n) s += \"x\";\n        }\n    } else if (type == \"non_forbidden_only\") {\n        // Construct s where no length-3 substrings are forbidden\n        s = string(n, 'x'); // Fill s with 'x'\n    } else if (type == \"single_char\") {\n        // s consists of a single character ('x', 'y', or 'z')\n        char c = \"xyz\"[rnd.next(3)];\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        // s is \"x y z x y z ...\" pattern\n        string pattern = \"xyz\";\n        for (int i = 0; i < n; ++i) {\n            s += pattern[i % 3];\n        }\n    } else if (type == \"repeated_pattern\") {\n        // s is a short pattern repeated\n        string patterns[] = {\"xyz\", \"xyx\", \"xzx\", \"yxy\", \"yzy\", \"zyz\"};\n        string pattern = patterns[rnd.next(6)];\n        while (s.size() < n) {\n            s += pattern;\n        }\n        s.resize(n); // Ensure s is of length n\n    } else if (type == \"li_equals_ri\") {\n        // s is random, but all queries have li = ri\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    } else if (type == \"edge\") {\n        // s is random\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    } else if (type == \"max_length\" || type == \"max_queries\") {\n        // s is random\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    } else {\n        // Default to random\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    if (type == \"li_equals_ri\") {\n        // All queries have li = ri\n        for (int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            printf(\"%d %d\\n\", pos, pos);\n        }\n    } else if (type == \"max_queries\") {\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (type == \"edge\") {\n        // Generate specific edge case queries\n        printf(\"1 %d\\n\", n); // Full range\n        printf(\"1 1\\n\"); // First character\n        printf(\"%d %d\\n\", n, n); // Last character\n        for (int i = 3; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else {\n        // Random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            printf(\"%d %d\\n\", l, r);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)]; // random letter from 'x', 'y', 'z'\n        }\n    } else if (type == \"forbidden_only\") {\n        // Construct s where all length-3 substrings are forbidden (\"zyx\", \"xzy\", \"yxz\")\n        string forbidden[] = {\"zyx\", \"xzy\", \"yxz\"};\n        while (s.size() + 3 <= n) {\n            int idx = rnd.next(3);\n            s += forbidden[idx];\n        }\n        // Fill the remaining characters if any\n        if (s.size() < n) {\n            s += \"x\"; // Fill with 'x' to reach length n\n            while (s.size() < n) s += \"x\";\n        }\n    } else if (type == \"non_forbidden_only\") {\n        // Construct s where no length-3 substrings are forbidden\n        s = string(n, 'x'); // Fill s with 'x'\n    } else if (type == \"single_char\") {\n        // s consists of a single character ('x', 'y', or 'z')\n        char c = \"xyz\"[rnd.next(3)];\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        // s is \"x y z x y z ...\" pattern\n        string pattern = \"xyz\";\n        for (int i = 0; i < n; ++i) {\n            s += pattern[i % 3];\n        }\n    } else if (type == \"repeated_pattern\") {\n        // s is a short pattern repeated\n        string patterns[] = {\"xyz\", \"xyx\", \"xzx\", \"yxy\", \"yzy\", \"zyz\"};\n        string pattern = patterns[rnd.next(6)];\n        while (s.size() < n) {\n            s += pattern;\n        }\n        s.resize(n); // Ensure s is of length n\n    } else if (type == \"li_equals_ri\") {\n        // s is random, but all queries have li = ri\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    } else if (type == \"edge\") {\n        // s is random\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    } else if (type == \"max_length\" || type == \"max_queries\") {\n        // s is random\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    } else {\n        // Default to random\n        string letters = \"xyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(3)];\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    if (type == \"li_equals_ri\") {\n        // All queries have li = ri\n        for (int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            printf(\"%d %d\\n\", pos, pos);\n        }\n    } else if (type == \"max_queries\") {\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (type == \"edge\") {\n        // Generate specific edge case queries\n        printf(\"1 %d\\n\", n); // Full range\n        printf(\"1 1\\n\"); // First character\n        printf(\"%d %d\\n\", n, n); // Last character\n        for (int i = 3; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else {\n        // Random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            printf(\"%d %d\\n\", l, r);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random\n./gen -n 100 -m 10 -type random\n./gen -n 1000 -m 100 -type random\n./gen -n 10000 -m 1000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type forbidden_only\n./gen -n 100000 -m 100000 -type non_forbidden_only\n./gen -n 100000 -m 100000 -type single_char\n./gen -n 100000 -m 100000 -type alternating\n./gen -n 100000 -m 100000 -type repeated_pattern\n\n./gen -n 50000 -m 50000 -type li_equals_ri\n./gen -n 100000 -m 100000 -type li_equals_ri\n\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type single_char\n\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 1 -type forbidden_only\n./gen -n 100000 -m 1 -type non_forbidden_only\n\n./gen -n 1 -m 100000 -type random\n./gen -n 1 -m 100000 -type single_char\n\n./gen -n 1000 -m 1000 -type non_forbidden_only\n./gen -n 1000 -m 1000 -type forbidden_only\n\n./gen -n 5000 -m 5000 -type alternating\n./gen -n 5000 -m 5000 -type repeated_pattern\n\n./gen -n 99999 -m 99999 -type edge\n./gen -n 100000 -m 99999 -type edge\n\n./gen -n 100000 -m 100000 -type max_length\n./gen -n 100000 -m 100000 -type max_queries\n\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 1 -type single_char\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:22.195362",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "367/B",
      "title": "B. Sereja ans Anagrams",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and p (1 ≤ n, m ≤ 2·105, 1 ≤ p ≤ 2·105). The next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The next line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 109).",
      "output_spec": "OutputIn the first line print the number of valid qs. In the second line, print the valid values in the increasing order.",
      "sample_tests": "ExamplesInputCopy5 3 11 2 3 2 11 2 3OutputCopy21 3InputCopy6 3 21 3 2 2 3 11 2 3OutputCopy21 2",
      "description": "B. Sereja ans Anagrams\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and p (1 ≤ n, m ≤ 2·105, 1 ≤ p ≤ 2·105). The next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The next line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 109).\n\nOutputIn the first line print the number of valid qs. In the second line, print the valid values in the increasing order.\n\nInputCopy5 3 11 2 3 2 11 2 3OutputCopy21 3InputCopy6 3 21 3 2 2 3 11 2 3OutputCopy21 2\n\nInputCopy5 3 11 2 3 2 11 2 3\n\nOutputCopy21 3\n\nInputCopy6 3 21 3 2 2 3 11 2 3\n\nOutputCopy21 2",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 367\\s*B"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 200000, \"p\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 200000, \"p\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 200000, \"p\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\");\n    string kind = opt<string>(\"kind\", \"random\"); // default is random\n\n    vector<int> a, b;\n\n    if(kind == \"random\") {\n        // Generate random sequences a and b within constraints\n        // a has size n, elements in [1, 1e9]\n        // b has size m, elements in [1, 1e9]\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"same_elements\") {\n        // All elements in a are the same\n        int value_a = rnd.next(1, 1000000000);\n        a.assign(n, value_a);\n        // All elements in b are the same as value_a or different\n        int same_b = rnd.next(0, 1); // 0 or 1\n        int value_b;\n        if(same_b) {\n            value_b = value_a;\n        } else {\n            do {\n                value_b = rnd.next(1, 1000000000);\n            } while(value_b == value_a);\n        }\n        b.assign(m, value_b);\n    }\n    else if(kind == \"b_in_a\") {\n        // Generate b\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n        // Generate a\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        // Ensure q exists such that the subsequence matches b\n        int max_q = n - (m - 1) * p;\n        if(max_q < 1) {\n            // Not possible, adjust n\n            n = (m - 1) * p + 1;\n            max_q = 1;\n            a.resize(n);\n            for(int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, 1000000000);\n            }\n        }\n        int q = rnd.next(1, max_q);\n        // Shuffle b before placing into a\n        shuffle(b.begin(), b.end());\n\n        // Place b at positions q + (i-1)*p\n        for(int i = 0; i < m; ++i) {\n            a[q -1 + i * p] = b[i];\n        }\n    }\n    else if(kind == \"no_valid_q\") {\n        // Generate a\n        a.resize(n);\n        set<int> a_values;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            a_values.insert(a[i]);\n        }\n        // Generate b, with at least one value not in a\n        b.resize(m);\n        int value_not_in_a;\n        do {\n            value_not_in_a = rnd.next(1, 1000000000);\n        } while(a_values.count(value_not_in_a));\n        for(int i = 0; i < m; ++i) {\n            b[i] = value_not_in_a; // ensure b contains values not in a\n        }\n    }\n    else if(kind == \"p_is_1\") {\n        p = 1;\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"p_is_n\") {\n        p = n;\n        m = 1; // Because otherwise q would be invalid\n        b.resize(1);\n        b[0] = rnd.next(1, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"max_n_m_p\") {\n        n = 200000;\n        m = 200000;\n        p = rnd.next(1, n);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"min_n_m_p\") {\n        n = 1;\n        m = 1;\n        p = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, 1000000000);\n        b.resize(1);\n        b[0] = rnd.next(1, 1000000000);\n    }\n    else {\n        // Default to random\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n m p\n    printf(\"%d %d %d\\n\", n, m, p);\n    // Output a\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    // Output b\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\");\n    string kind = opt<string>(\"kind\", \"random\"); // default is random\n\n    vector<int> a, b;\n\n    if(kind == \"random\") {\n        // Generate random sequences a and b within constraints\n        // a has size n, elements in [1, 1e9]\n        // b has size m, elements in [1, 1e9]\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"same_elements\") {\n        // All elements in a are the same\n        int value_a = rnd.next(1, 1000000000);\n        a.assign(n, value_a);\n        // All elements in b are the same as value_a or different\n        int same_b = rnd.next(0, 1); // 0 or 1\n        int value_b;\n        if(same_b) {\n            value_b = value_a;\n        } else {\n            do {\n                value_b = rnd.next(1, 1000000000);\n            } while(value_b == value_a);\n        }\n        b.assign(m, value_b);\n    }\n    else if(kind == \"b_in_a\") {\n        // Generate b\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n        // Generate a\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        // Ensure q exists such that the subsequence matches b\n        int max_q = n - (m - 1) * p;\n        if(max_q < 1) {\n            // Not possible, adjust n\n            n = (m - 1) * p + 1;\n            max_q = 1;\n            a.resize(n);\n            for(int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, 1000000000);\n            }\n        }\n        int q = rnd.next(1, max_q);\n        // Shuffle b before placing into a\n        shuffle(b.begin(), b.end());\n\n        // Place b at positions q + (i-1)*p\n        for(int i = 0; i < m; ++i) {\n            a[q -1 + i * p] = b[i];\n        }\n    }\n    else if(kind == \"no_valid_q\") {\n        // Generate a\n        a.resize(n);\n        set<int> a_values;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            a_values.insert(a[i]);\n        }\n        // Generate b, with at least one value not in a\n        b.resize(m);\n        int value_not_in_a;\n        do {\n            value_not_in_a = rnd.next(1, 1000000000);\n        } while(a_values.count(value_not_in_a));\n        for(int i = 0; i < m; ++i) {\n            b[i] = value_not_in_a; // ensure b contains values not in a\n        }\n    }\n    else if(kind == \"p_is_1\") {\n        p = 1;\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"p_is_n\") {\n        p = n;\n        m = 1; // Because otherwise q would be invalid\n        b.resize(1);\n        b[0] = rnd.next(1, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"max_n_m_p\") {\n        n = 200000;\n        m = 200000;\n        p = rnd.next(1, n);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if(kind == \"min_n_m_p\") {\n        n = 1;\n        m = 1;\n        p = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, 1000000000);\n        b.resize(1);\n        b[0] = rnd.next(1, 1000000000);\n    }\n    else {\n        // Default to random\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        b.resize(m);\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n m p\n    printf(\"%d %d %d\\n\", n, m, p);\n    // Output a\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    // Output b\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -p 1 -kind random\n./gen -n 5 -m 3 -p 1 -kind same_elements\n./gen -n 5 -m 3 -p 1 -kind b_in_a\n./gen -n 5 -m 3 -p 1 -kind no_valid_q\n\n./gen -n 1000 -m 500 -p 1 -kind random\n./gen -n 1000 -m 500 -p 1 -kind same_elements\n./gen -n 1000 -m 500 -p 1 -kind b_in_a\n./gen -n 1000 -m 500 -p 1 -kind no_valid_q\n\n./gen -n 200000 -m 200000 -p 1 -kind max_n_m_p\n./gen -n 200000 -m 1 -p 200000 -kind p_is_n\n./gen -n 200000 -m 1 -p 1 -kind p_is_1\n\n./gen -n 100000 -m 100000 -p 10 -kind random\n./gen -n 100000 -m 50000 -p 2 -kind b_in_a\n./gen -n 150000 -m 150000 -p 1 -kind same_elements\n\n./gen -n 200000 -m 200000 -p 1 -kind random\n./gen -n 200000 -m 200000 -p 200000 -kind p_is_n\n./gen -n 1 -m 1 -p 1 -kind min_n_m_p\n\n./gen -n 100000 -m 1 -p 1 -kind random\n./gen -n 1 -m 100000 -p 1 -kind random\n./gen -n 200000 -m 100000 -p 2 -kind random\n\n./gen -n 99999 -m 33333 -p 3 -kind b_in_a\n./gen -n 199999 -m 199999 -p 1 -kind no_valid_q\n./gen -n 100000 -m 50000 -p 2 -kind b_in_a\n\n./gen -n 100000 -m 1 -p 100000 -kind p_is_n\n./gen -n 2 -m 2 -p 1 -kind random\n./gen -n 150000 -m 1 -p 1 -kind random\n\n./gen -n 200000 -m 2 -p 100000 -kind b_in_a\n./gen -n 200000 -m 100000 -p 1 -kind same_elements\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:24.478884",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "367/C",
      "title": "C. Sereja and the Arrangement of Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 2·106, 1 ≤ m ≤ 105). Next m lines contain pairs of integers. The i-th line contains numbers qi, wi (1 ≤ qi, wi ≤ 105).It is guaranteed that all qi are distinct.",
      "output_spec": "OutputIn a single line print maximum amount of money (in rubles) Sereja can pay.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy5 21 22 3OutputCopy5InputCopy100 31 22 13 1OutputCopy4InputCopy1 21 12 100OutputCopy100",
      "description": "C. Sereja and the Arrangement of Numbers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 2·106, 1 ≤ m ≤ 105). Next m lines contain pairs of integers. The i-th line contains numbers qi, wi (1 ≤ qi, wi ≤ 105).It is guaranteed that all qi are distinct.\n\nOutputIn a single line print maximum amount of money (in rubles) Sereja can pay.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy5 21 22 3OutputCopy5InputCopy100 31 22 13 1OutputCopy4InputCopy1 21 12 100OutputCopy100\n\nInputCopy5 21 22 3\n\nOutputCopy5\n\nInputCopy100 31 22 13 1\n\nOutputCopy4\n\nInputCopy1 21 12 100\n\nOutputCopy100\n\nNoteIn the first sample Sereja can pay 5 rubles, for example, if Dima constructs the following array: [1, 2, 1, 2, 2]. There are another optimal arrays for this test.In the third sample Sereja can pay 100 rubles, if Dima constructs the following array: [2].",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 367\\s*C"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2 * int(1e6), \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, int(1e5), \"m\");\n    inf.readEoln();\n\n    unordered_set<int> qi_set;\n\n    for (int i = 0; i < m; i++) {\n        int qi = inf.readInt(1, int(1e5), \"qi\");\n        inf.readSpace();\n        int wi = inf.readInt(1, int(1e5), \"wi\");\n        inf.readEoln();\n\n        ensuref(qi_set.count(qi) == 0, \"qi=%d is not unique\", qi);\n        qi_set.insert(qi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2 * int(1e6), \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, int(1e5), \"m\");\n    inf.readEoln();\n\n    unordered_set<int> qi_set;\n\n    for (int i = 0; i < m; i++) {\n        int qi = inf.readInt(1, int(1e5), \"qi\");\n        inf.readSpace();\n        int wi = inf.readInt(1, int(1e5), \"wi\");\n        inf.readEoln();\n\n        ensuref(qi_set.count(qi) == 0, \"qi=%d is not unique\", qi);\n        qi_set.insert(qi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2 * int(1e6), \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, int(1e5), \"m\");\n    inf.readEoln();\n\n    unordered_set<int> qi_set;\n\n    for (int i = 0; i < m; i++) {\n        int qi = inf.readInt(1, int(1e5), \"qi\");\n        inf.readSpace();\n        int wi = inf.readInt(1, int(1e5), \"wi\");\n        inf.readEoln();\n\n        ensuref(qi_set.count(qi) == 0, \"qi=%d is not unique\", qi);\n        qi_set.insert(qi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxK(int n) {\n    // Compute largest k such that k*(k-1)/2 <= n\n    int k = 1;\n    while ((long long)k*(k-1)/2 <= n) {\n        k++;\n    }\n    return k - 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate m distinct q_i in [1,1e5]\n        // Generate w_i randomly in [1,1e5]\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n        vector<int> wi_list;\n        for (int i = 0; i < m; i++) {\n            int wi = rnd.next(1, 100000);\n            wi_list.push_back(wi);\n        }\n        \n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"one_number\") {\n        // Generate one qi with w_i = 100000\n        // Rest qi's with small w_i\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        // Let's make the first qi have w_i = 100000\n        vector<int> wi_list(m, 1); // initialize wi_list with 1\n\n        wi_list[0] = 100000; // the first qi has w_i = 100000\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"max_numbers\") {\n        int k = getMaxK(n);\n        if (k > m) k = m;\n\n        // Generate k qi with high w_i\n\n        set<int> qiset;\n        while ((int)qiset.size() < k) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list;\n        for (int i = 0; i < k; i++) {\n            wi_list.push_back(100000);\n        }\n\n        // For the rest of m - k, generate qi with small w_i\n        for (int i = k; i < m; i++) {\n            int qi;\n            do {\n                qi = rnd.next(1, 100000);\n            } while (qiset.count(qi));\n            qiset.insert(qi);\n            qi_list.push_back(qi);\n            wi_list.push_back(1);\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"small_n\") {\n        // n is already provided, but we can set n to small value\n        // Let's ensure n is small\n        if (n > 10) {\n            n = 10;\n        }\n\n        // Rest is same as \"random\"\n        // Generate m distinct q_i in [1,1e5]\n        // Generate w_i randomly in [1,1e5]\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n        vector<int> wi_list;\n        for (int i = 0; i < m; i++) {\n            int wi = rnd.next(1, 100000);\n            wi_list.push_back(wi);\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"max_n_m\") {\n        // Max n and m\n        n = 2000000;\n        m = 100000;\n\n        // Rest is same as \"random\"\n        // Generate m distinct q_i in [1,1e5]\n        // Generate w_i randomly in [1,1e5]\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n        vector<int> wi_list;\n        for (int i = 0; i < m; i++) {\n            int wi = rnd.next(1, 100000);\n            wi_list.push_back(wi);\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"increasing_wi\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list(m);\n        for (int i = 0; i < m; i++) {\n            wi_list[i] = i + 1;\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"decreasing_wi\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list(m);\n        int max_wi = 100000;\n        for (int i = 0; i < m; i++) {\n            wi_list[i] = max_wi - i;\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"all_equal_wi\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        int wi_value = rnd.next(1, 100000);\n        vector<int> wi_list(m, wi_value);\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"large_wi_gap\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list(m, 1);\n        wi_list[0] = 100000;\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else {\n        // Default to \"random\" or we can throw an error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        abort();\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxK(int n) {\n    // Compute largest k such that k*(k-1)/2 <= n\n    int k = 1;\n    while ((long long)k*(k-1)/2 <= n) {\n        k++;\n    }\n    return k - 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate m distinct q_i in [1,1e5]\n        // Generate w_i randomly in [1,1e5]\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n        vector<int> wi_list;\n        for (int i = 0; i < m; i++) {\n            int wi = rnd.next(1, 100000);\n            wi_list.push_back(wi);\n        }\n        \n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"one_number\") {\n        // Generate one qi with w_i = 100000\n        // Rest qi's with small w_i\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        // Let's make the first qi have w_i = 100000\n        vector<int> wi_list(m, 1); // initialize wi_list with 1\n\n        wi_list[0] = 100000; // the first qi has w_i = 100000\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"max_numbers\") {\n        int k = getMaxK(n);\n        if (k > m) k = m;\n\n        // Generate k qi with high w_i\n\n        set<int> qiset;\n        while ((int)qiset.size() < k) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list;\n        for (int i = 0; i < k; i++) {\n            wi_list.push_back(100000);\n        }\n\n        // For the rest of m - k, generate qi with small w_i\n        for (int i = k; i < m; i++) {\n            int qi;\n            do {\n                qi = rnd.next(1, 100000);\n            } while (qiset.count(qi));\n            qiset.insert(qi);\n            qi_list.push_back(qi);\n            wi_list.push_back(1);\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"small_n\") {\n        // n is already provided, but we can set n to small value\n        // Let's ensure n is small\n        if (n > 10) {\n            n = 10;\n        }\n\n        // Rest is same as \"random\"\n        // Generate m distinct q_i in [1,1e5]\n        // Generate w_i randomly in [1,1e5]\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n        vector<int> wi_list;\n        for (int i = 0; i < m; i++) {\n            int wi = rnd.next(1, 100000);\n            wi_list.push_back(wi);\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"max_n_m\") {\n        // Max n and m\n        n = 2000000;\n        m = 100000;\n\n        // Rest is same as \"random\"\n        // Generate m distinct q_i in [1,1e5]\n        // Generate w_i randomly in [1,1e5]\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n        vector<int> wi_list;\n        for (int i = 0; i < m; i++) {\n            int wi = rnd.next(1, 100000);\n            wi_list.push_back(wi);\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"increasing_wi\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list(m);\n        for (int i = 0; i < m; i++) {\n            wi_list[i] = i + 1;\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"decreasing_wi\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list(m);\n        int max_wi = 100000;\n        for (int i = 0; i < m; i++) {\n            wi_list[i] = max_wi - i;\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n\n    } else if (type == \"all_equal_wi\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        int wi_value = rnd.next(1, 100000);\n        vector<int> wi_list(m, wi_value);\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else if (type == \"large_wi_gap\") {\n        set<int> qiset;\n        while ((int)qiset.size() < m) {\n            int qi = rnd.next(1, 100000);\n            qiset.insert(qi);\n        }\n        vector<int> qi_list(qiset.begin(), qiset.end());\n\n        vector<int> wi_list(m, 1);\n        wi_list[0] = 100000;\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n\n        // Output the m coupons\n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", qi_list[i], wi_list[i]);\n        }\n    } else {\n        // Default to \"random\" or we can throw an error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        abort();\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type small_n\n./gen -n 2 -m 2 -type small_n\n./gen -n 5 -m 5 -type small_n\n./gen -n 100 -m 50 -type random\n./gen -n 1000 -m 500 -type random\n./gen -n 5000 -m 1000 -type random\n./gen -n 10000 -m 5000 -type one_number\n./gen -n 100000 -m 50000 -type one_number\n./gen -n 2000000 -m 100000 -type max_numbers\n./gen -n 2000000 -m 100000 -type increasing_wi\n./gen -n 2000000 -m 100000 -type decreasing_wi\n./gen -n 2000000 -m 100000 -type all_equal_wi\n./gen -n 1000000 -m 1000 -type large_wi_gap\n./gen -n 1000000 -m 1000 -type random\n./gen -n 1000000 -m 1000 -type max_numbers\n./gen -n 500 -m 1000 -type random\n./gen -n 2000000 -m 100000 -type random\n./gen -n 1234567 -m 76543 -type decreasing_wi\n./gen -n 2000000 -m 100000 -type large_wi_gap\n./gen -n 1 -m 100000 -type one_number\n./gen -n 2 -m 100000 -type max_numbers\n./gen -n 100000 -m 2 -type random\n./gen -n 2000000 -m 1 -type one_number\n./gen -n 100000 -m 100000 -type increasing_wi\n./gen -n 2 -m 1 -type one_number\n./gen -n 2000000 -m 100000 -type max_n_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:26.429546",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "367/D",
      "title": "D. Сережа и множества",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержатся целые числа n, m, d (1 ≤ d ≤ n ≤ 105, 1 ≤ m ≤ 20). В следующих m строках содержатся множества, первое число в i-ой строке si (1 ≤ si ≤ n) означает размер i-го множества, далее в строке содержатся si различных целых чисел от 1 до n — множество Ai.Гарантируется, что множества образуют разбиение всех целых чисел от 1 до n.",
      "output_spec": "Выходные данныеВ единственной строке выведите ответ на задачу — минимальное значение k при правильном выборе.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 2 21 22 1 3Выходные данныеСкопировать1Входные данныеСкопировать5 1 15 4 5 3 2 1Выходные данныеСкопировать1Входные данныеСкопировать7 3 14 1 3 5 72 2 61 4Выходные данныеСкопировать3",
      "description": "D. Сережа и множества\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержатся целые числа n, m, d (1 ≤ d ≤ n ≤ 105, 1 ≤ m ≤ 20). В следующих m строках содержатся множества, первое число в i-ой строке si (1 ≤ si ≤ n) означает размер i-го множества, далее в строке содержатся si различных целых чисел от 1 до n — множество Ai.Гарантируется, что множества образуют разбиение всех целых чисел от 1 до n.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите ответ на задачу — минимальное значение k при правильном выборе.\n\nВыходные данные\n\nВходные данныеСкопировать3 2 21 22 1 3Выходные данныеСкопировать1Входные данныеСкопировать5 1 15 4 5 3 2 1Выходные данныеСкопировать1Входные данныеСкопировать7 3 14 1 3 5 72 2 61 4Выходные данныеСкопировать3\n\nВходные данныеСкопировать3 2 21 22 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 1 15 4 5 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 3 14 1 3 5 72 2 61 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Всем привет!Совсем скоро, 26 ноября в 19:30 MSK состоится Codeforces Round #215, автором которого являюсь я. Это мой девятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Диме Березину (Berezin), Виталику Аксенову(Aksenov239), Михаилу Мирзаянову (MikeMirzayanov) и Максиму Бевзе(Cenadar) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка див1: 500-1000-1500-2000-2000Разбалловка див2: 500-1000-1500-2000-2500 Gl & hf ! :)Раунд завершен, спасибо за участие. Извиняюсь за ошибку в задаче A. Надеюсь, что задачи Вам понравились, а нестабильность сегодняшнего соревнования не испортила Вам настроение.Всем хорошего вечера :)Так же давайте поздравим rng_58 с достижением 3010 очков рейтинга!Разбор тут.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 840
        },
        {
          "title": "Codeforces Round #215 — Разбор задач - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Сережа и вешалкаБудем каждый раз циклом проходить по массиву и искать минимальный элемент, который еще не помечен. Если мы найдем элемент, добавим в ответ и пометим, иначе отнимем от ответа штраф.368B - Сережа и суффиксыПредпосчитаем значение ansi — количество различных элементов на суффиксе с i. Для подсчета пройдемся с конца массива, и будем считать ansi = ansi + 1 + newai, newai равно 1, если элемент ai еще не встречался и 0 в противном случае.367A - Сережа и алгоритмЕсли разобраться в том, что написано в условии, то станет понятно что алгоритм закончит свою работу, если мы можем получить строку вида: xx, yy, zz, zyxzyxzyx... и все ее циклические сдвиги. Для проверки нужно просто знать количество букв x, y и z по отдельности. Количества можно считать с помощью частичных сумм. 367B - Сережа и анаграммыРазобьем последовательность на min(n, p) последовательностей. 1-й, (1 + p)-й, (1 + 2·p)-й, ... символ идет в первую последовательность, 2-й, (2 + p)-й, (2 + 2·p)-й... идут во вторую последовательность и так далее. Теперь ответ нужно найти для каждой из них, считая что p = 1. Это можно решить простым методом. Можно пройтись по последовательности слева на право и посчитать количество вхождений каждого числа. Если количества вхождений каждого числа будет совпадать с количеством вхождения того же числа во вторую последовательность, то все ОК.367C - Сережа и расстановка чиселПонятно, что нужно набрать как можно больше самых дорогих чисел, что бы из них можно было построить массив. Замечу, что имея n чисел, мы будем иметь m = n·(n - 1) / 2 обязательных связей. Видим, что это граф, в котором нужно сделать Эйлеров путь, добавив как можно меньше ребер. Для n%2 = 1 — все ясно, а для n%2 = 0 нужно добавить n / 2 - 1 дополнительное ребро. Почему? Это Ваше домашнее задание :)Так же подробное объяснение Вы можете найти здесь. 367D - Сережа и множестваЗаменим все множества одним массивом, где элемент — номер множества, которому принадлежит индекс. Теперь возьмем все последовательные отрезки длиной d и найдем множество элементов, которое там не встречается. Понятно, что если в качестве ответа мы выберем подмножество такого множества, то оно нам не подойдет. Запомним все такие \"плохие надмножества\". Когда мы всех их знаем, найдем все \"плохие\" множества. Выберем самое большое по количеству элементов не плохое множество. Лучше всего здесь работать с битовыми масками. 367E - Сережа и отрезкиБудем считать, что отрезки отсортированы, а в конце ответ домножим на n!, мы можем так сделать, так как все отрезки будут различные.Рассмотрим два случая n > m и n ≤ m. Казалось бы нужно для обеих писать динамику за разную сложность, но не сложно показать, что в первом случае ответ 0. Второй случай делается следующей динамикой: dpi, l, r, i — сколько чисел мы рассмотрели, l, r — только на этом интервале отрезков будет присутствовать i. Так же нам будет нужна вспомогательная динамика si, l, i — сколько чисел рассмотрели, l — сколько отрезков уже закрыто, и i ничему не принадлежит. Переходов будет 4, так как на каждом числе у нас может начинаться и заканчиваться не более одного отрезка. Осталось прилепить число x, это делается достаточно просто: просто добавим еще один параметр 0 / 1 в динамику, было ли у нас такое начало интервала или нет. Учитывая нашу динамику, это не составит труда.Для уточнения деталей решений просмотрите любое прошедшее системное тестирование решение.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 367\\s*D"
          },
          "content_length": 3440
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "long long index = i + (p-1) * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "n, m, p = 100000, 100000, ...\nprint(n, m, p)\nL = ' '.join(map(str, [i % 4243 + 1 for i in range(n)]))\nprint(L)\nprint(L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "n, m, p = 100000, 100000, ...\nprint(n, m, p)\nL = ' '.join(map(str, [i % 4243 + 1 for i in range(n)]))\nprint(L)\nprint(L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "(m - 1) * p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "sum[0] = 0;\n\nfor(int i = 1; i <= n; i++) {\n    sum[i] = sum[i - 1] + a[i - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "sum[0] = 0;\n\nfor(int i = 1; i <= n; i++) {\n    sum[i] = sum[i - 1] + a[i - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "result = sum[r] - sum[l - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 8",
          "code": "result = sum[r] - sum[l - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 9",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 10",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 11",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 12",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 13",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 14",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 15",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false); // 1-based indexing\n\n    for (int i = 0; i < m; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n\n        set<int> Ai_set;\n\n        for (int j = 0; j < si; ++j) {\n            int aij = inf.readInt(1, n, \"aij\");\n            if (j + 1 < si) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n            // Check that aij is not duplicated in Ai\n            ensuref(Ai_set.insert(aij).second, \"Duplicate element %d in set %d\", aij, i + 1);\n            // Check that aij has not been seen before in other sets\n            ensuref(!seen[aij], \"Element %d occurs in more than one set\", aij);\n            seen[aij] = true;\n        }\n    }\n\n    // Check that all elements from 1 to n are present\n    for (int v = 1; v <= n; ++v) {\n        ensuref(seen[v], \"Element %d is missing from the sets\", v);\n    }\n\n    inf.readEof(); // Ensure end of file\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false); // 1-based indexing\n\n    for (int i = 0; i < m; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n\n        set<int> Ai_set;\n\n        for (int j = 0; j < si; ++j) {\n            int aij = inf.readInt(1, n, \"aij\");\n            if (j + 1 < si) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n            // Check that aij is not duplicated in Ai\n            ensuref(Ai_set.insert(aij).second, \"Duplicate element %d in set %d\", aij, i + 1);\n            // Check that aij has not been seen before in other sets\n            ensuref(!seen[aij], \"Element %d occurs in more than one set\", aij);\n            seen[aij] = true;\n        }\n    }\n\n    // Check that all elements from 1 to n are present\n    for (int v = 1; v <= n; ++v) {\n        ensuref(seen[v], \"Element %d is missing from the sets\", v);\n    }\n\n    inf.readEof(); // Ensure end of file\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false); // 1-based indexing\n\n    for (int i = 0; i < m; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n\n        set<int> Ai_set;\n\n        for (int j = 0; j < si; ++j) {\n            int aij = inf.readInt(1, n, \"aij\");\n            if (j + 1 < si) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n            // Check that aij is not duplicated in Ai\n            ensuref(Ai_set.insert(aij).second, \"Duplicate element %d in set %d\", aij, i + 1);\n            // Check that aij has not been seen before in other sets\n            ensuref(!seen[aij], \"Element %d occurs in more than one set\", aij);\n            seen[aij] = true;\n        }\n    }\n\n    // Check that all elements from 1 to n are present\n    for (int v = 1; v <= n; ++v) {\n        ensuref(seen[v], \"Element %d is missing from the sets\", v);\n    }\n\n    inf.readEof(); // Ensure end of file\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(1 <= m && m <= 20, \"m must be between 1 and 20\");\n    ensuref(1 <= d && d <= n, \"d must be between 1 and n\");\n\n    vector<int> elements(n);\n    for (int i = 0; i < n; ++i) {\n        elements[i] = i + 1;\n    }\n\n    vector<vector<int>> sets(m);\n\n    if (type == \"random\") {\n        // Shuffle elements\n        shuffle(elements.begin(), elements.end());\n        // Distribute elements randomly into m sets\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sets[idx].push_back(elements[i]);\n        }\n    } else if (type == \"equal\") {\n        // Shuffle elements (to randomize)\n        shuffle(elements.begin(), elements.end());\n        // Divide elements equally\n        int baseSize = n / m;\n        int extra = n % m; // Distribute extra ones to the first 'extra' sets\n        int pos = 0;\n        for (int i = 0; i < m; ++i) {\n            int size = baseSize + (i < extra ? 1 : 0);\n            for (int j = 0; j < size; ++j) {\n                sets[i].push_back(elements[pos++]);\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Shuffle elements (to randomize)\n        shuffle(elements.begin(), elements.end());\n        // One big set, rest are small\n        int bigSetSize = n - (m - 1); // One set has most elements\n        sets[0].assign(elements.begin(), elements.begin() + bigSetSize);\n        int pos = bigSetSize;\n        for (int i = 1; i < m; ++i) {\n            sets[i].push_back(elements[pos++]);\n        }\n    } else if (type == \"sequential\") {\n        // Elements are in order\n        // Divide elements into sequential blocks\n        int baseSize = n / m;\n        int extra = n % m; // Distribute extra ones to the first 'extra' sets\n        int pos = 0;\n        for (int i = 0; i < m; ++i) {\n            int size = baseSize + (i < extra ? 1 : 0);\n            for (int j = 0; j < size; ++j) {\n                sets[i].push_back(elements[pos++]);\n            }\n        }\n    } else if (type == \"reverse_sequential\") {\n        // Reverse elements\n        reverse(elements.begin(), elements.end());\n        // Divide elements into sequential blocks\n        int baseSize = n / m;\n        int extra = n % m; // Distribute extra ones to the first 'extra' sets\n        int pos = 0;\n        for (int i = 0; i < m; ++i) {\n            int size = baseSize + (i < extra ? 1 : 0);\n            for (int j = 0; j < size; ++j) {\n                sets[i].push_back(elements[pos++]);\n            }\n        }\n    } else if (type == \"one_set\") {\n        ensuref(m == 1, \"m must be 1 for type 'one_set'\");\n        sets[0].assign(elements.begin(), elements.end());\n    } else if (type == \"single_element_sets\") {\n        ensuref(m == n, \"m must be equal to n for type 'single_element_sets'\");\n        // Shuffle elements\n        shuffle(elements.begin(), elements.end());\n        for (int i = 0; i < n; ++i) {\n            sets[i].push_back(elements[i]);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output n m d\n    printf(\"%d %d %d\\n\", n, m, d);\n    // Output sets\n    for (int i = 0; i < m; ++i) {\n        int si = sets[i].size();\n        printf(\"%d\", si);\n        // Shuffle elements inside the set\n        shuffle(sets[i].begin(), sets[i].end());\n        for (int x : sets[i]) {\n            printf(\" %d\", x);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(1 <= m && m <= 20, \"m must be between 1 and 20\");\n    ensuref(1 <= d && d <= n, \"d must be between 1 and n\");\n\n    vector<int> elements(n);\n    for (int i = 0; i < n; ++i) {\n        elements[i] = i + 1;\n    }\n\n    vector<vector<int>> sets(m);\n\n    if (type == \"random\") {\n        // Shuffle elements\n        shuffle(elements.begin(), elements.end());\n        // Distribute elements randomly into m sets\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sets[idx].push_back(elements[i]);\n        }\n    } else if (type == \"equal\") {\n        // Shuffle elements (to randomize)\n        shuffle(elements.begin(), elements.end());\n        // Divide elements equally\n        int baseSize = n / m;\n        int extra = n % m; // Distribute extra ones to the first 'extra' sets\n        int pos = 0;\n        for (int i = 0; i < m; ++i) {\n            int size = baseSize + (i < extra ? 1 : 0);\n            for (int j = 0; j < size; ++j) {\n                sets[i].push_back(elements[pos++]);\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Shuffle elements (to randomize)\n        shuffle(elements.begin(), elements.end());\n        // One big set, rest are small\n        int bigSetSize = n - (m - 1); // One set has most elements\n        sets[0].assign(elements.begin(), elements.begin() + bigSetSize);\n        int pos = bigSetSize;\n        for (int i = 1; i < m; ++i) {\n            sets[i].push_back(elements[pos++]);\n        }\n    } else if (type == \"sequential\") {\n        // Elements are in order\n        // Divide elements into sequential blocks\n        int baseSize = n / m;\n        int extra = n % m; // Distribute extra ones to the first 'extra' sets\n        int pos = 0;\n        for (int i = 0; i < m; ++i) {\n            int size = baseSize + (i < extra ? 1 : 0);\n            for (int j = 0; j < size; ++j) {\n                sets[i].push_back(elements[pos++]);\n            }\n        }\n    } else if (type == \"reverse_sequential\") {\n        // Reverse elements\n        reverse(elements.begin(), elements.end());\n        // Divide elements into sequential blocks\n        int baseSize = n / m;\n        int extra = n % m; // Distribute extra ones to the first 'extra' sets\n        int pos = 0;\n        for (int i = 0; i < m; ++i) {\n            int size = baseSize + (i < extra ? 1 : 0);\n            for (int j = 0; j < size; ++j) {\n                sets[i].push_back(elements[pos++]);\n            }\n        }\n    } else if (type == \"one_set\") {\n        ensuref(m == 1, \"m must be 1 for type 'one_set'\");\n        sets[0].assign(elements.begin(), elements.end());\n    } else if (type == \"single_element_sets\") {\n        ensuref(m == n, \"m must be equal to n for type 'single_element_sets'\");\n        // Shuffle elements\n        shuffle(elements.begin(), elements.end());\n        for (int i = 0; i < n; ++i) {\n            sets[i].push_back(elements[i]);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output n m d\n    printf(\"%d %d %d\\n\", n, m, d);\n    // Output sets\n    for (int i = 0; i < m; ++i) {\n        int si = sets[i].size();\n        printf(\"%d\", si);\n        // Shuffle elements inside the set\n        shuffle(sets[i].begin(), sets[i].end());\n        for (int x : sets[i]) {\n            printf(\" %d\", x);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n, m, d\n./gen -n 1 -m 1 -d 1 -type one_set\n\n# Small n, m, d\n./gen -n 10 -m 1 -d 1 -type one_set\n\n# Small n, maximal m\n./gen -n 10 -m 10 -d 5 -type random\n\n# Medium n, small m, small d\n./gen -n 1000 -m 3 -d 1 -type random\n\n# Medium n, maximal m, medium d\n./gen -n 1000 -m 20 -d 500 -type equal\n\n# Maximal n, minimal m\n./gen -n 100000 -m 1 -d 100000 -type one_set\n\n# Maximal n, maximal m, minimal d\n./gen -n 100000 -m 20 -d 1 -type random\n\n# Maximal n, maximal m, maximal d\n./gen -n 100000 -m 20 -d 100000 -type sequential\n\n# Maximal n, skewed sets\n./gen -n 100000 -m 20 -d 50000 -type skewed\n\n# Random d\n./gen -n 100000 -m 20 -d 12345 -type random\n\n# Small n, test 'single_element_sets' type\n./gen -n 20 -m 20 -d 10 -type single_element_sets\n\n# Medium n, reverse sequential\n./gen -n 1000 -m 5 -d 200 -type reverse_sequential\n\n# Testing d=1 cases\n./gen -n 50000 -m 15 -d 1 -type random\n./gen -n 99999 -m 19 -d 1 -type skewed\n\n# Testing d=n cases\n./gen -n 50000 -m 10 -d 50000 -type equal\n./gen -n 100000 -m 20 -d 100000 -type skewed\n\n# Testing when b1 may be large\n./gen -n 100000 -m 20 -d 50000 -type reverse_sequential\n\n# Testing when b|b| may be small\n./gen -n 100000 -m 20 -d 1 -type reverse_sequential\n\n# Testing different random instances\n./gen -n 100000 -m 20 -d 50000 -type random\n./gen -n 100000 -m 20 -d 50000 -type random\n./gen -n 100000 -m 20 -d 50000 -type random\n\n# Testing small n, different d\n./gen -n 50 -m 5 -d 25 -type random\n./gen -n 50 -m 5 -d 1 -type random\n\n# Testing when m is at maximum\n./gen -n 99999 -m 20 -d 1000 -type skewed\n\n# Testing when m is minimum\n./gen -n 1000 -m 1 -d 500 -type one_set\n\n# Testing small n, m, d\n./gen -n 5 -m 1 -d 1 -type one_set\n./gen -n 5 -m 5 -d 3 -type equal\n\n# Testing with d greater than n/2\n./gen -n 1000 -m 5 -d 600 -type random\n\n# Testing when elements are in order\n./gen -n 1000 -m 10 -d 1000 -type sequential\n\n# Testing when elements are in reverse order\n./gen -n 1000 -m 10 -d 1 -type reverse_sequential\n\n# Maximal constraints\n./gen -n 100000 -m 20 -d 1 -type random\n\n# Another maximal\n./gen -n 100000 -m 1 -d 1 -type one_set\n\n# Edge case: n and m are both small\n./gen -n 2 -m 2 -d 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:28.817906",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "367/E",
      "title": "E. Sereja and Intervals",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m, x (1 ≤ n·m ≤ 100000, 1 ≤ x ≤ m) — the number of segments in the sequence, the constraints on the numbers in segments and Sereja's favourite number.",
      "output_spec": "OutputIn a single line print the answer modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1 1 1OutputCopy1InputCopy3 5 1OutputCopy240InputCopy2 3 3OutputCopy6",
      "description": "E. Sereja and Intervals\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m, x (1 ≤ n·m ≤ 100000, 1 ≤ x ≤ m) — the number of segments in the sequence, the constraints on the numbers in segments and Sereja's favourite number.\n\nOutputIn a single line print the answer modulo 1000000007 (109 + 7).\n\nInputCopy1 1 1OutputCopy1InputCopy3 5 1OutputCopy240InputCopy2 3 3OutputCopy6\n\nInputCopy1 1 1\n\nOutputCopy1\n\nInputCopy3 5 1\n\nOutputCopy240\n\nInputCopy2 3 3\n\nOutputCopy6\n\nNoteIn third example next sequences will be correct: {[1, 1], [3, 3]}, {[1, 2], [3, 3]}, {[2, 2], [3, 3]}, {[3, 3], [1, 1]}, {[3, 3], [2, 2]}, {[3, 3], [1, 2]}.",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 367\\s*E"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(1, m, \"x\");\n    inf.readEoln();\n\n    ensuref(1LL * n * m <= 100000, \"n*m must be <= 100000, but n = %d, m = %d, n*m = %lld\", n, m, 1LL * n * m);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(1, m, \"x\");\n    inf.readEoln();\n\n    ensuref(1LL * n * m <= 100000, \"n*m must be <= 100000, but n = %d, m = %d, n*m = %lld\", n, m, 1LL * n * m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(1, m, \"x\");\n    inf.readEoln();\n\n    ensuref(1LL * n * m <= 100000, \"n*m must be <= 100000, but n = %d, m = %d, n*m = %lld\", n, m, 1LL * n * m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int x = opt<int>(\"x\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        m = 1;\n        x = 1;\n    } else if (type == \"max_n\") {\n        n = 100000;\n        m = 1;\n        x = 1;\n    } else if (type == \"max_m\") {\n        n = 1;\n        m = 100000;\n        x = rnd.next(1, m);\n    } else if (type == \"max_both\") {\n        // n and m as big as possible, n*m <= 100000\n        n = 316;\n        m = 316;\n        x = rnd.next(1, m);\n    } else if (type == \"x_at_start\") {\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 100000 / n);\n        x = 1;\n    } else if (type == \"x_at_end\") {\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 100000 / n);\n        x = m;\n    } else if (type == \"x_in_middle\") {\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 100000 / n);\n        x = m / 2;\n        if (x < 1) x = 1;\n    } else if (type == \"n_small_m_large\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 100000 / n);\n        x = rnd.next(1, m);\n    } else if (type == \"n_large_m_small\") {\n        m = rnd.next(1, 10);\n        n = rnd.next(1, 100000 / m);\n        x = rnd.next(1, m);\n    } else {\n        // Random case\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) m = rnd.next(1, max(1, 100000 / n));\n        if (x == -1) x = rnd.next(1, m);\n    }\n\n    // Ensure that n * m <= 100000\n    while ((long long)n * m > 100000) {\n        if (n > m) {\n            n = 100000 / m;\n        } else {\n            m = 100000 / n;\n        }\n        if (n == 0) n = 1;\n        if (m == 0) m = 1;\n    }\n\n    // Ensure x within [1, m]\n    if (x < 1) x = 1;\n    if (x > m) x = m;\n\n    printf(\"%d %d %d\\n\", n, m, x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int x = opt<int>(\"x\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        m = 1;\n        x = 1;\n    } else if (type == \"max_n\") {\n        n = 100000;\n        m = 1;\n        x = 1;\n    } else if (type == \"max_m\") {\n        n = 1;\n        m = 100000;\n        x = rnd.next(1, m);\n    } else if (type == \"max_both\") {\n        // n and m as big as possible, n*m <= 100000\n        n = 316;\n        m = 316;\n        x = rnd.next(1, m);\n    } else if (type == \"x_at_start\") {\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 100000 / n);\n        x = 1;\n    } else if (type == \"x_at_end\") {\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 100000 / n);\n        x = m;\n    } else if (type == \"x_in_middle\") {\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 100000 / n);\n        x = m / 2;\n        if (x < 1) x = 1;\n    } else if (type == \"n_small_m_large\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 100000 / n);\n        x = rnd.next(1, m);\n    } else if (type == \"n_large_m_small\") {\n        m = rnd.next(1, 10);\n        n = rnd.next(1, 100000 / m);\n        x = rnd.next(1, m);\n    } else {\n        // Random case\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) m = rnd.next(1, max(1, 100000 / n));\n        if (x == -1) x = rnd.next(1, m);\n    }\n\n    // Ensure that n * m <= 100000\n    while ((long long)n * m > 100000) {\n        if (n > m) {\n            n = 100000 / m;\n        } else {\n            m = 100000 / n;\n        }\n        if (n == 0) n = 1;\n        if (m == 0) m = 1;\n    }\n\n    // Ensure x within [1, m]\n    if (x < 1) x = 1;\n    if (x > m) x = m;\n\n    printf(\"%d %d %d\\n\", n, m, x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max_n\n\n./gen -type max_m\n\n./gen -type max_both\n\n./gen -type x_at_start\n\n./gen -type x_at_end\n\n./gen -type x_in_middle\n\n./gen -type n_small_m_large\n\n./gen -type n_large_m_small\n\n./gen -n 50000 -m 2 -x 1\n\n./gen -n 1000 -m 100 -x 50\n\n./gen -n 99999 -m 1 -x 1\n\n./gen -n 1 -m 99999 -x 50000\n\n./gen -n 10 -m 10000 -x 5000\n\n./gen -n 10000 -m 10 -x 7\n\n./gen -n 316 -m 316 -x 100\n\n./gen -n 100 -m 1000 -x 1\n\n./gen -n 100 -m 1000 -x 1000\n\n./gen -n 100000 -m 1 -x 1\n\n./gen -n 1 -m 100000 -x 1\n\n./gen -n 1 -m 100000 -x 100000\n\n./gen -n 100 -m 1000 -x 500\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -n 100000 -m 1 -x 1\n\n./gen -n 1 -m 100000 -x 5000\n\n./gen -n 1000 -m 100 -x 25\n\n./gen -n 1000 -m 100 -x 1\n\n./gen -n 1000 -m 100 -x 100\n\n./gen -n 1000 -m 100 -x 50\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:31.283589",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "368/A",
      "title": "A. Сережа и вешалка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n и d (1 ≤ n, d ≤ 100). Следующая строка содержит целые числа a1, a2, ..., an (1 ≤ ai ≤ 100). Третья строка содержит целое число m (1 ≤ m ≤ 100).",
      "output_spec": "Выходные данныеВ единственную строку выведите целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 12 12Выходные данныеСкопировать3Входные данныеСкопировать2 12 110Выходные данныеСкопировать-5",
      "description": "A. Сережа и вешалка\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа n и d (1 ≤ n, d ≤ 100). Следующая строка содержит целые числа a1, a2, ..., an (1 ≤ ai ≤ 100). Третья строка содержит целое число m (1 ≤ m ≤ 100).\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать2 12 12Выходные данныеСкопировать3Входные данныеСкопировать2 12 110Выходные данныеСкопировать-5\n\nВходные данныеСкопировать2 12 12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 12 110\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте после прихода всех гостей обе вешалки будут заняты, поэтому Сережа получит прибыль 1 + 2 = 3 рублей.Во втором тесте после прихода всех гостей обе вешалки будут заняты, но и Сережа заплатит штраф 8 раз, поэтому его прибыль составит 3 - 8 =  - 5 рублей.",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Всем привет!Совсем скоро, 26 ноября в 19:30 MSK состоится Codeforces Round #215, автором которого являюсь я. Это мой девятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Диме Березину (Berezin), Виталику Аксенову(Aksenov239), Михаилу Мирзаянову (MikeMirzayanov) и Максиму Бевзе(Cenadar) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка див1: 500-1000-1500-2000-2000Разбалловка див2: 500-1000-1500-2000-2500 Gl & hf ! :)Раунд завершен, спасибо за участие. Извиняюсь за ошибку в задаче A. Надеюсь, что задачи Вам понравились, а нестабильность сегодняшнего соревнования не испортила Вам настроение.Всем хорошего вечера :)Так же давайте поздравим rng_58 с достижением 3010 очков рейтинга!Разбор тут.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 840
        },
        {
          "title": "Codeforces Round #215 — Разбор задач - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Сережа и вешалкаБудем каждый раз циклом проходить по массиву и искать минимальный элемент, который еще не помечен. Если мы найдем элемент, добавим в ответ и пометим, иначе отнимем от ответа штраф.368B - Сережа и суффиксыПредпосчитаем значение ansi — количество различных элементов на суффиксе с i. Для подсчета пройдемся с конца массива, и будем считать ansi = ansi + 1 + newai, newai равно 1, если элемент ai еще не встречался и 0 в противном случае.367A - Сережа и алгоритмЕсли разобраться в том, что написано в условии, то станет понятно что алгоритм закончит свою работу, если мы можем получить строку вида: xx, yy, zz, zyxzyxzyx... и все ее циклические сдвиги. Для проверки нужно просто знать количество букв x, y и z по отдельности. Количества можно считать с помощью частичных сумм. 367B - Сережа и анаграммыРазобьем последовательность на min(n, p) последовательностей. 1-й, (1 + p)-й, (1 + 2·p)-й, ... символ идет в первую последовательность, 2-й, (2 + p)-й, (2 + 2·p)-й... идут во вторую последовательность и так далее. Теперь ответ нужно найти для каждой из них, считая что p = 1. Это можно решить простым методом. Можно пройтись по последовательности слева на право и посчитать количество вхождений каждого числа. Если количества вхождений каждого числа будет совпадать с количеством вхождения того же числа во вторую последовательность, то все ОК.367C - Сережа и расстановка чиселПонятно, что нужно набрать как можно больше самых дорогих чисел, что бы из них можно было построить массив. Замечу, что имея n чисел, мы будем иметь m = n·(n - 1) / 2 обязательных связей. Видим, что это граф, в котором нужно сделать Эйлеров путь, добавив как можно меньше ребер. Для n%2 = 1 — все ясно, а для n%2 = 0 нужно добавить n / 2 - 1 дополнительное ребро. Почему? Это Ваше домашнее задание :)Так же подробное объяснение Вы можете найти здесь. 367D - Сережа и множестваЗаменим все множества одним массивом, где элемент — номер множества, которому принадлежит индекс. Теперь возьмем все последовательные отрезки длиной d и найдем множество элементов, которое там не встречается. Понятно, что если в качестве ответа мы выберем подмножество такого множества, то оно нам не подойдет. Запомним все такие \"плохие надмножества\". Когда мы всех их знаем, найдем все \"плохие\" множества. Выберем самое большое по количеству элементов не плохое множество. Лучше всего здесь работать с битовыми масками. 367E - Сережа и отрезкиБудем считать, что отрезки отсортированы, а в конце ответ домножим на n!, мы можем так сделать, так как все отрезки будут различные.Рассмотрим два случая n > m и n ≤ m. Казалось бы нужно для обеих писать динамику за разную сложность, но не сложно показать, что в первом случае ответ 0. Второй случай делается следующей динамикой: dpi, l, r, i — сколько чисел мы рассмотрели, l, r — только на этом интервале отрезков будет присутствовать i. Так же нам будет нужна вспомогательная динамика si, l, i — сколько чисел рассмотрели, l — сколько отрезков уже закрыто, и i ничему не принадлежит. Переходов будет 4, так как на каждом числе у нас может начинаться и заканчиваться не более одного отрезка. Осталось прилепить число x, это делается достаточно просто: просто добавим еще один параметр 0 / 1 в динамику, было ли у нас такое начало интервала или нет. Учитывая нашу динамику, это не составит труда.Для уточнения деталей решений просмотрите любое прошедшее системное тестирование решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 368\\s*A"
          },
          "content_length": 3440
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "long long index = i + (p-1) * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "n, m, p = 100000, 100000, ...\nprint(n, m, p)\nL = ' '.join(map(str, [i % 4243 + 1 for i in range(n)]))\nprint(L)\nprint(L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "n, m, p = 100000, 100000, ...\nprint(n, m, p)\nL = ' '.join(map(str, [i % 4243 + 1 for i in range(n)]))\nprint(L)\nprint(L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "(m - 1) * p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "sum[0] = 0;\n\nfor(int i = 1; i <= n; i++) {\n    sum[i] = sum[i - 1] + a[i - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "sum[0] = 0;\n\nfor(int i = 1; i <= n; i++) {\n    sum[i] = sum[i - 1] + a[i - 1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "result = sum[r] - sum[l - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 8",
          "code": "result = sum[r] - sum[l - 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 9",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 10",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 11",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 12",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 13",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 14",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 15",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100);\n    inf.readSpace();\n    int d = inf.readInt(1, 100);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100);\n    inf.readSpace();\n    int d = inf.readInt(1, 100);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100);\n    inf.readSpace();\n    int d = inf.readInt(1, 100);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n\n    vector<int> a(n);\n\n    if (ai_type == \"min\") {\n        /* All hook prices are minimum (1 ruble) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (ai_type == \"max\") {\n        /* All hook prices are maximum (100 rubles) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (ai_type == \"equal\") {\n        /* All hook prices are equal to ai_value */\n        int value = opt<int>(\"ai_value\");\n        for (int i = 0; i < n; ++i)\n            a[i] = value;\n    } else if (ai_type == \"alternating\") {\n        /* Hook prices alternate between 1 and 100 */\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : 100;\n    } else if (ai_type == \"sparse\") {\n        /* Few hooks have low price, others have high price */\n        int low_count = opt<int>(\"low_count\", n / 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n        for (int i = 0; i < low_count; ++i)\n            a[i] = 1;\n        shuffle(a.begin(), a.end());\n    } else {\n        /* Random hook prices between 1 and 100 */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    /* Output n and d */\n    printf(\"%d %d\\n\", n, d);\n\n    /* Output hook prices */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    /* Output m */\n    printf(\"%d\\n\", m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n\n    vector<int> a(n);\n\n    if (ai_type == \"min\") {\n        /* All hook prices are minimum (1 ruble) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (ai_type == \"max\") {\n        /* All hook prices are maximum (100 rubles) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (ai_type == \"equal\") {\n        /* All hook prices are equal to ai_value */\n        int value = opt<int>(\"ai_value\");\n        for (int i = 0; i < n; ++i)\n            a[i] = value;\n    } else if (ai_type == \"alternating\") {\n        /* Hook prices alternate between 1 and 100 */\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : 100;\n    } else if (ai_type == \"sparse\") {\n        /* Few hooks have low price, others have high price */\n        int low_count = opt<int>(\"low_count\", n / 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n        for (int i = 0; i < low_count; ++i)\n            a[i] = 1;\n        shuffle(a.begin(), a.end());\n    } else {\n        /* Random hook prices between 1 and 100 */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    /* Output n and d */\n    printf(\"%d %d\\n\", n, d);\n\n    /* Output hook prices */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    /* Output m */\n    printf(\"%d\\n\", m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size test cases\n./gen -n 1 -m 1 -d 1 -ai_type min\n./gen -n 1 -m 1 -d 1 -ai_type max\n./gen -n 1 -m 1 -d 1 -ai_type equal -ai_value 50\n\n# Test cases where m > n (many guests, few hooks)\n./gen -n 1 -m 100 -d 1 -ai_type min\n./gen -n 1 -m 100 -d 1 -ai_type max\n./gen -n 1 -m 100 -d 100 -ai_type min\n./gen -n 50 -m 100 -d 1 -ai_type min\n./gen -n 50 -m 100 -d 100 -ai_type max\n\n# Test cases where m < n (few guests, many hooks)\n./gen -n 100 -m 10 -d 1 -ai_type random\n./gen -n 100 -m 10 -d 100 -ai_type random\n\n# Test cases with maximum size\n./gen -n 100 -m 100 -d 1 -ai_type random\n./gen -n 100 -m 100 -d 100 -ai_type random\n./gen -n 100 -m 100 -d 1 -ai_type min\n./gen -n 100 -m 100 -d 1 -ai_type max\n./gen -n 100 -m 100 -d 100 -ai_type min\n./gen -n 100 -m 100 -d 100 -ai_type max\n\n# Test cases with alternating hook prices\n./gen -n 100 -m 100 -d 1 -ai_type alternating\n./gen -n 100 -m 50 -d 1 -ai_type alternating\n./gen -n 100 -m 150 -d 1 -ai_type alternating\n\n# Test cases with equal hook prices\n./gen -n 100 -m 100 -d 1 -ai_type equal -ai_value 1\n./gen -n 100 -m 100 -d 1 -ai_type equal -ai_value 50\n./gen -n 100 -m 100 -d 1 -ai_type equal -ai_value 100\n\n# Test cases with sparse low-cost hooks\n./gen -n 100 -m 100 -d 1 -ai_type sparse -low_count 5\n./gen -n 100 -m 100 -d 1 -ai_type sparse -low_count 10\n./gen -n 100 -m 150 -d 1 -ai_type sparse -low_count 5\n\n# Test cases varying the fine d\n./gen -n 50 -m 50 -d 1 -ai_type random\n./gen -n 50 -m 50 -d 100 -ai_type random\n\n# Test cases where n equals m\n./gen -n 100 -m 100 -d 1 -ai_type min\n./gen -n 100 -m 100 -d 1 -ai_type max\n\n# Test cases with maximum hook prices\n./gen -n 100 -m 1 -d 1 -ai_type max\n./gen -n 100 -m 1 -d 100 -ai_type max\n\n# Edge cases with one hook and many guests\n./gen -n 1 -m 100 -d 1 -ai_type max\n./gen -n 1 -m 100 -d 1 -ai_type min\n\n# Test cases with random hook prices\n./gen -n 95 -m 95 -d 50 -ai_type random\n./gen -n 70 -m 80 -d 20 -ai_type random\n\n# Test cases with m = n and random hook prices\n./gen -n 100 -m 100 -d 1 -ai_type random\n./gen -n 100 -m 100 -d 100 -ai_type random\n\n# Test cases with m = 1 and random hook prices\n./gen -n 100 -m 1 -d 1 -ai_type random\n./gen -n 100 -m 1 -d 100 -ai_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:33.850514",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "368/B",
      "title": "B. Sereja and Suffixes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 105). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 105) — the array elements.Next m lines contain integers l1, l2, ..., lm. The i-th line contains integer li (1 ≤ li ≤ n).",
      "output_spec": "OutputPrint m lines — on the i-th line print the answer to the number li.",
      "sample_tests": "ExamplesInputCopy10 101 2 3 4 1 2 3 4 100000 9999912345678910OutputCopy6666654321",
      "description": "B. Sereja and Suffixes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 105). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 105) — the array elements.Next m lines contain integers l1, l2, ..., lm. The i-th line contains integer li (1 ≤ li ≤ n).\n\nOutputPrint m lines — on the i-th line print the answer to the number li.\n\nInputCopy10 101 2 3 4 1 2 3 4 100000 9999912345678910OutputCopy6666654321\n\nInputCopy10 101 2 3 4 1 2 3 4 100000 9999912345678910\n\nOutputCopy6666654321",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 368\\s*B"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string li_type = opt<string>(\"li_type\", \"random\");\n\n    vector<int> a(n);\n\n    if (ai_type == \"all_same\") {\n        int x = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (ai_type == \"all_distinct\") {\n        // Need to ensure ai[i] ≤ 1e5 and ai are distinct\n        // Since n ≤ 1e5, we can assign ai[i]=i+1\n        // Shuffle them for randomness\n        vector<int> nums;\n        for (int i = 1; i <= n; ++i) {\n            nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = nums[i];\n        }\n    } else if (ai_type == \"permutation\") {\n        // Same as all_distinct, but perhaps we can shuffle in order\n        vector<int> nums;\n        for (int i = 1; i <= n; ++i) {\n            nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = nums[i];\n        }\n    } else if (ai_type == \"small_range\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (ai_type == \"big_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n    } else if (ai_type == \"alternating\") {\n        int x = rnd.next(1, 100000);\n        int y = rnd.next(1, 100000);\n        while (y == x) {\n            y = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else { // default is \"random\"\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Generate li\n\n    vector<int> li(m);\n\n    if (li_type == \"from_start\") {\n        // li = 1,2,... up to m (but li ≤ n)\n        for (int i = 0; i < m; ++i) {\n            li[i] = min(i + 1, n);\n        }\n    } else if (li_type == \"from_end\") {\n        // li = n, n-1, ..., up to m\n        for (int i = 0; i < m; ++i) {\n            li[i] = max(n - i, 1);\n        }\n    } else if (li_type == \"middle\") {\n        int mid = n / 2;\n        for (int i = 0; i < m; ++i) {\n            li[i] = mid + 1; // since positions are 1-based\n        }\n    } else if (li_type == \"first\") {\n        for (int i = 0; i < m; ++i) {\n            li[i] = 1;\n        }\n    } else if (li_type == \"last\") {\n        for (int i = 0; i < m; ++i) {\n            li[i] = n;\n        }\n    } else { // default is \"random\"\n        for (int i = 0; i < m; ++i) {\n            li[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n -1) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\\n\", li[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string li_type = opt<string>(\"li_type\", \"random\");\n\n    vector<int> a(n);\n\n    if (ai_type == \"all_same\") {\n        int x = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (ai_type == \"all_distinct\") {\n        // Need to ensure ai[i] ≤ 1e5 and ai are distinct\n        // Since n ≤ 1e5, we can assign ai[i]=i+1\n        // Shuffle them for randomness\n        vector<int> nums;\n        for (int i = 1; i <= n; ++i) {\n            nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = nums[i];\n        }\n    } else if (ai_type == \"permutation\") {\n        // Same as all_distinct, but perhaps we can shuffle in order\n        vector<int> nums;\n        for (int i = 1; i <= n; ++i) {\n            nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = nums[i];\n        }\n    } else if (ai_type == \"small_range\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (ai_type == \"big_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n    } else if (ai_type == \"alternating\") {\n        int x = rnd.next(1, 100000);\n        int y = rnd.next(1, 100000);\n        while (y == x) {\n            y = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else { // default is \"random\"\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Generate li\n\n    vector<int> li(m);\n\n    if (li_type == \"from_start\") {\n        // li = 1,2,... up to m (but li ≤ n)\n        for (int i = 0; i < m; ++i) {\n            li[i] = min(i + 1, n);\n        }\n    } else if (li_type == \"from_end\") {\n        // li = n, n-1, ..., up to m\n        for (int i = 0; i < m; ++i) {\n            li[i] = max(n - i, 1);\n        }\n    } else if (li_type == \"middle\") {\n        int mid = n / 2;\n        for (int i = 0; i < m; ++i) {\n            li[i] = mid + 1; // since positions are 1-based\n        }\n    } else if (li_type == \"first\") {\n        for (int i = 0; i < m; ++i) {\n            li[i] = 1;\n        }\n    } else if (li_type == \"last\") {\n        for (int i = 0; i < m; ++i) {\n            li[i] = n;\n        }\n    } else { // default is \"random\"\n        for (int i = 0; i < m; ++i) {\n            li[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n -1) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\\n\", li[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -ai_type all_same -li_type from_start\n./gen -n 2 -m 2 -ai_type all_same -li_type from_end\n./gen -n 3 -m 3 -ai_type big_numbers -li_type middle\n\n# Small test cases\n./gen -n 10 -m 10 -ai_type random -li_type random\n./gen -n 10 -m 10 -ai_type all_distinct -li_type random\n./gen -n 10 -m 10 -ai_type small_range -li_type random\n\n# Test cases with maximum n and m\n./gen -n 100000 -m 100000 -ai_type random -li_type random\n./gen -n 100000 -m 100000 -ai_type all_same -li_type from_start\n./gen -n 100000 -m 100000 -ai_type all_same -li_type from_end\n./gen -n 100000 -m 100000 -ai_type all_same -li_type random\n./gen -n 100000 -m 100000 -ai_type big_numbers -li_type random\n./gen -n 100000 -m 100000 -ai_type small_range -li_type random\n\n# Edge cases\n./gen -n 99999 -m 99999 -ai_type all_distinct -li_type random\n./gen -n 100000 -m 100000 -ai_type all_distinct -li_type from_start\n./gen -n 100000 -m 100000 -ai_type permutation -li_type random\n\n# Alternating numbers\n./gen -n 100000 -m 100000 -ai_type alternating -li_type random\n\n# Middle li\n./gen -n 100000 -m 100000 -ai_type random -li_type middle\n\n# Li from start\n./gen -n 100000 -m 100000 -ai_type random -li_type from_start\n\n# Li from end\n./gen -n 100000 -m 100000 -ai_type random -li_type from_end\n\n# Small m\n./gen -n 100000 -m 1 -ai_type random -li_type random\n./gen -n 100000 -m 1 -ai_type random -li_type from_start\n\n# Large n small m\n./gen -n 100000 -m 1 -ai_type big_numbers -li_type random\n\n# All same ai big m\n./gen -n 100000 -m 100000 -ai_type all_same -li_type first\n\n# n and m small\n./gen -n 100 -m 100 -ai_type small_range -li_type random\n\n# All ai are maximum number\n./gen -n 100000 -m 100000 -ai_type big_numbers -li_type from_end\n\n# Li is always 1 (testing covering entire array)\n./gen -n 100000 -m 100000 -ai_type random -li_type first\n\n# Li is always n (testing last element)\n./gen -n 100000 -m 100000 -ai_type random -li_type last\n\n# Minimum n and m\n./gen -n 1 -m 1 -ai_type random -li_type random\n\n# All ai same, li is always 1\n./gen -n 100000 -m 100000 -ai_type all_same -li_type first\n\n# All ai distinct, li is always n\n./gen -n 100000 -m 100000 -ai_type all_distinct -li_type last\n\n# Alternating ai, li in random positions\n./gen -n 100000 -m 100000 -ai_type alternating -li_type random\n\n# ai in small range, li is random\n./gen -n 100000 -m 100000 -ai_type small_range -li_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:35.827282",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "368/C",
      "title": "C. Sereja and Algorithm",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains non-empty string s, its length (n) doesn't exceed 105. It is guaranteed that string s only contains characters: 'x', 'y', 'z'.The second line contains integer m (1 ≤ m ≤ 105) — the number of tests. Next m lines contain the tests. The i-th line contains a pair of integers li, ri (1 ≤ li ≤ ri ≤ n).",
      "output_spec": "OutputFor each test, print \"YES\" (without the quotes) if the algorithm works correctly on the corresponding test and \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopyzyxxxxxxyyz55 51 31 111 43 6OutputCopyYESYESNOYESNO",
      "description": "C. Sereja and Algorithm\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains non-empty string s, its length (n) doesn't exceed 105. It is guaranteed that string s only contains characters: 'x', 'y', 'z'.The second line contains integer m (1 ≤ m ≤ 105) — the number of tests. Next m lines contain the tests. The i-th line contains a pair of integers li, ri (1 ≤ li ≤ ri ≤ n).\n\nOutputFor each test, print \"YES\" (without the quotes) if the algorithm works correctly on the corresponding test and \"NO\" (without the quotes) otherwise.\n\nInputCopyzyxxxxxxyyz55 51 31 111 43 6OutputCopyYESYESNOYESNO\n\nInputCopyzyxxxxxxyyz55 51 31 111 43 6\n\nOutputCopyYESYESNOYESNO\n\nNoteIn the first example, in test one and two the algorithm will always be terminated in one step. In the fourth test you can get string \"xzyx\" on which the algorithm will terminate. In all other tests the algorithm doesn't work correctly.",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 368"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the string s\n    string s = inf.readToken();\n    ensuref(1 <= s.length() && s.length() <= 100000, \"The length of s must be between 1 and 1e5, but length=%u\", s.length());\n    ensuref(regex_match(s, regex(\"[xyz]+\")), \"String s must contain only characters 'x', 'y', 'z'.\");\n    inf.readEoln();\n\n    int n = s.length();\n\n    // Read integer m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read m lines containing li and ri\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the string s\n    string s = inf.readToken();\n    ensuref(1 <= s.length() && s.length() <= 100000, \"The length of s must be between 1 and 1e5, but length=%u\", s.length());\n    ensuref(regex_match(s, regex(\"[xyz]+\")), \"String s must contain only characters 'x', 'y', 'z'.\");\n    inf.readEoln();\n\n    int n = s.length();\n\n    // Read integer m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read m lines containing li and ri\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the string s\n    string s = inf.readToken();\n    ensuref(1 <= s.length() && s.length() <= 100000, \"The length of s must be between 1 and 1e5, but length=%u\", s.length());\n    ensuref(regex_match(s, regex(\"[xyz]+\")), \"String s must contain only characters 'x', 'y', 'z'.\");\n    inf.readEoln();\n\n    int n = s.length();\n\n    // Read integer m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read m lines containing li and ri\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    // Generate string s based on the specified type\n    if (type == \"random\") {\n        // Random string consisting of 'x', 'y', 'z'\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int rnd_char = rnd.next(3); // Generates 0, 1 or 2\n            s += \"xyz\"[rnd_char];\n        }\n    } else if (type == \"all_same\") {\n        // String consisting of the same character 'x'\n        s = string(n, 'x');\n    } else if (type == \"forbidden_substrings\") {\n        // String made up entirely of forbidden substrings \"zyx\", \"xzy\", \"yxz\"\n        vector<string> forbidden = {\"zyx\", \"xzy\", \"yxz\"};\n        s = \"\";\n        while ((int)s.size() < n) {\n            int idx = rnd.next(3);\n            string sub = forbidden[idx];\n            if ((int)s.size() + 3 <= n)\n                s += sub;\n            else\n                s += sub.substr(0, n - s.size());\n        }\n    } else if (type == \"alternating\") {\n        // String with an alternating pattern \"xyzxyz...\"\n        string pattern = \"xyz\";\n        s = \"\";\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            s += pattern[idx % 3];\n            ++idx;\n        }\n    } else if (type == \"never_terminate\") {\n        // String designed so the algorithm will never terminate (e.g., all 'x's)\n        s = string(n, 'x');\n    } else if (type == \"always_terminate\") {\n        // String designed so the algorithm will always terminate immediately\n        vector<string> forbidden = {\"zyx\", \"xzy\", \"yxz\"};\n        s = \"\";\n        while ((int)s.size() < n) {\n            int idx = rnd.next(3);\n            string sub = forbidden[idx];\n            if ((int)s.size() + 3 <= n)\n                s += sub;\n            else\n                s += sub.substr(0, n - s.size());\n        }\n    } else {\n        // Default to a random string if type is unknown\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int rnd_char = rnd.next(3);\n            s += \"xyz\"[rnd_char];\n        }\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    // Generate m queries\n    printf(\"%d\\n\", m);\n    vector<pair<int, int>> queries;\n\n    if (type == \"max_tests\") {\n        // Generate queries covering the full range of the string\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            queries.push_back({l, r});\n        }\n    } else if (type == \"min_tests\") {\n        // Generate minimal queries of length 1\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            queries.push_back({l, r});\n        }\n    } else if (type == \"never_terminate\") {\n        // Queries that cover the entire string\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            queries.push_back({l, r});\n        }\n    } else if (type == \"always_terminate\") {\n        // Random queries for strings that always terminate\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    } else {\n        // Default: generate random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    }\n\n    // Output the queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    // Generate string s based on the specified type\n    if (type == \"random\") {\n        // Random string consisting of 'x', 'y', 'z'\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int rnd_char = rnd.next(3); // Generates 0, 1 or 2\n            s += \"xyz\"[rnd_char];\n        }\n    } else if (type == \"all_same\") {\n        // String consisting of the same character 'x'\n        s = string(n, 'x');\n    } else if (type == \"forbidden_substrings\") {\n        // String made up entirely of forbidden substrings \"zyx\", \"xzy\", \"yxz\"\n        vector<string> forbidden = {\"zyx\", \"xzy\", \"yxz\"};\n        s = \"\";\n        while ((int)s.size() < n) {\n            int idx = rnd.next(3);\n            string sub = forbidden[idx];\n            if ((int)s.size() + 3 <= n)\n                s += sub;\n            else\n                s += sub.substr(0, n - s.size());\n        }\n    } else if (type == \"alternating\") {\n        // String with an alternating pattern \"xyzxyz...\"\n        string pattern = \"xyz\";\n        s = \"\";\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            s += pattern[idx % 3];\n            ++idx;\n        }\n    } else if (type == \"never_terminate\") {\n        // String designed so the algorithm will never terminate (e.g., all 'x's)\n        s = string(n, 'x');\n    } else if (type == \"always_terminate\") {\n        // String designed so the algorithm will always terminate immediately\n        vector<string> forbidden = {\"zyx\", \"xzy\", \"yxz\"};\n        s = \"\";\n        while ((int)s.size() < n) {\n            int idx = rnd.next(3);\n            string sub = forbidden[idx];\n            if ((int)s.size() + 3 <= n)\n                s += sub;\n            else\n                s += sub.substr(0, n - s.size());\n        }\n    } else {\n        // Default to a random string if type is unknown\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int rnd_char = rnd.next(3);\n            s += \"xyz\"[rnd_char];\n        }\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    // Generate m queries\n    printf(\"%d\\n\", m);\n    vector<pair<int, int>> queries;\n\n    if (type == \"max_tests\") {\n        // Generate queries covering the full range of the string\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            queries.push_back({l, r});\n        }\n    } else if (type == \"min_tests\") {\n        // Generate minimal queries of length 1\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            queries.push_back({l, r});\n        }\n    } else if (type == \"never_terminate\") {\n        // Queries that cover the entire string\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            queries.push_back({l, r});\n        }\n    } else if (type == \"always_terminate\") {\n        // Random queries for strings that always terminate\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    } else {\n        // Default: generate random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    }\n\n    // Output the queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 2 -type random\n./gen -n 5 -m 2 -type all_same\n./gen -n 5 -m 2 -type forbidden_substrings\n./gen -n 5 -m 2 -type alternating\n./gen -n 5 -m 2 -type never_terminate\n./gen -n 5 -m 2 -type always_terminate\n\n./gen -n 100 -m 10 -type random\n./gen -n 100 -m 10 -type all_same\n./gen -n 100 -m 10 -type forbidden_substrings\n./gen -n 100 -m 10 -type alternating\n./gen -n 100 -m 10 -type never_terminate\n./gen -n 100 -m 10 -type always_terminate\n\n./gen -n 1000 -m 100 -type random\n./gen -n 1000 -m 100 -type all_same\n./gen -n 1000 -m 100 -type forbidden_substrings\n./gen -n 1000 -m 100 -type alternating\n./gen -n 1000 -m 100 -type never_terminate\n./gen -n 1000 -m 100 -type always_terminate\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type all_same\n./gen -n 100000 -m 100000 -type forbidden_substrings\n./gen -n 100000 -m 100000 -type alternating\n./gen -n 100000 -m 100000 -type never_terminate\n./gen -n 100000 -m 100000 -type always_terminate\n\n./gen -n 100000 -m 100000 -type max_tests\n./gen -n 100000 -m 1 -type max_tests\n./gen -n 100000 -m 1 -type min_tests\n./gen -n 1000 -m 500 -type max_tests\n./gen -n 1000 -m 500 -type min_tests\n./gen -n 50 -m 10 -type min_tests\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:38.504380",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "368/D",
      "title": "D. Sereja ans Anagrams",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and p (1 ≤ n, m ≤ 2·105, 1 ≤ p ≤ 2·105). The next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The next line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 109).",
      "output_spec": "OutputIn the first line print the number of valid qs. In the second line, print the valid values in the increasing order.",
      "sample_tests": "ExamplesInputCopy5 3 11 2 3 2 11 2 3OutputCopy21 3InputCopy6 3 21 3 2 2 3 11 2 3OutputCopy21 2",
      "description": "D. Sereja ans Anagrams\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and p (1 ≤ n, m ≤ 2·105, 1 ≤ p ≤ 2·105). The next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The next line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 109).\n\nOutputIn the first line print the number of valid qs. In the second line, print the valid values in the increasing order.\n\nInputCopy5 3 11 2 3 2 11 2 3OutputCopy21 3InputCopy6 3 21 3 2 2 3 11 2 3OutputCopy21 2\n\nInputCopy5 3 11 2 3 2 11 2 3\n\nOutputCopy21 3\n\nInputCopy6 3 21 3 2 2 3 11 2 3\n\nOutputCopy21 2",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 368"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 200000, \"p\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 200000, \"p\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 200000, \"p\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, p if specific types require\n    if (type == \"minimal\") {\n        n = m = p = 1;\n    } else if (type == \"max_p\") {\n        p = n;\n        m = 1;\n    } else if (type == \"p_is_one\") {\n        p = 1;\n    } else if (type == \"max_size\") {\n        n = 200000;\n        m = 200000;\n        p = rnd.next(1, 200000);\n    }\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        // Generate random a and b\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    } else if (type == \"duplicates_in_b\") {\n        // Generate random a and b with duplicates in b\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        int dup_val = rnd.next(1, 1000);\n        for (int i = 0; i < m; ++i)\n            b[i] = dup_val;\n    } else if (type == \"duplicates_in_a\") {\n        // Generate a with many duplicates\n        int dup_val = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = dup_val;\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    } else if (type == \"all_same\") {\n        // All elements are the same in a and b\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        for (int i = 0; i < m; ++i)\n            b[i] = val;\n    } else if (type == \"zero_valid_qs\") {\n        // Generate a and b such that there are zero valid q's\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 500000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(500000001, 1000000000);\n    } else if (type == \"p_is_one\") {\n        p = 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    } else if (type == \"one_valid_q\") {\n        if (p * (m - 1) >= n) {\n            p = max(1, n / m);\n        }\n        int q = rnd.next(1, n - (m - 1) * p);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i) {\n            int idx = q - 1 + i * p;\n            a[idx] = rnd.next(1, 1000000000);\n            b[i] = a[idx];\n        }\n    } else if (type == \"minimal\") {\n        // n = m = p = 1\n        a[0] = rnd.next(1, 1000000000);\n        b[0] = a[0];\n    } else if (type == \"max_p\") {\n        p = n;\n        m = 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        b[0] = a[0];\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, p);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", b[i], i + 1 == m ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, p if specific types require\n    if (type == \"minimal\") {\n        n = m = p = 1;\n    } else if (type == \"max_p\") {\n        p = n;\n        m = 1;\n    } else if (type == \"p_is_one\") {\n        p = 1;\n    } else if (type == \"max_size\") {\n        n = 200000;\n        m = 200000;\n        p = rnd.next(1, 200000);\n    }\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        // Generate random a and b\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    } else if (type == \"duplicates_in_b\") {\n        // Generate random a and b with duplicates in b\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        int dup_val = rnd.next(1, 1000);\n        for (int i = 0; i < m; ++i)\n            b[i] = dup_val;\n    } else if (type == \"duplicates_in_a\") {\n        // Generate a with many duplicates\n        int dup_val = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = dup_val;\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    } else if (type == \"all_same\") {\n        // All elements are the same in a and b\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        for (int i = 0; i < m; ++i)\n            b[i] = val;\n    } else if (type == \"zero_valid_qs\") {\n        // Generate a and b such that there are zero valid q's\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 500000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(500000001, 1000000000);\n    } else if (type == \"p_is_one\") {\n        p = 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    } else if (type == \"one_valid_q\") {\n        if (p * (m - 1) >= n) {\n            p = max(1, n / m);\n        }\n        int q = rnd.next(1, n - (m - 1) * p);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i) {\n            int idx = q - 1 + i * p;\n            a[idx] = rnd.next(1, 1000000000);\n            b[i] = a[idx];\n        }\n    } else if (type == \"minimal\") {\n        // n = m = p = 1\n        a[0] = rnd.next(1, 1000000000);\n        b[0] = a[0];\n    } else if (type == \"max_p\") {\n        p = n;\n        m = 1;\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        b[0] = a[0];\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, p);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", b[i], i + 1 == m ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -p 1 -type random\n./gen -n 10 -m 5 -p 2 -type random\n./gen -n 100000 -m 50000 -p 1 -type random\n./gen -n 200000 -m 100000 -p 100000 -type random\n./gen -n 100 -m 50 -p 1 -type duplicates_in_b\n./gen -n 100 -m 20 -p 5 -type duplicates_in_a\n./gen -n 1000 -m 1000 -p 1 -type all_same\n./gen -n 1000 -m 1000 -p 1 -type zero_valid_qs\n./gen -n 15 -m 5 -p 1 -type p_is_one\n./gen -n 1 -m 1 -p 1 -type minimal\n./gen -n 200000 -m 1 -p 200000 -type max_p\n./gen -n 200000 -m 200000 -p 1 -type max_size\n./gen -n 100000 -m 1000 -p 3 -type one_valid_q\n./gen -n 100000 -m 99999 -p 1 -type one_valid_q\n./gen -n 2 -m 1 -p 1 -type random\n./gen -n 2 -m 1 -p 2 -type random\n./gen -n 100 -m 1 -p 1 -type zero_valid_qs\n./gen -n 200000 -m 200000 -p 1 -type all_same\n./gen -n 100000 -m 1 -p 1 -type all_same\n./gen -n 10000 -m 5000 -p 3 -type duplicates_in_b\n./gen -n 50000 -m 30000 -p 2 -type duplicates_in_a\n./gen -n 10000 -m 10000 -p 100 -type one_valid_q\n./gen -n 200000 -m 200000 -p 200000 -type random\n./gen -n 200000 -m 100 -p 1 -type zero_valid_qs\n./gen -n 100000 -m 99999 -p 1 -type max_size\n./gen -n 1000 -m 1000 -p 1 -type all_same\n./gen -n 100000 -m 100000 -p 1 -type random\n./gen -n 99999 -m 99999 -p 1 -type one_valid_q\n./gen -n 200000 -m 2 -p 100000 -type max_p\n./gen -n 5000 -m 5000 -p 500 -type zero_valid_qs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:41.284259",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "368/E",
      "title": "E. Sereja and the Arrangement of Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 2·106, 1 ≤ m ≤ 105). Next m lines contain pairs of integers. The i-th line contains numbers qi, wi (1 ≤ qi, wi ≤ 105).It is guaranteed that all qi are distinct.",
      "output_spec": "OutputIn a single line print maximum amount of money (in rubles) Sereja can pay.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy5 21 22 3OutputCopy5InputCopy100 31 22 13 1OutputCopy4InputCopy1 21 12 100OutputCopy100",
      "description": "E. Sereja and the Arrangement of Numbers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 2·106, 1 ≤ m ≤ 105). Next m lines contain pairs of integers. The i-th line contains numbers qi, wi (1 ≤ qi, wi ≤ 105).It is guaranteed that all qi are distinct.\n\nOutputIn a single line print maximum amount of money (in rubles) Sereja can pay.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy5 21 22 3OutputCopy5InputCopy100 31 22 13 1OutputCopy4InputCopy1 21 12 100OutputCopy100\n\nInputCopy5 21 22 3\n\nOutputCopy5\n\nInputCopy100 31 22 13 1\n\nOutputCopy4\n\nInputCopy1 21 12 100\n\nOutputCopy100\n\nNoteIn the first sample Sereja can pay 5 rubles, for example, if Dima constructs the following array: [1, 2, 1, 2, 2]. There are another optimal arrays for this test.In the third sample Sereja can pay 100 rubles, if Dima constructs the following array: [2].",
      "solutions": [
        {
          "title": "Codeforces Round #215 - Codeforces",
          "content": "Hello everyone!Codeforces Round #215 will take place on Tuesday, November 26th at 19:30 MSK. This is my ninth Codeforces round and I hope not the last.I'd like to thank Gerald, Berezin, Aksenov239, MikeMirzayanov and Cenadar for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values div1: 500-1000-1500-2000-2000Problem point values div2: 500-1000-1500-2000-2500 Gl & hf ! :)Contest is over, thank you for participation. Sorry for mistake in problem A. Hope, that problems were interesting for you, also I hope that bugs didn't spoil your mood.Have a nice evening! :)Also I'd like to congratulate rng_58, he have 3010 rating now!Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 769
        },
        {
          "title": "Codeforces Round #215 — tutorial - Codeforces",
          "content": "Разбор задач Codeforces Round #215368A - Sereja and Coat RackEach time we will go through the array and look for the minimal element which is not yet marked. If we find an item, we add it to the answer and mark it, otherwise we will subtract the penlty from answer.368B - Sereja and SuffixesWe will count value ansi — number of different elements on the suffix from i. For calculation will walk from the end of the array, and we count ansi = ansi + 1 + newai, newai equals to 1, if element ai has not yet met and 0 otherwise.367A - Sereja and Algorithm If you look at what is written in the statment, it becomes clear that the algorithm finishes its work, if we can get a string like: xx, yy, zz, zyxzyxzyx... and all its cyclic shuffles. To check you just need to know the number of letters x, y and z separately. Quantities can be counted using partial sums. 367B - Sereja ans AnagramsWe will divide the sequence on min(n, p) sequences. 1-st, (1 + p)-th, (1 + 2·p)-th, ... element will go to the first sequence, 2-nd, (2 + p)-th, (2 + 2·p)-th... will go to the second sequence and so on. Now you need to find an answer for each of them, considering that p = 1. This can be solved by a simple method. You can go along the sequence from left to right and count the number of occurrences of each number. If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence, then everything is OK.367C - Sereja and the Arrangement of NumbersClear that we need to collect as many of the most expensive properties that would have been possible to build the array. Note that having n numbers, we have m = n·(n - 1) / 2 binding ties. See that this is a graph in which to do Euler path, adding as little as possible edges. For n%2 = 1 — everything is clear, and for n%2 = 0, you need to add an additional n / 2 - 1 rib. Why? This is your homework :)The detailed explanation can be found here. 367D - Sereja and SetsReplace out sets by array, where the element — the number set to which its index belongs. Now take all the consequitive sub-arrays with lengths of d and find a set of elements that were not found in that sub array. Clearly, if we as a response to select a subset of such set, it does not fit us. Remember all those \"bad set.\" As we know all of them, we can find all the \"bad\" subsets. Now we choose the set with maximum count of elements which is not a bad set. It is better to work here with bit masks. 367E - Sereja and IntervalsWe assume that the intervals are sorted, and in the end we will multiply the answer by n!, We can do so, as all segments are different.Consider two cases n > m and n ≤ m. It would seem that you need to write different dynamics for them, but not difficult to show that in the first case the answer is always 0 . The second case is the following dynamics : dpi, l, r, i — how many numbers we have considered , l, r — only in this interval will be present number i. Also, we will need an additional dynamic si, l, i — how many numbers are considered , l — how many segments are already closed , and i does not belong to any segment . There will be 4 transfers, since every number we can not begin and end with more than one segment.Now we should add x to our solution, it is quite simple: just add another parameter 0 / 1 in our dynamics, if we had such a element in the beginning of some interval or not. With out dynamics, it is not difficult. For more details check out any solution that passed system tests.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 368"
          },
          "content_length": 3501
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #215 - Codeforces - Code 1",
          "code": "#define OVER9000 1234567890",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 2",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 3",
          "code": "(WA) if ( good == mp.size() ) // Here mp is a map < long long, int > mp\n(AC) if ( good == dif ) // Here dif = mp.size() right after inserting things in map.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 4",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 5",
          "code": "#define FOR(i, a, b) for(int i = a; i <= b; ++i)\n#define FRD(i, a, b) for(int i = a; i >= b; --i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #215 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++i) {\n        // ...\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> qis;  // To ensure all qi are distinct\n\n    for (int i = 0; i < m; ++i) {\n        int qi = inf.readInt(1, 100000, \"qi\");\n        inf.readSpace();\n        int wi = inf.readInt(1, 100000, \"wi\");\n        inf.readEoln();\n\n        ensuref(qis.find(qi) == qis.end(), \"qi[%d]=%d is not unique\", i + 1, qi);\n        qis.insert(qi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> qis;  // To ensure all qi are distinct\n\n    for (int i = 0; i < m; ++i) {\n        int qi = inf.readInt(1, 100000, \"qi\");\n        inf.readSpace();\n        int wi = inf.readInt(1, 100000, \"wi\");\n        inf.readEoln();\n\n        ensuref(qis.find(qi) == qis.end(), \"qi[%d]=%d is not unique\", i + 1, qi);\n        qis.insert(qi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> qis;  // To ensure all qi are distinct\n\n    for (int i = 0; i < m; ++i) {\n        int qi = inf.readInt(1, 100000, \"qi\");\n        inf.readSpace();\n        int wi = inf.readInt(1, 100000, \"wi\");\n        inf.readEoln();\n\n        ensuref(qis.find(qi) == qis.end(), \"qi[%d]=%d is not unique\", i + 1, qi);\n        qis.insert(qi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int q_max = 100000;\nconst int w_max = 100000;\nconst int n_max = 2000000;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    n = max(1, min(n, n_max));\n    m = max(1, min(m, q_max));\n\n    vector<int> q_list;\n    vector<int> w_list;\n\n    if (type == \"random\") {\n        // Generate m distinct q_i in [1, q_max]\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    } else if (type == \"max_wi\") {\n        // Generate m distinct q_i in [1, q_max]\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Set w_i to w_max\n        w_list.assign(m, w_max);\n    } else if (type == \"min_wi\") {\n        // Generate m distinct q_i in [1, q_max]\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Set w_i to 1\n        w_list.assign(m, 1);\n    } else if (type == \"single_coupon\") {\n        m = 1;\n        n = max(n, 1); // Ensure n >= 1\n        int q = rnd.next(1, q_max);\n        int w = rnd.next(1, w_max);\n        q_list.push_back(q);\n        w_list.push_back(w);\n    } else if (type == \"max_coupons\") {\n        m = q_max; // m = 1e5\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        q_list = q_candidates;\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    } else if (type == \"max_n\") {\n        n = n_max; // n = 2e6\n        // Proceed as in \"random\"\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    } else {\n        // Default to random\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output m lines of q_i and w_i\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", q_list[i], w_list[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int q_max = 100000;\nconst int w_max = 100000;\nconst int n_max = 2000000;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    n = max(1, min(n, n_max));\n    m = max(1, min(m, q_max));\n\n    vector<int> q_list;\n    vector<int> w_list;\n\n    if (type == \"random\") {\n        // Generate m distinct q_i in [1, q_max]\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    } else if (type == \"max_wi\") {\n        // Generate m distinct q_i in [1, q_max]\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Set w_i to w_max\n        w_list.assign(m, w_max);\n    } else if (type == \"min_wi\") {\n        // Generate m distinct q_i in [1, q_max]\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Set w_i to 1\n        w_list.assign(m, 1);\n    } else if (type == \"single_coupon\") {\n        m = 1;\n        n = max(n, 1); // Ensure n >= 1\n        int q = rnd.next(1, q_max);\n        int w = rnd.next(1, w_max);\n        q_list.push_back(q);\n        w_list.push_back(w);\n    } else if (type == \"max_coupons\") {\n        m = q_max; // m = 1e5\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        q_list = q_candidates;\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    } else if (type == \"max_n\") {\n        n = n_max; // n = 2e6\n        // Proceed as in \"random\"\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    } else {\n        // Default to random\n        vector<int> q_candidates(q_max);\n        for (int i = 0; i < q_max; ++i) {\n            q_candidates[i] = i + 1;\n        }\n        shuffle(q_candidates.begin(), q_candidates.end());\n        q_list.assign(q_candidates.begin(), q_candidates.begin() + m);\n        // Generate random w_i in [1, w_max]\n        for (int i = 0; i < m; ++i) {\n            w_list.push_back(rnd.next(1, w_max));\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output m lines of q_i and w_i\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", q_list[i], w_list[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type single_coupon\n./gen -n 2 -m 2 -type min_wi\n./gen -n 10 -m 5 -type random\n./gen -n 100 -m 50 -type random\n./gen -n 1000 -m 500 -type random\n./gen -n 10000 -m 5000 -type random\n./gen -n 100000 -m 50000 -type max_wi\n./gen -n 2000000 -m 100000 -type max_wi\n./gen -n 2000000 -m 1 -type single_coupon\n./gen -n 1000 -m 1000 -type min_wi\n./gen -n 2000000 -m 100000 -type max_coupons\n./gen -n 1 -m 100000 -type max_coupons\n./gen -n 2000000 -m 100000 -type random\n./gen -n 1000000 -m 100000 -type random\n./gen -n 2 -m 100000 -type max_coupons\n./gen -n 100 -m 100 -type random\n./gen -n 2000000 -m 100000 -type min_wi\n./gen -n 10000 -m 100000 -type max_coupons\n./gen -n 500000 -m 100000 -type random\n./gen -n 1 -m 100000 -type max_wi\n./gen -n 2000000 -m 1 -type random\n./gen -n 2000000 -m 1 -type single_coupon\n./gen -n 2000000 -m 100000 -type random\n./gen -n 2000000 -m 100000 -type max_wi\n./gen -n 2000000 -m 100000 -type min_wi\n./gen -n 1234567 -m 98765 -type random\n./gen -n 100 -m 1 -type single_coupon\n./gen -n 2000000 -m 100000 -type random\n./gen -n 2000000 -m 99999 -type max_wi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:43.343835",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "369/A",
      "title": "A. Валера и тарелки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных задано три целых числа n, m, k (1 ≤ n, m, k ≤ 1000) — количество распланированных дней, количество чистых глубоких тарелок и количество чистых плоских тарелок.Во второй строке заданы n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 2). Если ai равно единице, то в день i Валера будет есть блюдо первого типа. Если ai равно двум, то в день i Валера будет есть блюдо второго типа.",
      "output_spec": "Выходные данныеВыведите единственное целое число — какое минимальное количество раз Валере потребуется помыть тарелку.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1 11 2 1Выходные данныеСкопировать1Входные данныеСкопировать4 3 11 1 1 1Выходные данныеСкопировать1Входные данныеСкопировать3 1 22 2 2Выходные данныеСкопировать0Входные данныеСкопировать8 2 21 2 1 2 1 2 1 2Выходные данныеСкопировать4",
      "description": "A. Валера и тарелки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных задано три целых числа n, m, k (1 ≤ n, m, k ≤ 1000) — количество распланированных дней, количество чистых глубоких тарелок и количество чистых плоских тарелок.Во второй строке заданы n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 2). Если ai равно единице, то в день i Валера будет есть блюдо первого типа. Если ai равно двум, то в день i Валера будет есть блюдо второго типа.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — какое минимальное количество раз Валере потребуется помыть тарелку.\n\nВыходные данные\n\nВходные данныеСкопировать3 1 11 2 1Выходные данныеСкопировать1Входные данныеСкопировать4 3 11 1 1 1Выходные данныеСкопировать1Входные данныеСкопировать3 1 22 2 2Выходные данныеСкопировать0Входные данныеСкопировать8 2 21 2 1 2 1 2 1 2Выходные данныеСкопировать4\n\nВходные данныеСкопировать3 1 11 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 3 11 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 1 22 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8 2 21 2 1 2 1 2 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Валера будет мыть глубокую тарелку только в третий день, поэтому ответ равен единице.Во втором примере все четыре дня Валера будет есть блюда первого типа, а поскольку глубоких тарелок всего три, то он будет мыть тарелку ровно один раз.В третьем примере все три дня Валера будет есть блюда второго типа, а поскольку их можно есть из тарелок обоих типов, то мыть тарелку не потребуется ни разу.",
      "solutions": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "Всем привет!Скоро, 29 ноября в 19:30 MSK, состоится очередной Codeforces Round #216 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса.Задачи были подготовлены группой авторов в составе: Гриднев Виталий (gridnevvvit), Лось Илья (IlyaLos). Большое спасибо Гере Агапову (Gerald) и Сергею Сухову (Serega) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. UPD1: Распределение баллов будет таким: 500, 1000, 1500, 2000, 2500.UPD2: Это была опечатка с распределением, теперь все верно.UPD Соревнование закончено, поздравляем победителей! Dshovn WhitedarkWalker hexor Pandii Ronnoc_2 Удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9738",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 746
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "369A - Валера и тарелкиБудем действовать жадно. Пусть сейчас i-й день, и текущее блюдо типа 1. Тогда если у нас есть чистая глубокая тарелка, то воспользуемся ею. Иначе увеличим ответ. Если текущее блюдо типа 2, то мы сначала попробуем взять плоскую тарелку, а потом глубокую. Если чистых тарелок нет совсем, то увеличим ответ.Авторское решение: 5306397369B - Валера и олимпиадаВ этой задаче требовалось найти такой массив a1, a2, ..., an, что верны условия: r ≥ a1 ≥ a2 ≥ ... ≥ an ≥ l; ; ; Понятно, что сумму sk нужно распределить равномерно между первыми k элементами. Например, так: remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}Если k ≠ n, то аналогично нужно поступить с остальными элементами, причем распределить им нужно sall - sk.Многие не учитывали случай k = n, в результате получали RE11.Авторское решение: 5306414369C - Валера и выборыРассмотрим все дороги, которые нам нужно отремонтировать. Пометим их концы u, v белым цветом. После этого, посчитаем простую динамику d[v] (v — вершина в дереве) на дереве, которая для каждой вершины в дереве посчитает количество белых вершин в поддереве. Это просто посчитать примерно так c помощью рекурсивной функции calc(v, prev) (v — текущая вершина, а prev — ее непосредственный предок): calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tдля всех u, таких что существует ребро (u,v) или (v,u) u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u]; \n}После этого, добавим к ответу количество белых вершин v, для которых d[v] = 1Авторское решение: 5306500 369D - Валера и дуракиПусть p[A] — вероятность того, что дурак с номером A попадет, если совершит выстрел. Заметим, что состояние очень просто описать парой чисел (A, B), где A — номер самого левого дурака, B — второго слева по порядку дурака. Понятно, что все дураки с индексами  ≥ B останутся живы. Выполним bfs по этим состояниям. Состояние (0, 1) достижимо в любом случае, потому что оно изначально. Поэтому сразу положим его в очередь. Далее, из текущего состояния в очереди мы можем перейти максимум в три состояния: (B + 1, B + 2) — только если p[A] > 0 и существует такой дурак с номером j ≥ B, у которого p[j] > 0. (A, B + 1) — только если p[A] > 0 и не существует такой дурак с номером j ≥ B, у которого p[j] = 100. (B, B + 1) — только если p[A] ≠ 100 и существует такой дурак с номером j ≥ B, у которого p[j] > 0. После этого, достаточно посчитать количество состояний, расстояние до которых от (0, 1) не более чем k. Также нужно аккуратно учесть, что если остался один дурак, то он не совершает выстрелов.Авторское решение: 5306516369E - Валера и запросыДавайте поддержим множество xs[y] — все отрезки, чьи правые границы в точности равны y. Теперь сведем нашу задачу к другой. Для каждого запроса посчитаем количество отрезков, которым не принадлежит ни одна точка. Пускай это значение v. Тогда ответ на запрос это n - v. Добавим к нашему запросу точки 0 и точку MV + 1, где MV = 1000000. Пусть точки запроса имеют вид x1 < x2... < xn. Рассмотрим xi и xi + 1. Пусть pi это количество отрезков которые лежат строго внутри xi и xi + 1. Тогда v = p1 + p2 + ... + pn - 1. Чтобы найти значения pi нужно поступить так. Рассмотрим все такие пары (x, xi + 1) по всем запросам и сложим их во второе множество xQ[r] — все пары, у которых правая граница равна r. Тогда чтобы узнать значения p для пар (xi, xi + 1) будем перебирать по возрастанию правую границу. Дополнительно будем поддерживать дерево Фенвика, которое умеет делать  +  = 1 в точке, и брать сумму на префиксе. Пусть i — текущая правая граница. Тогда мы можем узнать значение p для всеx пар (l, r), у которых правая граница равна i (l, i). Пусть j левая граница пары. Тогда ответом для пары будет значение S - sum(j), где S — количество добавленных в дерево Фенвика левых границ, а sum(j) — сумма на префиксе j. После этого, для текущей координаты нужно рассмотреть все отрезки, в множестве xs[i]. Пусть j левая граница отрезка. Тогда нам нужно сделать  +  = 1 в точке j в нашем дереве Фенвика. Итого, общая сложность решения .Авторское решение: 5306535",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9760",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 369\\s*A"
          },
          "content_length": 4091
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tдля всех u, таких что существует ребро (u,v) или (v,u) u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tдля всех u, таких что существует ребро (u,v) или (v,u) u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "Если хотя бы одно условие не выполнилось, то ответ -1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "Если хотя бы одно условие не выполнилось, то ответ -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "Гарантируется, что входные данные таковы, что ответ существует.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "ans = n - left - right - (first + second - both)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 9",
          "code": "first + second - both",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 10",
          "code": "r[x] - (n - l[x])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 11",
          "code": "r[b] - (n - l[a])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 12",
          "code": "random_shuffle(ans.begin(), ans.end());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 13",
          "code": "warning: ISO C++ forbids variable length array ‘p’",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 14",
          "code": "stack overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 15",
          "code": "Memory limit exceeded on test 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 16",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #216 (Div. 2) - Codeforces - Code 17",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string dishType = opt<string>(\"dishType\", \"random\");\n\n    vector<int> dishes(n);\n\n    if (dishType == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            dishes[i] = rnd.next(1, 2);\n        }\n    } else if (dishType == \"all1\") {\n        fill(dishes.begin(), dishes.end(), 1);\n    } else if (dishType == \"all2\") {\n        fill(dishes.begin(), dishes.end(), 2);\n    } else if (dishType == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            dishes[i] = (i % 2) + 1;\n        }\n    } else if (dishType == \"few1\") {\n        int numType1 = opt<int>(\"numType1\", n / 10);\n        set<int> pos;\n        while ((int)pos.size() < numType1) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        fill(dishes.begin(), dishes.end(), 2);\n        for (int idx : pos) {\n            dishes[idx] = 1;\n        }\n    } else if (dishType == \"few2\") {\n        int numType2 = opt<int>(\"numType2\", n / 10);\n        set<int> pos;\n        while ((int)pos.size() < numType2) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        fill(dishes.begin(), dishes.end(), 1);\n        for (int idx : pos) {\n            dishes[idx] = 2;\n        }\n    } else {\n        // Default to random if unrecognized dishType\n        for (int i = 0; i < n; ++i) {\n            dishes[i] = rnd.next(1, 2);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the dishes\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", dishes[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string dishType = opt<string>(\"dishType\", \"random\");\n\n    vector<int> dishes(n);\n\n    if (dishType == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            dishes[i] = rnd.next(1, 2);\n        }\n    } else if (dishType == \"all1\") {\n        fill(dishes.begin(), dishes.end(), 1);\n    } else if (dishType == \"all2\") {\n        fill(dishes.begin(), dishes.end(), 2);\n    } else if (dishType == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            dishes[i] = (i % 2) + 1;\n        }\n    } else if (dishType == \"few1\") {\n        int numType1 = opt<int>(\"numType1\", n / 10);\n        set<int> pos;\n        while ((int)pos.size() < numType1) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        fill(dishes.begin(), dishes.end(), 2);\n        for (int idx : pos) {\n            dishes[idx] = 1;\n        }\n    } else if (dishType == \"few2\") {\n        int numType2 = opt<int>(\"numType2\", n / 10);\n        set<int> pos;\n        while ((int)pos.size() < numType2) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        fill(dishes.begin(), dishes.end(), 1);\n        for (int idx : pos) {\n            dishes[idx] = 2;\n        }\n    } else {\n        // Default to random if unrecognized dishType\n        for (int i = 0; i < n; ++i) {\n            dishes[i] = rnd.next(1, 2);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the dishes\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", dishes[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -k 2 -dishType random\n./gen -n 1000 -m 500 -k 500 -dishType random\n./gen -n 1000 -m 0 -k 1000 -dishType all1\n./gen -n 1000 -m 0 -k 1000 -dishType all2\n./gen -n 1000 -m 1000 -k 0 -dishType all2\n./gen -n 1000 -m 1000 -k 0 -dishType all1\n./gen -n 1000 -m 0 -k 0 -dishType all2\n./gen -n 1000 -m 0 -k 0 -dishType all1\n./gen -n 10 -m 5 -k 5 -dishType alternate\n./gen -n 1000 -m 1 -k 1 -dishType random\n./gen -n 500 -m 500 -k 10 -dishType all1\n./gen -n 1000 -m 1000 -k 10 -dishType all2\n./gen -n 1000 -m 500 -k 500 -dishType all2\n./gen -n 1000 -m 500 -k 0 -dishType all1\n./gen -n 1000 -m 200 -k 200 -dishType all2\n./gen -n 1000 -m 700 -k 300 -dishType random\n./gen -n 1000 -m 300 -k 300 -dishType alternate\n./gen -n 1000 -m 10 -k 990 -dishType few1 -numType1 10\n./gen -n 1000 -m 990 -k 10 -dishType few2 -numType2 10\n./gen -n 1000 -m 1000 -k 1000 -dishType random\n./gen -n 1 -m 1 -k 1 -dishType all1\n./gen -n 1 -m 1 -k 1 -dishType all2\n./gen -n 1 -m 0 -k 0 -dishType all1\n./gen -n 1 -m 0 -k 0 -dishType all2\n./gen -n 1000 -m 1 -k 999 -dishType random\n./gen -n 1000 -m 999 -k 1 -dishType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:45.573131",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "369/B",
      "title": "B. Valera and Contest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains exactly six integers n, k, l, r, sall, sk (1 ≤ n, k, l, r ≤ 1000; l ≤ r; k ≤ n; 1 ≤ sk ≤ sall ≤ 106).It's guaranteed that the input is such that the answer exists.",
      "output_spec": "OutputPrint exactly n integers a1, a2, ..., an — the number of points each student scored. If there are multiple solutions, you can print any of them. You can print the distribution of points in any order.",
      "sample_tests": "ExamplesInputCopy5 3 1 3 13 9OutputCopy2 3 2 3 3 InputCopy5 3 1 3 15 9OutputCopy3 3 3 3 3",
      "description": "B. Valera and Contest\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains exactly six integers n, k, l, r, sall, sk (1 ≤ n, k, l, r ≤ 1000; l ≤ r; k ≤ n; 1 ≤ sk ≤ sall ≤ 106).It's guaranteed that the input is such that the answer exists.\n\nOutputPrint exactly n integers a1, a2, ..., an — the number of points each student scored. If there are multiple solutions, you can print any of them. You can print the distribution of points in any order.\n\nInputCopy5 3 1 3 13 9OutputCopy2 3 2 3 3 InputCopy5 3 1 3 15 9OutputCopy3 3 3 3 3\n\nInputCopy5 3 1 3 13 9\n\nOutputCopy2 3 2 3 3\n\nInputCopy5 3 1 3 15 9\n\nOutputCopy3 3 3 3 3",
      "solutions": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on November 29th at 19:30 MSK, you are lucky to participate in Codeforces Round #216 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit) and Los Ilya (IlyaLos).We want to thank Gerald Agapov (Gerald) and Sergey Sukhov (Serega) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2000, 2500.UPD2: It was a misprint with scoring system, now it is correct.UPD Contest finished, congratulations to winners! Dshovn WhitedarkWalker hexor Pandii Ronnoc_2 Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9738",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 756
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "369A - Valera and PlatesWe will use greedy algorithm. Let's now i-th day, and current dish is a dish of first type. Then if we have the bowl, let's use it. Otherwise we will increase the answer. If the current dish is a dish of the second type, we first try to get the plate, and then the bowl. If there are no plates/bowls at all, then we will increase the answer.Author's solution: 5306397369B - Valera and ContestIn this task you are to determine such array a1, a2, ..., an, that following conditions are met: r ≥ a1 ≥ a2 ≥ ... ≥ an ≥ l; ; ; It's clear to understand, that value sk should be distributed evenly between the first k elements. For example, you can use following algorithm: remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}If k ≠ n, you should use same algorithm with other elements, but there are to distribute value sall - sk.Some participants forgot about test, where k = n. They received RE11.Author's solution: 5306414369C - Valera and ElectionsConsider all the roads that we need to repair. Mark the ends of u, v white. After that, we will consider a simple dynamic programming d[v] (v is the vertex) on the tree that for each vertex in the tree determines the number of white vertexes in the subtree. It is easy to calculate this by using a recursive function calc(v, prev) (v is the current node, and prev its immediate ancestor): calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u]; \n}After that we will add to answer all white vertexes v such that next condition is correct: d[v] = 1Author's solution: 5306500369D - Valera and FoolsLet's p[A] is the pA from the statement. It's clear to understand that you can discribe the state by using pair of integers (A, B), where A is a number of the fool with smallest index, B — the second fool from the left. It is clear to understand that fool with indexes j ≥ B will be living. After that we will use bfs on the states (A, B). State (0, 1) is always visitable, because it is initial. We will push it in the queue. After that, there are only three transitions from current state (A, B). (B + 1, B + 2) — this transition is possible if and only if p[A] > 0 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. (A, B + 1) — this transition is possible if and only if p[A] > 0 и there are no fool with index j ≥ B, which has p[j] = 100. (B, B + 1) — this transition is possible if and only if p[A] ≠ 100 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. After that you are to determine number of states, which has distance from state (0, 1) less or equal to k. Also you should be careful, that if there are only one fool, that he doesn't shot.Author's solution: 5306516369E - Valera and QueriesLet's calculate sets xs[y] — all segments, whose right borders are exactly equal to y. Now we reduce our task to another. For each query we will count the number of segments that doesn't belong to any one point. Let's it will be the value v. Then the answer to the query is n - v. We add to our request the point 0 and a point MV + 1, where MV = 1000000. Let points request have the form x1 < x2... < xn. Consider the xi and xi + 1. Let pi is the number of segments that lie strictly inside xi and xi + 1. Then v = p1 + p2 + ... + pn - 1. We will use following algorithm to find the values pi. Let consider all such pairs (x, xi + 1) for all requests and to add them to a second set xQ[y] — all pairs whose right boundary is equal to r. Then to find the values p of pairs (xi, xi + 1) we will iterate ascending the right border. Additionally, we will support Fenwick's tree, which can make  +  = 1 at the point, and can calculate sum of the prefix. Let i — the current right border. Then we can find out the value p for all pairs (l, r), with the right border is equal to the i (l, i). Let j left border of the pair. Then the answer for the pair is the value of S - sum(j), where S — all added to the Fenwick's left borders, and sum(j) — sum of the prefix j. After that, for the current coordinate i we need to consider all segments in the set xs[i]. Let j left boundary of the segment. Then we need to make  +  = 1 at the point j in our Fenwick's tree. The total solution complexity is .Authors solution: 5306535",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9760",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 369\\s*B"
          },
          "content_length": 4401
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "random_shuffle(ans.begin(), ans.end());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "warning: ISO C++ forbids variable length array ‘p’",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "stack overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Memory limit exceeded on test 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 9",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 10",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readSpace();\n\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n\n    int sall = inf.readInt(1, 1000000, \"sall\");\n    inf.readSpace();\n\n    int sk = inf.readInt(1, 1000000, \"sk\");\n    inf.readEoln();\n\n    ensuref(l <= r, \"Constraint l <= r is violated: l = %d, r = %d\", l, r);\n    ensuref(k <= n, \"Constraint k <= n is violated: k = %d, n = %d\", k, n);\n    ensuref(sk <= sall, \"Constraint sk <= sall is violated: sk = %d, sall = %d\", sk, sall);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readSpace();\n\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n\n    int sall = inf.readInt(1, 1000000, \"sall\");\n    inf.readSpace();\n\n    int sk = inf.readInt(1, 1000000, \"sk\");\n    inf.readEoln();\n\n    ensuref(l <= r, \"Constraint l <= r is violated: l = %d, r = %d\", l, r);\n    ensuref(k <= n, \"Constraint k <= n is violated: k = %d, n = %d\", k, n);\n    ensuref(sk <= sall, \"Constraint sk <= sall is violated: sk = %d, sall = %d\", sk, sall);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readSpace();\n\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n\n    int sall = inf.readInt(1, 1000000, \"sall\");\n    inf.readSpace();\n\n    int sk = inf.readInt(1, 1000000, \"sk\");\n    inf.readEoln();\n\n    ensuref(l <= r, \"Constraint l <= r is violated: l = %d, r = %d\", l, r);\n    ensuref(k <= n, \"Constraint k <= n is violated: k = %d, n = %d\", k, n);\n    ensuref(sk <= sall, \"Constraint sk <= sall is violated: sk = %d, sall = %d\", sk, sall);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic void readAndCheckSolution(InStream &stream,\n    int n, int k, long long l, long long r, long long sall, long long sk)\n{\n    // Read n scores.\n    vector<long long> scores(n);\n    long long sumAll = 0;\n    for (int i = 0; i < n; i++) {\n        // Each score must be in [l, r].\n        scores[i] = stream.readLong(l, r, format(\"score[%d]\", i + 1).c_str());\n        sumAll += scores[i];\n    }\n\n    // Check if the total sum is sall.\n    if (sumAll != sall) {\n        stream.quitf(_wa,\n            \"the sum of all scores is expected to be %lld, but found %lld\",\n            sall, sumAll);\n    }\n\n    // Sort in non-increasing order to check the top k sum.\n    sort(scores.begin(), scores.end(), greater<long long>());\n    long long sumTopK = 0;\n    for (int i = 0; i < k; i++) {\n        sumTopK += scores[i];\n    }\n\n    // Check if the sum of the top k scores is sk.\n    if (sumTopK != sk) {\n        stream.quitf(_wa,\n            \"the sum of the top %d scores is expected to be %lld, but found %lld\",\n            k, sk, sumTopK);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input from the test file (not for format checking, just to get n, k, l, r, sall, sk).\n    int n = inf.readInt();\n    int k = inf.readInt();\n    long long l = inf.readLong();\n    long long r = inf.readLong();\n    long long sall = inf.readLong();\n    long long sk = inf.readLong();\n\n    // Read and check the jury's answer (ans). If it fails, verdict becomes _fail.\n    readAndCheckSolution(ans, n, k, l, r, sall, sk);\n\n    // Read and check the participant's answer (ouf). If it fails, verdict becomes _wa.\n    readAndCheckSolution(ouf, n, k, l, r, sall, sk);\n\n    // If both are valid, accept.\n    quitf(_ok, \"solution is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(l <= r);\n    ensure(1 <= n && n <= 1000);\n    ensure(1 <= k && k <= n);\n    ensure(1 <= l && l <= 1000);\n    ensure(1 <= r && r <= 1000);\n\n    int sk_min = k * l;\n    int sk_max = k * r;\n\n    int srest_min = (n - k) * l;\n    int srest_max = (n - k) * r;\n\n    int sall_min = n * l;\n    int sall_max = n * r;\n\n    int sk = 0;\n    int srest = 0;\n    int sall = 0;\n\n    if (type == \"random\") {\n        sk = rnd.next(sk_min, sk_max);\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            sk = sall_min - srest_min;\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    } else if (type == \"all_l\") {\n        sk = sk_min;\n        srest = srest_min;\n        sall = sk + srest;\n    } else if (type == \"all_r\") {\n        sk = sk_max;\n        srest = srest_max;\n        sall = sk + srest;\n    } else if (type == \"top_r\") {\n        sk = sk_max;\n        srest = srest_min;\n        sall = sk + srest;\n    } else if (type == \"top_l\") {\n        sk = sk_min;\n        srest = srest_max;\n        sall = sk + srest;\n    } else if (type == \"sall_max\") {\n        sall = sall_max;\n        int sk_possible_min = max(sk_min, sall - srest_max);\n        int sk_possible_max = min(sk_max, sall - srest_min);\n        if(sk_possible_min > sk_possible_max) {\n            sk = sk_min;\n            srest = sall - sk;\n        } else {\n            sk = rnd.next(sk_possible_min, sk_possible_max);\n            srest = sall - sk;\n        }\n    } else if (type == \"sall_min\") {\n        sall = sall_min;\n        int sk_possible_min = max(sk_min, sall - srest_max);\n        int sk_possible_max = min(sk_max, sall - srest_min);\n        if(sk_possible_min > sk_possible_max) {\n            sk = sk_min;\n            srest = sall - sk;\n        } else {\n            sk = rnd.next(sk_possible_min, sk_possible_max);\n            srest = sall - sk;\n        }\n    } else if (type == \"sk_max\") {\n        sk = sk_max;\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    } else if (type == \"sk_min\") {\n        sk = sk_min;\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    } else if (type == \"n_eq_k\") {\n        n = k;\n        srest = 0;\n        sk = rnd.next(sk_min, sk_max);\n        sall = sk;\n    } else {\n        sk = rnd.next(sk_min, sk_max);\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    }\n\n    if(sall < sall_min) sall = sall_min;\n    if(sall > sall_max) sall = sall_max;\n\n    srest = sall - sk;\n    if(srest < srest_min) srest = srest_min;\n    if(srest > srest_max) srest = srest_max;\n    sall = sk + srest;\n\n    printf(\"%d %d %d %d %d %d\\n\", n, k, l, r, sall, sk);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(l <= r);\n    ensure(1 <= n && n <= 1000);\n    ensure(1 <= k && k <= n);\n    ensure(1 <= l && l <= 1000);\n    ensure(1 <= r && r <= 1000);\n\n    int sk_min = k * l;\n    int sk_max = k * r;\n\n    int srest_min = (n - k) * l;\n    int srest_max = (n - k) * r;\n\n    int sall_min = n * l;\n    int sall_max = n * r;\n\n    int sk = 0;\n    int srest = 0;\n    int sall = 0;\n\n    if (type == \"random\") {\n        sk = rnd.next(sk_min, sk_max);\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            sk = sall_min - srest_min;\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    } else if (type == \"all_l\") {\n        sk = sk_min;\n        srest = srest_min;\n        sall = sk + srest;\n    } else if (type == \"all_r\") {\n        sk = sk_max;\n        srest = srest_max;\n        sall = sk + srest;\n    } else if (type == \"top_r\") {\n        sk = sk_max;\n        srest = srest_min;\n        sall = sk + srest;\n    } else if (type == \"top_l\") {\n        sk = sk_min;\n        srest = srest_max;\n        sall = sk + srest;\n    } else if (type == \"sall_max\") {\n        sall = sall_max;\n        int sk_possible_min = max(sk_min, sall - srest_max);\n        int sk_possible_max = min(sk_max, sall - srest_min);\n        if(sk_possible_min > sk_possible_max) {\n            sk = sk_min;\n            srest = sall - sk;\n        } else {\n            sk = rnd.next(sk_possible_min, sk_possible_max);\n            srest = sall - sk;\n        }\n    } else if (type == \"sall_min\") {\n        sall = sall_min;\n        int sk_possible_min = max(sk_min, sall - srest_max);\n        int sk_possible_max = min(sk_max, sall - srest_min);\n        if(sk_possible_min > sk_possible_max) {\n            sk = sk_min;\n            srest = sall - sk;\n        } else {\n            sk = rnd.next(sk_possible_min, sk_possible_max);\n            srest = sall - sk;\n        }\n    } else if (type == \"sk_max\") {\n        sk = sk_max;\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    } else if (type == \"sk_min\") {\n        sk = sk_min;\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    } else if (type == \"n_eq_k\") {\n        n = k;\n        srest = 0;\n        sk = rnd.next(sk_min, sk_max);\n        sall = sk;\n    } else {\n        sk = rnd.next(sk_min, sk_max);\n        int srest_min_possible = max(srest_min, sall_min - sk);\n        int srest_max_possible = min(srest_max, sall_max - sk);\n        if(srest_min_possible > srest_max_possible) {\n            srest = srest_min;\n            sall = sk + srest;\n        } else {\n            srest = rnd.next(srest_min_possible, srest_max_possible);\n            sall = sk + srest;\n        }\n    }\n\n    if(sall < sall_min) sall = sall_min;\n    if(sall > sall_max) sall = sall_max;\n\n    srest = sall - sk;\n    if(srest < srest_min) srest = srest_min;\n    if(srest > srest_max) srest = srest_max;\n    sall = sk + srest;\n\n    printf(\"%d %d %d %d %d %d\\n\", n, k, l, r, sall, sk);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 3 -l 1 -r 3 -type all_l\n./gen -n 5 -k 3 -l 1 -r 3 -type all_r\n./gen -n 5 -k 3 -l 1 -r 3 -type top_r\n./gen -n 5 -k 3 -l 1 -r 3 -type top_l\n./gen -n 5 -k 5 -l 1 -r 3 -type n_eq_k\n./gen -n 10 -k 5 -l 1 -r 10 -type random\n./gen -n 10 -k 5 -l 1 -r 10 -type sk_max\n./gen -n 10 -k 5 -l 1 -r 10 -type sk_min\n./gen -n 10 -k 5 -l 1 -r 10 -type sall_max\n./gen -n 10 -k 5 -l 1 -r 10 -type sall_min\n./gen -n 100 -k 50 -l 1 -r 10 -type sk_max\n./gen -n 100 -k 50 -l 1 -r 10 -type sk_min\n./gen -n 100 -k 50 -l 5 -r 5 -type all_l\n./gen -n 1000 -k 500 -l 5 -r 5 -type random\n./gen -n 2 -k 1 -l 1 -r 1000 -type random\n./gen -n 2 -k 2 -l 1 -r 1000 -type n_eq_k\n./gen -n 3 -k 2 -l 1 -r 10 -type random\n./gen -n 4 -k 2 -l 1 -r 1 -type all_l\n./gen -n 999 -k 500 -l 1 -r 1000 -type top_r\n./gen -n 1000 -k 1 -l 1 -r 1000 -type top_l\n./gen -n 1000 -k 1 -l 1 -r 1000 -type random\n./gen -n 1000 -k 1000 -l 1 -r 1000 -type all_r\n./gen -n 1 -k 1 -l 1 -r 1000 -type random\n./gen -n 500 -k 500 -l 1 -r 1 -type all_l\n./gen -n 1000 -k 999 -l 1 -r 1000 -type sall_min\n./gen -n 999 -k 1 -l 1000 -r 1000 -type all_r\n./gen -n 1000 -k 999 -l 1 -r 1000 -type random\n./gen -n 1000 -k 1 -l 1 -r 1 -type all_l\n./gen -n 1000 -k 999 -l 50 -r 50 -type all_r\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:47.614366",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "369/C",
      "title": "C. Valera and Elections",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of districts in the city.Then n - 1 lines follow. Each line contains the description of a city road as three positive integers xi, yi, ti (1 ≤ xi, yi ≤ n, 1 ≤ ti ≤ 2) — the districts connected by the i-th bidirectional road and the road type. If ti equals to one, then the i-th road isn't the problem road; if ti equals to two, then the i-th road is the problem road.It's guaranteed that the graph structure of the city is a tree.",
      "output_spec": "OutputIn the first line print a single non-negative number k — the minimum size of the required subset of candidates. Then on the second line print k space-separated integers a1, a2, ... ak — the numbers of the candidates that form the required subset. If there are multiple solutions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy51 2 22 3 23 4 24 5 2OutputCopy15 InputCopy51 2 12 3 22 4 14 5 1OutputCopy13 InputCopy51 2 21 3 21 4 21 5 2OutputCopy45 4 3 2",
      "description": "C. Valera and Elections\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of districts in the city.Then n - 1 lines follow. Each line contains the description of a city road as three positive integers xi, yi, ti (1 ≤ xi, yi ≤ n, 1 ≤ ti ≤ 2) — the districts connected by the i-th bidirectional road and the road type. If ti equals to one, then the i-th road isn't the problem road; if ti equals to two, then the i-th road is the problem road.It's guaranteed that the graph structure of the city is a tree.\n\nOutputIn the first line print a single non-negative number k — the minimum size of the required subset of candidates. Then on the second line print k space-separated integers a1, a2, ... ak — the numbers of the candidates that form the required subset. If there are multiple solutions, you are allowed to print any of them.\n\nInputCopy51 2 22 3 23 4 24 5 2OutputCopy15 InputCopy51 2 12 3 22 4 14 5 1OutputCopy13 InputCopy51 2 21 3 21 4 21 5 2OutputCopy45 4 3 2\n\nInputCopy51 2 22 3 23 4 24 5 2\n\nOutputCopy15\n\nInputCopy51 2 12 3 22 4 14 5 1\n\nOutputCopy13\n\nInputCopy51 2 21 3 21 4 21 5 2\n\nOutputCopy45 4 3 2",
      "solutions": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on November 29th at 19:30 MSK, you are lucky to participate in Codeforces Round #216 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit) and Los Ilya (IlyaLos).We want to thank Gerald Agapov (Gerald) and Sergey Sukhov (Serega) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2000, 2500.UPD2: It was a misprint with scoring system, now it is correct.UPD Contest finished, congratulations to winners! Dshovn WhitedarkWalker hexor Pandii Ronnoc_2 Good Luck!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9738",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 756
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "369A - Valera and PlatesWe will use greedy algorithm. Let's now i-th day, and current dish is a dish of first type. Then if we have the bowl, let's use it. Otherwise we will increase the answer. If the current dish is a dish of the second type, we first try to get the plate, and then the bowl. If there are no plates/bowls at all, then we will increase the answer.Author's solution: 5306397369B - Valera and ContestIn this task you are to determine such array a1, a2, ..., an, that following conditions are met: r ≥ a1 ≥ a2 ≥ ... ≥ an ≥ l; ; ; It's clear to understand, that value sk should be distributed evenly between the first k elements. For example, you can use following algorithm: remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}If k ≠ n, you should use same algorithm with other elements, but there are to distribute value sall - sk.Some participants forgot about test, where k = n. They received RE11.Author's solution: 5306414369C - Valera and ElectionsConsider all the roads that we need to repair. Mark the ends of u, v white. After that, we will consider a simple dynamic programming d[v] (v is the vertex) on the tree that for each vertex in the tree determines the number of white vertexes in the subtree. It is easy to calculate this by using a recursive function calc(v, prev) (v is the current node, and prev its immediate ancestor): calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u]; \n}After that we will add to answer all white vertexes v such that next condition is correct: d[v] = 1Author's solution: 5306500369D - Valera and FoolsLet's p[A] is the pA from the statement. It's clear to understand that you can discribe the state by using pair of integers (A, B), where A is a number of the fool with smallest index, B — the second fool from the left. It is clear to understand that fool with indexes j ≥ B will be living. After that we will use bfs on the states (A, B). State (0, 1) is always visitable, because it is initial. We will push it in the queue. After that, there are only three transitions from current state (A, B). (B + 1, B + 2) — this transition is possible if and only if p[A] > 0 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. (A, B + 1) — this transition is possible if and only if p[A] > 0 и there are no fool with index j ≥ B, which has p[j] = 100. (B, B + 1) — this transition is possible if and only if p[A] ≠ 100 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. After that you are to determine number of states, which has distance from state (0, 1) less or equal to k. Also you should be careful, that if there are only one fool, that he doesn't shot.Author's solution: 5306516369E - Valera and QueriesLet's calculate sets xs[y] — all segments, whose right borders are exactly equal to y. Now we reduce our task to another. For each query we will count the number of segments that doesn't belong to any one point. Let's it will be the value v. Then the answer to the query is n - v. We add to our request the point 0 and a point MV + 1, where MV = 1000000. Let points request have the form x1 < x2... < xn. Consider the xi and xi + 1. Let pi is the number of segments that lie strictly inside xi and xi + 1. Then v = p1 + p2 + ... + pn - 1. We will use following algorithm to find the values pi. Let consider all such pairs (x, xi + 1) for all requests and to add them to a second set xQ[y] — all pairs whose right boundary is equal to r. Then to find the values p of pairs (xi, xi + 1) we will iterate ascending the right border. Additionally, we will support Fenwick's tree, which can make  +  = 1 at the point, and can calculate sum of the prefix. Let i — the current right border. Then we can find out the value p for all pairs (l, r), with the right border is equal to the i (l, i). Let j left border of the pair. Then the answer for the pair is the value of S - sum(j), where S — all added to the Fenwick's left borders, and sum(j) — sum of the prefix j. After that, for the current coordinate i we need to consider all segments in the set xs[i]. Let j left boundary of the segment. Then we need to make  +  = 1 at the point j in our Fenwick's tree. The total solution complexity is .Authors solution: 5306535",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9760",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 369\\s*C"
          },
          "content_length": 4401
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "random_shuffle(ans.begin(), ans.end());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "warning: ISO C++ forbids variable length array ‘p’",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "stack overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Memory limit exceeded on test 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 9",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 10",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint find(vector<int>& parent, int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent, parent[u]); // Path compression\n    return parent[u];\n}\n\nvoid merge(vector<int>& parent, int u, int v, int& connectedComponents) {\n    u = find(parent, u);\n    v = find(parent, v);\n    if (u != v) {\n        parent[u] = v;\n        connectedComponents--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAXN); // Read n ∈ [2, 1e5]\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    int connectedComponents = n;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n);\n        inf.readSpace();\n        int yi = inf.readInt(1, n);\n        inf.readSpace();\n        int ti = inf.readInt(1, 2);\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d connects a district to itself (%d)\", i + 1, xi);\n\n        pair<int, int> edge = make_pair(min(xi, yi), max(xi, yi));\n        ensuref(!edges.count(edge), \"Multiple edges between districts %d and %d\", xi, yi);\n        edges.insert(edge);\n\n        merge(parent, xi, yi, connectedComponents);\n    }\n\n    ensuref(connectedComponents == 1, \"The given graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint find(vector<int>& parent, int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent, parent[u]); // Path compression\n    return parent[u];\n}\n\nvoid merge(vector<int>& parent, int u, int v, int& connectedComponents) {\n    u = find(parent, u);\n    v = find(parent, v);\n    if (u != v) {\n        parent[u] = v;\n        connectedComponents--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAXN); // Read n ∈ [2, 1e5]\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    int connectedComponents = n;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n);\n        inf.readSpace();\n        int yi = inf.readInt(1, n);\n        inf.readSpace();\n        int ti = inf.readInt(1, 2);\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d connects a district to itself (%d)\", i + 1, xi);\n\n        pair<int, int> edge = make_pair(min(xi, yi), max(xi, yi));\n        ensuref(!edges.count(edge), \"Multiple edges between districts %d and %d\", xi, yi);\n        edges.insert(edge);\n\n        merge(parent, xi, yi, connectedComponents);\n    }\n\n    ensuref(connectedComponents == 1, \"The given graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint find(vector<int>& parent, int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent, parent[u]); // Path compression\n    return parent[u];\n}\n\nvoid merge(vector<int>& parent, int u, int v, int& connectedComponents) {\n    u = find(parent, u);\n    v = find(parent, v);\n    if (u != v) {\n        parent[u] = v;\n        connectedComponents--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAXN); // Read n ∈ [2, 1e5]\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    int connectedComponents = n;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n);\n        inf.readSpace();\n        int yi = inf.readInt(1, n);\n        inf.readSpace();\n        int ti = inf.readInt(1, 2);\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d connects a district to itself (%d)\", i + 1, xi);\n\n        pair<int, int> edge = make_pair(min(xi, yi), max(xi, yi));\n        ensuref(!edges.count(edge), \"Multiple edges between districts %d and %d\", xi, yi);\n        edges.insert(edge);\n\n        merge(parent, xi, yi, connectedComponents);\n    }\n\n    ensuref(connectedComponents == 1, \"The given graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<vector<pair<int, int>>> adj;\nvector<int> edgeType;\nvector<int> parent;\nvector<int> parentEdge;\nint totalProblemEdges = 0;\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    for (auto &e : adj[u]) {\n        int v = e.first;\n        int eID = e.second;\n        if (v != p) {\n            parentEdge[v] = eID;\n            dfs(v, u);\n        }\n    }\n}\n\nint readAns(InStream& stream, vector<bool>& repairedEdges) {\n    int k = stream.readInt(0, n, \"k\");\n    vector<int> candidates;\n    set<int> candidateSet;\n    vector<bool> usedCandidate(n + 1, false);\n\n    for (int i = 0; i < k; ++i) {\n        int candidate = stream.readInt(1, n, format(\"candidate[%d]\", i + 1).c_str());\n        if (usedCandidate[candidate])\n            stream.quitf(_wa, \"Candidate %d is listed more than once.\", candidate);\n        usedCandidate[candidate] = true;\n        candidates.push_back(candidate);\n        int u = candidate;\n        while (u != 1) {\n            int eID = parentEdge[u];\n            if (edgeType[eID] == 2) {\n                repairedEdges[eID] = true;\n            }\n            u = parent[u];\n        }\n    }\n    // After processing all candidates, check whether all problem edges are repaired.\n    for (int i = 0; i < n - 1; ++i) {\n        if (edgeType[i] == 2 && !repairedEdges[i]) {\n            stream.quitf(_wa, \"Not all problem roads are repaired.\");\n        }\n    }\n    return k;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(2, 100000, \"n\");\n    adj.resize(n + 1);\n    edgeType.resize(n - 1);\n    parent.resize(n + 1);\n    parentEdge.resize(n + 1);\n\n    for (int i = 0; i < n - 1; ++i) {\n        int x = inf.readInt(1, n);\n        int y = inf.readInt(1, n);\n        int t = inf.readInt(1, 2);\n        adj[x].push_back({y, i});\n        adj[y].push_back({x, i});\n        edgeType[i] = t;\n    }\n\n    dfs(1, 0);\n    parentEdge[1] = -1; // root node\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (edgeType[i] == 2) {\n            totalProblemEdges++;\n        }\n    }\n\n    vector<bool> repairedEdges(n - 1, false);\n    int k_jury = readAns(ans, repairedEdges);\n\n    repairedEdges.assign(n - 1, false);\n    int k_participant = readAns(ouf, repairedEdges);\n\n    if (k_participant > k_jury) {\n        quitf(_wa, \"Participant's answer has larger size than jury's answer: participant's k = %d, jury's k = %d\", k_participant, k_jury);\n    } else if (k_participant == k_jury) {\n        quitf(_ok, \"Correct answer with minimal size k = %d\", k_participant);\n    } else {\n        quitf(_fail, \"Participant has better answer than jury: participant's k = %d, jury's k = %d\", k_participant, k_jury);\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string road_type = opt<string>(\"road_type\", \"random\");\n    double prob_prob = opt<double>(\"prob_prob\", 0.5);\n\n    // Generate tree edges\n    vector<pair<int, int>> edges;\n\n    if(type == \"chain\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i - 1, i)); // Connect node i-1 to i\n        }\n    } else if(type == \"star\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(0, i)); // Connect node 0 to node i\n        }\n    } else if(type == \"binary\") {\n        for(int i = 1; i < n; ++i) {\n            int parent = (i - 1) / 2; // integer division\n            edges.push_back(make_pair(parent, i));\n        }\n    } else {\n        // Random tree\n        vector<int> p(n);\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(i); // Parent of node i\n        for(int i = 1; i < n; ++i)\n            edges.push_back(make_pair(p[i], i));\n    } \n\n    // Shuffle nodes\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Re-label edges\n    vector<pair<int,int>> new_edges;\n    for(auto edge : edges) {\n        int u = perm[edge.first];\n        int v = perm[edge.second];\n        new_edges.push_back(make_pair(u, v));\n    }\n\n    // Shuffle edges\n    shuffle(new_edges.begin(), new_edges.end());\n\n    // Assign road types\n    vector<int> tis(n - 1);\n\n    if(road_type == \"random\") {\n        for(int i = 0; i < n - 1; ++i) {\n            if(rnd.next() < prob_prob)\n                tis[i] = 2; // problem road\n            else\n                tis[i] = 1; // normal road\n        }\n    } else if(road_type == \"all_problem\") {\n        fill(tis.begin(), tis.end(), 2);\n    } else if(road_type == \"no_problem\") {\n        fill(tis.begin(), tis.end(), 1);\n    } else if(road_type == \"alternate\") {\n        for(int i = 0; i < n - 1; ++i) {\n            tis[i] = (i % 2 == 0) ? 2 : 1;\n        }\n    } else if(road_type == \"first_k_problem\") {\n        int k = opt<int>(\"k\", n - 1);\n        for(int i = 0; i < n - 1; ++i) {\n            tis[i] = (i < k) ? 2 : 1;\n        }\n    } else {\n        // Default to random if unknown road_type\n        for(int i = 0; i < n - 1; ++i) {\n            if(rnd.next() < prob_prob)\n                tis[i] = 2; // problem road\n            else\n                tis[i] = 1; // normal road\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n - 1; ++i) {\n        int u = new_edges[i].first + 1;\n        int v = new_edges[i].second + 1;\n        int ti = tis[i];\n        printf(\"%d %d %d\\n\", u, v, ti);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string road_type = opt<string>(\"road_type\", \"random\");\n    double prob_prob = opt<double>(\"prob_prob\", 0.5);\n\n    // Generate tree edges\n    vector<pair<int, int>> edges;\n\n    if(type == \"chain\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i - 1, i)); // Connect node i-1 to i\n        }\n    } else if(type == \"star\") {\n        for(int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(0, i)); // Connect node 0 to node i\n        }\n    } else if(type == \"binary\") {\n        for(int i = 1; i < n; ++i) {\n            int parent = (i - 1) / 2; // integer division\n            edges.push_back(make_pair(parent, i));\n        }\n    } else {\n        // Random tree\n        vector<int> p(n);\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(i); // Parent of node i\n        for(int i = 1; i < n; ++i)\n            edges.push_back(make_pair(p[i], i));\n    } \n\n    // Shuffle nodes\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Re-label edges\n    vector<pair<int,int>> new_edges;\n    for(auto edge : edges) {\n        int u = perm[edge.first];\n        int v = perm[edge.second];\n        new_edges.push_back(make_pair(u, v));\n    }\n\n    // Shuffle edges\n    shuffle(new_edges.begin(), new_edges.end());\n\n    // Assign road types\n    vector<int> tis(n - 1);\n\n    if(road_type == \"random\") {\n        for(int i = 0; i < n - 1; ++i) {\n            if(rnd.next() < prob_prob)\n                tis[i] = 2; // problem road\n            else\n                tis[i] = 1; // normal road\n        }\n    } else if(road_type == \"all_problem\") {\n        fill(tis.begin(), tis.end(), 2);\n    } else if(road_type == \"no_problem\") {\n        fill(tis.begin(), tis.end(), 1);\n    } else if(road_type == \"alternate\") {\n        for(int i = 0; i < n - 1; ++i) {\n            tis[i] = (i % 2 == 0) ? 2 : 1;\n        }\n    } else if(road_type == \"first_k_problem\") {\n        int k = opt<int>(\"k\", n - 1);\n        for(int i = 0; i < n - 1; ++i) {\n            tis[i] = (i < k) ? 2 : 1;\n        }\n    } else {\n        // Default to random if unknown road_type\n        for(int i = 0; i < n - 1; ++i) {\n            if(rnd.next() < prob_prob)\n                tis[i] = 2; // problem road\n            else\n                tis[i] = 1; // normal road\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n - 1; ++i) {\n        int u = new_edges[i].first + 1;\n        int v = new_edges[i].second + 1;\n        int ti = tis[i];\n        printf(\"%d %d %d\\n\", u, v, ti);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain -road_type all_problem\n./gen -n 2 -type chain -road_type no_problem\n./gen -n 2 -type chain -road_type alternate\n\n./gen -n 10 -type random -road_type random -prob_prob 0.5\n./gen -n 10 -type chain -road_type alternate\n./gen -n 10 -type star -road_type all_problem\n./gen -n 10 -type binary -road_type no_problem\n\n./gen -n 1000 -type random -road_type random -prob_prob 0.1\n./gen -n 1000 -type chain -road_type random -prob_prob 0.9\n./gen -n 1000 -type star -road_type alternate\n./gen -n 1000 -type binary -road_type all_problem\n\n./gen -n 100000 -type random -road_type random -prob_prob 0.5\n./gen -n 100000 -type chain -road_type all_problem\n./gen -n 100000 -type star -road_type no_problem\n\n./gen -n 99999 -type random -road_type first_k_problem -k 50000\n\n./gen -n 50000 -type chain -road_type random -prob_prob 0.01\n\n./gen -n 50000 -type chain -road_type random -prob_prob 0.99\n\n./gen -n 100000 -type random -road_type alternate\n\n./gen -n 2 -type random -road_type random -prob_prob 1.0\n./gen -n 2 -type random -road_type random -prob_prob 0.0\n\n./gen -n 1 -type star -road_type all_problem\n\n./gen -n 100000 -type binary -road_type random -prob_prob 0.5\n./gen -n 100000 -type binary -road_type no_problem\n./gen -n 100000 -type binary -road_type all_problem\n\n./gen -n 99999 -type binary -road_type alternate\n\n./gen -n 100000 -type chain -road_type random -prob_prob 0.9\n\n./gen -n 100000 -type chain -road_type random -prob_prob 0.1\n\n./gen -n 100000 -type random -road_type no_problem\n\n./gen -n 100000 -type random -road_type all_problem\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:49.997721",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "369/D",
      "title": "D. Valera and Fools",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (1 ≤ n, k ≤ 3000) — the initial number of fools and the number of bullets for each fool.The second line contains n integers p1, p2, ..., pn (0 ≤ pi ≤ 100) — the given probabilities (in percent).",
      "output_spec": "OutputPrint a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 350 50 50OutputCopy7InputCopy1 1100OutputCopy1InputCopy2 1100 100OutputCopy2InputCopy3 30 0 0OutputCopy1",
      "description": "D. Valera and Fools\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, k (1 ≤ n, k ≤ 3000) — the initial number of fools and the number of bullets for each fool.The second line contains n integers p1, p2, ..., pn (0 ≤ pi ≤ 100) — the given probabilities (in percent).\n\nOutputPrint a single number — the answer to the problem.\n\nInputCopy3 350 50 50OutputCopy7InputCopy1 1100OutputCopy1InputCopy2 1100 100OutputCopy2InputCopy3 30 0 0OutputCopy1\n\nInputCopy3 350 50 50\n\nOutputCopy7\n\nInputCopy1 1100\n\nOutputCopy1\n\nInputCopy2 1100 100\n\nOutputCopy2\n\nInputCopy3 30 0 0\n\nOutputCopy1\n\nNoteIn the first sample, any situation is possible, except for situation {1, 2}.In the second sample there is exactly one fool, so he does not make shots.In the third sample the possible situations are {1, 2} (after zero rounds) and the \"empty\" situation {} (after one round).In the fourth sample, the only possible situation is {1, 2, 3}.",
      "solutions": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on November 29th at 19:30 MSK, you are lucky to participate in Codeforces Round #216 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit) and Los Ilya (IlyaLos).We want to thank Gerald Agapov (Gerald) and Sergey Sukhov (Serega) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2000, 2500.UPD2: It was a misprint with scoring system, now it is correct.UPD Contest finished, congratulations to winners! Dshovn WhitedarkWalker hexor Pandii Ronnoc_2 Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9738",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 756
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "369A - Valera and PlatesWe will use greedy algorithm. Let's now i-th day, and current dish is a dish of first type. Then if we have the bowl, let's use it. Otherwise we will increase the answer. If the current dish is a dish of the second type, we first try to get the plate, and then the bowl. If there are no plates/bowls at all, then we will increase the answer.Author's solution: 5306397369B - Valera and ContestIn this task you are to determine such array a1, a2, ..., an, that following conditions are met: r ≥ a1 ≥ a2 ≥ ... ≥ an ≥ l; ; ; It's clear to understand, that value sk should be distributed evenly between the first k elements. For example, you can use following algorithm: remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}If k ≠ n, you should use same algorithm with other elements, but there are to distribute value sall - sk.Some participants forgot about test, where k = n. They received RE11.Author's solution: 5306414369C - Valera and ElectionsConsider all the roads that we need to repair. Mark the ends of u, v white. After that, we will consider a simple dynamic programming d[v] (v is the vertex) on the tree that for each vertex in the tree determines the number of white vertexes in the subtree. It is easy to calculate this by using a recursive function calc(v, prev) (v is the current node, and prev its immediate ancestor): calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u]; \n}After that we will add to answer all white vertexes v such that next condition is correct: d[v] = 1Author's solution: 5306500369D - Valera and FoolsLet's p[A] is the pA from the statement. It's clear to understand that you can discribe the state by using pair of integers (A, B), where A is a number of the fool with smallest index, B — the second fool from the left. It is clear to understand that fool with indexes j ≥ B will be living. After that we will use bfs on the states (A, B). State (0, 1) is always visitable, because it is initial. We will push it in the queue. After that, there are only three transitions from current state (A, B). (B + 1, B + 2) — this transition is possible if and only if p[A] > 0 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. (A, B + 1) — this transition is possible if and only if p[A] > 0 и there are no fool with index j ≥ B, which has p[j] = 100. (B, B + 1) — this transition is possible if and only if p[A] ≠ 100 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. After that you are to determine number of states, which has distance from state (0, 1) less or equal to k. Also you should be careful, that if there are only one fool, that he doesn't shot.Author's solution: 5306516369E - Valera and QueriesLet's calculate sets xs[y] — all segments, whose right borders are exactly equal to y. Now we reduce our task to another. For each query we will count the number of segments that doesn't belong to any one point. Let's it will be the value v. Then the answer to the query is n - v. We add to our request the point 0 and a point MV + 1, where MV = 1000000. Let points request have the form x1 < x2... < xn. Consider the xi and xi + 1. Let pi is the number of segments that lie strictly inside xi and xi + 1. Then v = p1 + p2 + ... + pn - 1. We will use following algorithm to find the values pi. Let consider all such pairs (x, xi + 1) for all requests and to add them to a second set xQ[y] — all pairs whose right boundary is equal to r. Then to find the values p of pairs (xi, xi + 1) we will iterate ascending the right border. Additionally, we will support Fenwick's tree, which can make  +  = 1 at the point, and can calculate sum of the prefix. Let i — the current right border. Then we can find out the value p for all pairs (l, r), with the right border is equal to the i (l, i). Let j left border of the pair. Then the answer for the pair is the value of S - sum(j), where S — all added to the Fenwick's left borders, and sum(j) — sum of the prefix j. After that, for the current coordinate i we need to consider all segments in the set xs[i]. Let j left boundary of the segment. Then we need to make  +  = 1 at the point j in our Fenwick's tree. The total solution complexity is .Authors solution: 5306535",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9760",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 369\\s*D"
          },
          "content_length": 4401
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "random_shuffle(ans.begin(), ans.end());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "warning: ISO C++ forbids variable length array ‘p’",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "stack overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Memory limit exceeded on test 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 9",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 10",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 3000, \"k\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 0, 100, \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 3000, \"k\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 0, 100, \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 3000, \"k\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 0, 100, \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<int> p(n);\n\n    if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = 0;\n        }\n    } else if (type == \"all_hundred\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = 100;\n        }\n    } else if (type == \"half_zero_half_hundred\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                p[i] = 0;\n            else\n                p[i] = 100;\n        }\n    } else if (type == \"alternating_zero_hundred\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = 0;\n            else\n                p[i] = 100;\n        }\n    } else if (type == \"random_small_pi\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(0, 10); // p_i between 0 and 10\n        }\n    } else if (type == \"random_large_pi\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(90, 100); // p_i between 90 and 100\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(0, 100); // p_i between 0 and 100\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Output p_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<int> p(n);\n\n    if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = 0;\n        }\n    } else if (type == \"all_hundred\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = 100;\n        }\n    } else if (type == \"half_zero_half_hundred\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                p[i] = 0;\n            else\n                p[i] = 100;\n        }\n    } else if (type == \"alternating_zero_hundred\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = 0;\n            else\n                p[i] = 100;\n        }\n    } else if (type == \"random_small_pi\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(0, 10); // p_i between 0 and 10\n        }\n    } else if (type == \"random_large_pi\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(90, 100); // p_i between 90 and 100\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(0, 100); // p_i between 0 and 100\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Output p_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type all_zero\n./gen -n 1 -k 1 -type all_hundred\n./gen -n 1 -k 1 -type random\n\n./gen -n 2 -k 1 -type all_zero\n./gen -n 2 -k 1 -type all_hundred\n./gen -n 2 -k 1 -type alternating_zero_hundred\n./gen -n 2 -k 1 -type random\n\n./gen -n 3 -k 2 -type all_zero\n./gen -n 3 -k 2 -type all_hundred\n./gen -n 3 -k 2 -type alternating_zero_hundred\n./gen -n 3 -k 2 -type random\n\n./gen -n 10 -k 5 -type random_small_pi\n./gen -n 10 -k 5 -type random_large_pi\n./gen -n 10 -k 5 -type random\n\n./gen -n 100 -k 50 -type random_small_pi\n./gen -n 100 -k 50 -type random_large_pi\n./gen -n 100 -k 50 -type random\n\n./gen -n 1000 -k 500 -type random_small_pi\n./gen -n 1000 -k 500 -type random_large_pi\n./gen -n 1000 -k 500 -type random\n\n./gen -n 3000 -k 3000 -type all_zero\n./gen -n 3000 -k 3000 -type all_hundred\n./gen -n 3000 -k 3000 -type alternating_zero_hundred\n./gen -n 3000 -k 3000 -type random_small_pi\n./gen -n 3000 -k 3000 -type random_large_pi\n./gen -n 3000 -k 3000 -type random\n\n./gen -n 3000 -k 1 -type all_zero\n./gen -n 3000 -k 1 -type all_hundred\n./gen -n 3000 -k 1 -type random\n\n./gen -n 1 -k 3000 -type random\n\n./gen -n 2 -k 3000 -type random\n\n./gen -n 1000 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:51.994564",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "369/E",
      "title": "E. Valera and Queries",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 3·105) — the number of segments on the axis of coordinates and the number of queries. Next n lines contain the descriptions of the segments. The i-th line contains two positive integers li, ri (1 ≤ li ≤ ri ≤ 106) — the borders of the i-th segment.Next m lines contain the description of the queries, one per line. Each line starts from integer cnti (1 ≤ cnti ≤ 3·105) — the number of points in the i-th query. Then the line contains cnti distinct positive integers p1, p2, ..., pcnti (1 ≤ p1 < p2 < ... < pcnti ≤ 106) — the coordinates of points in the i-th query.It is guaranteed that the total number of points in all queries doesn't exceed 3·105.",
      "output_spec": "OutputPrint m non-negative integers, where the i-th number is the response to the i-th query.",
      "sample_tests": "ExamplesInputCopy3 31 34 56 73 1 4 72 4 51 8OutputCopy310",
      "description": "E. Valera and Queries\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 3·105) — the number of segments on the axis of coordinates and the number of queries. Next n lines contain the descriptions of the segments. The i-th line contains two positive integers li, ri (1 ≤ li ≤ ri ≤ 106) — the borders of the i-th segment.Next m lines contain the description of the queries, one per line. Each line starts from integer cnti (1 ≤ cnti ≤ 3·105) — the number of points in the i-th query. Then the line contains cnti distinct positive integers p1, p2, ..., pcnti (1 ≤ p1 < p2 < ... < pcnti ≤ 106) — the coordinates of points in the i-th query.It is guaranteed that the total number of points in all queries doesn't exceed 3·105.\n\nOutputPrint m non-negative integers, where the i-th number is the response to the i-th query.\n\nInputCopy3 31 34 56 73 1 4 72 4 51 8OutputCopy310\n\nInputCopy3 31 34 56 73 1 4 72 4 51 8\n\nOutputCopy310",
      "solutions": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on November 29th at 19:30 MSK, you are lucky to participate in Codeforces Round #216 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit) and Los Ilya (IlyaLos).We want to thank Gerald Agapov (Gerald) and Sergey Sukhov (Serega) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.UPD1: Scoring will be next: 500, 1000, 1500, 2000, 2500.UPD2: It was a misprint with scoring system, now it is correct.UPD Contest finished, congratulations to winners! Dshovn WhitedarkWalker hexor Pandii Ronnoc_2 Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9738",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 756
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces",
          "content": "369A - Valera and PlatesWe will use greedy algorithm. Let's now i-th day, and current dish is a dish of first type. Then if we have the bowl, let's use it. Otherwise we will increase the answer. If the current dish is a dish of the second type, we first try to get the plate, and then the bowl. If there are no plates/bowls at all, then we will increase the answer.Author's solution: 5306397369B - Valera and ContestIn this task you are to determine such array a1, a2, ..., an, that following conditions are met: r ≥ a1 ≥ a2 ≥ ... ≥ an ≥ l; ; ; It's clear to understand, that value sk should be distributed evenly between the first k elements. For example, you can use following algorithm: remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}If k ≠ n, you should use same algorithm with other elements, but there are to distribute value sall - sk.Some participants forgot about test, where k = n. They received RE11.Author's solution: 5306414369C - Valera and ElectionsConsider all the roads that we need to repair. Mark the ends of u, v white. After that, we will consider a simple dynamic programming d[v] (v is the vertex) on the tree that for each vertex in the tree determines the number of white vertexes in the subtree. It is easy to calculate this by using a recursive function calc(v, prev) (v is the current node, and prev its immediate ancestor): calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u]; \n}After that we will add to answer all white vertexes v such that next condition is correct: d[v] = 1Author's solution: 5306500369D - Valera and FoolsLet's p[A] is the pA from the statement. It's clear to understand that you can discribe the state by using pair of integers (A, B), where A is a number of the fool with smallest index, B — the second fool from the left. It is clear to understand that fool with indexes j ≥ B will be living. After that we will use bfs on the states (A, B). State (0, 1) is always visitable, because it is initial. We will push it in the queue. After that, there are only three transitions from current state (A, B). (B + 1, B + 2) — this transition is possible if and only if p[A] > 0 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. (A, B + 1) — this transition is possible if and only if p[A] > 0 и there are no fool with index j ≥ B, which has p[j] = 100. (B, B + 1) — this transition is possible if and only if p[A] ≠ 100 and there are some fool with index j ≥ B, which has non-zero value p[j] > 0. After that you are to determine number of states, which has distance from state (0, 1) less or equal to k. Also you should be careful, that if there are only one fool, that he doesn't shot.Author's solution: 5306516369E - Valera and QueriesLet's calculate sets xs[y] — all segments, whose right borders are exactly equal to y. Now we reduce our task to another. For each query we will count the number of segments that doesn't belong to any one point. Let's it will be the value v. Then the answer to the query is n - v. We add to our request the point 0 and a point MV + 1, where MV = 1000000. Let points request have the form x1 < x2... < xn. Consider the xi and xi + 1. Let pi is the number of segments that lie strictly inside xi and xi + 1. Then v = p1 + p2 + ... + pn - 1. We will use following algorithm to find the values pi. Let consider all such pairs (x, xi + 1) for all requests and to add them to a second set xQ[y] — all pairs whose right boundary is equal to r. Then to find the values p of pairs (xi, xi + 1) we will iterate ascending the right border. Additionally, we will support Fenwick's tree, which can make  +  = 1 at the point, and can calculate sum of the prefix. Let i — the current right border. Then we can find out the value p for all pairs (l, r), with the right border is equal to the i (l, i). Let j left border of the pair. Then the answer for the pair is the value of S - sum(j), where S — all added to the Fenwick's left borders, and sum(j) — sum of the prefix j. After that, for the current coordinate i we need to consider all segments in the set xs[i]. Let j left boundary of the segment. Then we need to make  +  = 1 at the point j in our Fenwick's tree. The total solution complexity is .Authors solution: 5306535",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9760",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 369\\s*E"
          },
          "content_length": 4401
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "cout << 0/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "int a;\ncin >> a;\ncout << 0/a << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "int a;\ncin >> a;\ncout << a/0 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Participants count: 2021\nA | first: 00:02 | sent/passed/hacked: 1963/1774/26\nB | first: 00:08 | sent/passed/hacked: 1665/816/239\nC | first: 00:11 | sent/passed/hacked: 819/442/1\nD | first: 00:33 | sent/passed/hacked: 45/15/0\nE | first: 00:44 | sent/passed/hacked: 87/11/0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9738",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 1",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 2",
          "code": "remainder = (s_k mod k);\nfor(int i = 0; i < k; i++) \n{\n\ta_i = s_k / k + (remainder > 0);\n\tremainder = remainder - 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 3",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 4",
          "code": "calc(v, prev)\n{\n\td[v] = 0; \n\tif (white[v])\n\t\tdv += 1; \n\tfor all vertexes u such that there is the edge (u,v) or (v,u), u != prev:\n\t\tcalc(u, v);\n\t\td[v] += d[u];  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 5",
          "code": "random_shuffle(ans.begin(), ans.end());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 6",
          "code": "warning: ISO C++ forbids variable length array ‘p’",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 7",
          "code": "stack overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 8",
          "code": "Memory limit exceeded on test 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 9",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #216 (Div. 2) - Codeforces - Code 10",
          "code": "bool dfs(int par,int node,bool problem)\n{\n\tbool child_problem=0;\n\tfor(auto x:adj[node])  //iterating over all children;\n\t\tif(x!=par)\n\t\t{\n\t\t\tbool f=m[node][x];\n\t\t\tchild_problem|=dfs(node,x,f);\t//if any one of the child has problem;\n\t\t}\n\tif(child_problem==0 && problem==1)\n\t{\n\t\tans.pb(node);\n\t\tchild_problem=1;\n\t}\n\treturn child_problem;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9760",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000, \"ri\");\n        inf.readEoln();\n    }\n\n    long long total_points = 0;\n    for (int i = 0; i < m; ++i) {\n        int cnti = inf.readInt(1, 300000, \"cnti\");\n        total_points += cnti;\n        ensuref(total_points <= 300000, \"Total number of points in all queries must not exceed 300000\");\n\n        inf.readSpace();\n        vector<int> p = inf.readInts(cnti, 1, 1000000, \"points\");\n\n        for (int j = 1; j < cnti; ++j) {\n            ensuref(p[j - 1] < p[j], \"Points in a query must be strictly increasing\");\n        }\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000, \"ri\");\n        inf.readEoln();\n    }\n\n    long long total_points = 0;\n    for (int i = 0; i < m; ++i) {\n        int cnti = inf.readInt(1, 300000, \"cnti\");\n        total_points += cnti;\n        ensuref(total_points <= 300000, \"Total number of points in all queries must not exceed 300000\");\n\n        inf.readSpace();\n        vector<int> p = inf.readInts(cnti, 1, 1000000, \"points\");\n\n        for (int j = 1; j < cnti; ++j) {\n            ensuref(p[j - 1] < p[j], \"Points in a query must be strictly increasing\");\n        }\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000, \"ri\");\n        inf.readEoln();\n    }\n\n    long long total_points = 0;\n    for (int i = 0; i < m; ++i) {\n        int cnti = inf.readInt(1, 300000, \"cnti\");\n        total_points += cnti;\n        ensuref(total_points <= 300000, \"Total number of points in all queries must not exceed 300000\");\n\n        inf.readSpace();\n        vector<int> p = inf.readInts(cnti, 1, 1000000, \"points\");\n\n        for (int j = 1; j < cnti; ++j) {\n            ensuref(p[j - 1] < p[j], \"Points in a query must be strictly increasing\");\n        }\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int tot_p = opt<int>(\"tot_p\");\n    string seg_type = opt<string>(\"seg_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 300000);\n    ensure(1 <= m && m <= 300000);\n    ensure(1 <= tot_p && tot_p <= 300000);\n\n    // Generate segments\n    vector<pair<int, int>> segments(n); // pairs of (l_i, r_i)\n    int coord_max = 1000000;\n\n    if (seg_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, coord_max);\n            int r = rnd.next(1, coord_max);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"overlap\") {\n        // All segments overlap at point coord_max/2\n        int mid = coord_max / 2;\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(mid - coord_max / 10, mid);\n            int r = rnd.next(mid, mid + coord_max / 10);\n            l = max(1, l);\n            r = min(coord_max, r);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"nonoverlap\") {\n        // Non-overlapping segments\n        int curr = 1;\n        int delta = coord_max / n;\n        for (int i = 0; i < n; ++i) {\n            int l = curr;\n            int r = curr + delta - 1;\n            if (l > r) r = l;\n            segments[i] = make_pair(l, r);\n            curr = r + 1;\n        }\n    } else if (seg_type == \"full\") {\n        // All segments cover full range\n        for (int i = 0; i < n; ++i) {\n            int l = 1;\n            int r = coord_max;\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"point\") {\n        // Segments with l_i == r_i\n        for (int i = 0; i < n; ++i) {\n            int p = rnd.next(1, coord_max);\n            segments[i] = make_pair(p, p);\n        }\n    } else if (seg_type == \"first_half\") {\n        // Segments are in [1, coord_max/2]\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, coord_max / 2);\n            int r = rnd.next(1, coord_max / 2);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"second_half\") {\n        // Segments are in [coord_max/2+1, coord_max]\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(coord_max / 2 + 1, coord_max);\n            int r = rnd.next(coord_max / 2 + 1, coord_max);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, coord_max);\n            int r = rnd.next(1, coord_max);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", segments[i].first, segments[i].second);\n    }\n\n    // Now generate queries\n    // tot_p points need to be distributed among m queries\n    // We'll generate cnt_i for each query, ensuring sum(cnt_i) == tot_p\n\n    vector<int> cnt(m, tot_p / m);\n    int remainder = tot_p % m;\n    for (int i = 0; i < remainder; ++i) {\n        cnt[i]++;\n    }\n\n    // Ensure that cnt_i ≤ 300000\n    for (int i = 0; i < m; ++i) {\n        ensure(1 <= cnt[i] && cnt[i] <= 300000);\n    }\n\n    // Now generate points for each query according to query_type\n\n    vector<vector<int>> queries(m);\n\n    if (query_type == \"random\") {\n        // Generate random points\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(1, coord_max);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    } else if (query_type == \"edge\") {\n        // Points at segment endpoints\n        vector<int> endpoints;\n        for (int i = 0; i < n; ++i) {\n            endpoints.push_back(segments[i].first);\n            endpoints.push_back(segments[i].second);\n        }\n        sort(endpoints.begin(), endpoints.end());\n        endpoints.erase(unique(endpoints.begin(), endpoints.end()), endpoints.end());\n        int total_endpoints = endpoints.size();\n        for (int i = 0; i < m; ++i) {\n            int sz = cnt[i];\n            vector<int> qpoints;\n            int idx = 0;\n            while (sz > 0 && idx < total_endpoints) {\n                qpoints.push_back(endpoints[idx]);\n                idx++;\n                sz--;\n            }\n            // If not enough endpoints, fill with random points\n            while (sz > 0) {\n                int p = rnd.next(1, coord_max);\n                qpoints.push_back(p);\n                sz--;\n            }\n            sort(qpoints.begin(), qpoints.end());\n            qpoints.erase(unique(qpoints.begin(), qpoints.end()), qpoints.end());\n            queries[i] = qpoints;\n        }\n    } else if (query_type == \"no_coverage\") {\n        // Points not covered by any segment\n        // Assuming segments are in [1, coord_max/2], generate points in [coord_max/2+1, coord_max]\n        int point_l = coord_max / 2 + 1;\n        int point_r = coord_max;\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(point_l, point_r);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    } else if (query_type == \"full_coverage\") {\n        // Points covering the full coordinate range\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            int step = max(1, coord_max / cnt[i]);\n            for (int p = 1; p <= coord_max && (int)points_set.size() < cnt[i]; p += step) {\n                points_set.insert(p);\n            }\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(1, coord_max);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(1, coord_max);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    }\n\n    // Now output queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", cnt[i]);\n        for (int p : queries[i]) {\n            printf(\" %d\", p);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int tot_p = opt<int>(\"tot_p\");\n    string seg_type = opt<string>(\"seg_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 300000);\n    ensure(1 <= m && m <= 300000);\n    ensure(1 <= tot_p && tot_p <= 300000);\n\n    // Generate segments\n    vector<pair<int, int>> segments(n); // pairs of (l_i, r_i)\n    int coord_max = 1000000;\n\n    if (seg_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, coord_max);\n            int r = rnd.next(1, coord_max);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"overlap\") {\n        // All segments overlap at point coord_max/2\n        int mid = coord_max / 2;\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(mid - coord_max / 10, mid);\n            int r = rnd.next(mid, mid + coord_max / 10);\n            l = max(1, l);\n            r = min(coord_max, r);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"nonoverlap\") {\n        // Non-overlapping segments\n        int curr = 1;\n        int delta = coord_max / n;\n        for (int i = 0; i < n; ++i) {\n            int l = curr;\n            int r = curr + delta - 1;\n            if (l > r) r = l;\n            segments[i] = make_pair(l, r);\n            curr = r + 1;\n        }\n    } else if (seg_type == \"full\") {\n        // All segments cover full range\n        for (int i = 0; i < n; ++i) {\n            int l = 1;\n            int r = coord_max;\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"point\") {\n        // Segments with l_i == r_i\n        for (int i = 0; i < n; ++i) {\n            int p = rnd.next(1, coord_max);\n            segments[i] = make_pair(p, p);\n        }\n    } else if (seg_type == \"first_half\") {\n        // Segments are in [1, coord_max/2]\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, coord_max / 2);\n            int r = rnd.next(1, coord_max / 2);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else if (seg_type == \"second_half\") {\n        // Segments are in [coord_max/2+1, coord_max]\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(coord_max / 2 + 1, coord_max);\n            int r = rnd.next(coord_max / 2 + 1, coord_max);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, coord_max);\n            int r = rnd.next(1, coord_max);\n            if (l > r) swap(l, r);\n            segments[i] = make_pair(l, r);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", segments[i].first, segments[i].second);\n    }\n\n    // Now generate queries\n    // tot_p points need to be distributed among m queries\n    // We'll generate cnt_i for each query, ensuring sum(cnt_i) == tot_p\n\n    vector<int> cnt(m, tot_p / m);\n    int remainder = tot_p % m;\n    for (int i = 0; i < remainder; ++i) {\n        cnt[i]++;\n    }\n\n    // Ensure that cnt_i ≤ 300000\n    for (int i = 0; i < m; ++i) {\n        ensure(1 <= cnt[i] && cnt[i] <= 300000);\n    }\n\n    // Now generate points for each query according to query_type\n\n    vector<vector<int>> queries(m);\n\n    if (query_type == \"random\") {\n        // Generate random points\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(1, coord_max);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    } else if (query_type == \"edge\") {\n        // Points at segment endpoints\n        vector<int> endpoints;\n        for (int i = 0; i < n; ++i) {\n            endpoints.push_back(segments[i].first);\n            endpoints.push_back(segments[i].second);\n        }\n        sort(endpoints.begin(), endpoints.end());\n        endpoints.erase(unique(endpoints.begin(), endpoints.end()), endpoints.end());\n        int total_endpoints = endpoints.size();\n        for (int i = 0; i < m; ++i) {\n            int sz = cnt[i];\n            vector<int> qpoints;\n            int idx = 0;\n            while (sz > 0 && idx < total_endpoints) {\n                qpoints.push_back(endpoints[idx]);\n                idx++;\n                sz--;\n            }\n            // If not enough endpoints, fill with random points\n            while (sz > 0) {\n                int p = rnd.next(1, coord_max);\n                qpoints.push_back(p);\n                sz--;\n            }\n            sort(qpoints.begin(), qpoints.end());\n            qpoints.erase(unique(qpoints.begin(), qpoints.end()), qpoints.end());\n            queries[i] = qpoints;\n        }\n    } else if (query_type == \"no_coverage\") {\n        // Points not covered by any segment\n        // Assuming segments are in [1, coord_max/2], generate points in [coord_max/2+1, coord_max]\n        int point_l = coord_max / 2 + 1;\n        int point_r = coord_max;\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(point_l, point_r);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    } else if (query_type == \"full_coverage\") {\n        // Points covering the full coordinate range\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            int step = max(1, coord_max / cnt[i]);\n            for (int p = 1; p <= coord_max && (int)points_set.size() < cnt[i]; p += step) {\n                points_set.insert(p);\n            }\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(1, coord_max);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            set<int> points_set;\n            while ((int)points_set.size() < cnt[i]) {\n                int p = rnd.next(1, coord_max);\n                points_set.insert(p);\n            }\n            queries[i] = vector<int>(points_set.begin(), points_set.end());\n            sort(queries[i].begin(), queries[i].end());\n        }\n    }\n\n    // Now output queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", cnt[i]);\n        for (int p : queries[i]) {\n            printf(\" %d\", p);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 10 -tot_p 10 -seg_type random -query_type random\n./gen -n 100 -m 100 -tot_p 1000 -seg_type random -query_type random\n./gen -n 1000 -m 1000 -tot_p 10000 -seg_type random -query_type random\n./gen -n 10000 -m 10000 -tot_p 50000 -seg_type random -query_type random\n./gen -n 300000 -m 300000 -tot_p 300000 -seg_type random -query_type random\n\n./gen -n 300000 -m 1 -tot_p 300000 -seg_type full -query_type full_coverage\n./gen -n 1 -m 300000 -tot_p 300000 -seg_type full -query_type random\n./gen -n 300000 -m 1 -tot_p 1 -seg_type full -query_type no_coverage\n\n./gen -n 300000 -m 300000 -tot_p 300000 -seg_type overlap -query_type edge\n./gen -n 100000 -m 100000 -tot_p 300000 -seg_type overlap -query_type edge\n\n./gen -n 5000 -m 1000 -tot_p 6000 -seg_type first_half -query_type no_coverage\n./gen -n 50000 -m 50000 -tot_p 300000 -seg_type first_half -query_type no_coverage\n\n./gen -n 300000 -m 50 -tot_p 300000 -seg_type overlap -query_type random\n./gen -n 300000 -m 300000 -tot_p 300000 -seg_type nonoverlap -query_type random\n./gen -n 250000 -m 50000 -tot_p 300000 -seg_type point -query_type random\n\n./gen -n 300000 -m 1 -tot_p 300000 -seg_type nonoverlap -query_type random\n./gen -n 300000 -m 300000 -tot_p 300000 -seg_type random -query_type no_coverage\n\n./gen -n 1 -m 300000 -tot_p 300000 -seg_type full -query_type edge\n./gen -n 500 -m 1000 -tot_p 5000 -seg_type overlap -query_type edge\n\n./gen -n 100000 -m 200000 -tot_p 300000 -seg_type random -query_type random\n./gen -n 200000 -m 100000 -tot_p 300000 -seg_type random -query_type random\n\n./gen -n 1 -m 1 -tot_p 1 -seg_type full -query_type full_coverage\n./gen -n 1 -m 1 -tot_p 1 -seg_type full -query_type no_coverage\n\n./gen -n 100000 -m 1 -tot_p 1 -seg_type nonoverlap -query_type random\n./gen -n 1 -m 100000 -tot_p 300000 -seg_type point -query_type random\n\n./gen -n 50000 -m 50000 -tot_p 300000 -seg_type second_half -query_type no_coverage\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:54.178530",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "37/A",
      "title": "A. Towers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer N (1 ≤ N ≤ 1000) — the number of bars at Vasya’s disposal. The second line contains N space-separated integers li — the lengths of the bars. All the lengths are natural numbers not exceeding 1000.",
      "output_spec": "OutputIn one line output two numbers — the height of the largest tower and their total number. Remember that Vasya should use all the bars.",
      "sample_tests": "ExamplesInputCopy31 2 3OutputCopy1 3InputCopy46 5 6 7OutputCopy2 3",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer N (1 ≤ N ≤ 1000) — the number of bars at Vasya’s disposal. The second line contains N space-separated integers li — the lengths of the bars. All the lengths are natural numbers not exceeding 1000.\n\nOutputIn one line output two numbers — the height of the largest tower and their total number. Remember that Vasya should use all the bars.\n\nInputCopy31 2 3OutputCopy1 3InputCopy46 5 6 7OutputCopy2 3\n\nInputCopy31 2 3\n\nOutputCopy1 3\n\nInputCopy46 5 6 7\n\nOutputCopy2 3",
      "solutions": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces",
          "content": "Good evening!Today I am the author of problems. I'm studying in Nizhny Novgorod State University (2 year, Mechanics and Mathematics). I want to thank the staff codeforces for assistance in preparing the contest, and, personally, Artem Rakhov and Maria Belova (for translations of problems into English). Also special thanks to Alexei Shmelev (NNSU) for writing alternative solutions.P.S. Unfortunately, this round could be in error to register a team. For teams participating in this round will be counted \"out of competition\", ie, rating of participants does not change. If you register a team by mistake, you can unregister and register in person.UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over, congratulate Ivan Popelyshev, who won this round. He was the only one who has successfully solved all five problems.Link to results.UPD: Tutorials are available.Regards,Vladislav Yepifanov.ПрослушатьНа латинице",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/792",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Beta Round #37 (Tutorial) - Codeforces",
          "content": "A. Towers The total number of towers is equal to number of different numbers in this set. To get the maximum height of the tower, it was possible to calculate for each length the number of bars with this length, and from these numbers is to choose the maximum. B. Computer Game Constraints in the problem allows us to solve it this way: we keep the current number of health from the boss, and current summary damage from used scrolls per second. At the next step, we choose which scrolls we can use in the current second. Of all these, we find the scroll, which causes the most damage, and apply it. If at some point we could not use any of the scrolls, and the current damage in one second does not exceed regeneration, we deduce that there are no answers. Otherwise, continue to iterate the algorithm until the number hit points will be nonnegative. C. Old Berland LanguageOne of the easiest to understand solutions of this problem is as follows: sort the words in ascending order of length, while remembering their positions in the source list. We will consistently build our set, starting with the short strings: strings of length one can only be strings \"0\" and \"1\". If the number of words of length one in a set are more than two, hence there are no answers. Add the desired number of strings of length one to answer, and remove it from the current list. Then look at the string of length two: each of the remaining strings of length one can be extended in two ways (having added to each of these symbols 0 and 1). Add the desired number of strings of length two in our answer, and then increase the length of the remaining strings by one. Continue this process, until we get all words from the input set. You can see that if at some moment the number of allowable words exceeded the number of remaining, the extra words can be ignored and solution takes O (N * the maximum length of input set) time. D. Lesson TimetableThis problem is solved by dynamic programming:state of dynamics will be a pair of numbers - the number of current room and number of groups which have first lesson in the room with a number not exceeding the current and for which the second room is not defined yet. For each state check all possible number of groups for which the second lesson will be held in the current classroom. When you add an answer from the new state, it must be multiplied by the corresponding binomial coefficients (the number of ways to select groups which have the first lesson in next room - Xi + 1, and the number of ways to select groups which have the second lesson in the current classroom).  E. Trial for ChiefFirst, we construct the following graph: each cell we associate a vertex of the same color as the cell itself. Between neighboring cells hold an edge of weight 0, if the cells share the same color and weight of 1, if different. Now, for each cell count the shortest distance from it to the most distant black cell (denoted by D). It is easy to see that we can construct a sequence of D + 1 repainting leads to the desired coloring:The first step of color all the cells at a distance less than or equal to D in black colorAt the second step color all the cells at a distance less than or equal to D - 1 in whiteEtc.Of all the cells, choose the one for which this distance is minimal, and this distance increased by one will be the answer to the problem.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/798",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces - Code 1",
          "code": "Test #4:206 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 6 7Possible Answer:YES000000, 0000110, 0000111, 0001000, 0001001, 000001, 00010100001011, 0001100, 0001101, 0001110, 0001111, 0010000, 00100010010010, 0010011, 0010100, 0010101, 000010, 0010110",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/792",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n    vector<int> li = inf.readInts(N, 1, 1000, \"li\"); \n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n    vector<int> li = inf.readInts(N, 1, 1000, \"li\"); \n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n    vector<int> li = inf.readInts(N, 1, 1000, \"li\"); \n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int maxlen = opt<int>(\"maxlen\", 1000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> bars;\n\n    if (type == \"small_random\") {\n        // Small n between 1 and 10\n        n = rnd.next(1, 10);\n        bars.resize(n);\n        for(int i = 0; i < n; ++i)\n            bars[i] = rnd.next(1, maxlen);\n    } else if (n == -1) {\n        fprintf(stderr, \"Parameter n is required for type %s\\n\", type.c_str());\n        exit(1);\n    } else {\n        bars.resize(n);\n\n        if (type == \"random\") {\n            // Random bar lengths in range [1, maxlen]\n            for(int i = 0; i < n; ++i)\n                bars[i] = rnd.next(1, maxlen);\n        } else if (type == \"all_same\") {\n            // All bars have the same length\n            int len = rnd.next(1, maxlen);\n            fill(bars.begin(), bars.end(), len);\n        } else if (type == \"all_unique\") {\n            // All bar lengths are unique\n            if (n > maxlen) {\n                fprintf(stderr, \"Cannot generate %d unique lengths with maxlen %d\\n\", n, maxlen);\n                exit(1);\n            }\n            vector<int> lengths(maxlen);\n            for(int i = 0; i < maxlen; ++i)\n                lengths[i] = i+1;\n            shuffle(lengths.begin(), lengths.end());\n            for(int i = 0; i < n; ++i)\n                bars[i] = lengths[i];\n        } else if (type == \"half_half\") {\n            // Half bars have one length, half have another length\n            int len1 = rnd.next(1, maxlen);\n            int len2 = rnd.next(1, maxlen);\n            while (len2 == len1)\n                len2 = rnd.next(1, maxlen);\n            for(int i = 0; i < n/2; ++i)\n                bars[i] = len1;\n            for(int i = n/2; i < n; ++i)\n                bars[i] = len2;\n            if (n%2 == 1)\n                bars[n-1] = len1; // Assign the extra bar\n            shuffle(bars.begin(), bars.end());\n        } else if (type == \"increasing\") {\n            // Bar lengths from 1 to n (maxlen ≥ n)\n            if (maxlen < n)\n                maxlen = n; // Adjust maxlen\n            for(int i = 0; i < n; ++i)\n                bars[i] = i+1;\n        } else if (type == \"decreasing\") {\n            // Bar lengths from n down to 1\n            if (maxlen < n)\n                maxlen = n;\n            for(int i = 0; i < n; ++i)\n                bars[i] = n - i;\n        } else if (type == \"max_case\") {\n            // All bar lengths are maximum\n            fill(bars.begin(), bars.end(), maxlen);\n        } else if (type == \"pattern\") {\n            int pattern_size = opt<int>(\"pattern_size\", 10);\n            if (pattern_size > n)\n                pattern_size = n;\n            vector<int> pattern(pattern_size);\n            for(int i = 0; i < pattern_size; ++i)\n                pattern[i] = rnd.next(1, maxlen);\n            for(int i = 0; i < n; ++i)\n                bars[i] = pattern[i % pattern_size];\n            shuffle(bars.begin(), bars.end());\n        } else {\n            fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n            exit(1);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", int(bars.size()));\n    for(int i = 0; i < int(bars.size()); ++i)\n        printf(\"%d%c\", bars[i], (i == int(bars.size()) - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int maxlen = opt<int>(\"maxlen\", 1000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> bars;\n\n    if (type == \"small_random\") {\n        // Small n between 1 and 10\n        n = rnd.next(1, 10);\n        bars.resize(n);\n        for(int i = 0; i < n; ++i)\n            bars[i] = rnd.next(1, maxlen);\n    } else if (n == -1) {\n        fprintf(stderr, \"Parameter n is required for type %s\\n\", type.c_str());\n        exit(1);\n    } else {\n        bars.resize(n);\n\n        if (type == \"random\") {\n            // Random bar lengths in range [1, maxlen]\n            for(int i = 0; i < n; ++i)\n                bars[i] = rnd.next(1, maxlen);\n        } else if (type == \"all_same\") {\n            // All bars have the same length\n            int len = rnd.next(1, maxlen);\n            fill(bars.begin(), bars.end(), len);\n        } else if (type == \"all_unique\") {\n            // All bar lengths are unique\n            if (n > maxlen) {\n                fprintf(stderr, \"Cannot generate %d unique lengths with maxlen %d\\n\", n, maxlen);\n                exit(1);\n            }\n            vector<int> lengths(maxlen);\n            for(int i = 0; i < maxlen; ++i)\n                lengths[i] = i+1;\n            shuffle(lengths.begin(), lengths.end());\n            for(int i = 0; i < n; ++i)\n                bars[i] = lengths[i];\n        } else if (type == \"half_half\") {\n            // Half bars have one length, half have another length\n            int len1 = rnd.next(1, maxlen);\n            int len2 = rnd.next(1, maxlen);\n            while (len2 == len1)\n                len2 = rnd.next(1, maxlen);\n            for(int i = 0; i < n/2; ++i)\n                bars[i] = len1;\n            for(int i = n/2; i < n; ++i)\n                bars[i] = len2;\n            if (n%2 == 1)\n                bars[n-1] = len1; // Assign the extra bar\n            shuffle(bars.begin(), bars.end());\n        } else if (type == \"increasing\") {\n            // Bar lengths from 1 to n (maxlen ≥ n)\n            if (maxlen < n)\n                maxlen = n; // Adjust maxlen\n            for(int i = 0; i < n; ++i)\n                bars[i] = i+1;\n        } else if (type == \"decreasing\") {\n            // Bar lengths from n down to 1\n            if (maxlen < n)\n                maxlen = n;\n            for(int i = 0; i < n; ++i)\n                bars[i] = n - i;\n        } else if (type == \"max_case\") {\n            // All bar lengths are maximum\n            fill(bars.begin(), bars.end(), maxlen);\n        } else if (type == \"pattern\") {\n            int pattern_size = opt<int>(\"pattern_size\", 10);\n            if (pattern_size > n)\n                pattern_size = n;\n            vector<int> pattern(pattern_size);\n            for(int i = 0; i < pattern_size; ++i)\n                pattern[i] = rnd.next(1, maxlen);\n            for(int i = 0; i < n; ++i)\n                bars[i] = pattern[i % pattern_size];\n            shuffle(bars.begin(), bars.end());\n        } else {\n            fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n            exit(1);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", int(bars.size()));\n    for(int i = 0; i < int(bars.size()); ++i)\n        printf(\"%d%c\", bars[i], (i == int(bars.size()) - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n\n./gen -n 1 -type all_same\n./gen -n 2 -type all_same\n./gen -n 1000 -type all_same\n\n./gen -n 5 -type all_unique\n./gen -n 100 -type all_unique\n./gen -n 1000 -type all_unique\n\n./gen -n 6 -type half_half\n./gen -n 99 -type half_half\n./gen -n 1000 -type half_half\n\n./gen -n 10 -type increasing\n./gen -n 1000 -type increasing\n\n./gen -n 10 -type decreasing\n./gen -n 1000 -type decreasing\n\n./gen -n 1000 -type random -maxlen 5\n./gen -n 1000 -type random -maxlen 10\n\n./gen -n 1000 -type max_case\n\n./gen -type small_random\n\n./gen -n 1 -type all_same\n\n./gen -n 1000 -type random -maxlen 1\n\n./gen -n 1000 -type random -maxlen 1000\n\n./gen -n 1 -type random -maxlen 1\n\n./gen -n 500 -type half_half\n\n./gen -n 500 -type random -maxlen 10\n\n./gen -n 1000 -type pattern -pattern_size 5 -maxlen 10\n\n./gen -n 1000 -type pattern -pattern_size 20 -maxlen 50\n\n./gen -n 1000 -type all_unique\n\n./gen -n 1000 -type max_case -maxlen 1000\n\n./gen -n 1 -type random -maxlen 1000\n\n./gen -n 1 -type random -maxlen 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:56.422794",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "37/B",
      "title": "B. Computer Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers N, max and reg (1 ≤ N, max, reg ≤ 1000) –– the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each — the parameters of the i-th scroll (0 ≤ powi ≤ 100, 1 ≤ dmgi ≤ 2000).",
      "output_spec": "OutputIn case Petya can’t complete this level, output in the single line NO.Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds.Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.",
      "sample_tests": "ExamplesInputCopy2 10 3100 399 1OutputCopyNOInputCopy2 100 10100 1190 9OutputCopyYES19 20 110 2",
      "description": "B. Computer Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers N, max and reg (1 ≤ N, max, reg ≤ 1000) –– the amount of scrolls and the parameters of the boss. The next N lines contain two integers powi and dmgi each — the parameters of the i-th scroll (0 ≤ powi ≤ 100, 1 ≤ dmgi ≤ 2000).\n\nOutputIn case Petya can’t complete this level, output in the single line NO.Otherwise, output on the first line YES. On the second line output the minimal time after which the boss can be defeated and the number of used scrolls. In the next lines for each used scroll output space-separated number of seconds passed from the start of the battle to the moment the scroll was used and the number of the scroll. Scrolls are numbered starting from 1 in the input order. The first scroll is considered to be available to be used after 0 seconds.Output scrolls in the order they were used. It is not allowed to use scrolls after the boss is defeated.\n\nInputCopy2 10 3100 399 1OutputCopyNOInputCopy2 100 10100 1190 9OutputCopyYES19 20 110 2\n\nInputCopy2 10 3100 399 1\n\nOutputCopyNO\n\nInputCopy2 100 10100 1190 9\n\nOutputCopyYES19 20 110 2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces",
          "content": "Good evening!Today I am the author of problems. I'm studying in Nizhny Novgorod State University (2 year, Mechanics and Mathematics). I want to thank the staff codeforces for assistance in preparing the contest, and, personally, Artem Rakhov and Maria Belova (for translations of problems into English). Also special thanks to Alexei Shmelev (NNSU) for writing alternative solutions.P.S. Unfortunately, this round could be in error to register a team. For teams participating in this round will be counted \"out of competition\", ie, rating of participants does not change. If you register a team by mistake, you can unregister and register in person.UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over, congratulate Ivan Popelyshev, who won this round. He was the only one who has successfully solved all five problems.Link to results.UPD: Tutorials are available.Regards,Vladislav Yepifanov.ПрослушатьНа латинице",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/792",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Beta Round #37 (Tutorial) - Codeforces",
          "content": "A. Towers The total number of towers is equal to number of different numbers in this set. To get the maximum height of the tower, it was possible to calculate for each length the number of bars with this length, and from these numbers is to choose the maximum. B. Computer Game Constraints in the problem allows us to solve it this way: we keep the current number of health from the boss, and current summary damage from used scrolls per second. At the next step, we choose which scrolls we can use in the current second. Of all these, we find the scroll, which causes the most damage, and apply it. If at some point we could not use any of the scrolls, and the current damage in one second does not exceed regeneration, we deduce that there are no answers. Otherwise, continue to iterate the algorithm until the number hit points will be nonnegative. C. Old Berland LanguageOne of the easiest to understand solutions of this problem is as follows: sort the words in ascending order of length, while remembering their positions in the source list. We will consistently build our set, starting with the short strings: strings of length one can only be strings \"0\" and \"1\". If the number of words of length one in a set are more than two, hence there are no answers. Add the desired number of strings of length one to answer, and remove it from the current list. Then look at the string of length two: each of the remaining strings of length one can be extended in two ways (having added to each of these symbols 0 and 1). Add the desired number of strings of length two in our answer, and then increase the length of the remaining strings by one. Continue this process, until we get all words from the input set. You can see that if at some moment the number of allowable words exceeded the number of remaining, the extra words can be ignored and solution takes O (N * the maximum length of input set) time. D. Lesson TimetableThis problem is solved by dynamic programming:state of dynamics will be a pair of numbers - the number of current room and number of groups which have first lesson in the room with a number not exceeding the current and for which the second room is not defined yet. For each state check all possible number of groups for which the second lesson will be held in the current classroom. When you add an answer from the new state, it must be multiplied by the corresponding binomial coefficients (the number of ways to select groups which have the first lesson in next room - Xi + 1, and the number of ways to select groups which have the second lesson in the current classroom).  E. Trial for ChiefFirst, we construct the following graph: each cell we associate a vertex of the same color as the cell itself. Between neighboring cells hold an edge of weight 0, if the cells share the same color and weight of 1, if different. Now, for each cell count the shortest distance from it to the most distant black cell (denoted by D). It is easy to see that we can construct a sequence of D + 1 repainting leads to the desired coloring:The first step of color all the cells at a distance less than or equal to D in black colorAt the second step color all the cells at a distance less than or equal to D - 1 in whiteEtc.Of all the cells, choose the one for which this distance is minimal, and this distance increased by one will be the answer to the problem.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/798",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces - Code 1",
          "code": "Test #4:206 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 6 7Possible Answer:YES000000, 0000110, 0000111, 0001000, 0001001, 000001, 00010100001011, 0001100, 0001101, 0001110, 0001111, 0010000, 00100010010010, 0010011, 0010100, 0010101, 000010, 0010110",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/792",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readSpace();\n    int maxHealth = inf.readInt(1, 1000, \"max\");\n    inf.readSpace();\n    int reg = inf.readInt(1, 1000, \"reg\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int pow_i = inf.readInt(0, 100, \"pow_i\");\n        inf.readSpace();\n        int dmg_i = inf.readInt(1, 2000, \"dmg_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readSpace();\n    int maxHealth = inf.readInt(1, 1000, \"max\");\n    inf.readSpace();\n    int reg = inf.readInt(1, 1000, \"reg\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int pow_i = inf.readInt(0, 100, \"pow_i\");\n        inf.readSpace();\n        int dmg_i = inf.readInt(1, 2000, \"dmg_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readSpace();\n    int maxHealth = inf.readInt(1, 1000, \"max\");\n    inf.readSpace();\n    int reg = inf.readInt(1, 1000, \"reg\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int pow_i = inf.readInt(0, 100, \"pow_i\");\n        inf.readSpace();\n        int dmg_i = inf.readInt(1, 2000, \"dmg_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_T = 100000; // Maximum time to simulate\n\nint N, max_health, reg;\nvector<int> powi, dmgi;\n\n// Reads the answer (either from ans or ouf stream)\n// Returns:\n// -1 if the answer is \"NO\"\n// Otherwise, simulates the battle according to the strategy and returns the minimal time\nint readAndSimulate(InStream& stream, const char* who, int& k_out, vector<pair<int, int>>& used_scrolls_out) {\n    string verdict = stream.readToken();\n    if (verdict != \"NO\" && verdict != \"YES\") {\n        stream.quitf(_pe, \"%s output invalid verdict: expected 'NO' or 'YES', found '%s'\", who, verdict.c_str());\n    }\n    if (verdict == \"NO\") {\n        k_out = -1;\n        return -1; // Can't defeat the boss\n    } else {\n        int min_time = stream.readInt(1, MAX_T, \"minimal time\");\n        k_out = stream.readInt(0, N, \"number of used scrolls\");\n        vector<pair<int, int>> used_scrolls;\n        set<int> used_scroll_indices;\n        int last_time = -1;\n        for (int i = 0; i < k_out; ++i) {\n            int time = stream.readInt(0, min_time, format(\"time[%d]\", i + 1).c_str());\n            if (time < last_time) {\n                stream.quitf(_wa, \"%s used scrolls at non-increasing times\", who);\n            }\n            last_time = time;\n            int scroll_number = stream.readInt(1, N, format(\"scroll_number[%d]\", i + 1).c_str());\n            if (used_scroll_indices.count(scroll_number)) {\n                stream.quitf(_wa, \"%s used scroll %d more than once\", who, scroll_number);\n            }\n            used_scroll_indices.insert(scroll_number);\n            used_scrolls.emplace_back(time, scroll_number - 1); // Zero-based index\n        }\n        used_scrolls_out = used_scrolls;\n\n        // Simulate the battle\n        int health = max_health;\n        vector<int> active_dmgs(N, 0); // Damage per second from active spells\n        int total_dps = 0;\n\n        int scroll_idx = 0; // Index in used_scrolls\n        int defeat_time = -1;\n        for (int t = 0; t <= MAX_T; ++t) {\n            // Apply damage from active spells\n            health -= total_dps;\n            // Check if boss is defeated\n            if (health <= 0) {\n                defeat_time = t;\n                if (defeat_time > min_time) {\n                    stream.quitf(_wa, \"%s's claimed minimal time %d is less than actual defeat time %d\", who, min_time, defeat_time);\n                }\n                break;\n            }\n            if (t == min_time && defeat_time == -1) {\n                // Boss is not defeated at claimed minimal time\n                stream.quitf(_wa, \"%s's strategy does not defeat the boss at claimed minimal time %d\", who, min_time);\n            }\n\n            // Boss regenerates\n            health += reg;\n            if (health > max_health) health = max_health;\n\n            // Use scroll if scheduled at this time\n            while (scroll_idx < k_out && used_scrolls[scroll_idx].first == t) {\n                int scroll_num = used_scrolls[scroll_idx].second;\n                int pow_i = powi[scroll_num];\n                int dmg_i = dmgi[scroll_num];\n                int health_percent = (health * 100 + max_health - 1) / max_health; // Round up\n                if (health_percent > pow_i) {\n                    stream.quitf(_wa, \"%s cannot use scroll %d at time %d: boss health percent is %d%%, needs ≤ %d%%\", who, scroll_num + 1, t, health_percent, pow_i);\n                }\n                active_dmgs[scroll_num] = dmg_i;\n                total_dps += dmg_i;\n                scroll_idx++;\n            }\n        }\n        if (defeat_time == -1) {\n            stream.quitf(_wa, \"%s's strategy does not defeat the boss within the maximum time limit\", who);\n        }\n        return min_time;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input\n    N = inf.readInt(1, 1000, \"N\");\n    max_health = inf.readInt(1, 1000, \"max\");\n    reg = inf.readInt(1, 1000, \"reg\");\n    powi.resize(N);\n    dmgi.resize(N);\n    for (int i = 0; i < N; ++i) {\n        powi[i] = inf.readInt(0, 100, format(\"pow[%d]\", i + 1).c_str());\n        dmgi[i] = inf.readInt(1, 2000, format(\"dmg[%d]\", i + 1).c_str());\n    }\n\n    // Read jury's answer\n    int k_jury;\n    vector<pair<int, int>> used_scrolls_jury;\n    int t_jury = readAndSimulate(ans, \"Jury\", k_jury, used_scrolls_jury);\n\n    // Read contestant's answer\n    int k_contestant;\n    vector<pair<int, int>> used_scrolls_contestant;\n    int t_contestant = readAndSimulate(ouf, \"Contestant\", k_contestant, used_scrolls_contestant);\n\n    if (t_jury == -1) { // Jury says \"NO\"\n        if (t_contestant == -1) { // Contestant says \"NO\"\n            quitf(_ok, \"Both jury and contestant agree that boss cannot be defeated\");\n        } else {\n            quitf(_fail, \"Participant found a solution but jury did not\");\n        }\n    } else { // Jury says \"YES\"\n        if (t_contestant == -1) { // Contestant says \"NO\"\n            quitf(_wa, \"Contestant says 'NO' but jury has a valid solution\");\n        } else {\n            if (t_contestant > t_jury) {\n                quitf(_wa, \"Jury has a better answer: jury time = %d, contestant time = %d\", t_jury, t_contestant);\n            } else if (t_contestant == t_jury) {\n                quitf(_ok, \"Correct answer with minimal time = %d\", t_contestant);\n            } else { // t_contestant < t_jury\n                quitf(_fail, \"Participant has a better answer: jury time = %d, contestant time = %d\", t_jury, t_contestant);\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int N = opt<int>(\"n\", 10); // Number of scrolls\n    int max_health = opt<int>(\"max\", 100); // Boss max health\n    int reg = opt<int>(\"reg\", 10); // Boss regen per second\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that parameters are within constraints\n    N = max(1, min(N, 1000));\n    max_health = max(1, min(max_health, 1000));\n    reg = max(1, min(reg, 1000));\n\n    vector<pair<int, int>> scrolls(N); // Each scroll as pair of (pow_i, dmg_i)\n\n    if (type == \"random\") {\n        // Generate random scrolls within constraints\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"impossible\") {\n        // Generate scrolls such that boss cannot be defeated\n        // Total possible damage per second is less than or equal to reg\n        int total_dmg = 0;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            scrolls[i].first = pow_i;\n        }\n        // Assign dmg_i to make total_dmg ≤ reg\n        for (int i = 0; i < N; ++i) {\n            int remaining = max(0, reg - total_dmg);\n            int dmg_i = (i == N - 1) ? remaining : rnd.next(0, remaining);\n            scrolls[i].second = dmg_i;\n            total_dmg += dmg_i;\n        }\n    } else if (type == \"possible\") {\n        // Generate scrolls such that boss can be defeated\n        // Total possible damage per second is greater than reg\n        int total_dmg = reg + rnd.next(1, 1000);\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            scrolls[i].first = pow_i;\n        }\n        // Distribute total_dmg among scrolls\n        int remaining_dmg = total_dmg;\n        for (int i = 0; i < N; ++i) {\n            int dmg_i = rnd.next(1, min(2000, remaining_dmg - (N - i - 1)));\n            scrolls[i].second = dmg_i;\n            remaining_dmg -= dmg_i;\n        }\n    } else if (type == \"max_damage\") {\n        // All scrolls have maximum damage\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = 2000;\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"min_damage\") {\n        // All scrolls have minimum damage\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = 1;\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"high_regen\") {\n        // High regeneration rate\n        reg = rnd.next(max_health / 2, max_health);\n        reg = max(1, min(reg, 1000)); // Ensure reg within constraints\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, reg + rnd.next(1, 1000));\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"edge_pow\") {\n        // Edge cases for pow_i\n        for (int i = 0; i < N; ++i) {\n            int pow_i = (i % 2 == 0) ? 0 : 100;\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"large_N\") {\n        // Maximum number of scrolls\n        N = 1000;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"low_health\") {\n        // Boss with minimum health and regen\n        max_health = 1;\n        reg = 1;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = 100;\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"max_health\") {\n        // Boss with maximum health and regen\n        max_health = 1000;\n        reg = 1000;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", N, max_health, reg);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d %d\\n\", scrolls[i].first, scrolls[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int N = opt<int>(\"n\", 10); // Number of scrolls\n    int max_health = opt<int>(\"max\", 100); // Boss max health\n    int reg = opt<int>(\"reg\", 10); // Boss regen per second\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that parameters are within constraints\n    N = max(1, min(N, 1000));\n    max_health = max(1, min(max_health, 1000));\n    reg = max(1, min(reg, 1000));\n\n    vector<pair<int, int>> scrolls(N); // Each scroll as pair of (pow_i, dmg_i)\n\n    if (type == \"random\") {\n        // Generate random scrolls within constraints\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"impossible\") {\n        // Generate scrolls such that boss cannot be defeated\n        // Total possible damage per second is less than or equal to reg\n        int total_dmg = 0;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            scrolls[i].first = pow_i;\n        }\n        // Assign dmg_i to make total_dmg ≤ reg\n        for (int i = 0; i < N; ++i) {\n            int remaining = max(0, reg - total_dmg);\n            int dmg_i = (i == N - 1) ? remaining : rnd.next(0, remaining);\n            scrolls[i].second = dmg_i;\n            total_dmg += dmg_i;\n        }\n    } else if (type == \"possible\") {\n        // Generate scrolls such that boss can be defeated\n        // Total possible damage per second is greater than reg\n        int total_dmg = reg + rnd.next(1, 1000);\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            scrolls[i].first = pow_i;\n        }\n        // Distribute total_dmg among scrolls\n        int remaining_dmg = total_dmg;\n        for (int i = 0; i < N; ++i) {\n            int dmg_i = rnd.next(1, min(2000, remaining_dmg - (N - i - 1)));\n            scrolls[i].second = dmg_i;\n            remaining_dmg -= dmg_i;\n        }\n    } else if (type == \"max_damage\") {\n        // All scrolls have maximum damage\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = 2000;\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"min_damage\") {\n        // All scrolls have minimum damage\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = 1;\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"high_regen\") {\n        // High regeneration rate\n        reg = rnd.next(max_health / 2, max_health);\n        reg = max(1, min(reg, 1000)); // Ensure reg within constraints\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, reg + rnd.next(1, 1000));\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"edge_pow\") {\n        // Edge cases for pow_i\n        for (int i = 0; i < N; ++i) {\n            int pow_i = (i % 2 == 0) ? 0 : 100;\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"large_N\") {\n        // Maximum number of scrolls\n        N = 1000;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"low_health\") {\n        // Boss with minimum health and regen\n        max_health = 1;\n        reg = 1;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = 100;\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else if (type == \"max_health\") {\n        // Boss with maximum health and regen\n        max_health = 1000;\n        reg = 1000;\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < N; ++i) {\n            int pow_i = rnd.next(0, 100);\n            int dmg_i = rnd.next(1, 2000);\n            scrolls[i] = make_pair(pow_i, dmg_i);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", N, max_health, reg);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d %d\\n\", scrolls[i].first, scrolls[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 5 -max 100 -reg 10 -type random\n./gen -n 10 -max 200 -reg 20 -type random\n./gen -n 20 -max 300 -reg 30 -type random\n\n# Large random test cases\n./gen -n 1000 -max 1000 -reg 500 -type random\n\n# Impossible to defeat the boss\n./gen -n 5 -max 100 -reg 200 -type impossible\n./gen -n 10 -max 200 -reg 500 -type impossible\n./gen -n 50 -max 300 -reg 1000 -type impossible\n\n# Possible to defeat the boss\n./gen -n 5 -max 100 -reg 10 -type possible\n./gen -n 10 -max 200 -reg 20 -type possible\n./gen -n 50 -max 300 -reg 30 -type possible\n\n# Test cases with maximum damage\n./gen -n 5 -max 100 -reg 10 -type max_damage\n./gen -n 10 -max 200 -reg 20 -type max_damage\n\n# Test cases with minimum damage\n./gen -n 5 -max 100 -reg 10 -type min_damage\n./gen -n 10 -max 200 -reg 20 -type min_damage\n\n# High regeneration rates\n./gen -n 5 -max 100 -type high_regen\n./gen -n 10 -max 200 -type high_regen\n\n# Edge cases for pow_i\n./gen -n 5 -max 100 -reg 10 -type edge_pow\n./gen -n 10 -max 200 -reg 20 -type edge_pow\n\n# Test cases with the maximum number of scrolls\n./gen -n 1000 -max 500 -reg 100 -type large_N\n./gen -n 1000 -max 1000 -reg 500 -type large_N\n\n# Boss with low health and regen\n./gen -n 5 -type low_health\n./gen -n 10 -type low_health\n\n# Boss with maximum health and regen\n./gen -n 5 -type max_health\n./gen -n 10 -type max_health\n\n# Mixed types\n./gen -n 20 -max 500 -reg 50 -type random\n./gen -n 30 -max 600 -reg 60 -type possible\n./gen -n 40 -max 700 -reg 70 -type impossible\n./gen -n 50 -max 800 -reg 80 -type high_regen\n./gen -n 60 -max 900 -reg 90 -type edge_pow\n./gen -n 70 -max 1000 -reg 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:15:59.529820",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "37/C",
      "title": "C. Old Berland Language",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer N (1 ≤ N ≤ 1000) — the number of words in Old Berland language. The second line contains N space-separated integers — the lengths of these words. All the lengths are natural numbers not exceeding 1000.",
      "output_spec": "OutputIf there’s no such set of words, in the single line output NO. Otherwise, in the first line output YES, and in the next N lines output the words themselves in the order their lengths were given in the input file. If the answer is not unique, output any.",
      "sample_tests": "ExamplesInputCopy31 2 3OutputCopyYES010110InputCopy31 1 1OutputCopyNO",
      "description": "C. Old Berland Language\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains one integer N (1 ≤ N ≤ 1000) — the number of words in Old Berland language. The second line contains N space-separated integers — the lengths of these words. All the lengths are natural numbers not exceeding 1000.\n\nOutputIf there’s no such set of words, in the single line output NO. Otherwise, in the first line output YES, and in the next N lines output the words themselves in the order their lengths were given in the input file. If the answer is not unique, output any.\n\nInputCopy31 2 3OutputCopyYES010110InputCopy31 1 1OutputCopyNO\n\nInputCopy31 2 3\n\nOutputCopyYES010110\n\nInputCopy31 1 1\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces",
          "content": "Good evening!Today I am the author of problems. I'm studying in Nizhny Novgorod State University (2 year, Mechanics and Mathematics). I want to thank the staff codeforces for assistance in preparing the contest, and, personally, Artem Rakhov and Maria Belova (for translations of problems into English). Also special thanks to Alexei Shmelev (NNSU) for writing alternative solutions.P.S. Unfortunately, this round could be in error to register a team. For teams participating in this round will be counted \"out of competition\", ie, rating of participants does not change. If you register a team by mistake, you can unregister and register in person.UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over, congratulate Ivan Popelyshev, who won this round. He was the only one who has successfully solved all five problems.Link to results.UPD: Tutorials are available.Regards,Vladislav Yepifanov.ПрослушатьНа латинице",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/792",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Beta Round #37 (Tutorial) - Codeforces",
          "content": "A. Towers The total number of towers is equal to number of different numbers in this set. To get the maximum height of the tower, it was possible to calculate for each length the number of bars with this length, and from these numbers is to choose the maximum. B. Computer Game Constraints in the problem allows us to solve it this way: we keep the current number of health from the boss, and current summary damage from used scrolls per second. At the next step, we choose which scrolls we can use in the current second. Of all these, we find the scroll, which causes the most damage, and apply it. If at some point we could not use any of the scrolls, and the current damage in one second does not exceed regeneration, we deduce that there are no answers. Otherwise, continue to iterate the algorithm until the number hit points will be nonnegative. C. Old Berland LanguageOne of the easiest to understand solutions of this problem is as follows: sort the words in ascending order of length, while remembering their positions in the source list. We will consistently build our set, starting with the short strings: strings of length one can only be strings \"0\" and \"1\". If the number of words of length one in a set are more than two, hence there are no answers. Add the desired number of strings of length one to answer, and remove it from the current list. Then look at the string of length two: each of the remaining strings of length one can be extended in two ways (having added to each of these symbols 0 and 1). Add the desired number of strings of length two in our answer, and then increase the length of the remaining strings by one. Continue this process, until we get all words from the input set. You can see that if at some moment the number of allowable words exceeded the number of remaining, the extra words can be ignored and solution takes O (N * the maximum length of input set) time. D. Lesson TimetableThis problem is solved by dynamic programming:state of dynamics will be a pair of numbers - the number of current room and number of groups which have first lesson in the room with a number not exceeding the current and for which the second room is not defined yet. For each state check all possible number of groups for which the second lesson will be held in the current classroom. When you add an answer from the new state, it must be multiplied by the corresponding binomial coefficients (the number of ways to select groups which have the first lesson in next room - Xi + 1, and the number of ways to select groups which have the second lesson in the current classroom).  E. Trial for ChiefFirst, we construct the following graph: each cell we associate a vertex of the same color as the cell itself. Between neighboring cells hold an edge of weight 0, if the cells share the same color and weight of 1, if different. Now, for each cell count the shortest distance from it to the most distant black cell (denoted by D). It is easy to see that we can construct a sequence of D + 1 repainting leads to the desired coloring:The first step of color all the cells at a distance less than or equal to D in black colorAt the second step color all the cells at a distance less than or equal to D - 1 in whiteEtc.Of all the cells, choose the one for which this distance is minimal, and this distance increased by one will be the answer to the problem.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/798",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces - Code 1",
          "code": "Test #4:206 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 6 7Possible Answer:YES000000, 0000110, 0000111, 0001000, 0001001, 000001, 00010100001011, 0001100, 0001101, 0001110, 0001111, 0010000, 00100010010010, 0010011, 0010100, 0010101, 000010, 0010110",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/792",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n\n    vector<int> lengths = inf.readInts(N, 1, 1000, \"l_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n\n    vector<int> lengths = inf.readInts(N, 1, 1000, \"l_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n\n    vector<int> lengths = inf.readInts(N, 1, 1000, \"l_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TrieNode {\n    int wordIndex; // 0 if no word ends here\n    unordered_map<char, TrieNode*> children;\n    TrieNode() : wordIndex(0) {}\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int N = inf.readInt();\n    vector<int> lengths(N);\n    for (int i = 0; i < N; ++i) {\n        lengths[i] = inf.readInt();\n    }\n\n    string jury_decision = ans.readToken();\n    if (jury_decision != \"YES\" && jury_decision != \"NO\") {\n        quitf(_fail, \"Jury's answer is neither YES nor NO\");\n    }\n\n    string cont_decision = ouf.readToken();\n\n    if (cont_decision != \"YES\" && cont_decision != \"NO\") {\n        quitf(_wa, \"Contestant's answer is neither YES nor NO\");\n    }\n\n    if (jury_decision == \"NO\") {\n        if (cont_decision != \"NO\") {\n            quitf(_wa, \"Jury's answer is NO, but contestant's answer is YES\");\n        }\n        ouf.skipBlanks();\n        if (!ouf.eof()) {\n            quitf(_wa, \"Contestant's answer has extra output after NO\");\n        }\n        quitf(_ok, \"Correctly answered NO\");\n    } else {\n        if (cont_decision != \"YES\") {\n            quitf(_wa, \"Jury's answer is YES, but contestant's answer is NO\");\n        }\n        vector<string> words(N);\n        for (int i = 0; i < N; ++i) {\n            if (ouf.eof()) {\n                quitf(_wa, \"Expected %d words, but found only %d\", N, i);\n            }\n            words[i] = ouf.readToken();\n            if ((int)words[i].length() != lengths[i]) {\n                quitf(_wa, \"The length of word %d is incorrect (expected %d, found %d)\", i+1, lengths[i], (int)words[i].length());\n            }\n            for (char c : words[i]) {\n                if (c != '0' && c != '1') {\n                    quitf(_wa, \"Invalid character '%c' in word %d\", c, i+1);\n                }\n            }\n        }\n        ouf.skipBlanks();\n        if (!ouf.eof()) {\n            quitf(_wa, \"Contestant's output has extra data\");\n        }\n        // Now check for prefixes\n        TrieNode* root = new TrieNode();\n        for (int i = 0; i < N; ++i) {\n            TrieNode* node = root;\n            for (char c : words[i]) {\n                // If a word ends at current node, it is a prefix of current word\n                if (node->wordIndex != 0) {\n                    quitf(_wa, \"Word %d is a prefix of word %d\", node->wordIndex, i+1);\n                }\n                if (node->children.find(c) == node->children.end()) {\n                    node->children[c] = new TrieNode();\n                }\n                node = node->children[c];\n            }\n            if (node->wordIndex != 0) {\n                // Duplicate word\n                quitf(_wa, \"Duplicate word %d and word %d\", node->wordIndex, i+1);\n            }\n            if (!node->children.empty()) {\n                // Current word is a prefix of another word\n                quitf(_wa, \"Word %d is a prefix of another word\", i+1);\n            }\n            node->wordIndex = i+1; // Store word index (1-based)\n        }\n        // All checks passed\n        quitf(_ok, \"Valid words provided\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxL = opt<int>(\"maxL\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> li;\n    if (type == \"possible\") {\n        // Generate possible test case\n        vector<int> cnt(maxL+1, 0);\n        double sum = 0.0;\n        int total_words = 0;\n        for (int l = 1; l <= maxL; ++l) {\n            if (total_words >= n) break;\n            int cnt_l = 1;\n\n            if (l <= 20) {\n                double term = cnt_l * 1.0 / (1LL << l);\n                if (sum + term <= 1.0 + 1e-9) { // small epsilon to handle floating point errors\n                    sum += term;\n                    cnt[l] = cnt_l;\n                    total_words += cnt_l;\n                } else {\n                    continue;\n                }\n            } else {\n                cnt_l = min(n - total_words, 1000);\n                cnt[l] = cnt_l;\n                total_words += cnt_l;\n            }\n        }\n        // If total_words < n, distribute remaining words over l > 20\n        int l = 21;\n        while (total_words < n && l <= maxL) {\n            cnt[l] = min(n - total_words, 1000);\n            total_words += cnt[l];\n            ++l;\n        }\n        // Now collect lengths li\n        for (int l = 1; l <= maxL; ++l) {\n            for (int i = 0; i < cnt[l]; ++i) {\n                li.push_back(l);\n            }\n        }\n        shuffle(li.begin(), li.end()); // Shuffle the lengths\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        vector<int> cnt(maxL+1, 0);\n        double sum = 0.0;\n        int total_words = 0;\n        cnt[1] = 3; // Set cnt[1] > 2 to make it impossible\n        sum += cnt[1] * 1.0 / (1LL << 1); // 1/2 * cnt[1]\n        total_words += cnt[1];\n\n        // sum > 1 now\n        // Add more words if needed\n        int l = 2;\n        while (total_words < n && l <= maxL) {\n            cnt[l] = min(n - total_words, 1000);\n            total_words += cnt[l];\n            ++l;\n        }\n\n        // Now collect lengths li\n        for (int l = 1; l <= maxL; ++l) {\n            for (int i = 0; i < cnt[l]; ++i) {\n                li.push_back(l);\n            }\n        }\n        shuffle(li.begin(), li.end()); // Shuffle the lengths\n    } else {\n        // Generate random test cases\n        li.resize(n);\n        for(int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, maxL);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", li[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxL = opt<int>(\"maxL\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> li;\n    if (type == \"possible\") {\n        // Generate possible test case\n        vector<int> cnt(maxL+1, 0);\n        double sum = 0.0;\n        int total_words = 0;\n        for (int l = 1; l <= maxL; ++l) {\n            if (total_words >= n) break;\n            int cnt_l = 1;\n\n            if (l <= 20) {\n                double term = cnt_l * 1.0 / (1LL << l);\n                if (sum + term <= 1.0 + 1e-9) { // small epsilon to handle floating point errors\n                    sum += term;\n                    cnt[l] = cnt_l;\n                    total_words += cnt_l;\n                } else {\n                    continue;\n                }\n            } else {\n                cnt_l = min(n - total_words, 1000);\n                cnt[l] = cnt_l;\n                total_words += cnt_l;\n            }\n        }\n        // If total_words < n, distribute remaining words over l > 20\n        int l = 21;\n        while (total_words < n && l <= maxL) {\n            cnt[l] = min(n - total_words, 1000);\n            total_words += cnt[l];\n            ++l;\n        }\n        // Now collect lengths li\n        for (int l = 1; l <= maxL; ++l) {\n            for (int i = 0; i < cnt[l]; ++i) {\n                li.push_back(l);\n            }\n        }\n        shuffle(li.begin(), li.end()); // Shuffle the lengths\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        vector<int> cnt(maxL+1, 0);\n        double sum = 0.0;\n        int total_words = 0;\n        cnt[1] = 3; // Set cnt[1] > 2 to make it impossible\n        sum += cnt[1] * 1.0 / (1LL << 1); // 1/2 * cnt[1]\n        total_words += cnt[1];\n\n        // sum > 1 now\n        // Add more words if needed\n        int l = 2;\n        while (total_words < n && l <= maxL) {\n            cnt[l] = min(n - total_words, 1000);\n            total_words += cnt[l];\n            ++l;\n        }\n\n        // Now collect lengths li\n        for (int l = 1; l <= maxL; ++l) {\n            for (int i = 0; i < cnt[l]; ++i) {\n                li.push_back(l);\n            }\n        }\n        shuffle(li.begin(), li.end()); // Shuffle the lengths\n    } else {\n        // Generate random test cases\n        li.resize(n);\n        for(int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, maxL);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", li[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -maxL 3 -type impossible\n./gen -n 3 -maxL 3 -type possible\n\n./gen -n 100 -maxL 10 -type possible\n./gen -n 100 -maxL 10 -type impossible\n\n./gen -n 1000 -maxL 20 -type possible\n\n./gen -n 1000 -maxL 20 -type impossible\n\n./gen -n 1000 -maxL 1000 -type possible\n\n./gen -n 500 -maxL 1000 -type possible\n\n./gen -n 500 -maxL 1000 -type impossible\n\n./gen -n 1000 -type random\n\n./gen -n 1 -maxL 1 -type possible\n./gen -n 2 -maxL 1 -type possible\n./gen -n 3 -maxL 1 -type impossible\n\n# Edge case: All lengths are 1\n./gen -n 100 -maxL 1 -type random\n\n# Edge case: All lengths are maxL\n./gen -n 1000 -maxL 1000 -type random\n\n# Edge case: Mixture of small and large lengths\n./gen -n 1000 -type random\n\n# Edge case: n = 1\n./gen -n 1 -type possible\n\n# Edge case: n = 1000\n./gen -n 1000 -type possible\n\n# Test case with n = 999\n./gen -n 999 -type possible\n\n# Test case with n = 2\n./gen -n 2 -type possible\n\n# Impossible case with n = 3 and small lengths\n./gen -n 3 -maxL 1 -type impossible\n\n# Edge case: n = 1000, impossible case\n./gen -n 1000 -maxL 1 -type impossible\n\n# Edge case: n = 1000, possible case with small lengths\n./gen -n 1000 -maxL 20 -type possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:01.859054",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "37/D",
      "title": "D. Lesson Timetable",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer M (1 ≤ M ≤ 100) — the number of classrooms.The second line contains M space-separated integers — Xi (0 ≤ Xi ≤ 100) the amount of groups present in classroom i during the first lesson.The third line contains M space-separated integers — Yi (0 ≤ Yi ≤ 100) the maximal amount of groups that can be present in classroom i at the same time.It is guaranteed that all the Xi ≤ Yi, and that the sum of all the Xi is positive and does not exceed 1000.",
      "output_spec": "OutputIn the single line output the answer to the problem modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy31 1 11 2 3OutputCopy36InputCopy31 1 11 1 1OutputCopy6",
      "description": "D. Lesson Timetable\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains one integer M (1 ≤ M ≤ 100) — the number of classrooms.The second line contains M space-separated integers — Xi (0 ≤ Xi ≤ 100) the amount of groups present in classroom i during the first lesson.The third line contains M space-separated integers — Yi (0 ≤ Yi ≤ 100) the maximal amount of groups that can be present in classroom i at the same time.It is guaranteed that all the Xi ≤ Yi, and that the sum of all the Xi is positive and does not exceed 1000.\n\nOutputIn the single line output the answer to the problem modulo 109 + 7.\n\nInputCopy31 1 11 2 3OutputCopy36InputCopy31 1 11 1 1OutputCopy6\n\nInputCopy31 1 11 2 3\n\nOutputCopy36\n\nInputCopy31 1 11 1 1\n\nOutputCopy6\n\nNoteIn the second sample test the first and the second lessons of each group must take place in the same classroom, that’s why the timetables will only be different in the rearrangement of the classrooms’ numbers for each group, e.g. 3! = 6.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces",
          "content": "Good evening!Today I am the author of problems. I'm studying in Nizhny Novgorod State University (2 year, Mechanics and Mathematics). I want to thank the staff codeforces for assistance in preparing the contest, and, personally, Artem Rakhov and Maria Belova (for translations of problems into English). Also special thanks to Alexei Shmelev (NNSU) for writing alternative solutions.P.S. Unfortunately, this round could be in error to register a team. For teams participating in this round will be counted \"out of competition\", ie, rating of participants does not change. If you register a team by mistake, you can unregister and register in person.UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over, congratulate Ivan Popelyshev, who won this round. He was the only one who has successfully solved all five problems.Link to results.UPD: Tutorials are available.Regards,Vladislav Yepifanov.ПрослушатьНа латинице",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/792",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Beta Round #37 (Tutorial) - Codeforces",
          "content": "A. Towers The total number of towers is equal to number of different numbers in this set. To get the maximum height of the tower, it was possible to calculate for each length the number of bars with this length, and from these numbers is to choose the maximum. B. Computer Game Constraints in the problem allows us to solve it this way: we keep the current number of health from the boss, and current summary damage from used scrolls per second. At the next step, we choose which scrolls we can use in the current second. Of all these, we find the scroll, which causes the most damage, and apply it. If at some point we could not use any of the scrolls, and the current damage in one second does not exceed regeneration, we deduce that there are no answers. Otherwise, continue to iterate the algorithm until the number hit points will be nonnegative. C. Old Berland LanguageOne of the easiest to understand solutions of this problem is as follows: sort the words in ascending order of length, while remembering their positions in the source list. We will consistently build our set, starting with the short strings: strings of length one can only be strings \"0\" and \"1\". If the number of words of length one in a set are more than two, hence there are no answers. Add the desired number of strings of length one to answer, and remove it from the current list. Then look at the string of length two: each of the remaining strings of length one can be extended in two ways (having added to each of these symbols 0 and 1). Add the desired number of strings of length two in our answer, and then increase the length of the remaining strings by one. Continue this process, until we get all words from the input set. You can see that if at some moment the number of allowable words exceeded the number of remaining, the extra words can be ignored and solution takes O (N * the maximum length of input set) time. D. Lesson TimetableThis problem is solved by dynamic programming:state of dynamics will be a pair of numbers - the number of current room and number of groups which have first lesson in the room with a number not exceeding the current and for which the second room is not defined yet. For each state check all possible number of groups for which the second lesson will be held in the current classroom. When you add an answer from the new state, it must be multiplied by the corresponding binomial coefficients (the number of ways to select groups which have the first lesson in next room - Xi + 1, and the number of ways to select groups which have the second lesson in the current classroom).  E. Trial for ChiefFirst, we construct the following graph: each cell we associate a vertex of the same color as the cell itself. Between neighboring cells hold an edge of weight 0, if the cells share the same color and weight of 1, if different. Now, for each cell count the shortest distance from it to the most distant black cell (denoted by D). It is easy to see that we can construct a sequence of D + 1 repainting leads to the desired coloring:The first step of color all the cells at a distance less than or equal to D in black colorAt the second step color all the cells at a distance less than or equal to D - 1 in whiteEtc.Of all the cells, choose the one for which this distance is minimal, and this distance increased by one will be the answer to the problem.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/798",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces - Code 1",
          "code": "Test #4:206 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 6 7Possible Answer:YES000000, 0000110, 0000111, 0001000, 0001001, 000001, 00010100001011, 0001100, 0001101, 0001110, 0001111, 0010000, 00100010010010, 0010011, 0010100, 0010101, 000010, 0010110",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/792",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int M = inf.readInt(1, 100, \"M\");\n    inf.readEoln();\n\n    vector<int> Xi = inf.readInts(M, 0, 100, \"Xi\");\n    inf.readEoln();\n\n    vector<int> Yi = inf.readInts(M, 0, 100, \"Yi\");\n    inf.readEoln();\n\n    int sumXi = 0;\n    for (int i = 0; i < M; i++) {\n        ensuref(Xi[i] <= Yi[i], \"Xi[%d]=%d should not exceed Yi[%d]=%d\", i+1, Xi[i], i+1, Yi[i]);\n        sumXi += Xi[i];\n    }\n    ensuref(sumXi >= 1, \"Sum of Xi should be positive, but it is %d\", sumXi);\n    ensuref(sumXi <= 1000, \"Sum of Xi should not exceed 1000, but it is %d\", sumXi);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int M = inf.readInt(1, 100, \"M\");\n    inf.readEoln();\n\n    vector<int> Xi = inf.readInts(M, 0, 100, \"Xi\");\n    inf.readEoln();\n\n    vector<int> Yi = inf.readInts(M, 0, 100, \"Yi\");\n    inf.readEoln();\n\n    int sumXi = 0;\n    for (int i = 0; i < M; i++) {\n        ensuref(Xi[i] <= Yi[i], \"Xi[%d]=%d should not exceed Yi[%d]=%d\", i+1, Xi[i], i+1, Yi[i]);\n        sumXi += Xi[i];\n    }\n    ensuref(sumXi >= 1, \"Sum of Xi should be positive, but it is %d\", sumXi);\n    ensuref(sumXi <= 1000, \"Sum of Xi should not exceed 1000, but it is %d\", sumXi);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int M = inf.readInt(1, 100, \"M\");\n    inf.readEoln();\n\n    vector<int> Xi = inf.readInts(M, 0, 100, \"Xi\");\n    inf.readEoln();\n\n    vector<int> Yi = inf.readInts(M, 0, 100, \"Yi\");\n    inf.readEoln();\n\n    int sumXi = 0;\n    for (int i = 0; i < M; i++) {\n        ensuref(Xi[i] <= Yi[i], \"Xi[%d]=%d should not exceed Yi[%d]=%d\", i+1, Xi[i], i+1, Yi[i]);\n        sumXi += Xi[i];\n    }\n    ensuref(sumXi >= 1, \"Sum of Xi should be positive, but it is %d\", sumXi);\n    ensuref(sumXi <= 1000, \"Sum of Xi should not exceed 1000, but it is %d\", sumXi);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int M = opt<int>(\"M\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxXiYi = opt<int>(\"maxXiYi\", 100); // maximum value for Xi and Yi, default to 100\n\n    vector<int> Xi(M);\n    vector<int> Yi(M);\n\n    int sumXi = 0;\n\n    if (type == \"max_xi\") {\n        // Set all Xi to maximum allowed under constraints\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = maxXiYi;\n            Yi[i] = maxXiYi;\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_zero\") {\n        // Some Xi are zero\n        for (int i = 0; i < M; ++i) {\n            bool zero = rnd.next(0,1);\n            if (zero) Xi[i] = 0;\n            else Xi[i] = rnd.next(1, maxXiYi);\n            Yi[i] = rnd.next(Xi[i], maxXiYi);\n            sumXi += Xi[i];\n        }\n    } else if (type == \"yi_zero\") {\n        // Some Yi are zero\n        // Since Xi ≤ Yi, this means Xi = Yi = 0 for those i.\n        for (int i = 0; i < M; ++i) {\n            bool zero = rnd.next(0,1);\n            if (zero) {\n                Xi[i] = 0;\n                Yi[i] = 0;\n            } else {\n                Xi[i] = rnd.next(1, maxXiYi);\n                Yi[i] = Xi[i] + rnd.next(0, maxXiYi - Xi[i]);\n            }\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_equals_yi\") {\n        // Xi = Yi\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = rnd.next(0, maxXiYi);\n            Yi[i] = Xi[i];\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_less_than_yi\") {\n        // Xi < Yi\n        for (int i = 0;  i < M; ++i) {\n            Xi[i] = rnd.next(0, maxXiYi - 1);\n            Yi[i] = Xi[i] + rnd.next(1, maxXiYi - Xi[i]);\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_equals_zero_yi_nonzero\") {\n        // Xi = 0, Yi > 0\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = 0;\n            Yi[i] = rnd.next(1, maxXiYi);\n        }\n        int idx = rnd.next(0, M-1);\n        Xi[idx] = 1;\n        Yi[idx] = max(Yi[idx], 1);\n        sumXi += 1;\n    } else if (type == \"large_N_small_M\") {\n        // N large, M small\n        M = min(M, 10);\n        Xi.resize(M);\n        Yi.resize(M);\n        int N_remain = 1000;\n        for (int i = 0; i < M -1; ++i) {\n            Xi[i] = rnd.next(0, min(N_remain, maxXiYi));\n            Yi[i] = Xi[i] + rnd.next(0, maxXiYi - Xi[i]);\n            N_remain -= Xi[i];\n            sumXi += Xi[i];\n        }\n        Xi[M -1] = min(N_remain, maxXiYi);\n        Yi[M -1] = Xi[M -1] + rnd.next(0, maxXiYi - Xi[M -1]);\n        sumXi += Xi[M -1];\n        if (sumXi == 0) {\n            Xi[0] = 1;\n            Yi[0] = max(Yi[0], Xi[0]);\n            sumXi = 1;\n        }\n    } else if (type == \"small_N_large_M\") {\n        // N small, M large\n        M = max(M, 50);\n        Xi.resize(M);\n        Yi.resize(M);\n        int N_remain = rnd.next(1, 10);\n        sumXi = N_remain;\n        for (int i = 0; i < M; ++i) {\n            if (N_remain > 0) {\n                Xi[i] = rnd.next(0, min(N_remain, maxXiYi));\n                Yi[i] = Xi[i] + rnd.next(0, maxXiYi - Xi[i]);\n                N_remain -= Xi[i];\n            } else {\n                Xi[i] = 0;\n                Yi[i] = rnd.next(Xi[i], maxXiYi);\n            }\n        }\n    } else if (type == \"max_limits\") {\n        // Set M = 100, Xi and Yi to maximum within constraints\n        M = 100;\n        Xi.resize(M, 100);\n        Yi.resize(M, 100);\n        sumXi = M * 100;\n    } else {\n        // Default: random values within constraints\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = rnd.next(0, maxXiYi);\n            Yi[i] = rnd.next(Xi[i], maxXiYi);\n            sumXi += Xi[i];\n        }\n    }\n\n    // Ensure sumXi <= 1000 and sumXi > 0, and that all Xi ≤ Yi\n\n    if (sumXi > 1000) {\n        // Need to scale down Xi proportionally\n        double factor = 1000.0 / sumXi;\n        sumXi = 0;\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = int(Xi[i] * factor);\n            Yi[i] = max(Xi[i], Yi[i]);\n            sumXi += Xi[i];\n        }\n        // Adjust to ensure sumXi > 0\n        if (sumXi == 0) {\n            Xi[0] = 1;\n            Yi[0] = max(Yi[0], Xi[0]);\n            sumXi = 1;\n        }\n    }\n\n    // Output M\n    cout << M << endl;\n\n    // Output Xi\n    for (int i = 0; i < M; ++i) {\n        if (i > 0) cout << \" \";\n        cout << Xi[i];\n    }\n    cout << endl;\n\n    // Output Yi\n    for (int i = 0; i < M; ++i) {\n        if (i > 0) cout << \" \";\n        cout << Yi[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int M = opt<int>(\"M\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxXiYi = opt<int>(\"maxXiYi\", 100); // maximum value for Xi and Yi, default to 100\n\n    vector<int> Xi(M);\n    vector<int> Yi(M);\n\n    int sumXi = 0;\n\n    if (type == \"max_xi\") {\n        // Set all Xi to maximum allowed under constraints\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = maxXiYi;\n            Yi[i] = maxXiYi;\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_zero\") {\n        // Some Xi are zero\n        for (int i = 0; i < M; ++i) {\n            bool zero = rnd.next(0,1);\n            if (zero) Xi[i] = 0;\n            else Xi[i] = rnd.next(1, maxXiYi);\n            Yi[i] = rnd.next(Xi[i], maxXiYi);\n            sumXi += Xi[i];\n        }\n    } else if (type == \"yi_zero\") {\n        // Some Yi are zero\n        // Since Xi ≤ Yi, this means Xi = Yi = 0 for those i.\n        for (int i = 0; i < M; ++i) {\n            bool zero = rnd.next(0,1);\n            if (zero) {\n                Xi[i] = 0;\n                Yi[i] = 0;\n            } else {\n                Xi[i] = rnd.next(1, maxXiYi);\n                Yi[i] = Xi[i] + rnd.next(0, maxXiYi - Xi[i]);\n            }\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_equals_yi\") {\n        // Xi = Yi\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = rnd.next(0, maxXiYi);\n            Yi[i] = Xi[i];\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_less_than_yi\") {\n        // Xi < Yi\n        for (int i = 0;  i < M; ++i) {\n            Xi[i] = rnd.next(0, maxXiYi - 1);\n            Yi[i] = Xi[i] + rnd.next(1, maxXiYi - Xi[i]);\n            sumXi += Xi[i];\n        }\n    } else if (type == \"xi_equals_zero_yi_nonzero\") {\n        // Xi = 0, Yi > 0\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = 0;\n            Yi[i] = rnd.next(1, maxXiYi);\n        }\n        int idx = rnd.next(0, M-1);\n        Xi[idx] = 1;\n        Yi[idx] = max(Yi[idx], 1);\n        sumXi += 1;\n    } else if (type == \"large_N_small_M\") {\n        // N large, M small\n        M = min(M, 10);\n        Xi.resize(M);\n        Yi.resize(M);\n        int N_remain = 1000;\n        for (int i = 0; i < M -1; ++i) {\n            Xi[i] = rnd.next(0, min(N_remain, maxXiYi));\n            Yi[i] = Xi[i] + rnd.next(0, maxXiYi - Xi[i]);\n            N_remain -= Xi[i];\n            sumXi += Xi[i];\n        }\n        Xi[M -1] = min(N_remain, maxXiYi);\n        Yi[M -1] = Xi[M -1] + rnd.next(0, maxXiYi - Xi[M -1]);\n        sumXi += Xi[M -1];\n        if (sumXi == 0) {\n            Xi[0] = 1;\n            Yi[0] = max(Yi[0], Xi[0]);\n            sumXi = 1;\n        }\n    } else if (type == \"small_N_large_M\") {\n        // N small, M large\n        M = max(M, 50);\n        Xi.resize(M);\n        Yi.resize(M);\n        int N_remain = rnd.next(1, 10);\n        sumXi = N_remain;\n        for (int i = 0; i < M; ++i) {\n            if (N_remain > 0) {\n                Xi[i] = rnd.next(0, min(N_remain, maxXiYi));\n                Yi[i] = Xi[i] + rnd.next(0, maxXiYi - Xi[i]);\n                N_remain -= Xi[i];\n            } else {\n                Xi[i] = 0;\n                Yi[i] = rnd.next(Xi[i], maxXiYi);\n            }\n        }\n    } else if (type == \"max_limits\") {\n        // Set M = 100, Xi and Yi to maximum within constraints\n        M = 100;\n        Xi.resize(M, 100);\n        Yi.resize(M, 100);\n        sumXi = M * 100;\n    } else {\n        // Default: random values within constraints\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = rnd.next(0, maxXiYi);\n            Yi[i] = rnd.next(Xi[i], maxXiYi);\n            sumXi += Xi[i];\n        }\n    }\n\n    // Ensure sumXi <= 1000 and sumXi > 0, and that all Xi ≤ Yi\n\n    if (sumXi > 1000) {\n        // Need to scale down Xi proportionally\n        double factor = 1000.0 / sumXi;\n        sumXi = 0;\n        for (int i = 0; i < M; ++i) {\n            Xi[i] = int(Xi[i] * factor);\n            Yi[i] = max(Xi[i], Yi[i]);\n            sumXi += Xi[i];\n        }\n        // Adjust to ensure sumXi > 0\n        if (sumXi == 0) {\n            Xi[0] = 1;\n            Yi[0] = max(Yi[0], Xi[0]);\n            sumXi = 1;\n        }\n    }\n\n    // Output M\n    cout << M << endl;\n\n    // Output Xi\n    for (int i = 0; i < M; ++i) {\n        if (i > 0) cout << \" \";\n        cout << Xi[i];\n    }\n    cout << endl;\n\n    // Output Yi\n    for (int i = 0; i < M; ++i) {\n        if (i > 0) cout << \" \";\n        cout << Yi[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -M 1 -type xi_equals_yi\n./gen -M 1 -type xi_zero\n./gen -M 2 -type xi_zero\n./gen -M 1 -type xi_equals_zero_yi_nonzero\n./gen -M 100 -type xi_equals_zero_yi_nonzero\n\n./gen -M 100 -type max_xi\n./gen -M 100 -type xi_equals_yi\n./gen -M 100 -type xi_less_than_yi\n\n./gen -M 100 -type large_N_small_M\n./gen -M 100 -type small_N_large_M\n\n./gen -M 1 -type max_limits\n./gen -M 50 -type max_limits\n./gen -M 100 -type max_limits\n\n./gen -M 50 -type random\n./gen -M 100 -type random\n\n./gen -M 10 -type xi_zero\n./gen -M 10 -type yi_zero\n\n# Edge cases\n\n# All Xi = 0 except one\n./gen -M 100 -type xi_zero\n\n# Xi = Yi = 0 in some cases\n./gen -M 100 -type yi_zero\n\n# Special case: sumXi = 1\n./gen -M 100 -type small_N_large_M\n\n# Another special case: sumXi = 1000\n./gen -M 100 -type max_xi\n\n./gen -M 5 -type xi_less_than_yi\n\n./gen -M 5 -type small_N_large_M\n\n# Random but ensure sumXi near upper limit\n./gen -M 50 -type random -maxXiYi 20\n\n./gen -M 5 -type xi_equals_zero_yi_nonzero\n\n./gen -M 10 -type xi_zero\n\n./gen -M 10 -type yi_zero\n\n# Mix types\n./gen -M 10 -type xi_equals_yi\n./gen -M 10 -type xi_less_than_yi\n\n./gen -M 100 -type large_N_small_M\n\n./gen -M 50 -type small_N_large_M\n\n# Mix random with different maxXiYi\n./gen -M 50 -type random -maxXiYi 50\n./gen -M 50 -type random -maxXiYi 100\n\n# Random with default parameters\n./gen -M 10\n./gen -M 50\n./gen -M 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:04.218714",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "37/E",
      "title": "E. Trial for Chief",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers N and M (1 ≤ N, M ≤ 50) — the number of lines and columns on the slab. The next N lines contain M symbols each — the final coloration of the slab. W stands for the square that should be painted white and B — for the square that should be painted black.",
      "output_spec": "OutputIn the single line output the minimal number of repaintings of side-linked areas needed to get the required coloration of the slab.",
      "sample_tests": "ExamplesInputCopy3 3WBWBWBWBWOutputCopy2InputCopy2 3BBBBWBOutputCopy1",
      "description": "E. Trial for Chief\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers N and M (1 ≤ N, M ≤ 50) — the number of lines and columns on the slab. The next N lines contain M symbols each — the final coloration of the slab. W stands for the square that should be painted white and B — for the square that should be painted black.\n\nOutputIn the single line output the minimal number of repaintings of side-linked areas needed to get the required coloration of the slab.\n\nInputCopy3 3WBWBWBWBWOutputCopy2InputCopy2 3BBBBWBOutputCopy1\n\nInputCopy3 3WBWBWBWBW\n\nOutputCopy2\n\nInputCopy2 3BBBBWB\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces",
          "content": "Good evening!Today I am the author of problems. I'm studying in Nizhny Novgorod State University (2 year, Mechanics and Mathematics). I want to thank the staff codeforces for assistance in preparing the contest, and, personally, Artem Rakhov and Maria Belova (for translations of problems into English). Also special thanks to Alexei Shmelev (NNSU) for writing alternative solutions.P.S. Unfortunately, this round could be in error to register a team. For teams participating in this round will be counted \"out of competition\", ie, rating of participants does not change. If you register a team by mistake, you can unregister and register in person.UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over, congratulate Ivan Popelyshev, who won this round. He was the only one who has successfully solved all five problems.Link to results.UPD: Tutorials are available.Regards,Vladislav Yepifanov.ПрослушатьНа латинице",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/792",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Beta Round #37 (Tutorial) - Codeforces",
          "content": "A. Towers The total number of towers is equal to number of different numbers in this set. To get the maximum height of the tower, it was possible to calculate for each length the number of bars with this length, and from these numbers is to choose the maximum. B. Computer Game Constraints in the problem allows us to solve it this way: we keep the current number of health from the boss, and current summary damage from used scrolls per second. At the next step, we choose which scrolls we can use in the current second. Of all these, we find the scroll, which causes the most damage, and apply it. If at some point we could not use any of the scrolls, and the current damage in one second does not exceed regeneration, we deduce that there are no answers. Otherwise, continue to iterate the algorithm until the number hit points will be nonnegative. C. Old Berland LanguageOne of the easiest to understand solutions of this problem is as follows: sort the words in ascending order of length, while remembering their positions in the source list. We will consistently build our set, starting with the short strings: strings of length one can only be strings \"0\" and \"1\". If the number of words of length one in a set are more than two, hence there are no answers. Add the desired number of strings of length one to answer, and remove it from the current list. Then look at the string of length two: each of the remaining strings of length one can be extended in two ways (having added to each of these symbols 0 and 1). Add the desired number of strings of length two in our answer, and then increase the length of the remaining strings by one. Continue this process, until we get all words from the input set. You can see that if at some moment the number of allowable words exceeded the number of remaining, the extra words can be ignored and solution takes O (N * the maximum length of input set) time. D. Lesson TimetableThis problem is solved by dynamic programming:state of dynamics will be a pair of numbers - the number of current room and number of groups which have first lesson in the room with a number not exceeding the current and for which the second room is not defined yet. For each state check all possible number of groups for which the second lesson will be held in the current classroom. When you add an answer from the new state, it must be multiplied by the corresponding binomial coefficients (the number of ways to select groups which have the first lesson in next room - Xi + 1, and the number of ways to select groups which have the second lesson in the current classroom).  E. Trial for ChiefFirst, we construct the following graph: each cell we associate a vertex of the same color as the cell itself. Between neighboring cells hold an edge of weight 0, if the cells share the same color and weight of 1, if different. Now, for each cell count the shortest distance from it to the most distant black cell (denoted by D). It is easy to see that we can construct a sequence of D + 1 repainting leads to the desired coloring:The first step of color all the cells at a distance less than or equal to D in black colorAt the second step color all the cells at a distance less than or equal to D - 1 in whiteEtc.Of all the cells, choose the one for which this distance is minimal, and this distance increased by one will be the answer to the problem.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/798",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #37 - Codeforces - Code 1",
          "code": "Test #4:206 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 6 7Possible Answer:YES000000, 0000110, 0000111, 0001000, 0001001, 000001, 00010100001011, 0001100, 0001101, 0001110, 0001111, 0010000, 00100010010010, 0010011, 0010100, 0010101, 000010, 0010110",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/792",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 50, \"M\");\n    inf.readEoln();\n\n    char pattern_c[100];\n    sprintf(pattern_c, \"[BW]{%d}\", M);\n    string pattern(pattern_c);\n\n    for(int i = 0; i < N; ++i) {\n        string line = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 50, \"M\");\n    inf.readEoln();\n\n    char pattern_c[100];\n    sprintf(pattern_c, \"[BW]{%d}\", M);\n    string pattern(pattern_c);\n\n    for(int i = 0; i < N; ++i) {\n        string line = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 50, \"M\");\n    inf.readEoln();\n\n    char pattern_c[100];\n    sprintf(pattern_c, \"[BW]{%d}\", M);\n    string pattern(pattern_c);\n\n    for(int i = 0; i < N; ++i) {\n        string line = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <cstdio>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(1 <= n && n <= 50, \"n must be between 1 and 50\");\n    ensuref(1 <= m && m <= 50, \"m must be between 1 and 50\");\n\n    vector<string> grid(n, string(m, 'W'));\n\n    if (type == \"all_white\") {\n        // grid already initialized to 'W'\n    } else if (type == \"all_black\") {\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(m, 'B');\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = ((i + j) % 2 == 0) ? 'B' : 'W';\n            }\n        }\n    } else if (type == \"stripes_horizontal\") {\n        for (int i = 0; i < n; i++) {\n            char c = (i % 2 == 0) ? 'B' : 'W';\n            grid[i] = string(m, c);\n        }\n    } else if (type == \"stripes_vertical\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (j % 2 == 0) ? 'B' : 'W';\n            }\n        }\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (i == j) ? 'B' : 'W';\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = rnd.next(0, 1) ? 'B' : 'W';\n            }\n        }\n    } else {\n        quitf(_fail, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output N and M\n    printf(\"%d %d\\n\", n, m);\n\n    // Output grid rows\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <cstdio>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(1 <= n && n <= 50, \"n must be between 1 and 50\");\n    ensuref(1 <= m && m <= 50, \"m must be between 1 and 50\");\n\n    vector<string> grid(n, string(m, 'W'));\n\n    if (type == \"all_white\") {\n        // grid already initialized to 'W'\n    } else if (type == \"all_black\") {\n        for (int i = 0; i < n; i++) {\n            grid[i] = string(m, 'B');\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = ((i + j) % 2 == 0) ? 'B' : 'W';\n            }\n        }\n    } else if (type == \"stripes_horizontal\") {\n        for (int i = 0; i < n; i++) {\n            char c = (i % 2 == 0) ? 'B' : 'W';\n            grid[i] = string(m, c);\n        }\n    } else if (type == \"stripes_vertical\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (j % 2 == 0) ? 'B' : 'W';\n            }\n        }\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = (i == j) ? 'B' : 'W';\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = rnd.next(0, 1) ? 'B' : 'W';\n            }\n        }\n    } else {\n        quitf(_fail, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output N and M\n    printf(\"%d %d\\n\", n, m);\n\n    // Output grid rows\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_white\n./gen -n 1 -m 1 -type all_black\n\n./gen -n 1 -m 50 -type random\n./gen -n 50 -m 1 -type random\n\n./gen -n 2 -m 2 -type checkerboard\n./gen -n 2 -m 2 -type stripes_horizontal\n./gen -n 2 -m 2 -type stripes_vertical\n\n./gen -n 3 -m 3 -type checkerboard\n./gen -n 3 -m 3 -type diagonal\n./gen -n 3 -m 3 -type random\n\n./gen -n 10 -m 10 -type random\n\n./gen -n 25 -m 25 -type all_white\n./gen -n 25 -m 25 -type all_black\n./gen -n 25 -m 25 -type stripes_horizontal\n./gen -n 25 -m 25 -type stripes_vertical\n./gen -n 25 -m 25 -type checkerboard\n./gen -n 25 -m 25 -type diagonal\n./gen -n 25 -m 25 -type random\n\n./gen -n 50 -m 50 -type all_white\n./gen -n 50 -m 50 -type all_black\n\n./gen -n 50 -m 50 -type stripes_horizontal\n./gen -n 50 -m 50 -type stripes_vertical\n\n./gen -n 50 -m 50 -type checkerboard\n./gen -n 50 -m 50 -type random\n\n./gen -n 45 -m 45 -type random\n./gen -n 50 -m 50 -type diagonal\n\n./gen -n 30 -m 20 -type random\n./gen -n 20 -m 30 -type random\n\n./gen -n 50 -m 2 -type stripes_vertical\n./gen -n 2 -m 50 -type stripes_horizontal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:06.047739",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "370/A",
      "title": "A. Rook, Bishop and King",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains four integers r1, c1, r2, c2 (1 ≤ r1, c1, r2, c2 ≤ 8) — the coordinates of the starting and the final field. The starting field doesn't coincide with the final one.You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.",
      "output_spec": "OutputPrint three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (r1, c1) to field (r2, c2). If a piece cannot make such a move, print a 0 instead of the corresponding number.",
      "sample_tests": "ExamplesInputCopy4 3 1 6OutputCopy2 1 3InputCopy5 5 5 6OutputCopy1 0 1",
      "description": "A. Rook, Bishop and King\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains four integers r1, c1, r2, c2 (1 ≤ r1, c1, r2, c2 ≤ 8) — the coordinates of the starting and the final field. The starting field doesn't coincide with the final one.You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.\n\nOutputPrint three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (r1, c1) to field (r2, c2). If a piece cannot make such a move, print a 0 instead of the corresponding number.\n\nInputCopy4 3 1 6OutputCopy2 1 3InputCopy5 5 5 6OutputCopy1 0 1\n\nInputCopy4 3 1 6\n\nOutputCopy2 1 3\n\nInputCopy5 5 5 6\n\nOutputCopy1 0 1",
      "solutions": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces",
          "content": "Please take a notice that recently the schedule has been changed. Twice.Greetings to the Codeforces community!I'm glad to announce that we again decided to introduce a round based on one of the programming olympiads for schoolchildren in Saratov. This time it is a round for participants from Division II. Round will start at unusual time for Codeforces: Dec. 7, 07:00 UTC.The problems were prepared by employees and students of Programming Competitions Training Center of Saratov State U.Members of the first division can participate out of competition, as usual.Currently we are planning to use dynamic scoring system.UPD: Moved from 09:00 to 07:00 because of Kotlin Challenge.UPD 2: Tutorial has been published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9854",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 714
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces",
          "content": "370A - Rook, Bishop and KingThere are two approaches to this task. The first is use BFS to find the shortest path three times. The second is to notice that: A rook can reach the destination in one or two moves. If the starting and the destination fields are in the same row or column, one move is enough. A bishop can reach only fields that are colored the same as the starting cell, and can do this in at most two moves: if the starting and the destination fields are on the same diagonal, one move is enough. To find this out, check that r1 - c1 = r2 - c2 OR r1 + c1 = r2 + c2. A king should make max(|r1 - r2|, |c1 - c2|) moves. int r1, c1, r2, c2;\n cin >> r1 >> c1 >> r2 >> c2;\n if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n cout << \" \";\n if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n }\n cout << \" \";\n cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;370B - Berland BingoIt is good idea to think about cards as set of numbers. It is easy to see that card a can’t be finished before b if b is subset of a. So all you need is to find such cards (sets) which do not have other card (other set) as subset.Since there are at most 1000 cards, you may iterate through all pairs and check that one card contains other in naive way like: bool contains(vector<int> a, vector<int> b) // b in a?\n{\n forn(i, b.size())\n {\n bool in = false;\n forn(j, a.size())\n if (a[j] == b[i])\n in = true;\n if (!in)\n return false;\n }\n\n return true;\n} 370C - MittensLet’s show that if the most frequent color appears not more than times, than all children can get mittens of distinct colors. One way to construct such solution is to sort all left mittens in the order of decreasing frequency of their colors: for the input 1 2 1 2 3 1 3 3 1 we get 1 1 1 1 3 3 3 2 2. To obtain the sequence of right mittens, rotate the sequence of left mittens to the left by the maximum color frequency (in the example it is 4, so we get the sequence 3 3 3 2 2 1 1 1 1). Then just match the sequences (1 — 3, 1 — 3, 1 — 3, 1 — 2, 3 — 2, 3 — 1, 3 — 1, 2 — 1, 2 — 1). It can be easily shown that all pairs consist of distinct colors.OK, but what to do if there is a dominating color that appears more than half times? Use exactly the same algorithm! It will maximize the number of pairs of distinct colors.370D - Broken MonitorThere are a lot of correct approaches to solve the problem. But there are much more incorrect :)One way to solve the problem is following. It is easy to see that in possible answer there are two opposite sides each containing w. In opposite case frame can be shrinked. So the size of frame is dx or dy, where dx = maxx - minx + 1 and dy = maxy - miny + 1 (minx, maxx, miny, maxy are coordinates of left/right/top/bottom ws). Obviously, you should choose max(dx, dy) as a size.Now we know the size of the required frame. How to find it’s leftmost-topmost corner?The set of possible xs is: minx, maxx - size + 1 and 0. Indeed, you may move frame to the left until it will abuts to w by left size/right size of abuts to the left side of monitor.Similarly, the set of possible ys as y-coordinate of leftmost-topmost corner: miny, maxy - size + 1, 0.Now the solution looks like: find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n foreach y in {miny, maxy-size+1, 0}\n if frame_correct(x, y, size)\n print answer\n exit algorithmAll you need is to write frame_correct. You may iterate through frame and check that all cells inside monitor and calculate the number of ws on it. If all the cells are inside and calculated number equals to total number of w, then return true.This solution works in O(nm).370E - Summer ReadingFor each book number that is in the sequence, find the leftmost and the rightmost position of this number. In other words, for each such book number we find a segment of positions that should consist of this number. If for some pair of numbers there segments intersect, it is impossible to construct the answer. The same thing happens if some segment has length more than 5. It is reasonable to separately handle the case when all given numbers are zeroes. In this case, fill in the numbers greedily, spending 2 days on each book (probably, except the last one).So, we have some blocks of numbers and gaps between them. Lets do the following DP: each state of DP is described by two values (i, j): i means the number of block (lets enumerate them consecutively), j means how far to the right will this block eventually extend (if there is a gap after this block, it is possible that we fill some prefix of this gap with the same book number that is in the block). It is clear that j - i will not exceed 5, so we actually can describe the state by values (i, j - i), which may sound more convenient. So, the number of states is linear. Lets say that D(i, j) is true if it it possible to correctly fill all the gaps that come before the i-th block, under condition that the i-th block extends to the position j, and D(i, j) is false otherwise. To calculate the value of D(i, j), lets try to extend the i-th block to the left in all (not so many) possible ways (to replace some number of consecutive zeroes that are in the gap just before the i-th block). Then, try to fix where the previous block can actually end (fix the state D(i - 1, k), where D(i - 1, k) is true, of course). To make a transition in DP, we should check whether it possible or not to fill the rest of the gap between the (i - 1)-th block and the i-th block. Lets say that (i - 1)-th block consists of number x, the i-th block consists of number y, and there are f still unfilled positions in the gap. Than the gap can be correctly filled if and only if 2·(y - x - 1) ≤ f ≤ 5·(y - x - 1).If you understand this DP, it won’t be difficult for you to find out how to construct the answer from it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9866",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 370\\s*A"
          },
          "content_length": 5913
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 1",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 2",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 3",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 4",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 5",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 6",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 7",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 8",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 9",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 10",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 11",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 12",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 13",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 14",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 15",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 16",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 17",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 18",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 1",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 2",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 3",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 4",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 5",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 6",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 7",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 8",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 9",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 10",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 11",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 12",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 13",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 14",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 15",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 16",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r1 = inf.readInt(1, 8, \"r1\");\n    inf.readSpace();\n    int c1 = inf.readInt(1, 8, \"c1\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, 8, \"r2\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, 8, \"c2\");\n    inf.readEoln();\n\n    ensuref(r1 != r2 || c1 != c2, \"Starting position must not be equal to ending position\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r1 = inf.readInt(1, 8, \"r1\");\n    inf.readSpace();\n    int c1 = inf.readInt(1, 8, \"c1\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, 8, \"r2\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, 8, \"c2\");\n    inf.readEoln();\n\n    ensuref(r1 != r2 || c1 != c2, \"Starting position must not be equal to ending position\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r1 = inf.readInt(1, 8, \"r1\");\n    inf.readSpace();\n    int c1 = inf.readInt(1, 8, \"c1\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, 8, \"r2\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, 8, \"c2\");\n    inf.readEoln();\n\n    ensuref(r1 != r2 || c1 != c2, \"Starting position must not be equal to ending position\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\", \"random\");\n    int r1, c1, r2, c2;\n\n    if (type == \"random\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while (r1 == r2 && c1 == c2);\n    } else if (type == \"bishop_impossible\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while ((r1 == r2 && c1 == c2) || ((r1 + c1) % 2 == (r2 + c2) % 2));\n    } else if (type == \"bishop_one_move\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while ((r1 == r2 && c1 == c2) || (abs(r1 - r2) != abs(c1 - c2)));\n    } else if (type == \"bishop_two_moves\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while ((r1 == r2 && c1 == c2) || ((r1 + c1) % 2 != (r2 + c2) % 2) || (abs(r1 - r2) == abs(c1 - c2)));\n    } else if (type == \"rook_one_move\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            if (rnd.next(2)) {\n                // Same row\n                r2 = r1;\n                do {\n                    c2 = rnd.next(1, 8);\n                } while (c2 == c1);\n            } else {\n                // Same column\n                c2 = c1;\n                do {\n                    r2 = rnd.next(1, 8);\n                } while (r2 == r1);\n            }\n        } while (r1 == r2 && c1 == c2);\n    } else if (type == \"rook_two_moves\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            do {\n                r2 = rnd.next(1, 8);\n            } while (r2 == r1);\n            do {\n                c2 = rnd.next(1, 8);\n            } while (c2 == c1);\n        } while (r1 == r2 && c1 == c2);\n    } else if (type == \"king_moves\") {\n        int k_moves = opt<int>(\"king_moves\");\n        if (k_moves < 1 || k_moves > 7) {\n            fprintf(stderr, \"Invalid king_moves parameter: %d\\n\", k_moves);\n            exit(1);\n        }\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            vector<pair<int, int>> positions;\n            for (int dr = -k_moves; dr <= k_moves; ++dr) {\n                for (int dc = -k_moves; dc <= k_moves; ++dc) {\n                    if (max(abs(dr), abs(dc)) != k_moves) continue;\n                    int r2_candidate = r1 + dr;\n                    int c2_candidate = c1 + dc;\n                    if (r2_candidate >= 1 && r2_candidate <= 8 && c2_candidate >= 1 && c2_candidate <= 8) {\n                        if (r2_candidate == r1 && c2_candidate == c1) continue;\n                        positions.push_back(make_pair(r2_candidate, c2_candidate));\n                    }\n                }\n            }\n            if (positions.empty()) continue;\n            auto p = rnd.any(positions);\n            r2 = p.first;\n            c2 = p.second;\n            break;\n        } while (true);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %d %d %d\\n\", r1, c1, r2, c2);\n\n    return 0;\n\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\", \"random\");\n    int r1, c1, r2, c2;\n\n    if (type == \"random\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while (r1 == r2 && c1 == c2);\n    } else if (type == \"bishop_impossible\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while ((r1 == r2 && c1 == c2) || ((r1 + c1) % 2 == (r2 + c2) % 2));\n    } else if (type == \"bishop_one_move\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while ((r1 == r2 && c1 == c2) || (abs(r1 - r2) != abs(c1 - c2)));\n    } else if (type == \"bishop_two_moves\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            r2 = rnd.next(1, 8);\n            c2 = rnd.next(1, 8);\n        } while ((r1 == r2 && c1 == c2) || ((r1 + c1) % 2 != (r2 + c2) % 2) || (abs(r1 - r2) == abs(c1 - c2)));\n    } else if (type == \"rook_one_move\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            if (rnd.next(2)) {\n                // Same row\n                r2 = r1;\n                do {\n                    c2 = rnd.next(1, 8);\n                } while (c2 == c1);\n            } else {\n                // Same column\n                c2 = c1;\n                do {\n                    r2 = rnd.next(1, 8);\n                } while (r2 == r1);\n            }\n        } while (r1 == r2 && c1 == c2);\n    } else if (type == \"rook_two_moves\") {\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            do {\n                r2 = rnd.next(1, 8);\n            } while (r2 == r1);\n            do {\n                c2 = rnd.next(1, 8);\n            } while (c2 == c1);\n        } while (r1 == r2 && c1 == c2);\n    } else if (type == \"king_moves\") {\n        int k_moves = opt<int>(\"king_moves\");\n        if (k_moves < 1 || k_moves > 7) {\n            fprintf(stderr, \"Invalid king_moves parameter: %d\\n\", k_moves);\n            exit(1);\n        }\n        do {\n            r1 = rnd.next(1, 8);\n            c1 = rnd.next(1, 8);\n            vector<pair<int, int>> positions;\n            for (int dr = -k_moves; dr <= k_moves; ++dr) {\n                for (int dc = -k_moves; dc <= k_moves; ++dc) {\n                    if (max(abs(dr), abs(dc)) != k_moves) continue;\n                    int r2_candidate = r1 + dr;\n                    int c2_candidate = c1 + dc;\n                    if (r2_candidate >= 1 && r2_candidate <= 8 && c2_candidate >= 1 && c2_candidate <= 8) {\n                        if (r2_candidate == r1 && c2_candidate == c1) continue;\n                        positions.push_back(make_pair(r2_candidate, c2_candidate));\n                    }\n                }\n            }\n            if (positions.empty()) continue;\n            auto p = rnd.any(positions);\n            r2 = p.first;\n            c2 = p.second;\n            break;\n        } while (true);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %d %d %d\\n\", r1, c1, r2, c2);\n\n    return 0;\n\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type bishop_impossible\n./gen -type bishop_impossible\n./gen -type bishop_one_move\n./gen -type bishop_one_move\n./gen -type bishop_two_moves\n./gen -type bishop_two_moves\n\n./gen -type rook_one_move\n./gen -type rook_one_move\n./gen -type rook_two_moves\n./gen -type rook_two_moves\n\n./gen -type king_moves -king_moves 1\n./gen -type king_moves -king_moves 2\n./gen -type king_moves -king_moves 3\n./gen -type king_moves -king_moves 4\n./gen -type king_moves -king_moves 5\n./gen -type king_moves -king_moves 6\n./gen -type king_moves -king_moves 7\n\n./gen -type random\n./gen -type random\n./gen -type bishop_impossible\n./gen -type bishop_one_move\n./gen -type bishop_two_moves\n./gen -type rook_one_move\n./gen -type rook_two_moves\n./gen -type king_moves -king_moves 3\n./gen -type king_moves -king_moves 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:08.081915",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "370/B",
      "title": "Problem 370/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int mi = inf.readInt(1, 100, \"mi\");\n        vector<int> nums;\n\n        for (int j = 0; j < mi; j++) {\n            inf.readSpace();\n            int a_ij = inf.readInt(1, 100, \"ai_j\");\n            nums.push_back(a_ij);\n        }\n\n        inf.readEoln();\n\n        // Check that numbers on each card are distinct\n        sort(nums.begin(), nums.end());\n        for (int k = 1; k < mi; k++) {\n            ensuref(nums[k] != nums[k - 1], \"Numbers on card %d are not distinct\", i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int mi = inf.readInt(1, 100, \"mi\");\n        vector<int> nums;\n\n        for (int j = 0; j < mi; j++) {\n            inf.readSpace();\n            int a_ij = inf.readInt(1, 100, \"ai_j\");\n            nums.push_back(a_ij);\n        }\n\n        inf.readEoln();\n\n        // Check that numbers on each card are distinct\n        sort(nums.begin(), nums.end());\n        for (int k = 1; k < mi; k++) {\n            ensuref(nums[k] != nums[k - 1], \"Numbers on card %d are not distinct\", i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int mi = inf.readInt(1, 100, \"mi\");\n        vector<int> nums;\n\n        for (int j = 0; j < mi; j++) {\n            inf.readSpace();\n            int a_ij = inf.readInt(1, 100, \"ai_j\");\n            nums.push_back(a_ij);\n        }\n\n        inf.readEoln();\n\n        // Check that numbers on each card are distinct\n        sort(nums.begin(), nums.end());\n        for (int k = 1; k < mi; k++) {\n            ensuref(nums[k] != nums[k - 1], \"Numbers on card %d are not distinct\", i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> cards;\n    if (type == \"random\") {\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        for (int i = 0; i < n; ++i) {\n            int mi = rnd.next(1, 100);\n            shuffle(num_pool.begin(), num_pool.end());\n            vector<int> nums(num_pool.begin(), num_pool.begin() + mi);\n            cards.push_back(nums);\n        }\n    } else if (type == \"max_mi\") {\n        for (int i = 0; i < n; ++i) {\n            int mi = 100;\n            vector<int> nums(100);\n            for (int j = 0; j < 100; ++j) nums[j] = j + 1;\n            cards.push_back(nums);\n        }\n    } else if (type == \"min_mi\") {\n        for (int i = 0; i < n; ++i) {\n            int mi = 1;\n            int num = rnd.next(1, 100);\n            vector<int> nums{num};\n            cards.push_back(nums);\n        }\n    } else if (type == \"same_cards\") {\n        int mi = rnd.next(1, 100);\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        shuffle(num_pool.begin(), num_pool.end());\n        vector<int> nums(num_pool.begin(), num_pool.begin() + mi);\n        for (int i = 0; i < n; ++i) {\n            cards.push_back(nums);\n        }\n    } else if (type == \"unique_cards\") {\n        n = min(n, 100);\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        shuffle(num_pool.begin(), num_pool.end());\n        for (int i = 0; i < n; ++i) {\n            int mi = 1;\n            vector<int> nums{num_pool[i]};\n            cards.push_back(nums);\n        }\n    } else if (type == \"subset_cards\") {\n        int mi0 = rnd.next(1, 100); // mi for player 0\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        shuffle(num_pool.begin(), num_pool.end());\n        vector<int> nums0(num_pool.begin(), num_pool.begin() + mi0);\n        cards.push_back(nums0);\n        int remaining_nums = 100 - mi0;\n        vector<int> remaining_numbers(num_pool.begin() + mi0, num_pool.end());\n        for (int i = 1; i < n; ++i) {\n            int mi = rnd.next(mi0, min(100, mi0 + remaining_nums));\n            // Include the nums0 plus some extra\n            vector<int> nums = nums0;\n            if (mi > mi0) {\n                int extra_nums = mi - mi0;\n                shuffle(remaining_numbers.begin(), remaining_numbers.end());\n                nums.insert(nums.end(), remaining_numbers.begin(), remaining_numbers.begin() + extra_nums);\n            }\n            cards.push_back(nums);\n        }\n    } else if (type == \"worst_case\") {\n        n = 100;\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        for (int i = 0; i < n; ++i) {\n            vector<int> nums = num_pool;\n            shuffle(nums.begin(), nums.end());\n            cards.push_back(nums);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        for (int i = 0; i < n; ++i) {\n            int mi = rnd.next(1, 100);\n            shuffle(num_pool.begin(), num_pool.end());\n            vector<int> nums(num_pool.begin(), num_pool.begin() + mi);\n            cards.push_back(nums);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int mi = cards[i].size();\n        printf(\"%d\", mi);\n        for (int j = 0; j < mi; ++j)\n            printf(\" %d\", cards[i][j]);\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> cards;\n    if (type == \"random\") {\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        for (int i = 0; i < n; ++i) {\n            int mi = rnd.next(1, 100);\n            shuffle(num_pool.begin(), num_pool.end());\n            vector<int> nums(num_pool.begin(), num_pool.begin() + mi);\n            cards.push_back(nums);\n        }\n    } else if (type == \"max_mi\") {\n        for (int i = 0; i < n; ++i) {\n            int mi = 100;\n            vector<int> nums(100);\n            for (int j = 0; j < 100; ++j) nums[j] = j + 1;\n            cards.push_back(nums);\n        }\n    } else if (type == \"min_mi\") {\n        for (int i = 0; i < n; ++i) {\n            int mi = 1;\n            int num = rnd.next(1, 100);\n            vector<int> nums{num};\n            cards.push_back(nums);\n        }\n    } else if (type == \"same_cards\") {\n        int mi = rnd.next(1, 100);\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        shuffle(num_pool.begin(), num_pool.end());\n        vector<int> nums(num_pool.begin(), num_pool.begin() + mi);\n        for (int i = 0; i < n; ++i) {\n            cards.push_back(nums);\n        }\n    } else if (type == \"unique_cards\") {\n        n = min(n, 100);\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        shuffle(num_pool.begin(), num_pool.end());\n        for (int i = 0; i < n; ++i) {\n            int mi = 1;\n            vector<int> nums{num_pool[i]};\n            cards.push_back(nums);\n        }\n    } else if (type == \"subset_cards\") {\n        int mi0 = rnd.next(1, 100); // mi for player 0\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        shuffle(num_pool.begin(), num_pool.end());\n        vector<int> nums0(num_pool.begin(), num_pool.begin() + mi0);\n        cards.push_back(nums0);\n        int remaining_nums = 100 - mi0;\n        vector<int> remaining_numbers(num_pool.begin() + mi0, num_pool.end());\n        for (int i = 1; i < n; ++i) {\n            int mi = rnd.next(mi0, min(100, mi0 + remaining_nums));\n            // Include the nums0 plus some extra\n            vector<int> nums = nums0;\n            if (mi > mi0) {\n                int extra_nums = mi - mi0;\n                shuffle(remaining_numbers.begin(), remaining_numbers.end());\n                nums.insert(nums.end(), remaining_numbers.begin(), remaining_numbers.begin() + extra_nums);\n            }\n            cards.push_back(nums);\n        }\n    } else if (type == \"worst_case\") {\n        n = 100;\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        for (int i = 0; i < n; ++i) {\n            vector<int> nums = num_pool;\n            shuffle(nums.begin(), nums.end());\n            cards.push_back(nums);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        vector<int> num_pool(100);\n        for (int i = 0; i < 100; ++i) num_pool[i] = i + 1;\n        for (int i = 0; i < n; ++i) {\n            int mi = rnd.next(1, 100);\n            shuffle(num_pool.begin(), num_pool.end());\n            vector<int> nums(num_pool.begin(), num_pool.begin() + mi);\n            cards.push_back(nums);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int mi = cards[i].size();\n        printf(\"%d\", mi);\n        for (int j = 0; j < mi; ++j)\n            printf(\" %d\", cards[i][j]);\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum input cases\n./gen -n 1 -type min_mi\n./gen -n 1 -type max_mi\n./gen -n 1 -type random\n\n# Small n cases\n./gen -n 2 -type same_cards\n./gen -n 2 -type unique_cards\n./gen -n 2 -type subset_cards\n./gen -n 3 -type random\n./gen -n 3 -type min_mi\n./gen -n 3 -type max_mi\n./gen -n 5 -type random\n\n# Medium n cases\n./gen -n 10 -type random\n./gen -n 10 -type min_mi\n./gen -n 10 -type max_mi\n./gen -n 10 -type same_cards\n./gen -n 10 -type unique_cards\n./gen -n 10 -type subset_cards\n\n# Large n cases\n./gen -n 50 -type random\n./gen -n 50 -type min_mi\n./gen -n 50 -type max_mi\n./gen -n 50 -type same_cards\n./gen -n 50 -type unique_cards\n./gen -n 50 -type subset_cards\n\n# Maximum n cases\n./gen -n 100 -type random\n./gen -n 100 -type min_mi\n./gen -n 100 -type max_mi\n./gen -n 100 -type same_cards\n./gen -n 100 -type unique_cards\n./gen -n 100 -type subset_cards\n\n# Worst case\n./gen -n 100 -type worst_case\n\n# Specific edge cases\n# All players have numbers from 1 to 100\n./gen -n 100 -type max_mi\n\n# All players have mi = 1, same number\n./gen -n 100 -type min_mi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:09.876846",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "370/C",
      "title": "C. Варежки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n и m — количество детей и количество возможных цветов варежек (1 ≤ n ≤ 5000, 1 ≤ m ≤ 100). Во второй строке записаны n целых чисел c1, c2, ... cn, где ci — цвет варежек i-го ребенка (1 ≤ ci ≤ m).",
      "output_spec": "Выходные данныеВ первой строке выведите наибольшее количество детей, у которых может оказаться разноцветная пара варежек. В следующих n строках выведите то, как именно могут быть распределены варежки в этом случае. В i-й из этих строк выведите через пробел два числа: цвет левой варежки, которая окажется у i-го ребенка, и цвет правой варежки, которая у него окажется. Если оптимальных решений несколько, разрешается вывести любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 31 3 2 2 1 1Выходные данныеСкопировать62 11 22 11 31 23 1Входные данныеСкопировать4 21 2 1 1Выходные данныеСкопировать21 21 12 11 1",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n и m — количество детей и количество возможных цветов варежек (1 ≤ n ≤ 5000, 1 ≤ m ≤ 100). Во второй строке записаны n целых чисел c1, c2, ... cn, где ci — цвет варежек i-го ребенка (1 ≤ ci ≤ m).\n\nВходные данные\n\nВыходные данныеВ первой строке выведите наибольшее количество детей, у которых может оказаться разноцветная пара варежек. В следующих n строках выведите то, как именно могут быть распределены варежки в этом случае. В i-й из этих строк выведите через пробел два числа: цвет левой варежки, которая окажется у i-го ребенка, и цвет правой варежки, которая у него окажется. Если оптимальных решений несколько, разрешается вывести любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать6 31 3 2 2 1 1Выходные данныеСкопировать62 11 22 11 31 23 1Входные данныеСкопировать4 21 2 1 1Выходные данныеСкопировать21 21 12 11 1\n\nВходные данныеСкопировать6 31 3 2 2 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать62 11 22 11 31 23 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 21 2 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 21 12 11 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces",
          "content": "Обратите внимание на некоторые изменения в расписании. Дважды.Доброго времени суток, сообщество Codeforces!Рад Вам сообщить, что мы в очередной раз делаем раунд из задач одной из олимпиад для саратовских школьников. На этот раз — раунд для второго дивизиона. Раунд начнется в необычное для Codeforces время: 7 декабря в 11:00 MSKЗадачи были подготовлены большим коллективом сотрудников и студентов Центра олимпиадной подготовки программистов Саратовского государственного университета.Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Наш текущий план: разбаловка задач будет динамической.UPD: Перенесли с 13:00 на 11:00 из-за Kotlin Challenge.UPD 2: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9854",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 703
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces",
          "content": "370A - Ладья, слон и корольК задаче есть два подхода. Первый — три раза запустить поиск в ширину. Второй — более легкий, нужно лишь понять, что: Ладья может достичь любого поля не более, чем за два хода. Если стартовое и конечное поле находятся в одной строке или в одном столбце, то достаточно одного хода. Слон может достичь только клетки, окрашенные в тот же цвет, что и стартовая, и тоже не более чем за два хода. Если стартовое и конечное поле находятся на одной диагонали, то достаточно одного хода. Чтобы это выяснить, нужно проверить, что r1 - c1 = r2 - c2 ИЛИ r1 + c1 = r2 + c2. Королю достаточно сделать max(|r1 - r2|, |c1 - c2|) ходов. int r1, c1, r2, c2;\n cin >> r1 >> c1 >> r2 >> c2;\n if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n cout << \" \";\n if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n }\n cout << \" \";\n cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;370B - Берляндское лотоВ этой задаче полезно рассматривать карточки игроков как множества чисел. В таком случае, карточка a не может быть закрыта строго раньше карточки b, если b является подмножеством a. Таким образом, критерием того, что карточка может быть закрыта первой является тот факт, что не существует другой карточки, которая является ее подмножеством.Так как карточек всего 100, то для каждой карточки можно перебрать все остальные, чтобы осуществить проверку. Проверку на подмножество можно делать совсем простым способом, например, так: bool contains(vector<int> a, vector<int> b) // b in a?\n{\n forn(i, b.size())\n {\n bool in = false;\n forn(j, a.size())\n if (a[j] == b[i])\n in = true;\n if (!in)\n return false;\n }\n\n return true;\n} 370C - ВарежкиЕсли максимальный цвет встречается не более раз, то каждый ребенок может получить левую и правую варежки разного цвета. Для этого отсортируем все левые варежки в порядке убывания частоты их цвета: для входа 1 2 1 2 3 1 3 3 1 получилось бы 1 1 1 1 3 3 3 2 2. Чтобы получить последовательность цветов правых варежек, сдвинем последовательность цветов левых варежек влево на количество самого популярного цвета (в примере это 4, поэтому получим 3 3 3 2 2 1 1 1 1). И теперь объединим эти две последовательности в пары (1 — 3, 1 — 3, 1 — 3, 1 — 2, 3 — 2, 3 — 1, 3 — 1, 2 — 1, 2 — 1). Легко показать, что при этом все пары будут состоять из варежек различного цвета.Хорошо, ну а что же делать, если есть доминирующий цвет, который встречается слишком много раз? Применять тот же самый алгоритм! При его применении количество разноцветных пар будет наибольшим. 370D - Сломанный мониторУ этой задачи есть большое количество правильных решений, но еще больше у нее неправильных решений :)Один из способов решить её такой. Легко видеть, что в правильном ответе найдется две противоположные стороны, на которых есть символ w. Если бы это было не так, то рамку можно было бы сжать до меньшего размена. Таким образом, размер рамки это dx или dy, где dx = maxx - minx + 1 and dy = maxy - miny + 1 (minx, maxx, miny, maxy — это соответствующие координаты левой/правой/верхней/нижней буквы w). Очевидно, размер искомой рамки равен максимуму из dx, dy.Хорошо, размер рамки ясен, а как быть с её положением? Попробуем найти ее левый верхний угол.Множество возможных координат x левого верхнего угла — это {minx, maxx - size + 1, 0}. В самом деле, давайте начнем двигать искомую рамку влево, пока это возможно. Либо она упрется в w левым или правым краем, либо в левую границу монитора.Аналогично, множество возможных координат y левого верхнего угла — это {miny, maxy - size + 1, 0}.Таким образом решение принимает вид: find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n foreach y in {miny, maxy-size+1, 0}\n if frame_correct(x, y, size)\n print answer\n exit algorithmВсё что осталось сделать, это написать функцию frame_correct, которая проверяет, что рамка с левым верхним углом в (x, y) и размером size является ответом. Для этого достаточно пройти по ней и проверить, что все ее клетки находятся в границах монитора и количество w на рамке совпадает с их общим числом.Описанное решение работает за O(nm).370E - Летнее чтениеДля каждого номера книги, который присутствует в последовательности, найдем самое левое и самое правое вхождения: для каждого номера получился отрезок из позиций, на котором он точно должен быть записан. Понятно, что если два каких-то отрезка пересеклись, или же длина какого-то отрезка больше 5, то ответа не существует. Можно еще отдельно обработать случай, когда все числа — нули. Тогда дневник можно заполнить жадно, отдавая на все книги (кроме, возможно, одной), по два дня.Итак, у нас есть несколько блоков из чисел и промежутки между ними. Будем решать задачу при помощи динамического программирования (ДП). Состояние будем описывать парой чисел (i, j): i означает номер блока из номеров книг (пронумеруем блоки слева направо), а j означает, до какой позиции числа из i-го блока будут идти в итоге (если после этого блока есть непустой промежуток свободных позиций, то сколько-то первый из них могут содержать такие же номера книг). Очевидно, что j - i не превосходит 5, поэтому количество состояний линейное. Пусть D(i, j) равно true, если можно корректно заполнить все пропуски до i-го блока при условии, что i-й блок распространится вправо вплоть до позиции j, и D(i, j) равно false в противном случае. Чтобы определить D(i, j), давайте переберем еще и то, насколько i-й блок распространится влево (очевидно, что таких способов всего несколько). Затем переберем позицию, до которой будет идти (i - 1)-й блок (т.е. зафиксируем состояние D(i - 1, k), где D(i - 1, k), конечно, равно true). Чтобы понять, возможен ли переход в ДП, нужно выяснить, можно ли корректно заполнить остаток промежутка между блоками. Пусть (i - 1)-й блок состоит из чисел x, i-й блок состоит из чисел y, а оставшаяся длина промежутка равна f. Тогда промежуток можно заполнить тогда и только тогда, когда 2·(y - x - 1) ≤ f ≤ 5·(y - x - 1).Если вы осознали, как работает это ДП, то вам не составит труда понять, как получить ответ.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9866",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 370\\s*C"
          },
          "content_length": 6104
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 1",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 2",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 3",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 4",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 5",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 6",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 7",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 8",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 9",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 10",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 11",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 12",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 13",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 14",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 15",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 16",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 17",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 18",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 1",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 2",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 3",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 4",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 5",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 6",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 7",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 8",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 9",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 10",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 11",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 12",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 13",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 14",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 15",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 16",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, m, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, m, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, m, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<int> c;\nvector<int> left_mittens;\nvector<int> right_mittens;\n\nint readAns(InStream& stream) {\n    int M = stream.readInt(0, n, \"number of mismatched mittens\");\n    vector<int> assigned_left_mittens(m + 1, 0);\n    vector<int> assigned_right_mittens(m + 1, 0);\n    int mismatched_children = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        int L_i = stream.readInt(1, m, format(\"L_%d\", i).c_str());\n        int R_i = stream.readInt(1, m, format(\"R_%d\", i).c_str());\n\n        assigned_left_mittens[L_i] += 1;\n        assigned_right_mittens[R_i] += 1;\n\n        if (L_i != R_i) mismatched_children += 1;\n    }\n\n    for (int color = 1; color <= m; ++color) {\n        if (assigned_left_mittens[color] > left_mittens[color]) {\n            stream.quitf(_wa, \"assigned more left mittens of color %d than available\", color);\n        }\n        if (assigned_right_mittens[color] > right_mittens[color]) {\n            stream.quitf(_wa, \"assigned more right mittens of color %d than available\", color);\n        }\n    }\n\n    if (mismatched_children != M) {\n        stream.quitf(_wa, \"number of mismatched children %d does not match claimed M = %d\", mismatched_children, M);\n    }\n\n    return M;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    n = inf.readInt(1, 5000, \"n\");\n    m = inf.readInt(1, 100, \"m\");\n\n    c.resize(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        c[i] = inf.readInt(1, m, format(\"c[%d]\", i).c_str());\n    }\n\n    // Initialize initial mitten counts\n    left_mittens.assign(m + 1, 0);\n    right_mittens.assign(m + 1, 0);\n\n    for (int i = 1; i <= n; ++i) {\n        left_mittens[c[i]] += 1;\n        right_mittens[c[i]] += 1;\n    }\n\n    int M_jury = readAns(ans);\n    int M_participant = readAns(ouf);\n\n    if (M_participant > M_jury) {\n        quitf(_fail, \"participant found better answer than jury: participant's M = %d, jury's M = %d\", M_participant, M_jury);\n    } else if (M_participant < M_jury) {\n        quitf(_wa, \"participant's M = %d less than jury's M = %d\", M_participant, M_jury);\n    } else {\n        quitf(_ok, \"number of children with mismatched mittens is %d\", M_jury);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within constraints\n    ensure(1 <= n && n <= 5000);\n    ensure(1 <= m && m <= 100);\n\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        // Random colors between 1 and m\n        for (int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, m);\n    } else if (type == \"same\") {\n        // All colors are the same\n        int color = rnd.next(1, m);\n        for (int i = 0; i < n; ++i)\n            c[i] = color;\n    } else if (type == \"minimal_colors\") {\n        // Use minimal number of colors, m = min(2, m)\n        m = min(2, m);\n        for (int i = 0; i < n; ++i)\n            c[i] = (i % m) + 1;\n    } else if (type == \"maximal_colors\") {\n        // Use maximal number of colors\n        m = min(m, 100);\n        m = min(m, n);\n        for (int i = 0; i < n; ++i)\n            c[i] = (i % m) + 1;\n    } else if (type == \"max_mismatches\") {\n        // Distribute colors to maximize mismatches\n        m = min(m, 100);\n        m = min(m, n);\n        vector<int> color_counts(m + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            int color = (i % m) + 1;\n            c[i] = color;\n            color_counts[color]++;\n        }\n        shuffle(c.begin(), c.end());\n    } else if (type == \"worst_case\") {\n        // Construct a case to challenge incorrect implementations\n        m = min(m, 100);\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                c[i] = 1;\n            else\n                c[i] = rnd.next(2, m);\n        }\n        shuffle(c.begin(), c.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, m);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within constraints\n    ensure(1 <= n && n <= 5000);\n    ensure(1 <= m && m <= 100);\n\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        // Random colors between 1 and m\n        for (int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, m);\n    } else if (type == \"same\") {\n        // All colors are the same\n        int color = rnd.next(1, m);\n        for (int i = 0; i < n; ++i)\n            c[i] = color;\n    } else if (type == \"minimal_colors\") {\n        // Use minimal number of colors, m = min(2, m)\n        m = min(2, m);\n        for (int i = 0; i < n; ++i)\n            c[i] = (i % m) + 1;\n    } else if (type == \"maximal_colors\") {\n        // Use maximal number of colors\n        m = min(m, 100);\n        m = min(m, n);\n        for (int i = 0; i < n; ++i)\n            c[i] = (i % m) + 1;\n    } else if (type == \"max_mismatches\") {\n        // Distribute colors to maximize mismatches\n        m = min(m, 100);\n        m = min(m, n);\n        vector<int> color_counts(m + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            int color = (i % m) + 1;\n            c[i] = color;\n            color_counts[color]++;\n        }\n        shuffle(c.begin(), c.end());\n    } else if (type == \"worst_case\") {\n        // Construct a case to challenge incorrect implementations\n        m = min(m, 100);\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                c[i] = 1;\n            else\n                c[i] = rnd.next(2, m);\n        }\n        shuffle(c.begin(), c.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, m);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type same\n./gen -n 5000 -m 1 -type same\n\n./gen -n 5000 -m 2 -type minimal_colors\n./gen -n 4999 -m 2 -type minimal_colors\n\n./gen -n 5000 -m 100 -type maximal_colors\n./gen -n 5000 -m 100 -type random\n\n./gen -n 5000 -m 50 -type max_mismatches\n./gen -n 5000 -m 100 -type max_mismatches\n\n./gen -n 5000 -m 5 -type max_mismatches\n./gen -n 2500 -m 50 -type max_mismatches\n\n./gen -n 5000 -m 99 -type max_mismatches\n\n./gen -n 5000 -m 100 -type worst_case\n./gen -n 5000 -m 2 -type worst_case\n./gen -n 4999 -m 2 -type worst_case\n\n./gen -n 5000 -m 1 -type same\n\n./gen -n 5000 -m 100 -type minimal_colors\n\n./gen -n 50 -m 10 -type random\n./gen -n 100 -m 10 -type random\n./gen -n 500 -m 20 -type random\n./gen -n 1000 -m 50 -type random\n\n./gen -n 2500 -m 1 -type same\n./gen -n 2500 -m 2 -type minimal_colors\n\n./gen -n 5000 -m 100 -type random\n./gen -n 4999 -m 50 -type random\n\n./gen -n 3 -m 3 -type maximal_colors\n./gen -n 4 -m 4 -type maximal_colors\n\n./gen -n 2 -m 1 -type same\n./gen -n 2 -m 2 -type minimal_colors\n\n./gen -n 5000 -m 100 -type max_mismatches\n\n./gen -n 5000 -m 100 -type worst_case\n\n./gen -n 1 -m 100 -type random\n./gen -n 5000 -m 1 -type same\n\n./gen -n 1 -m 1 -type same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:11.914868",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "370/D",
      "title": "D. Сломанный монитор",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится разрешение монитора в виде пары целых чисел n, m (1 ≤ n, m ≤ 2000). Следующие n строк содержат ровно по m символов — состояние пикселей монитора на момент игры. Символ «.» (точка) соответствует черному пикселю, а символ «w» (строчная латинская буква w) — белому. Гарантируется, что хотя бы один пиксель монитора — белый.",
      "output_spec": "Выходные данныеВыведите экран монитора, обозначив искомую рамку символами «+» (знак «плюс»). Те пиксели, которые во время игры были белыми, изменять не следует. Их следует выводить, используя «w». Если возможных вариантов размещения рамки минимального размера несколько, выведите любой из них.Если искомой рамки не существует, то выведите вместо n строк единственную строку, содержащую число -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 8..w..w....................w..w..Выходные данныеСкопировать..w++w....+..+....+..+....w++w..Входные данныеСкопировать5 6.......w............w.........Выходные данныеСкопировать......+w+...+.+...++w.........Входные данныеСкопировать2 4.....w..Выходные данныеСкопировать.....w..Входные данныеСкопировать2 6w..w.w...w..Выходные данныеСкопировать-1",
      "description": "D. Сломанный монитор\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится разрешение монитора в виде пары целых чисел n, m (1 ≤ n, m ≤ 2000). Следующие n строк содержат ровно по m символов — состояние пикселей монитора на момент игры. Символ «.» (точка) соответствует черному пикселю, а символ «w» (строчная латинская буква w) — белому. Гарантируется, что хотя бы один пиксель монитора — белый.\n\nВходные данные\n\nВыходные данныеВыведите экран монитора, обозначив искомую рамку символами «+» (знак «плюс»). Те пиксели, которые во время игры были белыми, изменять не следует. Их следует выводить, используя «w». Если возможных вариантов размещения рамки минимального размера несколько, выведите любой из них.Если искомой рамки не существует, то выведите вместо n строк единственную строку, содержащую число -1.\n\nВыходные данные\n\nВходные данныеСкопировать4 8..w..w....................w..w..Выходные данныеСкопировать..w++w....+..+....+..+....w++w..Входные данныеСкопировать5 6.......w............w.........Выходные данныеСкопировать......+w+...+.+...++w.........Входные данныеСкопировать2 4.....w..Выходные данныеСкопировать.....w..Входные данныеСкопировать2 6w..w.w...w..Выходные данныеСкопировать-1\n\nВходные данныеСкопировать4 8..w..w....................w..w..\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать..w++w....+..+....+..+....w++w..\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 6.......w............w.........\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать......+w+...+.+...++w.........\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 4.....w..\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать.....w..\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 6w..w.w...w..\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере размер искомой рамки равен 4. Во втором примере размер искомой рамки равен 3. В третьем примере искомая рамка имеет размер 1. В четвертом примере искомой рамки не существует.",
      "solutions": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces",
          "content": "Обратите внимание на некоторые изменения в расписании. Дважды.Доброго времени суток, сообщество Codeforces!Рад Вам сообщить, что мы в очередной раз делаем раунд из задач одной из олимпиад для саратовских школьников. На этот раз — раунд для второго дивизиона. Раунд начнется в необычное для Codeforces время: 7 декабря в 11:00 MSKЗадачи были подготовлены большим коллективом сотрудников и студентов Центра олимпиадной подготовки программистов Саратовского государственного университета.Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Наш текущий план: разбаловка задач будет динамической.UPD: Перенесли с 13:00 на 11:00 из-за Kotlin Challenge.UPD 2: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9854",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 703
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces",
          "content": "370A - Ладья, слон и корольК задаче есть два подхода. Первый — три раза запустить поиск в ширину. Второй — более легкий, нужно лишь понять, что: Ладья может достичь любого поля не более, чем за два хода. Если стартовое и конечное поле находятся в одной строке или в одном столбце, то достаточно одного хода. Слон может достичь только клетки, окрашенные в тот же цвет, что и стартовая, и тоже не более чем за два хода. Если стартовое и конечное поле находятся на одной диагонали, то достаточно одного хода. Чтобы это выяснить, нужно проверить, что r1 - c1 = r2 - c2 ИЛИ r1 + c1 = r2 + c2. Королю достаточно сделать max(|r1 - r2|, |c1 - c2|) ходов. int r1, c1, r2, c2;\n cin >> r1 >> c1 >> r2 >> c2;\n if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n cout << \" \";\n if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n }\n cout << \" \";\n cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;370B - Берляндское лотоВ этой задаче полезно рассматривать карточки игроков как множества чисел. В таком случае, карточка a не может быть закрыта строго раньше карточки b, если b является подмножеством a. Таким образом, критерием того, что карточка может быть закрыта первой является тот факт, что не существует другой карточки, которая является ее подмножеством.Так как карточек всего 100, то для каждой карточки можно перебрать все остальные, чтобы осуществить проверку. Проверку на подмножество можно делать совсем простым способом, например, так: bool contains(vector<int> a, vector<int> b) // b in a?\n{\n forn(i, b.size())\n {\n bool in = false;\n forn(j, a.size())\n if (a[j] == b[i])\n in = true;\n if (!in)\n return false;\n }\n\n return true;\n} 370C - ВарежкиЕсли максимальный цвет встречается не более раз, то каждый ребенок может получить левую и правую варежки разного цвета. Для этого отсортируем все левые варежки в порядке убывания частоты их цвета: для входа 1 2 1 2 3 1 3 3 1 получилось бы 1 1 1 1 3 3 3 2 2. Чтобы получить последовательность цветов правых варежек, сдвинем последовательность цветов левых варежек влево на количество самого популярного цвета (в примере это 4, поэтому получим 3 3 3 2 2 1 1 1 1). И теперь объединим эти две последовательности в пары (1 — 3, 1 — 3, 1 — 3, 1 — 2, 3 — 2, 3 — 1, 3 — 1, 2 — 1, 2 — 1). Легко показать, что при этом все пары будут состоять из варежек различного цвета.Хорошо, ну а что же делать, если есть доминирующий цвет, который встречается слишком много раз? Применять тот же самый алгоритм! При его применении количество разноцветных пар будет наибольшим. 370D - Сломанный мониторУ этой задачи есть большое количество правильных решений, но еще больше у нее неправильных решений :)Один из способов решить её такой. Легко видеть, что в правильном ответе найдется две противоположные стороны, на которых есть символ w. Если бы это было не так, то рамку можно было бы сжать до меньшего размена. Таким образом, размер рамки это dx или dy, где dx = maxx - minx + 1 and dy = maxy - miny + 1 (minx, maxx, miny, maxy — это соответствующие координаты левой/правой/верхней/нижней буквы w). Очевидно, размер искомой рамки равен максимуму из dx, dy.Хорошо, размер рамки ясен, а как быть с её положением? Попробуем найти ее левый верхний угол.Множество возможных координат x левого верхнего угла — это {minx, maxx - size + 1, 0}. В самом деле, давайте начнем двигать искомую рамку влево, пока это возможно. Либо она упрется в w левым или правым краем, либо в левую границу монитора.Аналогично, множество возможных координат y левого верхнего угла — это {miny, maxy - size + 1, 0}.Таким образом решение принимает вид: find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n foreach y in {miny, maxy-size+1, 0}\n if frame_correct(x, y, size)\n print answer\n exit algorithmВсё что осталось сделать, это написать функцию frame_correct, которая проверяет, что рамка с левым верхним углом в (x, y) и размером size является ответом. Для этого достаточно пройти по ней и проверить, что все ее клетки находятся в границах монитора и количество w на рамке совпадает с их общим числом.Описанное решение работает за O(nm).370E - Летнее чтениеДля каждого номера книги, который присутствует в последовательности, найдем самое левое и самое правое вхождения: для каждого номера получился отрезок из позиций, на котором он точно должен быть записан. Понятно, что если два каких-то отрезка пересеклись, или же длина какого-то отрезка больше 5, то ответа не существует. Можно еще отдельно обработать случай, когда все числа — нули. Тогда дневник можно заполнить жадно, отдавая на все книги (кроме, возможно, одной), по два дня.Итак, у нас есть несколько блоков из чисел и промежутки между ними. Будем решать задачу при помощи динамического программирования (ДП). Состояние будем описывать парой чисел (i, j): i означает номер блока из номеров книг (пронумеруем блоки слева направо), а j означает, до какой позиции числа из i-го блока будут идти в итоге (если после этого блока есть непустой промежуток свободных позиций, то сколько-то первый из них могут содержать такие же номера книг). Очевидно, что j - i не превосходит 5, поэтому количество состояний линейное. Пусть D(i, j) равно true, если можно корректно заполнить все пропуски до i-го блока при условии, что i-й блок распространится вправо вплоть до позиции j, и D(i, j) равно false в противном случае. Чтобы определить D(i, j), давайте переберем еще и то, насколько i-й блок распространится влево (очевидно, что таких способов всего несколько). Затем переберем позицию, до которой будет идти (i - 1)-й блок (т.е. зафиксируем состояние D(i - 1, k), где D(i - 1, k), конечно, равно true). Чтобы понять, возможен ли переход в ДП, нужно выяснить, можно ли корректно заполнить остаток промежутка между блоками. Пусть (i - 1)-й блок состоит из чисел x, i-й блок состоит из чисел y, а оставшаяся длина промежутка равна f. Тогда промежуток можно заполнить тогда и только тогда, когда 2·(y - x - 1) ≤ f ≤ 5·(y - x - 1).Если вы осознали, как работает это ДП, то вам не составит труда понять, как получить ответ.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9866",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 370\\s*D"
          },
          "content_length": 6104
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 1",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 2",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 3",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 4",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 5",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 6",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 7",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 8",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 9",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 10",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 11",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 12",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 13",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 14",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 15",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 16",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 17",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 18",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 1",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 2",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 3",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 4",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 5",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 6",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 7",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 8",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 9",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 10",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 11",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 12",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 13",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 14",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 15",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): разбор задач - Codeforces - Code 16",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    int white_pixels = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n\n        ensuref((int)s.length() == m, \"Line %d is of length %d, expected %d\", i+1, (int)s.length(), m);\n\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '.' || c == 'w', \"Invalid character '%c' at line %d, position %d. Expected '.' or 'w'\", c, i+1, j+1);\n            if (c == 'w') {\n                white_pixels++;\n            }\n        }\n    }\n\n    ensuref(white_pixels > 0, \"At least one white pixel ('w') must be present\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    int white_pixels = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n\n        ensuref((int)s.length() == m, \"Line %d is of length %d, expected %d\", i+1, (int)s.length(), m);\n\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '.' || c == 'w', \"Invalid character '%c' at line %d, position %d. Expected '.' or 'w'\", c, i+1, j+1);\n            if (c == 'w') {\n                white_pixels++;\n            }\n        }\n    }\n\n    ensuref(white_pixels > 0, \"At least one white pixel ('w') must be present\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    int white_pixels = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n\n        ensuref((int)s.length() == m, \"Line %d is of length %d, expected %d\", i+1, (int)s.length(), m);\n\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '.' || c == 'w', \"Invalid character '%c' at line %d, position %d. Expected '.' or 'w'\", c, i+1, j+1);\n            if (c == 'w') {\n                white_pixels++;\n            }\n        }\n    }\n\n    ensuref(white_pixels > 0, \"At least one white pixel ('w') must be present\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<string> grid;\n\nvector<pair<int, int>> whites;\n\nbool check_frame(int si, int sj, int d) {\n    if (si < 0 || sj < 0 || si + d > n || sj + d > m)\n        return false;\n    for (auto [i, j] : whites) {\n        if (i < si || i >= si + d || j < sj || j >= sj + d)\n            return false;\n        bool on_border = (i == si || i == si + d - 1 || j == sj || j == sj + d -1);\n        if (!on_border)\n            return false;\n    }\n    return true;\n}\n\nint compute_min_d() {\n    int min_i = n, max_i = -1, min_j = m, max_j = -1;\n    for (auto [i, j] : whites) {\n        min_i = min(min_i, i);\n        max_i = max(max_i, i);\n        min_j = min(min_j, j);\n        max_j = max(max_j, j);\n    }\n    int d_min = max(max_i - min_i + 1, max_j - min_j + 1);\n    for (int d = d_min; d <= max(n, m); d++) {\n        for (int si = max(0, min_i - (d - 1)); si <= min(min_i, n - d); si++) {\n            for (int sj = max(0, min_j - (d - 1)); sj <= min(min_j, m - d); sj++) {\n                if (check_frame(si, sj, d)) {\n                    return d;\n                }\n            }\n        }\n    }\n    return -1; // No frame exists\n}\n\nbool frame_exists() {\n    return compute_min_d() != -1;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    m = inf.readInt();\n    grid.resize(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readToken();\n        if ((int)grid[i].size() != m)\n            quitf(_fail, \"Invalid input file: line %d has length %d instead of %d\", i + 1, (int)grid[i].size(), m);\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 'w') {\n                whites.push_back({i, j});\n            }\n        }\n    }\n\n    if (whites.empty()) {\n        // Should not happen according to problem statement\n        quitf(_fail, \"Invalid input: no white pixels\");\n    }\n\n    if (ouf.seekEof())\n        quitf(_pe, \"Unexpected end of file\");\n\n    string firstLine = ouf.readLine();\n\n    if (trim(firstLine) == \"-1\") {\n        // Participant outputs -1\n        if (frame_exists()) {\n            quitf(_wa, \"Participant outputs -1 but a solution exists\");\n        } else {\n            quitf(_ok, \"Correctly outputs -1 when no solution exists\");\n        }\n    } else {\n        vector<string> pgrid(n);\n        pgrid[0] = firstLine;\n        if ((int)pgrid[0].size() != m)\n            quitf(_pe, \"Line 1 has length %d instead of %d\", (int)pgrid[0].size(), m);\n        for (int i = 1; i < n; i++) {\n            if (ouf.seekEof())\n                quitf(_pe, \"Unexpected end of file after line %d\", i);\n            pgrid[i] = ouf.readLine();\n            if ((int)pgrid[i].size() != m)\n                quitf(_pe, \"Line %d has length %d instead of %d\", i + 1, (int)pgrid[i].size(), m);\n        }\n        if (!ouf.seekEof())\n            quitf(_pe, \"Extra output after reading %d lines\", n);\n\n        // Check that the 'w's in input are preserved\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 'w') {\n                    if (pgrid[i][j] != 'w') {\n                        quitf(_wa, \"Pixel (%d, %d): Expected 'w', found '%c'\", i + 1, j + 1, pgrid[i][j]);\n                    }\n                }\n            }\n        }\n\n        // Find the frame in participant's output\n        vector<pair<int, int>> frame_pixels;\n        int min_i = n, max_i = -1, min_j = m, max_j = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (pgrid[i][j] == '+' || pgrid[i][j] == 'w') {\n                    frame_pixels.push_back({i, j});\n                    min_i = min(min_i, i);\n                    max_i = max(max_i, i);\n                    min_j = min(min_j, j);\n                    max_j = max(max_j, j);\n                } else if (pgrid[i][j] != '.') {\n                    quitf(_wa, \"Pixel (%d, %d): Invalid character '%c'\", i + 1, j + 1, pgrid[i][j]);\n                }\n            }\n        }\n\n        if (frame_pixels.empty()) {\n            quitf(_wa, \"No frame found in participant's output\");\n        }\n\n        int d = max(max_i - min_i + 1, max_j - min_j + 1);\n\n        if (max_i - min_i != d - 1 || max_j - min_j != d -1) {\n            quitf(_wa, \"Frame is not a square of size %d\", d);\n        }\n        if (min_i < 0 || min_j < 0 || max_i >= n || max_j >= m) {\n            quitf(_wa, \"Frame goes outside the screen boundaries\");\n        }\n\n        // Check frame's width is 1 pixel\n        for (int i = min_i; i <= max_i; i++) {\n            for (int j = min_j; j <= max_j; j++) {\n                bool on_border = (i == min_i || i == max_i || j == min_j || j == max_j);\n                char expected_char;\n                if (grid[i][j] == 'w') {\n                    expected_char = 'w';\n                } else if (on_border) {\n                    expected_char = '+';\n                } else {\n                    expected_char = '.'; // Inside the frame\n                }\n                if (pgrid[i][j] != expected_char) {\n                    quitf(_wa, \"Pixel (%d, %d): Expected '%c', found '%c'\", i + 1, j + 1, expected_char, pgrid[i][j]);\n                }\n            }\n        }\n\n        // All 'w's should be on the frame's border\n        for (auto [i, j] : whites) {\n            if (i < min_i || i > max_i || j < min_j || j > max_j) {\n                quitf(_wa, \"White pixel (%d, %d) is outside the frame\", i + 1, j + 1);\n            }\n            bool on_border = (i == min_i || i == max_i || j == min_j || j == max_j);\n            if (!on_border) {\n                quitf(_wa, \"White pixel (%d, %d) is inside the frame, not on the border\", i + 1, j + 1);\n            }\n        }\n\n        // Check that the frame size is minimal\n        int min_d = compute_min_d();\n        if (min_d == -1) {\n            quitf(_fail, \"Participant outputs a frame but no frame exists according to the checker\");\n        }\n        if (d > min_d) {\n            quitf(_wa, \"Participant's frame size %d is larger than minimal possible size %d\", d, min_d);\n        }\n\n        quitf(_ok, \"Accepted\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"random\") {\n        int w_count = opt<int>(\"w_count\", max(1, n * m / 10)); // Default to 10% of the grid\n        w_count = min(w_count, n * m);\n        for (int i = 0; i < w_count; ++i) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            grid[x][y] = 'w';\n        }\n    } else if (type == \"single_w\") {\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = 'w';\n    } else if (type == \"line_w\") {\n        bool horizontal = rnd.next(0, 1); // 0 for vertical, 1 for horizontal\n        if (horizontal) {\n            int x = rnd.next(0, n - 1);\n            for (int y = 0; y < m; ++y)\n                grid[x][y] = 'w';\n        } else {\n            int y = rnd.next(0, m - 1);\n            for (int x = 0; x < n; ++x)\n                grid[x][y] = 'w';\n        }\n    } else if (type == \"corner_w\") {\n        grid[0][0] = 'w';\n        grid[0][m - 1] = 'w';\n        grid[n - 1][0] = 'w';\n        grid[n - 1][m - 1] = 'w';\n    } else if (type == \"cluster_w\") {\n        int cluster_size = opt<int>(\"cluster_size\", 5);\n        cluster_size = min(cluster_size, min(n, m));\n        int x0 = rnd.next(0, n - cluster_size);\n        int y0 = rnd.next(0, m - cluster_size);\n        for (int x = x0; x < x0 + cluster_size; ++x) {\n            for (int y = y0; y < y0 + cluster_size; ++y) {\n                grid[x][y] = 'w';\n            }\n        }\n    } else if (type == \"negative_case\") {\n        // Construct a grid where it's impossible to have a valid frame\n        grid[0][0] = 'w';\n        if (n > 1 && m > 1) {\n            grid[1][m - 1] = 'w';\n            grid[n - 1][1] = 'w';\n        }\n    } else if (type == \"max_case\") {\n        // Place 'w's on the main diagonal\n        for (int i = 0; i < min(n, m); ++i) {\n            grid[i][i] = 'w';\n        }\n    } else if (type == \"dense_w\") {\n        // Fill the grid with 'w's\n        for (int x = 0; x < n; ++x)\n            for (int y = 0; y < m; ++y)\n                grid[x][y] = 'w';\n    } else if (type == \"sparse_w\") {\n        // Put 'w's in random positions but very few\n        int w_count = opt<int>(\"w_count\", 1);\n        w_count = min(w_count, n * m);\n        set<pair<int, int>> positions;\n        while ((int)positions.size() < w_count) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            positions.insert({x, y});\n        }\n        for (auto pos : positions) {\n            grid[pos.first][pos.second] = 'w';\n        }\n    } else if (type == \"checkerboard\") {\n        // Place 'w's in a checkerboard pattern\n        for (int x = 0; x < n; ++x)\n            for (int y = 0; y < m; ++y)\n                if ((x + y) % 2 == 0)\n                    grid[x][y] = 'w';\n    } else if (type == \"edge_w\") {\n        // Place 'w's along the edges\n        for (int y = 0; y < m; ++y) {\n            grid[0][y] = 'w';          // Top row\n            grid[n - 1][y] = 'w';      // Bottom row\n        }\n        for (int x = 0; x < n; ++x) {\n            grid[x][0] = 'w';          // Left column\n            grid[x][m - 1] = 'w';      // Right column\n        }\n    } else {\n        // If type is unknown\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure there is at least one 'w'\n    bool has_w = false;\n    for (int x = 0; x < n && !has_w; ++x)\n        for (int y = 0; y < m && !has_w; ++y)\n            if (grid[x][y] == 'w')\n                has_w = true;\n    if (!has_w) {\n        // Place a single 'w' randomly\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = 'w';\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int x = 0; x < n; ++x)\n        printf(\"%s\\n\", grid[x].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"random\") {\n        int w_count = opt<int>(\"w_count\", max(1, n * m / 10)); // Default to 10% of the grid\n        w_count = min(w_count, n * m);\n        for (int i = 0; i < w_count; ++i) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            grid[x][y] = 'w';\n        }\n    } else if (type == \"single_w\") {\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = 'w';\n    } else if (type == \"line_w\") {\n        bool horizontal = rnd.next(0, 1); // 0 for vertical, 1 for horizontal\n        if (horizontal) {\n            int x = rnd.next(0, n - 1);\n            for (int y = 0; y < m; ++y)\n                grid[x][y] = 'w';\n        } else {\n            int y = rnd.next(0, m - 1);\n            for (int x = 0; x < n; ++x)\n                grid[x][y] = 'w';\n        }\n    } else if (type == \"corner_w\") {\n        grid[0][0] = 'w';\n        grid[0][m - 1] = 'w';\n        grid[n - 1][0] = 'w';\n        grid[n - 1][m - 1] = 'w';\n    } else if (type == \"cluster_w\") {\n        int cluster_size = opt<int>(\"cluster_size\", 5);\n        cluster_size = min(cluster_size, min(n, m));\n        int x0 = rnd.next(0, n - cluster_size);\n        int y0 = rnd.next(0, m - cluster_size);\n        for (int x = x0; x < x0 + cluster_size; ++x) {\n            for (int y = y0; y < y0 + cluster_size; ++y) {\n                grid[x][y] = 'w';\n            }\n        }\n    } else if (type == \"negative_case\") {\n        // Construct a grid where it's impossible to have a valid frame\n        grid[0][0] = 'w';\n        if (n > 1 && m > 1) {\n            grid[1][m - 1] = 'w';\n            grid[n - 1][1] = 'w';\n        }\n    } else if (type == \"max_case\") {\n        // Place 'w's on the main diagonal\n        for (int i = 0; i < min(n, m); ++i) {\n            grid[i][i] = 'w';\n        }\n    } else if (type == \"dense_w\") {\n        // Fill the grid with 'w's\n        for (int x = 0; x < n; ++x)\n            for (int y = 0; y < m; ++y)\n                grid[x][y] = 'w';\n    } else if (type == \"sparse_w\") {\n        // Put 'w's in random positions but very few\n        int w_count = opt<int>(\"w_count\", 1);\n        w_count = min(w_count, n * m);\n        set<pair<int, int>> positions;\n        while ((int)positions.size() < w_count) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            positions.insert({x, y});\n        }\n        for (auto pos : positions) {\n            grid[pos.first][pos.second] = 'w';\n        }\n    } else if (type == \"checkerboard\") {\n        // Place 'w's in a checkerboard pattern\n        for (int x = 0; x < n; ++x)\n            for (int y = 0; y < m; ++y)\n                if ((x + y) % 2 == 0)\n                    grid[x][y] = 'w';\n    } else if (type == \"edge_w\") {\n        // Place 'w's along the edges\n        for (int y = 0; y < m; ++y) {\n            grid[0][y] = 'w';          // Top row\n            grid[n - 1][y] = 'w';      // Bottom row\n        }\n        for (int x = 0; x < n; ++x) {\n            grid[x][0] = 'w';          // Left column\n            grid[x][m - 1] = 'w';      // Right column\n        }\n    } else {\n        // If type is unknown\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure there is at least one 'w'\n    bool has_w = false;\n    for (int x = 0; x < n && !has_w; ++x)\n        for (int y = 0; y < m && !has_w; ++y)\n            if (grid[x][y] == 'w')\n                has_w = true;\n    if (!has_w) {\n        // Place a single 'w' randomly\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = 'w';\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int x = 0; x < n; ++x)\n        printf(\"%s\\n\", grid[x].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type single_w\n./gen -n 1 -m 1 -type negative_case\n./gen -n 2 -m 2 -type corner_w\n./gen -n 2 -m 2 -type negative_case\n./gen -n 3 -m 3 -type edge_w\n./gen -n 5 -m 5 -type checkerboard\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type random -w_count 10\n./gen -n 10 -m 10 -type cluster_w -cluster_size 5\n./gen -n 50 -m 50 -type line_w\n./gen -n 100 -m 100 -type sparse_w -w_count 10\n./gen -n 500 -m 500 -type dense_w\n./gen -n 1000 -m 1000 -type checkerboard\n./gen -n 2000 -m 2000 -type edge_w\n./gen -n 2000 -m 2000 -type max_case\n./gen -n 2000 -m 2000 -type negative_case\n./gen -n 2000 -m 2000 -type random -w_count 1\n./gen -n 2000 -m 2000 -type random -w_count 100000\n./gen -n 2000 -m 2000 -type random -w_count 4000000\n./gen -n 2000 -m 1 -type line_w\n./gen -n 1 -m 2000 -type line_w\n./gen -n 500 -m 2000 -type cluster_w -cluster_size 100\n./gen -n 2000 -m 500 -type cluster_w -cluster_size 100\n./gen -n 2000 -m 2000 -type checkerboard\n./gen -n 1999 -m 1999 -type negative_case\n./gen -n 2000 -m 2000 -type sparse_w -w_count 0\n./gen -n 2000 -m 2000 -type dense_w\n./gen -n 2 -m 2000 -type line_w\n./gen -n 2000 -m 2 -type line_w\n./gen -n 2000 -m 2000 -type corner_w\n./gen -n 2000 -m 2000 -type single_w\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:14.146771",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "370/E",
      "title": "E. Summer Reading",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n — the number of summer days (2 ≤ n ≤ 2·105). The second line contains n integers a1, a2, ... an — the records in the diary in the order they were written (0 ≤ ai ≤ 105). If Vasya forgot to write the number of the book on the i-th day, then ai equals 0.",
      "output_spec": "OutputIf it is impossible to correctly fill the blanks in the diary (the diary may contain mistakes initially), print \"-1\". Otherwise, print in the first line the maximum number of books Vasya could have read in the summer if we stick to the diary. In the second line print n integers — the diary with correctly inserted records. If there are multiple optimal solutions, you can print any of them.",
      "sample_tests": "ExamplesInputCopy70 1 0 0 0 3 0OutputCopy31 1 2 2 3 3 3 InputCopy80 0 0 0 0 0 0 0OutputCopy41 1 2 2 3 3 4 4 InputCopy40 0 1 0OutputCopy11 1 1 1 InputCopy40 0 0 3OutputCopy-1",
      "description": "E. Summer Reading\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n — the number of summer days (2 ≤ n ≤ 2·105). The second line contains n integers a1, a2, ... an — the records in the diary in the order they were written (0 ≤ ai ≤ 105). If Vasya forgot to write the number of the book on the i-th day, then ai equals 0.\n\nOutputIf it is impossible to correctly fill the blanks in the diary (the diary may contain mistakes initially), print \"-1\". Otherwise, print in the first line the maximum number of books Vasya could have read in the summer if we stick to the diary. In the second line print n integers — the diary with correctly inserted records. If there are multiple optimal solutions, you can print any of them.\n\nInputCopy70 1 0 0 0 3 0OutputCopy31 1 2 2 3 3 3 InputCopy80 0 0 0 0 0 0 0OutputCopy41 1 2 2 3 3 4 4 InputCopy40 0 1 0OutputCopy11 1 1 1 InputCopy40 0 0 3OutputCopy-1\n\nInputCopy70 1 0 0 0 3 0\n\nOutputCopy31 1 2 2 3 3 3\n\nInputCopy80 0 0 0 0 0 0 0\n\nOutputCopy41 1 2 2 3 3 4 4\n\nInputCopy40 0 1 0\n\nOutputCopy11 1 1 1\n\nInputCopy40 0 0 3\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces",
          "content": "Please take a notice that recently the schedule has been changed. Twice.Greetings to the Codeforces community!I'm glad to announce that we again decided to introduce a round based on one of the programming olympiads for schoolchildren in Saratov. This time it is a round for participants from Division II. Round will start at unusual time for Codeforces: Dec. 7, 07:00 UTC.The problems were prepared by employees and students of Programming Competitions Training Center of Saratov State U.Members of the first division can participate out of competition, as usual.Currently we are planning to use dynamic scoring system.UPD: Moved from 09:00 to 07:00 because of Kotlin Challenge.UPD 2: Tutorial has been published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9854",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 714
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces",
          "content": "370A - Rook, Bishop and KingThere are two approaches to this task. The first is use BFS to find the shortest path three times. The second is to notice that: A rook can reach the destination in one or two moves. If the starting and the destination fields are in the same row or column, one move is enough. A bishop can reach only fields that are colored the same as the starting cell, and can do this in at most two moves: if the starting and the destination fields are on the same diagonal, one move is enough. To find this out, check that r1 - c1 = r2 - c2 OR r1 + c1 = r2 + c2. A king should make max(|r1 - r2|, |c1 - c2|) moves. int r1, c1, r2, c2;\n cin >> r1 >> c1 >> r2 >> c2;\n if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n cout << \" \";\n if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n }\n cout << \" \";\n cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;370B - Berland BingoIt is good idea to think about cards as set of numbers. It is easy to see that card a can’t be finished before b if b is subset of a. So all you need is to find such cards (sets) which do not have other card (other set) as subset.Since there are at most 1000 cards, you may iterate through all pairs and check that one card contains other in naive way like: bool contains(vector<int> a, vector<int> b) // b in a?\n{\n forn(i, b.size())\n {\n bool in = false;\n forn(j, a.size())\n if (a[j] == b[i])\n in = true;\n if (!in)\n return false;\n }\n\n return true;\n} 370C - MittensLet’s show that if the most frequent color appears not more than times, than all children can get mittens of distinct colors. One way to construct such solution is to sort all left mittens in the order of decreasing frequency of their colors: for the input 1 2 1 2 3 1 3 3 1 we get 1 1 1 1 3 3 3 2 2. To obtain the sequence of right mittens, rotate the sequence of left mittens to the left by the maximum color frequency (in the example it is 4, so we get the sequence 3 3 3 2 2 1 1 1 1). Then just match the sequences (1 — 3, 1 — 3, 1 — 3, 1 — 2, 3 — 2, 3 — 1, 3 — 1, 2 — 1, 2 — 1). It can be easily shown that all pairs consist of distinct colors.OK, but what to do if there is a dominating color that appears more than half times? Use exactly the same algorithm! It will maximize the number of pairs of distinct colors.370D - Broken MonitorThere are a lot of correct approaches to solve the problem. But there are much more incorrect :)One way to solve the problem is following. It is easy to see that in possible answer there are two opposite sides each containing w. In opposite case frame can be shrinked. So the size of frame is dx or dy, where dx = maxx - minx + 1 and dy = maxy - miny + 1 (minx, maxx, miny, maxy are coordinates of left/right/top/bottom ws). Obviously, you should choose max(dx, dy) as a size.Now we know the size of the required frame. How to find it’s leftmost-topmost corner?The set of possible xs is: minx, maxx - size + 1 and 0. Indeed, you may move frame to the left until it will abuts to w by left size/right size of abuts to the left side of monitor.Similarly, the set of possible ys as y-coordinate of leftmost-topmost corner: miny, maxy - size + 1, 0.Now the solution looks like: find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n foreach y in {miny, maxy-size+1, 0}\n if frame_correct(x, y, size)\n print answer\n exit algorithmAll you need is to write frame_correct. You may iterate through frame and check that all cells inside monitor and calculate the number of ws on it. If all the cells are inside and calculated number equals to total number of w, then return true.This solution works in O(nm).370E - Summer ReadingFor each book number that is in the sequence, find the leftmost and the rightmost position of this number. In other words, for each such book number we find a segment of positions that should consist of this number. If for some pair of numbers there segments intersect, it is impossible to construct the answer. The same thing happens if some segment has length more than 5. It is reasonable to separately handle the case when all given numbers are zeroes. In this case, fill in the numbers greedily, spending 2 days on each book (probably, except the last one).So, we have some blocks of numbers and gaps between them. Lets do the following DP: each state of DP is described by two values (i, j): i means the number of block (lets enumerate them consecutively), j means how far to the right will this block eventually extend (if there is a gap after this block, it is possible that we fill some prefix of this gap with the same book number that is in the block). It is clear that j - i will not exceed 5, so we actually can describe the state by values (i, j - i), which may sound more convenient. So, the number of states is linear. Lets say that D(i, j) is true if it it possible to correctly fill all the gaps that come before the i-th block, under condition that the i-th block extends to the position j, and D(i, j) is false otherwise. To calculate the value of D(i, j), lets try to extend the i-th block to the left in all (not so many) possible ways (to replace some number of consecutive zeroes that are in the gap just before the i-th block). Then, try to fix where the previous block can actually end (fix the state D(i - 1, k), where D(i - 1, k) is true, of course). To make a transition in DP, we should check whether it possible or not to fill the rest of the gap between the (i - 1)-th block and the i-th block. Lets say that (i - 1)-th block consists of number x, the i-th block consists of number y, and there are f still unfilled positions in the gap. Than the gap can be correctly filled if and only if 2·(y - x - 1) ≤ f ≤ 5·(y - x - 1).If you understand this DP, it won’t be difficult for you to find out how to construct the answer from it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9866",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 370\\s*E"
          },
          "content_length": 5913
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 1",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 2",
          "code": "res[i] + \" \" + res[ (i+offset)%size ] ; // i = 1..n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 3",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 4",
          "code": "1 1 1 2 2 3\nfor\n1 2 2 1 3 1\n\n// (I've just found that I simply need to sort it, xd)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 5",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 6",
          "code": "1 2\n1 2\n1 3\n2 1\n2 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 7",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 8",
          "code": "5 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 9",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 10",
          "code": "10\n1 3\n3 1\n2 1\n1 2\n3 2\n2 3\n1 3\n3 1\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 11",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 12",
          "code": "10\n1 2\n3 1\n2 1\n1 3\n3 1\n2 3\n1 2\n3 1\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 13",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 14",
          "code": "|   | Sent | Accepted |\n| A | 1094 | 781      |\n| B | 820  | 654      |\n| C | 449  | 151      |\n| D | 130  | 17       |\n| E | 11   | 2        |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 15",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 16",
          "code": "for(i=1;i<=n;++i)\n  for(j=i+1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 17",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2) - Codeforces - Code 18",
          "code": "for(i=1;i<=n;++i)\n  for(j=1;j<=n;++j)\n     if(color[i]!=color[j])\n     {\n        add_edge(i,j);\n        //add_edge(j,i);\n     }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9854",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 1",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 2",
          "code": "int r1, c1, r2, c2;\n    cin >> r1 >> c1 >> r2 >> c2;\n    if (r1 == r2 || c1 == c2) cout << 1; else cout << 2;\n    cout << \" \";\n    if ((r1 + c1) % 2 != (r2 + c2) % 2) cout << 0; else {\n        if (r1 + c1 == r2 + c2 || r1 - c1 == r2 - c2) cout << 1; else cout << 2;\n    }\n    cout << \" \";\n    cout << max(abs(r1 - r2), abs(c1 - c2)) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 3",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 4",
          "code": "bool contains(vector<int> a, vector<int> b) // b in a?\n{\n    forn(i, b.size())\n    {\n        bool in = false;\n        forn(j, a.size())\n            if (a[j] == b[i])\n                in = true;\n        if (!in)\n            return false;\n    }\n\n    return true;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 5",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 6",
          "code": "find minx, maxx, miny, maxy\ndx = maxx-minx+1, dy=maxy-miny+1\nsize = max(dx, dy)\nforeach x in {minx, maxx-size+1, 0}\n    foreach y in {miny, maxy-size+1, 0}\n        if frame_correct(x, y, size)\n            print answer\n            exit algorithm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 7",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 8",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 9",
          "code": "5 7\n.......\n.wwww..\n.......\n.......\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 10",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 11",
          "code": ".++++..\n.wwww..\n.+..+..\n.++++..\n.......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 12",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 13",
          "code": ".......\n.wwww..\n.+..+..\n.+..+..\n.++++..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 14",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 15",
          "code": "if(set(A).contain(K)){\n  Bitset[K]=true;\n }else{\n  Bitset[K]=false;\n }\nBitset(C) = set(A) U set(B) =Bitset(A)|Bitset(B)\n\nif(Bitset(A)==Bitset(C)){\n  A contains B\n}\nif(Bitset(B)==Bitset(C)){\n B contains A\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #217 (Div. 2): tutorial - Codeforces - Code 16",
          "code": "frame_correct",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9866",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    int n = inf.readInt();\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInt(0, 100000);\n    }\n    \n    int jury_B = ans.readInt(-1, n / 2 + 1, \"jury's maximum number of books\");\n    vector<int> jury_diary;\n    if (jury_B != -1) {\n        jury_diary = ans.readInts(n, 1, 100000, \"jury's filled diary\");\n    }\n\n    int cont_B = ouf.readInt(-1, n / 2 + 1, \"participant's maximum number of books\");\n    vector<int> cont_diary;\n    if (cont_B != -1) {\n        cont_diary = ouf.readInts(n, 1, 100000, \"participant's filled diary\");\n    }\n\n    if (jury_B == -1) {\n        if (cont_B == -1) {\n            quitf(_ok, \"Correctly reported -1\");\n        } else {\n            quitf(_wa, \"Contestant found a solution but jury says impossible\");\n        }\n    } else {\n        if (cont_B == -1) {\n            quitf(_wa, \"Contestant reports -1 but a solution exists\");\n        }\n        if (cont_B != jury_B) {\n            quitf(_wa, \"Contestant's maximum number of books %d is not equal to jury's maximum %d\", cont_B, jury_B);\n        }\n        // Validate the contestant's filled diary\n        int n = a.size();\n        vector<int>& diary = cont_diary;\n\n        // Check that at positions where a[i] != 0, diary[i] == a[i]\n        for (int i = 0; i < n; i++) {\n            if (a[i] != 0 && diary[i] != a[i]) {\n                quitf(_wa, \"Mismatch at position %d: expected %d, found %d\", i+1, a[i], diary[i]);\n            }\n        }\n        // Check that the diary entries are >=1\n        for (int i = 0; i < n; i++) {\n            if (diary[i] < 1) {\n                quitf(_wa, \"Diary entry at position %d is invalid: %d\", i+1, diary[i]);\n            }\n        }\n        // Check that the book numbers are consecutive starting from 1\n        int current_book = diary[0];\n        if (current_book != 1) {\n            quitf(_wa, \"First book must be 1, found %d\", current_book);\n        }\n        int current_book_start = 0;\n        int current_book_length = 1;\n\n        for (int i = 1; i <= n; i++) {\n            if (i < n && diary[i] == current_book) {\n                current_book_length++;\n            } else {\n                // Process current book segment\n                if (current_book_length < 2 || current_book_length > 5) {\n                    quitf(_wa, \"Book %d has invalid length %d at positions [%d, %d], must be between 2 and 5\", current_book, current_book_length, current_book_start + 1, i);\n                }\n                if (i < n) {\n                    int next_book = diary[i];\n                    if (next_book != current_book && next_book != current_book + 1) {\n                        quitf(_wa, \"Book numbers must increase by 1, found %d after %d at position %d\", next_book, current_book, i+1);\n                    }\n                    if (next_book < current_book) {\n                        quitf(_wa, \"Book numbers must not decrease, found %d after %d at position %d\", next_book, current_book, i+1);\n                    }\n                    current_book = next_book;\n                    current_book_start = i;\n                    current_book_length = 1;\n                }\n            }\n        }\n        // Check that the number of books read is equal to cont_B\n        int max_book = *max_element(diary.begin(), diary.end());\n        if (max_book != cont_B) {\n            quitf(_wa, \"Maximum book number in diary (%d) does not match reported number of books (%d)\", max_book, cont_B);\n        }\n        quitf(_ok, \"Correct diary with %d books\", cont_B);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> diary(n, 0);\n\n    if (type == \"all_zeroes\") {\n        // All entries are zeroes (missing)\n        // Do nothing as the diary is already initialized to zeros\n    } else if (type == \"random\") {\n        int min_books = (n + 4) / 5; // ceil(n / 5.0)\n        int max_books = n / 2;\n        int num_books = rnd.next(min_books, max_books);\n\n        vector<int> lengths(num_books, 2); // Initialize lengths with 2\n        int remaining_extra_days = n - 2 * num_books;\n\n        // Distribute remaining_extra_days into lengths\n        for (int i = 0; i < num_books; i++) {\n            int max_extra = min(3, remaining_extra_days);\n            int delta = rnd.next(0, max_extra);\n            lengths[i] += delta;\n            remaining_extra_days -= delta;\n        }\n\n        // Shuffle the lengths to randomize distribution\n        shuffle(lengths.begin(), lengths.end());\n\n        // Now create the diary entries\n        int day = 0;\n        for (int book_id = 0; book_id < num_books; book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                if (rnd.next(2) == 0) {\n                    diary[day++] = 0;\n                } else {\n                    diary[day++] = book_id + 1;\n                }\n            }\n        }\n    } else if (type == \"max_books\") {\n        int num_books = n / 2;\n        int remaining_days = n - num_books * 2;\n        vector<int> lengths(num_books, 2);\n\n        // Distribute remaining days\n        for (int i = 0; remaining_days > 0 && i < num_books; i++, remaining_days--) {\n            lengths[i]++;\n        }\n\n        int day = 0;\n        for (int book_id = 0; book_id < num_books; book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                diary[day++] = book_id + 1;\n            }\n        }\n\n        // Randomly set some entries to 0\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) {\n                diary[i] = 0;\n            }\n        }\n    } else if (type == \"min_books\") {\n        int num_books = n / 5;\n        int remaining_days = n - num_books * 5;\n        vector<int> lengths(num_books, 5);\n\n        if (remaining_days > 0) {\n            num_books++;\n            lengths.push_back(remaining_days);\n            int i = 0;\n            while ((lengths.back() < 2 || lengths.back() > 5) && i < lengths.size() -1) {\n                if (lengths[i] > 2) {\n                    lengths[i]--;\n                    lengths.back()++;\n                }\n                i++;\n            }\n        }\n\n        int day = 0;\n        for (int book_id = 0; book_id < lengths.size(); book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                diary[day++] = book_id + 1;\n            }\n        }\n\n        // Randomly set some entries to 0\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) {\n                diary[i] = 0;\n            }\n        }\n    } else if (type == \"impossible\") {\n        if (n >= 3) {\n            diary[0] = 1;\n            diary[1] = 0;\n            diary[2] = 2; // Book 2 starts on day 3, but book 1 has only 1 day recorded\n        } else {\n            // For n < 3, just fill with impossible entries\n            for (int i = 0; i < n; i++) {\n                diary[i] = i + 2; // Starting from book 2\n            }\n        }\n    } else if (type == \"pattern\") {\n        // Create a pattern where Vasya reads maximum length books alternating with minimum length books\n        vector<int> lengths;\n        bool toggle = true;\n        int total_days = 0;\n        while (total_days < n) {\n            int len = toggle ? 5 : 2;\n            if (total_days + len > n) {\n                len = n - total_days;\n                if (len < 2 || len > 5) {\n                    len = 2; // minimum allowed\n                }\n            }\n            lengths.push_back(len);\n            total_days += len;\n            toggle = !toggle;\n        }\n\n        int day = 0;\n        for (int book_id = 0; book_id < lengths.size(); book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                diary[day++] = book_id + 1;\n            }\n        }\n\n        // Randomly set some entries to 0\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(3) == 0) {\n                diary[i] = 0;\n            }\n        }\n    } else {\n        // Default to all zeros if unknown type\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the diary entries\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", diary[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> diary(n, 0);\n\n    if (type == \"all_zeroes\") {\n        // All entries are zeroes (missing)\n        // Do nothing as the diary is already initialized to zeros\n    } else if (type == \"random\") {\n        int min_books = (n + 4) / 5; // ceil(n / 5.0)\n        int max_books = n / 2;\n        int num_books = rnd.next(min_books, max_books);\n\n        vector<int> lengths(num_books, 2); // Initialize lengths with 2\n        int remaining_extra_days = n - 2 * num_books;\n\n        // Distribute remaining_extra_days into lengths\n        for (int i = 0; i < num_books; i++) {\n            int max_extra = min(3, remaining_extra_days);\n            int delta = rnd.next(0, max_extra);\n            lengths[i] += delta;\n            remaining_extra_days -= delta;\n        }\n\n        // Shuffle the lengths to randomize distribution\n        shuffle(lengths.begin(), lengths.end());\n\n        // Now create the diary entries\n        int day = 0;\n        for (int book_id = 0; book_id < num_books; book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                if (rnd.next(2) == 0) {\n                    diary[day++] = 0;\n                } else {\n                    diary[day++] = book_id + 1;\n                }\n            }\n        }\n    } else if (type == \"max_books\") {\n        int num_books = n / 2;\n        int remaining_days = n - num_books * 2;\n        vector<int> lengths(num_books, 2);\n\n        // Distribute remaining days\n        for (int i = 0; remaining_days > 0 && i < num_books; i++, remaining_days--) {\n            lengths[i]++;\n        }\n\n        int day = 0;\n        for (int book_id = 0; book_id < num_books; book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                diary[day++] = book_id + 1;\n            }\n        }\n\n        // Randomly set some entries to 0\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) {\n                diary[i] = 0;\n            }\n        }\n    } else if (type == \"min_books\") {\n        int num_books = n / 5;\n        int remaining_days = n - num_books * 5;\n        vector<int> lengths(num_books, 5);\n\n        if (remaining_days > 0) {\n            num_books++;\n            lengths.push_back(remaining_days);\n            int i = 0;\n            while ((lengths.back() < 2 || lengths.back() > 5) && i < lengths.size() -1) {\n                if (lengths[i] > 2) {\n                    lengths[i]--;\n                    lengths.back()++;\n                }\n                i++;\n            }\n        }\n\n        int day = 0;\n        for (int book_id = 0; book_id < lengths.size(); book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                diary[day++] = book_id + 1;\n            }\n        }\n\n        // Randomly set some entries to 0\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(2) == 0) {\n                diary[i] = 0;\n            }\n        }\n    } else if (type == \"impossible\") {\n        if (n >= 3) {\n            diary[0] = 1;\n            diary[1] = 0;\n            diary[2] = 2; // Book 2 starts on day 3, but book 1 has only 1 day recorded\n        } else {\n            // For n < 3, just fill with impossible entries\n            for (int i = 0; i < n; i++) {\n                diary[i] = i + 2; // Starting from book 2\n            }\n        }\n    } else if (type == \"pattern\") {\n        // Create a pattern where Vasya reads maximum length books alternating with minimum length books\n        vector<int> lengths;\n        bool toggle = true;\n        int total_days = 0;\n        while (total_days < n) {\n            int len = toggle ? 5 : 2;\n            if (total_days + len > n) {\n                len = n - total_days;\n                if (len < 2 || len > 5) {\n                    len = 2; // minimum allowed\n                }\n            }\n            lengths.push_back(len);\n            total_days += len;\n            toggle = !toggle;\n        }\n\n        int day = 0;\n        for (int book_id = 0; book_id < lengths.size(); book_id++) {\n            int len = lengths[book_id];\n            for (int j = 0; j < len; j++) {\n                diary[day++] = book_id + 1;\n            }\n        }\n\n        // Randomly set some entries to 0\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(3) == 0) {\n                diary[i] = 0;\n            }\n        }\n    } else {\n        // Default to all zeros if unknown type\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the diary entries\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", diary[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type all_zeroes\n./gen -n 5 -type random\n./gen -n 5 -type max_books\n./gen -n 5 -type min_books\n./gen -n 5 -type impossible\n\n./gen -n 2 -type random\n./gen -n 2 -type max_books\n./gen -n 2 -type min_books\n./gen -n 2 -type impossible\n\n./gen -n 100 -type random\n./gen -n 100 -type max_books\n./gen -n 100 -type min_books\n\n./gen -n 1000 -type random\n./gen -n 1000 -type max_books\n./gen -n 1000 -type min_books\n\n./gen -n 200000 -type random\n./gen -n 200000 -type max_books\n./gen -n 200000 -type min_books\n\n./gen -n 50000 -type impossible\n./gen -n 50000 -type pattern\n./gen -n 100000 -type pattern\n./gen -n 200000 -type pattern\n\n./gen -n 4 -type impossible\n./gen -n 3 -type impossible\n./gen -n 4 -type random\n./gen -n 3 -type random\n\n./gen -n 7 -type random\n./gen -n 8 -type random\n./gen -n 9 -type random\n\n./gen -n 10 -type random\n./gen -n 10 -type max_books\n./gen -n 10 -type min_books\n./gen -n 10 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:16.056596",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "371/A",
      "title": "A. K-периодичный массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных содержится пара целых положительных чисел n, k (1 ≤ k ≤ n ≤ 100), где n — длина массива, а значение k делит нацело n. Вторая строка содержит последовательность элементов заданного массива a1, a2, ..., an (1 ≤ ai ≤ 2), ai — i-й элемент массива.",
      "output_spec": "Выходные данныеВыведите наименьшее количество элементов массива, которые надо изменить, чтобы он стал k-периодическим. Если массив уже является k-периодичным, то выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 22 1 2 2 2 1Выходные данныеСкопировать1Входные данныеСкопировать8 41 1 2 1 1 1 2 1Выходные данныеСкопировать0Входные данныеСкопировать9 32 1 1 1 2 1 1 1 2Выходные данныеСкопировать3",
      "description": "A. K-периодичный массив\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных содержится пара целых положительных чисел n, k (1 ≤ k ≤ n ≤ 100), где n — длина массива, а значение k делит нацело n. Вторая строка содержит последовательность элементов заданного массива a1, a2, ..., an (1 ≤ ai ≤ 2), ai — i-й элемент массива.\n\nВходные данные\n\nВыходные данныеВыведите наименьшее количество элементов массива, которые надо изменить, чтобы он стал k-периодическим. Если массив уже является k-периодичным, то выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать6 22 1 2 2 2 1Выходные данныеСкопировать1Входные данныеСкопировать8 41 1 2 1 1 1 2 1Выходные данныеСкопировать0Входные данныеСкопировать9 32 1 1 1 2 1 1 1 2Выходные данныеСкопировать3\n\nВходные данныеСкопировать6 22 1 2 2 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8 41 1 2 1 1 1 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9 32 1 1 1 2 1 1 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере достаточно заменить четвертый элемент с 2 на 1, тогда массив примет вид [2, 1, 2, 1, 2, 1].Во втором примере заданный массив уже 4-периодичный.В третьем примере достаточно каждое вхождение двойки заменить на единицу. В этом случае массив примет вид [1, 1, 1, 1, 1, 1, 1, 1, 1] — этот массив одновременно 1-, 3- и 9-периодичный.",
      "solutions": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, сообщество Codeforces!В Саратове продолжается школьная олимпиада, поэтому мы предлагаем вам очередной раунд на базе школьных задач. Раунд будет предназначен для участников из второго дивизиона. Участники из первого дивизиона, как обычно, могут поучаствовать вне конкурса.Раунд начнется 8 декабря в 13:00 MSKЗадачи были подготовлены сотрудниками и студентами Саратовского государственного университета, включая MikeMirzayanov, Fefer_Ivan, NALP, HolkinPV и меня.Разбалловка стандартная: 500-1000-1500-2000-2500.UPD: Поздравляем победителей: asalwaysdontbeahero VKRNVO5 chnluyi pkwv Xe4NIK UPD: Разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 628
        },
        {
          "title": "Codeforces Round #218 (Div. 2): разбор задач - Codeforces",
          "content": "Разбор задач подготовили: Fefer_Ivan, NALP.371A - K-периодичный массивДля того, чтобы массив был периодическим, элементы 1, 1 + k, 1 + 2 * k, ... должны быть равны. Также, элементы 2, 2 + k, 2 + 2 * k, ... должны быть равны. И так далее до k. То есть существует k групп элементов, таких что каждый элемент принадлежит ровно одной группе. Каждая группа может рассматриваться независимо. Рассмотрим группу в которой a единичек и b двоек. Все элементы в одной группе должны быть равны. Для того, чтобы этого достичь необходимо либо все единички сделать двойками (что потребует a операций изменения), либо все двойки сделать единичками (что потребует b операций изменения). Для того, чтобы решение было оптимальным, необходимо выбрать способ, который требует наименьшее количество операций изменения.371B - Как лисица сыр делилаИз условия понятно, что лисица может производить над числами лишь три операции: поделить какое-то из них на 2, поделить на 3 или поделить на 5. Для начала, давайте представим оба числа в форме a = x·2a2·3a3·5a5, b = y·2b2·3b3·5b5, где x и y не делятся ни на 2, ни на 3, ни на 5. Если x ≠ y, то понятно, что как бы лисица не делила числа a и b, то сравнять она их не сможет, а значит, следует вывести “-1”. В противном случае, требуется сравнять степени чисел 2, 3 и 5 в разложениях, за наименьшее количество операций это делается так: от наибольшей степени отнимается единица, пока она не сравняется с меньше степенью. Таким образом, ответ равен |a2 - b2| + |a3 - b3| + |a5 - b5|.371C - ГамбургерыДля решения этой задачи будем использовать идею бинарного поиска по ответу. Предположим, что ответ равен x, необходимо убедиться, что Поликарп сможет собрать именно столько гамбургеров и не потратит больше денег, чем у него есть. Давайте для x подсчитаем, сколько будет стоит собрать эти гамбургеры.Пусть для одного гамбургера требуется сb кусочков хлеб, cs колбасы и cc сыра (эти данные нетрудно подсчитать из строки-рецепта “гамбургера от Поликарпа”). Тогда всего необходимо cb·x кусочков хлеба, cs·x колбасы и cс·x сыра. За лишние ингредиенты Поликарпу придется заплатить, поэтому в сумме он отдаст в магазине max(0, x·cb - nb)·pb + max(0, x·cs - ns)·ps + max(0, x·cc - nc)·pc рублей. Если это значение меньше, чем r, то Поликарп сможет сделать x гамбургеров, а иначе — нет.С помощью бинарного поиска найдем такое максимальное x, что max(0, x·cb - nb)·pb + max(0, x·cs - ns)·ps + max(0, x·cc - nc)·pc ≤ r, такое число и будет ответом на задачу.371D - СосудыНаивное решение этой задачи работает следующим образом. Давайте хранить количество жидкости в каждом сосуде в массиве v. Тогда для ответа на запрос второго типа надо просто взять значение из этого массива. Для выполнения запроса первого типа (налить x жидкости в сосуд i) надо выполнить следующую процедуру: Если x = 0 то вся вода уже использована, закончить процедуру. Если i > n то вся оставшаяся вода будет разлита на пол, закончить процедуру. Если x единиц воды помещаются в сосуд i, то прибавить x к v[i] и закончить процедуру. Заполнить сосуд i полностью и вычесть использованное для этого количество воды из x. Присвоить i = i + 1. Перейти к первому шагу. В худшем случае, такая процедура будет итерироваться по всем сосудам для каждого запроса. Например, если у нас есть n сосудов вместимости 1, то запрос вида 11n потребует O(n) времени на выполнение.Для того, чтобы ускорить решение, необходимо заметить, что как только сосуд будет заполнен, то его можно выкинуть из рассмотрения во время выполнения процедуры наливания.То есть вместо i = i + 1 присвоение должно выглядеть так i = найти_следующий_неполный_сосуд(i).Для реализации этой функция существует множество структур данных. Например, можно использовать упорядоченное множество (set в C++, TreeSet в Java). Давайте поддерживать множество индексов незаполненных сосудов. Тогда для того, чтобы найти следующий сосуд после i-того необходимо найти наименьшее число в множестве, которое строго больше i. Для этого существуют встроенные методы (upper_bound в C++, higher в Java). Так же, каждый раз, когда сосуд заполняется, соответствующий индекс необходимо удалять из множества.Теперь алгоритм выполняет не более, чем O((m + n)logn) операций для всех запросов. Во время каждой итерации процедуры наливания существует два варианта: либо сосуд будет полностью заполнен водой (а такое может произойти только n раз, так как у нас всего n сосудов), либо у нас закончится вода и процедура завершится. Таким образом в сумме будет совершено не более, чем O(m + n) итераций процедуры наливания. Каждая итерация требует не более одного запроса к упорядоченному множеству, следовательно решение работает за O((m + n)logn).371E - Реформа метроЕсли внимательно изучить условие, то нетрудно увидеть, что наименьшее возможное среднее время фактически означает наименьшую сумму попарных расстояний между выбранными k станциями.Сначала давайте отсортируем все станции по их координате. Главная идея в этой задаче заключается в том, что выбранные k станций обязательно будут следовать подряд в этом отсортированном списке. Ограничения не позволяют делать это “в лоб”, поэтому нам необходимо решение быстрее.Определим функцию f(i, k) — попарное расстояние среди k подряд идущих в отсортированном списке станций, начиная с позиции i. Для начала, давайте подсчитаем f(0, k) (здесь и далее будем использовать 0-нумерацию). Это делается несложно за линейное время: по определению f(0, 0) = 0, а по значению f(0, i) найдем значение f(0, i + 1):  = f(0, i) + xi·i - sum(0, i - 1),где функция sum(l, r) означает сумму xi, где l ≤ i ≤ r, значения этой функции легко считаются за O(1) с помощью частичных сумм.Теперь научимся считать по значению f(i, k) значение f(i + 1, k): для этого необходимо исключить из набора координату xi и добавить xi + k. Аналогично выше рассуждениям: f(i + 1, k) = f(i, k) - (sum(i + 1, i + k - 1) - xi·(k - 1)) + (xi + k·(k - 1) - sum(i + 1, i + k - 1)).Таким образом считаются значения f(i, k) для любых корректных значений i. Найдем минимальное значение, где оно достигается и выведем ответ. Решение работает за линейное время.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9876",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 371\\s*A"
          },
          "content_length": 6074
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 1",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 2",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 3",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 4",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 5",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 6",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 7",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 8",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 9",
          "code": "(long long) 1e15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): разбор задач - Codeforces - Code 1",
          "code": "i = найти_следующий_неполный_сосуд(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): разбор задач - Codeforces - Code 2",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): разбор задач - Codeforces - Code 3",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    ensuref(n % k == 0, \"n must be divisible by k\");\n\n    vector<int> a = inf.readInts(n, 1, 2, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    ensuref(n % k == 0, \"n must be divisible by k\");\n\n    vector<int> a = inf.readInts(n, 1, 2, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    ensuref(n % k == 0, \"n must be divisible by k\");\n\n    vector<int> a = inf.readInts(n, 1, 2, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= k && k <= n && n <= 100);\n    ensure(n % k == 0);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Randomly generate each element as 1 or 2\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2); // Random integer between 1 and 2\n        }\n    } else if (type == \"periodic\") {\n        // Generate a random period of length k, and repeat it n / k times\n        vector<int> period(k);\n        for (int i = 0; i < k; ++i) {\n            period[i] = rnd.next(1, 2);\n        }\n        for (int t = 0; t < n / k; ++t) {\n            for (int i = 0; i < k; ++i) {\n                a[t * k + i] = period[i];\n            }\n        }\n    } else if (type == \"almost_periodic\") {\n        int changes = opt<int>(\"changes\", n / 10);\n        // Generate a periodic array\n        vector<int> period(k);\n        for (int i = 0; i < k; ++i) {\n            period[i] = rnd.next(1, 2);\n        }\n        for (int t = 0; t < n / k; ++t) {\n            for (int i = 0; i < k; ++i) {\n                a[t * k + i] = period[i];\n            }\n        }\n        // Introduce some changes\n        set<int> changed_positions;\n        for (int i = 0; i < changes; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(0, n - 1);\n            } while (changed_positions.count(pos));\n            changed_positions.insert(pos);\n            // Flip the element at position pos\n            a[pos] = 3 - a[pos];\n        }\n    } else if (type == \"max_change\") {\n        int t = n / k;\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < t; ++j) {\n                int pos = i + j * k;\n                a[pos] = ((j % 2) == 0) ? 1 : 2;\n            }\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 2);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 2;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"twos\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= k && k <= n && n <= 100);\n    ensure(n % k == 0);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Randomly generate each element as 1 or 2\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2); // Random integer between 1 and 2\n        }\n    } else if (type == \"periodic\") {\n        // Generate a random period of length k, and repeat it n / k times\n        vector<int> period(k);\n        for (int i = 0; i < k; ++i) {\n            period[i] = rnd.next(1, 2);\n        }\n        for (int t = 0; t < n / k; ++t) {\n            for (int i = 0; i < k; ++i) {\n                a[t * k + i] = period[i];\n            }\n        }\n    } else if (type == \"almost_periodic\") {\n        int changes = opt<int>(\"changes\", n / 10);\n        // Generate a periodic array\n        vector<int> period(k);\n        for (int i = 0; i < k; ++i) {\n            period[i] = rnd.next(1, 2);\n        }\n        for (int t = 0; t < n / k; ++t) {\n            for (int i = 0; i < k; ++i) {\n                a[t * k + i] = period[i];\n            }\n        }\n        // Introduce some changes\n        set<int> changed_positions;\n        for (int i = 0; i < changes; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(0, n - 1);\n            } while (changed_positions.count(pos));\n            changed_positions.insert(pos);\n            // Flip the element at position pos\n            a[pos] = 3 - a[pos];\n        }\n    } else if (type == \"max_change\") {\n        int t = n / k;\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < t; ++j) {\n                int pos = i + j * k;\n                a[pos] = ((j % 2) == 0) ? 1 : 2;\n            }\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 2);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 2;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"twos\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type ones\n./gen -n 1 -k 1 -type twos\n./gen -n 1 -k 1 -type random\n./gen -n 2 -k 1 -type alternate\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 5 -type periodic\n./gen -n 10 -k 5 -type almost_periodic -changes 1\n./gen -n 10 -k 5 -type almost_periodic -changes 2\n./gen -n 20 -k 4 -type max_change\n./gen -n 20 -k 4 -type periodic\n./gen -n 20 -k 10 -type random\n./gen -n 30 -k 6 -type max_change\n./gen -n 50 -k 25 -type random\n./gen -n 50 -k 25 -type almost_periodic -changes 5\n./gen -n 50 -k 25 -type max_change\n./gen -n 100 -k 1 -type max_change\n./gen -n 100 -k 2 -type random\n./gen -n 100 -k 2 -type almost_periodic -changes 10\n./gen -n 100 -k 4 -type periodic\n./gen -n 100 -k 20 -type alternate\n./gen -n 100 -k 25 -type ones\n./gen -n 100 -k 25 -type twos\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 50 -type almost_periodic -changes 10\n./gen -n 100 -k 50 -type periodic\n./gen -n 100 -k 50 -type max_change\n./gen -n 100 -k 100 -type random\n./gen -n 100 -k 100 -type periodic\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:18.150494",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "371/B",
      "title": "B. Fox Dividing Cheese",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers a and b (1 ≤ a, b ≤ 109).",
      "output_spec": "OutputIf the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.",
      "sample_tests": "ExamplesInputCopy15 20OutputCopy3InputCopy14 8OutputCopy-1InputCopy6 6OutputCopy0",
      "description": "B. Fox Dividing Cheese\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers a and b (1 ≤ a, b ≤ 109).\n\nOutputIf the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.\n\nInputCopy15 20OutputCopy3InputCopy14 8OutputCopy-1InputCopy6 6OutputCopy0\n\nInputCopy15 20\n\nOutputCopy3\n\nInputCopy14 8\n\nOutputCopy-1\n\nInputCopy6 6\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Today in Saratov there is a second day of the local school competition, so we again introduce you a round based on school problemset. Round is for participants from Division II. Members of the first division can participate out of competition, as usual.Round starts on 8-th of December at 09:00 UTCProblems were prepared by employees and students of Saratov State U, including MikeMirzayanov, Fefer_Ivan, NALP, HolkinPV and me.Scoring: 500-1000-1500-2000-2500.UPD: Congratulations to the winners: asalwaysdontbeahero VKRNVO5 chnluyi pkwv Xe4NIK UPD: tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 597
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces",
          "content": "The tutorial has been prepared by Fefer_Ivan and NALP.371A - K-Periodic ArrayFor array to be periodic, elements 1, 1 + k, 1 + 2 * k, … must be equal. Also, elements 2, 2 + k, 2 + 2 * k, … must be equal. And so on up to k. So each element of the array is a part of exactly one group. And there are k groups total. Each such group is independent. Let’s consider some group of elements, that contain a ones and b twos. All elements in this group must be equal. So we either change all ones to twos or all twos to ones. First option will require a changing operations and second one — b changing operations. For the optimal solution, you should select the operation with smaller number of changing operations required.371B - Fox Dividing CheeseIt is easy to see that the fox can do three type of operations: divide by 2, divide by 3 and divide by 5. Let’s write both given numbers in form a = x·2a2·3a3·5a5, b = y·2b2·3b3·5b5, where x and y are not dibisible by 2, 3 and 5. If x ≠ y the fox can’t make numbers equal and program should print -1. If x = y then soluion exists. The answer equals to |a2 - b2| + |a3 - b3| + |a5 - b5|, because |a2 - b2| is the minimal number of operations to have 2 in the same power in both numbers, |a3 - b3| is the minimal number of operations to have 3 in the same power in both numbers, and |a5 - b5| is the same for 5.371C - HamburgersLet's use binary search approach. For given number of hamburgers (say, x) let's find the minimal number of money needed to cook them. Say, for one hamburger Polycarpus needs cb bread pieces, cs sausages pieces, cc cheese pieces. So for x hamburgers he needs: cb·x, cs·x and cc·x pieces (by types). Since he already has nb, ns and nc pieces, so he needs to buy: bread: max(0, cb·x - nb), sausages: max(0, cs·x - ns), cheese: max(0, cc·x - nc). So the formula to calculate money to cook x hamburgers is: f(x) = max(0, cb·x - nb)·pb + max(0, cs·x - ns)·ps + max(0, cc·x - nc)·pcObviously, the function f(x) is monotonic (increasing). So it is possible to use binary search approach to find largest x such that f(x) ler.371D - VesselsThe naive solution for this problem will work like this. Let us store an amount of water in each vessel in some array v. If we need to know how much water is in some vessel, we just take the number from the array. If we need to pour x units of water into vessel number i, we must follow the simple procedure: 1. If x = 0 then all water is poured and we must end the procedure 2. If i > n then all remaining water is spilled on the floor and we must end the procedure 3. If x units of water can fit into the i-th vessel, then add x to v[i] and end the procedure 4. Fill i-th vessel completely and subtract used amount from x. 5. Assign i = i + 1. 6. Go to the first step.In the worst case scenario such procedure can iterate through all vessels each time. For example, if there are n vessels and each vessels have capacity of one unit of water, each query like 11n will take O(n) time to process.To make this solution faster we should notice, that once completely filled, vessel can be skipped during the algorithm above because it can not consume any more water.So instead of i = i + 1 assignment should be like i = findNextNotFilledVessel(i). To implement this function we can use different structures. For example, we can use sorted set of numbers (set in C++, TreeSet in Java). Let store the set of indices of unfilled vessels. So to find next not filled vessel from i-th vessel, we must find smallest number, that is contained in set and is strictly greater than i. There are built-in methods for it (upper_bound in C++, higher in Java). Also, each time we fill the vessel, we must erase corresponding index from the set.So now we can see, that algorithm can not complete more that O((m + n)logn) operations for all queries. Because on each iteration of the pouring procedure either the vessel is filled (which can only happen n times during the whole runtime), or we run out of water (or vessels) and the procedure is stopped. So there will be only total of O(m + n) iterations of the pouring procedure and each iteration require one lookup in the sorted set, which takes O(logn) operations. So the total number of needed operations is O((m + n)logn).371E - Subway InnovationIt is easy to see that you need to minimize the sum of pairwise distances between k stations. The main idea to do it is to sort them and the required stations will form a continuous segment. It is easy to prove by contradiction.Huge constraints do not allow to use straight-forward method to find required segment. Let’s call f(i, k) — sum of pairwise distances of k stations starting from the i-th. To find f(0, k) you need to start from f(0, 0) = 0 and use transformation from calculated f(0, i) to f(0, i + 1). You can use equation:  = f(0, i) + xi·i - sum(0, i - 1)where sum(l, r) means xl + xl + 1 + ... + xr. We can precalculate sum[i] = x0 + x1 + ... + xi and use equation sum(l, r) = sum[r] - sum[l - 1] to find sum(l, r) in O(1).Actually we need f(0, k), f(1, k) and so on (and find minimal value among them).To recalculate f(i, k) to f(i + 1, k) you need exclude xi and include xi + k. Using the method like in the previous paragraph: f(i + 1, k) = f(i, k) - (sum(i + 1, i + k - 1) - xi·(k - 1)) + (xi + k·(k - 1) - sum(i + 1, i + k - 1)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9876",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 371\\s*B"
          },
          "content_length": 5325
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 1",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 2",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 3",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 4",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 5",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 6",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 7",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 8",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 1",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 2",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> powers_of_2;\nvector<long long> powers_of_3;\nvector<long long> powers_of_5;\n\nvoid precompute_powers() {\n    long long val;\n    val = 1;\n    powers_of_2.push_back(val);\n    while (val <= 1e9 / 2) {\n        val *= 2;\n        powers_of_2.push_back(val);\n    }\n\n    val = 1;\n    powers_of_3.push_back(val);\n    while (val <= 1e9 / 3) {\n        val *= 3;\n        powers_of_3.push_back(val);\n    }\n\n    val = 1;\n    powers_of_5.push_back(val);\n    while (val <= 1e9 / 5) {\n        val *= 5;\n        powers_of_5.push_back(val);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int maxN = opt<int>(\"maxN\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    precompute_powers();\n\n    long long a, b;\n\n    if (type == \"equal\") {\n        // Generate equal numbers\n        a = b = rnd.next(1LL, (long long)maxN);\n    } else if (type == \"possible\") {\n        // Generate numbers possible to reduce to equal\n\n        // Generate a random remainder that has no factors of 2, 3, or 5\n        int remain = rnd.next(1, 10000);\n        while (remain % 2 == 0 || remain % 3 == 0 || remain % 5 == 0) {\n            remain = rnd.next(1, 10000);\n        }\n\n        // Random exponents for a\n        int exp2_a = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_a = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_a = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Random exponents for b\n        int exp2_b = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_b = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_b = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Compute a and b\n        a = remain * powers_of_2[exp2_a] * powers_of_3[exp3_a] * powers_of_5[exp5_a];\n        b = remain * powers_of_2[exp2_b] * powers_of_3[exp3_b] * powers_of_5[exp5_b];\n\n        // Ensure a and b are within bounds\n        if (a > maxN) a = remain;\n        if (b > maxN) b = remain;\n\n    } else if (type == \"impossible\") {\n        // Generate numbers impossible to reduce to equal\n\n        // Generate two distinct remainders without factors of 2, 3, or 5\n        int remainA = rnd.next(2, 10000);\n        int remainB = rnd.next(2, 10000);\n        while (remainA % 2 == 0 || remainA % 3 == 0 || remainA % 5 == 0) {\n            remainA = rnd.next(2, 10000);\n        }\n        while (remainB % 2 == 0 || remainB % 3 == 0 || remainB % 5 == 0 || remainB == remainA) {\n            remainB = rnd.next(2, 10000);\n        }\n\n        // Random exponents for a\n        int exp2_a = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_a = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_a = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Random exponents for b\n        int exp2_b = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_b = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_b = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Compute a and b\n        a = remainA * powers_of_2[exp2_a] * powers_of_3[exp3_a] * powers_of_5[exp5_a];\n        b = remainB * powers_of_2[exp2_b] * powers_of_3[exp3_b] * powers_of_5[exp5_b];\n\n        // Ensure a and b are within bounds\n        if (a > maxN) a = remainA;\n        if (b > maxN) b = remainB;\n\n    } else if (type == \"random\") {\n        // Generate random numbers\n        a = rnd.next(1LL, (long long)maxN);\n        b = rnd.next(1LL, (long long)maxN);\n    }\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> powers_of_2;\nvector<long long> powers_of_3;\nvector<long long> powers_of_5;\n\nvoid precompute_powers() {\n    long long val;\n    val = 1;\n    powers_of_2.push_back(val);\n    while (val <= 1e9 / 2) {\n        val *= 2;\n        powers_of_2.push_back(val);\n    }\n\n    val = 1;\n    powers_of_3.push_back(val);\n    while (val <= 1e9 / 3) {\n        val *= 3;\n        powers_of_3.push_back(val);\n    }\n\n    val = 1;\n    powers_of_5.push_back(val);\n    while (val <= 1e9 / 5) {\n        val *= 5;\n        powers_of_5.push_back(val);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int maxN = opt<int>(\"maxN\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    precompute_powers();\n\n    long long a, b;\n\n    if (type == \"equal\") {\n        // Generate equal numbers\n        a = b = rnd.next(1LL, (long long)maxN);\n    } else if (type == \"possible\") {\n        // Generate numbers possible to reduce to equal\n\n        // Generate a random remainder that has no factors of 2, 3, or 5\n        int remain = rnd.next(1, 10000);\n        while (remain % 2 == 0 || remain % 3 == 0 || remain % 5 == 0) {\n            remain = rnd.next(1, 10000);\n        }\n\n        // Random exponents for a\n        int exp2_a = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_a = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_a = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Random exponents for b\n        int exp2_b = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_b = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_b = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Compute a and b\n        a = remain * powers_of_2[exp2_a] * powers_of_3[exp3_a] * powers_of_5[exp5_a];\n        b = remain * powers_of_2[exp2_b] * powers_of_3[exp3_b] * powers_of_5[exp5_b];\n\n        // Ensure a and b are within bounds\n        if (a > maxN) a = remain;\n        if (b > maxN) b = remain;\n\n    } else if (type == \"impossible\") {\n        // Generate numbers impossible to reduce to equal\n\n        // Generate two distinct remainders without factors of 2, 3, or 5\n        int remainA = rnd.next(2, 10000);\n        int remainB = rnd.next(2, 10000);\n        while (remainA % 2 == 0 || remainA % 3 == 0 || remainA % 5 == 0) {\n            remainA = rnd.next(2, 10000);\n        }\n        while (remainB % 2 == 0 || remainB % 3 == 0 || remainB % 5 == 0 || remainB == remainA) {\n            remainB = rnd.next(2, 10000);\n        }\n\n        // Random exponents for a\n        int exp2_a = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_a = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_a = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Random exponents for b\n        int exp2_b = rnd.next(0, (int)powers_of_2.size() - 1);\n        int exp3_b = rnd.next(0, (int)powers_of_3.size() - 1);\n        int exp5_b = rnd.next(0, (int)powers_of_5.size() - 1);\n\n        // Compute a and b\n        a = remainA * powers_of_2[exp2_a] * powers_of_3[exp3_a] * powers_of_5[exp5_a];\n        b = remainB * powers_of_2[exp2_b] * powers_of_3[exp3_b] * powers_of_5[exp5_b];\n\n        // Ensure a and b are within bounds\n        if (a > maxN) a = remainA;\n        if (b > maxN) b = remainB;\n\n    } else if (type == \"random\") {\n        // Generate random numbers\n        a = rnd.next(1LL, (long long)maxN);\n        b = rnd.next(1LL, (long long)maxN);\n    }\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Equal numbers with small values\n./gen -type equal -maxN 1\n./gen -type equal -maxN 10\n./gen -type equal -maxN 100\n\n# Equal numbers with large values\n./gen -type equal -maxN 10000\n./gen -type equal -maxN 1000000\n./gen -type equal -maxN 1000000000\n\n# Possible to make equal, small values\n./gen -type possible -maxN 10\n./gen -type possible -maxN 100\n\n# Possible to make equal, medium values\n./gen -type possible -maxN 10000\n./gen -type possible -maxN 1000000\n\n# Possible to make equal, large values\n./gen -type possible -maxN 1000000000\n\n# Impossible to make equal, small values\n./gen -type impossible -maxN 10\n./gen -type impossible -maxN 100\n\n# Impossible to make equal, medium values\n./gen -type impossible -maxN 10000\n./gen -type impossible -maxN 1000000\n\n# Impossible to make equal, large values\n./gen -type impossible -maxN 1000000000\n\n# Random test cases with varying sizes\n./gen -type random -maxN 1\n./gen -type random -maxN 10\n./gen -type random -maxN 100\n./gen -type random -maxN 10000\n./gen -type random -maxN 1000000\n./gen -type random -maxN 1000000000\n\n# Additional random cases\n./gen -type random -maxN 1000000000\n./gen -type random -maxN 1000000000\n./gen -type random -maxN 1000000000\n./gen -type random -maxN 1000000000\n./gen -type random -maxN 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:20.897167",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "371/C",
      "title": "C. Hamburgers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a non-empty string that describes the recipe of \"Le Hamburger de Polycarpus\". The length of the string doesn't exceed 100, the string contains only letters 'B' (uppercase English B), 'S' (uppercase English S) and 'C' (uppercase English C).The second line contains three integers nb, ns, nc (1 ≤ nb, ns, nc ≤ 100) — the number of the pieces of bread, sausage and cheese on Polycarpus' kitchen. The third line contains three integers pb, ps, pc (1 ≤ pb, ps, pc ≤ 100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer r (1 ≤ r ≤ 1012) — the number of rubles Polycarpus has.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint the maximum number of hamburgers Polycarpus can make. If he can't make any hamburger, print 0.",
      "sample_tests": "ExamplesInputCopyBBBSSC6 4 11 2 34OutputCopy2InputCopyBBC1 10 11 10 121OutputCopy7InputCopyBSC1 1 11 1 31000000000000OutputCopy200000000001",
      "description": "C. Hamburgers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains a non-empty string that describes the recipe of \"Le Hamburger de Polycarpus\". The length of the string doesn't exceed 100, the string contains only letters 'B' (uppercase English B), 'S' (uppercase English S) and 'C' (uppercase English C).The second line contains three integers nb, ns, nc (1 ≤ nb, ns, nc ≤ 100) — the number of the pieces of bread, sausage and cheese on Polycarpus' kitchen. The third line contains three integers pb, ps, pc (1 ≤ pb, ps, pc ≤ 100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer r (1 ≤ r ≤ 1012) — the number of rubles Polycarpus has.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint the maximum number of hamburgers Polycarpus can make. If he can't make any hamburger, print 0.\n\nInputCopyBBBSSC6 4 11 2 34OutputCopy2InputCopyBBC1 10 11 10 121OutputCopy7InputCopyBSC1 1 11 1 31000000000000OutputCopy200000000001\n\nInputCopyBBBSSC6 4 11 2 34\n\nOutputCopy2\n\nInputCopyBBC1 10 11 10 121\n\nOutputCopy7\n\nInputCopyBSC1 1 11 1 31000000000000\n\nOutputCopy200000000001",
      "solutions": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Today in Saratov there is a second day of the local school competition, so we again introduce you a round based on school problemset. Round is for participants from Division II. Members of the first division can participate out of competition, as usual.Round starts on 8-th of December at 09:00 UTCProblems were prepared by employees and students of Saratov State U, including MikeMirzayanov, Fefer_Ivan, NALP, HolkinPV and me.Scoring: 500-1000-1500-2000-2500.UPD: Congratulations to the winners: asalwaysdontbeahero VKRNVO5 chnluyi pkwv Xe4NIK UPD: tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 597
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces",
          "content": "The tutorial has been prepared by Fefer_Ivan and NALP.371A - K-Periodic ArrayFor array to be periodic, elements 1, 1 + k, 1 + 2 * k, … must be equal. Also, elements 2, 2 + k, 2 + 2 * k, … must be equal. And so on up to k. So each element of the array is a part of exactly one group. And there are k groups total. Each such group is independent. Let’s consider some group of elements, that contain a ones and b twos. All elements in this group must be equal. So we either change all ones to twos or all twos to ones. First option will require a changing operations and second one — b changing operations. For the optimal solution, you should select the operation with smaller number of changing operations required.371B - Fox Dividing CheeseIt is easy to see that the fox can do three type of operations: divide by 2, divide by 3 and divide by 5. Let’s write both given numbers in form a = x·2a2·3a3·5a5, b = y·2b2·3b3·5b5, where x and y are not dibisible by 2, 3 and 5. If x ≠ y the fox can’t make numbers equal and program should print -1. If x = y then soluion exists. The answer equals to |a2 - b2| + |a3 - b3| + |a5 - b5|, because |a2 - b2| is the minimal number of operations to have 2 in the same power in both numbers, |a3 - b3| is the minimal number of operations to have 3 in the same power in both numbers, and |a5 - b5| is the same for 5.371C - HamburgersLet's use binary search approach. For given number of hamburgers (say, x) let's find the minimal number of money needed to cook them. Say, for one hamburger Polycarpus needs cb bread pieces, cs sausages pieces, cc cheese pieces. So for x hamburgers he needs: cb·x, cs·x and cc·x pieces (by types). Since he already has nb, ns and nc pieces, so he needs to buy: bread: max(0, cb·x - nb), sausages: max(0, cs·x - ns), cheese: max(0, cc·x - nc). So the formula to calculate money to cook x hamburgers is: f(x) = max(0, cb·x - nb)·pb + max(0, cs·x - ns)·ps + max(0, cc·x - nc)·pcObviously, the function f(x) is monotonic (increasing). So it is possible to use binary search approach to find largest x such that f(x) ler.371D - VesselsThe naive solution for this problem will work like this. Let us store an amount of water in each vessel in some array v. If we need to know how much water is in some vessel, we just take the number from the array. If we need to pour x units of water into vessel number i, we must follow the simple procedure: 1. If x = 0 then all water is poured and we must end the procedure 2. If i > n then all remaining water is spilled on the floor and we must end the procedure 3. If x units of water can fit into the i-th vessel, then add x to v[i] and end the procedure 4. Fill i-th vessel completely and subtract used amount from x. 5. Assign i = i + 1. 6. Go to the first step.In the worst case scenario such procedure can iterate through all vessels each time. For example, if there are n vessels and each vessels have capacity of one unit of water, each query like 11n will take O(n) time to process.To make this solution faster we should notice, that once completely filled, vessel can be skipped during the algorithm above because it can not consume any more water.So instead of i = i + 1 assignment should be like i = findNextNotFilledVessel(i). To implement this function we can use different structures. For example, we can use sorted set of numbers (set in C++, TreeSet in Java). Let store the set of indices of unfilled vessels. So to find next not filled vessel from i-th vessel, we must find smallest number, that is contained in set and is strictly greater than i. There are built-in methods for it (upper_bound in C++, higher in Java). Also, each time we fill the vessel, we must erase corresponding index from the set.So now we can see, that algorithm can not complete more that O((m + n)logn) operations for all queries. Because on each iteration of the pouring procedure either the vessel is filled (which can only happen n times during the whole runtime), or we run out of water (or vessels) and the procedure is stopped. So there will be only total of O(m + n) iterations of the pouring procedure and each iteration require one lookup in the sorted set, which takes O(logn) operations. So the total number of needed operations is O((m + n)logn).371E - Subway InnovationIt is easy to see that you need to minimize the sum of pairwise distances between k stations. The main idea to do it is to sort them and the required stations will form a continuous segment. It is easy to prove by contradiction.Huge constraints do not allow to use straight-forward method to find required segment. Let’s call f(i, k) — sum of pairwise distances of k stations starting from the i-th. To find f(0, k) you need to start from f(0, 0) = 0 and use transformation from calculated f(0, i) to f(0, i + 1). You can use equation:  = f(0, i) + xi·i - sum(0, i - 1)where sum(l, r) means xl + xl + 1 + ... + xr. We can precalculate sum[i] = x0 + x1 + ... + xi and use equation sum(l, r) = sum[r] - sum[l - 1] to find sum(l, r) in O(1).Actually we need f(0, k), f(1, k) and so on (and find minimal value among them).To recalculate f(i, k) to f(i + 1, k) you need exclude xi and include xi + k. Using the method like in the previous paragraph: f(i + 1, k) = f(i, k) - (sum(i + 1, i + k - 1) - xi·(k - 1)) + (xi + k·(k - 1) - sum(i + 1, i + k - 1)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9876",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 371\\s*C"
          },
          "content_length": 5325
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 1",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 2",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 3",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 4",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 5",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 6",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 7",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 8",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 1",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 2",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string recipe = inf.readToken(\"[BSC]{1,100}\", \"recipe\");\n    inf.readEoln();\n\n    int nb = inf.readInt(1, 100, \"nb\");\n    inf.readSpace();\n    int ns = inf.readInt(1, 100, \"ns\");\n    inf.readSpace();\n    int nc = inf.readInt(1, 100, \"nc\");\n    inf.readEoln();\n\n    int pb = inf.readInt(1, 100, \"pb\");\n    inf.readSpace();\n    int ps = inf.readInt(1, 100, \"ps\");\n    inf.readSpace();\n    int pc = inf.readInt(1, 100, \"pc\");\n    inf.readEoln();\n\n    long long r = inf.readLong(1LL, 1000000000000LL, \"r\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string recipe = inf.readToken(\"[BSC]{1,100}\", \"recipe\");\n    inf.readEoln();\n\n    int nb = inf.readInt(1, 100, \"nb\");\n    inf.readSpace();\n    int ns = inf.readInt(1, 100, \"ns\");\n    inf.readSpace();\n    int nc = inf.readInt(1, 100, \"nc\");\n    inf.readEoln();\n\n    int pb = inf.readInt(1, 100, \"pb\");\n    inf.readSpace();\n    int ps = inf.readInt(1, 100, \"ps\");\n    inf.readSpace();\n    int pc = inf.readInt(1, 100, \"pc\");\n    inf.readEoln();\n\n    long long r = inf.readLong(1LL, 1000000000000LL, \"r\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string recipe = inf.readToken(\"[BSC]{1,100}\", \"recipe\");\n    inf.readEoln();\n\n    int nb = inf.readInt(1, 100, \"nb\");\n    inf.readSpace();\n    int ns = inf.readInt(1, 100, \"ns\");\n    inf.readSpace();\n    int nc = inf.readInt(1, 100, \"nc\");\n    inf.readEoln();\n\n    int pb = inf.readInt(1, 100, \"pb\");\n    inf.readSpace();\n    int ps = inf.readInt(1, 100, \"ps\");\n    inf.readSpace();\n    int pc = inf.readInt(1, 100, \"pc\");\n    inf.readEoln();\n\n    long long r = inf.readLong(1LL, 1000000000000LL, \"r\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int len = opt<int>(\"len\");\n\n    int nb = opt<int>(\"nb\", -1);\n    int ns = opt<int>(\"ns\", -1);\n    int nc = opt<int>(\"nc\", -1);\n\n    int pb = opt<int>(\"pb\", -1);\n    int ps = opt<int>(\"ps\", -1);\n    int pc = opt<int>(\"pc\", -1);\n\n    long long r = opt<long long>(\"r\", -1);\n\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    // Generate the recipe\n    string recipe;\n\n    if (type == \"only_B\") {\n        // Recipe contains only 'B's\n        recipe = string(len, 'B');\n    } else if (type == \"only_S\") {\n        // Recipe contains only 'S's\n        recipe = string(len, 'S');\n    } else if (type == \"only_C\") {\n        // Recipe contains only 'C's\n        recipe = string(len, 'C');\n    } else {\n        // Random recipe\n        string ingredients = \"BSC\";\n        for(int i = 0; i < len; ++i) {\n            char c = ingredients[rnd.next(0,2)];\n            recipe += c;\n        }\n    }\n\n    if(nb == -1) {\n        nb = rnd.next(1, 100);\n    }\n    if(ns == -1) {\n        ns = rnd.next(1, 100);\n    }\n    if(nc == -1) {\n        nc = rnd.next(1, 100);\n    }\n\n    if(pb == -1) {\n        pb = rnd.next(1, 100);\n    }\n    if(ps == -1) {\n        ps = rnd.next(1, 100);\n    }\n    if(pc == -1) {\n        pc = rnd.next(1, 100);\n    }\n    if(r == -1) {\n        if(type == \"max_r\") {\n            r = 1000000000000LL;\n        } else {\n            r = rnd.next(1LL, 1000000000000LL);\n        }\n    }\n\n    // Output according to problem format\n    cout << recipe << endl;\n    cout << nb << \" \" << ns << \" \" << nc << endl;\n    cout << pb << \" \" << ps << \" \" << pc << endl;\n    cout << r << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int len = opt<int>(\"len\");\n\n    int nb = opt<int>(\"nb\", -1);\n    int ns = opt<int>(\"ns\", -1);\n    int nc = opt<int>(\"nc\", -1);\n\n    int pb = opt<int>(\"pb\", -1);\n    int ps = opt<int>(\"ps\", -1);\n    int pc = opt<int>(\"pc\", -1);\n\n    long long r = opt<long long>(\"r\", -1);\n\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    // Generate the recipe\n    string recipe;\n\n    if (type == \"only_B\") {\n        // Recipe contains only 'B's\n        recipe = string(len, 'B');\n    } else if (type == \"only_S\") {\n        // Recipe contains only 'S's\n        recipe = string(len, 'S');\n    } else if (type == \"only_C\") {\n        // Recipe contains only 'C's\n        recipe = string(len, 'C');\n    } else {\n        // Random recipe\n        string ingredients = \"BSC\";\n        for(int i = 0; i < len; ++i) {\n            char c = ingredients[rnd.next(0,2)];\n            recipe += c;\n        }\n    }\n\n    if(nb == -1) {\n        nb = rnd.next(1, 100);\n    }\n    if(ns == -1) {\n        ns = rnd.next(1, 100);\n    }\n    if(nc == -1) {\n        nc = rnd.next(1, 100);\n    }\n\n    if(pb == -1) {\n        pb = rnd.next(1, 100);\n    }\n    if(ps == -1) {\n        ps = rnd.next(1, 100);\n    }\n    if(pc == -1) {\n        pc = rnd.next(1, 100);\n    }\n    if(r == -1) {\n        if(type == \"max_r\") {\n            r = 1000000000000LL;\n        } else {\n            r = rnd.next(1LL, 1000000000000LL);\n        }\n    }\n\n    // Output according to problem format\n    cout << recipe << endl;\n    cout << nb << \" \" << ns << \" \" << nc << endl;\n    cout << pb << \" \" << ps << \" \" << pc << endl;\n    cout << r << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying lengths\n./gen -len 10 -type random\n./gen -len 20 -type random\n./gen -len 50 -type random\n./gen -len 100 -type random\n\n# Test cases with only one ingredient in the recipe\n./gen -len 100 -type only_B\n./gen -len 100 -type only_S\n./gen -len 100 -type only_C\n\n# Maximum initial counts\n./gen -len 100 -type random -nb 100 -ns 100 -nc 100\n\n# Minimum initial counts\n./gen -len 100 -type random -nb 1 -ns 1 -nc 1\n\n# Maximum prices\n./gen -len 100 -type random -pb 100 -ps 100 -pc 100\n\n# Minimum prices\n./gen -len 100 -type random -pb 1 -ps 1 -pc 1\n\n# Maximum amount of money\n./gen -len 100 -type random -r 1000000000000\n\n# Minimal amount of money\n./gen -len 100 -type random -r 1\n\n# Large answer test case (to test for overflows)\n./gen -len 100 -type random -nb 1 -ns 1 -nc 1 -pb 1 -ps 1 -pc 1 -r 1000000000000\n\n# Small answer test case\n./gen -len 1 -type random -nb 1 -ns 1 -nc 1 -pb 100 -ps 100 -pc 100 -r 1\n\n# All parameters at maximum\n./gen -len 100 -type random -nb 100 -ns 100 -nc 100 -pb 100 -ps 100 -pc 100 -r 1000000000000\n\n# All parameters at minimum\n./gen -len 1 -type random -nb 1 -ns 1 -nc 1 -pb 1 -ps 1 -pc 1 -r 1\n\n# Edge case: Only 'B's, maximum counts\n./gen -len 100 -type only_B -nb 100 -ns 1 -nc 1 -pb 1 -ps 1 -pc 1 -r 1\n\n# Edge case: Only 'S's, maximum counts\n./gen -len 100 -type only_S -nb 1 -ns 100 -nc 1 -pb 1 -ps 1 -pc 1 -r 1\n\n# Edge case: Only 'C's, maximum counts\n./gen -len 100 -type only_C -nb 1 -ns 1 -nc 100 -pb 1 -ps 1 -pc 1 -r 1\n\n# Edge case: Max counts and minimal prices, maximum r\n./gen -len 100 -type random -nb 100 -ns 100 -nc 100 -pb 1 -ps 1 -pc 1 -r 1000000000000\n\n# Edge case: Min counts and maximum prices, minimal r\n./gen -len 1 -type random -nb 1 -ns 1 -nc 1 -pb 100 -ps 100 -pc 100 -r 1\n\n# Edge case: Maximum counts and maximum prices, maximum r\n./gen -len 100 -type random -nb 100 -ns 100 -nc 100 -pb 100 -ps 100 -pc 100 -r 1000000000000\n\n# Edge case: Minimal counts and minimal prices, minimal r\n./gen -len 1 -type random -nb 1 -ns 1 -nc 1 -pb 1 -ps 1 -pc 1 -r 1\n\n# Edge case: Recipe uses only one ingredient with minimal counts and maximal r\n./gen -len 100 -type only_B -nb 1 -ns 1 -nc 1 -pb 1 -ps 1 -pc 1 -r 1000000000000\n\n# Edge case: Recipe uses all three ingredients equally\n./gen -len 99 -type random -nb 1 -ns 1 -nc 1 -pb 1 -ps 1 -pc 1 -r 1000000000000\n\n# Edge case: Very long recipe with minimal counts, minimal prices, max r\n./gen -len 100 -type random -nb 1 -ns 1 -nc 1 -pb 1 -ps 1 -pc 1 -r 1000000000000\n\n# Random test cases\n./gen -len 57 -type random\n./gen -len 89 -type random\n\n# Random test cases with extreme counts and prices\n./gen -len 34 -type random -nb 100 -ns 1 -nc 50 -pb 10 -ps 90 -pc 55\n\n# Random test cases with random r\n./gen -len 73 -type random -r 500000000000\n\n# Random test cases with random initial counts and prices\n./gen -len 85 -type random -nb 50 -ns 75 -nc 25 -pb 97 -ps 3 -pc 60 -r 650000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:22.677326",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "371/D",
      "title": "D. Vessels",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n — the number of vessels (1 ≤ n ≤ 2·105). The second line contains n integers a1, a2, ..., an — the vessels' capacities (1 ≤ ai ≤ 109). The vessels' capacities do not necessarily increase from the top vessels to the bottom ones (see the second sample). The third line contains integer m — the number of queries (1 ≤ m ≤ 2·105). Each of the next m lines contains the description of one query. The query of the first type is represented as \"1 pi xi\", the query of the second type is represented as \"2 ki\" (1 ≤ pi ≤ n, 1 ≤ xi ≤ 109, 1 ≤ ki ≤ n).",
      "output_spec": "OutputFor each query, print on a single line the number of liters of water in the corresponding vessel.",
      "sample_tests": "ExamplesInputCopy25 1061 1 42 11 2 51 1 42 12 2OutputCopy458InputCopy35 10 861 1 122 21 1 61 3 22 22 3OutputCopy7105",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n — the number of vessels (1 ≤ n ≤ 2·105). The second line contains n integers a1, a2, ..., an — the vessels' capacities (1 ≤ ai ≤ 109). The vessels' capacities do not necessarily increase from the top vessels to the bottom ones (see the second sample). The third line contains integer m — the number of queries (1 ≤ m ≤ 2·105). Each of the next m lines contains the description of one query. The query of the first type is represented as \"1 pi xi\", the query of the second type is represented as \"2 ki\" (1 ≤ pi ≤ n, 1 ≤ xi ≤ 109, 1 ≤ ki ≤ n).\n\nOutputFor each query, print on a single line the number of liters of water in the corresponding vessel.\n\nInputCopy25 1061 1 42 11 2 51 1 42 12 2OutputCopy458InputCopy35 10 861 1 122 21 1 61 3 22 22 3OutputCopy7105\n\nInputCopy25 1061 1 42 11 2 51 1 42 12 2\n\nOutputCopy458\n\nInputCopy35 10 861 1 122 21 1 61 3 22 22 3\n\nOutputCopy7105",
      "solutions": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Today in Saratov there is a second day of the local school competition, so we again introduce you a round based on school problemset. Round is for participants from Division II. Members of the first division can participate out of competition, as usual.Round starts on 8-th of December at 09:00 UTCProblems were prepared by employees and students of Saratov State U, including MikeMirzayanov, Fefer_Ivan, NALP, HolkinPV and me.Scoring: 500-1000-1500-2000-2500.UPD: Congratulations to the winners: asalwaysdontbeahero VKRNVO5 chnluyi pkwv Xe4NIK UPD: tutorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 597
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces",
          "content": "The tutorial has been prepared by Fefer_Ivan and NALP.371A - K-Periodic ArrayFor array to be periodic, elements 1, 1 + k, 1 + 2 * k, … must be equal. Also, elements 2, 2 + k, 2 + 2 * k, … must be equal. And so on up to k. So each element of the array is a part of exactly one group. And there are k groups total. Each such group is independent. Let’s consider some group of elements, that contain a ones and b twos. All elements in this group must be equal. So we either change all ones to twos or all twos to ones. First option will require a changing operations and second one — b changing operations. For the optimal solution, you should select the operation with smaller number of changing operations required.371B - Fox Dividing CheeseIt is easy to see that the fox can do three type of operations: divide by 2, divide by 3 and divide by 5. Let’s write both given numbers in form a = x·2a2·3a3·5a5, b = y·2b2·3b3·5b5, where x and y are not dibisible by 2, 3 and 5. If x ≠ y the fox can’t make numbers equal and program should print -1. If x = y then soluion exists. The answer equals to |a2 - b2| + |a3 - b3| + |a5 - b5|, because |a2 - b2| is the minimal number of operations to have 2 in the same power in both numbers, |a3 - b3| is the minimal number of operations to have 3 in the same power in both numbers, and |a5 - b5| is the same for 5.371C - HamburgersLet's use binary search approach. For given number of hamburgers (say, x) let's find the minimal number of money needed to cook them. Say, for one hamburger Polycarpus needs cb bread pieces, cs sausages pieces, cc cheese pieces. So for x hamburgers he needs: cb·x, cs·x and cc·x pieces (by types). Since he already has nb, ns and nc pieces, so he needs to buy: bread: max(0, cb·x - nb), sausages: max(0, cs·x - ns), cheese: max(0, cc·x - nc). So the formula to calculate money to cook x hamburgers is: f(x) = max(0, cb·x - nb)·pb + max(0, cs·x - ns)·ps + max(0, cc·x - nc)·pcObviously, the function f(x) is monotonic (increasing). So it is possible to use binary search approach to find largest x such that f(x) ler.371D - VesselsThe naive solution for this problem will work like this. Let us store an amount of water in each vessel in some array v. If we need to know how much water is in some vessel, we just take the number from the array. If we need to pour x units of water into vessel number i, we must follow the simple procedure: 1. If x = 0 then all water is poured and we must end the procedure 2. If i > n then all remaining water is spilled on the floor and we must end the procedure 3. If x units of water can fit into the i-th vessel, then add x to v[i] and end the procedure 4. Fill i-th vessel completely and subtract used amount from x. 5. Assign i = i + 1. 6. Go to the first step.In the worst case scenario such procedure can iterate through all vessels each time. For example, if there are n vessels and each vessels have capacity of one unit of water, each query like 11n will take O(n) time to process.To make this solution faster we should notice, that once completely filled, vessel can be skipped during the algorithm above because it can not consume any more water.So instead of i = i + 1 assignment should be like i = findNextNotFilledVessel(i). To implement this function we can use different structures. For example, we can use sorted set of numbers (set in C++, TreeSet in Java). Let store the set of indices of unfilled vessels. So to find next not filled vessel from i-th vessel, we must find smallest number, that is contained in set and is strictly greater than i. There are built-in methods for it (upper_bound in C++, higher in Java). Also, each time we fill the vessel, we must erase corresponding index from the set.So now we can see, that algorithm can not complete more that O((m + n)logn) operations for all queries. Because on each iteration of the pouring procedure either the vessel is filled (which can only happen n times during the whole runtime), or we run out of water (or vessels) and the procedure is stopped. So there will be only total of O(m + n) iterations of the pouring procedure and each iteration require one lookup in the sorted set, which takes O(logn) operations. So the total number of needed operations is O((m + n)logn).371E - Subway InnovationIt is easy to see that you need to minimize the sum of pairwise distances between k stations. The main idea to do it is to sort them and the required stations will form a continuous segment. It is easy to prove by contradiction.Huge constraints do not allow to use straight-forward method to find required segment. Let’s call f(i, k) — sum of pairwise distances of k stations starting from the i-th. To find f(0, k) you need to start from f(0, 0) = 0 and use transformation from calculated f(0, i) to f(0, i + 1). You can use equation:  = f(0, i) + xi·i - sum(0, i - 1)where sum(l, r) means xl + xl + 1 + ... + xr. We can precalculate sum[i] = x0 + x1 + ... + xi and use equation sum(l, r) = sum[r] - sum[l - 1] to find sum(l, r) in O(1).Actually we need f(0, k), f(1, k) and so on (and find minimal value among them).To recalculate f(i, k) to f(i + 1, k) you need exclude xi and include xi + k. Using the method like in the previous paragraph: f(i + 1, k) = f(i, k) - (sum(i + 1, i + k - 1) - xi·(k - 1)) + (xi + k·(k - 1) - sum(i + 1, i + k - 1)).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9876",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 371\\s*D"
          },
          "content_length": 5325
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 1",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 2",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 3",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 4",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 5",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 6",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 7",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 8",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 1",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 2",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int queryType = inf.readInt(1, 2, \"query type\");\n        if (queryType == 1) {\n            inf.readSpace();\n            int p_i = inf.readInt(1, n, \"p_i\");\n            inf.readSpace();\n            int x_i = inf.readInt(1, 1000000000, \"x_i\");\n            inf.readEoln();\n        } else { // queryType == 2\n            inf.readSpace();\n            int k_i = inf.readInt(1, n, \"k_i\");\n            inf.readEoln();\n        } \n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int queryType = inf.readInt(1, 2, \"query type\");\n        if (queryType == 1) {\n            inf.readSpace();\n            int p_i = inf.readInt(1, n, \"p_i\");\n            inf.readSpace();\n            int x_i = inf.readInt(1, 1000000000, \"x_i\");\n            inf.readEoln();\n        } else { // queryType == 2\n            inf.readSpace();\n            int k_i = inf.readInt(1, n, \"k_i\");\n            inf.readEoln();\n        } \n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int queryType = inf.readInt(1, 2, \"query type\");\n        if (queryType == 1) {\n            inf.readSpace();\n            int p_i = inf.readInt(1, n, \"p_i\");\n            inf.readSpace();\n            int x_i = inf.readInt(1, 1000000000, \"x_i\");\n            inf.readEoln();\n        } else { // queryType == 2\n            inf.readSpace();\n            int k_i = inf.readInt(1, n, \"k_i\");\n            inf.readEoln();\n        } \n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"max_caps\") {\n        // All capacities are at maximum\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000LL;\n        }\n    }\n    else if (type == \"min_caps\") {\n        // All capacities are at minimum\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1LL;\n        }\n    }\n    else if (type == \"random_caps\") {\n        // Capacities are random within the allowed range\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n    else if (type == \"increasing_caps\") {\n        // Capacities increasing from top to bottom\n        long long cap = rnd.next(1LL, 10LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = cap;\n            cap += rnd.next(0LL, 10LL);\n            if (cap > 1000000000LL) cap = 1000000000LL;\n        }\n    }\n    else if (type == \"decreasing_caps\") {\n        // Capacities decreasing from top to bottom\n        long long cap = 1000000000LL;\n        for (int i = 0; i < n; ++i) {\n            a[i] = cap;\n            cap -= rnd.next(0LL, 10LL);\n            if (cap < 1LL) cap = 1LL;\n        }\n    }\n    else {\n        // Default random capacities\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    // Output n\n    cout << n << \"\\n\";\n    // Output capacities\n    for (int i = 0; i < n; ++i) {\n        cout << a[i];\n        if (i == n - 1) cout << \"\\n\";\n        else cout << \" \";\n    }\n\n    // Generate m queries\n    cout << m << \"\\n\";\n\n    if (type == \"max_queries\") {\n        // All queries are pouring maximum xi into the top vessel\n        for (int i = 0; i < m; ++i) {\n            cout << \"1 1 1000000000\\n\";\n        }\n    } else if (type == \"single_pour\") {\n        // Single large pour into the top vessel, then queries\n        long long total_capacity = accumulate(a.begin(), a.end(), 0LL);\n        long long pour_amount = total_capacity;\n        if (pour_amount < 1000000000LL) pour_amount += rnd.next(1LL, 1000000000LL);\n        cout << \"1 1 \" << pour_amount << \"\\n\";\n        for (int i = 1; i < m; ++i) {\n            int ki = rnd.next(1, n);\n            cout << \"2 \" << ki << \"\\n\";\n        }\n    } else if (type == \"only_queries\") {\n        // All queries are type 2\n        for (int i = 0; i < m; ++i) {\n            int ki = rnd.next(1, n);\n            cout << \"2 \" << ki << \"\\n\";\n        }\n    } else if (type == \"only_pours\") {\n        // All queries are type 1\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            long long xi = rnd.next(1LL, 1000000000LL);\n            cout << \"1 \" << pi << \" \" << xi << \"\\n\";\n        }\n    } else if (type == \"random_queries\") {\n        // Random mix of query types\n        for (int i = 0; i < m; ++i) {\n            int qtype = rnd.next(1, 2);\n            if (qtype == 1) {\n                int pi = rnd.next(1, n);\n                long long xi = rnd.next(1LL, 1000000000LL);\n                cout << \"1 \" << pi << \" \" << xi << \"\\n\";\n            } else {\n                int ki = rnd.next(1, n);\n                cout << \"2 \" << ki << \"\\n\";\n            }\n        }\n    } else if (type == \"cascade\") {\n        // Pour enough water into the top vessel to overflow all vessels\n        long long total_capacity = accumulate(a.begin(), a.end(), 0LL);\n        long long overflow = rnd.next(1LL, 1000000000LL);\n        long long pour_amount = total_capacity + overflow;\n        cout << \"1 1 \" << pour_amount << \"\\n\";\n        for (int i = 1; i < m; ++i) {\n            int ki = rnd.next(1, n);\n            cout << \"2 \" << ki << \"\\n\";\n        }\n    } else {\n        // Default random queries\n        for (int i = 0; i < m; ++i) {\n            int qtype = rnd.next(1, 2);\n            if (qtype ==1) {\n                int pi = rnd.next(1, n);\n                long long xi = rnd.next(1LL, 1000000000LL);\n                cout << \"1 \" << pi << \" \" << xi << \"\\n\";\n            } else {\n                int ki = rnd.next(1, n);\n                cout << \"2 \" << ki << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"max_caps\") {\n        // All capacities are at maximum\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000LL;\n        }\n    }\n    else if (type == \"min_caps\") {\n        // All capacities are at minimum\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1LL;\n        }\n    }\n    else if (type == \"random_caps\") {\n        // Capacities are random within the allowed range\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n    else if (type == \"increasing_caps\") {\n        // Capacities increasing from top to bottom\n        long long cap = rnd.next(1LL, 10LL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = cap;\n            cap += rnd.next(0LL, 10LL);\n            if (cap > 1000000000LL) cap = 1000000000LL;\n        }\n    }\n    else if (type == \"decreasing_caps\") {\n        // Capacities decreasing from top to bottom\n        long long cap = 1000000000LL;\n        for (int i = 0; i < n; ++i) {\n            a[i] = cap;\n            cap -= rnd.next(0LL, 10LL);\n            if (cap < 1LL) cap = 1LL;\n        }\n    }\n    else {\n        // Default random capacities\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    // Output n\n    cout << n << \"\\n\";\n    // Output capacities\n    for (int i = 0; i < n; ++i) {\n        cout << a[i];\n        if (i == n - 1) cout << \"\\n\";\n        else cout << \" \";\n    }\n\n    // Generate m queries\n    cout << m << \"\\n\";\n\n    if (type == \"max_queries\") {\n        // All queries are pouring maximum xi into the top vessel\n        for (int i = 0; i < m; ++i) {\n            cout << \"1 1 1000000000\\n\";\n        }\n    } else if (type == \"single_pour\") {\n        // Single large pour into the top vessel, then queries\n        long long total_capacity = accumulate(a.begin(), a.end(), 0LL);\n        long long pour_amount = total_capacity;\n        if (pour_amount < 1000000000LL) pour_amount += rnd.next(1LL, 1000000000LL);\n        cout << \"1 1 \" << pour_amount << \"\\n\";\n        for (int i = 1; i < m; ++i) {\n            int ki = rnd.next(1, n);\n            cout << \"2 \" << ki << \"\\n\";\n        }\n    } else if (type == \"only_queries\") {\n        // All queries are type 2\n        for (int i = 0; i < m; ++i) {\n            int ki = rnd.next(1, n);\n            cout << \"2 \" << ki << \"\\n\";\n        }\n    } else if (type == \"only_pours\") {\n        // All queries are type 1\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            long long xi = rnd.next(1LL, 1000000000LL);\n            cout << \"1 \" << pi << \" \" << xi << \"\\n\";\n        }\n    } else if (type == \"random_queries\") {\n        // Random mix of query types\n        for (int i = 0; i < m; ++i) {\n            int qtype = rnd.next(1, 2);\n            if (qtype == 1) {\n                int pi = rnd.next(1, n);\n                long long xi = rnd.next(1LL, 1000000000LL);\n                cout << \"1 \" << pi << \" \" << xi << \"\\n\";\n            } else {\n                int ki = rnd.next(1, n);\n                cout << \"2 \" << ki << \"\\n\";\n            }\n        }\n    } else if (type == \"cascade\") {\n        // Pour enough water into the top vessel to overflow all vessels\n        long long total_capacity = accumulate(a.begin(), a.end(), 0LL);\n        long long overflow = rnd.next(1LL, 1000000000LL);\n        long long pour_amount = total_capacity + overflow;\n        cout << \"1 1 \" << pour_amount << \"\\n\";\n        for (int i = 1; i < m; ++i) {\n            int ki = rnd.next(1, n);\n            cout << \"2 \" << ki << \"\\n\";\n        }\n    } else {\n        // Default random queries\n        for (int i = 0; i < m; ++i) {\n            int qtype = rnd.next(1, 2);\n            if (qtype ==1) {\n                int pi = rnd.next(1, n);\n                long long xi = rnd.next(1LL, 1000000000LL);\n                cout << \"1 \" << pi << \" \" << xi << \"\\n\";\n            } else {\n                int ki = rnd.next(1, n);\n                cout << \"2 \" << ki << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type min_caps\n./gen -n 1 -m 1 -type max_caps\n./gen -n 10 -m 10 -type random_caps\n./gen -n 10 -m 10 -type increasing_caps\n./gen -n 10 -m 10 -type decreasing_caps\n./gen -n 10 -m 10 -type random_queries\n./gen -n 100 -m 100 -type min_caps\n./gen -n 100 -m 100 -type max_caps\n./gen -n 100 -m 100 -type random_caps\n./gen -n 100 -m 100 -type random_queries\n./gen -n 1000 -m 1000 -type only_pours\n./gen -n 1000 -m 1000 -type only_queries\n./gen -n 1000 -m 1000 -type cascade\n./gen -n 5000 -m 5000 -type single_pour\n./gen -n 5000 -m 5000 -type random_queries\n./gen -n 10000 -m 10000 -type random_caps\n./gen -n 10000 -m 10000 -type max_queries\n./gen -n 10000 -m 10000 -type min_caps\n./gen -n 50000 -m 50000 -type increasing_caps\n./gen -n 50000 -m 50000 -type decreasing_caps\n./gen -n 50000 -m 50000 -type cascade\n./gen -n 100000 -m 100000 -type random_queries\n./gen -n 100000 -m 100000 -type only_pours\n./gen -n 100000 -m 100000 -type only_queries\n./gen -n 200000 -m 200000 -type random_caps\n./gen -n 200000 -m 200000 -type single_pour\n./gen -n 200000 -m 200000 -type cascade\n./gen -n 200000 -m 200000 -type max_queries\n./gen -n 200000 -m 200000 -type random_queries\n./gen -n 200000 -m 200000 -type min_caps\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:24.483109",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "371/E",
      "title": "E. Subway Innovation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (3 ≤ n ≤ 3·105) — the number of the stations before the innovation. The second line contains the coordinates of the stations x1, x2, ..., xn ( - 108 ≤ xi ≤ 108). The third line contains integer k (2 ≤ k ≤ n - 1) — the number of stations after the innovation.The station coordinates are distinct and not necessarily sorted.",
      "output_spec": "OutputPrint a sequence of k distinct integers t1, t2, ..., tk (1 ≤ tj ≤ n) — the numbers of the stations that should be left after the innovation in arbitrary order. Assume that the stations are numbered 1 through n in the order they are given in the input. The number of stations you print must have the minimum possible average commute time among all possible ways to choose k stations. If there are multiple such ways, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy31 100 1012OutputCopy2 3",
      "description": "E. Subway Innovation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (3 ≤ n ≤ 3·105) — the number of the stations before the innovation. The second line contains the coordinates of the stations x1, x2, ..., xn ( - 108 ≤ xi ≤ 108). The third line contains integer k (2 ≤ k ≤ n - 1) — the number of stations after the innovation.The station coordinates are distinct and not necessarily sorted.\n\nOutputPrint a sequence of k distinct integers t1, t2, ..., tk (1 ≤ tj ≤ n) — the numbers of the stations that should be left after the innovation in arbitrary order. Assume that the stations are numbered 1 through n in the order they are given in the input. The number of stations you print must have the minimum possible average commute time among all possible ways to choose k stations. If there are multiple such ways, you are allowed to print any of them.\n\nInputCopy31 100 1012OutputCopy2 3\n\nInputCopy31 100 1012\n\nOutputCopy2 3\n\nNoteIn the sample testcase the optimal answer is to destroy the first station (with x = 1). The average commute time will be equal to 1 in this way.",
      "solutions": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Today in Saratov there is a second day of the local school competition, so we again introduce you a round based on school problemset. Round is for participants from Division II. Members of the first division can participate out of competition, as usual.Round starts on 8-th of December at 09:00 UTCProblems were prepared by employees and students of Saratov State U, including MikeMirzayanov, Fefer_Ivan, NALP, HolkinPV and me.Scoring: 500-1000-1500-2000-2500.UPD: Congratulations to the winners: asalwaysdontbeahero VKRNVO5 chnluyi pkwv Xe4NIK UPD: tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 597
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces",
          "content": "The tutorial has been prepared by Fefer_Ivan and NALP.371A - K-Periodic ArrayFor array to be periodic, elements 1, 1 + k, 1 + 2 * k, … must be equal. Also, elements 2, 2 + k, 2 + 2 * k, … must be equal. And so on up to k. So each element of the array is a part of exactly one group. And there are k groups total. Each such group is independent. Let’s consider some group of elements, that contain a ones and b twos. All elements in this group must be equal. So we either change all ones to twos or all twos to ones. First option will require a changing operations and second one — b changing operations. For the optimal solution, you should select the operation with smaller number of changing operations required.371B - Fox Dividing CheeseIt is easy to see that the fox can do three type of operations: divide by 2, divide by 3 and divide by 5. Let’s write both given numbers in form a = x·2a2·3a3·5a5, b = y·2b2·3b3·5b5, where x and y are not dibisible by 2, 3 and 5. If x ≠ y the fox can’t make numbers equal and program should print -1. If x = y then soluion exists. The answer equals to |a2 - b2| + |a3 - b3| + |a5 - b5|, because |a2 - b2| is the minimal number of operations to have 2 in the same power in both numbers, |a3 - b3| is the minimal number of operations to have 3 in the same power in both numbers, and |a5 - b5| is the same for 5.371C - HamburgersLet's use binary search approach. For given number of hamburgers (say, x) let's find the minimal number of money needed to cook them. Say, for one hamburger Polycarpus needs cb bread pieces, cs sausages pieces, cc cheese pieces. So for x hamburgers he needs: cb·x, cs·x and cc·x pieces (by types). Since he already has nb, ns and nc pieces, so he needs to buy: bread: max(0, cb·x - nb), sausages: max(0, cs·x - ns), cheese: max(0, cc·x - nc). So the formula to calculate money to cook x hamburgers is: f(x) = max(0, cb·x - nb)·pb + max(0, cs·x - ns)·ps + max(0, cc·x - nc)·pcObviously, the function f(x) is monotonic (increasing). So it is possible to use binary search approach to find largest x such that f(x) ler.371D - VesselsThe naive solution for this problem will work like this. Let us store an amount of water in each vessel in some array v. If we need to know how much water is in some vessel, we just take the number from the array. If we need to pour x units of water into vessel number i, we must follow the simple procedure: 1. If x = 0 then all water is poured and we must end the procedure 2. If i > n then all remaining water is spilled on the floor and we must end the procedure 3. If x units of water can fit into the i-th vessel, then add x to v[i] and end the procedure 4. Fill i-th vessel completely and subtract used amount from x. 5. Assign i = i + 1. 6. Go to the first step.In the worst case scenario such procedure can iterate through all vessels each time. For example, if there are n vessels and each vessels have capacity of one unit of water, each query like 11n will take O(n) time to process.To make this solution faster we should notice, that once completely filled, vessel can be skipped during the algorithm above because it can not consume any more water.So instead of i = i + 1 assignment should be like i = findNextNotFilledVessel(i). To implement this function we can use different structures. For example, we can use sorted set of numbers (set in C++, TreeSet in Java). Let store the set of indices of unfilled vessels. So to find next not filled vessel from i-th vessel, we must find smallest number, that is contained in set and is strictly greater than i. There are built-in methods for it (upper_bound in C++, higher in Java). Also, each time we fill the vessel, we must erase corresponding index from the set.So now we can see, that algorithm can not complete more that O((m + n)logn) operations for all queries. Because on each iteration of the pouring procedure either the vessel is filled (which can only happen n times during the whole runtime), or we run out of water (or vessels) and the procedure is stopped. So there will be only total of O(m + n) iterations of the pouring procedure and each iteration require one lookup in the sorted set, which takes O(logn) operations. So the total number of needed operations is O((m + n)logn).371E - Subway InnovationIt is easy to see that you need to minimize the sum of pairwise distances between k stations. The main idea to do it is to sort them and the required stations will form a continuous segment. It is easy to prove by contradiction.Huge constraints do not allow to use straight-forward method to find required segment. Let’s call f(i, k) — sum of pairwise distances of k stations starting from the i-th. To find f(0, k) you need to start from f(0, 0) = 0 and use transformation from calculated f(0, i) to f(0, i + 1). You can use equation:  = f(0, i) + xi·i - sum(0, i - 1)where sum(l, r) means xl + xl + 1 + ... + xr. We can precalculate sum[i] = x0 + x1 + ... + xi and use equation sum(l, r) = sum[r] - sum[l - 1] to find sum(l, r) in O(1).Actually we need f(0, k), f(1, k) and so on (and find minimal value among them).To recalculate f(i, k) to f(i + 1, k) you need exclude xi and include xi + k. Using the method like in the previous paragraph: f(i + 1, k) = f(i, k) - (sum(i + 1, i + k - 1) - xi·(k - 1)) + (xi + k·(k - 1) - sum(i + 1, i + k - 1)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9876",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 371\\s*E"
          },
          "content_length": 5325
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 1",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 2",
          "code": "int arr[100];\nfor ( i = 1; i <= n; i++ ) scanf ( \"%d\", &arr[i] ); //Here n can be 100.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 3",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 4",
          "code": "int ans = 0;\nwhile (n % 2 == 0) {\n  n /= 2;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 5",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 6",
          "code": "int ans = 0;\nwhile ((n & 1) == 0) {\n  n >>= 1;\n  ans ++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 7",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2) - Codeforces - Code 8",
          "code": "Sent   Hacked   Accepted \n A | 1235 | 15     | 1020     |\n B | 1132 | 36     | 662      |\n C | 716  | 9      | 285      |\n D | 329  | 0      | 150      |\n E | 95   | 2      | 18       |\nParticipants count: 1342",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9871",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 1",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #218 (Div. 2): Tutorial - Codeforces - Code 2",
          "code": "// C problem\nint32_t main(){\n\t\n\t// fuck ratings\n\n    string str; cin>>str;\n\n    int b=0,s=0,c=0,ans=0;\n\n    for(auto ch:str){\n        if(ch=='B')b++;\n        else if(ch=='S')s++;\n        else c++;\n    }\n\n    int nb,ns,nc; cin>>nb>>ns>>nc;\n    int pb,ps,pc; cin>>pb>>ps>>pc;\n\n    int R; cin>>R;\n\n    // After reading editorial -> Awesome Binary Search application\n\n    // For x burgers \n    // no of bread needed to be bought = max(0,b*x-nb)\n    // no of sauce needed to be bought = max(0,s*x-ns)\n    // no of cheese needed to be bought = max(0,c*x-nc)\n\n    // Magic : Whole interpretation of this complex question is \n    //         folded into 1-variable\n    \n    // Intuition of Magic:\n    // Since in whole , question only no. of burgers is the protagonist\n    // so we let burgers =x \n    // and now we just want all other less important variables \n    // in terms of x and break down this complex scenario\n\n// cost of x burger = f(x) = max(0,b*x-nb)+max(0,s*x-ns)+max(0,c*x-nc)\n// f(x) monotonic increasing\n// x->increase  f(x)=cost->increase\n\n // Range of cost or f(x)\n // 1<=f(x)<=R(money in our pocket)\n\n    // We have to apply binary search on no. of burgers\n    // low=1 , hi=100\n\n    int left=0, ri=1e13, z=0;\n\n    // left ------R--------mid(=x)------------R---------ri\n\n    int limit=50;\n\n    while(left<ri){\n\n        limit--;\n //       int mid=(left+ri)/2;  //this will work if    while(left+1<ri)\n\n\n       int mid = (left+ri+1)>>1; //this will work if   while(left<ri)\n\n       // cout<<left<<\" \"<<ri<<\"\\n\";\n\n        int x=mid;\n        int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n       // cout<<cost-R<<\"\\n\\n\";\n       \n        if(cost>R){   // buy less burger\n            ri=mid-1;\n        }\n        else{\n            left=mid;\n        }\n\n        if(limit==0)break; // 50 iterations max \n     \n    }\n    \n    // Security check\n    int x=left+1;\n    int cost=pb*max(z,b*x-nb)+ps*max(z,s*x-ns)+pc*max(z,c*x-nc);\n\n    \n    if(cost<=R)left++;\n\n    cout<<left;\n \n  \n   return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9876",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, -100000000, 100000000, \"x_i\");\n    inf.readEoln();\n\n    set<int> s(x.begin(), x.end());\n    ensuref((int)s.size() == n, \"All x_i must be distinct\");\n\n    int k = inf.readInt(2, n - 1, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, -100000000, 100000000, \"x_i\");\n    inf.readEoln();\n\n    set<int> s(x.begin(), x.end());\n    ensuref((int)s.size() == n, \"All x_i must be distinct\");\n\n    int k = inf.readInt(2, n - 1, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, -100000000, 100000000, \"x_i\");\n    inf.readEoln();\n\n    set<int> s(x.begin(), x.end());\n    ensuref((int)s.size() == n, \"All x_i must be distinct\");\n\n    int k = inf.readInt(2, n - 1, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nvector<int> xi;\n\n// Function to compute the total sum of pairwise distances over sorted xi_list\nlong long computeTotalSum(vector<int>& xi_list) {\n    int k = xi_list.size();\n    vector<long long> prefixSums(k);\n    prefixSums[0] = xi_list[0];\n    for (int i = 1; i < k; i++) {\n        prefixSums[i] = prefixSums[i-1] + xi_list[i];\n    }\n    long long total = 0;\n    for (int i = 1; i < k; i++) {\n        total += (long long)xi_list[i] * i - prefixSums[i-1];\n    }\n    return total;\n}\n\n// Function to read and validate the answer from the stream (ans or ouf)\nvoid readAns(InStream& stream, long long& totalSum) {\n    vector<int> indices(k);\n    set<int> used;\n    for (int i = 0; i < k; i++) {\n        indices[i] = stream.readInt(1, n, format(\"index[%d]\", i+1).c_str());\n        if (used.count(indices[i])) {\n            stream.quitf(_wa, \"Same index used more than once: index %d\", indices[i]);\n        }\n        used.insert(indices[i]);\n    }\n    vector<int> xi_list;\n    for (int i = 0; i < k; i++) {\n        xi_list.push_back(xi[indices[i]-1]); // Adjust for 0-based indexing\n    }\n    sort(xi_list.begin(), xi_list.end());\n    totalSum = computeTotalSum(xi_list);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt();\n    xi.resize(n);\n    for (int i = 0; i < n; i++) {\n        xi[i] = inf.readInt();\n    }\n    k = inf.readInt();\n\n    long long ansTotal, oufTotal;\n    readAns(ans, ansTotal); // Read and compute total sum from jury's answer\n    readAns(ouf, oufTotal); // Read and compute total sum from participant's answer\n\n    if (oufTotal > ansTotal)\n        quitf(_wa, \"Participant's total sum %lld is greater than minimal total sum %lld\", oufTotal, ansTotal);\n    else if (oufTotal == ansTotal)\n        quitf(_ok, \"Participant's total sum %lld matches minimal total sum\", oufTotal);\n    else\n        quitf(_fail, \"Participant's total sum %lld is less than minimal total sum %lld\", oufTotal, ansTotal);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x;\n    if (type == \"random\") {\n        // Generate random distinct coordinates in range [-1e8, 1e8]\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"cluster\") {\n        // Generate clusters of stations\n        int clusters = rnd.next(1, min(n, 10));\n        vector<int> cluster_centers(clusters);\n        for (int i = 0; i < clusters; ++i) {\n            cluster_centers[i] = rnd.next(-100000000, 100000000);\n        }\n        int idx = 0;\n        while ((int)x.size() < n) {\n            int cluster_idx = idx % clusters;\n            int val = cluster_centers[cluster_idx] + rnd.next(-1000, 1000);\n            x.push_back(val);\n            idx++;\n        }\n        // Ensure x_i are distinct\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        // If less than n, generate more points\n        while ((int)x.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            if (!binary_search(x.begin(), x.end(), val)) {\n                x.push_back(val);\n            }\n        }\n        shuffle(x.begin(), x.end());\n    } else if (type == \"sorted\") {\n        // Coordinates are sorted in increasing order\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        // x is sorted\n    } else if (type == \"negative\") {\n        // All coordinates are negative\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, -1);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"positive\") {\n        // All coordinates are positive\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(1, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"consecutive\") {\n        // Coordinates are consecutive integers starting from a random number\n        int start = rnd.next(-100000000, 100000000 - n);\n        for (int i = 0; i < n; ++i) {\n            x.push_back(start + i);\n        }\n        shuffle(x.begin(), x.end());\n    } else if (type == \"extreme\") {\n        // Coordinates are at extreme values\n        for (int i = 0; i < n / 2; ++i) {\n            x.push_back(-100000000 + i);\n        }\n        while ((int)x.size() < n) {\n            x.push_back(100000000 - (n - x.size()) + 1);\n        }\n        shuffle(x.begin(), x.end());\n    } else {\n        // Default to random\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    }\n\n    // Now output n\n    printf(\"%d\\n\", n);\n    // Output x_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output k\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x;\n    if (type == \"random\") {\n        // Generate random distinct coordinates in range [-1e8, 1e8]\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"cluster\") {\n        // Generate clusters of stations\n        int clusters = rnd.next(1, min(n, 10));\n        vector<int> cluster_centers(clusters);\n        for (int i = 0; i < clusters; ++i) {\n            cluster_centers[i] = rnd.next(-100000000, 100000000);\n        }\n        int idx = 0;\n        while ((int)x.size() < n) {\n            int cluster_idx = idx % clusters;\n            int val = cluster_centers[cluster_idx] + rnd.next(-1000, 1000);\n            x.push_back(val);\n            idx++;\n        }\n        // Ensure x_i are distinct\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        // If less than n, generate more points\n        while ((int)x.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            if (!binary_search(x.begin(), x.end(), val)) {\n                x.push_back(val);\n            }\n        }\n        shuffle(x.begin(), x.end());\n    } else if (type == \"sorted\") {\n        // Coordinates are sorted in increasing order\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        // x is sorted\n    } else if (type == \"negative\") {\n        // All coordinates are negative\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, -1);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"positive\") {\n        // All coordinates are positive\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(1, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"consecutive\") {\n        // Coordinates are consecutive integers starting from a random number\n        int start = rnd.next(-100000000, 100000000 - n);\n        for (int i = 0; i < n; ++i) {\n            x.push_back(start + i);\n        }\n        shuffle(x.begin(), x.end());\n    } else if (type == \"extreme\") {\n        // Coordinates are at extreme values\n        for (int i = 0; i < n / 2; ++i) {\n            x.push_back(-100000000 + i);\n        }\n        while ((int)x.size() < n) {\n            x.push_back(100000000 - (n - x.size()) + 1);\n        }\n        shuffle(x.begin(), x.end());\n    } else {\n        // Default to random\n        set<int> s;\n        while ((int)s.size() < n) {\n            int val = rnd.next(-100000000, 100000000);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    }\n\n    // Now output n\n    printf(\"%d\\n\", n);\n    // Output x_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output k\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -k 2 -type random\n./gen -n 3 -k 2 -type cluster\n./gen -n 3 -k 2 -type sorted\n./gen -n 3 -k 2 -type consecutive\n\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 5 -type cluster\n./gen -n 10 -k 5 -type negative\n./gen -n 10 -k 5 -type positive\n\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 2 -type random\n./gen -n 100 -k 99 -type random\n./gen -n 100 -k 50 -type sorted\n\n./gen -n 1000 -k 500 -type cluster\n./gen -n 1000 -k 2 -type consecutive\n./gen -n 1000 -k 999 -type consecutive\n./gen -n 1000 -k 500 -type negative\n\n./gen -n 50000 -k 25000 -type extreme\n./gen -n 50000 -k 2 -type extreme\n./gen -n 50000 -k 49999 -type extreme\n\n./gen -n 300000 -k 150000 -type cluster\n./gen -n 300000 -k 2 -type cluster\n./gen -n 300000 -k 299999 -type cluster\n\n./gen -n 300000 -k 150000 -type sorted\n./gen -n 300000 -k 150000 -type random\n./gen -n 300000 -k 150000 -type negative\n./gen -n 300000 -k 150000 -type positive\n\n./gen -n 300000 -k 2 -type sorted\n./gen -n 300000 -k 2 -type random\n./gen -n 300000 -k 300000 -type consecutive  # Note: k should be n-1 maximum; adjust accordingly if needed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:26.400007",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "372/A",
      "title": "A. Counting Kangaroos is Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer — n (1 ≤ n ≤ 5·105). Each of the next n lines contains an integer si — the size of the i-th kangaroo (1 ≤ si ≤ 105).",
      "output_spec": "OutputOutput a single integer — the optimal number of visible kangaroos.",
      "sample_tests": "ExamplesInputCopy825769842OutputCopy5InputCopy891626583OutputCopy5",
      "description": "A. Counting Kangaroos is Fun\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer — n (1 ≤ n ≤ 5·105). Each of the next n lines contains an integer si — the size of the i-th kangaroo (1 ≤ si ≤ 105).\n\nOutputOutput a single integer — the optimal number of visible kangaroos.\n\nInputCopy825769842OutputCopy5InputCopy891626583OutputCopy5\n\nInputCopy825769842\n\nOutputCopy5\n\nInputCopy891626583\n\nOutputCopy5",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Hello.Codeforces Round #219 will take place on December 13th at 18:00 MSK for both Div.1 and Div.2 participant. Make sure that it will be held unusual　time.Problem setters are kagamiz and DEGwer, and we thank Gerald for helping us to hold this contest, and Delinur for the translation, and MikeMirzayanov for systems.The score distribution will be uploaded soon, but probably we use the standard scoring system.UPD1: The score distribution is standard, 500-1000-1500-2000-2500 for both division.UPD2: Problem B from Div.2 and problem C from Div.1 have some problems, so all submissions to these problems are rejudged. I'm very sorry.UPD3: Anyone who gets AC two or more times, because of resubmit before clarification, please, write to Gerald, your submissions that should be skipped. Sorry for inconvenience.UPD4: Now system test has finished, congratulation for winners!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackAnd also congrats for rng_58 and permin, who got AC on Div.1 E problem!!UPD5: Now editorial is uploaded here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1105
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Collecting Beats is Fun /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Making Sequences is Fun /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Counting Kangaroos is Fun / 372A - Counting Kangaroos is Fun /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Counting Rectangles is Fun / 372B - Counting Rectangles is Fun /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Watching Fireworks is Fun / 372C - Watching Fireworks is Fun /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Choosing Subtree is Fun /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Drawing Circles is Fun /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 372\\s*A"
          },
          "content_length": 6042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 100000, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 100000, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 100000, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(min_size, max_size);\n        }\n    } else if (type == \"constant\") {\n        int size = opt<int>(\"size\", 1);\n        for (int i = 0; i < n; ++i) {\n            s[i] = size;\n        }\n    } else if (type == \"increasing\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        if (min_size > max_size) swap(min_size, max_size);\n        if (n == 1) {\n            s[0] = min_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                s[i] = min_size + ((long long)(max_size - min_size) * i) / (n - 1);\n            }\n        }\n    } else if (type == \"decreasing\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        if (min_size > max_size) swap(min_size, max_size);\n        if (n == 1) {\n            s[0] = max_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                s[i] = max_size - ((long long)(max_size - min_size) * i) / (n - 1);\n            }\n        }\n    } else if (type == \"alternate_large_small\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s[i] = max_size;\n            else\n                s[i] = min_size;\n        }\n    } else if (type == \"powers_of_two\") {\n        int max_power = opt<int>(\"max_power\", 16); // 2^16 = 65536\n        for (int i = 0; i < n; ++i) {\n            int power = rnd.next(0, max_power);\n            s[i] = 1 << power;\n        }\n    } else if (type == \"max_pack\") {\n        int k = opt<int>(\"k\", 50000);\n        int size1 = k;\n        int size2 = min(2 * k, 100000);\n        for (int i = 0; i < n / 2; ++i) {\n            s[i] = size1;\n        }\n        for (int i = n / 2; i < n; ++i) {\n            s[i] = size2;\n        }\n    } else if (type == \"min_pack\") {\n        int size = 100000;\n        for (int i = 0; i < n; ++i) {\n            s[i] = size;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure all sizes are within 1 and 100000\n    for (int i = 0; i < n; ++i) {\n        if (s[i] < 1) s[i] = 1;\n        if (s[i] > 100000) s[i] = 100000;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", s[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(min_size, max_size);\n        }\n    } else if (type == \"constant\") {\n        int size = opt<int>(\"size\", 1);\n        for (int i = 0; i < n; ++i) {\n            s[i] = size;\n        }\n    } else if (type == \"increasing\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        if (min_size > max_size) swap(min_size, max_size);\n        if (n == 1) {\n            s[0] = min_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                s[i] = min_size + ((long long)(max_size - min_size) * i) / (n - 1);\n            }\n        }\n    } else if (type == \"decreasing\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        if (min_size > max_size) swap(min_size, max_size);\n        if (n == 1) {\n            s[0] = max_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                s[i] = max_size - ((long long)(max_size - min_size) * i) / (n - 1);\n            }\n        }\n    } else if (type == \"alternate_large_small\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s[i] = max_size;\n            else\n                s[i] = min_size;\n        }\n    } else if (type == \"powers_of_two\") {\n        int max_power = opt<int>(\"max_power\", 16); // 2^16 = 65536\n        for (int i = 0; i < n; ++i) {\n            int power = rnd.next(0, max_power);\n            s[i] = 1 << power;\n        }\n    } else if (type == \"max_pack\") {\n        int k = opt<int>(\"k\", 50000);\n        int size1 = k;\n        int size2 = min(2 * k, 100000);\n        for (int i = 0; i < n / 2; ++i) {\n            s[i] = size1;\n        }\n        for (int i = n / 2; i < n; ++i) {\n            s[i] = size2;\n        }\n    } else if (type == \"min_pack\") {\n        int size = 100000;\n        for (int i = 0; i < n; ++i) {\n            s[i] = size;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure all sizes are within 1 and 100000\n    for (int i = 0; i < n; ++i) {\n        if (s[i] < 1) s[i] = 1;\n        if (s[i] > 100000) s[i] = 100000;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", s[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, various types\n./gen -n 8 -type random\n./gen -n 8 -type constant -size 5\n./gen -n 8 -type increasing -min_size 1 -max_size 10\n./gen -n 8 -type decreasing -min_size 1 -max_size 10\n./gen -n 8 -type alternate_large_small -min_size 2 -max_size 8\n./gen -n 8 -type powers_of_two -max_power 3\n./gen -n 8 -type max_pack -k 2\n./gen -n 8 -type min_pack\n\n# Medium n, random\n./gen -n 1000 -type random\n./gen -n 1000 -type random -min_size 50 -max_size 50000\n\n# Large n, random\n./gen -n 500000 -type random\n\n# Max n, constant sizes\n./gen -n 500000 -type constant -size 100000\n\n# Max n, increasing sizes\n./gen -n 500000 -type increasing\n\n# Max n, decreasing sizes\n./gen -n 500000 -type decreasing\n\n# Max n, alternate large and small\n./gen -n 500000 -type alternate_large_small -min_size 1 -max_size 100000\n\n# Max n, powers of two\n./gen -n 500000 -type powers_of_two\n\n# Max n, max_pack\n./gen -n 500000 -type max_pack -k 50000\n\n# Max n, min_pack\n./gen -n 500000 -type min_pack\n\n# Edge cases\n./gen -n 1 -type random\n./gen -n 1 -type constant -size 100000\n\n# Small n, constant sizes\n./gen -n 3 -type constant -size 100000\n\n# Max n, constant size 1\n./gen -n 500000 -type constant -size 1\n\n# Max n, random sizes between 1 and 2\n./gen -n 500000 -type random -min_size 1 -max_size 2\n\n# Max n, random sizes between 99999 and 100000\n./gen -n 500000 -type random -min_size 99999 -max_size 100000\n\n# Max n, random sizes between 50000 and 50000 (all 50000)\n./gen -n 500000 -type random -min_size 50000 -max_size 50000\n\n# Max n, increasing sizes from 100000 to 1\n./gen -n 500000 -type increasing -min_size 100000 -max_size 1\n\n# Max n, decreasing sizes from 1 to 100000\n./gen -n 500000 -type decreasing -min_size 1 -max_size 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:28.066599",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "372/B",
      "title": "B. Counting Rectangles is Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThere are three integers in the first line: n, m and q (1 ≤ n, m ≤ 40, 1 ≤ q ≤ 3·105). Each of the next n lines contains m characters — the grid. Consider grid rows are numbered from top to bottom, and grid columns are numbered from left to right. Both columns and rows are numbered starting from 1. Each of the next q lines contains a query — four integers that describe the current rectangle, a, b, c, d (1 ≤ a ≤ c ≤ n; 1 ≤ b ≤ d ≤ m).",
      "output_spec": "OutputFor each query output an answer — a single integer in a separate line.",
      "sample_tests": "ExamplesInputCopy5 5 500101000000000101000000011 2 2 44 5 4 51 2 5 22 2 4 54 2 5 3OutputCopy1017345InputCopy4 7 500001000000010001100000000001 7 2 73 1 3 12 3 4 51 2 2 72 2 4 7OutputCopy31162752",
      "description": "B. Counting Rectangles is Fun\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThere are three integers in the first line: n, m and q (1 ≤ n, m ≤ 40, 1 ≤ q ≤ 3·105). Each of the next n lines contains m characters — the grid. Consider grid rows are numbered from top to bottom, and grid columns are numbered from left to right. Both columns and rows are numbered starting from 1. Each of the next q lines contains a query — four integers that describe the current rectangle, a, b, c, d (1 ≤ a ≤ c ≤ n; 1 ≤ b ≤ d ≤ m).\n\nOutputFor each query output an answer — a single integer in a separate line.\n\nInputCopy5 5 500101000000000101000000011 2 2 44 5 4 51 2 5 22 2 4 54 2 5 3OutputCopy1017345InputCopy4 7 500001000000010001100000000001 7 2 73 1 3 12 3 4 51 2 2 72 2 4 7OutputCopy31162752\n\nInputCopy5 5 500101000000000101000000011 2 2 44 5 4 51 2 5 22 2 4 54 2 5 3\n\nOutputCopy1017345\n\nInputCopy4 7 500001000000010001100000000001 7 2 73 1 3 12 3 4 51 2 2 72 2 4 7\n\nOutputCopy31162752\n\nNoteFor the first example, there is a 5 × 5 rectangular grid, and the first, the second, and the third queries are represented in the following image.    For the first query, there are 10 good rectangles, five 1 × 1, two 2 × 1, two 1 × 2, and one 1 × 3.  For the second query, there is only one 1 × 1 good rectangle.  For the third query, there are 7 good rectangles, four 1 × 1, two 2 × 1, and one 3 × 1.",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Hello.Codeforces Round #219 will take place on December 13th at 18:00 MSK for both Div.1 and Div.2 participant. Make sure that it will be held unusual　time.Problem setters are kagamiz and DEGwer, and we thank Gerald for helping us to hold this contest, and Delinur for the translation, and MikeMirzayanov for systems.The score distribution will be uploaded soon, but probably we use the standard scoring system.UPD1: The score distribution is standard, 500-1000-1500-2000-2500 for both division.UPD2: Problem B from Div.2 and problem C from Div.1 have some problems, so all submissions to these problems are rejudged. I'm very sorry.UPD3: Anyone who gets AC two or more times, because of resubmit before clarification, please, write to Gerald, your submissions that should be skipped. Sorry for inconvenience.UPD4: Now system test has finished, congratulation for winners!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackAnd also congrats for rng_58 and permin, who got AC on Div.1 E problem!!UPD5: Now editorial is uploaded here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1105
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Collecting Beats is Fun /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Making Sequences is Fun /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Counting Kangaroos is Fun / 372A - Counting Kangaroos is Fun /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Counting Rectangles is Fun / 372B - Counting Rectangles is Fun /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Watching Fireworks is Fun / 372C - Watching Fireworks is Fun /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Choosing Subtree is Fun /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Drawing Circles is Fun /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 372\\s*B"
          },
          "content_length": 6042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 40, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(\"[01]{\" + to_string(m) + \"}\", \"gridLine\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(a, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(b, m, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 40, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(\"[01]{\" + to_string(m) + \"}\", \"gridLine\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(a, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(b, m, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 40, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(\"[01]{\" + to_string(m) + \"}\", \"gridLine\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(a, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(b, m, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string gridType = opt<string>(\"gridType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Generate grid\n    vector<string> grid(n);\n    if (gridType == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n        }\n    } else if (gridType == \"all_one\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n        }\n    } else if (gridType == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += rnd.next(0, 1) + '0';\n            }\n        }\n    } else if (gridType == \"checkerboard\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += ((i + j) % 2) + '0';\n            }\n        }\n    } else if (gridType == \"single_one\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n        }\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '1';\n    } else if (gridType == \"single_zero\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n        }\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '0';\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += rnd.next(0, 1) + '0';\n            }\n        }\n    }\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, m, q);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    // Generate queries\n    vector<tuple<int, int, int, int>> queries(q);\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            if (a > c) swap(a, c);\n            int b = rnd.next(1, m);\n            int d = rnd.next(1, m);\n            if (b > d) swap(b, d);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    } else if (queryType == \"full_grid\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_tuple(1, 1, n, m);\n        }\n    } else if (queryType == \"single_cell\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            queries[i] = make_tuple(x, y, x, y);\n        }\n    } else if (queryType == \"big_rectangles\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, max(1, n - n / 4));\n            int c = rnd.next(min(n, n / 2), n);\n            if (a > c) swap(a, c);\n            int b = rnd.next(1, max(1, m - m / 4));\n            int d = rnd.next(min(m, m / 2), m);\n            if (b > d) swap(b, d);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    } else if (queryType == \"small_rectangles\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int c = a + rnd.next(0, min(n - a, 2));\n            int b = rnd.next(1, m);\n            int d = b + rnd.next(0, min(m - b, 2));\n            c = min(c, n);\n            d = min(d, m);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            if (a > c) swap(a, c);\n            int b = rnd.next(1, m);\n            int d = rnd.next(1, m);\n            if (b > d) swap(b, d);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        int a, b, c, d;\n        tie(a, b, c, d) = queries[i];\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string gridType = opt<string>(\"gridType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Generate grid\n    vector<string> grid(n);\n    if (gridType == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n        }\n    } else if (gridType == \"all_one\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n        }\n    } else if (gridType == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += rnd.next(0, 1) + '0';\n            }\n        }\n    } else if (gridType == \"checkerboard\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += ((i + j) % 2) + '0';\n            }\n        }\n    } else if (gridType == \"single_one\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n        }\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '1';\n    } else if (gridType == \"single_zero\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n        }\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '0';\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                grid[i] += rnd.next(0, 1) + '0';\n            }\n        }\n    }\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, m, q);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    // Generate queries\n    vector<tuple<int, int, int, int>> queries(q);\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            if (a > c) swap(a, c);\n            int b = rnd.next(1, m);\n            int d = rnd.next(1, m);\n            if (b > d) swap(b, d);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    } else if (queryType == \"full_grid\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_tuple(1, 1, n, m);\n        }\n    } else if (queryType == \"single_cell\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            queries[i] = make_tuple(x, y, x, y);\n        }\n    } else if (queryType == \"big_rectangles\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, max(1, n - n / 4));\n            int c = rnd.next(min(n, n / 2), n);\n            if (a > c) swap(a, c);\n            int b = rnd.next(1, max(1, m - m / 4));\n            int d = rnd.next(min(m, m / 2), m);\n            if (b > d) swap(b, d);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    } else if (queryType == \"small_rectangles\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int c = a + rnd.next(0, min(n - a, 2));\n            int b = rnd.next(1, m);\n            int d = b + rnd.next(0, min(m - b, 2));\n            c = min(c, n);\n            d = min(d, m);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            if (a > c) swap(a, c);\n            int b = rnd.next(1, m);\n            int d = rnd.next(1, m);\n            if (b > d) swap(b, d);\n            queries[i] = make_tuple(a, b, c, d);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        int a, b, c, d;\n        tie(a, b, c, d) = queries[i];\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -q 5 -gridType random -queryType random\n./gen -n 5 -m 5 -q 5 -gridType all_zero -queryType full_grid\n./gen -n 5 -m 5 -q 5 -gridType all_one -queryType random\n./gen -n 5 -m 5 -q 5 -gridType checkerboard -queryType small_rectangles\n./gen -n 5 -m 5 -q 5 -gridType single_one -queryType single_cell\n./gen -n 40 -m 40 -q 300000 -gridType all_zero -queryType full_grid\n./gen -n 40 -m 40 -q 300000 -gridType all_one -queryType random\n./gen -n 40 -m 40 -q 300000 -gridType random -queryType random\n./gen -n 40 -m 40 -q 300000 -gridType random -queryType big_rectangles\n./gen -n 40 -m 40 -q 300000 -gridType checkerboard -queryType single_cell\n./gen -n 40 -m 40 -q 300000 -gridType single_zero -queryType full_grid\n./gen -n 40 -m 40 -q 300000 -gridType single_one -queryType small_rectangles\n./gen -n 40 -m 40 -q 300000 -gridType all_zero -queryType small_rectangles\n./gen -n 40 -m 40 -q 300000 -gridType all_zero -queryType big_rectangles\n./gen -n 40 -m 40 -q 300000 -gridType random -queryType single_cell\n./gen -n 5 -m 5 -q 5 -gridType all_one -queryType full_grid\n./gen -n 5 -m 5 -q 5 -gridType random -queryType full_grid\n./gen -n 5 -m 5 -q 5 -gridType single_zero -queryType random\n./gen -n 40 -m 1 -q 300000 -gridType all_zero -queryType full_grid\n./gen -n 1 -m 40 -q 300000 -gridType all_zero -queryType full_grid\n./gen -n 40 -m 40 -q 300000 -gridType checkerboard -queryType big_rectangles\n./gen -n 40 -m 40 -q 300000 -gridType checkerboard -queryType random\n./gen -n 39 -m 39 -q 100000 -gridType checkerboard -queryType small_rectangles\n./gen -n 40 -m 40 -q 1 -gridType all_zero -queryType full_grid\n./gen -n 40 -m 40 -q 1 -gridType all_one -queryType full_grid\n./gen -n 40 -m 40 -q 300000 -gridType all_zero -queryType random\n./gen -n 40 -m 40 -q 300000 -gridType random -queryType small_rectangles\n./gen -n 30 -m 30 -q 200000 -gridType single_zero -queryType random\n./gen -n 35 -m 35 -q 250000 -gridType single_one -queryType big_rectangles\n./gen -n 40 -m 40 -q 300000 -gridType checkerboard -queryType full_grid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:30.362330",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "372/C",
      "title": "C. Watching Fireworks is Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, d (1 ≤ n ≤ 150000; 1 ≤ m ≤ 300; 1 ≤ d ≤ n).Each of the next m lines contains integers ai, bi, ti (1 ≤ ai ≤ n; 1 ≤ bi ≤ 109; 1 ≤ ti ≤ 109). The i-th line contains description of the i-th launching.It is guaranteed that the condition ti ≤ ti + 1 (1 ≤ i < m) will be satisfied.",
      "output_spec": "OutputPrint a single integer — the maximum sum of happiness that you can gain from watching all the fireworks.Please, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy50 3 149 1 126 1 46 1 10OutputCopy-31InputCopy10 2 11 1000 49 1000 4OutputCopy1992",
      "description": "C. Watching Fireworks is Fun\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, d (1 ≤ n ≤ 150000; 1 ≤ m ≤ 300; 1 ≤ d ≤ n).Each of the next m lines contains integers ai, bi, ti (1 ≤ ai ≤ n; 1 ≤ bi ≤ 109; 1 ≤ ti ≤ 109). The i-th line contains description of the i-th launching.It is guaranteed that the condition ti ≤ ti + 1 (1 ≤ i < m) will be satisfied.\n\nOutputPrint a single integer — the maximum sum of happiness that you can gain from watching all the fireworks.Please, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy50 3 149 1 126 1 46 1 10OutputCopy-31InputCopy10 2 11 1000 49 1000 4OutputCopy1992\n\nInputCopy50 3 149 1 126 1 46 1 10\n\nOutputCopy-31\n\nInputCopy10 2 11 1000 49 1000 4\n\nOutputCopy1992",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Hello.Codeforces Round #219 will take place on December 13th at 18:00 MSK for both Div.1 and Div.2 participant. Make sure that it will be held unusual　time.Problem setters are kagamiz and DEGwer, and we thank Gerald for helping us to hold this contest, and Delinur for the translation, and MikeMirzayanov for systems.The score distribution will be uploaded soon, but probably we use the standard scoring system.UPD1: The score distribution is standard, 500-1000-1500-2000-2500 for both division.UPD2: Problem B from Div.2 and problem C from Div.1 have some problems, so all submissions to these problems are rejudged. I'm very sorry.UPD3: Anyone who gets AC two or more times, because of resubmit before clarification, please, write to Gerald, your submissions that should be skipped. Sorry for inconvenience.UPD4: Now system test has finished, congratulation for winners!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackAnd also congrats for rng_58 and permin, who got AC on Div.1 E problem!!UPD5: Now editorial is uploaded here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1105
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Collecting Beats is Fun /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Making Sequences is Fun /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Counting Kangaroos is Fun / 372A - Counting Kangaroos is Fun /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Counting Rectangles is Fun / 372B - Counting Rectangles is Fun /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Watching Fireworks is Fun / 372C - Watching Fireworks is Fun /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Choosing Subtree is Fun /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Drawing Circles is Fun /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 372\\s*C"
          },
          "content_length": 6042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    vector<long long> t(m);\n    for (int i = 0; i < m; i++) {\n        char varname[20];\n\n        snprintf(varname, sizeof(varname), \"a[%d]\", i+1);\n        int a = inf.readInt(1, n, varname);\n        inf.readSpace();\n\n        snprintf(varname, sizeof(varname), \"b[%d]\", i+1);\n        long long b = inf.readLong(1, 1000000000LL, varname);\n        inf.readSpace();\n\n        snprintf(varname, sizeof(varname), \"t[%d]\", i+1);\n        t[i] = inf.readLong(1, 1000000000LL, varname);\n\n        inf.readEoln();\n    }\n\n    for (int i = 1; i < m; i++) {\n        ensuref(t[i-1] <= t[i], \"t[%d] = %lld > t[%d] = %lld\", i, t[i-1], i+1, t[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    vector<long long> t(m);\n    for (int i = 0; i < m; i++) {\n        char varname[20];\n\n        snprintf(varname, sizeof(varname), \"a[%d]\", i+1);\n        int a = inf.readInt(1, n, varname);\n        inf.readSpace();\n\n        snprintf(varname, sizeof(varname), \"b[%d]\", i+1);\n        long long b = inf.readLong(1, 1000000000LL, varname);\n        inf.readSpace();\n\n        snprintf(varname, sizeof(varname), \"t[%d]\", i+1);\n        t[i] = inf.readLong(1, 1000000000LL, varname);\n\n        inf.readEoln();\n    }\n\n    for (int i = 1; i < m; i++) {\n        ensuref(t[i-1] <= t[i], \"t[%d] = %lld > t[%d] = %lld\", i, t[i-1], i+1, t[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    vector<long long> t(m);\n    for (int i = 0; i < m; i++) {\n        char varname[20];\n\n        snprintf(varname, sizeof(varname), \"a[%d]\", i+1);\n        int a = inf.readInt(1, n, varname);\n        inf.readSpace();\n\n        snprintf(varname, sizeof(varname), \"b[%d]\", i+1);\n        long long b = inf.readLong(1, 1000000000LL, varname);\n        inf.readSpace();\n\n        snprintf(varname, sizeof(varname), \"t[%d]\", i+1);\n        t[i] = inf.readLong(1, 1000000000LL, varname);\n\n        inf.readEoln();\n    }\n\n    for (int i = 1; i < m; i++) {\n        ensuref(t[i-1] <= t[i], \"t[%d] = %lld > t[%d] = %lld\", i, t[i-1], i+1, t[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string t_type = opt<string>(\"t_type\", \"random\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n\n    vector<long long> t(m);\n    vector<int> a(m);\n    vector<int> b(m);\n\n    // Generate t_i\n    if (t_type == \"random\") {\n        t[0] = rnd.next(1LL, 1000000000LL);\n        for(int i = 1; i < m; ++i) {\n            t[i] = rnd.next(t[i-1], 1000000000LL);\n        }\n    } else if (t_type == \"same\") {\n        for(int i = 0; i < m; ++i)\n            t[i] = 1;\n    } else if (t_type == \"increasing_small\") {\n        t[0] = 1;\n        for(int i = 1; i < m; ++i)\n            t[i] = t[i-1] + 1;\n    } else if (t_type == \"increasing_large\") {\n        t[0] = 1;\n        for(int i = 1; i < m; ++i)\n            t[i] = t[i-1] + rnd.next(100000000LL, 1000000000LL);\n    }\n\n    // Generate a_i\n    if (a_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else if (a_type == \"same\") {\n        int pos = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = pos;\n    } else if (a_type == \"edges\") {\n        for(int i = 0; i < m; ++i)\n            a[i] = (i % 2 == 0) ? 1 : n;\n    }\n\n    // Generate b_i\n    if (b_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    } else if (b_type == \"small\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = 1;\n    } else if (b_type == \"large\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = 1000000000;\n    }\n\n    // Output n m d\n    printf(\"%d %d %d\\n\", n, m, d);\n    // Output ai bi ti\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d %lld\\n\", a[i], b[i], t[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string t_type = opt<string>(\"t_type\", \"random\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n\n    vector<long long> t(m);\n    vector<int> a(m);\n    vector<int> b(m);\n\n    // Generate t_i\n    if (t_type == \"random\") {\n        t[0] = rnd.next(1LL, 1000000000LL);\n        for(int i = 1; i < m; ++i) {\n            t[i] = rnd.next(t[i-1], 1000000000LL);\n        }\n    } else if (t_type == \"same\") {\n        for(int i = 0; i < m; ++i)\n            t[i] = 1;\n    } else if (t_type == \"increasing_small\") {\n        t[0] = 1;\n        for(int i = 1; i < m; ++i)\n            t[i] = t[i-1] + 1;\n    } else if (t_type == \"increasing_large\") {\n        t[0] = 1;\n        for(int i = 1; i < m; ++i)\n            t[i] = t[i-1] + rnd.next(100000000LL, 1000000000LL);\n    }\n\n    // Generate a_i\n    if (a_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else if (a_type == \"same\") {\n        int pos = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = pos;\n    } else if (a_type == \"edges\") {\n        for(int i = 0; i < m; ++i)\n            a[i] = (i % 2 == 0) ? 1 : n;\n    }\n\n    // Generate b_i\n    if (b_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    } else if (b_type == \"small\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = 1;\n    } else if (b_type == \"large\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = 1000000000;\n    }\n\n    // Output n m d\n    printf(\"%d %d %d\\n\", n, m, d);\n    // Output ai bi ti\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d %lld\\n\", a[i], b[i], t[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 1 -d 1 -t_type same -a_type same -b_type small\n./gen -n 1 -m 10 -d 1 -t_type same -a_type random -b_type random\n./gen -n 100000 -m 300 -d 1 -t_type increasing_small -a_type random -b_type random\n./gen -n 100000 -m 300 -d 100000 -t_type increasing_large -a_type random -b_type random\n./gen -n 150000 -m 300 -d 1 -t_type same -a_type same -b_type large\n./gen -n 150000 -m 300 -d 1 -t_type same -a_type edges -b_type small\n./gen -n 100000 -m 300 -d 100000 -t_type same -a_type edges -b_type large\n./gen -n 150000 -m 1 -d 1 -t_type increasing_small -a_type random -b_type random\n./gen -n 2 -m 300 -d 1 -t_type same -a_type edges -b_type large\n./gen -n 150000 -m 300 -d 150000 -t_type increasing_large -a_type random -b_type random\n./gen -n 150000 -m 300 -d 1 -t_type increasing_small -a_type random -b_type large\n./gen -n 1 -m 300 -d 1 -t_type increasing_large -a_type same -b_type large\n./gen -n 1 -m 300 -d 1 -t_type increasing_small -a_type same -b_type small\n./gen -n 150000 -m 1 -d 150000 -t_type increasing_large -a_type random -b_type large\n./gen -n 100000 -m 300 -d 1 -t_type increasing_small -a_type random -b_type small\n./gen -n 100000 -m 300 -d 1000 -t_type increasing_large -a_type edges -b_type large\n./gen -n 2 -m 2 -d 1 -t_type same -a_type edges -b_type small\n./gen -n 100000 -m 1 -d 1 -t_type same -a_type random -b_type small\n./gen -n 100000 -m 1 -d 100000 -t_type same -a_type random -b_type large\n./gen -n 150000 -m 300 -d 1 -t_type same -a_type random -b_type random\n./gen -n 150000 -m 300 -d 1 -t_type increasing_small -a_type same -b_type small\n./gen -n 150000 -m 300 -d 1 -t_type increasing_small -a_type edges -b_type large\n./gen -n 150000 -m 300 -d 1 -t_type increasing_large -a_type random -b_type large\n./gen -n 150000 -m 300 -d 1 -t_type increasing_large -a_type same -b_type small\n./gen -n 100000 -m 300 -d 100000 -t_type same -a_type random -b_type small\n./gen -n 100000 -m 300 -d 100000 -t_type same -a_type random -b_type large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:32.522213",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "372/D",
      "title": "D. Choosing Subtree is Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThere are two integers in the first line, n and k (1 ≤ k ≤ n ≤ 105). Each of the next n - 1 lines contains integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi). That means ai and bi are connected by a tree edge.It is guaranteed that the input represents a tree.",
      "output_spec": "OutputOutput should contain a single integer — the maximum possible score.",
      "sample_tests": "ExamplesInputCopy10 64 1010 62 99 68 57 14 77 31 8OutputCopy3InputCopy16 713 1112 112 148 69 1516 115 146 154 311 1515 1410 13 1414 71 7OutputCopy6",
      "description": "D. Choosing Subtree is Fun\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThere are two integers in the first line, n and k (1 ≤ k ≤ n ≤ 105). Each of the next n - 1 lines contains integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi). That means ai and bi are connected by a tree edge.It is guaranteed that the input represents a tree.\n\nOutputOutput should contain a single integer — the maximum possible score.\n\nInputCopy10 64 1010 62 99 68 57 14 77 31 8OutputCopy3InputCopy16 713 1112 112 148 69 1516 115 146 154 311 1515 1410 13 1414 71 7OutputCopy6\n\nInputCopy10 64 1010 62 99 68 57 14 77 31 8\n\nOutputCopy3\n\nInputCopy16 713 1112 112 148 69 1516 115 146 154 311 1515 1410 13 1414 71 7\n\nOutputCopy6\n\nNoteFor the first case, there is some subtree whose size is at most 6, including 3 consecutive numbers of vertices. For example, the subtree that consists of {1, 3, 4, 5, 7, 8} or of {1, 4, 6, 7, 8, 10} includes 3 consecutive numbers of vertices. But there is no subtree whose size is at most 6, which includes 4 or more consecutive numbers of vertices.",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Hello.Codeforces Round #219 will take place on December 13th at 18:00 MSK for both Div.1 and Div.2 participant. Make sure that it will be held unusual　time.Problem setters are kagamiz and DEGwer, and we thank Gerald for helping us to hold this contest, and Delinur for the translation, and MikeMirzayanov for systems.The score distribution will be uploaded soon, but probably we use the standard scoring system.UPD1: The score distribution is standard, 500-1000-1500-2000-2500 for both division.UPD2: Problem B from Div.2 and problem C from Div.1 have some problems, so all submissions to these problems are rejudged. I'm very sorry.UPD3: Anyone who gets AC two or more times, because of resubmit before clarification, please, write to Gerald, your submissions that should be skipped. Sorry for inconvenience.UPD4: Now system test has finished, congratulation for winners!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackAnd also congrats for rng_58 and permin, who got AC on Div.1 E problem!!UPD5: Now editorial is uploaded here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1105
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Collecting Beats is Fun /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Making Sequences is Fun /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Counting Kangaroos is Fun / 372A - Counting Kangaroos is Fun /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Counting Rectangles is Fun / 372B - Counting Rectangles is Fun /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Watching Fireworks is Fun / 372C - Watching Fireworks is Fun /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Choosing Subtree is Fun /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Drawing Circles is Fun /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 372\\s*D"
          },
          "content_length": 6042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000; // Maximum value for n\n\nint parent[MAX_N + 1]; // Disjoint set union parent array\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]); // Path compression\n    }\n    return parent[x];\n}\n\nbool union_sets(int a, int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) {\n        return false; // Cycle detected\n    }\n    parent[pa] = pb;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loop detected at vertex %d\", ai);\n\n        bool united = union_sets(ai, bi);\n        ensuref(united, \"Edge between vertices %d and %d creates a cycle\", ai, bi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000; // Maximum value for n\n\nint parent[MAX_N + 1]; // Disjoint set union parent array\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]); // Path compression\n    }\n    return parent[x];\n}\n\nbool union_sets(int a, int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) {\n        return false; // Cycle detected\n    }\n    parent[pa] = pb;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loop detected at vertex %d\", ai);\n\n        bool united = union_sets(ai, bi);\n        ensuref(united, \"Edge between vertices %d and %d creates a cycle\", ai, bi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000; // Maximum value for n\n\nint parent[MAX_N + 1]; // Disjoint set union parent array\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]); // Path compression\n    }\n    return parent[x];\n}\n\nbool union_sets(int a, int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) {\n        return false; // Cycle detected\n    }\n    parent[pa] = pb;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loop detected at vertex %d\", ai);\n\n        bool united = union_sets(ai, bi);\n        ensuref(united, \"Edge between vertices %d and %d creates a cycle\", ai, bi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n);\n    string type = opt<string>(\"type\", \"random\");\n    bool shuffle_labels = opt<bool>(\"shuffle\", false);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Nodes connected in order\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Node 1 connected to all other nodes\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"clustered\") {\n        // Divide into clusters\n        int c = min(n, 10); // Number of clusters, can be adjusted\n        vector<int> cluster_sizes(c, n / c);\n        for (int i = 0; i < n % c; ++i)\n            cluster_sizes[i]++;\n\n        vector<int> cluster_starts(c + 1);\n        cluster_starts[0] = 1;\n        for (int i = 0; i < c; ++i)\n            cluster_starts[i + 1] = cluster_starts[i] + cluster_sizes[i];\n\n        // Build edges within clusters\n        for (int i = 0; i < c; ++i) {\n            int start = cluster_starts[i];\n            int end = cluster_starts[i + 1] - 1;\n            // Connect nodes in cluster as chain\n            for (int j = start; j < end; ++j) {\n                edges.push_back({j, j + 1});\n            }\n        }\n        // Connect clusters\n        for (int i = 0; i < c - 1; ++i) {\n            int u = cluster_starts[i + 1] - 1; // Last node of cluster i\n            int v = cluster_starts[i + 1];     // First node of cluster i+1\n            edges.push_back({u, v});\n        }\n    } else if (type == \"reverse_chain\") {\n        // Nodes connected in reverse order\n        for (int i = n; i > 1; --i) {\n            edges.push_back({i, i - 1});\n        }\n    } else if (type == \"random_labels\") {\n        // Generate chain\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Shuffling labels will be handled below\n    } else { // random\n        // Generate random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle labels if required\n    if (shuffle_labels) {\n        vector<int> perm(n + 1);\n        for (int i = 1; i <= n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin() + 1, perm.end());\n\n        // Remap edges\n        for (auto& e : edges) {\n            e.first = perm[e.first];\n            e.second = perm[e.second];\n        }\n    }\n\n    // Shuffle edges to prevent potential hardcoding\n    shuffle(edges.begin(), edges.end());\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n);\n    string type = opt<string>(\"type\", \"random\");\n    bool shuffle_labels = opt<bool>(\"shuffle\", false);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Nodes connected in order\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Node 1 connected to all other nodes\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"clustered\") {\n        // Divide into clusters\n        int c = min(n, 10); // Number of clusters, can be adjusted\n        vector<int> cluster_sizes(c, n / c);\n        for (int i = 0; i < n % c; ++i)\n            cluster_sizes[i]++;\n\n        vector<int> cluster_starts(c + 1);\n        cluster_starts[0] = 1;\n        for (int i = 0; i < c; ++i)\n            cluster_starts[i + 1] = cluster_starts[i] + cluster_sizes[i];\n\n        // Build edges within clusters\n        for (int i = 0; i < c; ++i) {\n            int start = cluster_starts[i];\n            int end = cluster_starts[i + 1] - 1;\n            // Connect nodes in cluster as chain\n            for (int j = start; j < end; ++j) {\n                edges.push_back({j, j + 1});\n            }\n        }\n        // Connect clusters\n        for (int i = 0; i < c - 1; ++i) {\n            int u = cluster_starts[i + 1] - 1; // Last node of cluster i\n            int v = cluster_starts[i + 1];     // First node of cluster i+1\n            edges.push_back({u, v});\n        }\n    } else if (type == \"reverse_chain\") {\n        // Nodes connected in reverse order\n        for (int i = n; i > 1; --i) {\n            edges.push_back({i, i - 1});\n        }\n    } else if (type == \"random_labels\") {\n        // Generate chain\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Shuffling labels will be handled below\n    } else { // random\n        // Generate random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle labels if required\n    if (shuffle_labels) {\n        vector<int> perm(n + 1);\n        for (int i = 1; i <= n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin() + 1, perm.end());\n\n        // Remap edges\n        for (auto& e : edges) {\n            e.first = perm[e.first];\n            e.second = perm[e.second];\n        }\n    }\n\n    // Shuffle edges to prevent potential hardcoding\n    shuffle(edges.begin(), edges.end());\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type chain\n./gen -n 2 -k 1 -type chain\n./gen -n 2 -k 2 -type chain -shuffle\n\n./gen -n 5 -k 1 -type star\n./gen -n 5 -k 3 -type chain -shuffle\n./gen -n 5 -k 5 -type random\n\n./gen -n 10 -k 5 -type chain\n./gen -n 10 -k 10 -type star\n./gen -n 10 -k 7 -type clustered -shuffle\n\n./gen -n 100 -k 50 -type chain\n./gen -n 100 -k 100 -type random_labels\n./gen -n 100 -k 25 -type star -shuffle\n\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 1000 -type clustered\n./gen -n 1000 -k 10 -type reverse_chain -shuffle\n\n./gen -n 10000 -k 5000 -type chain\n./gen -n 10000 -k 10000 -type random_labels -shuffle\n\n./gen -n 100000 -k 1 -type star\n./gen -n 100000 -k 100000 -type chain\n./gen -n 100000 -k 50000 -type clustered -shuffle\n\n./gen -n 100000 -k 1 -type random -shuffle\n./gen -n 100000 -k 75000 -type reverse_chain\n\n./gen -n 99999 -k 99999 -type star -shuffle\n./gen -n 100000 -k 1 -type random_labels\n\n./gen -n 100000 -k 100000 -type random\n./gen -n 100000 -k 100000 -type random_labels -shuffle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:34.611842",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "372/E",
      "title": "E. Drawing Circles is Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of points in S. Each of the next n lines contains four integers ai, bi, ci, di (0 ≤ |ai|, |ci| ≤ 50; 1 ≤ bi, di ≤ 50; (ai, ci) ≠ (0, 0)). These integers represent a point .No two points coincide.",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy10-46 46 0 360 20 -24 48-50 50 -49 49-20 50 8 40-15 30 14 284 10 -4 56 15 8 10-20 50 -3 154 34 -16 3416 34 2 17OutputCopy2InputCopy1030 30 -26 260 15 -36 36-28 28 -34 3410 10 0 4-8 20 40 509 45 12 306 15 7 3536 45 -8 20-16 34 -4 344 34 8 17OutputCopy4InputCopy100 20 38 38-30 30 -13 13-11 11 16 1630 30 0 376 30 -4 106 15 12 15-4 5 -10 25-16 20 4 108 17 -2 1716 34 2 17OutputCopy10",
      "description": "E. Drawing Circles is Fun\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of points in S. Each of the next n lines contains four integers ai, bi, ci, di (0 ≤ |ai|, |ci| ≤ 50; 1 ≤ bi, di ≤ 50; (ai, ci) ≠ (0, 0)). These integers represent a point .No two points coincide.\n\nOutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy10-46 46 0 360 20 -24 48-50 50 -49 49-20 50 8 40-15 30 14 284 10 -4 56 15 8 10-20 50 -3 154 34 -16 3416 34 2 17OutputCopy2InputCopy1030 30 -26 260 15 -36 36-28 28 -34 3410 10 0 4-8 20 40 509 45 12 306 15 7 3536 45 -8 20-16 34 -4 344 34 8 17OutputCopy4InputCopy100 20 38 38-30 30 -13 13-11 11 16 1630 30 0 376 30 -4 106 15 12 15-4 5 -10 25-16 20 4 108 17 -2 1716 34 2 17OutputCopy10\n\nInputCopy10-46 46 0 360 20 -24 48-50 50 -49 49-20 50 8 40-15 30 14 284 10 -4 56 15 8 10-20 50 -3 154 34 -16 3416 34 2 17\n\nOutputCopy2\n\nInputCopy1030 30 -26 260 15 -36 36-28 28 -34 3410 10 0 4-8 20 40 509 45 12 306 15 7 3536 45 -8 20-16 34 -4 344 34 8 17\n\nOutputCopy4\n\nInputCopy100 20 38 38-30 30 -13 13-11 11 16 1630 30 0 376 30 -4 106 15 12 15-4 5 -10 25-16 20 4 108 17 -2 1716 34 2 17\n\nOutputCopy10",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Hello.Codeforces Round #219 will take place on December 13th at 18:00 MSK for both Div.1 and Div.2 participant. Make sure that it will be held unusual　time.Problem setters are kagamiz and DEGwer, and we thank Gerald for helping us to hold this contest, and Delinur for the translation, and MikeMirzayanov for systems.The score distribution will be uploaded soon, but probably we use the standard scoring system.UPD1: The score distribution is standard, 500-1000-1500-2000-2500 for both division.UPD2: Problem B from Div.2 and problem C from Div.1 have some problems, so all submissions to these problems are rejudged. I'm very sorry.UPD3: Anyone who gets AC two or more times, because of resubmit before clarification, please, write to Gerald, your submissions that should be skipped. Sorry for inconvenience.UPD4: Now system test has finished, congratulation for winners!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackAnd also congrats for rng_58 and permin, who got AC on Div.1 E problem!!UPD5: Now editorial is uploaded here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1105
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Collecting Beats is Fun /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Making Sequences is Fun /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Counting Kangaroos is Fun / 372A - Counting Kangaroos is Fun /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Counting Rectangles is Fun / 372B - Counting Rectangles is Fun /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Watching Fireworks is Fun / 372C - Watching Fireworks is Fun /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Choosing Subtree is Fun /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Drawing Circles is Fun /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 372\\s*E"
          },
          "content_length": 6042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> ai(n), bi(n), ci(n), di(n);\n    for (int i = 0; i < n; ++i) {\n        ai[i] = inf.readInt(-50, 50, \"ai\");\n        inf.readSpace();\n        bi[i] = inf.readInt(1, 50, \"bi\");\n        inf.readSpace();\n        ci[i] = inf.readInt(-50, 50, \"ci\");\n        inf.readSpace();\n        di[i] = inf.readInt(1, 50, \"di\");\n        inf.readEoln();\n        ensuref(ai[i] != 0 || ci[i] != 0, \"Point #%d cannot be (0,0)\", i+1);\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int64_t xi1 = int64_t(ai[i]) * bi[j];\n            int64_t xi2 = int64_t(ai[j]) * bi[i];\n            int64_t yi1 = int64_t(ci[i]) * di[j];\n            int64_t yi2 = int64_t(ci[j]) * di[i];\n            if (xi1 == xi2 && yi1 == yi2) {\n                ensuref(false, \"Points #%d and #%d coincide\", i+1, j+1);\n            }\n            int64_t N = int64_t(ai[i]) * ci[j] * bi[j] * di[i] - int64_t(ai[j]) * ci[i] * bi[i] * di[j];\n            ensuref(N != 0, \"Vectors to points #%d and #%d are colinear\", i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> ai(n), bi(n), ci(n), di(n);\n    for (int i = 0; i < n; ++i) {\n        ai[i] = inf.readInt(-50, 50, \"ai\");\n        inf.readSpace();\n        bi[i] = inf.readInt(1, 50, \"bi\");\n        inf.readSpace();\n        ci[i] = inf.readInt(-50, 50, \"ci\");\n        inf.readSpace();\n        di[i] = inf.readInt(1, 50, \"di\");\n        inf.readEoln();\n        ensuref(ai[i] != 0 || ci[i] != 0, \"Point #%d cannot be (0,0)\", i+1);\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int64_t xi1 = int64_t(ai[i]) * bi[j];\n            int64_t xi2 = int64_t(ai[j]) * bi[i];\n            int64_t yi1 = int64_t(ci[i]) * di[j];\n            int64_t yi2 = int64_t(ci[j]) * di[i];\n            if (xi1 == xi2 && yi1 == yi2) {\n                ensuref(false, \"Points #%d and #%d coincide\", i+1, j+1);\n            }\n            int64_t N = int64_t(ai[i]) * ci[j] * bi[j] * di[i] - int64_t(ai[j]) * ci[i] * bi[i] * di[j];\n            ensuref(N != 0, \"Vectors to points #%d and #%d are colinear\", i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> ai(n), bi(n), ci(n), di(n);\n    for (int i = 0; i < n; ++i) {\n        ai[i] = inf.readInt(-50, 50, \"ai\");\n        inf.readSpace();\n        bi[i] = inf.readInt(1, 50, \"bi\");\n        inf.readSpace();\n        ci[i] = inf.readInt(-50, 50, \"ci\");\n        inf.readSpace();\n        di[i] = inf.readInt(1, 50, \"di\");\n        inf.readEoln();\n        ensuref(ai[i] != 0 || ci[i] != 0, \"Point #%d cannot be (0,0)\", i+1);\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int64_t xi1 = int64_t(ai[i]) * bi[j];\n            int64_t xi2 = int64_t(ai[j]) * bi[i];\n            int64_t yi1 = int64_t(ci[i]) * di[j];\n            int64_t yi2 = int64_t(ci[j]) * di[i];\n            if (xi1 == xi2 && yi1 == yi2) {\n                ensuref(false, \"Points #%d and #%d coincide\", i+1, j+1);\n            }\n            int64_t N = int64_t(ai[i]) * ci[j] * bi[j] * di[i] - int64_t(ai[j]) * ci[i] * bi[i] * di[j];\n            ensuref(N != 0, \"Vectors to points #%d and #%d are colinear\", i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> slopes;\n    set<pair<int, int>> points;\n    vector<tuple<int, int, int, int>> data;\n\n    if (type == \"random\") {\n        while ((int)data.size() < n) {\n            int ai = rnd.next(-50, 50);\n            while(ai == 0) ai = rnd.next(-50,50);\n            int bi = 1;\n            int ci = rnd.next(-50, 50);\n            int di = 1;\n            // Ensure (ai, ci) != (0, 0)\n            if (ai == 0 && ci == 0) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute slope ci/ai reduced\n            int num = ci;\n            int denom = ai;\n            int g = __gcd(num, denom);\n            num /= g;\n            denom /= g;\n            if (denom < 0) {\n                denom = -denom;\n                num = -num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({num, denom})) continue;\n            slopes.insert({num, denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n        }\n    } else if (type == \"circle\") {\n        // Generate points equally spaced around a circle centered at origin\n        for(int i = 0; i < n*10; ++i) {\n            double angle = 2 * M_PI * i / (n*10);\n            double x = cos(angle);\n            double y = sin(angle);\n            // Scale to integers within range\n            int ai = (int)round(x * 50);\n            int ci = (int)round(y * 50);\n            if (ai == 0 && ci == 0) continue; // avoid (0,0)\n            int bi = 1;\n            int di = 1;\n            // Ensure within constraints\n            if (ai < -50 || ai > 50 || ci < -50 || ci > 50) continue;\n            // Ensure ai != 0\n            if (ai == 0) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute slope\n            int num = ci;\n            int denom = ai;\n            int g = __gcd(num, denom);\n            num /= g;\n            denom /= g;\n            if (denom < 0) {\n                denom = -denom;\n                num = -num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({num, denom})) continue;\n            slopes.insert({num, denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n            if ((int)data.size() >= n) break;\n        }\n    } else if (type == \"near_colinear\") {\n        // Generate points that are nearly colinear with the origin\n        int base_slope_num = rnd.next(-50,50);\n        while(base_slope_num == 0) base_slope_num = rnd.next(-50,50);\n        int base_slope_denom = rnd.next(1,50);\n        for(int i = 0; i < n*10 && (int)data.size() < n; ++i) {\n            // Perturb the slope slightly\n            int num = base_slope_num + rnd.next(-5,5);\n            int denom = base_slope_denom + rnd.next(-5,5);\n            if(denom == 0 || num == 0) continue;\n            // Compute ai, ci\n            int ai = denom;\n            int ci = num;\n            if(ai == 0) continue;\n            int bi = 1;\n            int di = 1;\n            // Ensure within constraints\n            if(ai < -50 || ai > 50 || ci < -50 || ci > 50) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute reduced slope\n            int g = __gcd(ci, ai);\n            int reduced_num = ci / g;\n            int reduced_denom = ai / g;\n            if (reduced_denom < 0) {\n                reduced_denom = -reduced_denom;\n                reduced_num = -reduced_num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({reduced_num, reduced_denom})) continue;\n            slopes.insert({reduced_num, reduced_denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n        }\n    } else {\n        // default to random\n        while ((int)data.size() < n) {\n            int ai = rnd.next(-50, 50);\n            while(ai == 0) ai = rnd.next(-50,50);\n            int bi = 1;\n            int ci = rnd.next(-50, 50);\n            int di = 1;\n            // Ensure (ai, ci) != (0, 0)\n            if (ai == 0 && ci == 0) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute slope ci/ai reduced\n            int num = ci;\n            int denom = ai;\n            int g = __gcd(num, denom);\n            num /= g;\n            denom /= g;\n            if (denom < 0) {\n                denom = -denom;\n                num = -num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({num, denom})) continue;\n            slopes.insert({num, denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)data.size());\n    for(auto& t : data) {\n        int ai = get<0>(t);\n        int bi = get<1>(t);\n        int ci = get<2>(t);\n        int di = get<3>(t);\n        printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> slopes;\n    set<pair<int, int>> points;\n    vector<tuple<int, int, int, int>> data;\n\n    if (type == \"random\") {\n        while ((int)data.size() < n) {\n            int ai = rnd.next(-50, 50);\n            while(ai == 0) ai = rnd.next(-50,50);\n            int bi = 1;\n            int ci = rnd.next(-50, 50);\n            int di = 1;\n            // Ensure (ai, ci) != (0, 0)\n            if (ai == 0 && ci == 0) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute slope ci/ai reduced\n            int num = ci;\n            int denom = ai;\n            int g = __gcd(num, denom);\n            num /= g;\n            denom /= g;\n            if (denom < 0) {\n                denom = -denom;\n                num = -num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({num, denom})) continue;\n            slopes.insert({num, denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n        }\n    } else if (type == \"circle\") {\n        // Generate points equally spaced around a circle centered at origin\n        for(int i = 0; i < n*10; ++i) {\n            double angle = 2 * M_PI * i / (n*10);\n            double x = cos(angle);\n            double y = sin(angle);\n            // Scale to integers within range\n            int ai = (int)round(x * 50);\n            int ci = (int)round(y * 50);\n            if (ai == 0 && ci == 0) continue; // avoid (0,0)\n            int bi = 1;\n            int di = 1;\n            // Ensure within constraints\n            if (ai < -50 || ai > 50 || ci < -50 || ci > 50) continue;\n            // Ensure ai != 0\n            if (ai == 0) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute slope\n            int num = ci;\n            int denom = ai;\n            int g = __gcd(num, denom);\n            num /= g;\n            denom /= g;\n            if (denom < 0) {\n                denom = -denom;\n                num = -num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({num, denom})) continue;\n            slopes.insert({num, denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n            if ((int)data.size() >= n) break;\n        }\n    } else if (type == \"near_colinear\") {\n        // Generate points that are nearly colinear with the origin\n        int base_slope_num = rnd.next(-50,50);\n        while(base_slope_num == 0) base_slope_num = rnd.next(-50,50);\n        int base_slope_denom = rnd.next(1,50);\n        for(int i = 0; i < n*10 && (int)data.size() < n; ++i) {\n            // Perturb the slope slightly\n            int num = base_slope_num + rnd.next(-5,5);\n            int denom = base_slope_denom + rnd.next(-5,5);\n            if(denom == 0 || num == 0) continue;\n            // Compute ai, ci\n            int ai = denom;\n            int ci = num;\n            if(ai == 0) continue;\n            int bi = 1;\n            int di = 1;\n            // Ensure within constraints\n            if(ai < -50 || ai > 50 || ci < -50 || ci > 50) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute reduced slope\n            int g = __gcd(ci, ai);\n            int reduced_num = ci / g;\n            int reduced_denom = ai / g;\n            if (reduced_denom < 0) {\n                reduced_denom = -reduced_denom;\n                reduced_num = -reduced_num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({reduced_num, reduced_denom})) continue;\n            slopes.insert({reduced_num, reduced_denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n        }\n    } else {\n        // default to random\n        while ((int)data.size() < n) {\n            int ai = rnd.next(-50, 50);\n            while(ai == 0) ai = rnd.next(-50,50);\n            int bi = 1;\n            int ci = rnd.next(-50, 50);\n            int di = 1;\n            // Ensure (ai, ci) != (0, 0)\n            if (ai == 0 && ci == 0) continue;\n            // Ensure point is not duplicate\n            if (points.count({ai, ci})) continue;\n            // Compute slope ci/ai reduced\n            int num = ci;\n            int denom = ai;\n            int g = __gcd(num, denom);\n            num /= g;\n            denom /= g;\n            if (denom < 0) {\n                denom = -denom;\n                num = -num;\n            }\n            // Ensure slope is unique\n            if (slopes.count({num, denom})) continue;\n            slopes.insert({num, denom});\n            points.insert({ai, ci});\n            data.push_back({ai, bi, ci, di});\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)data.size());\n    for(auto& t : data) {\n        int ai = get<0>(t);\n        int bi = get<1>(t);\n        int ci = get<2>(t);\n        int di = get<3>(t);\n        printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 999 -type random\n./gen -n 1000 -type random\n\n./gen -n 1 -type circle\n./gen -n 2 -type circle\n./gen -n 5 -type circle\n./gen -n 10 -type circle\n./gen -n 50 -type circle\n./gen -n 100 -type circle\n./gen -n 500 -type circle\n./gen -n 999 -type circle\n./gen -n 1000 -type circle\n\n./gen -n 1 -type near_colinear\n./gen -n 2 -type near_colinear\n./gen -n 5 -type near_colinear\n./gen -n 10 -type near_colinear\n./gen -n 50 -type near_colinear\n./gen -n 100 -type near_colinear\n./gen -n 500 -type near_colinear\n./gen -n 999 -type near_colinear\n./gen -n 1000 -type near_colinear\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:36.853827",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "373/A",
      "title": "A. Весело нажимать на панели",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число k (1 ≤ k ≤ 5) — количество панелей, которые мальчик-огуречик может нажать одной своей рукой.В следующих 4 строках записано по 4 символа (цифры от 1 до 9 или точка) — таблица игры. Если на панели записано число i, то значит, надо нажать эту панель во время i. Если на панели записана точка, значит, эту панель нажимать не обязательно.",
      "output_spec": "Выходные данныеВыведите «YES» (без кавычек), если мальчик сможет нажать все панели как нужно. В противном случае выведите «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать1.135124734685789Выходные данныеСкопироватьYESВходные данныеСкопировать5..1.1111..1...1.Выходные данныеСкопироватьYESВходные данныеСкопировать1....12.1.2...2..Выходные данныеСкопироватьNO",
      "description": "A. Весело нажимать на панели\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число k (1 ≤ k ≤ 5) — количество панелей, которые мальчик-огуречик может нажать одной своей рукой.В следующих 4 строках записано по 4 символа (цифры от 1 до 9 или точка) — таблица игры. Если на панели записано число i, то значит, надо нажать эту панель во время i. Если на панели записана точка, значит, эту панель нажимать не обязательно.\n\nВходные данные\n\nВыходные данныеВыведите «YES» (без кавычек), если мальчик сможет нажать все панели как нужно. В противном случае выведите «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать1.135124734685789Выходные данныеСкопироватьYESВходные данныеСкопировать5..1.1111..1...1.Выходные данныеСкопироватьYESВходные данныеСкопировать1....12.1.2...2..Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать1.135124734685789\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5..1.1111..1...1.\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1....12.1.2...2..\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ третьем тестовом примере мальчик не может достигнуть цели. Он сможет нажать двумя руками панели в момент времени 1, но не сможет нажать панели двумя руками в момент времени 2.",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Привет.Codeforces Round #219 начнется 13-го декабря в 18:00 MSK, раунд будет проводиться как для участников из Div. 1, так и для Div. 2 участников. Обратите внимание, что раунд проводится в нестандартное время.Задачи готовили kagamiz и DEGwer. Мы хотим поблагодарить Gerald за помощь в организации раунда, Delinur за перевод, а MikeMirzayanov за систему.Распределение баллов по задачам скоро будет анонсировано, вполне вероятно, будет стандартное распределение баллов по задачам.UPD1: Распределение баллов по задачам, 500-1000-1500-2000-2500 для обоих дивизионов.UPD2: В задачах B из Div. 2 и C из Div. 1 были проблемы, все решения перетестированы. Извиняюсь, за это.UPD3: Все кто получили двойной или более AC из-за того, что перепослали решение до объявления, пожалуйста, напишите Gerald номера посылок, которые нужно отменить. Просим прощение за принесенные неудобства.UPD4: Системное тестирование завершилось, поздравления победителям!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackОсобенно поздравляем rng_58 и permin, которые решили задачу E в Div. 1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1134
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Весело нажимать на панели /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Весело составлять последовательности /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Весело считать Кенгуру / 372A - Весело считать Кенгуру /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Весело считать прямоугольники / 372B - Весело считать прямоугольники /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Весело смотреть на фейерверки / 372C - Весело смотреть на фейерверки /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Весело выбирать поддерево /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Весело рисовать круги /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 373\\s*A"
          },
          "content_length": 6066
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "40 - 82 - 201 - 405 - 814\n45 - 94 - 204 - 409 - 819\n48 - 97 - 205 - 433 - 886\n54 - 109 - 222 - 449 - 911\n60 - 125 - 271 - 549\n83 - 237 - 474 - 948\n110 - 240 - 484 - 972\n130 - 271 - 570\n132 - 276 - 576\n134 - 282 - 579\n139 - 288 - 589\n139 - 288 - 590\n141 - 303 - 618\n142 - 314 - 636\n145 - 330 - 666\n146 - 336 - 682\n150 - 341 - 702\n154 - 347 - 735\n242 - 520\n245 - 535\n249 - 601\n364 - 754\n384 - 775\n438 - 896\n441 - 911\n454 - 916\n601\n604\n638\n647\n655\n778\n783\n804\n807\n836\n841\n842\n845\n923\n930\n938\n952\n957\n974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "40 - 82 - 201 - 405 - 814\n45 - 94 - 204 - 409 - 819\n48 - 97 - 205 - 433 - 886\n54 - 109 - 222 - 449 - 911\n60 - 125 - 271 - 549\n83 - 237 - 474 - 948\n110 - 240 - 484 - 972\n130 - 271 - 570\n132 - 276 - 576\n134 - 282 - 579\n139 - 288 - 589\n139 - 288 - 590\n141 - 303 - 618\n142 - 314 - 636\n145 - 330 - 666\n146 - 336 - 682\n150 - 341 - 702\n154 - 347 - 735\n242 - 520\n245 - 535\n249 - 601\n364 - 754\n384 - 775\n438 - 896\n441 - 911\n454 - 916\n601\n604\n638\n647\n655\n778\n783\n804\n807\n836\n841\n842\n845\n923\n930\n938\n952\n957\n974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "d = n/2;x =0; m = n;\nwhile (d > 0 && n > d){\n\t\tif (2*s[d] <= s[n]){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tn--;\n\t\t}\n\t\telse {\n\t\t\td--;\n\t\t}\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "d = n/2;x =0; m = n;\nwhile (d > 0 && n > d){\n\t\tif (2*s[d] <= s[n]){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tn--;\n\t\t}\n\t\telse {\n\t\t\td--;\n\t\t}\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 31",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 32",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 33",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 34",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < 4; i++) {\n        string s = inf.readLine(\"^[1-9.]{4}$\", \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < 4; i++) {\n        string s = inf.readLine(\"^[1-9.]{4}$\", \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < 4; i++) {\n        string s = inf.readLine(\"^[1-9.]{4}$\", \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Verify that k is within 1 ≤ k ≤5\n    ensure(k >= 1 && k <=5);\n\n    vector<string> grid(4, string(4, '.')); // Initialize grid with periods\n\n    if (type == \"empty\") {\n        // Do nothing, grid is already filled with periods\n    } else if (type == \"full\") {\n        // Fill grid with digits from 1 to 9, make sure that no time requires pressing more than 2k panels\n        int times_needed = (16 + 2*k -1) / (2*k); // Ceiling division\n\n        vector<int> times;\n        for(int t = 1; t <= 9 && (int)times.size() < times_needed; ++t) {\n            times.push_back(t);\n        }\n\n        while ((int)times.size() < times_needed) {\n            times.push_back(times.back()); // reuse last time if needed\n        }\n\n        vector<int> counts(10, 0); // Index 1..9\n\n        int panel_count = 0;\n        for(int i = 0; i < 4; ++i) {\n            for(int j = 0; j < 4; ++j) {\n                int t = times[panel_count % times.size()];\n                counts[t]++;\n                ensure(counts[t] <= 2*k);\n                grid[i][j] = '0' + t;\n                panel_count++;\n            }\n        }\n\n    } else if (type == \"overload\") {\n        // Create a time where number of panels to press > 2k\n        int t = rnd.next(1, 9);\n        int overload_count = 2*k + 1; // Number of panels at time t\n\n        vector<int> positions;\n\n        for(int i = 0; i < 16; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n\n        for(int idx = 0; idx < overload_count; ++idx) {\n            int pos = positions[idx];\n            int row = pos / 4;\n            int col = pos % 4;\n            grid[row][col] = '0' + t;\n        }\n        // The rest of the grid remains periods\n\n    } else if (type == \"max_press\") {\n        // Create a time where number of panels to press ==2k\n        int t = rnd.next(1, 9);\n        int panel_count = 2*k;\n\n        vector<int> positions;\n        for(int i = 0; i < 16; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n\n        for(int idx = 0; idx < panel_count; ++idx) {\n            int pos = positions[idx];\n            int row = pos / 4;\n            int col = pos % 4;\n            grid[row][col] = '0' + t;\n        }\n\n    } else if (type == \"same_time\") {\n        // All panels have the same time t\n        int t = rnd.next(1,9);\n\n        for(int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                grid[i][j] = '0' + t;\n            }\n        }\n        // Answer is YES if 2k >=16, else NO\n\n    } else if (type == \"random\") {\n        // Random grid with random digits and periods\n        for (int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                if (rnd.next(0,1)) {\n                    // Set digit\n                    int t = rnd.next(1,9);\n                    grid[i][j] = '0' + t;\n                } else {\n                    // Period\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        // For random cases, we may or may not satisfy the constraints. So output could be \"YES\" or \"NO\".\n\n    } else if (type == \"edge_k1\") {\n        // k=1, generate specific test cases if needed\n        ensure(k == 1);\n        // Let's create a grid where at time t, exactly 2k panels need to be pressed\n        int t = rnd.next(1,9);\n        int panel_count = 2*k;\n\n        vector<int> positions;\n        for(int i = 0; i < 16; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n\n        for(int idx = 0; idx < panel_count; ++idx) {\n            int pos = positions[idx];\n            int row = pos / 4;\n            int col = pos % 4;\n            grid[row][col] = '0' + t;\n        }\n\n    } else if (type == \"edge_k5\") {\n        // k=5, generate specific test cases if needed\n        ensure(k == 5);\n        // Could be a same_time test case\n        int t = rnd.next(1,9);\n        for(int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                grid[i][j] = '0' + t;\n            }\n        }\n\n    } else {\n        // Default random\n        // Could call \"random\" code\n        for (int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                if (rnd.next(0,1)) {\n                    // Set digit\n                    int t = rnd.next(1,9);\n                    grid[i][j] = '0' + t;\n                } else {\n                    // Period\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n\n    // Now, output the test case\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < 4; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Verify that k is within 1 ≤ k ≤5\n    ensure(k >= 1 && k <=5);\n\n    vector<string> grid(4, string(4, '.')); // Initialize grid with periods\n\n    if (type == \"empty\") {\n        // Do nothing, grid is already filled with periods\n    } else if (type == \"full\") {\n        // Fill grid with digits from 1 to 9, make sure that no time requires pressing more than 2k panels\n        int times_needed = (16 + 2*k -1) / (2*k); // Ceiling division\n\n        vector<int> times;\n        for(int t = 1; t <= 9 && (int)times.size() < times_needed; ++t) {\n            times.push_back(t);\n        }\n\n        while ((int)times.size() < times_needed) {\n            times.push_back(times.back()); // reuse last time if needed\n        }\n\n        vector<int> counts(10, 0); // Index 1..9\n\n        int panel_count = 0;\n        for(int i = 0; i < 4; ++i) {\n            for(int j = 0; j < 4; ++j) {\n                int t = times[panel_count % times.size()];\n                counts[t]++;\n                ensure(counts[t] <= 2*k);\n                grid[i][j] = '0' + t;\n                panel_count++;\n            }\n        }\n\n    } else if (type == \"overload\") {\n        // Create a time where number of panels to press > 2k\n        int t = rnd.next(1, 9);\n        int overload_count = 2*k + 1; // Number of panels at time t\n\n        vector<int> positions;\n\n        for(int i = 0; i < 16; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n\n        for(int idx = 0; idx < overload_count; ++idx) {\n            int pos = positions[idx];\n            int row = pos / 4;\n            int col = pos % 4;\n            grid[row][col] = '0' + t;\n        }\n        // The rest of the grid remains periods\n\n    } else if (type == \"max_press\") {\n        // Create a time where number of panels to press ==2k\n        int t = rnd.next(1, 9);\n        int panel_count = 2*k;\n\n        vector<int> positions;\n        for(int i = 0; i < 16; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n\n        for(int idx = 0; idx < panel_count; ++idx) {\n            int pos = positions[idx];\n            int row = pos / 4;\n            int col = pos % 4;\n            grid[row][col] = '0' + t;\n        }\n\n    } else if (type == \"same_time\") {\n        // All panels have the same time t\n        int t = rnd.next(1,9);\n\n        for(int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                grid[i][j] = '0' + t;\n            }\n        }\n        // Answer is YES if 2k >=16, else NO\n\n    } else if (type == \"random\") {\n        // Random grid with random digits and periods\n        for (int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                if (rnd.next(0,1)) {\n                    // Set digit\n                    int t = rnd.next(1,9);\n                    grid[i][j] = '0' + t;\n                } else {\n                    // Period\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        // For random cases, we may or may not satisfy the constraints. So output could be \"YES\" or \"NO\".\n\n    } else if (type == \"edge_k1\") {\n        // k=1, generate specific test cases if needed\n        ensure(k == 1);\n        // Let's create a grid where at time t, exactly 2k panels need to be pressed\n        int t = rnd.next(1,9);\n        int panel_count = 2*k;\n\n        vector<int> positions;\n        for(int i = 0; i < 16; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n\n        for(int idx = 0; idx < panel_count; ++idx) {\n            int pos = positions[idx];\n            int row = pos / 4;\n            int col = pos % 4;\n            grid[row][col] = '0' + t;\n        }\n\n    } else if (type == \"edge_k5\") {\n        // k=5, generate specific test cases if needed\n        ensure(k == 5);\n        // Could be a same_time test case\n        int t = rnd.next(1,9);\n        for(int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                grid[i][j] = '0' + t;\n            }\n        }\n\n    } else {\n        // Default random\n        // Could call \"random\" code\n        for (int i = 0; i < 4; ++i) {\n            for(int j = 0; j <4; ++j) {\n                if (rnd.next(0,1)) {\n                    // Set digit\n                    int t = rnd.next(1,9);\n                    grid[i][j] = '0' + t;\n                } else {\n                    // Period\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n\n    // Now, output the test case\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < 4; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 1 -type empty\n./gen -k 5 -type empty\n\n./gen -k 1 -type full\n./gen -k 2 -type full\n./gen -k 3 -type full\n./gen -k 5 -type full\n\n./gen -k 1 -type overload\n./gen -k 2 -type overload\n./gen -k 3 -type overload\n./gen -k 5 -type overload\n\n./gen -k 1 -type max_press\n./gen -k 2 -type max_press\n./gen -k 3 -type max_press\n./gen -k 5 -type max_press\n\n./gen -k 1 -type same_time\n./gen -k 2 -type same_time\n./gen -k 3 -type same_time\n./gen -k 5 -type same_time\n\n./gen -k 1 -type random\n./gen -k 2 -type random\n./gen -k 3 -type random\n./gen -k 5 -type random\n\n./gen -k 1 -type edge_k1\n./gen -k 5 -type edge_k5\n\n./gen -k 3 -type random\n./gen -k 3 -type random\n./gen -k 3 -type random\n./gen -k 4 -type random\n./gen -k 4 -type random\n./gen -k 4 -type overload\n./gen -k 4 -type max_press\n./gen -k 2 -type random\n./gen -k 2 -type overload\n./gen -k 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:38.806261",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "373/B",
      "title": "B. Making Sequences is Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers w (1 ≤ w ≤ 1016), m (1 ≤ m ≤ 1016), k (1 ≤ k ≤ 109).Please, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputThe first line should contain a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy9 1 1OutputCopy9InputCopy77 7 7OutputCopy7InputCopy114 5 14OutputCopy6InputCopy1 1 2OutputCopy0",
      "description": "B. Making Sequences is Fun\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers w (1 ≤ w ≤ 1016), m (1 ≤ m ≤ 1016), k (1 ≤ k ≤ 109).Please, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputThe first line should contain a single integer — the answer to the problem.\n\nInputCopy9 1 1OutputCopy9InputCopy77 7 7OutputCopy7InputCopy114 5 14OutputCopy6InputCopy1 1 2OutputCopy0\n\nInputCopy9 1 1\n\nOutputCopy9\n\nInputCopy77 7 7\n\nOutputCopy7\n\nInputCopy114 5 14\n\nOutputCopy6\n\nInputCopy1 1 2\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Hello.Codeforces Round #219 will take place on December 13th at 18:00 MSK for both Div.1 and Div.2 participant. Make sure that it will be held unusual　time.Problem setters are kagamiz and DEGwer, and we thank Gerald for helping us to hold this contest, and Delinur for the translation, and MikeMirzayanov for systems.The score distribution will be uploaded soon, but probably we use the standard scoring system.UPD1: The score distribution is standard, 500-1000-1500-2000-2500 for both division.UPD2: Problem B from Div.2 and problem C from Div.1 have some problems, so all submissions to these problems are rejudged. I'm very sorry.UPD3: Anyone who gets AC two or more times, because of resubmit before clarification, please, write to Gerald, your submissions that should be skipped. Sorry for inconvenience.UPD4: Now system test has finished, congratulation for winners!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackAnd also congrats for rng_58 and permin, who got AC on Div.1 E problem!!UPD5: Now editorial is uploaded here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1105
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Collecting Beats is Fun /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Making Sequences is Fun /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Counting Kangaroos is Fun / 372A - Counting Kangaroos is Fun /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Counting Rectangles is Fun / 372B - Counting Rectangles is Fun /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Watching Fireworks is Fun / 372C - Watching Fireworks is Fun /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Choosing Subtree is Fun /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Drawing Circles is Fun /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 373\\s*B"
          },
          "content_length": 6042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long Min_w = 1LL;\n    const long long Max_w = 10000000000000000LL; // 1e16\n\n    const long long Min_m = 1LL;\n    const long long Max_m = 10000000000000000LL; // 1e16\n\n    const int Min_k = 1;\n    const int Max_k = 1000000000; // 1e9\n\n    long long w = inf.readLong(Min_w, Max_w, \"w\");\n    inf.readSpace();\n    long long m = inf.readLong(Min_m, Max_m, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(Min_k, Max_k, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long Min_w = 1LL;\n    const long long Max_w = 10000000000000000LL; // 1e16\n\n    const long long Min_m = 1LL;\n    const long long Max_m = 10000000000000000LL; // 1e16\n\n    const int Min_k = 1;\n    const int Max_k = 1000000000; // 1e9\n\n    long long w = inf.readLong(Min_w, Max_w, \"w\");\n    inf.readSpace();\n    long long m = inf.readLong(Min_m, Max_m, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(Min_k, Max_k, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long Min_w = 1LL;\n    const long long Max_w = 10000000000000000LL; // 1e16\n\n    const long long Min_m = 1LL;\n    const long long Max_m = 10000000000000000LL; // 1e16\n\n    const int Min_k = 1;\n    const int Max_k = 1000000000; // 1e9\n\n    long long w = inf.readLong(Min_w, Max_w, \"w\");\n    inf.readSpace();\n    long long m = inf.readLong(Min_m, Max_m, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(Min_k, Max_k, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long w_max = opt<long long>(\"w_max\", (long long)1e16);\n    long long m_max = opt<long long>(\"m_max\", (long long)1e16);\n    int k_max = opt<int>(\"k_max\", (int)1e9);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long w, m;\n    int k;\n\n    if (type == \"random\") {\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"max_w\") {\n        w = w_max;\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"min_w\") {\n        w = 1;\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"max_k\") {\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = k_max;\n    } else if (type == \"min_k\") {\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = 1;\n    } else if (type == \"max_m\") {\n        w = rnd.next(1LL, w_max);\n        m = m_max;\n        k = rnd.next(1, k_max);\n    } else if (type == \"min_m\") {\n        w = rnd.next(1LL, w_max);\n        m = 1;\n        k = rnd.next(1, k_max);\n    } else if (type == \"digit_transition\") {\n        // Set m to just before a power of 10 to test digit transitions\n        int num_digits = rnd.next(1, 16); // Number of digits from 1 to 16\n        long long power_of_10 = 1;\n        for (int i = 1; i <= num_digits; i++) {\n            power_of_10 *= 10;\n        }\n        m = max(1LL, power_of_10 - rnd.next(1LL, 10LL)); // m in [power_of_10 - 10, power_of_10 - 1]\n        w = rnd.next(1LL, w_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"small\") {\n        w = rnd.next(1, 100);    // Small w\n        m = rnd.next(1, 1000);   // Small m\n        k = rnd.next(1, 100);    // Small k\n    } else if (type == \"large\") {\n        w = w_max;\n        m = m_max;\n        k = k_max;\n    } else if (type == \"special_w_equals_cost_of_m\") {\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n        int num_digits = to_string(m).length();\n        w = (long long)num_digits * k; // w equals the cost to add m\n    } else if (type == \"special_w_less_than_cost_of_m\") {\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n        int num_digits = to_string(m).length();\n        w = rnd.next(1LL, (long long)num_digits * k - 1); // w less than the cost to add m\n        if (w <= 0) w = 1; // Ensure w >= 1\n    } else {\n        // Default to random\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    }\n\n    printf(\"%lld %lld %d\\n\", w, m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long w_max = opt<long long>(\"w_max\", (long long)1e16);\n    long long m_max = opt<long long>(\"m_max\", (long long)1e16);\n    int k_max = opt<int>(\"k_max\", (int)1e9);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long w, m;\n    int k;\n\n    if (type == \"random\") {\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"max_w\") {\n        w = w_max;\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"min_w\") {\n        w = 1;\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"max_k\") {\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = k_max;\n    } else if (type == \"min_k\") {\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = 1;\n    } else if (type == \"max_m\") {\n        w = rnd.next(1LL, w_max);\n        m = m_max;\n        k = rnd.next(1, k_max);\n    } else if (type == \"min_m\") {\n        w = rnd.next(1LL, w_max);\n        m = 1;\n        k = rnd.next(1, k_max);\n    } else if (type == \"digit_transition\") {\n        // Set m to just before a power of 10 to test digit transitions\n        int num_digits = rnd.next(1, 16); // Number of digits from 1 to 16\n        long long power_of_10 = 1;\n        for (int i = 1; i <= num_digits; i++) {\n            power_of_10 *= 10;\n        }\n        m = max(1LL, power_of_10 - rnd.next(1LL, 10LL)); // m in [power_of_10 - 10, power_of_10 - 1]\n        w = rnd.next(1LL, w_max);\n        k = rnd.next(1, k_max);\n    } else if (type == \"small\") {\n        w = rnd.next(1, 100);    // Small w\n        m = rnd.next(1, 1000);   // Small m\n        k = rnd.next(1, 100);    // Small k\n    } else if (type == \"large\") {\n        w = w_max;\n        m = m_max;\n        k = k_max;\n    } else if (type == \"special_w_equals_cost_of_m\") {\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n        int num_digits = to_string(m).length();\n        w = (long long)num_digits * k; // w equals the cost to add m\n    } else if (type == \"special_w_less_than_cost_of_m\") {\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n        int num_digits = to_string(m).length();\n        w = rnd.next(1LL, (long long)num_digits * k - 1); // w less than the cost to add m\n        if (w <= 0) w = 1; // Ensure w >= 1\n    } else {\n        // Default to random\n        w = rnd.next(1LL, w_max);\n        m = rnd.next(1LL, m_max);\n        k = rnd.next(1, k_max);\n    }\n\n    printf(\"%lld %lld %d\\n\", w, m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -w_max 100 -m_max 100 -k_max 10 -type random\n./gen -w_max 1000 -m_max 1000 -k_max 100 -type random\n./gen -w_max 10000000000000000 -m_max 10000000000000000 -k_max 1000000000 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type max_w\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type min_w\n\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type max_k\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type min_k\n\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type max_m\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type min_m\n\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type digit_transition\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type digit_transition\n./gen -w_max 1e3 -m_max 1e3 -k_max 1e2 -type small\n./gen -w_max 1e3 -m_max 1e3 -k_max 1e2 -type small\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type large\n\n# Edge cases\n# w just enough to buy m\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type special_w_equals_cost_of_m\n\n# w just not enough to buy m\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type special_w_less_than_cost_of_m\n\n# Maximal values for all parameters\n./gen -w_max 10000000000000000 -m_max 10000000000000000 -k_max 1000000000 -type large\n\n# Minimal values for all parameters\n./gen -w_max 1 -m_max 1 -k_max 1 -type small\n\n# Additional random tests\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n./gen -w_max 1e16 -m_max 1e16 -k_max 1e9 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:40.688825",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "373/C",
      "title": "C. Весело считать Кенгуру",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число — n (1 ≤ n ≤ 5·105). Каждая из следующих n строк содержит целое число si — размер i-го кенгуру (1 ≤ si ≤ 105).",
      "output_spec": "Выходные данныеВыведите единственное целое число — оптимальное количество видимых кенгуру.",
      "sample_tests": "ПримерыВходные данныеСкопировать825769842Выходные данныеСкопировать5Входные данныеСкопировать891626583Выходные данныеСкопировать5",
      "description": "C. Весело считать Кенгуру\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число — n (1 ≤ n ≤ 5·105). Каждая из следующих n строк содержит целое число si — размер i-го кенгуру (1 ≤ si ≤ 105).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — оптимальное количество видимых кенгуру.\n\nВыходные данные\n\nВходные данныеСкопировать825769842Выходные данныеСкопировать5Входные данныеСкопировать891626583Выходные данныеСкопировать5\n\nВходные данныеСкопировать825769842\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать891626583\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Привет.Codeforces Round #219 начнется 13-го декабря в 18:00 MSK, раунд будет проводиться как для участников из Div. 1, так и для Div. 2 участников. Обратите внимание, что раунд проводится в нестандартное время.Задачи готовили kagamiz и DEGwer. Мы хотим поблагодарить Gerald за помощь в организации раунда, Delinur за перевод, а MikeMirzayanov за систему.Распределение баллов по задачам скоро будет анонсировано, вполне вероятно, будет стандартное распределение баллов по задачам.UPD1: Распределение баллов по задачам, 500-1000-1500-2000-2500 для обоих дивизионов.UPD2: В задачах B из Div. 2 и C из Div. 1 были проблемы, все решения перетестированы. Извиняюсь, за это.UPD3: Все кто получили двойной или более AC из-за того, что перепослали решение до объявления, пожалуйста, напишите Gerald номера посылок, которые нужно отменить. Просим прощение за принесенные неудобства.UPD4: Системное тестирование завершилось, поздравления победителям!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackОсобенно поздравляем rng_58 и permin, которые решили задачу E в Div. 1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1134
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Весело нажимать на панели /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Весело составлять последовательности /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Весело считать Кенгуру / 372A - Весело считать Кенгуру /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Весело считать прямоугольники / 372B - Весело считать прямоугольники /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Весело смотреть на фейерверки / 372C - Весело смотреть на фейерверки /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Весело выбирать поддерево /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Весело рисовать круги /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 373\\s*C"
          },
          "content_length": 6066
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "40 - 82 - 201 - 405 - 814\n45 - 94 - 204 - 409 - 819\n48 - 97 - 205 - 433 - 886\n54 - 109 - 222 - 449 - 911\n60 - 125 - 271 - 549\n83 - 237 - 474 - 948\n110 - 240 - 484 - 972\n130 - 271 - 570\n132 - 276 - 576\n134 - 282 - 579\n139 - 288 - 589\n139 - 288 - 590\n141 - 303 - 618\n142 - 314 - 636\n145 - 330 - 666\n146 - 336 - 682\n150 - 341 - 702\n154 - 347 - 735\n242 - 520\n245 - 535\n249 - 601\n364 - 754\n384 - 775\n438 - 896\n441 - 911\n454 - 916\n601\n604\n638\n647\n655\n778\n783\n804\n807\n836\n841\n842\n845\n923\n930\n938\n952\n957\n974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "40 - 82 - 201 - 405 - 814\n45 - 94 - 204 - 409 - 819\n48 - 97 - 205 - 433 - 886\n54 - 109 - 222 - 449 - 911\n60 - 125 - 271 - 549\n83 - 237 - 474 - 948\n110 - 240 - 484 - 972\n130 - 271 - 570\n132 - 276 - 576\n134 - 282 - 579\n139 - 288 - 589\n139 - 288 - 590\n141 - 303 - 618\n142 - 314 - 636\n145 - 330 - 666\n146 - 336 - 682\n150 - 341 - 702\n154 - 347 - 735\n242 - 520\n245 - 535\n249 - 601\n364 - 754\n384 - 775\n438 - 896\n441 - 911\n454 - 916\n601\n604\n638\n647\n655\n778\n783\n804\n807\n836\n841\n842\n845\n923\n930\n938\n952\n957\n974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "d = n/2;x =0; m = n;\nwhile (d > 0 && n > d){\n\t\tif (2*s[d] <= s[n]){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tn--;\n\t\t}\n\t\telse {\n\t\t\td--;\n\t\t}\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "d = n/2;x =0; m = n;\nwhile (d > 0 && n > d){\n\t\tif (2*s[d] <= s[n]){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tn--;\n\t\t}\n\t\telse {\n\t\t\td--;\n\t\t}\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 31",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 32",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 33",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 34",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 100000, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 100000, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 100000, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of kangaroos\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    int min_size = opt<int>(\"min_size\", 1); // Minimum size of kangaroos\n    int max_size = opt<int>(\"max_size\", 100000); // Maximum size of kangaroos\n\n    vector<int> sizes(n);\n\n    if (type == \"random\") {\n        // Random sizes between min_size and max_size\n        for (int i = 0; i < n; ++i) {\n            sizes[i] = rnd.next(min_size, max_size);\n        }\n    } else if (type == \"maximal\") {\n        // All sizes are max_size\n        fill(sizes.begin(), sizes.end(), max_size);\n    } else if (type == \"minimal\") {\n        // All sizes are min_size\n        fill(sizes.begin(), sizes.end(), min_size);\n    } else if (type == \"increasing\") {\n        // Sizes increase from min_size to max_size\n        if (n == 1) {\n            sizes[0] = min_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                sizes[i] = min_size + (long long)(max_size - min_size) * i / (n - 1);\n            }\n        }\n    } else if (type == \"decreasing\") {\n        // Sizes decrease from max_size to min_size\n        if (n == 1) {\n            sizes[0] = max_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                sizes[i] = max_size - (long long)(max_size - min_size) * i / (n - 1);\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Sizes alternate between min_size and max_size\n        for (int i = 0; i < n; ++i) {\n            sizes[i] = (i % 2 == 0) ? min_size : max_size;\n        }\n    } else if (type == \"duplicates\") {\n        // Sizes with many duplicates\n        int c = opt<int>(\"c\", 10); // Number of unique sizes\n        vector<int> unique_sizes(c);\n        for (int i = 0; i < c; ++i) {\n            unique_sizes[i] = rnd.next(min_size, max_size);\n        }\n        for (int i = 0; i < n; ++i) {\n            sizes[i] = unique_sizes[rnd.next(0, c - 1)];\n        }\n    } else if (type == \"clustered\") {\n        // Sizes clustered around a few values\n        int clusters = opt<int>(\"clusters\", 5); // Number of clusters\n        vector<int> cluster_centers(clusters);\n        for (int i = 0; i < clusters; ++i) {\n            cluster_centers[i] = rnd.next(min_size, max_size);\n        }\n        for (int i = 0; i < n; ++i) {\n            int center = cluster_centers[rnd.next(0, clusters - 1)];\n            int deviation = rnd.next(-10, 10); // Small deviation\n            sizes[i] = max(min_size, min(max_size, center + deviation));\n        }\n    } else if (type == \"worst_case\") {\n        // Sizes designed to cause worst-case behavior in some algorithms\n        for (int i = 0; i < n / 2; ++i) {\n            sizes[i] = min_size;\n        }\n        for (int i = n / 2; i < n; ++i) {\n            sizes[i] = min(max_size, min_size * 2 - 1);\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure sizes are within bounds\n    for (int i = 0; i < n; ++i) {\n        if (sizes[i] < min_size || sizes[i] > max_size) {\n            cerr << \"Size out of bounds at position \" << i << \": \" << sizes[i] << endl;\n            return 1;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output sizes\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", sizes[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of kangaroos\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    int min_size = opt<int>(\"min_size\", 1); // Minimum size of kangaroos\n    int max_size = opt<int>(\"max_size\", 100000); // Maximum size of kangaroos\n\n    vector<int> sizes(n);\n\n    if (type == \"random\") {\n        // Random sizes between min_size and max_size\n        for (int i = 0; i < n; ++i) {\n            sizes[i] = rnd.next(min_size, max_size);\n        }\n    } else if (type == \"maximal\") {\n        // All sizes are max_size\n        fill(sizes.begin(), sizes.end(), max_size);\n    } else if (type == \"minimal\") {\n        // All sizes are min_size\n        fill(sizes.begin(), sizes.end(), min_size);\n    } else if (type == \"increasing\") {\n        // Sizes increase from min_size to max_size\n        if (n == 1) {\n            sizes[0] = min_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                sizes[i] = min_size + (long long)(max_size - min_size) * i / (n - 1);\n            }\n        }\n    } else if (type == \"decreasing\") {\n        // Sizes decrease from max_size to min_size\n        if (n == 1) {\n            sizes[0] = max_size;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                sizes[i] = max_size - (long long)(max_size - min_size) * i / (n - 1);\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Sizes alternate between min_size and max_size\n        for (int i = 0; i < n; ++i) {\n            sizes[i] = (i % 2 == 0) ? min_size : max_size;\n        }\n    } else if (type == \"duplicates\") {\n        // Sizes with many duplicates\n        int c = opt<int>(\"c\", 10); // Number of unique sizes\n        vector<int> unique_sizes(c);\n        for (int i = 0; i < c; ++i) {\n            unique_sizes[i] = rnd.next(min_size, max_size);\n        }\n        for (int i = 0; i < n; ++i) {\n            sizes[i] = unique_sizes[rnd.next(0, c - 1)];\n        }\n    } else if (type == \"clustered\") {\n        // Sizes clustered around a few values\n        int clusters = opt<int>(\"clusters\", 5); // Number of clusters\n        vector<int> cluster_centers(clusters);\n        for (int i = 0; i < clusters; ++i) {\n            cluster_centers[i] = rnd.next(min_size, max_size);\n        }\n        for (int i = 0; i < n; ++i) {\n            int center = cluster_centers[rnd.next(0, clusters - 1)];\n            int deviation = rnd.next(-10, 10); // Small deviation\n            sizes[i] = max(min_size, min(max_size, center + deviation));\n        }\n    } else if (type == \"worst_case\") {\n        // Sizes designed to cause worst-case behavior in some algorithms\n        for (int i = 0; i < n / 2; ++i) {\n            sizes[i] = min_size;\n        }\n        for (int i = n / 2; i < n; ++i) {\n            sizes[i] = min(max_size, min_size * 2 - 1);\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure sizes are within bounds\n    for (int i = 0; i < n; ++i) {\n        if (sizes[i] < min_size || sizes[i] > max_size) {\n            cerr << \"Size out of bounds at position \" << i << \": \" << sizes[i] << endl;\n            return 1;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output sizes\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", sizes[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type maximal\n./gen -n 1 -type minimal\n\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type duplicates -c 1\n./gen -n 10 -type duplicates -c 2\n./gen -n 10 -type clustered -clusters 2\n./gen -n 10 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type duplicates -c 5\n./gen -n 100 -type clustered -clusters 10\n./gen -n 100 -type alternating\n\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type duplicates -c 10\n./gen -n 1000 -type clustered -clusters 50\n./gen -n 1000 -type worst_case\n\n./gen -n 10000 -type random\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n./gen -n 10000 -type duplicates -c 100\n./gen -n 10000 -type clustered -clusters 100\n./gen -n 10000 -type worst_case\n\n./gen -n 500000 -type random\n./gen -n 500000 -type increasing\n./gen -n 500000 -type decreasing\n./gen -n 500000 -type duplicates -c 1000\n./gen -n 500000 -type clustered -clusters 1000\n./gen -n 500000 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:42.947927",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "373/D",
      "title": "D. Counting Rectangles is Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThere are three integers in the first line: n, m and q (1 ≤ n, m ≤ 40, 1 ≤ q ≤ 3·105). Each of the next n lines contains m characters — the grid. Consider grid rows are numbered from top to bottom, and grid columns are numbered from left to right. Both columns and rows are numbered starting from 1. Each of the next q lines contains a query — four integers that describe the current rectangle, a, b, c, d (1 ≤ a ≤ c ≤ n; 1 ≤ b ≤ d ≤ m).",
      "output_spec": "OutputFor each query output an answer — a single integer in a separate line.",
      "sample_tests": "ExamplesInputCopy5 5 500101000000000101000000011 2 2 44 5 4 51 2 5 22 2 4 54 2 5 3OutputCopy1017345InputCopy4 7 500001000000010001100000000001 7 2 73 1 3 12 3 4 51 2 2 72 2 4 7OutputCopy31162752",
      "description": "D. Counting Rectangles is Fun\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThere are three integers in the first line: n, m and q (1 ≤ n, m ≤ 40, 1 ≤ q ≤ 3·105). Each of the next n lines contains m characters — the grid. Consider grid rows are numbered from top to bottom, and grid columns are numbered from left to right. Both columns and rows are numbered starting from 1. Each of the next q lines contains a query — four integers that describe the current rectangle, a, b, c, d (1 ≤ a ≤ c ≤ n; 1 ≤ b ≤ d ≤ m).\n\nOutputFor each query output an answer — a single integer in a separate line.\n\nInputCopy5 5 500101000000000101000000011 2 2 44 5 4 51 2 5 22 2 4 54 2 5 3OutputCopy1017345InputCopy4 7 500001000000010001100000000001 7 2 73 1 3 12 3 4 51 2 2 72 2 4 7OutputCopy31162752\n\nInputCopy5 5 500101000000000101000000011 2 2 44 5 4 51 2 5 22 2 4 54 2 5 3\n\nOutputCopy1017345\n\nInputCopy4 7 500001000000010001100000000001 7 2 73 1 3 12 3 4 51 2 2 72 2 4 7\n\nOutputCopy31162752\n\nNoteFor the first example, there is a 5 × 5 rectangular grid, and the first, the second, and the third queries are represented in the following image.    For the first query, there are 10 good rectangles, five 1 × 1, two 2 × 1, two 1 × 2, and one 1 × 3.  For the second query, there is only one 1 × 1 good rectangle.  For the third query, there are 7 good rectangles, four 1 × 1, two 2 × 1, and one 3 × 1.",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Hello.Codeforces Round #219 will take place on December 13th at 18:00 MSK for both Div.1 and Div.2 participant. Make sure that it will be held unusual　time.Problem setters are kagamiz and DEGwer, and we thank Gerald for helping us to hold this contest, and Delinur for the translation, and MikeMirzayanov for systems.The score distribution will be uploaded soon, but probably we use the standard scoring system.UPD1: The score distribution is standard, 500-1000-1500-2000-2500 for both division.UPD2: Problem B from Div.2 and problem C from Div.1 have some problems, so all submissions to these problems are rejudged. I'm very sorry.UPD3: Anyone who gets AC two or more times, because of resubmit before clarification, please, write to Gerald, your submissions that should be skipped. Sorry for inconvenience.UPD4: Now system test has finished, congratulation for winners!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackAnd also congrats for rng_58 and permin, who got AC on Div.1 E problem!!UPD5: Now editorial is uploaded here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1105
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Collecting Beats is Fun /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Making Sequences is Fun /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Counting Kangaroos is Fun / 372A - Counting Kangaroos is Fun /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Counting Rectangles is Fun / 372B - Counting Rectangles is Fun /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Watching Fireworks is Fun / 372C - Watching Fireworks is Fun /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Choosing Subtree is Fun /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Drawing Circles is Fun /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 373\\s*D"
          },
          "content_length": 6042
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 40, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[01]{\" + to_string(m) + \"}\");\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(a, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(b, m, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 40, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[01]{\" + to_string(m) + \"}\");\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(a, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(b, m, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 40, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[01]{\" + to_string(m) + \"}\");\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(a, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(b, m, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string gridType = opt<string>(\"gridType\", \"random\");\n\n    // Validate constraints\n    ensure(n >= 1 && n <= 40);\n    ensure(m >= 1 && m <= 40);\n    ensure(q >= 1 && q <= 300000);\n\n    // Generate grid\n    vector<string> grid(n, string(m, '0'));\n\n    if (gridType == \"zeros\") {\n        // Grid already initialized with zeros\n    } else if (gridType == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n    } else if (gridType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2); // Random 0 or 1\n    } else if (gridType == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + ((i + j) % 2);\n    } else if (gridType == \"border\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1)\n                    grid[i][j] = '1';\n                else\n                    grid[i][j] = '0';\n    } else if (gridType == \"diagonal\") {\n        for (int i = 0; i < n && i < m; ++i)\n            grid[i][i] = '0';\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (i != j)\n                    grid[i][j] = '1';\n    } else if (gridType == \"randomblock\") {\n        // Fill grid with ones\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        // Random rectangle of zeros\n        int a = rnd.next(0, n - 1);\n        int c = rnd.next(a, n - 1);\n        int b = rnd.next(0, m - 1);\n        int d = rnd.next(b, m - 1);\n        for (int i = a; i <= c; ++i)\n            for (int j = b; j <= d; ++j)\n                grid[i][j] = '0';\n    } else {\n        // Default to random grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2); // Random 0 or 1\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    // Generate queries\n    for (int k = 0; k < q; ++k) {\n        int a = rnd.next(1, n);\n        int c = rnd.next(a, n);\n        int b = rnd.next(1, m);\n        int d = rnd.next(b, m);\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string gridType = opt<string>(\"gridType\", \"random\");\n\n    // Validate constraints\n    ensure(n >= 1 && n <= 40);\n    ensure(m >= 1 && m <= 40);\n    ensure(q >= 1 && q <= 300000);\n\n    // Generate grid\n    vector<string> grid(n, string(m, '0'));\n\n    if (gridType == \"zeros\") {\n        // Grid already initialized with zeros\n    } else if (gridType == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n    } else if (gridType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2); // Random 0 or 1\n    } else if (gridType == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + ((i + j) % 2);\n    } else if (gridType == \"border\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1)\n                    grid[i][j] = '1';\n                else\n                    grid[i][j] = '0';\n    } else if (gridType == \"diagonal\") {\n        for (int i = 0; i < n && i < m; ++i)\n            grid[i][i] = '0';\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (i != j)\n                    grid[i][j] = '1';\n    } else if (gridType == \"randomblock\") {\n        // Fill grid with ones\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        // Random rectangle of zeros\n        int a = rnd.next(0, n - 1);\n        int c = rnd.next(a, n - 1);\n        int b = rnd.next(0, m - 1);\n        int d = rnd.next(b, m - 1);\n        for (int i = a; i <= c; ++i)\n            for (int j = b; j <= d; ++j)\n                grid[i][j] = '0';\n    } else {\n        // Default to random grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = '0' + rnd.next(2); // Random 0 or 1\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    // Generate queries\n    for (int k = 0; k < q; ++k) {\n        int a = rnd.next(1, n);\n        int c = rnd.next(a, n);\n        int b = rnd.next(1, m);\n        int d = rnd.next(b, m);\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -q 1 -gridType zeros\n./gen -n 1 -m 1 -q 1 -gridType ones\n./gen -n 40 -m 40 -q 300000 -gridType random\n./gen -n 40 -m 40 -q 300000 -gridType zeros\n./gen -n 2 -m 2 -q 5 -gridType checkerboard\n./gen -n 10 -m 10 -q 1000 -gridType checkerboard\n./gen -n 40 -m 40 -q 100000 -gridType border\n./gen -n 40 -m 40 -q 300000 -gridType randomblock\n./gen -n 30 -m 35 -q 250000 -gridType ones\n./gen -n 40 -m 30 -q 300000 -gridType zeros\n./gen -n 35 -m 35 -q 300000 -gridType diagonal\n./gen -n 3 -m 3 -q 50 -gridType random\n./gen -n 20 -m 25 -q 300000 -gridType random\n./gen -n 40 -m 40 -q 300000 -gridType random\n./gen -n 40 -m 40 -q 300000 -gridType random\n./gen -n 40 -m 40 -q 300000 -gridType random\n./gen -n 40 -m 40 -q 1 -gridType zeros\n./gen -n 40 -m 40 -q 1 -gridType ones\n./gen -n 40 -m 40 -q 1 -gridType checkerboard\n./gen -n 40 -m 40 -q 300000 -gridType checkerboard\n./gen -n 1 -m 40 -q 100 -gridType zeros\n./gen -n 1 -m 40 -q 100 -gridType ones\n./gen -n 40 -m 1 -q 100 -gridType zeros\n./gen -n 40 -m 1 -q 100 -gridType ones\n./gen -n 40 -m 40 -q 300000 -gridType randomblock\n./gen -n 5 -m 5 -q 1000 -gridType diagonal\n./gen -n 20 -m 20 -q 100000 -gridType diagonal\n./gen -n 30 -m 30 -q 200000 -gridType border\n./gen -n 40 -m 40 -q 300000 -gridType border\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:45.496486",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "373/E",
      "title": "E. Весело смотреть на фейерверки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано три целых числа n, m, d (1 ≤ n ≤ 150000; 1 ≤ m ≤ 300; 1 ≤ d ≤ n).В каждой из следующих m строк записаны целые числа ai, bi, ti (1 ≤ ai ≤ n; 1 ≤ bi ≤ 109; 1 ≤ ti ≤ 109). В i-ой строке записано описание i-ого запуска.Гарантируется, что условие ti ≤ ti + 1 (1 ≤ i < m) будет удовлетворено.",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальную сумму счастья, которую можно получить от просмотра всех фейерверков.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать50 3 149 1 126 1 46 1 10Выходные данныеСкопировать-31Входные данныеСкопировать10 2 11 1000 49 1000 4Выходные данныеСкопировать1992",
      "description": "E. Весело смотреть на фейерверки\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано три целых числа n, m, d (1 ≤ n ≤ 150000; 1 ≤ m ≤ 300; 1 ≤ d ≤ n).В каждой из следующих m строк записаны целые числа ai, bi, ti (1 ≤ ai ≤ n; 1 ≤ bi ≤ 109; 1 ≤ ti ≤ 109). В i-ой строке записано описание i-ого запуска.Гарантируется, что условие ti ≤ ti + 1 (1 ≤ i < m) будет удовлетворено.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальную сумму счастья, которую можно получить от просмотра всех фейерверков.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать50 3 149 1 126 1 46 1 10Выходные данныеСкопировать-31Входные данныеСкопировать10 2 11 1000 49 1000 4Выходные данныеСкопировать1992\n\nВходные данныеСкопировать50 3 149 1 126 1 46 1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-31\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 2 11 1000 49 1000 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1992\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #219 - Codeforces",
          "content": "Привет.Codeforces Round #219 начнется 13-го декабря в 18:00 MSK, раунд будет проводиться как для участников из Div. 1, так и для Div. 2 участников. Обратите внимание, что раунд проводится в нестандартное время.Задачи готовили kagamiz и DEGwer. Мы хотим поблагодарить Gerald за помощь в организации раунда, Delinur за перевод, а MikeMirzayanov за систему.Распределение баллов по задачам скоро будет анонсировано, вполне вероятно, будет стандартное распределение баллов по задачам.UPD1: Распределение баллов по задачам, 500-1000-1500-2000-2500 для обоих дивизионов.UPD2: В задачах B из Div. 2 и C из Div. 1 были проблемы, все решения перетестированы. Извиняюсь, за это.UPD3: Все кто получили двойной или более AC из-за того, что перепослали решение до объявления, пожалуйста, напишите Gerald номера посылок, которые нужно отменить. Просим прощение за принесенные неудобства.UPD4: Системное тестирование завершилось, поздравления победителям!!!Division 1:1.jqdai08152.tourist3.PavelKunyavskiy4.dasko15.al13nDivision 2:1.Hwhitetooth2.pcnc_zLq3.wuyiqi4.prok5.aaaaajackОсобенно поздравляем rng_58 и permin, которые решили задачу E в Div. 1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9907",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1134
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces",
          "content": "Sorry for late.This is the editorial of Codeforces Round #219. Div2 A, Div2 B, Div1 C are made by kagamiz, and other problems are made by me.373A - Весело нажимать на панели /\\_/\\First, you need to count the occurence of each number (1 through 9). If none of them are greater than 2 * k, Cucumber boy is able to press the panels in perfect timing.Complexity is O(1).My solution : http://ideone.com/CwQtBv373B - Весело составлять последовательности /\\_/\\Naive simulation (subtracting S(i) * k from w while w >= 0) won't finish in 2 seconds.At first, these two facts will make it easier to solve the problem : 1. k doesn't matter for solving this problem, so you can simply divide w with k at the first point. 2. S(10^x) + S(10^x + 1) + ... + S(10^(x+1) — 1) = 9 * x * 10^x .There are many ways to solve this problem, and I'll show you 2 ways. Binary Search Let's define f(n) as \\sum_{k=1}^{n} S(n). This problem can be solved by finding largest x that satisfies f(x) — f(m — 1) <= w. If x satisfies the given inequation, also x — 1, x — 2, ... satisfies inequation since S(x) is always positive. So it can be solved by using binary search. By using fact2, you can quickly simulate the value of f(n). The answer can be rather large, so be careful not to cause overflow by too large upper bound. Overall complexity is O(log |upper_bound — lower_bound|). Cumulative Sums Let's think to speed up naive solutions that I've written at first. If you use fact 2, the number of simulation will reduce from O(|answer|) to O(1). Also, simulation will be much easier if you add S(1) + ... + S(m-1) to w. Please see my source code for further detail. DEGwer's solution (Solution 1) : http://ideone.com/cU78oe My solution(Solution 2) : http://ideone.com/NjxlwP373C - Весело считать Кенгуру / 372A - Весело считать Кенгуру /\\_/\\Because of the number of holding-held relations is at most , We can assume that first half of kangaroos do not hold any kangaroos, and last half of kangaroos are not held by any kangaroos. So we can split kangaroos in two set, such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half, and use easy greedy algorithm. The time conplexity is O(N log N) for sorting and O(N) for greedy, so the time conplexity is O(N log N).my solution: http://ideone.com/w8ch4w373D - Весело считать прямоугольники / 372B - Весело считать прямоугольники /\\_/\\We can precalculate all rectangles, in O(N^2M^2) with using consecutive sums for 2D. And then we use 4D consecutive sums, we can answer the queries. The time conplexity is O(N^2M^2+Q).my solution: http://ideone.com/QOjwse373E - Весело смотреть на фейерверки / 372C - Весело смотреть на фейерверки /\\_/\\I think most of the participants came up with simple DP algorithm : dp[i][j] := the maximum happiness value that you can gain when you're on poisition j at i th launching. Each value in table can be calculated by this formula : dp[i][j] = max[k =  - t * d..t * d](dp[i — 1][j + k] + b[i] — |a[i] — j|) where t = t[i] — t[i — 1].If you look up for all k, since the table's size is O(mn), the overall complexity will be O(mn^2), and its too slow to solve the problem. Now, We're going to make this algorithm faster. Since the second term in the DP formula doesn't depend on k, you have to find maximum value of dp[i — 1][j + k] faster. Using segment tree or sparse table can fasten finding from O(n) to O(log n), but the overall complexity is still O(mn log n), and the solution will get time limit exceeded.Intended solution uses sliding window maximum (see this page http://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html) for some information), since the interval [j — t * d, j + t * d] is independent for all the fireworks. It can be implemented by simple array or deque. This will speed up to calculate formula, and overall complexity will be O(mn).kcm1700 has submitted faster solution than our intended one during contest! It's complexity is O(m^2). Please read his comment (http://codeforces.com/blog/entry/9907#comment-153963) for further information.My solution : http://ideone.com/Unrfaa kcm1700's solution : http://codeforces.com/contest/372/submission/5431649372D - Весело выбирать поддерево /\\_/\\We can use two pointers, which treat the interval of the consecutive numbers of node on tree. All we have to do is answer the query which requires the minimal number of size of subtree which contains all the vertices in the set, after the \"add vertices to the set\" and \"delete verticesto the set\" operations. We can calculate the distance between two nodes with LCA algorithm, then when we order the nodes by dfs order, we can answer the \"add vertice\" query that adds the vertice which is numbered s in dfs order, and assume that previous numbered vertices in dfs order in the set is t, and next is u, we can get rid of the \"add\" query that $(current size of subtree)+distance(s,t)+distance(t,u)-distance(s,u), and \"delete\" so on. The time conplexity of LCA algorithm is O(log N), so we can solve this problem in O(Nlog N).There is another solution which uses heavy-light decomposition and segment tree. This solution is O(Nlog^2 N), which also pass.my solution (heavy-light decomposition): http://ideone.com/XfJPsS372E - Весело рисовать круги /\\_/\\All circles we must consider pass through O, so we can consider the operation inversion. At this operation, the point (x, y) will be . From now, we think the plane as the plane after inversed. \"The circumcircles of triangles OAB and OCD have a single common point, and the circumcircle of triangles OAD and OBC have a single common point\" can be said, after the inversion, ABCD is parallelogram. And we can say it \"the diagonal AC and BD have a common midpoint and the inclination of AC and BD are different\". So all we have to do is make the list of the midpoints and inclination of all pairs of points and the line passes through them, and sort this array, and do some multiplication. It can be solved in O(N^2 log N).my solution: http://ideone.com/x3Xrqe",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/9944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 373\\s*E"
          },
          "content_length": 6066
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #219 - Codeforces - Code 1",
          "code": "dp[i][j][i+di][j+dj]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 2",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 3",
          "code": "dp[i][j][i+di][j+dj] =\n dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1]+dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj]-dp[i][j+1][i+di-1][j+dj]-dp[i][j+1][i+di][j+dj-1]+dp[i][j+1][i+di-1][j+dj-1]-dp[i+1][j][i+di-1][j+dj]-dp[i+1][j][i+di][j+dj-1]+dp[i+1][j][i+di-1][j+dj-1]+dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1]+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 4",
          "code": "dp[i][j][k][l]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 5",
          "code": "(i+di,j+dj)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 6",
          "code": "dp[i][j][i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 7",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 8",
          "code": "// i want the rectangles that start at or after (i,j) and end at or before (i+di,j+dj)\ndp[i][j][i+di][j+dj] =\n\n// rectangles that start at or after (i,j) and end before (i+di,j+dj)\n+(dp[i][j][i+di-1][j+dj]+dp[i][j][i+di][j+dj-1]-dp[i][j][i+di-1][j+dj-1])\n\n// rectangles that start after (i,j) and end at or before (i+di,j+dj)\n+(dp[i][j+1][i+di][j+dj]+dp[i+1][j][i+di][j+dj]-dp[i+1][j+1][i+di][j+dj])\n\n// i have added rectangles that start after (i,j) and end before (i+di,j+dj) twice, so i should subtract those\n\n// rectangles that start at or after (i,j+1) and end before (i+di,j+dj)\n-(dp[i][j+1][i+di-1][j+dj]+dp[i][j+1][i+di][j+dj-1]-dp[i][j+1][i+di-1][j+dj-1])\n\n// rectangles that start at or after (i+1,j) and end before (i+di,j+dj)\n-(dp[i+1][j][i+di-1][j+dj]+dp[i+1][j][i+di][j+dj-1]-dp[i+1][j][i+di-1][j+dj-1])\n\n// i have subtracted the rectangles that start at or after (i+1,j+1) twice, so i should add those back\n\n// rectangles that start at or after after (i+1,j+1) and end before (i+di,j+dj)\n+(dp[i+1][j+1][i+di-1][j+dj]+dp[i+1][j+1][i+di][j+dj-1]-dp[i+1][j+1][i+di-1][j+dj-1])\n\n// the big rectangle that starts at (i,j) and ends at (i+di,j+dj) maybe a \"good\" rectangle\n+check(i,j,i+di,j+dj);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 9",
          "code": "atoi(&str[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 10",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 11",
          "code": "int t[12];\nmemset(t,0,sizeof t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 12",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 13",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 14",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 15",
          "code": "sort(a+1,a+n+1);\nint l = 1 , r = n/2+1;\nwhile(l <= n/2 && r <= n){\n    if(a[r] >= a[l]*2)\n        l++ , r++;\n    else\n        r++;\n}\ncout<<n-l+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 16",
          "code": "(n - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 17",
          "code": "40 - 82 - 201 - 405 - 814\n45 - 94 - 204 - 409 - 819\n48 - 97 - 205 - 433 - 886\n54 - 109 - 222 - 449 - 911\n60 - 125 - 271 - 549\n83 - 237 - 474 - 948\n110 - 240 - 484 - 972\n130 - 271 - 570\n132 - 276 - 576\n134 - 282 - 579\n139 - 288 - 589\n139 - 288 - 590\n141 - 303 - 618\n142 - 314 - 636\n145 - 330 - 666\n146 - 336 - 682\n150 - 341 - 702\n154 - 347 - 735\n242 - 520\n245 - 535\n249 - 601\n364 - 754\n384 - 775\n438 - 896\n441 - 911\n454 - 916\n601\n604\n638\n647\n655\n778\n783\n804\n807\n836\n841\n842\n845\n923\n930\n938\n952\n957\n974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 18",
          "code": "40 - 82 - 201 - 405 - 814\n45 - 94 - 204 - 409 - 819\n48 - 97 - 205 - 433 - 886\n54 - 109 - 222 - 449 - 911\n60 - 125 - 271 - 549\n83 - 237 - 474 - 948\n110 - 240 - 484 - 972\n130 - 271 - 570\n132 - 276 - 576\n134 - 282 - 579\n139 - 288 - 589\n139 - 288 - 590\n141 - 303 - 618\n142 - 314 - 636\n145 - 330 - 666\n146 - 336 - 682\n150 - 341 - 702\n154 - 347 - 735\n242 - 520\n245 - 535\n249 - 601\n364 - 754\n384 - 775\n438 - 896\n441 - 911\n454 - 916\n601\n604\n638\n647\n655\n778\n783\n804\n807\n836\n841\n842\n845\n923\n930\n938\n952\n957\n974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 19",
          "code": "char row[4];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 20",
          "code": "char row[5];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 21",
          "code": "operator []",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 22",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 23",
          "code": "int[] a = new int[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 24",
          "code": "d = n/2;x =0; m = n;\nwhile (d > 0 && n > d){\n\t\tif (2*s[d] <= s[n]){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tn--;\n\t\t}\n\t\telse {\n\t\t\td--;\n\t\t}\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 25",
          "code": "d = n/2;x =0; m = n;\nwhile (d > 0 && n > d){\n\t\tif (2*s[d] <= s[n]){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tn--;\n\t\t}\n\t\telse {\n\t\t\td--;\n\t\t}\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 26",
          "code": "w -= (tmp - m) * k * length ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 27",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 28",
          "code": "n: 4\ns: 1 1 4 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 29",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 30",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 31",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 32",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 33",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 - Codeforces - Code 34",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9907",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 1",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 2",
          "code": "// Line 32-34 of the code linked in the editorial\n\n for (lint j = 1; j <= interval; j++){\n            while (dq.size() && dp[1 - p][dq[dq.size() - 1]] <= dp[1 - p][(int)j]) dq.pop_back();\n            dq.push_back((int)j);\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 3",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 4",
          "code": "for (lint j = 1; j <= interval; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 5",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #219 editorial - Codeforces - Code 6",
          "code": "for(int m=j-interval;m<=j+interval;m++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/9944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    long long prev_ti = -1;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, 1000000000LL, \"bi\");\n        inf.readSpace();\n        long long ti = inf.readLong(1LL, 1000000000LL, \"ti\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_ti <= ti, \"ti should be non-decreasing, but ti[%d]=%lld > ti[%d]=%lld\", i, prev_ti, i + 1, ti);\n        }\n        prev_ti = ti;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    long long prev_ti = -1;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, 1000000000LL, \"bi\");\n        inf.readSpace();\n        long long ti = inf.readLong(1LL, 1000000000LL, \"ti\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_ti <= ti, \"ti should be non-decreasing, but ti[%d]=%lld > ti[%d]=%lld\", i, prev_ti, i + 1, ti);\n        }\n        prev_ti = ti;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(1, n, \"d\");\n    inf.readEoln();\n\n    long long prev_ti = -1;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, 1000000000LL, \"bi\");\n        inf.readSpace();\n        long long ti = inf.readLong(1LL, 1000000000LL, \"ti\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_ti <= ti, \"ti should be non-decreasing, but ti[%d]=%lld > ti[%d]=%lld\", i, prev_ti, i + 1, ti);\n        }\n        prev_ti = ti;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, m, d);\n\n    vector<int> a(m);\n    vector<int> b(m);\n    vector<int> t(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"max_n_max_m\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = 1000000000;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"same_time\") {\n        int T = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = T;\n        }\n    }\n    else if (type == \"large_time_gaps\") {\n        int T = 0;\n        for (int i = 0; i < m; ++i) {\n            T += rnd.next(1000000, 1000000000 / m);\n            t[i] = T;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if (type == \"same_section\") {\n        int section = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = section;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"max_bi\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = 1000000000;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"min_bi\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = 1;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"negative_happiness\") {\n        int section_far = n;\n        for (int i = 0; i < m; ++i) {\n            a[i] = section_far;\n            b[i] = 1;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"alternating_sections\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : n;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"unreachable_fireworks\") {\n        int T = 1;\n        for (int i = 0; i < m; ++i) {\n            T += rnd.next(1, 2); // very small time intervals\n            a[i] = (i % 2 == 0) ? 1 : n;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = T;\n        }\n    }\n    else if (type == \"edge_fireworks\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : n;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"max_time\") {\n        for (int i = 0; i < m; ++i) {\n            t[i] = 1000000000;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if (type == \"min_time\") {\n        for (int i = 0; i < m; ++i) {\n            t[i] = 1;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if (type == \"incremental_time\") {\n        for (int i = 0; i < m; ++i) {\n            t[i] = i + 1;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else {\n        // Default random\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n\n    // Ensure t_i ≤ t_{i+1}\n    // Already sorted in most cases\n    // For \"unreachable_fireworks\" and \"incremental_time\", t_i is already non-decreasing\n\n    // Output the ai, bi, ti\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", a[i], b[i], t[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, m, d);\n\n    vector<int> a(m);\n    vector<int> b(m);\n    vector<int> t(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"max_n_max_m\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = 1000000000;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"same_time\") {\n        int T = rnd.next(1, 1000000000);\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = T;\n        }\n    }\n    else if (type == \"large_time_gaps\") {\n        int T = 0;\n        for (int i = 0; i < m; ++i) {\n            T += rnd.next(1000000, 1000000000 / m);\n            t[i] = T;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if (type == \"same_section\") {\n        int section = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = section;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"max_bi\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = 1000000000;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"min_bi\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = 1;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"negative_happiness\") {\n        int section_far = n;\n        for (int i = 0; i < m; ++i) {\n            a[i] = section_far;\n            b[i] = 1;\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"alternating_sections\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : n;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"unreachable_fireworks\") {\n        int T = 1;\n        for (int i = 0; i < m; ++i) {\n            T += rnd.next(1, 2); // very small time intervals\n            a[i] = (i % 2 == 0) ? 1 : n;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = T;\n        }\n    }\n    else if (type == \"edge_fireworks\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : n;\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n    else if (type == \"max_time\") {\n        for (int i = 0; i < m; ++i) {\n            t[i] = 1000000000;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if (type == \"min_time\") {\n        for (int i = 0; i < m; ++i) {\n            t[i] = 1;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else if (type == \"incremental_time\") {\n        for (int i = 0; i < m; ++i) {\n            t[i] = i + 1;\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n        }\n    }\n    else {\n        // Default random\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            b[i] = rnd.next(1, 1000000000);\n            t[i] = rnd.next(1, 1000000000);\n        }\n        sort(t.begin(), t.end());\n    }\n\n    // Ensure t_i ≤ t_{i+1}\n    // Already sorted in most cases\n    // For \"unreachable_fireworks\" and \"incremental_time\", t_i is already non-decreasing\n\n    // Output the ai, bi, ti\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", a[i], b[i], t[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -n 1 -m 1 -d 1 -type random\n\n# Small input\n./gen -n 10 -m 10 -d 5 -type random\n\n# Medium input\n./gen -n 1000 -m 100 -d 100 -type random\n\n# Maximal input\n./gen -n 150000 -m 300 -d 150000 -type random\n\n# Maximal n, minimal m\n./gen -n 150000 -m 1 -d 1000 -type random\n\n# Minimal n, maximal m\n./gen -n 1 -m 300 -d 1 -type random\n\n# All fireworks at the same time\n./gen -n 10000 -m 300 -d 1000 -type same_time\n\n# Large time gaps between fireworks\n./gen -n 50000 -m 300 -d 500 -type large_time_gaps\n\n# All fireworks in the same section\n./gen -n 1000 -m 300 -d 100 -type same_section\n\n# Fireworks with maximum b_i values\n./gen -n 100000 -m 300 -d 10000 -type max_bi\n\n# Fireworks with minimum b_i values\n./gen -n 100000 -m 300 -d 10000 -type min_bi\n\n# Test for negative happiness values\n./gen -n 100000 -m 300 -d 10 -type negative_happiness\n\n# Alternating fireworks at sections 1 and n\n./gen -n 100000 -m 300 -d 500 -type alternating_sections\n\n# Unreachable fireworks due to small d and time intervals\n./gen -n 100000 -m 300 -d 1 -type unreachable_fireworks\n\n# Fireworks at the edges of the main street\n./gen -n 100000 -m 300 -d 500 -type edge_fireworks\n\n# Fireworks all at maximum time t_i = 1e9\n./gen -n 150000 -m 300 -d 1 -type max_time\n\n# Fireworks all at minimum time t_i = 1\n./gen -n 150000 -m 300 -d 1 -type min_time\n\n# Fireworks with incremental time t_i = i + 1\n./gen -n 100000 -m 300 -d 1000 -type incremental_time\n\n# Test with small d\n./gen -n 10000 -m 100 -d 1 -type random\n\n# Test with large d\n./gen -n 10000 -m 100 -d 10000 -type random\n\n# Test with maximal movement capability (d equals n)\n./gen -n 100000 -m 300 -d 100000 -type random\n\n# Maximize potential happiness gain\n./gen -n 100000 -m 300 -d 100000 -type max_bi\n\n# Fireworks happening at every possible time unit\n./gen -n 100000 -m 300 -d 1000 -type incremental_time\n\n# Fireworks at same position but varying times\n./gen -n 100000 -m 300 -d 5000 -type same_section\n\n# Fireworks at the start and end simultaneously\n./gen -n 150000 -m 300 -d 75000 -type edge_fireworks\n\n# Fireworks with t_i values exactly at the limits\n./gen -n 150000 -m 300 -d 1 -type max_time\n\n# Fireworks that require maximum movement between events\n./gen -n 100000 -m 300 -d 500 -type large_time_gaps\n\n# Random test case with maximal n and m\n./gen -n 150000 -m 300 -d 1000 -type random\n\n# Random test case with moderate n and minimal m\n./gen -n 50000 -m 1 -d 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:47.793143",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "374/A",
      "title": "A. Inna and Pink Pony",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains six integers n, m, i, j, a, b (1 ≤ n, m ≤ 106; 1 ≤ i ≤ n; 1 ≤ j ≤ m; 1 ≤ a, b ≤ 106).You can assume that the chessboard rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to m from left to right. Position (i, j) in the statement is a chessboard cell on the intersection of the i-th row and the j-th column. You can consider that the corners are: (1, m), (n, 1), (n, m), (1, 1).",
      "output_spec": "OutputIn a single line print a single integer — the minimum number of moves needed to get the candy.If Inna and the pony cannot get the candy playing by Dima's rules, print on a single line \"Poor Inna and pony!\" without the quotes.",
      "sample_tests": "ExamplesInputCopy5 7 1 3 2 2OutputCopy2InputCopy5 5 2 3 1 1OutputCopyPoor Inna and pony!",
      "description": "A. Inna and Pink Pony\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains six integers n, m, i, j, a, b (1 ≤ n, m ≤ 106; 1 ≤ i ≤ n; 1 ≤ j ≤ m; 1 ≤ a, b ≤ 106).You can assume that the chessboard rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to m from left to right. Position (i, j) in the statement is a chessboard cell on the intersection of the i-th row and the j-th column. You can consider that the corners are: (1, m), (n, 1), (n, m), (1, 1).\n\nOutputIn a single line print a single integer — the minimum number of moves needed to get the candy.If Inna and the pony cannot get the candy playing by Dima's rules, print on a single line \"Poor Inna and pony!\" without the quotes.\n\nInputCopy5 7 1 3 2 2OutputCopy2InputCopy5 5 2 3 1 1OutputCopyPoor Inna and pony!\n\nInputCopy5 7 1 3 2 2\n\nOutputCopy2\n\nInputCopy5 5 2 3 1 1\n\nOutputCopyPoor Inna and pony!\n\nNoteNote to sample 1:Inna and the pony can move the candy to position (1 + 2, 3 + 2) = (3, 5), from there they can move it to positions (3 - 2, 5 + 2) = (1, 7) and (3 + 2, 5 + 2) = (5, 7). These positions correspond to the corner squares of the chess board. Thus, the answer to the test sample equals two.",
      "solutions": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces",
          "content": "Hi! Soon Codeforces Round #220 (Div. 2) will take place, i am the author, Dmytro Berezin. This is my third round and Sereja still hopes, that this is the last :)Everything changed since last round. Dima and Inna have thought about their behavior and asked Sereja to excuse them. They are good friends now. You should make the family happiness even stronger!Thanks to Gerald Agapov (Gerald) for the help in round preparation, Maria Belova (Delinur) for tasks translations, Mike Mirzayanov (MikeMirzayanov) for perfect system, and Sergii Nagin (Sereja) for his agreement (not to post here another photo) to help in testing.Points distribution will be. 500-1000-1500-2000-2500. Here we go :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 688
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces",
          "content": "374A — Inna and the pink ponyLets find a solution for shifting a candy from the position (x1, y1) into position (x2, y2). On each step we shift (increase or decrease) x1 by a and y1 by b. It is not difficult to understand that if |x2 - x1| is not divisible by a and |y2 - y1| is divisible by b answer doesn't exist.We should also note that |x2 - x1| / a and |y2 - y1| / b Should be both even or odd as shifting is performed at a time for both values.We should also look up for a corner case when step dropes us out from the board.Now we can determine the way from (x1, y1) to (x2, y2) as max(|x1 - x2| / a, |y1 - y2| / b). Lets calculate it for all corners and choose minimum or determine that the answer doesn't exist.374B — Инна и девятьWe can divide the task into subtasks because if two adjacent digits have sum none-9 the number transformation doesn't depends on other side relatively to the position between this two digits. It means we should divide our task into subtasks of kind: x or xyxyxyx...xyxy where x + y = 9. We should multiply all such answers because we are looking for the whole number of variants.For x answer is 1. What should we do for xyxyxy? Let its length is s. Then if s is even we simply receive s / 2 nines. If s is odd one digit (any of them) will stay. Thus each sequence xyxyxyxyx...xyxyxy with odd length s increases the answer IN s times.374C — Inna and DimaOur task is tranformed to the task of finding cycle or maximal way, but lets solve it without any graphs.Lets run dfs from each digit D, memorizing all already calculated tasks. If we come into the cell we have already been (in one of the previous D) than we should simply add the maximal way length to our current length. Way length is increased not in each cell but only when we come into A. If we come into the cell we have already been on current step (in our dfs running) this is the cycle and we should stop the algorithm. Don't forget to change the color of cell after droping from recursiong because you will receive \"false cycle\". Simply set the colour to current when come into the cell but decrease it before end of recursion for this cell.374D — Inna and sequenceLets note that not more than n numbers, thus it will be not more than n dropings. We will run this process using data structure Segment Tree (you can use another structures). Lets calculate the number of numbers in current segment. When the number is added we should simply go down from the root to the leaf and increase value for each segment on the way by 1. Deletetion — vice versa. If there is enough numbers in the left subtree we should go into the right one, othervise — into the left one. Don't forget to shift the ai position by decreasing on i as all numbers are droped immidiately. And don't forget to break the cycle as soon as you reach first ai such that there is no number to be droped out from it.374E — Inna and babiesWe will make the binary search to find the answer. For each time let's generate our segments and rotate them to transform them into horizontal and verticle. We can use transformation (x, y) to (x + y, x - y). Don't forget to make the union of all segments which were at the one diagonal and have an intersection. You should sort all segments of one type and iterate through them updating the size of the segment. Now we should only determine if there is at least one rectangle. For example we can iterate each verticle segment updating the set of all horizontal which begin not later than our verticle. For each verticle (the left one) we should iterate the right verticle and now calculate the set of horizontal which not only begin not later than the left verticle but also don't end earlier than the right one. Now we should only determine is ther is two or more horizontal segments from the set which satisfy also y-conditions for current vertical.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10018",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 374\\s*A"
          },
          "content_length": 3854
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 1",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 2",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 3",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 4",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 1",
          "code": "a1+a2 = b1+b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 2",
          "code": "(x2-x1)/a = a2-a1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 3",
          "code": "(y2-y1)/b = b2-b1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 4",
          "code": "(x2-x1)/a + (y2-y1)/b = (a2-a1) + (b2-b1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int i = inf.readInt(1, n);\n    inf.readSpace();\n    int j = inf.readInt(1, m);\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int i = inf.readInt(1, n);\n    inf.readSpace();\n    int j = inf.readInt(1, m);\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int i = inf.readInt(1, n);\n    inf.readSpace();\n    int j = inf.readInt(1, m);\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, i, j;\n\n    if (type == \"random\") {\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        i = rnd.next(1, n);\n        j = rnd.next(1, m);\n    } else if (type == \"corner\") {\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        vector<int> corner_i = {1, n};\n        vector<int> corner_j = {1, m};\n        i = corner_i[rnd.next(0, 1)];\n        j = corner_j[rnd.next(0, 1)];\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        do {\n            a = rnd.next(1, min(1000000, n));\n            b = rnd.next(1, min(1000000, m));\n            i = rnd.next(1, n);\n            j = rnd.next(1, m);\n        } while ((abs(i - 1) % a == 0 || abs(n - i) % a == 0) ||\n                 (abs(j - 1) % b == 0 || abs(m - j) % b == 0) ||\n                 ((abs(i - 1) / a) % 2 == (abs(j - 1) / b) % 2) ||\n                 ((abs(n - i) / a) % 2 == (abs(j - 1) / b) % 2) ||\n                 ((abs(i - 1) / a) % 2 == (abs(m - j) / b) % 2) ||\n                 ((abs(n - i) / a) % 2 == (abs(m - j) / b) % 2));\n    } else if (type == \"max_size\") {\n        n = 1000000;\n        m = 1000000;\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        i = rnd.next(1, n);\n        j = rnd.next(1, m);\n    } else if (type == \"min_size\") {\n        n = 1;\n        m = 1;\n        a = 1;\n        b = 1;\n        i = 1;\n        j = 1;\n    } else if (type == \"custom\") {\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        i = opt<int>(\"i\");\n        j = opt<int>(\"j\");\n    } else {\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        i = rnd.next(1, n);\n        j = rnd.next(1, m);\n    }\n\n    printf(\"%d %d %d %d %d %d\\n\", n, m, i, j, a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, i, j;\n\n    if (type == \"random\") {\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        i = rnd.next(1, n);\n        j = rnd.next(1, m);\n    } else if (type == \"corner\") {\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        vector<int> corner_i = {1, n};\n        vector<int> corner_j = {1, m};\n        i = corner_i[rnd.next(0, 1)];\n        j = corner_j[rnd.next(0, 1)];\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        do {\n            a = rnd.next(1, min(1000000, n));\n            b = rnd.next(1, min(1000000, m));\n            i = rnd.next(1, n);\n            j = rnd.next(1, m);\n        } while ((abs(i - 1) % a == 0 || abs(n - i) % a == 0) ||\n                 (abs(j - 1) % b == 0 || abs(m - j) % b == 0) ||\n                 ((abs(i - 1) / a) % 2 == (abs(j - 1) / b) % 2) ||\n                 ((abs(n - i) / a) % 2 == (abs(j - 1) / b) % 2) ||\n                 ((abs(i - 1) / a) % 2 == (abs(m - j) / b) % 2) ||\n                 ((abs(n - i) / a) % 2 == (abs(m - j) / b) % 2));\n    } else if (type == \"max_size\") {\n        n = 1000000;\n        m = 1000000;\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        i = rnd.next(1, n);\n        j = rnd.next(1, m);\n    } else if (type == \"min_size\") {\n        n = 1;\n        m = 1;\n        a = 1;\n        b = 1;\n        i = 1;\n        j = 1;\n    } else if (type == \"custom\") {\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n        i = opt<int>(\"i\");\n        j = opt<int>(\"j\");\n    } else {\n        a = rnd.next(1, 1000000);\n        b = rnd.next(1, 1000000);\n        i = rnd.next(1, n);\n        j = rnd.next(1, m);\n    }\n\n    printf(\"%d %d %d %d %d %d\\n\", n, m, i, j, a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size test case\n./gen -n 1 -m 1 -type min_size\n\n# Maximal size test cases\n./gen -n 1000000 -m 1000000 -type max_size\n\n# Random test cases of various sizes\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 100000 -m 100000 -type random\n./gen -n 1000000 -m 1000000 -type random\n\n# Edge cases where starting position is at corner\n./gen -n 10 -m 10 -type corner\n./gen -n 1000 -m 1000 -type corner\n./gen -n 1000000 -m 1000000 -type corner\n\n# Impossible cases\n./gen -n 10 -m 10 -type impossible\n./gen -n 100 -m 100 -type impossible\n./gen -n 1000 -m 1000 -type impossible\n./gen -n 10000 -m 10000 -type impossible\n./gen -n 100000 -m 100000 -type impossible\n./gen -n 1000000 -m 1000000 -type impossible\n\n# Custom cases where 'a' or 'b' is 1\n./gen -n 1000 -m 1000 -a 1 -b 1000 -i 1 -j 500 -type custom\n./gen -n 1000 -m 1000 -a 1000 -b 1 -i 500 -j 1 -type custom\n./gen -n 10000 -m 10000 -a 1 -b 1 -i 5000 -j 5000 -type custom\n\n# Custom cases where 'a' or 'b' is equal to n or m\n./gen -n 1000 -m 1000 -a 1000 -b 1000 -i 500 -j 500 -type custom\n\n# Custom cases where initial position is already at corner\n./gen -n 1000 -m 1000 -a 1 -b 1 -i 1 -j 1 -type custom\n\n# Custom cases with specific steps\n./gen -n 10 -m 10 -a 2 -b 3 -i 5 -j 5 -type custom\n\n# Additional random cases\n./gen -n 5000 -m 5000 -type random\n./gen -n 20000 -m 20000 -type random\n./gen -n 700000 -m 300000 -type random\n\n# Additional impossible cases\n./gen -n 20 -m 30 -type impossible\n./gen -n 2000 -m 3000 -type impossible\n./gen -n 200000 -m 300000 -type impossible\n\n# Additional custom cases where 'a' and 'b' are primes\n./gen -n 100000 -m 100000 -a 9973 -b 10007 -i 50000 -j 50000 -type custom\n\n# Additional custom cases to test parities\n./gen -n 1000 -m 1000 -a 2 -b 2 -i 500 -j 500 -type custom\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:50.452005",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "374/B",
      "title": "Problem 374/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string a = inf.readToken(\"[1-9]{1,1000000}\", \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string a = inf.readToken(\"[1-9]{1,1000000}\", \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string a = inf.readToken(\"[1-9]{1,1000000}\", \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string number;\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            number += char('0' + rnd.next(1, 9)); // Generates digits '1' to '9'.\n        }\n    } else if (type == \"all_nines\") {\n        number = string(n, '9');\n    } else if (type == \"all_ones\") {\n        number = string(n, '1');\n    } else if (type == \"sum_to_nine_repeat\") {\n        // Pairs of digits that sum to 9\n        vector<pair<char, char>> pairs = {{'1','8'}, {'2','7'}, {'3','6'}, {'4','5'},\n                                          {'5','4'}, {'6','3'}, {'7','2'}, {'8','1'}};\n        pair<char, char> p = pairs[rnd.next(0, (int)pairs.size() - 1)];\n        string pattern = \"\";\n        \n        // Build the repeating pattern\n        pattern += p.first;\n        pattern += p.second;\n\n        int repeatCount = n / 2;\n        for (int i = 0; i < repeatCount; ++i) {\n            number += pattern;\n        }\n        if (n % 2 == 1) {\n            // Append a random digit between 1 and 9\n            number += char('0' + rnd.next(1, 9));\n        }\n    } else if (type == \"max_options\") {\n        // Generate a number where there are multiple ways to create the max number of 9's\n        // Using digits '3' and '6' since 3 + 6 = 9\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                number += '3';\n            } else {\n                number += '6';\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            number += char('0' + rnd.next(1, 9));\n        }\n    }\n\n    // Output the number\n    cout << number << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string number;\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            number += char('0' + rnd.next(1, 9)); // Generates digits '1' to '9'.\n        }\n    } else if (type == \"all_nines\") {\n        number = string(n, '9');\n    } else if (type == \"all_ones\") {\n        number = string(n, '1');\n    } else if (type == \"sum_to_nine_repeat\") {\n        // Pairs of digits that sum to 9\n        vector<pair<char, char>> pairs = {{'1','8'}, {'2','7'}, {'3','6'}, {'4','5'},\n                                          {'5','4'}, {'6','3'}, {'7','2'}, {'8','1'}};\n        pair<char, char> p = pairs[rnd.next(0, (int)pairs.size() - 1)];\n        string pattern = \"\";\n        \n        // Build the repeating pattern\n        pattern += p.first;\n        pattern += p.second;\n\n        int repeatCount = n / 2;\n        for (int i = 0; i < repeatCount; ++i) {\n            number += pattern;\n        }\n        if (n % 2 == 1) {\n            // Append a random digit between 1 and 9\n            number += char('0' + rnd.next(1, 9));\n        }\n    } else if (type == \"max_options\") {\n        // Generate a number where there are multiple ways to create the max number of 9's\n        // Using digits '3' and '6' since 3 + 6 = 9\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                number += '3';\n            } else {\n                number += '6';\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            number += char('0' + rnd.next(1, 9));\n        }\n    }\n\n    // Output the number\n    cout << number << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_nines\n./gen -n 1 -type all_ones\n./gen -n 1 -type sum_to_nine_repeat\n./gen -n 1 -type max_options\n\n./gen -n 2 -type random\n./gen -n 2 -type all_nines\n./gen -n 2 -type all_ones\n./gen -n 2 -type sum_to_nine_repeat\n./gen -n 2 -type max_options\n\n./gen -n 10 -type random\n./gen -n 10 -type all_nines\n./gen -n 10 -type all_ones\n./gen -n 10 -type sum_to_nine_repeat\n./gen -n 10 -type max_options\n\n./gen -n 100 -type random\n./gen -n 100 -type all_nines\n./gen -n 100 -type all_ones\n./gen -n 100 -type sum_to_nine_repeat\n./gen -n 100 -type max_options\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_nines\n./gen -n 1000 -type all_ones\n./gen -n 1000 -type sum_to_nine_repeat\n./gen -n 1000 -type max_options\n\n./gen -n 10000 -type random\n./gen -n 10000 -type all_nines\n./gen -n 10000 -type all_ones\n./gen -n 10000 -type sum_to_nine_repeat\n./gen -n 10000 -type max_options\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_nines\n./gen -n 100000 -type all_ones\n./gen -n 100000 -type sum_to_nine_repeat\n./gen -n 100000 -type max_options\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type all_nines\n./gen -n 1000000 -type all_ones\n./gen -n 1000000 -type sum_to_nine_repeat\n./gen -n 1000000 -type max_options\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:52.316341",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "374/C",
      "title": "C. Inna and Dima",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 103). Then follow n lines that describe Inna and Dima's table. Each line contains m characters. Each character is one of the following four characters: \"D\", \"I\", \"M\", \"A\". Note that it is not guaranteed that the table contains at least one letter \"D\".",
      "output_spec": "OutputIf Inna cannot go through name DIMA once, print on a single line \"Poor Dima!\" without the quotes. If there is the infinite number of names DIMA Inna can go through, print \"Poor Inna!\" without the quotes. Otherwise print a single integer — the maximum number of times Inna can go through name DIMA.",
      "sample_tests": "ExamplesInputCopy1 2DIOutputCopyPoor Dima!InputCopy2 2MAIDOutputCopyPoor Inna!InputCopy5 5DIMADDIMAIDIMAMDDMAAAAMIDOutputCopy4",
      "description": "C. Inna and Dima\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 103). Then follow n lines that describe Inna and Dima's table. Each line contains m characters. Each character is one of the following four characters: \"D\", \"I\", \"M\", \"A\". Note that it is not guaranteed that the table contains at least one letter \"D\".\n\nOutputIf Inna cannot go through name DIMA once, print on a single line \"Poor Dima!\" without the quotes. If there is the infinite number of names DIMA Inna can go through, print \"Poor Inna!\" without the quotes. Otherwise print a single integer — the maximum number of times Inna can go through name DIMA.\n\nInputCopy1 2DIOutputCopyPoor Dima!InputCopy2 2MAIDOutputCopyPoor Inna!InputCopy5 5DIMADDIMAIDIMAMDDMAAAAMIDOutputCopy4\n\nInputCopy1 2DI\n\nOutputCopyPoor Dima!\n\nInputCopy2 2MAID\n\nOutputCopyPoor Inna!\n\nInputCopy5 5DIMADDIMAIDIMAMDDMAAAAMID\n\nOutputCopy4\n\nNoteNotes to the samples:In the first test sample, Inna cannot go through name DIMA a single time.In the second test sample, Inna can go through the infinite number of words DIMA. For that, she should move in the clockwise direction starting from the lower right corner.In the third test sample the best strategy is to start from the cell in the upper left corner of the table. Starting from this cell, Inna can go through name DIMA four times.",
      "solutions": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces",
          "content": "Hi! Soon Codeforces Round #220 (Div. 2) will take place, i am the author, Dmytro Berezin. This is my third round and Sereja still hopes, that this is the last :)Everything changed since last round. Dima and Inna have thought about their behavior and asked Sereja to excuse them. They are good friends now. You should make the family happiness even stronger!Thanks to Gerald Agapov (Gerald) for the help in round preparation, Maria Belova (Delinur) for tasks translations, Mike Mirzayanov (MikeMirzayanov) for perfect system, and Sergii Nagin (Sereja) for his agreement (not to post here another photo) to help in testing.Points distribution will be. 500-1000-1500-2000-2500. Here we go :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 688
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces",
          "content": "374A — Inna and the pink ponyLets find a solution for shifting a candy from the position (x1, y1) into position (x2, y2). On each step we shift (increase or decrease) x1 by a and y1 by b. It is not difficult to understand that if |x2 - x1| is not divisible by a and |y2 - y1| is divisible by b answer doesn't exist.We should also note that |x2 - x1| / a and |y2 - y1| / b Should be both even or odd as shifting is performed at a time for both values.We should also look up for a corner case when step dropes us out from the board.Now we can determine the way from (x1, y1) to (x2, y2) as max(|x1 - x2| / a, |y1 - y2| / b). Lets calculate it for all corners and choose minimum or determine that the answer doesn't exist.374B — Инна и девятьWe can divide the task into subtasks because if two adjacent digits have sum none-9 the number transformation doesn't depends on other side relatively to the position between this two digits. It means we should divide our task into subtasks of kind: x or xyxyxyx...xyxy where x + y = 9. We should multiply all such answers because we are looking for the whole number of variants.For x answer is 1. What should we do for xyxyxy? Let its length is s. Then if s is even we simply receive s / 2 nines. If s is odd one digit (any of them) will stay. Thus each sequence xyxyxyxyx...xyxyxy with odd length s increases the answer IN s times.374C — Inna and DimaOur task is tranformed to the task of finding cycle or maximal way, but lets solve it without any graphs.Lets run dfs from each digit D, memorizing all already calculated tasks. If we come into the cell we have already been (in one of the previous D) than we should simply add the maximal way length to our current length. Way length is increased not in each cell but only when we come into A. If we come into the cell we have already been on current step (in our dfs running) this is the cycle and we should stop the algorithm. Don't forget to change the color of cell after droping from recursiong because you will receive \"false cycle\". Simply set the colour to current when come into the cell but decrease it before end of recursion for this cell.374D — Inna and sequenceLets note that not more than n numbers, thus it will be not more than n dropings. We will run this process using data structure Segment Tree (you can use another structures). Lets calculate the number of numbers in current segment. When the number is added we should simply go down from the root to the leaf and increase value for each segment on the way by 1. Deletetion — vice versa. If there is enough numbers in the left subtree we should go into the right one, othervise — into the left one. Don't forget to shift the ai position by decreasing on i as all numbers are droped immidiately. And don't forget to break the cycle as soon as you reach first ai such that there is no number to be droped out from it.374E — Inna and babiesWe will make the binary search to find the answer. For each time let's generate our segments and rotate them to transform them into horizontal and verticle. We can use transformation (x, y) to (x + y, x - y). Don't forget to make the union of all segments which were at the one diagonal and have an intersection. You should sort all segments of one type and iterate through them updating the size of the segment. Now we should only determine if there is at least one rectangle. For example we can iterate each verticle segment updating the set of all horizontal which begin not later than our verticle. For each verticle (the left one) we should iterate the right verticle and now calculate the set of horizontal which not only begin not later than the left verticle but also don't end earlier than the right one. Now we should only determine is ther is two or more horizontal segments from the set which satisfy also y-conditions for current vertical.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10018",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 374\\s*C"
          },
          "content_length": 3854
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 1",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 2",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 3",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 4",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 1",
          "code": "a1+a2 = b1+b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 2",
          "code": "(x2-x1)/a = a2-a1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 3",
          "code": "(y2-y1)/b = b2-b1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 4",
          "code": "(x2-x1)/a + (y2-y1)/b = (a2-a1) + (b2-b1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n        ensuref((int)line.size() == m, \"Line %d should have exactly %d characters, but has length %d\", i+1, m, (int)line.size());\n        for (int j = 0; j < m; ++j) {\n            char c = line[j];\n            ensuref(c == 'D' || c == 'I' || c == 'M' || c == 'A', \"Invalid character '%c' at line %d, position %d\", c, i+1, j+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n        ensuref((int)line.size() == m, \"Line %d should have exactly %d characters, but has length %d\", i+1, m, (int)line.size());\n        for (int j = 0; j < m; ++j) {\n            char c = line[j];\n            ensuref(c == 'D' || c == 'I' || c == 'M' || c == 'A', \"Invalid character '%c' at line %d, position %d\", c, i+1, j+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n        ensuref((int)line.size() == m, \"Line %d should have exactly %d characters, but has length %d\", i+1, m, (int)line.size());\n        for (int j = 0; j < m; ++j) {\n            char c = line[j];\n            ensuref(c == 'D' || c == 'I' || c == 'M' || c == 'A', \"Invalid character '%c' at line %d, position %d\", c, i+1, j+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'D'));\n\n    if (type == \"random\") {\n        const char letters[] = {'D', 'I', 'M', 'A'};\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(4)];\n            }\n        }\n    } else if (type == \"no_dima\") {\n        // Grid with no 'D's, so Inna cannot start (\"Poor Dima!\")\n        const char letters[] = {'I', 'M', 'A', 'A'}; // No 'D'\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(4)];\n            }\n        }\n    } else if (type == \"infinite\") {\n        // Grid with cycles leading to infinite repetitions (\"Poor Inna!\")\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = \"DIMA\"[(i + j) % 4];\n            }\n        }\n    } else if (type == \"maximal\") {\n        // Grid designed to maximize the number of times Inna can go through DIMA without cycles\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = \"DIMA\"[(i + j) % 4];\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        const char letters[] = {'D', 'I', 'M', 'A'};\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(4)];\n            }\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'D'));\n\n    if (type == \"random\") {\n        const char letters[] = {'D', 'I', 'M', 'A'};\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(4)];\n            }\n        }\n    } else if (type == \"no_dima\") {\n        // Grid with no 'D's, so Inna cannot start (\"Poor Dima!\")\n        const char letters[] = {'I', 'M', 'A', 'A'}; // No 'D'\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(4)];\n            }\n        }\n    } else if (type == \"infinite\") {\n        // Grid with cycles leading to infinite repetitions (\"Poor Inna!\")\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = \"DIMA\"[(i + j) % 4];\n            }\n        }\n    } else if (type == \"maximal\") {\n        // Grid designed to maximize the number of times Inna can go through DIMA without cycles\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = \"DIMA\"[(i + j) % 4];\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        const char letters[] = {'D', 'I', 'M', 'A'};\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(4)];\n            }\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random grids\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 3 -m 3 -type random\n\n# Medium random grids\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n\n# Large random grid\n./gen -n 1000 -m 1000 -type random\n\n# Grids with no 'D's (Poor Dima!)\n./gen -n 1 -m 1 -type no_dima\n./gen -n 10 -m 10 -type no_dima\n./gen -n 1000 -m 1000 -type no_dima\n\n# Grids with infinite cycles (Poor Inna!)\n./gen -n 2 -m 2 -type infinite\n./gen -n 3 -m 3 -type infinite\n./gen -n 10 -m 10 -type infinite\n./gen -n 100 -m 100 -type infinite\n./gen -n 1000 -m 1000 -type infinite\n\n# Grids with maximal finite DIMA sequences\n./gen -n 1 -m 4 -type maximal\n./gen -n 4 -m 4 -type maximal\n./gen -n 10 -m 10 -type maximal\n./gen -n 1000 -m 1000 -type maximal\n\n# Edge cases and minimum size grids\n./gen -n 1 -m 1 -type random    # Random single-cell grid\n./gen -n 1 -m 1 -type no_dima   # Single-cell grid with no 'D'\n\n# Random small grids to test recursion depth\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n\n# Large grids to test performance\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type maximal\n./gen -n 1000 -m 1000 -type infinite\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:54.558949",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "374/D",
      "title": "D. Инна и последовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 106) — количество событий и количество загаданных Димой чисел.Следующая строка содержит m различных целых чисел ai (1 ≤ ai ≤ 106), отсортированных в порядке возрастания. Следующие n строк описывают события в хронологическом порядке. Каждая строка содержит одно целое число: -1, 0 или 1. Число -1 означает, что Дима стукает по столу. Число 0 означает, что Инна и Дима добавляют в конец последовательности число 0. Число 1 означает, что Инна и Дима добавляют в конец последовательности число 1.",
      "output_spec": "Выходные данныеВ единственной строке выведите последовательность из 0 и 1 — содержимое w после всех событий. Элементы последовательности должны быть выведены в порядке от начала к концу последовательности.Если после всех событий последовательность w окажется пустой, выведите «Poor stack!».",
      "sample_tests": "ПримерыВходные данныеСкопировать10 31 3 6-11100-101-11Выходные данныеСкопировать011Входные данныеСкопировать2 111-1Выходные данныеСкопироватьPoor stack!",
      "description": "D. Инна и последовательность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 106) — количество событий и количество загаданных Димой чисел.Следующая строка содержит m различных целых чисел ai (1 ≤ ai ≤ 106), отсортированных в порядке возрастания. Следующие n строк описывают события в хронологическом порядке. Каждая строка содержит одно целое число: -1, 0 или 1. Число -1 означает, что Дима стукает по столу. Число 0 означает, что Инна и Дима добавляют в конец последовательности число 0. Число 1 означает, что Инна и Дима добавляют в конец последовательности число 1.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите последовательность из 0 и 1 — содержимое w после всех событий. Элементы последовательности должны быть выведены в порядке от начала к концу последовательности.Если после всех событий последовательность w окажется пустой, выведите «Poor stack!».\n\nВыходные данные\n\nВходные данныеСкопировать10 31 3 6-11100-101-11Выходные данныеСкопировать011Входные данныеСкопировать2 111-1Выходные данныеСкопироватьPoor stack!\n\nВходные данныеСкопировать10 31 3 6-11100-101-11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать011\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 111-1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьPoor stack!\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces",
          "content": "Всем привет! Скоро состоится Codeforces Round #220 (Div. 2), автором которого являюсь я, Дмитрий Березин. Это мой третий раунд, и Сережа все еще верит, что последний :)Со времен прошлого раунда многое изменилось, Дима и Инна подумали над своим поведением, извинились перед Сережей, и все теперь живут дружно. Вам предстоит еще больше укрепить семейное счастье!Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда, Марии Беловой (Delinur) за перевод задач, Михаилу Мирзаянову (MikeMirzayanov) за превосходную систему, и Сереже Нагину (Sereja) за то, что любезно (не выложил тут очередное фото) согласился помочь в тестировании.Разбалловка будет. 500-1000-1500-2000-2500. Я же сказал, что будет :) Прошу прощения за задержку.По всей видимости задача B имеет ошибки в авторском решении, приношу свои глубочайшие извинения. Сейчас мы исправляем ошибку и тесты. Раунд будет не рейтинговый. Большая часть решений, которые прошли претесты — неправильные. Вы можете исправить ваше решение и послать его в систему, как только все будет исправлено, все решения будут перетестированы.Спасибо Вам за потраченное время, постараюсь в будущем исключить подобные ошибки.Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces",
          "content": "374A — Инна и розовое пониРассмотрим задачу о перемещении конфеты из позиции (x1, y1) в позицию (x2, y2). Очевидно, что каждым движением мы увеличиваем или уменьшаем x1 на a и y1 на b. Тогда несложно догадаться, что если |x2 - x1| не делится нацело на a или |y2 - x1| не делится нацело на a, то добраться не возможно.Стоит также заметить, что числа |x2 - x1| / a и |y2 - y1| / b должны быть одинаковы по парности, так как увеличение или уменьшение происходит одновременно для обоих значений.Помимо этого, нужно отдельно рассмотреть случай, когда ход выводит нас за границы доски, это не допустимо.Теперь мы можем определить сложность пути позиции (x1, y1) в позицию (x2, y2) как max(|x1 - x2| / a, |y1 - y2| / b). Посчитаем это для всех четырех углов и выберем максимум, либо определим, что добраться не возможно.374B — Инна и девятьОчевидно, что мы можем разбить задачу на подзадачи, так как если рядом не стоят цифры с суммой 9, то число будет независимо изменяться, относительно позиции между этими числами. Это значит, что мы разделим задачу на подзадачи вида x либо xyxyxyx...xyxy причем x + y = 9. Ответ для таких отрезков нужно будет перемножить, так как мы ищем общее количество вариантов. Для x ответ 1. Что же делать с xyxyxy? Пусть длинна ее s. Тогда, если s парное, мы однозначно получаем s / 2 девяток. Если же s не парное, одна цифра (причем любая) останется. Таким образом каждая последовательность xyxyxyxyx...xyxyxy непарной длинны s увеличивает ответ в s / 2 + 1 раз.374C — Инна и ДимаПо сути, задача сводится к нахождению цикла и поиску максимального пути, однако, решим ее без построения графа. Запустим обход в глубину из каждой буквы D, запоминая уже обработанные позиции. Если мы попали в позицию, в которой уже были раньше (зашли в нее обходом из других D) тогда можем просто прибавить длину текущего пути к длине максимального пути из этой позиции. Длина пути, заметьте, растет нe с каждый переходом, а только с переходом в букву A. Если же мы попали в позицию, помеченную номером нашей буквы D (из которой мы начали), значит, имеет место цикл, и поиски можно заканчивать. Не забудьте также менять цвет позиции при выходе из рекурсии, иначе будет \"ложный цикл\", таким образом, помеченными \"нашим\" цветом должны быть только позиции, в которые мы зашли рекурсивно, но еще не вышли.374D — Инна и последовательностьЗаметим, что всего будет добавлено не более n чисел, а следовательно вылетов тоже будет не более n. Будем имитировать процесс с помощью структур данных, к примеру, деревом отрезков (можно и другими). Будем поддерживать количество чисел, которое есть на подотрезке. Соответственно добавление — спускаемся от корня до листа, увеличивая на единичку значения. Удаление — с точностью до наоборот. Если в левом поддереве не достаточно элементов, спускаемся в правое, иначе — в левой. Не забудьте также смещать позицию дырки на ее номер (так как вылеты у нас моментальные из всех дырок) и останавливать цикл при достижении первой дырки, позиция которой больше текущего количества элементов.374E — Инна и пупсикиБудем делать бинпоиск по ответу (очевидно, что функция монотонная). Для каждого времени генерируем наши отрезки, и повернем их на 45 градусов так, чтобы они стали вертикальными и горизонтальными. Это можно сделать заменой (x, y) — (x + y, x - y). Не забудьте слить отрезки, стоящие на одной диагонали и имеющие пересечения в один. Для этого нужно отсортировать все отрезки, и пройтись подряд, обновляя правую или нижнюю границу соответственного отрезка. Теперь осталось проверить, можно ли из текущих отрезков сложить прямоугольник. К примеру, можно перебирать левый вертикальный отрезок, поддерживая множество всех горизонтальных, которые начинаются не позже него, затем, для каждого левого вертикального перебирать правый вертикальный, поддерживая уже множество горизонтальных, которые начинаются не позже левого, но и заканчиваются не раньше правого. Теперь осталось только убедится, что есть хотя бы два горизонтальных отрезка из множества, которые, к тому же удовлетворяют еще и неравенство по y-кам.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10018",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 374\\s*D"
          },
          "content_length": 4045
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 1",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 2",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 3",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 4",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 1",
          "code": "a1+a2 = b1+b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 2",
          "code": "(x2-x1)/a = a2-a1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 3",
          "code": "(y2-y1)/b = b2-b1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 4",
          "code": "(x2-x1)/a + (y2-y1)/b = (a2-a1) + (b2-b1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i < m; ++i) {\n        ensuref(a[i - 1] < a[i], \"The sequence a must be strictly increasing: a[%d]=%d >= a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-1, 1, \"event\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i < m; ++i) {\n        ensuref(a[i - 1] < a[i], \"The sequence a must be strictly increasing: a[%d]=%d >= a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-1, 1, \"event\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i < m; ++i) {\n        ensuref(a[i - 1] < a[i], \"The sequence a must be strictly increasing: a[%d]=%d >= a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-1, 1, \"event\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate m unique random integers in [1, 1e6]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n random events (-1, 0, or 1)\n        vector<int> events(n);\n        for (int i = 0; i < n; ++i) {\n            events[i] = rnd.next(-1,1);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"push_only\") {\n        // Generate m unique random integers in [1,1e6]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n random pushes (0 or 1)\n        vector<int> events(n);\n        for (int i = 0; i < n; ++i) {\n            events[i] = rnd.next(0,1);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"pop_only\") {\n        // Generate m unique random integers in [1,1e6]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n events, all -1\n        vector<int> events(n, -1);\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"alternating\") {\n        // Generate m unique integers in [1, n]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, n);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        vector<int> events;\n        for (int i = 0; i < n/2; ++i) {\n            events.push_back(rnd.next(0,1));\n            events.push_back(-1);\n        }\n        if (events.size() < n) {\n            events.push_back(rnd.next(0,1));\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"edge_case\") {\n        // m is given as parameter, we'll generate ai from 1 to m\n        vector<int> ai(m);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = i + 1;\n        }\n\n        vector<int> events;\n        // Let's design events\n\n        // First Dima hits before any pushes\n        events.push_back(-1);\n\n        // Now we add one number\n        events.push_back(1);\n\n        // Now Dima hits, should remove position 1\n        events.push_back(-1);\n\n        // Add more numbers\n        for (int i = 0; i < 5; ++i) {\n            events.push_back(rnd.next(0,1));\n        }\n\n        // Now Dima hits\n        events.push_back(-1);\n\n        // Continue adding numbers\n        while (events.size() < n) {\n             // Randomly decide to add number or Dima hits\n            int choice = rnd.next(0,2);\n            if (choice == 0) {\n                events.push_back(-1);\n            } else {\n                events.push_back(rnd.next(0,1));\n            }\n        }\n\n        // Trim events to size n\n        if (events.size() > n) {\n            events.resize(n);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else {\n        // Default to random\n        // Same as \"random\"\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n random events (-1, 0, or 1)\n        vector<int> events(n);\n        for (int i = 0; i < n; ++i) {\n            events[i] = rnd.next(-1,1);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate m unique random integers in [1, 1e6]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n random events (-1, 0, or 1)\n        vector<int> events(n);\n        for (int i = 0; i < n; ++i) {\n            events[i] = rnd.next(-1,1);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"push_only\") {\n        // Generate m unique random integers in [1,1e6]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n random pushes (0 or 1)\n        vector<int> events(n);\n        for (int i = 0; i < n; ++i) {\n            events[i] = rnd.next(0,1);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"pop_only\") {\n        // Generate m unique random integers in [1,1e6]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n events, all -1\n        vector<int> events(n, -1);\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"alternating\") {\n        // Generate m unique integers in [1, n]\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, n);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        vector<int> events;\n        for (int i = 0; i < n/2; ++i) {\n            events.push_back(rnd.next(0,1));\n            events.push_back(-1);\n        }\n        if (events.size() < n) {\n            events.push_back(rnd.next(0,1));\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else if (type == \"edge_case\") {\n        // m is given as parameter, we'll generate ai from 1 to m\n        vector<int> ai(m);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = i + 1;\n        }\n\n        vector<int> events;\n        // Let's design events\n\n        // First Dima hits before any pushes\n        events.push_back(-1);\n\n        // Now we add one number\n        events.push_back(1);\n\n        // Now Dima hits, should remove position 1\n        events.push_back(-1);\n\n        // Add more numbers\n        for (int i = 0; i < 5; ++i) {\n            events.push_back(rnd.next(0,1));\n        }\n\n        // Now Dima hits\n        events.push_back(-1);\n\n        // Continue adding numbers\n        while (events.size() < n) {\n             // Randomly decide to add number or Dima hits\n            int choice = rnd.next(0,2);\n            if (choice == 0) {\n                events.push_back(-1);\n            } else {\n                events.push_back(rnd.next(0,1));\n            }\n        }\n\n        // Trim events to size n\n        if (events.size() > n) {\n            events.resize(n);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n\n    } else {\n        // Default to random\n        // Same as \"random\"\n        set<int> ai_set;\n        while (ai_set.size() < m) {\n            int num = rnd.next(1, 1000000);\n            ai_set.insert(num);\n        }\n        vector<int> ai(ai_set.begin(), ai_set.end());\n        sort(ai.begin(), ai.end());\n\n        // Generate n random events (-1, 0, or 1)\n        vector<int> events(n);\n        for (int i = 0; i < n; ++i) {\n            events[i] = rnd.next(-1,1);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", ai[i]);\n        }\n        printf(\"\\n\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", events[i]);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type push_only\n./gen -n 10 -m 5 -type pop_only\n./gen -n 10 -m 5 -type alternating\n./gen -n 10 -m 5 -type edge_case\n\n./gen -n 100 -m 10 -type random\n./gen -n 1000 -m 500 -type random\n./gen -n 10000 -m 5000 -type random\n./gen -n 100000 -m 50000 -type random\n./gen -n 1000000 -m 500000 -type random\n\n./gen -n 100 -m 10 -type push_only\n./gen -n 1000 -m 1000 -type push_only\n./gen -n 10000 -m 10000 -type push_only\n./gen -n 100000 -m 50000 -type push_only\n\n./gen -n 100 -m 50 -type pop_only\n./gen -n 1000 -m 500 -type pop_only\n./gen -n 10000 -m 5000 -type pop_only\n\n./gen -n 100 -m 10 -type alternating\n./gen -n 1000 -m 500 -type alternating\n./gen -n 10000 -m 5000 -type alternating\n\n./gen -n 100 -m 50 -type edge_case\n./gen -n 500 -m 100 -type edge_case\n./gen -n 1000 -m 500 -type edge_case\n./gen -n 10000 -m 5000 -type edge_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:56.248243",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "374/E",
      "title": "E. Инна и пупсики",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест6 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 2000).В следующих n строках заданы координаты синих пупсиков. В i-той строке записаны целые числа xi, yi — координаты очередного пупсика. В следующих m строках заданы координаты m красных пупсиков в аналогичном формате.Все координаты во входных данных не превосходят 106 по модулю. Обратите внимание, что все пупсики стоят в различных точках.",
      "output_spec": "Выходные данныеВ единственной строке выведите целое число — ответ на задачу. Если прямоугольник никогда не появится на плоскости, выведите «Poor Sereja!» без кавычек.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 22 25 53 75 1Выходные данныеСкопировать3Входные данныеСкопировать3 22 23 26 24 25 2Выходные данныеСкопировать1",
      "description": "E. Инна и пупсики\n\nограничение по времени на тест6 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 2000).В следующих n строках заданы координаты синих пупсиков. В i-той строке записаны целые числа xi, yi — координаты очередного пупсика. В следующих m строках заданы координаты m красных пупсиков в аналогичном формате.Все координаты во входных данных не превосходят 106 по модулю. Обратите внимание, что все пупсики стоят в различных точках.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите целое число — ответ на задачу. Если прямоугольник никогда не появится на плоскости, выведите «Poor Sereja!» без кавычек.\n\nВыходные данные\n\nВходные данныеСкопировать2 22 25 53 75 1Выходные данныеСкопировать3Входные данныеСкопировать3 22 23 26 24 25 2Выходные данныеСкопировать1\n\nВходные данныеСкопировать2 22 25 53 75 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 22 23 26 24 25 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces",
          "content": "Всем привет! Скоро состоится Codeforces Round #220 (Div. 2), автором которого являюсь я, Дмитрий Березин. Это мой третий раунд, и Сережа все еще верит, что последний :)Со времен прошлого раунда многое изменилось, Дима и Инна подумали над своим поведением, извинились перед Сережей, и все теперь живут дружно. Вам предстоит еще больше укрепить семейное счастье!Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда, Марии Беловой (Delinur) за перевод задач, Михаилу Мирзаянову (MikeMirzayanov) за превосходную систему, и Сереже Нагину (Sereja) за то, что любезно (не выложил тут очередное фото) согласился помочь в тестировании.Разбалловка будет. 500-1000-1500-2000-2500. Я же сказал, что будет :) Прошу прощения за задержку.По всей видимости задача B имеет ошибки в авторском решении, приношу свои глубочайшие извинения. Сейчас мы исправляем ошибку и тесты. Раунд будет не рейтинговый. Большая часть решений, которые прошли претесты — неправильные. Вы можете исправить ваше решение и послать его в систему, как только все будет исправлено, все решения будут перетестированы.Спасибо Вам за потраченное время, постараюсь в будущем исключить подобные ошибки.Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces",
          "content": "374A — Инна и розовое пониРассмотрим задачу о перемещении конфеты из позиции (x1, y1) в позицию (x2, y2). Очевидно, что каждым движением мы увеличиваем или уменьшаем x1 на a и y1 на b. Тогда несложно догадаться, что если |x2 - x1| не делится нацело на a или |y2 - x1| не делится нацело на a, то добраться не возможно.Стоит также заметить, что числа |x2 - x1| / a и |y2 - y1| / b должны быть одинаковы по парности, так как увеличение или уменьшение происходит одновременно для обоих значений.Помимо этого, нужно отдельно рассмотреть случай, когда ход выводит нас за границы доски, это не допустимо.Теперь мы можем определить сложность пути позиции (x1, y1) в позицию (x2, y2) как max(|x1 - x2| / a, |y1 - y2| / b). Посчитаем это для всех четырех углов и выберем максимум, либо определим, что добраться не возможно.374B — Инна и девятьОчевидно, что мы можем разбить задачу на подзадачи, так как если рядом не стоят цифры с суммой 9, то число будет независимо изменяться, относительно позиции между этими числами. Это значит, что мы разделим задачу на подзадачи вида x либо xyxyxyx...xyxy причем x + y = 9. Ответ для таких отрезков нужно будет перемножить, так как мы ищем общее количество вариантов. Для x ответ 1. Что же делать с xyxyxy? Пусть длинна ее s. Тогда, если s парное, мы однозначно получаем s / 2 девяток. Если же s не парное, одна цифра (причем любая) останется. Таким образом каждая последовательность xyxyxyxyx...xyxyxy непарной длинны s увеличивает ответ в s / 2 + 1 раз.374C — Инна и ДимаПо сути, задача сводится к нахождению цикла и поиску максимального пути, однако, решим ее без построения графа. Запустим обход в глубину из каждой буквы D, запоминая уже обработанные позиции. Если мы попали в позицию, в которой уже были раньше (зашли в нее обходом из других D) тогда можем просто прибавить длину текущего пути к длине максимального пути из этой позиции. Длина пути, заметьте, растет нe с каждый переходом, а только с переходом в букву A. Если же мы попали в позицию, помеченную номером нашей буквы D (из которой мы начали), значит, имеет место цикл, и поиски можно заканчивать. Не забудьте также менять цвет позиции при выходе из рекурсии, иначе будет \"ложный цикл\", таким образом, помеченными \"нашим\" цветом должны быть только позиции, в которые мы зашли рекурсивно, но еще не вышли.374D — Инна и последовательностьЗаметим, что всего будет добавлено не более n чисел, а следовательно вылетов тоже будет не более n. Будем имитировать процесс с помощью структур данных, к примеру, деревом отрезков (можно и другими). Будем поддерживать количество чисел, которое есть на подотрезке. Соответственно добавление — спускаемся от корня до листа, увеличивая на единичку значения. Удаление — с точностью до наоборот. Если в левом поддереве не достаточно элементов, спускаемся в правое, иначе — в левой. Не забудьте также смещать позицию дырки на ее номер (так как вылеты у нас моментальные из всех дырок) и останавливать цикл при достижении первой дырки, позиция которой больше текущего количества элементов.374E — Инна и пупсикиБудем делать бинпоиск по ответу (очевидно, что функция монотонная). Для каждого времени генерируем наши отрезки, и повернем их на 45 градусов так, чтобы они стали вертикальными и горизонтальными. Это можно сделать заменой (x, y) — (x + y, x - y). Не забудьте слить отрезки, стоящие на одной диагонали и имеющие пересечения в один. Для этого нужно отсортировать все отрезки, и пройтись подряд, обновляя правую или нижнюю границу соответственного отрезка. Теперь осталось проверить, можно ли из текущих отрезков сложить прямоугольник. К примеру, можно перебирать левый вертикальный отрезок, поддерживая множество всех горизонтальных, которые начинаются не позже него, затем, для каждого левого вертикального перебирать правый вертикальный, поддерживая уже множество горизонтальных, которые начинаются не позже левого, но и заканчиваются не раньше правого. Теперь осталось только убедится, что есть хотя бы два горизонтальных отрезка из множества, которые, к тому же удовлетворяют еще и неравенство по y-кам.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10018",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 374\\s*E"
          },
          "content_length": 4045
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 1",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 2",
          "code": "int w[2000000];\nint *start = w;\nint *end = w;\n\nvoid appendValue(int i) {\n  *end = i;\n  end++;\n}\n\nvoid popFirst(int k) {\n  start += k;\n  if ( start >= end ) {\n    start = 0;\n    end = 0;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 3",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) - Codeforces - Code 4",
          "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int size = 499; // or 999\nchar str[size][size+1];\nconst char *dima = \"DIMA\";\nint main(){\n    freopen(\"cout.txt\", \"w\", stdout);\n    cout << size << \" \" << size << endl;\n    for(int i = 0; i < size; i++){\n        fill(str[i], str[i] + size, '?');\n        str[i][size] = '\\0';\n    }\n    int k = 0;\n    for(int i = 0; i < size / 2; i += 2){\n        for(int j = max(i - 1, 0); j < size - i; j++)\n            str[i][j] = str[i+1][j] = dima[k++ % 4];\n        for(int j = i + 1; j < size - i; j++)\n            str[j][size - i - 1] = str[j][size - i - 2] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i; j--)\n            str[size - i - 1][j] = str[size - i - 2][j] = dima[k++ % 4];\n        for(int j = size - i - 2; j >= i + 2; j--)\n            str[j][i] = str[j][i+1] = dima[k++ % 4];\n    }\n    for(int i = 0; i < size; i++)\n        cout << str[i] << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10003",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 1",
          "code": "a1+a2 = b1+b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 2",
          "code": "(x2-x1)/a = a2-a1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 3",
          "code": "(y2-y1)/b = b2-b1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #220 (Div. 2) разбор - Codeforces - Code 4",
          "code": "(x2-x1)/a + (y2-y1)/b = (a2-a1) + (b2-b1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10018",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Babies must stand in distinct points\");\n        points.insert(p);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Babies must stand in distinct points\");\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Babies must stand in distinct points\");\n        points.insert(p);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Babies must stand in distinct points\");\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Babies must stand in distinct points\");\n        points.insert(p);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Babies must stand in distinct points\");\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_positions(vector<pair<int, int>>& babies, int num, set<pair<int, int>>& used_positions, int xmin=-1000000, int xmax=1000000, int ymin=-1000000, int ymax=1000000) {\n    while ((int)babies.size() < num) {\n        int x = rnd.next(xmin, xmax);\n        int y = rnd.next(ymin, ymax);\n        if (used_positions.count({x, y}) == 0) {\n            babies.push_back({x, y});\n            used_positions.insert({x, y});\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> positions;\n    vector<pair<int, int>> blueBabies;\n    vector<pair<int, int>> redBabies;\n\n    if (type == \"simple\") {\n        // Small n and m, coordinates in a small range\n        n = min(n, 5);\n        m = min(m, 5);\n        generate_positions(blueBabies, n, positions, -10, 10, -10, 10);\n        generate_positions(redBabies, m, positions, -10, 10, -10, 10);\n\n    } else if (type == \"max_random\") {\n        // Max n and m, random positions\n        n = 2000;\n        m = 2000;\n        generate_positions(blueBabies, n, positions);\n        generate_positions(redBabies, m, positions);\n\n    } else if (type == \"no_rectangle\") {\n        // Generate positions so that rectangle never appears\n        int x_base = rnd.next(-1000000, 1000000);\n        for (int i = 0; i < n; ++i) {\n            int x = x_base + i;\n            int y = 1000000;\n            blueBabies.push_back({x, y});\n            positions.insert({x, y});\n        }\n        for (int i = 0; i < m; ++i) {\n            int x = x_base + i;\n            int y = -1000000;\n            redBabies.push_back({x, y});\n            positions.insert({x, y});\n        }\n    } else if (type == \"t1\") {\n        // Construct a rectangle that appears at t = 1\n        n = max(n, 2);\n        m = max(m, 2);\n\n        // Positions to cover the sides of rectangle [0,2] x [0,2] at t = 1\n        // Blue babies for left and right sides\n        blueBabies.push_back({0, 1});\n        positions.insert({0, 1});\n        if (n > 1) {\n            blueBabies.push_back({2, 1});\n            positions.insert({2, 1});\n            for (int i = 2; i < n; ++i) {\n                // Add random blue babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    blueBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n\n        // Red babies for top and bottom sides\n        redBabies.push_back({1, 0});\n        positions.insert({1, 0});\n        if (m > 1) {\n            redBabies.push_back({1, 2});\n            positions.insert({1, 2});\n            for (int i = 2; i < m; ++i) {\n                // Add random red babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    redBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n    } else if (type == \"t_large\") {\n        // Construct a rectangle that appears at a large t\n        int t_large = 1000000;\n        // Positions to cover the rectangle [0, t_large*2] x [0, t_large*2] at time t_large\n        n = max(n, 2);\n        m = max(m, 2);\n\n        // Blue babies for left and right sides\n        blueBabies.push_back({0, t_large});\n        positions.insert({0, t_large});\n        if (n > 1) {\n            blueBabies.push_back({t_large*2, t_large});\n            positions.insert({t_large*2, t_large});\n            for (int i = 2; i < n; ++i) {\n                // Add random blue babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    blueBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n\n        // Red babies for top and bottom sides\n        redBabies.push_back({t_large, 0});\n        positions.insert({t_large, 0});\n        if (m > 1) {\n            redBabies.push_back({t_large, t_large*2});\n            positions.insert({t_large, t_large*2});\n            for (int i = 2; i < m; ++i) {\n                // Add random red babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    redBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n    } else {\n        // Random positions within constraints\n        generate_positions(blueBabies, n, positions);\n        generate_positions(redBabies, m, positions);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output blue baby coordinates\n    for (auto p : blueBabies) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    // Output red baby coordinates\n    for (auto p : redBabies) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_positions(vector<pair<int, int>>& babies, int num, set<pair<int, int>>& used_positions, int xmin=-1000000, int xmax=1000000, int ymin=-1000000, int ymax=1000000) {\n    while ((int)babies.size() < num) {\n        int x = rnd.next(xmin, xmax);\n        int y = rnd.next(ymin, ymax);\n        if (used_positions.count({x, y}) == 0) {\n            babies.push_back({x, y});\n            used_positions.insert({x, y});\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> positions;\n    vector<pair<int, int>> blueBabies;\n    vector<pair<int, int>> redBabies;\n\n    if (type == \"simple\") {\n        // Small n and m, coordinates in a small range\n        n = min(n, 5);\n        m = min(m, 5);\n        generate_positions(blueBabies, n, positions, -10, 10, -10, 10);\n        generate_positions(redBabies, m, positions, -10, 10, -10, 10);\n\n    } else if (type == \"max_random\") {\n        // Max n and m, random positions\n        n = 2000;\n        m = 2000;\n        generate_positions(blueBabies, n, positions);\n        generate_positions(redBabies, m, positions);\n\n    } else if (type == \"no_rectangle\") {\n        // Generate positions so that rectangle never appears\n        int x_base = rnd.next(-1000000, 1000000);\n        for (int i = 0; i < n; ++i) {\n            int x = x_base + i;\n            int y = 1000000;\n            blueBabies.push_back({x, y});\n            positions.insert({x, y});\n        }\n        for (int i = 0; i < m; ++i) {\n            int x = x_base + i;\n            int y = -1000000;\n            redBabies.push_back({x, y});\n            positions.insert({x, y});\n        }\n    } else if (type == \"t1\") {\n        // Construct a rectangle that appears at t = 1\n        n = max(n, 2);\n        m = max(m, 2);\n\n        // Positions to cover the sides of rectangle [0,2] x [0,2] at t = 1\n        // Blue babies for left and right sides\n        blueBabies.push_back({0, 1});\n        positions.insert({0, 1});\n        if (n > 1) {\n            blueBabies.push_back({2, 1});\n            positions.insert({2, 1});\n            for (int i = 2; i < n; ++i) {\n                // Add random blue babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    blueBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n\n        // Red babies for top and bottom sides\n        redBabies.push_back({1, 0});\n        positions.insert({1, 0});\n        if (m > 1) {\n            redBabies.push_back({1, 2});\n            positions.insert({1, 2});\n            for (int i = 2; i < m; ++i) {\n                // Add random red babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    redBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n    } else if (type == \"t_large\") {\n        // Construct a rectangle that appears at a large t\n        int t_large = 1000000;\n        // Positions to cover the rectangle [0, t_large*2] x [0, t_large*2] at time t_large\n        n = max(n, 2);\n        m = max(m, 2);\n\n        // Blue babies for left and right sides\n        blueBabies.push_back({0, t_large});\n        positions.insert({0, t_large});\n        if (n > 1) {\n            blueBabies.push_back({t_large*2, t_large});\n            positions.insert({t_large*2, t_large});\n            for (int i = 2; i < n; ++i) {\n                // Add random blue babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    blueBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n\n        // Red babies for top and bottom sides\n        redBabies.push_back({t_large, 0});\n        positions.insert({t_large, 0});\n        if (m > 1) {\n            redBabies.push_back({t_large, t_large*2});\n            positions.insert({t_large, t_large*2});\n            for (int i = 2; i < m; ++i) {\n                // Add random red babies\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (positions.count({x, y}) == 0) {\n                    redBabies.push_back({x, y});\n                    positions.insert({x, y});\n                } else {\n                    --i;\n                }\n            }\n        }\n    } else {\n        // Random positions within constraints\n        generate_positions(blueBabies, n, positions);\n        generate_positions(redBabies, m, positions);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output blue baby coordinates\n    for (auto p : blueBabies) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    // Output red baby coordinates\n    for (auto p : redBabies) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Simple small test cases\n./gen -n 1 -m 1 -type simple\n./gen -n 2 -m 2 -type simple\n./gen -n 5 -m 5 -type simple\n\n# Random small test cases\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n\n# Test cases where rectangle appears at t = 1\n./gen -n 2 -m 2 -type t1\n./gen -n 5 -m 5 -type t1\n./gen -n 10 -m 10 -type t1\n\n# Test cases where rectangle appears at a large t\n./gen -n 2 -m 2 -type t_large\n./gen -n 10 -m 10 -type t_large\n./gen -n 100 -m 100 -type t_large\n\n# Test cases where rectangle never appears\n./gen -n 5 -m 5 -type no_rectangle\n./gen -n 10 -m 10 -type no_rectangle\n./gen -n 100 -m 100 -type no_rectangle\n\n# Maximum size test cases\n./gen -n 2000 -m 2000 -type max_random\n./gen -n 2000 -m 2000 -type random\n\n# Additional random test cases with varying sizes\n./gen -n 100 -m 100 -type random\n./gen -n 500 -m 500 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 1500 -m 1500 -type random\n\n# Test cases with uneven n and m\n./gen -n 2000 -m 1 -type random\n./gen -n 1 -m 2000 -type random\n./gen -n 1000 -m 2000 -type random\n./gen -n 2000 -m 1000 -type random\n\n# Edge case with minimal n and maximal m\n./gen -n 1 -m 2000 -type random\n./gen -n 2 -m 1999 -type random\n\n# Edge case with babies at extreme coordinates\n./gen -n 10 -m 10 -type random\n\n# Test cases with overlapping babies (positions adjusted to prevent actual overlap due to constraints)\n./gen -n 10 -m 10 -type t1\n./gen -n 20 -m 20 -type t1\n\n# Additional test cases to ensure coverage\n./gen -n 50 -m 50 -type simple\n./gen -n 200 -m 200 -type simple\n./gen -n 500 -m 500 -type no_rectangle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:16:58.321038",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "375/A",
      "title": "A. Divisible by Seven",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains positive integer a in the decimal record. It is guaranteed that the record of number a contains digits: 1, 6, 8, 9. Number a doesn't contain any leading zeroes. The decimal representation of number a contains at least 4 and at most 106 characters.",
      "output_spec": "OutputPrint a number in the decimal notation without leading zeroes — the result of the permutation.If it is impossible to rearrange the digits of the number a in the required manner, print 0.",
      "sample_tests": "ExamplesInputCopy1689OutputCopy1869InputCopy18906OutputCopy18690",
      "description": "A. Divisible by Seven\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains positive integer a in the decimal record. It is guaranteed that the record of number a contains digits: 1, 6, 8, 9. Number a doesn't contain any leading zeroes. The decimal representation of number a contains at least 4 and at most 106 characters.\n\nOutputPrint a number in the decimal notation without leading zeroes — the result of the permutation.If it is impossible to rearrange the digits of the number a in the required manner, print 0.\n\nInputCopy1689OutputCopy1869InputCopy18906OutputCopy18690\n\nInputCopy1689\n\nOutputCopy1869\n\nInputCopy18906\n\nOutputCopy18690",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 375\\s*A"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken();\n    inf.readEoln();\n\n    int n = s.length();\n    ensuref(n >= 4 && n <= 1000000, \"Length of a must be between 4 and 1e6, but is %d\", n);\n\n    ensuref(s[0] != '0', \"Number a must not have leading zero\");\n\n    for (int i = 0; i < n; ++i) {\n        ensuref('0' <= s[i] && s[i] <= '9', \"All characters in a must be digits, but found '%c'\", s[i]);\n    }\n\n    map<char, int> cnt;\n    for (char c : s) {\n        cnt[c]++;\n    }\n\n    ensuref(cnt['1'] > 0, \"Number a must contain digit '1'\");\n    ensuref(cnt['6'] > 0, \"Number a must contain digit '6'\");\n    ensuref(cnt['8'] > 0, \"Number a must contain digit '8'\");\n    ensuref(cnt['9'] > 0, \"Number a must contain digit '9'\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken();\n    inf.readEoln();\n\n    int n = s.length();\n    ensuref(n >= 4 && n <= 1000000, \"Length of a must be between 4 and 1e6, but is %d\", n);\n\n    ensuref(s[0] != '0', \"Number a must not have leading zero\");\n\n    for (int i = 0; i < n; ++i) {\n        ensuref('0' <= s[i] && s[i] <= '9', \"All characters in a must be digits, but found '%c'\", s[i]);\n    }\n\n    map<char, int> cnt;\n    for (char c : s) {\n        cnt[c]++;\n    }\n\n    ensuref(cnt['1'] > 0, \"Number a must contain digit '1'\");\n    ensuref(cnt['6'] > 0, \"Number a must contain digit '6'\");\n    ensuref(cnt['8'] > 0, \"Number a must contain digit '8'\");\n    ensuref(cnt['9'] > 0, \"Number a must contain digit '9'\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken();\n    inf.readEoln();\n\n    int n = s.length();\n    ensuref(n >= 4 && n <= 1000000, \"Length of a must be between 4 and 1e6, but is %d\", n);\n\n    ensuref(s[0] != '0', \"Number a must not have leading zero\");\n\n    for (int i = 0; i < n; ++i) {\n        ensuref('0' <= s[i] && s[i] <= '9', \"All characters in a must be digits, but found '%c'\", s[i]);\n    }\n\n    map<char, int> cnt;\n    for (char c : s) {\n        cnt[c]++;\n    }\n\n    ensuref(cnt['1'] > 0, \"Number a must contain digit '1'\");\n    ensuref(cnt['6'] > 0, \"Number a must contain digit '6'\");\n    ensuref(cnt['8'] > 0, \"Number a must contain digit '8'\");\n    ensuref(cnt['9'] > 0, \"Number a must contain digit '9'\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input number a from the input file\n    string a = inf.readLine();\n    // Build frequency map of digits in a\n    vector<int> freq_a(10, 0);\n    for (char c : a) {\n        if (!isdigit(c)) {\n            quitf(_fail, \"Input contains non-digit character\");\n        }\n        freq_a[c - '0']++;\n    }\n    // Read contestant's output\n    string s = ouf.readToken();\n    // First, check s is non-empty\n    if (s.empty()) {\n        quitf(_wa, \"No output\");\n    }\n    // Check s does not have leading zeros (unless it is \"0\")\n    if (s.size() > 1 && s[0] == '0') {\n        quitf(_wa, \"Output has leading zeros\");\n    }\n    // Check if s is \"0\"\n    if (s == \"0\") {\n        quitf(_wa, \"Answer should not be 0, rearrangement is possible\");\n    }\n    // Check s consists only of digits '0'-'9' and build freq_s\n    vector<int> freq_s(10, 0);\n    for (char c : s) {\n        if (!isdigit(c)) {\n            quitf(_wa, \"Output contains non-digit character\");\n        }\n        freq_s[c - '0']++;\n    }\n    // Check that frequencies match\n    for (int d = 0; d <= 9; d++) {\n        if (freq_a[d] != freq_s[d]) {\n            quitf(_wa, \"Digit counts do not match for digit %d\", d);\n        }\n    }\n    // Compute s mod 7\n    int mod = 0;\n    for (char c : s) {\n        mod = (mod * 10 + (c - '0')) % 7;\n    }\n    if (mod != 0) {\n        quitf(_wa, \"Number is not divisible by 7\");\n    }\n    // Everything is OK\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a; // The input number\n\n    if (type == \"random\") {\n        int n_digits = n;\n        vector<char> digits;\n        // Add one occurrence of each of 1,6,8,9\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        n_digits -= 4;\n        // Generate remaining digits randomly\n        for (int i = 0; i < n_digits; ++i) {\n            char d = rnd.next(0,9) + '0';\n            digits.push_back(d);\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not 0\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        // Build the number\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"leadingZeroEdge\") {\n        int n_digits = n;\n        vector<char> digits;\n        // One occurrence of each of 1,6,8,9\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        n_digits -= 4;\n        // Add remaining zeros\n        for (int i = 0; i < n_digits; ++i) {\n            digits.push_back('0');\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not zero\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            // If all are zeros, set first digit to '1'\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"repeatedDigits\") {\n        int n_digits = n;\n        vector<char> digits;\n        // One occurrence of each of 1,6,8,9\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        n_digits -= 4;\n        // Choose a digit to repeat\n        char repeat_digit = rnd.next(0,9) + '0';\n        // Add repeated digits\n        for (int i = 0; i < n_digits; ++i) {\n            digits.push_back(repeat_digit);\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not zero\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"allDigits\") {\n        int n_digits = n;\n        vector<char> digits;\n        for (char c = '0'; c <= '9'; ++c) {\n            digits.push_back(c);\n        }\n        n_digits -= 10;\n        for (int i = 0; i < n_digits; ++i) {\n            digits.push_back(rnd.next(0,9) + '0');\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not zero\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"small\") {\n        n = 4;\n        vector<char> digits;\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        a = string(digits.begin(), digits.end());\n    } else {\n        // Default case, same as random\n        //...\n    }\n\n    cout << a << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a; // The input number\n\n    if (type == \"random\") {\n        int n_digits = n;\n        vector<char> digits;\n        // Add one occurrence of each of 1,6,8,9\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        n_digits -= 4;\n        // Generate remaining digits randomly\n        for (int i = 0; i < n_digits; ++i) {\n            char d = rnd.next(0,9) + '0';\n            digits.push_back(d);\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not 0\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        // Build the number\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"leadingZeroEdge\") {\n        int n_digits = n;\n        vector<char> digits;\n        // One occurrence of each of 1,6,8,9\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        n_digits -= 4;\n        // Add remaining zeros\n        for (int i = 0; i < n_digits; ++i) {\n            digits.push_back('0');\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not zero\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            // If all are zeros, set first digit to '1'\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"repeatedDigits\") {\n        int n_digits = n;\n        vector<char> digits;\n        // One occurrence of each of 1,6,8,9\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        n_digits -= 4;\n        // Choose a digit to repeat\n        char repeat_digit = rnd.next(0,9) + '0';\n        // Add repeated digits\n        for (int i = 0; i < n_digits; ++i) {\n            digits.push_back(repeat_digit);\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not zero\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"allDigits\") {\n        int n_digits = n;\n        vector<char> digits;\n        for (char c = '0'; c <= '9'; ++c) {\n            digits.push_back(c);\n        }\n        n_digits -= 10;\n        for (int i = 0; i < n_digits; ++i) {\n            digits.push_back(rnd.next(0,9) + '0');\n        }\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        // Ensure first digit is not zero\n        if (digits[0] == '0') {\n            for (int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n            if (digits[0] == '0') {\n                digits[0] = '1';\n            }\n        }\n        a = string(digits.begin(), digits.end());\n    } else if (type == \"small\") {\n        n = 4;\n        vector<char> digits;\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n        // Shuffle digits\n        shuffle(digits.begin(), digits.end());\n        a = string(digits.begin(), digits.end());\n    } else {\n        // Default case, same as random\n        //...\n    }\n\n    cout << a << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type small\n\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n./gen -n 500000 -type random\n./gen -n 1000000 -type random\n\n./gen -n 10 -type leadingZeroEdge\n./gen -n 50 -type leadingZeroEdge\n./gen -n 100 -type leadingZeroEdge\n./gen -n 1000 -type leadingZeroEdge\n./gen -n 5000 -type leadingZeroEdge\n\n./gen -n 10 -type repeatedDigits\n./gen -n 100 -type repeatedDigits\n./gen -n 1000 -type repeatedDigits\n./gen -n 10000 -type repeatedDigits\n./gen -n 100000 -type repeatedDigits\n\n./gen -n 10 -type allDigits\n./gen -n 100 -type allDigits\n./gen -n 1000 -type allDigits\n./gen -n 10000 -type allDigits\n\n./gen -n 4 -type small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:00.224050",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "375/B",
      "title": "B. Наибольшая подматрица 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n и m (1 ≤ n, m ≤ 5000). В следующих n строках записано по m символов — матрица a. Матрица a содержит только символы: «0» и «1». Обратите внимание, что элементы матрицы заданы в строках без пробелов.",
      "output_spec": "Выходные данныеВыведите единственное целое число — площадь максимальной полученной подматрицы. Если подматрицу из единиц невозможно получить, выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 11Выходные данныеСкопировать1Входные данныеСкопировать2 21011Выходные данныеСкопировать2Входные данныеСкопировать4 3100011000101Выходные данныеСкопировать2",
      "description": "B. Наибольшая подматрица 2\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых числа n и m (1 ≤ n, m ≤ 5000). В следующих n строках записано по m символов — матрица a. Матрица a содержит только символы: «0» и «1». Обратите внимание, что элементы матрицы заданы в строках без пробелов.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — площадь максимальной полученной подматрицы. Если подматрицу из единиц невозможно получить, выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать1 11Выходные данныеСкопировать1Входные данныеСкопировать2 21011Выходные данныеСкопировать2Входные данныеСкопировать4 3100011000101Выходные данныеСкопировать2\n\nВходные данныеСкопировать1 11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 21011\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 3100011000101\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Привет, Codeforces Round #221 начнется 24го декабря в 18:00 по москве. Раунд будет проводиться в обоих дивизионах.Задачи готовили whd, oGhost и boleyn.su. Это наш первый раунд на Codeforces, и мы надеемся, что он будет весьма хорош.Хочется поблагодарить Gerald и alpc104 за помощь в подготовке раунда, а также MikeMirzayanov за создание платформы, где все мы можем соревноваться и общаться.Распределение баллов по задачам будет анонсировано перед началом контеста.UPD1: Распределение баллов 500-1000-1500-2000-2500 для обоих дивизионов.UPD2: Наши поздравления победителям! Также поздравляем с рождеством всех, кто празднует его сегодня!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 733
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 375\\s*B"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "10^(n - 4))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "<<<\nx += (x & -x);\n>>>\nx = x | (x + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "<<<\nx += (x & -x);\n>>>\nx = x | (x + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "<<<\nx -= (x & -x);\n>>>\nx = (x & (x + 1)) - 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "<<<\nx -= (x & -x);\n>>>\nx = (x & (x + 1)) - 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 12",
          "code": "sort(v,v+n,greater<int>())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 13",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 14",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 15",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 16",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 17",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    \n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(pattern);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    \n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(pattern);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    \n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(pattern);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> matrix(n, string(m, '0'));\n\n    if (type == \"all_zeros\") {\n        // The matrix is already initialized with '0's\n    } else if (type == \"all_ones\") {\n        for(int i = 0; i < n; ++i)\n            fill(matrix[i].begin(), matrix[i].end(), '1');\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                matrix[i][j] = rnd.next(2) + '0';  // '0' or '1'\n    } else if (type == \"single_one\") {\n        // Only one '1' in the entire matrix\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        matrix[x][y] = '1';\n    } else if (type == \"single_row_ones\") {\n        // Only one row has ones, rest are zeros\n        int x = rnd.next(0, n - 1);\n        for (int j = 0; j < m; ++j)\n            matrix[x][j] = '1';\n    } else if (type == \"single_column_ones\") {\n        // Only one column has ones, rest are zeros\n        int y = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i)\n            matrix[i][y] = '1';\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                matrix[i][j] = ((i + j) % 2) + '0';\n    } else if (type == \"half_ones\") {\n        // Top half rows are ones, bottom half zeros\n        int mid = n / 2;\n        for (int i = 0; i < mid; ++i)\n            fill(matrix[i].begin(), matrix[i].end(), '1');\n    } else if (type == \"large_rectangle\") {\n        // Generate a large rectangle of ones somewhere in the matrix\n        int h = rnd.next(n / 2, n);\n        int w = rnd.next(m / 2, m);\n        int si = rnd.next(0, n - h);\n        int sj = rnd.next(0, m - w);\n        for (int i = si; i < si + h; ++i)\n            for (int j = sj; j < sj + w; ++j)\n                matrix[i][j] = '1';\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n && i < m; ++i)\n            matrix[i][i] = '1';\n    } else if (type == \"anti_diagonal\") {\n        for (int i = 0; i < n && i < m; ++i)\n            matrix[i][m - i - 1] = '1';\n    } else if (type == \"sparse\") {\n        // Randomly place a few ones\n        int ones = opt<int>(\"ones\", n * m / 10); // Default number of ones is 10% of cells\n        for (int k = 0; k < ones; ++k) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            matrix[i][j] = '1';\n        }\n    } else if (type == \"full_random\") {\n        // Fill the matrix with '1's and '0's with a given probability\n        double p = opt<double>(\"p\", 0.5);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                matrix[i][j] = (rnd.next(0.0, 1.0) < p) ? '1' : '0';\n    } else if (type == \"worst_case\") {\n        // Construct a matrix that may cause O(n^2) solutions to TLE\n        // Each row has a decreasing number of ones\n        for (int i = 0; i < n; ++i) {\n            int num_ones = m - i;\n            for (int j = 0; j < num_ones; ++j)\n                matrix[i][j] = '1';\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                matrix[i][j] = rnd.next(2) + '0';\n    }\n\n    // Output the matrix\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", matrix[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> matrix(n, string(m, '0'));\n\n    if (type == \"all_zeros\") {\n        // The matrix is already initialized with '0's\n    } else if (type == \"all_ones\") {\n        for(int i = 0; i < n; ++i)\n            fill(matrix[i].begin(), matrix[i].end(), '1');\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                matrix[i][j] = rnd.next(2) + '0';  // '0' or '1'\n    } else if (type == \"single_one\") {\n        // Only one '1' in the entire matrix\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        matrix[x][y] = '1';\n    } else if (type == \"single_row_ones\") {\n        // Only one row has ones, rest are zeros\n        int x = rnd.next(0, n - 1);\n        for (int j = 0; j < m; ++j)\n            matrix[x][j] = '1';\n    } else if (type == \"single_column_ones\") {\n        // Only one column has ones, rest are zeros\n        int y = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i)\n            matrix[i][y] = '1';\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                matrix[i][j] = ((i + j) % 2) + '0';\n    } else if (type == \"half_ones\") {\n        // Top half rows are ones, bottom half zeros\n        int mid = n / 2;\n        for (int i = 0; i < mid; ++i)\n            fill(matrix[i].begin(), matrix[i].end(), '1');\n    } else if (type == \"large_rectangle\") {\n        // Generate a large rectangle of ones somewhere in the matrix\n        int h = rnd.next(n / 2, n);\n        int w = rnd.next(m / 2, m);\n        int si = rnd.next(0, n - h);\n        int sj = rnd.next(0, m - w);\n        for (int i = si; i < si + h; ++i)\n            for (int j = sj; j < sj + w; ++j)\n                matrix[i][j] = '1';\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n && i < m; ++i)\n            matrix[i][i] = '1';\n    } else if (type == \"anti_diagonal\") {\n        for (int i = 0; i < n && i < m; ++i)\n            matrix[i][m - i - 1] = '1';\n    } else if (type == \"sparse\") {\n        // Randomly place a few ones\n        int ones = opt<int>(\"ones\", n * m / 10); // Default number of ones is 10% of cells\n        for (int k = 0; k < ones; ++k) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            matrix[i][j] = '1';\n        }\n    } else if (type == \"full_random\") {\n        // Fill the matrix with '1's and '0's with a given probability\n        double p = opt<double>(\"p\", 0.5);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                matrix[i][j] = (rnd.next(0.0, 1.0) < p) ? '1' : '0';\n    } else if (type == \"worst_case\") {\n        // Construct a matrix that may cause O(n^2) solutions to TLE\n        // Each row has a decreasing number of ones\n        for (int i = 0; i < n; ++i) {\n            int num_ones = m - i;\n            for (int j = 0; j < num_ones; ++j)\n                matrix[i][j] = '1';\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                matrix[i][j] = rnd.next(2) + '0';\n    }\n\n    // Output the matrix\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", matrix[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal cases\n./gen -n 1 -m 1 -type all_zeros\n./gen -n 1 -m 1 -type all_ones\n./gen -n 1 -m 1 -type random\n\n# Small test cases\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type single_one\n./gen -n 5 -m 5 -type single_row_ones\n./gen -n 5 -m 5 -type single_column_ones\n./gen -n 5 -m 5 -type checkerboard\n./gen -n 5 -m 5 -type half_ones\n./gen -n 5 -m 5 -type large_rectangle\n./gen -n 5 -m 5 -type diagonal\n./gen -n 5 -m 5 -type anti_diagonal\n./gen -n 5 -m 5 -type sparse -ones 3\n./gen -n 5 -m 5 -type full_random -p 0.3\n\n# Medium test cases\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type all_ones\n./gen -n 100 -m 100 -type all_zeros\n./gen -n 100 -m 100 -type checkerboard\n./gen -n 100 -m 100 -type large_rectangle\n./gen -n 100 -m 100 -type sparse -ones 500\n./gen -n 100 -m 100 -type full_random -p 0.1\n./gen -n 100 -m 100 -type full_random -p 0.9\n./gen -n 100 -m 100 -type diagonal\n./gen -n 100 -m 100 -type anti_diagonal\n\n# Large test cases\n./gen -n 5000 -m 5000 -type random\n./gen -n 5000 -m 5000 -type all_ones\n./gen -n 5000 -m 5000 -type all_zeros\n./gen -n 5000 -m 5000 -type checkerboard\n./gen -n 5000 -m 5000 -type large_rectangle\n./gen -n 5000 -m 5000 -type sparse -ones 5000000\n./gen -n 5000 -m 5000 -type full_random -p 0.1\n./gen -n 5000 -m 5000 -type full_random -p 0.9\n./gen -n 5000 -m 5000 -type half_ones\n./gen -n 5000 -m 5000 -type diagonal\n./gen -n 5000 -m 5000 -type anti_diagonal\n./gen -n 5000 -m 5000 -type worst_case\n\n# Edge cases with n or m = 1\n./gen -n 5000 -m 1 -type random\n./gen -n 1 -m 5000 -type random\n./gen -n 5000 -m 1 -type all_ones\n./gen -n 1 -m 5000 -type all_ones\n\n# Additional test cases\n./gen -n 3000 -m 5000 -type random\n./gen -n 5000 -m 3000 -type random\n./gen -n 5000 -m 5000 -type sparse -ones 1000000\n./gen -n 5000 -m 5000 -type full_random -p 0.5\n./gen -n 5000 -m 5000 -type large_rectangle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:01.841527",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "375/C",
      "title": "C. Circling Round Treasures",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 20) — the sizes of the table. Next n lines each contains m characters — the description of the table. The description means the following:  character \"B\" is a cell with a bomb;  character \"S\" is the starting cell, you can assume that it's empty;  digit c (1-8) is treasure with index c;  character \".\" is an empty cell;  character \"#\" is an obstacle. Assume that the map has t treasures. Next t lines contain the prices of the treasures. The i-th line contains the price of the treasure with index i, vi ( - 200 ≤ vi ≤ 200). It is guaranteed that the treasures are numbered from 1 to t. It is guaranteed that the map has not more than 8 objects in total. Objects are bombs and treasures. It is guaranteed that the map has exactly one character \"S\".",
      "output_spec": "OutputPrint a single integer — the maximum possible profit you can get.",
      "sample_tests": "ExamplesInputCopy4 4.....S1.........10OutputCopy2InputCopy7 7........1###2..#...#..#.B.#..3...4...##.........S100100100100OutputCopy364InputCopy7 8....................1B...S..........2...3...............100-100100OutputCopy0InputCopy1 1SOutputCopy0",
      "description": "C. Circling Round Treasures\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 20) — the sizes of the table. Next n lines each contains m characters — the description of the table. The description means the following:  character \"B\" is a cell with a bomb;  character \"S\" is the starting cell, you can assume that it's empty;  digit c (1-8) is treasure with index c;  character \".\" is an empty cell;  character \"#\" is an obstacle. Assume that the map has t treasures. Next t lines contain the prices of the treasures. The i-th line contains the price of the treasure with index i, vi ( - 200 ≤ vi ≤ 200). It is guaranteed that the treasures are numbered from 1 to t. It is guaranteed that the map has not more than 8 objects in total. Objects are bombs and treasures. It is guaranteed that the map has exactly one character \"S\".\n\nOutputPrint a single integer — the maximum possible profit you can get.\n\nInputCopy4 4.....S1.........10OutputCopy2InputCopy7 7........1###2..#...#..#.B.#..3...4...##.........S100100100100OutputCopy364InputCopy7 8....................1B...S..........2...3...............100-100100OutputCopy0InputCopy1 1SOutputCopy0\n\nInputCopy4 4.....S1.........10\n\nOutputCopy2\n\nInputCopy7 7........1###2..#...#..#.B.#..3...4...##.........S100100100100\n\nOutputCopy364\n\nInputCopy7 8....................1B...S..........2...3...............100-100100\n\nOutputCopy0\n\nInputCopy1 1S\n\nOutputCopy0\n\nNoteIn the first example the answer will look as follows.  In the second example the answer will look as follows.  In the third example you cannot get profit.In the fourth example you cannot get profit as you cannot construct a closed path with more than one cell.",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 375\\s*C"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    int s_count = 0;\n    int number_of_bombs = 0;\n    int number_of_treasures = 0;\n    set<int> treasureLabels;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have length %d, but has length %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            char ch = s[j];\n            if (ch == 'S') {\n                s_count++;\n            } else if (ch == 'B') {\n                number_of_bombs++;\n            } else if (ch == '.' || ch == '#') {\n                // do nothing\n            } else if ('1' <= ch && ch <= '8') {\n                int c = ch - '0';\n                treasureLabels.insert(c);\n                number_of_treasures++;\n            } else {\n                ensuref(false, \"Invalid character '%c' at row %d, column %d\", ch, i+1, j+1);\n            }\n        }\n    }\n\n    ensuref(s_count == 1, \"There must be exactly one 'S' in the grid, found %d\", s_count);\n    ensuref(number_of_bombs + number_of_treasures <= 8, \"Total number of bombs and treasures must not exceed 8, found %d\", number_of_bombs + number_of_treasures);\n\n    int t = 0;\n    if (!treasureLabels.empty()) {\n        t = *treasureLabels.rbegin(); // maximum label\n        ensuref(t <= 8, \"Maximum treasure label must be at most 8, found %d\", t);\n        ensuref((int)treasureLabels.size() == t, \"Treasures must be labeled from 1 to %d, but found only %d labels\", t, (int)treasureLabels.size());\n        for (int i = 1; i <= t; ++i) {\n            ensuref(treasureLabels.count(i) == 1, \"Missing treasure label %d\", i);\n        }\n    }\n\n    for (int i = 0; i < t; ++i) {\n        int vi = inf.readInt(-200, 200, format(\"v[%d]\", i+1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    int s_count = 0;\n    int number_of_bombs = 0;\n    int number_of_treasures = 0;\n    set<int> treasureLabels;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have length %d, but has length %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            char ch = s[j];\n            if (ch == 'S') {\n                s_count++;\n            } else if (ch == 'B') {\n                number_of_bombs++;\n            } else if (ch == '.' || ch == '#') {\n                // do nothing\n            } else if ('1' <= ch && ch <= '8') {\n                int c = ch - '0';\n                treasureLabels.insert(c);\n                number_of_treasures++;\n            } else {\n                ensuref(false, \"Invalid character '%c' at row %d, column %d\", ch, i+1, j+1);\n            }\n        }\n    }\n\n    ensuref(s_count == 1, \"There must be exactly one 'S' in the grid, found %d\", s_count);\n    ensuref(number_of_bombs + number_of_treasures <= 8, \"Total number of bombs and treasures must not exceed 8, found %d\", number_of_bombs + number_of_treasures);\n\n    int t = 0;\n    if (!treasureLabels.empty()) {\n        t = *treasureLabels.rbegin(); // maximum label\n        ensuref(t <= 8, \"Maximum treasure label must be at most 8, found %d\", t);\n        ensuref((int)treasureLabels.size() == t, \"Treasures must be labeled from 1 to %d, but found only %d labels\", t, (int)treasureLabels.size());\n        for (int i = 1; i <= t; ++i) {\n            ensuref(treasureLabels.count(i) == 1, \"Missing treasure label %d\", i);\n        }\n    }\n\n    for (int i = 0; i < t; ++i) {\n        int vi = inf.readInt(-200, 200, format(\"v[%d]\", i+1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    int s_count = 0;\n    int number_of_bombs = 0;\n    int number_of_treasures = 0;\n    set<int> treasureLabels;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have length %d, but has length %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            char ch = s[j];\n            if (ch == 'S') {\n                s_count++;\n            } else if (ch == 'B') {\n                number_of_bombs++;\n            } else if (ch == '.' || ch == '#') {\n                // do nothing\n            } else if ('1' <= ch && ch <= '8') {\n                int c = ch - '0';\n                treasureLabels.insert(c);\n                number_of_treasures++;\n            } else {\n                ensuref(false, \"Invalid character '%c' at row %d, column %d\", ch, i+1, j+1);\n            }\n        }\n    }\n\n    ensuref(s_count == 1, \"There must be exactly one 'S' in the grid, found %d\", s_count);\n    ensuref(number_of_bombs + number_of_treasures <= 8, \"Total number of bombs and treasures must not exceed 8, found %d\", number_of_bombs + number_of_treasures);\n\n    int t = 0;\n    if (!treasureLabels.empty()) {\n        t = *treasureLabels.rbegin(); // maximum label\n        ensuref(t <= 8, \"Maximum treasure label must be at most 8, found %d\", t);\n        ensuref((int)treasureLabels.size() == t, \"Treasures must be labeled from 1 to %d, but found only %d labels\", t, (int)treasureLabels.size());\n        for (int i = 1; i <= t; ++i) {\n            ensuref(treasureLabels.count(i) == 1, \"Missing treasure label %d\", i);\n        }\n    }\n\n    for (int i = 0; i < t; ++i) {\n        int vi = inf.readInt(-200, 200, format(\"v[%d]\", i+1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within bounds\n    ensure(1 <= n && n <= 20);\n    ensure(1 <= m && m <= 20);\n\n    if (type == \"random\") {\n        // Generate a random grid of size n x m\n        int max_objects = 8; // Maximum number of bombs and treasures\n\n        int max_treasures = min(max_objects, 8);\n        int t = rnd.next(1, max_treasures); // number of treasures\n\n        int max_bombs = max_objects - t;\n        int b = rnd.next(0, max_bombs); // number of bombs\n\n        int total_objects = t + b;\n        int max_obstacles = n * m - total_objects - 1; // Leave space for 'S'\n\n        // Create grid filled with '.'\n        vector<string> grid(n, string(m, '.'));\n        set<pair<int, int>> used_positions;\n\n        // Randomly place treasures with indices from '1' to '8'\n        for (int i = 1; i <= t; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            used_positions.insert({x, y});\n            grid[x][y] = '0' + i;\n        }\n\n        // Randomly place bombs 'B'\n        for (int i = 0; i < b; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            used_positions.insert({x, y});\n            grid[x][y] = 'B';\n        }\n\n        // Randomly place obstacles '#'\n        int remaining_cells = n * m - (int)used_positions.size() - 1;\n        int num_obstacles = rnd.next(0, min(remaining_cells, max(remaining_cells / 10, 5)));\n        for (int i = 0; i < num_obstacles; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            used_positions.insert({x, y});\n            grid[x][y] = '#';\n        }\n\n        // Place 'S' in a random empty cell\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, m - 1);\n        } while (used_positions.count({x, y}));\n        grid[x][y] = 'S';\n        used_positions.insert({x, y});\n\n        // Output grid\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n        // Output treasure values\n        for (int i = 1; i <= t; ++i) {\n            int v = rnd.next(-200, 200);\n            printf(\"%d\\n\", v);\n        }\n\n    } else if (type == \"maximal\") {\n        // Maximal test case\n        n = 20;\n        m = 20;\n        int t = 8; // Max treasures\n        int b = 0; // No bombs\n\n        vector<string> grid(n, string(m, '.'));\n        set<pair<int, int>> used_positions;\n\n        // Fill half the grid with obstacles\n        int num_obstacles = n * m / 2;\n        for (int i = 0; i < num_obstacles; ++i) {\n            int x = i / m;\n            int y = i % m;\n            grid[x][y] = '#';\n            used_positions.insert({x, y});\n        }\n\n        // Place treasures\n        for (int i = 1; i <= t; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (grid[x][y] != '.');\n            grid[x][y] = '0' + i;\n            used_positions.insert({x, y});\n        }\n\n        // Place 'S'\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, m - 1);\n        } while (grid[x][y] != '.');\n        grid[x][y] = 'S';\n        used_positions.insert({x, y});\n\n        // Output grid\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n        // Output treasure values (max value 200)\n        for (int i = 1; i <= t; ++i) {\n            printf(\"200\\n\");\n        }\n\n    } else if (type == \"minimal\") {\n        // Minimal test case\n        n = 1;\n        m = 1;\n        printf(\"%d %d\\n\", n, m);\n        printf(\"S\\n\");\n        // No treasures or bombs\n\n    } else if (type == \"impossible\") {\n        // Impossible test case\n        vector<string> grid(n, string(m, '#'));\n        int x = n / 2;\n        int y = m / 2;\n        grid[x][y] = 'S';\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n    } else if (type == \"negative\") {\n        // Negative treasure values\n        int max_objects = 8;\n        int t = rnd.next(1, max_objects); // number of treasures\n        int b = rnd.next(0, max_objects - t); // number of bombs\n\n        vector<string> grid(n, string(m, '.'));\n        set<pair<int, int>> used_positions;\n\n        // Place treasures\n        for (int i = 1; i <= t; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            grid[x][y] = '0' + i;\n            used_positions.insert({x, y});\n        }\n\n        // Place bombs\n        for (int i = 0; i < b; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            grid[x][y] = 'B';\n            used_positions.insert({x, y});\n        }\n\n        // Place 'S'\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, m - 1);\n        } while (used_positions.count({x, y}));\n        grid[x][y] = 'S';\n        used_positions.insert({x, y});\n\n        // Output grid\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n        // Output negative treasure values\n        for (int i = 1; i <= t; ++i) {\n            int v = rnd.next(-200, -1);\n            printf(\"%d\\n\", v);\n        }\n\n    } else if (type == \"self_intersection\") {\n        // Self-intersection required\n        n = 5;\n        m = 5;\n        vector<string> grid = {\n            \".....\",\n            \".S#1.\",\n            \".#.#.\",\n            \".2#..\",\n            \".....\"\n        };\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n        printf(\"100\\n\");\n        printf(\"100\\n\");\n\n    } else if (type == \"edge_case\") {\n        // Edge case for point-in-polygon\n        n = 5;\n        m = 5;\n        vector<string> grid = {\n            \"1....\",\n            \".#.#.\",\n            \"..S..\",\n            \".#.#.\",\n            \"....2\"\n        };\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n        printf(\"100\\n\");\n        printf(\"100\\n\");\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s. Using random.\\n\", type.c_str());\n        // Default to random\n        // (Omitted code duplication for brevity)\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within bounds\n    ensure(1 <= n && n <= 20);\n    ensure(1 <= m && m <= 20);\n\n    if (type == \"random\") {\n        // Generate a random grid of size n x m\n        int max_objects = 8; // Maximum number of bombs and treasures\n\n        int max_treasures = min(max_objects, 8);\n        int t = rnd.next(1, max_treasures); // number of treasures\n\n        int max_bombs = max_objects - t;\n        int b = rnd.next(0, max_bombs); // number of bombs\n\n        int total_objects = t + b;\n        int max_obstacles = n * m - total_objects - 1; // Leave space for 'S'\n\n        // Create grid filled with '.'\n        vector<string> grid(n, string(m, '.'));\n        set<pair<int, int>> used_positions;\n\n        // Randomly place treasures with indices from '1' to '8'\n        for (int i = 1; i <= t; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            used_positions.insert({x, y});\n            grid[x][y] = '0' + i;\n        }\n\n        // Randomly place bombs 'B'\n        for (int i = 0; i < b; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            used_positions.insert({x, y});\n            grid[x][y] = 'B';\n        }\n\n        // Randomly place obstacles '#'\n        int remaining_cells = n * m - (int)used_positions.size() - 1;\n        int num_obstacles = rnd.next(0, min(remaining_cells, max(remaining_cells / 10, 5)));\n        for (int i = 0; i < num_obstacles; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            used_positions.insert({x, y});\n            grid[x][y] = '#';\n        }\n\n        // Place 'S' in a random empty cell\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, m - 1);\n        } while (used_positions.count({x, y}));\n        grid[x][y] = 'S';\n        used_positions.insert({x, y});\n\n        // Output grid\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n        // Output treasure values\n        for (int i = 1; i <= t; ++i) {\n            int v = rnd.next(-200, 200);\n            printf(\"%d\\n\", v);\n        }\n\n    } else if (type == \"maximal\") {\n        // Maximal test case\n        n = 20;\n        m = 20;\n        int t = 8; // Max treasures\n        int b = 0; // No bombs\n\n        vector<string> grid(n, string(m, '.'));\n        set<pair<int, int>> used_positions;\n\n        // Fill half the grid with obstacles\n        int num_obstacles = n * m / 2;\n        for (int i = 0; i < num_obstacles; ++i) {\n            int x = i / m;\n            int y = i % m;\n            grid[x][y] = '#';\n            used_positions.insert({x, y});\n        }\n\n        // Place treasures\n        for (int i = 1; i <= t; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (grid[x][y] != '.');\n            grid[x][y] = '0' + i;\n            used_positions.insert({x, y});\n        }\n\n        // Place 'S'\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, m - 1);\n        } while (grid[x][y] != '.');\n        grid[x][y] = 'S';\n        used_positions.insert({x, y});\n\n        // Output grid\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n        // Output treasure values (max value 200)\n        for (int i = 1; i <= t; ++i) {\n            printf(\"200\\n\");\n        }\n\n    } else if (type == \"minimal\") {\n        // Minimal test case\n        n = 1;\n        m = 1;\n        printf(\"%d %d\\n\", n, m);\n        printf(\"S\\n\");\n        // No treasures or bombs\n\n    } else if (type == \"impossible\") {\n        // Impossible test case\n        vector<string> grid(n, string(m, '#'));\n        int x = n / 2;\n        int y = m / 2;\n        grid[x][y] = 'S';\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n    } else if (type == \"negative\") {\n        // Negative treasure values\n        int max_objects = 8;\n        int t = rnd.next(1, max_objects); // number of treasures\n        int b = rnd.next(0, max_objects - t); // number of bombs\n\n        vector<string> grid(n, string(m, '.'));\n        set<pair<int, int>> used_positions;\n\n        // Place treasures\n        for (int i = 1; i <= t; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            grid[x][y] = '0' + i;\n            used_positions.insert({x, y});\n        }\n\n        // Place bombs\n        for (int i = 0; i < b; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used_positions.count({x, y}));\n            grid[x][y] = 'B';\n            used_positions.insert({x, y});\n        }\n\n        // Place 'S'\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, m - 1);\n        } while (used_positions.count({x, y}));\n        grid[x][y] = 'S';\n        used_positions.insert({x, y});\n\n        // Output grid\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n\n        // Output negative treasure values\n        for (int i = 1; i <= t; ++i) {\n            int v = rnd.next(-200, -1);\n            printf(\"%d\\n\", v);\n        }\n\n    } else if (type == \"self_intersection\") {\n        // Self-intersection required\n        n = 5;\n        m = 5;\n        vector<string> grid = {\n            \".....\",\n            \".S#1.\",\n            \".#.#.\",\n            \".2#..\",\n            \".....\"\n        };\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n        printf(\"100\\n\");\n        printf(\"100\\n\");\n\n    } else if (type == \"edge_case\") {\n        // Edge case for point-in-polygon\n        n = 5;\n        m = 5;\n        vector<string> grid = {\n            \"1....\",\n            \".#.#.\",\n            \"..S..\",\n            \".#.#.\",\n            \"....2\"\n        };\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n        printf(\"100\\n\");\n        printf(\"100\\n\");\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s. Using random.\\n\", type.c_str());\n        // Default to random\n        // (Omitted code duplication for brevity)\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type minimal\n./gen -n 20 -m 20 -type maximal\n./gen -n 5 -m 5 -type impossible\n./gen -n 10 -m 10 -type negative\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 15 -m 15 -type random\n./gen -n 20 -m 20 -type random\n./gen -n 20 -m 20 -type random\n./gen -n 10 -m 10 -type self_intersection\n./gen -n 5 -m 5 -type edge_case\n./gen -n 5 -m 5 -type self_intersection\n./gen -n 7 -m 7 -type negative\n./gen -n 7 -m 7 -type impossible\n./gen -n 5 -m 5 -type minimal\n./gen -n 20 -m 20 -type maximal\n./gen -n 20 -m 20 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 20 -m 15 -type random\n./gen -n 15 -m 20 -type random\n./gen -n 1 -m 1 -type minimal\n./gen -n 5 -m 5 -type impossible\n./gen -n 5 -m 5 -type negative\n./gen -n 5 -m 5 -type edge_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:03.693025",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "375/D",
      "title": "D. Tree and Queries",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n ≤ 105; 1 ≤ m ≤ 105). The next line contains a sequence of integers c1, c2, ..., cn (1 ≤ ci ≤ 105). The next n - 1 lines contain the edges of the tree. The i-th line contains the numbers ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — the vertices connected by an edge of the tree.Next m lines contain the queries. The j-th line contains two integers vj, kj (1 ≤ vj ≤ n; 1 ≤ kj ≤ 105).",
      "output_spec": "OutputPrint m integers — the answers to the queries in the order the queries appear in the input.",
      "sample_tests": "ExamplesInputCopy8 51 2 2 3 3 2 3 31 21 52 32 45 65 75 81 21 31 42 35 3OutputCopy22101InputCopy4 11 2 3 41 22 33 41 1OutputCopy4",
      "description": "D. Tree and Queries\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n ≤ 105; 1 ≤ m ≤ 105). The next line contains a sequence of integers c1, c2, ..., cn (1 ≤ ci ≤ 105). The next n - 1 lines contain the edges of the tree. The i-th line contains the numbers ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — the vertices connected by an edge of the tree.Next m lines contain the queries. The j-th line contains two integers vj, kj (1 ≤ vj ≤ n; 1 ≤ kj ≤ 105).\n\nOutputPrint m integers — the answers to the queries in the order the queries appear in the input.\n\nInputCopy8 51 2 2 3 3 2 3 31 21 52 32 45 65 75 81 21 31 42 35 3OutputCopy22101InputCopy4 11 2 3 41 22 33 41 1OutputCopy4\n\nInputCopy8 51 2 2 3 3 2 3 31 21 52 32 45 65 75 81 21 31 42 35 3\n\nOutputCopy22101\n\nInputCopy4 11 2 3 41 22 33 41 1\n\nOutputCopy4\n\nNoteA subtree of vertex v in a rooted tree with root r is a set of vertices {u : dist(r, v) + dist(v, u) = dist(r, u)}. Where dist(x, y) is the length (in edges) of the shortest path between vertices x and y.",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 375\\s*D"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n + 1);\n        for (int i = 1; i <= n; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x)\n            return parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return false;\n        parent[x] = y;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    DSU dsu(n);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n);\n        inf.readSpace();\n        int b = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a vertex to itself.\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between %d and %d.\", u, v);\n        edges.insert({u, v});\n\n        ensuref(dsu.unite(a, b), \"Adding edge between %d and %d creates a cycle.\", a, b);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int vj = inf.readInt(1, n);\n        inf.readSpace();\n        int kj = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n + 1);\n        for (int i = 1; i <= n; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x)\n            return parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return false;\n        parent[x] = y;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    DSU dsu(n);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n);\n        inf.readSpace();\n        int b = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a vertex to itself.\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between %d and %d.\", u, v);\n        edges.insert({u, v});\n\n        ensuref(dsu.unite(a, b), \"Adding edge between %d and %d creates a cycle.\", a, b);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int vj = inf.readInt(1, n);\n        inf.readSpace();\n        int kj = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n + 1);\n        for (int i = 1; i <= n; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x)\n            return parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return false;\n        parent[x] = y;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    DSU dsu(n);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n);\n        inf.readSpace();\n        int b = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a vertex to itself.\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between %d and %d.\", u, v);\n        edges.insert({u, v});\n\n        ensuref(dsu.unite(a, b), \"Adding edge between %d and %d creates a cycle.\", a, b);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int vj = inf.readInt(1, n);\n        inf.readSpace();\n        int kj = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    \n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string color_type = opt<string>(\"color_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    int max_c = opt<int>(\"max_c\", 100000);\n    int k = opt<int>(\"k\", 2); // For k-ary trees or patterns\n\n    // Enforce constraints\n    n = max(2, min(n, (int)1e5));\n    m = max(1, min(m, (int)1e5));\n    max_c = max(1, min(max_c, (int)1e5));\n\n    vector<int> parent(n + 1); // parent[1..n], parent[1] = -1 for root\n    parent[1] = -1; // root has no parent\n\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        for (int i = 2; i <= n; ++i) {\n            if (rnd.next(0, 1) == 0 && i > 2) {\n                parent[i] = parent[i - 1];\n            } else {\n                parent[i] = i - 1;\n            }\n        }\n    } else if (tree_type == \"complete_kary\") {\n        // Complete k-ary tree\n        int curr = 2;\n        for (int i = 1; i <= n && curr <= n; ++i) {\n            for (int j = 0; j < k && curr <= n; ++j) {\n                parent[curr++] = i;\n            }\n        }\n    } else {\n        // random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1); // parent is any node from 1 to i-1\n        }\n    }\n\n    // Shuffle the nodes\n    vector<int> perm(n + 1); // perm[1..n], mapping from old node to new node\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end()); // Nodes numbered from 1 to n\n\n    // Adjust the parent array\n    vector<int> new_parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        if (parent[i] == -1) {\n            new_parent[perm[i]] = -1;\n        } else {\n            new_parent[perm[i]] = perm[parent[i]];\n        }\n    }\n\n    // Generate colors\n    vector<int> color(n + 1);\n\n    if (color_type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = rnd.next(1, max_c);\n        }\n    } else if (color_type == \"single_color\") {\n        int c = rnd.next(1, max_c);\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = c;\n        }\n    } else if (color_type == \"max_colors\") {\n        int use_max_c = min(n, max_c);\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = (i <= use_max_c) ? i : rnd.next(1, use_max_c);\n        }\n    } else if (color_type == \"repeating_pattern\") {\n        int total_colors = min(k, max_c);\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = ((i - 1) % total_colors) + 1;\n        }\n    } else {\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = rnd.next(1, max_c);\n        }\n    }\n\n    // Generate edges\n    vector<pair<int, int>> edges;\n\n    for (int i = 1; i <= n; ++i) {\n        if (new_parent[i] != -1) {\n            edges.emplace_back(i, new_parent[i]);\n        }\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    // Generate m queries\n    vector<pair<int, int>> queries(m);\n\n    for (int i = 0; i < m; ++i) {\n        int vj, kj;\n        if (query_type == \"random\") {\n            vj = rnd.next(1, n);\n            kj = rnd.next(1, min(n, 100000));\n        } else if (query_type == \"all_same\") {\n            if (i == 0) {\n                vj = rnd.next(1, n);\n                kj = rnd.next(1, min(n, 100000));\n            }\n            queries[i] = make_pair(vj, kj);\n            continue;\n        } else if (query_type == \"edge_cases\") {\n            int type = rnd.next(1, 3);\n            if (type == 1) {\n                vj = 1; // root\n            } else if (type == 2) {\n                vj = perm[n]; // leaf node\n            } else {\n                vj = rnd.next(1, n);\n            }\n            if (rnd.next(0, 1) == 0) {\n                kj = 1;\n            } else {\n                kj = min(n, 100000);\n            }\n        } else if (query_type == \"heavy\") {\n            vj = 1; // root\n            kj = rnd.next(1, 5); // small kj\n        } else {\n            vj = rnd.next(1, n);\n            kj = rnd.next(1, min(n, 100000));\n        }\n        queries[i] = make_pair(vj, kj);\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", color[i]);\n        if (i < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    \n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string color_type = opt<string>(\"color_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    int max_c = opt<int>(\"max_c\", 100000);\n    int k = opt<int>(\"k\", 2); // For k-ary trees or patterns\n\n    // Enforce constraints\n    n = max(2, min(n, (int)1e5));\n    m = max(1, min(m, (int)1e5));\n    max_c = max(1, min(max_c, (int)1e5));\n\n    vector<int> parent(n + 1); // parent[1..n], parent[1] = -1 for root\n    parent[1] = -1; // root has no parent\n\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree\n        for (int i = 2; i <= n; ++i) {\n            if (rnd.next(0, 1) == 0 && i > 2) {\n                parent[i] = parent[i - 1];\n            } else {\n                parent[i] = i - 1;\n            }\n        }\n    } else if (tree_type == \"complete_kary\") {\n        // Complete k-ary tree\n        int curr = 2;\n        for (int i = 1; i <= n && curr <= n; ++i) {\n            for (int j = 0; j < k && curr <= n; ++j) {\n                parent[curr++] = i;\n            }\n        }\n    } else {\n        // random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1); // parent is any node from 1 to i-1\n        }\n    }\n\n    // Shuffle the nodes\n    vector<int> perm(n + 1); // perm[1..n], mapping from old node to new node\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end()); // Nodes numbered from 1 to n\n\n    // Adjust the parent array\n    vector<int> new_parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        if (parent[i] == -1) {\n            new_parent[perm[i]] = -1;\n        } else {\n            new_parent[perm[i]] = perm[parent[i]];\n        }\n    }\n\n    // Generate colors\n    vector<int> color(n + 1);\n\n    if (color_type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = rnd.next(1, max_c);\n        }\n    } else if (color_type == \"single_color\") {\n        int c = rnd.next(1, max_c);\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = c;\n        }\n    } else if (color_type == \"max_colors\") {\n        int use_max_c = min(n, max_c);\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = (i <= use_max_c) ? i : rnd.next(1, use_max_c);\n        }\n    } else if (color_type == \"repeating_pattern\") {\n        int total_colors = min(k, max_c);\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = ((i - 1) % total_colors) + 1;\n        }\n    } else {\n        for (int i = 1; i <= n; ++i) {\n            color[perm[i]] = rnd.next(1, max_c);\n        }\n    }\n\n    // Generate edges\n    vector<pair<int, int>> edges;\n\n    for (int i = 1; i <= n; ++i) {\n        if (new_parent[i] != -1) {\n            edges.emplace_back(i, new_parent[i]);\n        }\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    // Generate m queries\n    vector<pair<int, int>> queries(m);\n\n    for (int i = 0; i < m; ++i) {\n        int vj, kj;\n        if (query_type == \"random\") {\n            vj = rnd.next(1, n);\n            kj = rnd.next(1, min(n, 100000));\n        } else if (query_type == \"all_same\") {\n            if (i == 0) {\n                vj = rnd.next(1, n);\n                kj = rnd.next(1, min(n, 100000));\n            }\n            queries[i] = make_pair(vj, kj);\n            continue;\n        } else if (query_type == \"edge_cases\") {\n            int type = rnd.next(1, 3);\n            if (type == 1) {\n                vj = 1; // root\n            } else if (type == 2) {\n                vj = perm[n]; // leaf node\n            } else {\n                vj = rnd.next(1, n);\n            }\n            if (rnd.next(0, 1) == 0) {\n                kj = 1;\n            } else {\n                kj = min(n, 100000);\n            }\n        } else if (query_type == \"heavy\") {\n            vj = 1; // root\n            kj = rnd.next(1, 5); // small kj\n        } else {\n            vj = rnd.next(1, n);\n            kj = rnd.next(1, min(n, 100000));\n        }\n        queries[i] = make_pair(vj, kj);\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", color[i]);\n        if (i < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -tree_type chain -color_type single_color -query_type edge_cases\n./gen -n 10 -m 5 -tree_type chain -color_type random -query_type random\n./gen -n 10 -m 5 -tree_type star -color_type random -query_type random\n./gen -n 10 -m 5 -tree_type random -color_type random -query_type random\n./gen -n 1000 -m 1000 -tree_type chain -color_type repeating_pattern -k 10 -query_type random\n./gen -n 1000 -m 1000 -tree_type star -color_type repeating_pattern -k 10 -query_type random\n./gen -n 1000 -m 1000 -tree_type random -color_type repeating_pattern -k 10 -query_type random\n./gen -n 1000 -m 1000 -tree_type complete_kary -k 2 -color_type random -query_type random\n./gen -n 1000 -m 1000 -tree_type complete_kary -k 3 -color_type random -query_type random\n./gen -n 1000 -m 1000 -tree_type skewed -color_type random -query_type random\n./gen -n 100000 -m 100000 -tree_type chain -color_type random -query_type heavy\n./gen -n 100000 -m 100000 -tree_type star -color_type random -query_type heavy\n./gen -n 100000 -m 100000 -tree_type random -color_type random -query_type heavy\n./gen -n 100000 -m 100000 -tree_type skewed -color_type repeating_pattern -k 5 -query_type edge_cases\n./gen -n 100000 -m 100000 -tree_type complete_kary -k 2 -color_type random -query_type random\n./gen -n 100000 -m 100000 -tree_type complete_kary -k 3 -color_type random -query_type random\n./gen -n 100000 -m 100000 -tree_type random -color_type single_color -query_type heavy\n./gen -n 100000 -m 100000 -tree_type chain -color_type max_colors -query_type random\n./gen -n 50 -m 1000 -tree_type skewed -color_type repeating_pattern -k 3 -query_type random\n./gen -n 100000 -m 100000 -tree_type random -color_type random -max_c 100 -query_type random\n./gen -n 100000 -m 100000 -tree_type random -color_type random -max_c 100000 -query_type random\n./gen -n 100000 -m 100000 -tree_type random -color_type random -query_type edge_cases\n./gen -n 100000 -m 100000 -tree_type random -color_type random -query_type all_same\n./gen -n 2 -m 100000 -tree_type chain -color_type random -query_type random\n./gen -n 100000 -m 100000 -tree_type chain -color_type single_color -query_type all_same\n./gen -n 100000 -m 100000 -tree_type star -color_type max_colors -query_type random\n./gen -n 100000 -m 100000 -tree_type complete_kary -k 4 -color_type random -query_type random\n./gen -n 100000 -m 100000 -tree_type skewed -color_type max_colors -query_type random\n./gen -n 100000 -m 100000 -tree_type random -color_type random -query_type heavy\n./gen -n 100000 -m 100000 -tree_type chain -color_type repeating_pattern -k 1000 -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:05.760286",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "375/E",
      "title": "E. Red and Black Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and x (2 ≤ n ≤ 500; 1 ≤ x ≤ 109). The next line contains n integers, each of them is either a zero or one. If the i-th number equals 1, then vertex i of the tree is black, otherwise vertex i is red. Next n - 1 lines contain the tree edges. The j-th line contains integers uj vj wj (1 ≤ uj, vj ≤ n; uj ≠ vj; 1 ≤ wj ≤ 109) which means that the tree has an edge of weight wj between vertices vj and uj.Assume that the tree vertices are numbered from 1 to n.",
      "output_spec": "OutputPrint a single integer — the minimum number of required swap operations.If it is impossible to get a beautiful tree at any number of operations, print -1.",
      "sample_tests": "ExamplesInputCopy3 21 0 01 2 22 3 2OutputCopy1InputCopy4 20 1 0 01 2 22 3 23 4 2OutputCopy-1",
      "description": "E. Red and Black Tree\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and x (2 ≤ n ≤ 500; 1 ≤ x ≤ 109). The next line contains n integers, each of them is either a zero or one. If the i-th number equals 1, then vertex i of the tree is black, otherwise vertex i is red. Next n - 1 lines contain the tree edges. The j-th line contains integers uj vj wj (1 ≤ uj, vj ≤ n; uj ≠ vj; 1 ≤ wj ≤ 109) which means that the tree has an edge of weight wj between vertices vj and uj.Assume that the tree vertices are numbered from 1 to n.\n\nOutputPrint a single integer — the minimum number of required swap operations.If it is impossible to get a beautiful tree at any number of operations, print -1.\n\nInputCopy3 21 0 01 2 22 3 2OutputCopy1InputCopy4 20 1 0 01 2 22 3 23 4 2OutputCopy-1\n\nInputCopy3 21 0 01 2 22 3 2\n\nOutputCopy1\n\nInputCopy4 20 1 0 01 2 22 3 23 4 2\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 375\\s*E"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 500;\nconst int MAX_X = 1000000000;\nconst int MAX_W = 1000000000;\n\nint parent[501];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAX_N, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, MAX_X, \"x\");\n    inf.readEoln();\n\n    vector<int> colors = inf.readInts(n, 0, 1, \"colors\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int w = inf.readInt(1, MAX_W, \"w\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node with itself\", i + 1);\n\n        int pu = find(u);\n        int pv = find(v);\n\n        ensuref(pu != pv, \"Edge %d creates a cycle\", i + 1);\n\n        parent[pu] = pv;\n    }\n\n    set<int> components;\n    for (int i = 1; i <= n; ++i) {\n        components.insert(find(i));\n    }\n    ensuref(components.size() == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 500;\nconst int MAX_X = 1000000000;\nconst int MAX_W = 1000000000;\n\nint parent[501];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAX_N, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, MAX_X, \"x\");\n    inf.readEoln();\n\n    vector<int> colors = inf.readInts(n, 0, 1, \"colors\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int w = inf.readInt(1, MAX_W, \"w\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node with itself\", i + 1);\n\n        int pu = find(u);\n        int pv = find(v);\n\n        ensuref(pu != pv, \"Edge %d creates a cycle\", i + 1);\n\n        parent[pu] = pv;\n    }\n\n    set<int> components;\n    for (int i = 1; i <= n; ++i) {\n        components.insert(find(i));\n    }\n    ensuref(components.size() == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 500;\nconst int MAX_X = 1000000000;\nconst int MAX_W = 1000000000;\n\nint parent[501];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAX_N, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, MAX_X, \"x\");\n    inf.readEoln();\n\n    vector<int> colors = inf.readInts(n, 0, 1, \"colors\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int w = inf.readInt(1, MAX_W, \"w\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node with itself\", i + 1);\n\n        int pu = find(u);\n        int pv = find(v);\n\n        ensuref(pu != pv, \"Edge %d creates a cycle\", i + 1);\n\n        parent[pu] = pv;\n    }\n\n    set<int> components;\n    for (int i = 1; i <= n; ++i) {\n        components.insert(find(i));\n    }\n    ensuref(components.size() == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_tree(int n, string type, vector<pair<int,int>>& edges) {\n  if (type == \"chain\") {\n    for (int i = 2; i <= n; ++i) {\n      edges.push_back({i-1, i});\n    }\n  } else if (type == \"star\") {\n    for (int i = 2; i <= n; ++i) {\n      edges.push_back({1, i});\n    }\n  } else if (type == \"binary\") {\n    for (int i = 2; i <= n; ++i) {\n      edges.push_back({i/2, i});\n    }\n  } else if (type == \"random\") {\n    for (int i = 2; i <= n; ++i) {\n      int u = rnd.next(1, i - 1);\n      int v = i;\n      edges.push_back({u, v});\n    }\n  } else {\n    // Default to random\n    for (int i = 2; i <= n; ++i) {\n      int u = rnd.next(1, i - 1);\n      int v = i;\n      edges.push_back({u, v});\n    }\n  }\n}\n\nvoid assign_colors(int n, string color_pattern, vector<int>& colors) {\n  colors.resize(n+1);\n  if (color_pattern == \"all_black\") {\n    for (int i = 1; i <= n; ++i)\n      colors[i] = 1;\n  } else if (color_pattern == \"all_red\") {\n    for (int i = 1; i <= n; ++i)\n      colors[i] = 0;\n  } else if (color_pattern == \"random\") {\n    for (int i = 1; i <= n; ++i) {\n      colors[i] = rnd.next(0, 1);\n    }\n  } else if (color_pattern == \"alternate\") {\n    for (int i = 1; i <= n; ++i) {\n      colors[i] = i % 2;\n    }\n  } else if (color_pattern == \"half_red\") {\n    for (int i = 1; i <= n; ++i) {\n      if (i <= n / 2)\n        colors[i] = 0;\n      else\n        colors[i] = 1;\n    }\n  } else if (color_pattern == \"one_black\") {\n    int black_node = rnd.next(1, n);\n    for (int i = 1; i <= n; ++i) {\n        colors[i] = 0;\n    }\n    colors[black_node] = 1;\n  } else if (color_pattern == \"one_red\") {\n    int red_node = rnd.next(1, n);\n    for (int i = 1; i <= n; ++i) {\n        colors[i] = 1;\n    }\n    colors[red_node] = 0;\n  } else {\n    // Default to random\n    for (int i = 1; i <= n; ++i) {\n      colors[i] = rnd.next(0, 1);\n    }\n  }\n}\n\nvoid assign_weights(int m, string weight_pattern, vector<int>& weights) {\n  weights.resize(m);\n  if (weight_pattern == \"all_one\") {\n    for (int i = 0; i < m; ++i)\n      weights[i] = 1;\n  } else if (weight_pattern == \"random\") {\n    for (int i = 0; i < m; ++i) {\n      weights[i] = rnd.next(1, (int)1e9);\n    }\n  } else if (weight_pattern == \"max\") {\n    for (int i = 0; i < m; ++i)\n      weights[i] = 1000000000;\n  } else {\n    // Default to random\n    for (int i = 0; i < m; ++i) {\n      weights[i] = rnd.next(1, (int)1e9);\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n\n    string type = opt<string>(\"type\", \"random\");\n    string color_pattern = opt<string>(\"color\", \"random\");\n    string weight_pattern = opt<string>(\"weight\", \"random\");\n\n    vector<pair<int,int>> edges;\n    generate_tree(n, type, edges);\n\n    vector<int> colors; // index from 1 to n\n    assign_colors(n, color_pattern, colors);\n\n    vector<int> weights;\n    assign_weights(edges.size(), weight_pattern, weights);\n\n    // Generate permutation of node labels\n    vector<int> permutation(n + 1); // Indexing from 1\n    for (int i = 1; i <= n; ++i) {\n      permutation[i] = i;\n    }\n\n    shuffle(permutation.begin() + 1, permutation.end());\n\n    vector<int> permuted_colors(n + 1);\n    for (int i =1 ; i <= n; ++i) {\n      permuted_colors[permutation[i]] = colors[i];\n    }\n\n    colors = permuted_colors;\n\n    for (size_t i = 0; i < edges.size(); ++i) {\n      edges[i].first = permutation[edges[i].first];\n      edges[i].second = permutation[edges[i].second];\n    }\n\n    // Now assemble edges and weights into edge_list\n    vector<tuple<int,int,int>> edge_list;\n\n    for (size_t i = 0; i < edges.size(); ++i){\n        edge_list.push_back(make_tuple(edges[i].first, edges[i].second, weights[i]));\n    }\n\n    // Now shuffle edge_list\n    shuffle(edge_list.begin(), edge_list.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, x);\n    // Output the colors\n\n    for (int i = 1; i <= n; ++i) {\n      printf(\"%d\", colors[i]);\n      if (i != n)\n        printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output the edges and weights\n    for (auto& e : edge_list) {\n       int u, v, w;\n       tie(u, v, w) = e;\n       printf(\"%d %d %d\\n\", u, v, w);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_tree(int n, string type, vector<pair<int,int>>& edges) {\n  if (type == \"chain\") {\n    for (int i = 2; i <= n; ++i) {\n      edges.push_back({i-1, i});\n    }\n  } else if (type == \"star\") {\n    for (int i = 2; i <= n; ++i) {\n      edges.push_back({1, i});\n    }\n  } else if (type == \"binary\") {\n    for (int i = 2; i <= n; ++i) {\n      edges.push_back({i/2, i});\n    }\n  } else if (type == \"random\") {\n    for (int i = 2; i <= n; ++i) {\n      int u = rnd.next(1, i - 1);\n      int v = i;\n      edges.push_back({u, v});\n    }\n  } else {\n    // Default to random\n    for (int i = 2; i <= n; ++i) {\n      int u = rnd.next(1, i - 1);\n      int v = i;\n      edges.push_back({u, v});\n    }\n  }\n}\n\nvoid assign_colors(int n, string color_pattern, vector<int>& colors) {\n  colors.resize(n+1);\n  if (color_pattern == \"all_black\") {\n    for (int i = 1; i <= n; ++i)\n      colors[i] = 1;\n  } else if (color_pattern == \"all_red\") {\n    for (int i = 1; i <= n; ++i)\n      colors[i] = 0;\n  } else if (color_pattern == \"random\") {\n    for (int i = 1; i <= n; ++i) {\n      colors[i] = rnd.next(0, 1);\n    }\n  } else if (color_pattern == \"alternate\") {\n    for (int i = 1; i <= n; ++i) {\n      colors[i] = i % 2;\n    }\n  } else if (color_pattern == \"half_red\") {\n    for (int i = 1; i <= n; ++i) {\n      if (i <= n / 2)\n        colors[i] = 0;\n      else\n        colors[i] = 1;\n    }\n  } else if (color_pattern == \"one_black\") {\n    int black_node = rnd.next(1, n);\n    for (int i = 1; i <= n; ++i) {\n        colors[i] = 0;\n    }\n    colors[black_node] = 1;\n  } else if (color_pattern == \"one_red\") {\n    int red_node = rnd.next(1, n);\n    for (int i = 1; i <= n; ++i) {\n        colors[i] = 1;\n    }\n    colors[red_node] = 0;\n  } else {\n    // Default to random\n    for (int i = 1; i <= n; ++i) {\n      colors[i] = rnd.next(0, 1);\n    }\n  }\n}\n\nvoid assign_weights(int m, string weight_pattern, vector<int>& weights) {\n  weights.resize(m);\n  if (weight_pattern == \"all_one\") {\n    for (int i = 0; i < m; ++i)\n      weights[i] = 1;\n  } else if (weight_pattern == \"random\") {\n    for (int i = 0; i < m; ++i) {\n      weights[i] = rnd.next(1, (int)1e9);\n    }\n  } else if (weight_pattern == \"max\") {\n    for (int i = 0; i < m; ++i)\n      weights[i] = 1000000000;\n  } else {\n    // Default to random\n    for (int i = 0; i < m; ++i) {\n      weights[i] = rnd.next(1, (int)1e9);\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n\n    string type = opt<string>(\"type\", \"random\");\n    string color_pattern = opt<string>(\"color\", \"random\");\n    string weight_pattern = opt<string>(\"weight\", \"random\");\n\n    vector<pair<int,int>> edges;\n    generate_tree(n, type, edges);\n\n    vector<int> colors; // index from 1 to n\n    assign_colors(n, color_pattern, colors);\n\n    vector<int> weights;\n    assign_weights(edges.size(), weight_pattern, weights);\n\n    // Generate permutation of node labels\n    vector<int> permutation(n + 1); // Indexing from 1\n    for (int i = 1; i <= n; ++i) {\n      permutation[i] = i;\n    }\n\n    shuffle(permutation.begin() + 1, permutation.end());\n\n    vector<int> permuted_colors(n + 1);\n    for (int i =1 ; i <= n; ++i) {\n      permuted_colors[permutation[i]] = colors[i];\n    }\n\n    colors = permuted_colors;\n\n    for (size_t i = 0; i < edges.size(); ++i) {\n      edges[i].first = permutation[edges[i].first];\n      edges[i].second = permutation[edges[i].second];\n    }\n\n    // Now assemble edges and weights into edge_list\n    vector<tuple<int,int,int>> edge_list;\n\n    for (size_t i = 0; i < edges.size(); ++i){\n        edge_list.push_back(make_tuple(edges[i].first, edges[i].second, weights[i]));\n    }\n\n    // Now shuffle edge_list\n    shuffle(edge_list.begin(), edge_list.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, x);\n    // Output the colors\n\n    for (int i = 1; i <= n; ++i) {\n      printf(\"%d\", colors[i]);\n      if (i != n)\n        printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output the edges and weights\n    for (auto& e : edge_list) {\n       int u, v, w;\n       tie(u, v, w) = e;\n       printf(\"%d %d %d\\n\", u, v, w);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test case\n./gen -n 2 -x 1 -type chain -color all_black -weight all_one\n\n# Small n, small x, chain, all_black, all_one\n./gen -n 5 -x 2 -type chain -color all_black -weight all_one\n\n# Small n, small x, star, all_red, random weights\n./gen -n 5 -x 2 -type star -color all_red -weight random\n\n# Medium n, medium x, binary, half_red, max weights\n./gen -n 250 -x 500000000 -type binary -color half_red -weight max\n\n# Maximum n, maximum x, random tree, random colors, random weights\n./gen -n 500 -x 1000000000 -type random -color random -weight random\n\n# n = 500, x = 1, chain, alternate colors, random weights\n./gen -n 500 -x 1 -type chain -color alternate -weight random\n\n# x = 1e9, weights all_one, star tree, colors all_black\n./gen -n 500 -x 1000000000 -type star -color all_black -weight all_one\n\n# x = 1, weights max, star tree, colors all_red\n./gen -n 500 -x 1 -type star -color all_red -weight max\n\n# Tree where it's impossible to make it beautiful (all red nodes)\n./gen -n 500 -x 1 -type chain -color all_red -weight all_one\n\n# Tree where it's already beautiful (all black nodes)\n./gen -n 500 -x 1000000000 -type random -color all_black -weight random\n\n# Tree where minimal swaps are needed\n./gen -n 500 -x 10 -type random -color random -weight random\n\n# Tree with one black node, rest red\n./gen -n 500 -x 1000000000 -type random -color one_black -weight random\n\n# Tree with one red node, rest black\n./gen -n 500 -x 10 -type random -color one_red -weight random\n\n# x is minimal, weights are maximal\n./gen -n 500 -x 1 -type random -color random -weight max\n\n# x is maximal, weights are minimal\n./gen -n 500 -x 1000000000 -type random -color random -weight all_one\n\n# n is minimal, x is maximal\n./gen -n 2 -x 1000000000 -type chain -color alternate -weight random\n\n# Tree where distances to black nodes exceed x\n./gen -n 500 -x 1 -type chain -color one_black -weight random\n\n# Tree where distances to black nodes are within x\n./gen -n 500 -x 1000000000 -type chain -color one_black -weight random\n\n# Tree where it's possible to make beautiful by swapping\n./gen -n 500 -x 100000 -type chain -color half_red -weight random\n\n# Tree with alternating colors, x large\n./gen -n 500 -x 1000000000 -type random -color alternate -weight random\n\n# Tree with constant edge weights\n./gen -n 500 -x 500000 -type random -color random -weight all_one\n\n# Tree with random edge weights\n./gen -n 500 -x 500000 -type random -color random -weight random\n\n# Tree where all nodes are at distance x from black node\n./gen -n 500 -x 1 -type star -color one_black -weight all_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:08.127127",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "376/A",
      "title": "A. Lever",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the lever description as a non-empty string s (3 ≤ |s| ≤ 106), consisting of digits (1-9) and characters \"^\" and \"=\". It is guaranteed that the line contains exactly one character \"^\". It is guaranteed that the pivot of the lever isn't located in any end of the lever bar.To solve the problem you may need 64-bit integer numbers. Please, do not forget to use them in your programs.",
      "output_spec": "OutputPrint \"left\" if the given lever tilts to the left, \"right\" if it tilts to the right and \"balance\", if it is in balance.",
      "sample_tests": "ExamplesInputCopy=^==OutputCopybalanceInputCopy9===^==1OutputCopyleftInputCopy2==^7==OutputCopyrightInputCopy41^52==OutputCopybalance",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the lever description as a non-empty string s (3 ≤ |s| ≤ 106), consisting of digits (1-9) and characters \"^\" and \"=\". It is guaranteed that the line contains exactly one character \"^\". It is guaranteed that the pivot of the lever isn't located in any end of the lever bar.To solve the problem you may need 64-bit integer numbers. Please, do not forget to use them in your programs.\n\nOutputPrint \"left\" if the given lever tilts to the left, \"right\" if it tilts to the right and \"balance\", if it is in balance.\n\nInputCopy=^==OutputCopybalanceInputCopy9===^==1OutputCopyleftInputCopy2==^7==OutputCopyrightInputCopy41^52==OutputCopybalance\n\nInputCopy=^==\n\nOutputCopybalance\n\nInputCopy9===^==1\n\nOutputCopyleft\n\nInputCopy2==^7==\n\nOutputCopyright\n\nInputCopy41^52==\n\nOutputCopybalance\n\nNoteAs you solve the problem, you may find the following link useful to better understand how a lever functions: http://en.wikipedia.org/wiki/Lever.The pictures to the examples:",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 376\\s*A"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(s.size() >= 3 && s.size() <= 1000000, \n        \"String length must be between 3 and 1000000 inclusive, but found %d\", (int)s.size());\n\n    int num_caret = 0;\n    int caret_pos = -1;\n    for (int i = 0; i < (int)s.size(); i++) {\n        char c = s[i];\n        ensuref((c >= '1' && c <= '9') || c == '=' || c == '^', \n                \"Invalid character '%c' at position %d\", c, i+1);\n        if (c == '^') {\n            num_caret++;\n            caret_pos = i;\n        }\n    }\n    ensuref(num_caret == 1, \"There must be exactly one '^' character\");\n    ensuref(caret_pos != 0 && caret_pos != (int)s.size()-1,\n            \"The '^' character must not be at the first or last position, but found at position %d\", caret_pos+1);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(s.size() >= 3 && s.size() <= 1000000, \n        \"String length must be between 3 and 1000000 inclusive, but found %d\", (int)s.size());\n\n    int num_caret = 0;\n    int caret_pos = -1;\n    for (int i = 0; i < (int)s.size(); i++) {\n        char c = s[i];\n        ensuref((c >= '1' && c <= '9') || c == '=' || c == '^', \n                \"Invalid character '%c' at position %d\", c, i+1);\n        if (c == '^') {\n            num_caret++;\n            caret_pos = i;\n        }\n    }\n    ensuref(num_caret == 1, \"There must be exactly one '^' character\");\n    ensuref(caret_pos != 0 && caret_pos != (int)s.size()-1,\n            \"The '^' character must not be at the first or last position, but found at position %d\", caret_pos+1);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(s.size() >= 3 && s.size() <= 1000000, \n        \"String length must be between 3 and 1000000 inclusive, but found %d\", (int)s.size());\n\n    int num_caret = 0;\n    int caret_pos = -1;\n    for (int i = 0; i < (int)s.size(); i++) {\n        char c = s[i];\n        ensuref((c >= '1' && c <= '9') || c == '=' || c == '^', \n                \"Invalid character '%c' at position %d\", c, i+1);\n        if (c == '^') {\n            num_caret++;\n            caret_pos = i;\n        }\n    }\n    ensuref(num_caret == 1, \"There must be exactly one '^' character\");\n    ensuref(caret_pos != 0 && caret_pos != (int)s.size()-1,\n            \"The '^' character must not be at the first or last position, but found at position %d\", caret_pos+1);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<char> s(n, '=');\n    \n    int pivot_pos = rnd.next(1, n - 2); // Pivot not at ends\n    s[pivot_pos] = '^';\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            if (i == pivot_pos) continue;\n            // Randomly decide whether to put a mass or '='\n            if (rnd.next(0, 1) == 0) {\n                s[i] = '=';\n            } else {\n                s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n            }\n        }\n    } else if (type == \"left\") {\n        for(int i = 0; i < pivot_pos; ++i) {\n            s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '='; // No masses on the right\n        }\n    } else if (type == \"right\") {\n        for(int i = 0; i < pivot_pos; ++i) {\n            s[i] = '='; // No masses on the left\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n        }\n    } else if (type == \"balance\") {\n        // Place masses symmetrically around the pivot\n        int left = pivot_pos - 1, right = pivot_pos + 1;\n        while(left >= 0 && right < n) {\n            char mass = '1' + rnd.next(0, 8);\n            s[left] = mass;\n            s[right] = mass;\n            left--;\n            right++;\n        }\n        // For remaining positions, fill with '='\n        while(left >= 0) {\n            s[left--] = '=';\n        }\n        while(right < n) {\n            s[right++] = '=';\n        }\n    } else if (type == \"max_left_torque\") {\n        for(int i = 0; i < pivot_pos; ++i){\n            s[i] = '9'; // Max mass\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '='; // No masses on the right\n        }\n    } else if (type == \"max_right_torque\") {\n        for(int i = 0; i < pivot_pos; ++i){\n            s[i] = '='; // No masses on the left\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '9'; // Max mass\n        }\n    } else if (type == \"zero_weights\") {\n        // All positions are '=', except the pivot\n        // s is initialized with '=' already\n    } else if (type == \"single_mass_left\") {\n        // Place mass at leftmost position\n        if (pivot_pos != 0)\n            s[0] = '9';\n        else\n            s[1] = '9'; // Ensure not to overwrite the pivot\n    } else if (type == \"single_mass_right\") {\n        // Place mass at rightmost position (but not where pivot is)\n        if (pivot_pos != n - 1)\n            s[n - 1] = '9';\n        else\n            s[n - 2] = '9'; // Ensure not to overwrite the pivot\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            if (i == pivot_pos) continue;\n            if (i % 2 == 0)\n                s[i] = '1' + rnd.next(0, 8); // Random digit\n            else\n                s[i] = '=';\n        }\n    } else if (type == \"heavy_at_ends\") {\n        if (pivot_pos != 0)\n            s[0] = '9';\n        else\n            s[1] = '9'; // Ensure not to overwrite the pivot\n        if (pivot_pos != n - 1)\n            s[n - 1] = '9';\n        else\n            s[n - 2] = '9'; // Ensure not to overwrite the pivot\n        for(int i = 1; i < n - 1; ++i) {\n            if (i == pivot_pos) continue;\n            s[i] = '='; // No masses elsewhere\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            if (i == pivot_pos) continue;\n            if (rnd.next(0, 1) == 0) {\n                s[i] = '=';\n            } else {\n                s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n            }\n        }\n    }\n\n    // Output the string\n    for(char c : s) {\n        printf(\"%c\", c);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<char> s(n, '=');\n    \n    int pivot_pos = rnd.next(1, n - 2); // Pivot not at ends\n    s[pivot_pos] = '^';\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            if (i == pivot_pos) continue;\n            // Randomly decide whether to put a mass or '='\n            if (rnd.next(0, 1) == 0) {\n                s[i] = '=';\n            } else {\n                s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n            }\n        }\n    } else if (type == \"left\") {\n        for(int i = 0; i < pivot_pos; ++i) {\n            s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '='; // No masses on the right\n        }\n    } else if (type == \"right\") {\n        for(int i = 0; i < pivot_pos; ++i) {\n            s[i] = '='; // No masses on the left\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n        }\n    } else if (type == \"balance\") {\n        // Place masses symmetrically around the pivot\n        int left = pivot_pos - 1, right = pivot_pos + 1;\n        while(left >= 0 && right < n) {\n            char mass = '1' + rnd.next(0, 8);\n            s[left] = mass;\n            s[right] = mass;\n            left--;\n            right++;\n        }\n        // For remaining positions, fill with '='\n        while(left >= 0) {\n            s[left--] = '=';\n        }\n        while(right < n) {\n            s[right++] = '=';\n        }\n    } else if (type == \"max_left_torque\") {\n        for(int i = 0; i < pivot_pos; ++i){\n            s[i] = '9'; // Max mass\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '='; // No masses on the right\n        }\n    } else if (type == \"max_right_torque\") {\n        for(int i = 0; i < pivot_pos; ++i){\n            s[i] = '='; // No masses on the left\n        }\n        for(int i = pivot_pos + 1; i < n; ++i){\n            s[i] = '9'; // Max mass\n        }\n    } else if (type == \"zero_weights\") {\n        // All positions are '=', except the pivot\n        // s is initialized with '=' already\n    } else if (type == \"single_mass_left\") {\n        // Place mass at leftmost position\n        if (pivot_pos != 0)\n            s[0] = '9';\n        else\n            s[1] = '9'; // Ensure not to overwrite the pivot\n    } else if (type == \"single_mass_right\") {\n        // Place mass at rightmost position (but not where pivot is)\n        if (pivot_pos != n - 1)\n            s[n - 1] = '9';\n        else\n            s[n - 2] = '9'; // Ensure not to overwrite the pivot\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            if (i == pivot_pos) continue;\n            if (i % 2 == 0)\n                s[i] = '1' + rnd.next(0, 8); // Random digit\n            else\n                s[i] = '=';\n        }\n    } else if (type == \"heavy_at_ends\") {\n        if (pivot_pos != 0)\n            s[0] = '9';\n        else\n            s[1] = '9'; // Ensure not to overwrite the pivot\n        if (pivot_pos != n - 1)\n            s[n - 1] = '9';\n        else\n            s[n - 2] = '9'; // Ensure not to overwrite the pivot\n        for(int i = 1; i < n - 1; ++i) {\n            if (i == pivot_pos) continue;\n            s[i] = '='; // No masses elsewhere\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            if (i == pivot_pos) continue;\n            if (rnd.next(0, 1) == 0) {\n                s[i] = '=';\n            } else {\n                s[i] = '1' + rnd.next(0, 8); // Random digit '1'-'9'\n            }\n        }\n    }\n\n    // Output the string\n    for(char c : s) {\n        printf(\"%c\", c);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n tests\n./gen -n 3 -type left\n./gen -n 3 -type right\n./gen -n 3 -type balance\n./gen -n 3 -type zero_weights\n./gen -n 3 -type single_mass_left\n./gen -n 3 -type single_mass_right\n\n./gen -n 10 -type random\n./gen -n 10 -type left\n./gen -n 10 -type right\n./gen -n 10 -type balance\n./gen -n 10 -type alternating\n./gen -n 10 -type heavy_at_ends\n\n# Medium n tests\n./gen -n 50 -type random\n./gen -n 50 -type left\n./gen -n 50 -type right\n./gen -n 50 -type balance\n./gen -n 50 -type max_left_torque\n./gen -n 50 -type max_right_torque\n\n./gen -n 100 -type random\n./gen -n 100 -type left\n./gen -n 100 -type right\n./gen -n 100 -type balance\n\n# Large n tests\n./gen -n 1000 -type random\n./gen -n 1000 -type left\n./gen -n 1000 -type right\n./gen -n 1000 -type balance\n\n./gen -n 10000 -type random\n./gen -n 10000 -type left\n./gen -n 10000 -type right\n./gen -n 10000 -type balance\n\n./gen -n 100000 -type random\n./gen -n 100000 -type left\n./gen -n 100000 -type right\n./gen -n 100000 -type balance\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type left\n./gen -n 1000000 -type right\n./gen -n 1000000 -type balance\n\n# Edge tests\n# Minimum size\n./gen -n 3 -type zero_weights\n./gen -n 3 -type random\n\n# Maximum size with single mass\n./gen -n 1000000 -type single_mass_left\n./gen -n 1000000 -type single_mass_right\n\n# Maximum left torque\n./gen -n 1000000 -type max_left_torque\n\n# Maximum right torque\n./gen -n 1000000 -type max_right_torque\n\n# Alternating pattern\n./gen -n 1000000 -type alternating\n\n# Heavy masses at ends\n./gen -n 1000000 -type heavy_at_ends\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:10.707864",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "376/B",
      "title": "B. I.O.U.",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 100; 0 ≤ m ≤ 104). The next m lines contain the debts. The i-th line contains three integers ai, bi, ci (1 ≤ ai, bi ≤ n; ai ≠ bi; 1 ≤ ci ≤ 100), which mean that person ai owes person bi ci rubles.Assume that the people are numbered by integers from 1 to n.It is guaranteed that the same pair of people occurs at most once in the input. The input doesn't simultaneously contain pair of people (x, y) and pair of people (y, x).",
      "output_spec": "OutputPrint a single integer — the minimum sum of debts in the optimal rearrangement.",
      "sample_tests": "ExamplesInputCopy5 31 2 102 3 12 4 1OutputCopy10InputCopy3 0OutputCopy0InputCopy4 31 2 12 3 13 1 1OutputCopy0",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 100; 0 ≤ m ≤ 104). The next m lines contain the debts. The i-th line contains three integers ai, bi, ci (1 ≤ ai, bi ≤ n; ai ≠ bi; 1 ≤ ci ≤ 100), which mean that person ai owes person bi ci rubles.Assume that the people are numbered by integers from 1 to n.It is guaranteed that the same pair of people occurs at most once in the input. The input doesn't simultaneously contain pair of people (x, y) and pair of people (y, x).\n\nOutputPrint a single integer — the minimum sum of debts in the optimal rearrangement.\n\nInputCopy5 31 2 102 3 12 4 1OutputCopy10InputCopy3 0OutputCopy0InputCopy4 31 2 12 3 13 1 1OutputCopy0\n\nInputCopy5 31 2 102 3 12 4 1\n\nOutputCopy10\n\nInputCopy3 0\n\nOutputCopy0\n\nInputCopy4 31 2 12 3 13 1 1\n\nOutputCopy0\n\nNoteIn the first sample, you can assume that person number 1 owes 8 rubles to person number 2, 1 ruble to person number 3 and 1 ruble to person number 4. He doesn't owe anybody else anything. In the end, the total debt equals 10.In the second sample, there are no debts.In the third sample, you can annul all the debts.",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 376\\s*B"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> debt_pairs;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100, \"ci\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Person can't owe himself (ai != bi), but ai=%d, bi=%d\", a, b);\n\n        pair<int,int> ab = make_pair(a, b);\n        pair<int,int> ba = make_pair(b, a);\n\n        ensuref(!debt_pairs.count(ab), \"Debt between %d and %d occurs more than once\", a, b);\n        ensuref(!debt_pairs.count(ba), \"Input contains both debts between %d->%d and %d->%d\", a, b, b, a);\n\n        debt_pairs.insert(ab);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> debt_pairs;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100, \"ci\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Person can't owe himself (ai != bi), but ai=%d, bi=%d\", a, b);\n\n        pair<int,int> ab = make_pair(a, b);\n        pair<int,int> ba = make_pair(b, a);\n\n        ensuref(!debt_pairs.count(ab), \"Debt between %d and %d occurs more than once\", a, b);\n        ensuref(!debt_pairs.count(ba), \"Input contains both debts between %d->%d and %d->%d\", a, b, b, a);\n\n        debt_pairs.insert(ab);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> debt_pairs;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100, \"ci\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Person can't owe himself (ai != bi), but ai=%d, bi=%d\", a, b);\n\n        pair<int,int> ab = make_pair(a, b);\n        pair<int,int> ba = make_pair(b, a);\n\n        ensuref(!debt_pairs.count(ab), \"Debt between %d and %d occurs more than once\", a, b);\n        ensuref(!debt_pairs.count(ba), \"Input contains both debts between %d->%d and %d->%d\", a, b, b, a);\n\n        debt_pairs.insert(ab);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // default m = 0\n    string type = opt<string>(\"type\", \"random\"); // default type = \"random\"\n    int maxc = opt<int>(\"maxc\", 100); // maximum value of c_i, default is 100\n\n    int max_m = n * (n - 1); // maximum number of debts possible\n    m = min(m, max_m); // ensure m does not exceed possible number of debts\n\n    vector<tuple<int, int, int>> debts;\n\n    if (type == \"random\") {\n        // Generate all possible edges (a, b) where a != b\n        vector<pair<int, int>> possible_edges;\n        for (int a = 1; a <= n; ++a) {\n            for (int b = 1; b <= n; ++b) {\n                if (a != b) {\n                    possible_edges.emplace_back(a, b);\n                }\n            }\n        }\n\n        // Shuffle the possible edges\n        shuffle(possible_edges.begin(), possible_edges.end());\n\n        // Initialize a set to store edges we have chosen\n        set<pair<int, int>> chosen_edges;\n\n        for (int i = 0; i < (int)possible_edges.size() && (int)debts.size() < m; ++i) {\n            int a = possible_edges[i].first;\n            int b = possible_edges[i].second;\n\n            // Check if (b, a) has been chosen already\n            if (chosen_edges.count(make_pair(b, a)) == 0) {\n                int c = rnd.next(1, maxc);\n                debts.emplace_back(a, b, c);\n                chosen_edges.insert(make_pair(a, b));\n            }\n        }\n\n        m = debts.size(); // update m in case it's less than requested\n    } else if (type == \"cancelable\") {\n        if (n == 1) {\n            m = 0;\n        } else {\n            // Generate a cycle of debts with c_i = 1\n            for (int i = 1; i < n; ++i) {\n                debts.emplace_back(i, i + 1, 1);\n            }\n            debts.emplace_back(n, 1, 1);\n            m = n;\n        }\n    } else if (type == \"max\") {\n        // Debts from person 1 to others, c_i = maxc\n        for (int b = 2; b <= n; ++b) {\n            debts.emplace_back(1, b, maxc);\n        }\n        m = n - 1;\n    } else if (type == \"zero\") {\n        m = 0;\n        // debts is empty\n    } else {\n        // default to random\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output debts\n    for (const auto& debt : debts) {\n        int a, b, c;\n        tie(a, b, c) = debt;\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // default m = 0\n    string type = opt<string>(\"type\", \"random\"); // default type = \"random\"\n    int maxc = opt<int>(\"maxc\", 100); // maximum value of c_i, default is 100\n\n    int max_m = n * (n - 1); // maximum number of debts possible\n    m = min(m, max_m); // ensure m does not exceed possible number of debts\n\n    vector<tuple<int, int, int>> debts;\n\n    if (type == \"random\") {\n        // Generate all possible edges (a, b) where a != b\n        vector<pair<int, int>> possible_edges;\n        for (int a = 1; a <= n; ++a) {\n            for (int b = 1; b <= n; ++b) {\n                if (a != b) {\n                    possible_edges.emplace_back(a, b);\n                }\n            }\n        }\n\n        // Shuffle the possible edges\n        shuffle(possible_edges.begin(), possible_edges.end());\n\n        // Initialize a set to store edges we have chosen\n        set<pair<int, int>> chosen_edges;\n\n        for (int i = 0; i < (int)possible_edges.size() && (int)debts.size() < m; ++i) {\n            int a = possible_edges[i].first;\n            int b = possible_edges[i].second;\n\n            // Check if (b, a) has been chosen already\n            if (chosen_edges.count(make_pair(b, a)) == 0) {\n                int c = rnd.next(1, maxc);\n                debts.emplace_back(a, b, c);\n                chosen_edges.insert(make_pair(a, b));\n            }\n        }\n\n        m = debts.size(); // update m in case it's less than requested\n    } else if (type == \"cancelable\") {\n        if (n == 1) {\n            m = 0;\n        } else {\n            // Generate a cycle of debts with c_i = 1\n            for (int i = 1; i < n; ++i) {\n                debts.emplace_back(i, i + 1, 1);\n            }\n            debts.emplace_back(n, 1, 1);\n            m = n;\n        }\n    } else if (type == \"max\") {\n        // Debts from person 1 to others, c_i = maxc\n        for (int b = 2; b <= n; ++b) {\n            debts.emplace_back(1, b, maxc);\n        }\n        m = n - 1;\n    } else if (type == \"zero\") {\n        m = 0;\n        // debts is empty\n    } else {\n        // default to random\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output debts\n    for (const auto& debt : debts) {\n        int a, b, c;\n        tie(a, b, c) = debt;\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type zero\n./gen -n 2 -m 1 -type cancelable\n./gen -n 3 -m 3 -type cancelable\n./gen -n 4 -m 4 -type cancelable\n./gen -n 5 -m 10 -type random\n./gen -n 10 -m 20 -type random\n./gen -n 10 -m 20 -type random -maxc 1\n./gen -n 10 -m 20 -type random -maxc 100\n./gen -n 50 -m 1000 -type random\n./gen -n 50 -m 2450 -type random\n./gen -n 50 -m 1000 -type random -maxc 1\n./gen -n 50 -m 1000 -type random -maxc 100\n./gen -n 100 -type max\n./gen -n 100 -type cancelable\n./gen -n 100 -m 9900 -type random\n./gen -n 100 -m 9900 -type random -maxc 1\n./gen -n 100 -m 9900 -type random -maxc 100\n./gen -n 100 -m 10000 -type random\n./gen -n 100 -m 10000 -type random -maxc 100\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 0 -type zero\n./gen -n 99 -m 500 -type random\n./gen -n 100 -m 0 -type zero\n./gen -n 100 -m 1000 -type random\n./gen -n 100 -m 5000 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 9000 -type random\n./gen -n 100 -m 9900 -type random -maxc 50\n./gen -n 100 -m 9900 -type random -maxc 1\n./gen -n 5 -m 20 -type random -maxc 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:13.007045",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "376/C",
      "title": "C. Divisible by Seven",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains positive integer a in the decimal record. It is guaranteed that the record of number a contains digits: 1, 6, 8, 9. Number a doesn't contain any leading zeroes. The decimal representation of number a contains at least 4 and at most 106 characters.",
      "output_spec": "OutputPrint a number in the decimal notation without leading zeroes — the result of the permutation.If it is impossible to rearrange the digits of the number a in the required manner, print 0.",
      "sample_tests": "ExamplesInputCopy1689OutputCopy1869InputCopy18906OutputCopy18690",
      "description": "C. Divisible by Seven\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains positive integer a in the decimal record. It is guaranteed that the record of number a contains digits: 1, 6, 8, 9. Number a doesn't contain any leading zeroes. The decimal representation of number a contains at least 4 and at most 106 characters.\n\nOutputPrint a number in the decimal notation without leading zeroes — the result of the permutation.If it is impossible to rearrange the digits of the number a in the required manner, print 0.\n\nInputCopy1689OutputCopy1869InputCopy18906OutputCopy18690\n\nInputCopy1689\n\nOutputCopy1869\n\nInputCopy18906\n\nOutputCopy18690",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 376 和字母"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_LEN = 4;\nconst int MAX_LEN = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"a\"); // Read number a, no leading zeros\n\n    inf.readEoln();\n    inf.readEof();\n\n    // Check that the length of s is between MIN_LEN and MAX_LEN\n    int len = s.length();\n    ensuref(len >= MIN_LEN && len <= MAX_LEN, \"Length of input number should be between 4 and 1e6, but it is %d\", len);\n\n    // Ensure that s contains digits '1', '6', '8', '9'\n    set<char> required_digits = {'1', '6', '8', '9'};\n    for (char c : required_digits) {\n        ensuref(s.find(c) != string::npos, \"Input number must contain digit '%c'\", c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_LEN = 4;\nconst int MAX_LEN = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"a\"); // Read number a, no leading zeros\n\n    inf.readEoln();\n    inf.readEof();\n\n    // Check that the length of s is between MIN_LEN and MAX_LEN\n    int len = s.length();\n    ensuref(len >= MIN_LEN && len <= MAX_LEN, \"Length of input number should be between 4 and 1e6, but it is %d\", len);\n\n    // Ensure that s contains digits '1', '6', '8', '9'\n    set<char> required_digits = {'1', '6', '8', '9'};\n    for (char c : required_digits) {\n        ensuref(s.find(c) != string::npos, \"Input number must contain digit '%c'\", c);\n    }\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_LEN = 4;\nconst int MAX_LEN = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"a\"); // Read number a, no leading zeros\n\n    inf.readEoln();\n    inf.readEof();\n\n    // Check that the length of s is between MIN_LEN and MAX_LEN\n    int len = s.length();\n    ensuref(len >= MIN_LEN && len <= MAX_LEN, \"Length of input number should be between 4 and 1e6, but it is %d\", len);\n\n    // Ensure that s contains digits '1', '6', '8', '9'\n    set<char> required_digits = {'1', '6', '8', '9'};\n    for (char c : required_digits) {\n        ensuref(s.find(c) != string::npos, \"Input number must contain digit '%c'\", c);\n    }\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string a = inf.readToken(); // Read the input number 'a'\n\n    string pans = ouf.readToken(); // Read participant's output\n    string jans = ans.readToken(); // Read jury's answer\n\n    if (pans == \"0\") {\n        if (jans == \"0\") {\n            quitf(_ok, \"Correctly output 0\");\n        } else {\n            quitf(_wa, \"An answer exists, but participant outputs 0\");\n        }\n    } else {\n        if (pans[0] == '0') {\n            quitf(_wa, \"Output number has leading zeros\");\n        }\n        if (!all_of(pans.begin(), pans.end(), ::isdigit)) {\n            quitf(_wa, \"Output contains non-digit characters\");\n        }\n\n        // Check that 'pans' is a permutation of 'a'\n        vector<int> freq_a(10, 0), freq_pans(10, 0);\n        for (char c : a) {\n            freq_a[c - '0']++;\n        }\n        for (char c : pans) {\n            freq_pans[c - '0']++;\n        }\n        if (freq_a != freq_pans) {\n            quitf(_wa, \"Output is not a permutation of input digits\");\n        }\n\n        // Check divisibility by 7\n        int mod = 0;\n        for (char c : pans) {\n            mod = (mod * 10 + (c - '0')) % 7;\n        }\n        if (mod != 0) {\n            quitf(_wa, \"Output is not divisible by 7\");\n        }\n\n        if (jans == \"0\") {\n            quitf(_fail, \"Participant found an answer when jury did not\");\n        } else {\n            quitf(_ok, \"Correct answer\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 4);\n    string type = opt<string>(\"type\", \"random\");\n\n    string a;\n\n    if (type == \"random\") {\n        vector<char> digits;\n\n        // Start by adding digits '1', '6', '8', '9'\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        // Now generate remaining digits\n        for(int i = 0; i < n - 4; ++i) {\n            char digit = '0' + rnd.next(10); // '0' to '9'\n            digits.push_back(digit);\n        }\n\n        // Ensure first digit is not '0'\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"max_length\") {\n        n = 1000000; // Max length\n\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            char digit = '0' + rnd.next(10);\n            digits.push_back(digit);\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"leading_zero_problem\") {\n\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            digits.push_back('0');\n        }\n\n        // First digit is already non-zero\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"duplicates\") {\n\n        vector<char> digits;\n\n        int num_copies = n / 4;\n        if (num_copies == 0) num_copies = 1;\n\n        for(int i = 0; i < num_copies; ++i) {\n            digits.push_back('1');\n            digits.push_back('6');\n            digits.push_back('8');\n            digits.push_back('9');\n        }\n\n        while (digits.size() > n) {\n            digits.pop_back();\n        }\n\n        while (digits.size() < n) {\n            char digit = '0' + rnd.next(10);\n            digits.push_back(digit);\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"with_zeros\") {\n\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            digits.push_back('0' + rnd.next(2)); // '0' or '1'\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"only_digits_1689\") {\n\n        n = 4;\n\n        vector<char> digits = {'1', '6', '8', '9'};\n        shuffle(digits.begin(), digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"repeated_1689\") {\n\n        vector<char> digits;\n\n        int repeats = n / 4;\n        if (repeats == 0) repeats = 1;\n\n        for(int i = 0; i < repeats; ++i) {\n            digits.push_back('1');\n            digits.push_back('6');\n            digits.push_back('8');\n            digits.push_back('9');\n        }\n\n        while (digits.size() > n) {\n            digits.pop_back();\n        }\n\n        while (digits.size() < n) {\n            digits.push_back('0' + rnd.next(10));\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else {\n        // Default: random\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            char digit = '0' + rnd.next(10); // '0' to '9'\n            digits.push_back(digit);\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n    }\n\n    cout << a << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 4);\n    string type = opt<string>(\"type\", \"random\");\n\n    string a;\n\n    if (type == \"random\") {\n        vector<char> digits;\n\n        // Start by adding digits '1', '6', '8', '9'\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        // Now generate remaining digits\n        for(int i = 0; i < n - 4; ++i) {\n            char digit = '0' + rnd.next(10); // '0' to '9'\n            digits.push_back(digit);\n        }\n\n        // Ensure first digit is not '0'\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"max_length\") {\n        n = 1000000; // Max length\n\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            char digit = '0' + rnd.next(10);\n            digits.push_back(digit);\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"leading_zero_problem\") {\n\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            digits.push_back('0');\n        }\n\n        // First digit is already non-zero\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"duplicates\") {\n\n        vector<char> digits;\n\n        int num_copies = n / 4;\n        if (num_copies == 0) num_copies = 1;\n\n        for(int i = 0; i < num_copies; ++i) {\n            digits.push_back('1');\n            digits.push_back('6');\n            digits.push_back('8');\n            digits.push_back('9');\n        }\n\n        while (digits.size() > n) {\n            digits.pop_back();\n        }\n\n        while (digits.size() < n) {\n            char digit = '0' + rnd.next(10);\n            digits.push_back(digit);\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"with_zeros\") {\n\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            digits.push_back('0' + rnd.next(2)); // '0' or '1'\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"only_digits_1689\") {\n\n        n = 4;\n\n        vector<char> digits = {'1', '6', '8', '9'};\n        shuffle(digits.begin(), digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else if (type == \"repeated_1689\") {\n\n        vector<char> digits;\n\n        int repeats = n / 4;\n        if (repeats == 0) repeats = 1;\n\n        for(int i = 0; i < repeats; ++i) {\n            digits.push_back('1');\n            digits.push_back('6');\n            digits.push_back('8');\n            digits.push_back('9');\n        }\n\n        while (digits.size() > n) {\n            digits.pop_back();\n        }\n\n        while (digits.size() < n) {\n            digits.push_back('0' + rnd.next(10));\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n\n    } else {\n        // Default: random\n        vector<char> digits;\n\n        digits.push_back('1');\n        digits.push_back('6');\n        digits.push_back('8');\n        digits.push_back('9');\n\n        for(int i = 0; i < n - 4; ++i) {\n            char digit = '0' + rnd.next(10); // '0' to '9'\n            digits.push_back(digit);\n        }\n\n        if (digits[0] == '0') {\n            for(int i = 1; i < digits.size(); ++i) {\n                if (digits[i] != '0') {\n                    swap(digits[0], digits[i]);\n                    break;\n                }\n            }\n        }\n\n        shuffle(digits.begin() + 1, digits.end());\n        a = string(digits.begin(), digits.end());\n    }\n\n    cout << a << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 1000000 -type random\n\n./gen -type max_length\n\n./gen -n 10 -type leading_zero_problem\n./gen -n 100 -type leading_zero_problem\n./gen -n 1000 -type leading_zero_problem\n\n./gen -n 10 -type duplicates\n./gen -n 100 -type duplicates\n./gen -n 1000 -type duplicates\n\n./gen -n 10 -type with_zeros\n./gen -n 100 -type with_zeros\n./gen -n 1000 -type with_zeros\n./gen -n 10000 -type with_zeros\n\n./gen -type only_digits_1689\n\n./gen -n 8 -type repeated_1689\n./gen -n 16 -type repeated_1689\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:15.000730",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "376/D",
      "title": "D. Maximum Submatrix 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000). Next n lines contain m characters each — matrix a. Matrix a only contains characters: \"0\" and \"1\". Note that the elements of the matrix follow without any spaces in the lines.",
      "output_spec": "OutputPrint a single integer — the area of the maximum obtained submatrix. If we cannot obtain a matrix of numbers one, print 0.",
      "sample_tests": "ExamplesInputCopy1 11OutputCopy1InputCopy2 21011OutputCopy2InputCopy4 3100011000101OutputCopy2",
      "description": "D. Maximum Submatrix 2\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000). Next n lines contain m characters each — matrix a. Matrix a only contains characters: \"0\" and \"1\". Note that the elements of the matrix follow without any spaces in the lines.\n\nOutputPrint a single integer — the area of the maximum obtained submatrix. If we cannot obtain a matrix of numbers one, print 0.\n\nInputCopy1 11OutputCopy1InputCopy2 21011OutputCopy2InputCopy4 3100011000101OutputCopy2\n\nInputCopy1 11\n\nOutputCopy1\n\nInputCopy2 21011\n\nOutputCopy2\n\nInputCopy4 3100011000101\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 376 和字母"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,5000,\"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,5000,\"m\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(pattern, \"line\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,5000,\"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,5000,\"m\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(pattern, \"line\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,5000,\"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,5000,\"m\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(pattern, \"line\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> matrix(n, string(m, '0'));\n\n    if (type == \"all_zeros\") {\n        // Matrix is already initialized with zeros.\n    } else if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i)\n            matrix[i] = string(m, '1');\n    } else if (type == \"single_row_ones\") {\n        int row = rnd.next(0, n-1);\n        matrix[row] = string(m, '1');\n    } else if (type == \"single_column_ones\") {\n        int col = rnd.next(0, m-1);\n        for (int i = 0; i < n; ++i)\n            matrix[i][col] = '1';\n    } else if (type == \"diagonal_ones\") {\n        for (int i = 0; i < min(n,m); ++i)\n            matrix[i][i] = '1';\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 0)\n                    matrix[i][j] = '1';\n    } else if (type == \"sparse\") {\n        int ones = (n * m) / 10; // 10% ones\n        while (ones--) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            matrix[i][j] = '1';\n        }\n    } else if (type == \"dense\") {\n        int zeros = (n * m) / 10; // 10% zeros\n        for (int i = 0; i < n; ++i)\n            matrix[i] = string(m, '1');\n        while (zeros--) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            matrix[i][j] = '0';\n        }\n    } else if (type == \"random\") {\n        for (int i =0; i < n; ++i)\n            for (int j =0; j < m; ++j)\n                matrix[i][j] = rnd.next(0,1) ? '1' : '0';\n    } else if (type == \"worst_case\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j <= i && j < m; ++j)\n                matrix[i][j] = '1';\n    } else {\n        // Handle unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the matrix\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", matrix[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> matrix(n, string(m, '0'));\n\n    if (type == \"all_zeros\") {\n        // Matrix is already initialized with zeros.\n    } else if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i)\n            matrix[i] = string(m, '1');\n    } else if (type == \"single_row_ones\") {\n        int row = rnd.next(0, n-1);\n        matrix[row] = string(m, '1');\n    } else if (type == \"single_column_ones\") {\n        int col = rnd.next(0, m-1);\n        for (int i = 0; i < n; ++i)\n            matrix[i][col] = '1';\n    } else if (type == \"diagonal_ones\") {\n        for (int i = 0; i < min(n,m); ++i)\n            matrix[i][i] = '1';\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 0)\n                    matrix[i][j] = '1';\n    } else if (type == \"sparse\") {\n        int ones = (n * m) / 10; // 10% ones\n        while (ones--) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            matrix[i][j] = '1';\n        }\n    } else if (type == \"dense\") {\n        int zeros = (n * m) / 10; // 10% zeros\n        for (int i = 0; i < n; ++i)\n            matrix[i] = string(m, '1');\n        while (zeros--) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, m-1);\n            matrix[i][j] = '0';\n        }\n    } else if (type == \"random\") {\n        for (int i =0; i < n; ++i)\n            for (int j =0; j < m; ++j)\n                matrix[i][j] = rnd.next(0,1) ? '1' : '0';\n    } else if (type == \"worst_case\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j <= i && j < m; ++j)\n                matrix[i][j] = '1';\n    } else {\n        // Handle unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the matrix\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", matrix[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small matrices\n./gen -n 1 -m 1 -type all_zeros\n./gen -n 1 -m 1 -type all_ones\n./gen -n 1 -m 1 -type random\n\n./gen -n 5 -m 5 -type all_ones\n./gen -n 5 -m 5 -type all_zeros\n./gen -n 5 -m 5 -type single_row_ones\n./gen -n 5 -m 5 -type single_column_ones\n./gen -n 5 -m 5 -type diagonal_ones\n./gen -n 5 -m 5 -type checkerboard\n./gen -n 5 -m 5 -type random\n\n# Medium matrices\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type sparse\n./gen -n 100 -m 100 -type dense\n./gen -n 100 -m 100 -type worst_case\n\n# Large matrices\n./gen -n 5000 -m 5000 -type random\n./gen -n 5000 -m 5000 -type sparse\n./gen -n 5000 -m 5000 -type dense\n./gen -n 5000 -m 5000 -type all_ones\n./gen -n 5000 -m 5000 -type all_zeros\n./gen -n 5000 -m 5000 -type worst_case\n\n# Edge cases\n./gen -n 5000 -m 1 -type random\n./gen -n 1 -m 5000 -type random\n\n./gen -n 5000 -m 5000 -type single_row_ones\n./gen -n 5000 -m 5000 -type single_column_ones\n\n./gen -n 1000 -m 1000 -type diagonal_ones\n./gen -n 1000 -m 1000 -type checkerboard\n\n./gen -n 2500 -m 2500 -type worst_case\n\n# Additional specific test cases\n./gen -n 5000 -m 5000 -type random\n\n./gen -n 2 -m 2 -type random\n./gen -n 3 -m 3 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:17.588994",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "376/E",
      "title": "E. Circling Round Treasures",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 20) — the sizes of the table. Next n lines each contains m characters — the description of the table. The description means the following:  character \"B\" is a cell with a bomb;  character \"S\" is the starting cell, you can assume that it's empty;  digit c (1-8) is treasure with index c;  character \".\" is an empty cell;  character \"#\" is an obstacle. Assume that the map has t treasures. Next t lines contain the prices of the treasures. The i-th line contains the price of the treasure with index i, vi ( - 200 ≤ vi ≤ 200). It is guaranteed that the treasures are numbered from 1 to t. It is guaranteed that the map has not more than 8 objects in total. Objects are bombs and treasures. It is guaranteed that the map has exactly one character \"S\".",
      "output_spec": "OutputPrint a single integer — the maximum possible profit you can get.",
      "sample_tests": "ExamplesInputCopy4 4.....S1.........10OutputCopy2InputCopy7 7........1###2..#...#..#.B.#..3...4...##.........S100100100100OutputCopy364InputCopy7 8....................1B...S..........2...3...............100-100100OutputCopy0InputCopy1 1SOutputCopy0",
      "description": "E. Circling Round Treasures\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 20) — the sizes of the table. Next n lines each contains m characters — the description of the table. The description means the following:  character \"B\" is a cell with a bomb;  character \"S\" is the starting cell, you can assume that it's empty;  digit c (1-8) is treasure with index c;  character \".\" is an empty cell;  character \"#\" is an obstacle. Assume that the map has t treasures. Next t lines contain the prices of the treasures. The i-th line contains the price of the treasure with index i, vi ( - 200 ≤ vi ≤ 200). It is guaranteed that the treasures are numbered from 1 to t. It is guaranteed that the map has not more than 8 objects in total. Objects are bombs and treasures. It is guaranteed that the map has exactly one character \"S\".\n\nOutputPrint a single integer — the maximum possible profit you can get.\n\nInputCopy4 4.....S1.........10OutputCopy2InputCopy7 7........1###2..#...#..#.B.#..3...4...##.........S100100100100OutputCopy364InputCopy7 8....................1B...S..........2...3...............100-100100OutputCopy0InputCopy1 1SOutputCopy0\n\nInputCopy4 4.....S1.........10\n\nOutputCopy2\n\nInputCopy7 7........1###2..#...#..#.B.#..3...4...##.........S100100100100\n\nOutputCopy364\n\nInputCopy7 8....................1B...S..........2...3...............100-100100\n\nOutputCopy0\n\nInputCopy1 1S\n\nOutputCopy0\n\nNoteIn the first example the answer will look as follows.  In the second example the answer will look as follows.  In the third example you cannot get profit.In the fourth example you cannot get profit as you cannot construct a closed path with more than one cell.",
      "solutions": [
        {
          "title": "Codeforces Round #221 - Codeforces",
          "content": "Hi, Codeforces Round #221 will take place on December 24th at 18:00 MSK for both divisions.Problem setters are whd, oGhost and boleyn.su. This is our first Codeforces Round, and we hope it will be a good one.We'd like to thank Gerald and alpc104 for helping us prepare this round, and MikeMirzayanov for bringing all of us a place to compete and communicate with others.The score distribution will be announced before the contest starts.UPD1: The score distribution is 500-1000-1500-2000-2500 for both divisions.UPD2:Congratulations to winnners and Merry Christmas to ones who celebrate it today!Div 1:1.Touma_Kazusa2.al13n3.rng_584.hmspmy0775.uwiDiv 2:1.bohuss2.Tyg3R3.xhsong4.adamant5.Kira96",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 693
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces",
          "content": "376A - Leverwriter: boleyn.suO(n):Let mid = position of ^Let value(x) = x if x is a digit , 0 otherwise.Let sum = value(i-th char)*(i-mid)If sum = 0 then answer = balanceElse if sum<0 then answer = leftElse answer = right376B - I.O.U.writer: oGhostO(n^4):Let f[i][j] = how many money i owes j#It can be proved we only need to loop n times.Loop n times do: For i,j,k in [1..n]\n\n If f[i][j]>0 and f[j][k]>0 then\n\n Let delta = min (f[i][j], f[j][k])\n\n Decrease f[i][j] and f[j][k] by delta\n\n Increase f[i][k] by deltaAnswer will be sum{f[i][j]}O(m+n):Let owe[i] = 0 for all i#Suppose there is an agnecy to help people with debts.#If you owe someone, you give money to the agency.#If someone owes you, you get money from the agency.For each ai, bi, ci Increase owe[ai] by ci\n\nDecrease owe[bi] by ciAnsewr will be sum{owe[i]|owe[i]>0}375A - Divisible by Sevenwriter: oGhostO(n):Because permutation of 1, 6, 8, 9 can form integers that mod 7 equals 0, 1, 2, 3, 4, 5, 6.So you can construct answer like this: nonzero digits + a permutation of 1, 6, 8, 9 + zeros.375B - Maximum Submatrix 2writer: oGhostO(n*m):#We can get right[i][j] by O(n*m) dp.Let right[i][j] = how many continuous 1s is on cell (j, i)'s right.Let answer = 0For all column i Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)375C - Circling Round Treasureswriter: whd#T = number of treasures, B = number of boomsO(n*m*2^(T+B)):#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}375D - Tree and Querieswriter: whdO(nlogn) or O(nlog^2n):Use binary search tree and merge them by rank.Use binary search tree that supports O(n) merging to get O(nlogn) solution.O(n*sqrt(n)):Dfs the tree to transform the problem to: Given a[i], query [l,r] k.To solve this problem: Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).375E - Red and Black Treewriter: boleyn.suThis problem can be solved by integer programming: min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} = R\n\n x[i] = 0 or 1 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.As it is known, integer programming is NP-hard.Thus, this cannot be the solution.But we can prove the following linear programing's solution is same as the integer programming's. min sum{c[i]*x[i]}\n\nsubject to\n\n sum{A[i][j]*x[j]} >= 1 for all i\n\n sum{x[i]} <= R\n\n x[i] >= 0 for all i\n\nwhere\n\n c[i] = 1 if node i is black, 0 otherwise\n\n A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n R = number of red nodes.And the known fastest algorithm to solve linear programming is O(n^3.5).But in fact due to the property of this problem, using simplex algorithm to solve linear programming is even faster. I think it can be O(n^3), but I have no proof.So just use simplex to solve the linear programming problem above.The tutorial is not finished yet. More details will be added later.UPDThanks to Codeforces users, a lot of details supposed to be added can be found in comments. I am adding something that is not clearly explained in the comments or something that I want to share with you.Div1C:There are few questions about this one. So I am explaining it more clearly.#State(i, j, ts, bs) means:# 1. You are at cell (i, j)# 2. If the i-th bit of ts is 0 i-th treasure cross even edges of current path, otherwise odd edges.# 3. If the i-th bit of bs is 0 i-th boom cross even edges of current path, otherwise odd edges.Let dis[i][j][ts][bs] = min step to go to reach state (i, j, ts, bs).Then we can use bfs algorithm to calculate dis.About the bfs algorithm: We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.The answer will be max{value(ts) — dis[Si][Sj][ts][0]}My submission: 5550863Div1D:To our surprise, there seems to be many different solutions to Div1D, which is very good. In fact, we thought about changing this problem so that only online algorithm will be accepted, but we didn't have much time to change it. I guess if we only accept online algorithm, the problem will be less interesting becasue we might not have so many different solutions. So, not changing it is a good decision.However, it may(some solution is hard to change to solve the online-version, so I use 'may') be quite simple to solve the online-version of this problem if you have solved the offline-version. You just need to use persistent data structure when implementing binary search trees. You can get more detail from wiki.Div1E:The meaning of the integer programming: We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}After changing it to linear programming: Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.My submission: 5523033There is a nice DP solution too, check this submission 5516578 by Touma_Kazusa.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 376 和字母"
          },
          "content_length": 7562
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #221 - Codeforces - Code 1",
          "code": "ios :: sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 2",
          "code": "scanf(\"%c\",&x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 3",
          "code": "x = getchar()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 4",
          "code": "scanf(\"%c\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 5",
          "code": "O(n^2log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 6",
          "code": "scanf(\"%1d\", &a[i][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 7",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 8",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 9",
          "code": "ios::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 10",
          "code": "ios::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 - Codeforces - Code 11",
          "code": "XMLHttpRequest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 1",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 2",
          "code": "For i,j,k in [1..n]\n\n    If f[i][j]>0 and f[j][k]>0 then\n\n       Let  delta = min (f[i][j], f[j][k])\n\n       Decrease f[i][j] and f[j][k] by delta\n\n       Increase f[i][k] by delta",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 3",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 4",
          "code": "Increase owe[ai] by ci\n\nDecrease owe[bi] by ci",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 5",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 6",
          "code": "Sort right[i] #You can use O(n) sorting algorithm\n\nFor j in [1..n]\n\n    If right[i][j]*(n-j+1) > answer then answer = right[i][j]*(n-j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 7",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 8",
          "code": "Given a[i], query [l,r] k.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 9",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 10",
          "code": "Build sqrt(n) bucket, put query [l,r] into (l/sqrt(n)+1)-th bucket\n\nFor each bucket\n\n    For thoese queries whose r is also in the bucket (l/sqrt(n) equals r/sqrt(n)), a brute-froce O(n) solution exists.\n\n    For thoes queries whose r is not in the same bucket, let we sort them by l. We will get l[i[1]]<=l[i[2]]<=..<=l[i[k]]<=r[i[k]]<=r[i[k-1]]<=..<=r[i[1]](do not forget we get l[] and r[] by dfs the tree!). Solving them can be done in O(n) too.\n\nSince we only have O(sqrt(n)) buckets, the total time is O(n*sqrt(n)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 11",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 12",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} = R\n\n    x[i] = 0 or 1 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 13",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 14",
          "code": "min sum{c[i]*x[i]}\n\nsubject to\n\n    sum{A[i][j]*x[j]} >= 1 for all i\n\n    sum{x[i]} <= R\n\n    x[i] >= 0 for all i\n\nwhere\n\n    c[i] = 1 if node i is black, 0 otherwise\n\n    A[i][j] = 1 if distance between i and j is no greater than X, 0 otherwise\n\n    R = number of red nodes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 15",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 16",
          "code": "We know dis[Si][Sj][0][0] = 0.\n\nFor state(i, j, bs, ts) we can goto cell (i-1, j), (i+1, j), (i, j-1) and (i, j+1). Of course, we cannot go out of the map or go into a trap. So suppose we go from cell (i, j) to cell (ni, nj) and the new state is (ni, nj, nts, nbs). We can see if a treasure is crossing through the edge (i, j) - (ni, nj), if i-th treasure is, then the i-th bit of nts will be 1 xor i-th bit of ts, otherwise, the i-th bit of nts and ts will be same. The same for nbs.\n\nWe can reach state (ni, nj, nts, nbs) from (i, j, ts, bs) in one step, so we just need to start bfs from state(Si, Sj, 0, 0) to get the min dis of all state.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 17",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 18",
          "code": "We use x[i] to stand whether node i is red or not. So we have:\n\nx[i] = 0 or 1 for all i\n\nThere is a beautiful tree, for each node, exists an red node whose distance to this node is no more than X. So we have:\n\nsum{A[i][j]*x[j]} >= 1 for all i\n\nThere are only R red node. So we have:\n\nsum{x[i]} = R\n\nAnd we need to minimize the swap number, and in fact the swap number equals to number of nodes that changed from black to red. So we need to minimize:\n\nsum{c[i]*x[i]}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 19",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 20",
          "code": "Firstly, it is obvious that the solution of the linear programming will not be worse than integer programming, because integer programming has stronger constraint.\n\nSo we only need to show the solution of the linear programming will not be better than integer programming.\n\nTo prove this, we need to show for an optimal solution, there will be an solution which is as good as it and all x[i] is either 0 or 1.\n\n1. Because for \"sum{A[i][j]*x[j]} >= 1 for all i\", there is no need to make some x[i] > 1. It is obvious that if the solution has some x[i] > 1, we can increase x[i] for nodes that are red in the first place, so that there will not be any x[i] > 1 and this solution is as good as the old one.\n\n2. We need to prove in an optimal solution, making some x[i] not being an integer will not get btter solution. It is really hard to decribe it. So just leave you a hint: use the property of trees to prove and consider leaves of the tree.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 21",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 22",
          "code": "int myints[] = {1,6,8,9};\nstd::next_permutation(myints,myints+4);\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 23",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 24",
          "code": "int arr[] = {1689,1698,1869,1896,1968,1986,6189,6198,6819,6891,6918,6981,8169,8196,8619,8691,8916,8961,9168,9186,9618,9681,9816,9861} ;\nint dec[7] = {0} ;    \nfor(int i=0;i<7;i++)\n{\n    for(int j=0;j<24;j++)\n    {\n        int num = i*10000+arr[j] ;\n        if(num%7==0) dec[i] = arr[j] ;\n    }\n}\nfor(int i=0;i<7;i++) cout<<dec[i]<<\",\" ;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 25",
          "code": "i[1], i[2], ..., i[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 26",
          "code": "l[i[1]] <= l[i[2]] <= ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 27",
          "code": "add(l[i + 1], ..., l[i] - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 28",
          "code": "add(r[i] + 1, ..., r[i + 1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 29",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 30",
          "code": "Number a doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also **mustn't contain any leading zeroes.**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 31",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 32",
          "code": "3 3\n      1 2 10\n      2 3 30\n      3 1 300",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 33",
          "code": "M, N <= 5000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 34",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 35",
          "code": "Matrix           Consecutive sum from right\ncolumn     123456\n\nrow1       ....**           000021\nrow2       **.***           210321\nrow3       **...*           210001\nrow4       ..****           004321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 36",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 37",
          "code": "ans = 0;\nfor each column, starting from 1 to 6\n      tmp_ans=1;\n      make ca\n      sort ca\n      form largest value to smallest value in ca ( from (ca.size(); to 1 )\n              tmp_ans*= max(tmp_ans, (ca.size - current position on ca which is i)*ca[i]);\n      \n      ans=max(ans,tmp_ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #221 Tutorial - Codeforces - Code 38",
          "code": "You are allowed to rearrange its rows.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10084",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,20, \"n\"); // n rows\n    inf.readSpace();\n    int m = inf.readInt(1,20, \"m\"); // m columns\n    inf.readEoln();\n\n    int num_S = 0;\n    int num_bombs = 0;\n    set<int> treasure_indices;\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d: length is %d, expected %d\", i+1, (int)s.length(), m);\n        for(int j = 0; j < m; ++j) {\n            char c = s[j];\n            if(c == 'S') {\n                num_S++;\n            } else if(c == 'B') {\n                num_bombs++;\n            } else if(c >= '1' && c <= '8') {\n                int treasure_index = c - '0';\n                treasure_indices.insert(treasure_index);\n            } else if(c == '.' || c == '#') {\n                // OK\n            } else {\n                ensuref(false, \"Invalid character '%c' at position (%d,%d)\", c, i+1, j+1);\n            }\n        }\n    }\n    ensuref(num_S == 1, \"Number of starting positions 'S' must be exactly 1, but found %d\", num_S);\n    int t = treasure_indices.size();\n    for(int idx = 1; idx <= t; ++idx) {\n        ensuref(treasure_indices.count(idx) == 1, \"Treasure index %d is missing in the map.\", idx);\n    }\n    ensuref(t + num_bombs <= 8, \"Total number of treasures (%d) and bombs (%d) exceeds 8\", t, num_bombs);\n\n    for(int i = 0; i < t; ++i) {\n        int vi = inf.readInt(-200, 200, \"v_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,20, \"n\"); // n rows\n    inf.readSpace();\n    int m = inf.readInt(1,20, \"m\"); // m columns\n    inf.readEoln();\n\n    int num_S = 0;\n    int num_bombs = 0;\n    set<int> treasure_indices;\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d: length is %d, expected %d\", i+1, (int)s.length(), m);\n        for(int j = 0; j < m; ++j) {\n            char c = s[j];\n            if(c == 'S') {\n                num_S++;\n            } else if(c == 'B') {\n                num_bombs++;\n            } else if(c >= '1' && c <= '8') {\n                int treasure_index = c - '0';\n                treasure_indices.insert(treasure_index);\n            } else if(c == '.' || c == '#') {\n                // OK\n            } else {\n                ensuref(false, \"Invalid character '%c' at position (%d,%d)\", c, i+1, j+1);\n            }\n        }\n    }\n    ensuref(num_S == 1, \"Number of starting positions 'S' must be exactly 1, but found %d\", num_S);\n    int t = treasure_indices.size();\n    for(int idx = 1; idx <= t; ++idx) {\n        ensuref(treasure_indices.count(idx) == 1, \"Treasure index %d is missing in the map.\", idx);\n    }\n    ensuref(t + num_bombs <= 8, \"Total number of treasures (%d) and bombs (%d) exceeds 8\", t, num_bombs);\n\n    for(int i = 0; i < t; ++i) {\n        int vi = inf.readInt(-200, 200, \"v_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,20, \"n\"); // n rows\n    inf.readSpace();\n    int m = inf.readInt(1,20, \"m\"); // m columns\n    inf.readEoln();\n\n    int num_S = 0;\n    int num_bombs = 0;\n    set<int> treasure_indices;\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d: length is %d, expected %d\", i+1, (int)s.length(), m);\n        for(int j = 0; j < m; ++j) {\n            char c = s[j];\n            if(c == 'S') {\n                num_S++;\n            } else if(c == 'B') {\n                num_bombs++;\n            } else if(c >= '1' && c <= '8') {\n                int treasure_index = c - '0';\n                treasure_indices.insert(treasure_index);\n            } else if(c == '.' || c == '#') {\n                // OK\n            } else {\n                ensuref(false, \"Invalid character '%c' at position (%d,%d)\", c, i+1, j+1);\n            }\n        }\n    }\n    ensuref(num_S == 1, \"Number of starting positions 'S' must be exactly 1, but found %d\", num_S);\n    int t = treasure_indices.size();\n    for(int idx = 1; idx <= t; ++idx) {\n        ensuref(treasure_indices.count(idx) == 1, \"Treasure index %d is missing in the map.\", idx);\n    }\n    ensuref(t + num_bombs <= 8, \"Total number of treasures (%d) and bombs (%d) exceeds 8\", t, num_bombs);\n\n    for(int i = 0; i < t; ++i) {\n        int vi = inf.readInt(-200, 200, \"v_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Input parameters\n    int n = opt<int>(\"n\", rnd.next(1, 20));\n    int m = opt<int>(\"m\", rnd.next(1, 20));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    // We need to have exactly one 'S' in the grid\n    int start_i, start_j;\n\n    // Place starting position\n    if (type == \"corner_start\") {\n        start_i = 0;\n        start_j = 0;\n    } else {\n        start_i = opt<int>(\"start_i\", rnd.next(0, n - 1));\n        start_j = opt<int>(\"start_j\", rnd.next(0, m - 1));\n    }\n\n    grid[start_i][start_j] = 'S';\n\n    // Available positions to place bombs, treasures, and obstacles\n    vector<pair<int, int>> empty_cells;\n\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < m; ++j)\n            if (grid[i][j] == '.')\n                empty_cells.push_back({i, j});\n\n    // Depending on the type, generate different kinds of maps\n    if (type == \"random\") {\n        // Randomly place bombs, treasures, obstacles\n\n        int max_objects = 8;\n        int num_objects = rnd.next(0, max_objects); // number of bombs + treasures\n        int bombs = opt<int>(\"bombs\", rnd.next(0, num_objects));\n        int treasures = opt<int>(\"treasures\", num_objects - bombs);\n        treasures = min(treasures, 8 - bombs);\n\n        int obstacles = opt<int>(\"obstacles\", rnd.next(0, (int)empty_cells.size() - bombs - treasures));\n\n        ensure(bombs + treasures <= 8);\n        ensure(bombs + treasures + obstacles + 1 <= n * m);\n\n        // Shuffle empty cells\n        shuffle(empty_cells.begin(), empty_cells.end());\n\n        int index = 0;\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Place treasures, numbered from '1' to '8'\n        int total_treasures = treasures;\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i; // '1' to '8'\n        }\n\n        // Place obstacles\n        for (int i = 0; i < obstacles && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '#';\n        }\n\n        // Output\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Generate random values between -200 and 200\n        for (int i = 0; i < treasures; ++i) {\n            int value = rnd.next(-200, 200);\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"max_objects\") {\n        // Place maximum number of objects (8)\n        int total_objects = 8;\n\n        // Randomly decide number of bombs and treasures\n        int bombs = rnd.next(0, total_objects);\n        int treasures = total_objects - bombs;\n\n        ensure((int)empty_cells.size() >= total_objects);\n\n        // Shuffle empty cells\n        shuffle(empty_cells.begin(), empty_cells.end());\n        int index = 0;\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Place treasures\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i; // '1' to '8'\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Generate random values between -200 and 200\n        for (int i = 0; i < treasures; ++i) {\n            int value = rnd.next(-200, 200);\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"max_treasure_value\") {\n        // Place some treasures with max value\n        int treasures = rnd.next(1, 8);\n        int bombs = rnd.next(0, 8 - treasures);\n        ensure((int)empty_cells.size() >= treasures + bombs);\n\n        shuffle(empty_cells.begin(), empty_cells.end());\n        int index = 0;\n\n        // Place treasures\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i; // '1' to '8'\n        }\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Set all treasure values to 200\n        for (int i = 0; i < treasures; ++i) {\n            int value = 200;\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"negative_treasures\") {\n        // Place treasures with negative values\n        int treasures = rnd.next(1, 8);\n        int bombs = rnd.next(0, 8 - treasures);\n        ensure((int)empty_cells.size() >= treasures + bombs);\n\n        shuffle(empty_cells.begin(), empty_cells.end());\n        int index = 0;\n\n        // Place treasures\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i;\n        }\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Set all treasure values to -200\n        for (int i = 0; i < treasures; ++i) {\n            int value = -200;\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"obstacles\") {\n        // Fill the map with obstacles except starting position\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(grid[i][j] != 'S')\n                    grid[i][j] = '#';\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // No treasures, so no values to output\n\n    } else if (type == \"n1m1\") {\n        // Map of size 1x1\n        n = 1;\n        m = 1;\n        grid = vector<string>(n, string(m, '.'));\n\n        grid[0][0] = 'S';\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%s\\n\", grid[0].c_str());\n\n        // No treasures, so no values to output\n\n    } else if (type == \"full_map\") {\n        // Fill the map completely with treasures\n        n = 20;\n        m = 20;\n        grid = vector<string>(n, string(m, '.'));\n\n        // Starting position\n        grid[0][0] = 'S';\n\n        int treasures = 8;\n\n        int treasure_index = 0;\n\n        for(int i = 0; i < n && treasure_index < treasures; ++i)\n            for(int j = 0; j < m && treasure_index < treasures; ++j)\n                if(grid[i][j] == '.')\n                {\n                    grid[i][j] = '1' + treasure_index;\n                    treasure_index++;\n                }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        for (int i = 0; i < treasures; ++i) {\n            int value = rnd.next(-200, 200);\n            printf(\"%d\\n\", value);\n        }\n    } else if (type == \"path_needed\") {\n        // Create a map where the only way to get treasure is via a specific path\n\n        // Simple example: create corridors\n\n        n = 5;\n        m = 5;\n        grid = vector<string>(n, string(m, '#'));\n        // Clear a path\n        for(int i = 0; i < n; ++i)\n            grid[i][1] = '.';\n\n        for(int j = 1; j < m; ++j)\n            grid[n - 2][j] = '.';\n\n        // Place starting position\n        grid[0][1] = 'S';\n\n        // Place a treasure at (n-2, m-1)\n        grid[n - 2][m - 1] = '1';\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure value\n        printf(\"200\\n\");\n\n    } else {\n        // default random\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Input parameters\n    int n = opt<int>(\"n\", rnd.next(1, 20));\n    int m = opt<int>(\"m\", rnd.next(1, 20));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    // We need to have exactly one 'S' in the grid\n    int start_i, start_j;\n\n    // Place starting position\n    if (type == \"corner_start\") {\n        start_i = 0;\n        start_j = 0;\n    } else {\n        start_i = opt<int>(\"start_i\", rnd.next(0, n - 1));\n        start_j = opt<int>(\"start_j\", rnd.next(0, m - 1));\n    }\n\n    grid[start_i][start_j] = 'S';\n\n    // Available positions to place bombs, treasures, and obstacles\n    vector<pair<int, int>> empty_cells;\n\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < m; ++j)\n            if (grid[i][j] == '.')\n                empty_cells.push_back({i, j});\n\n    // Depending on the type, generate different kinds of maps\n    if (type == \"random\") {\n        // Randomly place bombs, treasures, obstacles\n\n        int max_objects = 8;\n        int num_objects = rnd.next(0, max_objects); // number of bombs + treasures\n        int bombs = opt<int>(\"bombs\", rnd.next(0, num_objects));\n        int treasures = opt<int>(\"treasures\", num_objects - bombs);\n        treasures = min(treasures, 8 - bombs);\n\n        int obstacles = opt<int>(\"obstacles\", rnd.next(0, (int)empty_cells.size() - bombs - treasures));\n\n        ensure(bombs + treasures <= 8);\n        ensure(bombs + treasures + obstacles + 1 <= n * m);\n\n        // Shuffle empty cells\n        shuffle(empty_cells.begin(), empty_cells.end());\n\n        int index = 0;\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Place treasures, numbered from '1' to '8'\n        int total_treasures = treasures;\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i; // '1' to '8'\n        }\n\n        // Place obstacles\n        for (int i = 0; i < obstacles && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '#';\n        }\n\n        // Output\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Generate random values between -200 and 200\n        for (int i = 0; i < treasures; ++i) {\n            int value = rnd.next(-200, 200);\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"max_objects\") {\n        // Place maximum number of objects (8)\n        int total_objects = 8;\n\n        // Randomly decide number of bombs and treasures\n        int bombs = rnd.next(0, total_objects);\n        int treasures = total_objects - bombs;\n\n        ensure((int)empty_cells.size() >= total_objects);\n\n        // Shuffle empty cells\n        shuffle(empty_cells.begin(), empty_cells.end());\n        int index = 0;\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Place treasures\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i; // '1' to '8'\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Generate random values between -200 and 200\n        for (int i = 0; i < treasures; ++i) {\n            int value = rnd.next(-200, 200);\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"max_treasure_value\") {\n        // Place some treasures with max value\n        int treasures = rnd.next(1, 8);\n        int bombs = rnd.next(0, 8 - treasures);\n        ensure((int)empty_cells.size() >= treasures + bombs);\n\n        shuffle(empty_cells.begin(), empty_cells.end());\n        int index = 0;\n\n        // Place treasures\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i; // '1' to '8'\n        }\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Set all treasure values to 200\n        for (int i = 0; i < treasures; ++i) {\n            int value = 200;\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"negative_treasures\") {\n        // Place treasures with negative values\n        int treasures = rnd.next(1, 8);\n        int bombs = rnd.next(0, 8 - treasures);\n        ensure((int)empty_cells.size() >= treasures + bombs);\n\n        shuffle(empty_cells.begin(), empty_cells.end());\n        int index = 0;\n\n        // Place treasures\n        for (int i = 0; i < treasures && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = '1' + i;\n        }\n\n        // Place bombs\n        for (int i = 0; i < bombs && index < empty_cells.size(); ++i, ++index) {\n            int x = empty_cells[index].first;\n            int y = empty_cells[index].second;\n            grid[x][y] = 'B';\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        // Set all treasure values to -200\n        for (int i = 0; i < treasures; ++i) {\n            int value = -200;\n            printf(\"%d\\n\", value);\n        }\n\n    } else if (type == \"obstacles\") {\n        // Fill the map with obstacles except starting position\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(grid[i][j] != 'S')\n                    grid[i][j] = '#';\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // No treasures, so no values to output\n\n    } else if (type == \"n1m1\") {\n        // Map of size 1x1\n        n = 1;\n        m = 1;\n        grid = vector<string>(n, string(m, '.'));\n\n        grid[0][0] = 'S';\n\n        printf(\"%d %d\\n\", n, m);\n        printf(\"%s\\n\", grid[0].c_str());\n\n        // No treasures, so no values to output\n\n    } else if (type == \"full_map\") {\n        // Fill the map completely with treasures\n        n = 20;\n        m = 20;\n        grid = vector<string>(n, string(m, '.'));\n\n        // Starting position\n        grid[0][0] = 'S';\n\n        int treasures = 8;\n\n        int treasure_index = 0;\n\n        for(int i = 0; i < n && treasure_index < treasures; ++i)\n            for(int j = 0; j < m && treasure_index < treasures; ++j)\n                if(grid[i][j] == '.')\n                {\n                    grid[i][j] = '1' + treasure_index;\n                    treasure_index++;\n                }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure values\n        for (int i = 0; i < treasures; ++i) {\n            int value = rnd.next(-200, 200);\n            printf(\"%d\\n\", value);\n        }\n    } else if (type == \"path_needed\") {\n        // Create a map where the only way to get treasure is via a specific path\n\n        // Simple example: create corridors\n\n        n = 5;\n        m = 5;\n        grid = vector<string>(n, string(m, '#'));\n        // Clear a path\n        for(int i = 0; i < n; ++i)\n            grid[i][1] = '.';\n\n        for(int j = 1; j < m; ++j)\n            grid[n - 2][j] = '.';\n\n        // Place starting position\n        grid[0][1] = 'S';\n\n        // Place a treasure at (n-2, m-1)\n        grid[n - 2][m - 1] = '1';\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 0; i < n; ++i)\n            printf(\"%s\\n\", grid[i].c_str());\n\n        // Output treasure value\n        printf(\"200\\n\");\n\n    } else {\n        // default random\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type n1m1\n./gen -type random -n 1 -m 1\n./gen -type random -n 1 -m 20\n./gen -type random -n 20 -m 1\n./gen -type random -n 5 -m 5\n./gen -type random -n 10 -m 10\n./gen -type random -n 15 -m 15\n./gen -type random -n 20 -m 20\n./gen -type max_objects -n 20 -m 20\n./gen -type negative_treasures -n 10 -m 10\n./gen -type negative_treasures -n 20 -m 20\n./gen -type max_treasure_value -n 10 -m 10\n./gen -type max_treasure_value -n 20 -m 20\n./gen -type obstacles -n 15 -m 15\n./gen -type obstacles -n 20 -m 20\n./gen -type path_needed\n./gen -type full_map\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random -n 10 -m 15\n./gen -type random -n 15 -m 10\n./gen -type random -n 7 -m 13\n./gen -type random -n 20 -m 20 -start_i 0 -start_j 0\n./gen -type random -n 20 -m 20 -start_i 19 -start_j 19\n./gen -type random -n 20 -m 20 -bombs 4 -treasures 4\n./gen -type random -n 10 -m 10 -bombs 2 -treasures 1\n./gen -type random -n 4 -m 4 -bombs 2 -treasures 2 -obstacles 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:19.947850",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "377/A",
      "title": "A. Maze",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 500, 0 ≤ k < s), where n and m are the maze's height and width, correspondingly, k is the number of walls Pavel wants to add and letter s represents the number of empty cells in the original maze.Each of the next n lines contains m characters. They describe the original maze. If a character on a line equals \".\", then the corresponding cell is empty and if the character equals \"#\", then the cell is a wall.",
      "output_spec": "OutputPrint n lines containing m characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as \"X\", the other cells must be left without changes (that is, \".\" and \"#\").It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.",
      "sample_tests": "ExamplesInputCopy3 4 2#..#..#.#...OutputCopy#.X#X.#.#...InputCopy5 4 5#...#.#..#.....#.#.#OutputCopy#XXX#X#.X#.....#.#.#",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 500, 0 ≤ k < s), where n and m are the maze's height and width, correspondingly, k is the number of walls Pavel wants to add and letter s represents the number of empty cells in the original maze.Each of the next n lines contains m characters. They describe the original maze. If a character on a line equals \".\", then the corresponding cell is empty and if the character equals \"#\", then the cell is a wall.\n\nOutputPrint n lines containing m characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as \"X\", the other cells must be left without changes (that is, \".\" and \"#\").It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.\n\nInputCopy3 4 2#..#..#.#...OutputCopy#.X#X.#.#...InputCopy5 4 5#...#.#..#.....#.#.#OutputCopy#XXX#X#.X#.....#.#.#\n\nInputCopy3 4 2#..#..#.#...\n\nOutputCopy#.X#X.#.#...\n\nInputCopy5 4 5#...#.#..#.....#.#.#\n\nOutputCopy#XXX#X#.X#.....#.#.#",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 377\\s*A"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n, m, k\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * m, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int s = 0; // Number of empty cells\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readToken();\n        ensuref(int(grid[i].length()) == m, \"Line %d must be of length %d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(grid[i][j] == '.' || grid[i][j] == '#', \"Invalid character '%c' at row %d column %d\", grid[i][j], i + 1, j + 1);\n            if (grid[i][j] == '.') s++;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(k >= 0 && k < s, \"k must satisfy 0 <= k < s, but k=%d, s=%d\", k, s);\n\n    // Check connectivity of empty cells\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<pair<int, int>> q;\n    bool found = false;\n    for (int i = 0; i < n && !found; i++) {\n        for (int j = 0; j < m && !found; j++) {\n            if (grid[i][j] == '.') {\n                q.push({i, j});\n                visited[i][j] = true;\n                found = true;\n            }\n        }\n    }\n    ensuref(found, \"No empty cells found in the grid\");\n    int cnt = 1; // Number of empty cells visited\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; dir++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < n && ny >=0 && ny < m) {\n                if (!visited[nx][ny] && grid[nx][ny] == '.') {\n                    visited[nx][ny] = true;\n                    cnt++;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    ensuref(cnt == s, \"Empty cells are not connected: Only %d out of %d empty cells are reachable\", cnt, s);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n, m, k\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * m, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int s = 0; // Number of empty cells\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readToken();\n        ensuref(int(grid[i].length()) == m, \"Line %d must be of length %d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(grid[i][j] == '.' || grid[i][j] == '#', \"Invalid character '%c' at row %d column %d\", grid[i][j], i + 1, j + 1);\n            if (grid[i][j] == '.') s++;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(k >= 0 && k < s, \"k must satisfy 0 <= k < s, but k=%d, s=%d\", k, s);\n\n    // Check connectivity of empty cells\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<pair<int, int>> q;\n    bool found = false;\n    for (int i = 0; i < n && !found; i++) {\n        for (int j = 0; j < m && !found; j++) {\n            if (grid[i][j] == '.') {\n                q.push({i, j});\n                visited[i][j] = true;\n                found = true;\n            }\n        }\n    }\n    ensuref(found, \"No empty cells found in the grid\");\n    int cnt = 1; // Number of empty cells visited\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; dir++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < n && ny >=0 && ny < m) {\n                if (!visited[nx][ny] && grid[nx][ny] == '.') {\n                    visited[nx][ny] = true;\n                    cnt++;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    ensuref(cnt == s, \"Empty cells are not connected: Only %d out of %d empty cells are reachable\", cnt, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n, m, k\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * m, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int s = 0; // Number of empty cells\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readToken();\n        ensuref(int(grid[i].length()) == m, \"Line %d must be of length %d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(grid[i][j] == '.' || grid[i][j] == '#', \"Invalid character '%c' at row %d column %d\", grid[i][j], i + 1, j + 1);\n            if (grid[i][j] == '.') s++;\n        }\n        inf.readEoln();\n    }\n\n    ensuref(k >= 0 && k < s, \"k must satisfy 0 <= k < s, but k=%d, s=%d\", k, s);\n\n    // Check connectivity of empty cells\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<pair<int, int>> q;\n    bool found = false;\n    for (int i = 0; i < n && !found; i++) {\n        for (int j = 0; j < m && !found; j++) {\n            if (grid[i][j] == '.') {\n                q.push({i, j});\n                visited[i][j] = true;\n                found = true;\n            }\n        }\n    }\n    ensuref(found, \"No empty cells found in the grid\");\n    int cnt = 1; // Number of empty cells visited\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; dir++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < n && ny >=0 && ny < m) {\n                if (!visited[nx][ny] && grid[nx][ny] == '.') {\n                    visited[nx][ny] = true;\n                    cnt++;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    ensuref(cnt == s, \"Empty cells are not connected: Only %d out of %d empty cells are reachable\", cnt, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nvector<string> grid;\nvector<string> output_grid;\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y, vector<vector<bool>>& visited) {\n    visited[x][y] = true;\n    for(int dir = 0; dir < 4; dir++) {\n        int nx = x + dx[dir], ny = y + dy[dir];\n        if(nx >= 0 && nx < n && ny >= 0 && ny < m) {\n            if(output_grid[nx][ny] == '.' && !visited[nx][ny]) {\n                dfs(nx, ny, visited);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt();\n    m = inf.readInt();\n    k = inf.readInt();\n    int s = 0;\n    grid.resize(n);\n    for(int i = 0; i < n; i++) {\n        grid[i] = inf.readToken();\n        if((int)grid[i].length() != m)\n            quitf(_fail, \"Input grid line %d has incorrect length\", i + 1);\n        for(int j = 0; j < m; j++) {\n            if(grid[i][j] == '.')\n                s++;\n            else if(grid[i][j] != '#')\n                quitf(_fail, \"Invalid character '%c' in input grid at (%d, %d)\", grid[i][j], i + 1, j + 1);\n        }\n    }\n    if(k < 0 || k >= s)\n        quitf(_fail, \"Invalid k: %d\", k);\n    output_grid.resize(n);\n    for(int i = 0; i < n; i++) {\n        if(ouf.eof())\n            quitf(_wa, \"Unexpected end of file at line %d\", i + 1);\n        output_grid[i] = ouf.readToken();\n        if((int)output_grid[i].length() != m)\n            quitf(_wa, \"Output grid line %d has incorrect length\", i + 1);\n    }\n    int x_count = 0;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            char in_ch = grid[i][j];\n            char out_ch = output_grid[i][j];\n            if(in_ch == '#') {\n                if(out_ch != '#')\n                    quitf(_wa, \"Cell (%d, %d) should remain '#' in output\", i + 1, j + 1);\n            } else if(in_ch == '.') {\n                if(out_ch == 'X') {\n                    x_count++;\n                } else if(out_ch != '.') {\n                    quitf(_wa, \"Invalid character '%c' at (%d, %d) in output\", out_ch, i + 1, j + 1);\n                }\n            } else {\n                quitf(_fail, \"Invalid character '%c' in input grid at (%d, %d)\", in_ch, i + 1, j + 1);\n            }\n        }\n    }\n    if(x_count != k)\n        quitf(_wa, \"Expected %d 'X's but found %d\", k, x_count);\n    // Check connectivity of '.' cells\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int total_dots = 0;\n    int connected_dots = 0;\n    queue<pair<int,int>> q;\n    bool found_start = false;\n    for(int i = 0; i < n && !found_start; i++) {\n        for(int j = 0; j < m && !found_start; j++) {\n            if(output_grid[i][j] == '.') {\n                q.push({i, j});\n                visited[i][j] = true;\n                found_start = true;\n                connected_dots++;\n            }\n        }\n    }\n    if(!found_start) {\n        quitf(_wa, \"No empty cells ('.') left in output grid\");\n    } else {\n        while(!q.empty()) {\n            int x = q.front().first, y = q.front().second;\n            q.pop();\n            for(int dir = 0; dir < 4; dir++) {\n                int nx = x + dx[dir], ny = y + dy[dir];\n                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    if(output_grid[nx][ny] == '.' && !visited[nx][ny]) {\n                        visited[nx][ny] = true;\n                        q.push({nx, ny});\n                        connected_dots++;\n                    }\n                }\n            }\n        }\n        // Count total dots in output\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++)\n                if(output_grid[i][j] == '.')\n                    total_dots++;\n        if(connected_dots != total_dots)\n            quitf(_wa, \"The empty cells are not connected\");\n    }\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_maze(int n, int m, vector<string>& grid) {\n    grid.assign(n, string(m, '#'));\n    vector<vector<bool> > visited(n, vector<bool>(m, false));\n\n    int sx = rnd.next(0, n-1);\n    int sy = rnd.next(0, m-1);\n\n    stack<pair<int, int> > stk;\n    stk.push({sx, sy});\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {-1, 0, 1, 0};\n\n    while (!stk.empty()) {\n        int x = stk.top().first;\n        int y = stk.top().second;\n        stk.pop();\n\n        if (visited[x][y]) continue;\n        visited[x][y] = true;\n        grid[x][y] = '.';\n\n        vector<int> dirs = {0, 1, 2, 3};\n        shuffle(dirs.begin(), dirs.end());\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[dirs[i]];\n            int ny = y + dy[dirs[i]];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                if (!visited[nx][ny]) {\n                    stk.push({nx, ny});\n                }\n            }\n        }\n    }\n}\n\nvoid generate_full_maze(int n, int m, vector<string>& grid) {\n    grid.assign(n, string(m, '.'));\n}\n\nvoid generate_snake_maze(int n, int m, vector<string>& grid) {\n    grid.assign(n, string(m, '#'));\n    int x = 0, y = 0;\n    bool dir = true; // true: right, false: left\n\n    while (x < n) {\n        if (dir) {\n            for (y = 0; y < m; ++y)\n                grid[x][y] = '.';\n        } else {\n            for (y = m-1; y >=0; --y)\n                grid[x][y] = '.';\n        }\n        x++;\n        dir = !dir;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid;\n\n    if (type == \"random\") {\n        generate_random_maze(n, m, grid);\n    } else if (type == \"full\") {\n        generate_full_maze(n, m, grid);\n    } else if (type == \"snake\") {\n        generate_snake_maze(n, m, grid);\n    } else {\n        // Default to full maze\n        generate_full_maze(n, m, grid);\n    }\n\n    // Count number of empty cells\n    int s = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            if (grid[i][j] == '.')\n                ++s;\n\n    if (k < 0 || k >= s) {\n        // Adjust k to be valid\n        k = rnd.next(0, s-1);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_maze(int n, int m, vector<string>& grid) {\n    grid.assign(n, string(m, '#'));\n    vector<vector<bool> > visited(n, vector<bool>(m, false));\n\n    int sx = rnd.next(0, n-1);\n    int sy = rnd.next(0, m-1);\n\n    stack<pair<int, int> > stk;\n    stk.push({sx, sy});\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {-1, 0, 1, 0};\n\n    while (!stk.empty()) {\n        int x = stk.top().first;\n        int y = stk.top().second;\n        stk.pop();\n\n        if (visited[x][y]) continue;\n        visited[x][y] = true;\n        grid[x][y] = '.';\n\n        vector<int> dirs = {0, 1, 2, 3};\n        shuffle(dirs.begin(), dirs.end());\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[dirs[i]];\n            int ny = y + dy[dirs[i]];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                if (!visited[nx][ny]) {\n                    stk.push({nx, ny});\n                }\n            }\n        }\n    }\n}\n\nvoid generate_full_maze(int n, int m, vector<string>& grid) {\n    grid.assign(n, string(m, '.'));\n}\n\nvoid generate_snake_maze(int n, int m, vector<string>& grid) {\n    grid.assign(n, string(m, '#'));\n    int x = 0, y = 0;\n    bool dir = true; // true: right, false: left\n\n    while (x < n) {\n        if (dir) {\n            for (y = 0; y < m; ++y)\n                grid[x][y] = '.';\n        } else {\n            for (y = m-1; y >=0; --y)\n                grid[x][y] = '.';\n        }\n        x++;\n        dir = !dir;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid;\n\n    if (type == \"random\") {\n        generate_random_maze(n, m, grid);\n    } else if (type == \"full\") {\n        generate_full_maze(n, m, grid);\n    } else if (type == \"snake\") {\n        generate_snake_maze(n, m, grid);\n    } else {\n        // Default to full maze\n        generate_full_maze(n, m, grid);\n    }\n\n    // Count number of empty cells\n    int s = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            if (grid[i][j] == '.')\n                ++s;\n\n    if (k < 0 || k >= s) {\n        // Adjust k to be valid\n        k = rnd.next(0, s-1);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small size grids\n./gen -n 3 -m 3 -k 0 -type full\n./gen -n 3 -m 3 -k 1 -type full\n./gen -n 3 -m 3 -k 2 -type full\n./gen -n 3 -m 3 -k 0 -type random\n./gen -n 3 -m 3 -k 1 -type random\n./gen -n 3 -m 3 -k 2 -type random\n./gen -n 3 -m 3 -k 0 -type snake\n./gen -n 3 -m 3 -k 1 -type snake\n./gen -n 3 -m 3 -k 2 -type snake\n\n# Medium size grids\n./gen -n 50 -m 50 -k 0 -type full\n./gen -n 50 -m 50 -k 100 -type full\n./gen -n 50 -m 50 -k 2499 -type full\n./gen -n 50 -m 50 -k 0 -type random\n./gen -n 50 -m 50 -k -1 -type random\n./gen -n 50 -m 50 -k 5000 -type random\n./gen -n 50 -m 50 -k 0 -type snake\n./gen -n 50 -m 50 -k 100 -type snake\n./gen -n 50 -m 50 -k 2499 -type snake\n\n# Large size grids\n./gen -n 500 -m 500 -k 0 -type full\n./gen -n 500 -m 500 -k 10000 -type full\n./gen -n 500 -m 500 -k 249999 -type full\n./gen -n 500 -m 500 -k 0 -type random\n./gen -n 500 -m 500 -k -1 -type random\n./gen -n 500 -m 500 -k 1000000 -type random\n./gen -n 500 -m 500 -k 0 -type snake\n./gen -n 500 -m 500 -k 10000 -type snake\n./gen -n 500 -m 500 -k 249999 -type snake\n\n# Edge cases\n./gen -n 1 -m 500 -k 0 -type full\n./gen -n 500 -m 1 -k 0 -type full\n./gen -n 1 -m 1 -k 0 -type full\n\n# k equals s-1\n./gen -n 10 -m 10 -k 99 -type full\n\n# Max k\n./gen -n 500 -m 500 -k 249999 -type random\n\n# k equals 0\n./gen -n 100 -m 100 -k 0 -type random\n\n# k equals s/2\n./gen -n 200 -m 200 -k 20000 -type random\n\n# Minimum size\n./gen -n 1 -m 1 -k 0 -type random\n\n# Random sizes and types\n./gen -n 123 -m 456 -k 0 -type random\n./gen -n 234 -m 567 -k 0 -type snake\n./gen -n 345 -m 678 -k 0 -type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:21.960769",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "377/B",
      "title": "B. Preparing for the Contest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers: n, m and s (1 ≤ n, m ≤ 105, 0 ≤ s ≤ 109) — the number of students, the number of bugs in the system and the maximum number of passes the university is ready to give the students.The next line contains m space-separated integers a1, a2, ..., am (1 ≤ ai ≤ 109) — the bugs' complexities.The next line contains n space-separated integers b1, b2, ..., bn (1 ≤ bi ≤ 109) — the levels of the students' abilities.The next line contains n space-separated integers c1, c2, ..., cn (0 ≤ ci ≤ 109) — the numbers of the passes the students want to get for their help.",
      "output_spec": "OutputIf the university can't correct all bugs print \"NO\".Otherwise, on the first line print \"YES\", and on the next line print m space-separated integers: the i-th of these numbers should equal the number of the student who corrects the i-th bug in the optimal answer. The bugs should be corrected as quickly as possible (you must spend the minimum number of days), and the total given passes mustn't exceed s. If there are multiple optimal answers, you can output any of them.",
      "sample_tests": "ExamplesInputCopy3 4 91 3 1 22 1 34 3 6OutputCopyYES2 3 2 3InputCopy3 4 102 3 1 22 1 34 3 6OutputCopyYES1 3 1 3InputCopy3 4 92 3 1 22 1 34 3 6OutputCopyYES3 3 2 3InputCopy3 4 51 3 1 22 1 35 3 6OutputCopyNO",
      "description": "B. Preparing for the Contest\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers: n, m and s (1 ≤ n, m ≤ 105, 0 ≤ s ≤ 109) — the number of students, the number of bugs in the system and the maximum number of passes the university is ready to give the students.The next line contains m space-separated integers a1, a2, ..., am (1 ≤ ai ≤ 109) — the bugs' complexities.The next line contains n space-separated integers b1, b2, ..., bn (1 ≤ bi ≤ 109) — the levels of the students' abilities.The next line contains n space-separated integers c1, c2, ..., cn (0 ≤ ci ≤ 109) — the numbers of the passes the students want to get for their help.\n\nOutputIf the university can't correct all bugs print \"NO\".Otherwise, on the first line print \"YES\", and on the next line print m space-separated integers: the i-th of these numbers should equal the number of the student who corrects the i-th bug in the optimal answer. The bugs should be corrected as quickly as possible (you must spend the minimum number of days), and the total given passes mustn't exceed s. If there are multiple optimal answers, you can output any of them.\n\nInputCopy3 4 91 3 1 22 1 34 3 6OutputCopyYES2 3 2 3InputCopy3 4 102 3 1 22 1 34 3 6OutputCopyYES1 3 1 3InputCopy3 4 92 3 1 22 1 34 3 6OutputCopyYES3 3 2 3InputCopy3 4 51 3 1 22 1 35 3 6OutputCopyNO\n\nInputCopy3 4 91 3 1 22 1 34 3 6\n\nOutputCopyYES2 3 2 3\n\nInputCopy3 4 102 3 1 22 1 34 3 6\n\nOutputCopyYES1 3 1 3\n\nInputCopy3 4 92 3 1 22 1 34 3 6\n\nOutputCopyYES3 3 2 3\n\nInputCopy3 4 51 3 1 22 1 35 3 6\n\nOutputCopyNO\n\nNoteConsider the first sample.The third student (with level 3) must fix the 2nd and 4th bugs (complexities 3 and 2 correspondingly) and the second student (with level 1) must fix the 1st and 3rd bugs (their complexity also equals 1). Fixing each bug takes one day for each student, so it takes 2 days to fix all bugs (the students can work in parallel).The second student wants 3 passes for his assistance, the third student wants 6 passes. It meets the university's capabilities as it is ready to give at most 9 passes.",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 377\\s*B"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nlong long s;\nvector<int> a, b, c;\n\nint readAns(InStream& stream) {\n    string res = stream.readToken();\n\n    if (res == \"NO\") {\n        return -1;  // Impossible to fix all bugs\n    } else if (res != \"YES\") {\n        stream.quitf(_pe, \"Expected 'YES' or 'NO', found '%s'\", res.c_str());\n    }\n\n    // Reading the assignment\n    vector<int> assignment(m);\n    for (int i = 0; i < m; i++) {\n        assignment[i] = stream.readInt(1, n, format(\"student assigned to bug %d\", i + 1).c_str());\n    }\n\n    // Validate the assignment\n    long long total_passes = 0;\n    vector<int> studentBugCount(n, 0);\n    set<int> students_used;\n    for (int i = 0; i < m; i++) {\n        int student_id = assignment[i];\n        int student_index = student_id - 1;  // zero-based index\n        int bug_index = i;\n        if (b[student_index] < a[bug_index]) {\n            stream.quitf(_wa, \"Student %d cannot fix bug %d\", student_id, bug_index + 1);\n        }\n        studentBugCount[student_index]++;\n        students_used.insert(student_id);\n    }\n\n    // Each student cannot fix more than one bug per day\n    int D = 0;\n    for (int i = 0; i < n; i++) {\n        D = max(D, studentBugCount[i]);\n    }\n\n    // Check total passes\n    for (int student_id : students_used) {\n        total_passes += c[student_id - 1];\n    }\n    if (total_passes > s) {\n        stream.quitf(_wa, \"Total passes %lld exceed limit %lld\", total_passes, s);\n    }\n\n    return D;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Reading input\n    n = inf.readInt();\n    m = inf.readInt();\n    s = inf.readLong();\n\n    a.resize(m);\n    for(int i = 0; i < m; i++) {\n        a[i] = inf.readInt();\n    }\n\n    b.resize(n);\n    for(int i = 0; i < n; i++) {\n        b[i] = inf.readInt();\n    }\n\n    c.resize(n);\n    for(int i = 0; i < n; i++) {\n        c[i] = inf.readInt();\n    }\n\n    int juryD = readAns(ans);\n    int participantD = readAns(ouf);\n\n    if (juryD == -1) {\n        if (participantD == -1) {\n            quitf(_ok, \"Both outputs are 'NO'\");\n        } else {\n            quitf(_fail, \"Participant found a solution but jury did not\");\n        }\n    } else {\n        if (participantD == -1) {\n            quitf(_wa, \"Participant did not find a solution\");\n        } else if (participantD > juryD) {\n            quitf(_wa, \"Participant's answer uses more days than minimal possible (%d > %d)\", participantD, juryD);\n        } else if (participantD == juryD) {\n            quitf(_ok, \"Correct answer with minimal days %d\", participantD);\n        } else {\n            quitf(_fail, \"Participant has a better answer with fewer days (%d < %d)\", participantD, juryD);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command-line options\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(m);\n    vector<int> bi(n);\n    vector<int> ci(n);\n\n    if (type == \"random\") {\n        // Generate ai\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        // Generate bi and ci\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        // Generate s if not given\n        if (s == -1) {\n            s = rnd.next(0LL, 1000000000LL);\n        }\n    }\n    else if (type == \"max_s\") {\n        // s is large\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        if (s == -1) {\n            s = 1000000000;\n        }\n    }\n    else if (type == \"min_s\") {\n        // s is minimal: sum of ci of necessary students\n        n = m;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n            bi[i] = ai[i];\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        long long total_ci = 0;\n        for (int i = 0; i < n; ++i) total_ci += ci[i];\n        if (s == -1) {\n            s = min(total_ci, 1000000000LL);\n        }\n    }\n    else if (type == \"impossible\") {\n        // s is too low, so total ci of necessary students exceeds s\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(1000000000 - 10, 1000000000);\n        }\n        if (s == -1) {\n            s = rnd.next(0, 1000000000 / 100);\n        }\n    }\n    else if (type == \"abilities_equal_complexities\") {\n        n = m;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n            bi[i] = ai[i];\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        long long total_ci = 0;\n        for (int i = 0; i < n; ++i) total_ci += ci[i];\n        if (s == -1){\n            s = min(total_ci, 1000000000LL);\n        }\n    }\n    else {\n        // Default to random\n        // Generate ai\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        // Generate bi and ci\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        // Generate s if not given\n        if (s == -1) {\n            s = rnd.next(0LL, 1000000000LL);\n        }\n    }\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, s);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < m) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", bi[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ci[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command-line options\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(m);\n    vector<int> bi(n);\n    vector<int> ci(n);\n\n    if (type == \"random\") {\n        // Generate ai\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        // Generate bi and ci\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        // Generate s if not given\n        if (s == -1) {\n            s = rnd.next(0LL, 1000000000LL);\n        }\n    }\n    else if (type == \"max_s\") {\n        // s is large\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        if (s == -1) {\n            s = 1000000000;\n        }\n    }\n    else if (type == \"min_s\") {\n        // s is minimal: sum of ci of necessary students\n        n = m;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n            bi[i] = ai[i];\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        long long total_ci = 0;\n        for (int i = 0; i < n; ++i) total_ci += ci[i];\n        if (s == -1) {\n            s = min(total_ci, 1000000000LL);\n        }\n    }\n    else if (type == \"impossible\") {\n        // s is too low, so total ci of necessary students exceeds s\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(1000000000 - 10, 1000000000);\n        }\n        if (s == -1) {\n            s = rnd.next(0, 1000000000 / 100);\n        }\n    }\n    else if (type == \"abilities_equal_complexities\") {\n        n = m;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n            bi[i] = ai[i];\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        long long total_ci = 0;\n        for (int i = 0; i < n; ++i) total_ci += ci[i];\n        if (s == -1){\n            s = min(total_ci, 1000000000LL);\n        }\n    }\n    else {\n        // Default to random\n        // Generate ai\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        // Generate bi and ci\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(0, 1000000000);\n        }\n        // Generate s if not given\n        if (s == -1) {\n            s = rnd.next(0LL, 1000000000LL);\n        }\n    }\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, s);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < m) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", bi[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ci[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type impossible\n./gen -n 1 -m 1 -s 0 -type random\n\n./gen -n 2 -m 2 -type min_s\n./gen -n 2 -m 2 -s 0 -type impossible\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type max_s\n./gen -n 10 -m 10 -type min_s\n./gen -n 10 -m 10 -type impossible\n./gen -n 10 -m 10 -type abilities_equal_complexities\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type max_s\n./gen -n 100 -m 100 -type min_s\n./gen -n 100 -m 100 -type impossible\n./gen -n 100 -m 100 -type abilities_equal_complexities\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type max_s\n./gen -n 1000 -m 1000 -type min_s\n./gen -n 1000 -m 1000 -type impossible\n./gen -n 1000 -m 1000 -type abilities_equal_complexities\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type max_s\n./gen -n 100000 -m 100000 -type min_s\n./gen -n 100000 -m 100000 -type impossible\n./gen -n 100000 -m 100000 -type abilities_equal_complexities\n\n./gen -n 100000 -m 1 -type max_s\n./gen -n 1 -m 100000 -type impossible\n\n./gen -n 50000 -m 50000 -type random\n./gen -n 50000 -m 50000 -type min_s\n./gen -n 50000 -m 50000 -type impossible\n./gen -n 50000 -m 50000 -type abilities_equal_complexities\n\n./gen -n 99999 -m 99999 -type random\n\n./gen -n 1 -m 1 -s 1000000000 -type random\n./gen -n 100000 -m 100000 -s 0 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:24.531762",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "377/C",
      "title": "C. Captains Mode",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 100) — the number of heroes in Dota 2.The second line contains n integers s1, s2, ..., sn (1 ≤ si ≤ 106) — the strengths of all the heroes.The third line contains a single integer m (2 ≤ m ≤ min(n, 20)) — the number of actions the captains of the team must perform.Next m lines look like \"action team\", where action is the needed action: a pick (represented as a \"p\") or a ban (represented as a \"b\"), and team is the number of the team that needs to perform the action (number 1 or 2).It is guaranteed that each team makes at least one pick. Besides, each team has the same number of picks and the same number of bans.",
      "output_spec": "OutputPrint a single integer — the difference between the strength of the first team and the strength of the second team if the captains of both teams will act optimally well.",
      "sample_tests": "ExamplesInputCopy22 12p 1p 2OutputCopy1InputCopy66 4 5 4 5 54b 2p 1b 1p 2OutputCopy0InputCopy41 2 3 44p 2b 2p 1b 1OutputCopy-2",
      "description": "C. Captains Mode\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 100) — the number of heroes in Dota 2.The second line contains n integers s1, s2, ..., sn (1 ≤ si ≤ 106) — the strengths of all the heroes.The third line contains a single integer m (2 ≤ m ≤ min(n, 20)) — the number of actions the captains of the team must perform.Next m lines look like \"action team\", where action is the needed action: a pick (represented as a \"p\") or a ban (represented as a \"b\"), and team is the number of the team that needs to perform the action (number 1 or 2).It is guaranteed that each team makes at least one pick. Besides, each team has the same number of picks and the same number of bans.\n\nOutputPrint a single integer — the difference between the strength of the first team and the strength of the second team if the captains of both teams will act optimally well.\n\nInputCopy22 12p 1p 2OutputCopy1InputCopy66 4 5 4 5 54b 2p 1b 1p 2OutputCopy0InputCopy41 2 3 44p 2b 2p 1b 1OutputCopy-2\n\nInputCopy22 12p 1p 2\n\nOutputCopy1\n\nInputCopy66 4 5 4 5 54b 2p 1b 1p 2\n\nOutputCopy0\n\nInputCopy41 2 3 44p 2b 2p 1b 1\n\nOutputCopy-2",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 377\\s*C"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint pickCounts[3]; // indexes 1 and 2\nint banCounts[3];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n\n    int m = inf.readInt(2, min(n, 20), \"m\");\n    inf.readEoln();\n\n    pickCounts[1] = pickCounts[2] = 0;\n    banCounts[1] = banCounts[2] = 0;\n\n    for (int i = 0; i < m; i++) {\n        char action = inf.readChar();\n        ensuref(action == 'p' || action == 'b', \"Action must be 'p' or 'b', but found '%c' on line %d\", action, i + 4);\n\n        inf.readSpace();\n\n        int team = inf.readInt(1, 2, \"team\");\n\n        inf.readEoln();\n\n        if (action == 'p') {\n            pickCounts[team]++;\n        } else {\n            banCounts[team]++;\n        }\n    }\n\n    // Each team makes at least one pick\n    ensuref(pickCounts[1] >= 1, \"Team 1 must make at least one pick\");\n    ensuref(pickCounts[2] >= 1, \"Team 2 must make at least one pick\");\n\n    // Each team has the same number of picks\n    ensuref(pickCounts[1] == pickCounts[2], \"Both teams must have the same number of picks\");\n\n    // Each team has the same number of bans\n    ensuref(banCounts[1] == banCounts[2], \"Both teams must have the same number of bans\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint pickCounts[3]; // indexes 1 and 2\nint banCounts[3];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n\n    int m = inf.readInt(2, min(n, 20), \"m\");\n    inf.readEoln();\n\n    pickCounts[1] = pickCounts[2] = 0;\n    banCounts[1] = banCounts[2] = 0;\n\n    for (int i = 0; i < m; i++) {\n        char action = inf.readChar();\n        ensuref(action == 'p' || action == 'b', \"Action must be 'p' or 'b', but found '%c' on line %d\", action, i + 4);\n\n        inf.readSpace();\n\n        int team = inf.readInt(1, 2, \"team\");\n\n        inf.readEoln();\n\n        if (action == 'p') {\n            pickCounts[team]++;\n        } else {\n            banCounts[team]++;\n        }\n    }\n\n    // Each team makes at least one pick\n    ensuref(pickCounts[1] >= 1, \"Team 1 must make at least one pick\");\n    ensuref(pickCounts[2] >= 1, \"Team 2 must make at least one pick\");\n\n    // Each team has the same number of picks\n    ensuref(pickCounts[1] == pickCounts[2], \"Both teams must have the same number of picks\");\n\n    // Each team has the same number of bans\n    ensuref(banCounts[1] == banCounts[2], \"Both teams must have the same number of bans\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint pickCounts[3]; // indexes 1 and 2\nint banCounts[3];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n\n    int m = inf.readInt(2, min(n, 20), \"m\");\n    inf.readEoln();\n\n    pickCounts[1] = pickCounts[2] = 0;\n    banCounts[1] = banCounts[2] = 0;\n\n    for (int i = 0; i < m; i++) {\n        char action = inf.readChar();\n        ensuref(action == 'p' || action == 'b', \"Action must be 'p' or 'b', but found '%c' on line %d\", action, i + 4);\n\n        inf.readSpace();\n\n        int team = inf.readInt(1, 2, \"team\");\n\n        inf.readEoln();\n\n        if (action == 'p') {\n            pickCounts[team]++;\n        } else {\n            banCounts[team]++;\n        }\n    }\n\n    // Each team makes at least one pick\n    ensuref(pickCounts[1] >= 1, \"Team 1 must make at least one pick\");\n    ensuref(pickCounts[2] >= 1, \"Team 2 must make at least one pick\");\n\n    // Each team has the same number of picks\n    ensuref(pickCounts[1] == pickCounts[2], \"Both teams must have the same number of picks\");\n\n    // Each team has the same number of bans\n    ensuref(banCounts[1] == banCounts[2], \"Both teams must have the same number of bans\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n within [2, 100]\n    n = max(2, min(n, 100));\n\n    // Ensure m is even and within [2, min(n, 20)]\n    m = min(m, min(n, 20));\n    if (m % 2 != 0) {\n        m--;\n    }\n    m = max(m, 2);\n\n    // Generate the strengths s_i\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_strength\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 1000000;\n        }\n    } else if (type == \"all_equal_strength\") {\n        int s_val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            s[i] = s_val;\n        }\n    } else if (type == \"increasing_strength\") {\n        int s_val = 1;\n        for (int i = 0; i < n; ++i) {\n            s[i] = s_val;\n            s_val += rnd.next(1, 10);\n        }\n    } else if (type == \"decreasing_strength\") {\n        int s_val = 1000000;\n        for (int i = 0; i < n; ++i) {\n            s[i] = s_val;\n            s_val -= rnd.next(1, 10);\n            if (s_val < 1) s_val = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Generate actions\n    vector<pair<char,int>> actions; // pair<action, team>\n\n    int actions_per_team = m / 2;\n\n    int picks_per_team;\n    int bans_per_team;\n\n    if (type == \"all_picks\") {\n        picks_per_team = actions_per_team;\n        bans_per_team = 0;\n    } else if (type == \"all_bans\") {\n        picks_per_team = 1; // At least one pick per team\n        bans_per_team = actions_per_team - picks_per_team;\n    } else if (type == \"alternating_actions\") {\n        picks_per_team = max(1, actions_per_team / 2);\n        bans_per_team = actions_per_team - picks_per_team;\n    } else {\n        // Random\n        picks_per_team = rnd.next(1, actions_per_team);\n        bans_per_team = actions_per_team - picks_per_team;\n    }\n\n    // Prepare action lists for each team\n    vector<pair<char,int>> team1_actions_list;\n    vector<pair<char,int>> team2_actions_list;\n    for (int i = 0; i < picks_per_team; ++i) {\n        team1_actions_list.push_back({'p', 1});\n        team2_actions_list.push_back({'p', 2});\n    }\n    for (int i = 0; i < bans_per_team; ++i) {\n        team1_actions_list.push_back({'b', 1});\n        team2_actions_list.push_back({'b', 2});\n    }\n\n    // Shuffle actions within teams\n    shuffle(team1_actions_list.begin(), team1_actions_list.end());\n    shuffle(team2_actions_list.begin(), team2_actions_list.end());\n\n    // Generate action sequence according to type\n    if (type == \"alternating_actions\") {\n        vector<pair<char,int>> action_sequence;\n        size_t idx1 = 0, idx2 = 0;\n        while (idx1 < team1_actions_list.size() || idx2 < team2_actions_list.size()) {\n            if (idx1 < team1_actions_list.size()) {\n                action_sequence.push_back(team1_actions_list[idx1++]);\n            }\n            if (idx2 < team2_actions_list.size()) {\n                action_sequence.push_back(team2_actions_list[idx2++]);\n            }\n        }\n        actions = action_sequence;\n    } else if (type == \"team1_picks_first\") {\n        actions = team1_actions_list;\n        actions.insert(actions.end(), team2_actions_list.begin(), team2_actions_list.end());\n    } else if (type == \"team2_picks_first\") {\n        actions = team2_actions_list;\n        actions.insert(actions.end(), team1_actions_list.begin(), team1_actions_list.end());\n    } else {\n        // Randomly shuffle all actions\n        vector<pair<char,int>> all_actions = team1_actions_list;\n        all_actions.insert(all_actions.end(), team2_actions_list.begin(), team2_actions_list.end());\n        shuffle(all_actions.begin(), all_actions.end());\n        actions = all_actions;\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i+1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%c %d\\n\", actions[i].first, actions[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n within [2, 100]\n    n = max(2, min(n, 100));\n\n    // Ensure m is even and within [2, min(n, 20)]\n    m = min(m, min(n, 20));\n    if (m % 2 != 0) {\n        m--;\n    }\n    m = max(m, 2);\n\n    // Generate the strengths s_i\n    vector<int> s(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_strength\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 1000000;\n        }\n    } else if (type == \"all_equal_strength\") {\n        int s_val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            s[i] = s_val;\n        }\n    } else if (type == \"increasing_strength\") {\n        int s_val = 1;\n        for (int i = 0; i < n; ++i) {\n            s[i] = s_val;\n            s_val += rnd.next(1, 10);\n        }\n    } else if (type == \"decreasing_strength\") {\n        int s_val = 1000000;\n        for (int i = 0; i < n; ++i) {\n            s[i] = s_val;\n            s_val -= rnd.next(1, 10);\n            if (s_val < 1) s_val = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Generate actions\n    vector<pair<char,int>> actions; // pair<action, team>\n\n    int actions_per_team = m / 2;\n\n    int picks_per_team;\n    int bans_per_team;\n\n    if (type == \"all_picks\") {\n        picks_per_team = actions_per_team;\n        bans_per_team = 0;\n    } else if (type == \"all_bans\") {\n        picks_per_team = 1; // At least one pick per team\n        bans_per_team = actions_per_team - picks_per_team;\n    } else if (type == \"alternating_actions\") {\n        picks_per_team = max(1, actions_per_team / 2);\n        bans_per_team = actions_per_team - picks_per_team;\n    } else {\n        // Random\n        picks_per_team = rnd.next(1, actions_per_team);\n        bans_per_team = actions_per_team - picks_per_team;\n    }\n\n    // Prepare action lists for each team\n    vector<pair<char,int>> team1_actions_list;\n    vector<pair<char,int>> team2_actions_list;\n    for (int i = 0; i < picks_per_team; ++i) {\n        team1_actions_list.push_back({'p', 1});\n        team2_actions_list.push_back({'p', 2});\n    }\n    for (int i = 0; i < bans_per_team; ++i) {\n        team1_actions_list.push_back({'b', 1});\n        team2_actions_list.push_back({'b', 2});\n    }\n\n    // Shuffle actions within teams\n    shuffle(team1_actions_list.begin(), team1_actions_list.end());\n    shuffle(team2_actions_list.begin(), team2_actions_list.end());\n\n    // Generate action sequence according to type\n    if (type == \"alternating_actions\") {\n        vector<pair<char,int>> action_sequence;\n        size_t idx1 = 0, idx2 = 0;\n        while (idx1 < team1_actions_list.size() || idx2 < team2_actions_list.size()) {\n            if (idx1 < team1_actions_list.size()) {\n                action_sequence.push_back(team1_actions_list[idx1++]);\n            }\n            if (idx2 < team2_actions_list.size()) {\n                action_sequence.push_back(team2_actions_list[idx2++]);\n            }\n        }\n        actions = action_sequence;\n    } else if (type == \"team1_picks_first\") {\n        actions = team1_actions_list;\n        actions.insert(actions.end(), team2_actions_list.begin(), team2_actions_list.end());\n    } else if (type == \"team2_picks_first\") {\n        actions = team2_actions_list;\n        actions.insert(actions.end(), team1_actions_list.begin(), team1_actions_list.end());\n    } else {\n        // Randomly shuffle all actions\n        vector<pair<char,int>> all_actions = team1_actions_list;\n        all_actions.insert(all_actions.end(), team2_actions_list.begin(), team2_actions_list.end());\n        shuffle(all_actions.begin(), all_actions.end());\n        actions = all_actions;\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i+1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%c %d\\n\", actions[i].first, actions[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type random\n./gen -n 4 -m 4 -type random\n./gen -n 10 -m 6 -type increasing_strength\n./gen -n 20 -m 8 -type decreasing_strength\n./gen -n 50 -m 10 -type all_equal_strength\n./gen -n 100 -m 20 -type max_strength\n./gen -n 100 -m 20 -type random\n./gen -n 100 -m 20 -type all_picks\n./gen -n 100 -m 20 -type all_bans\n./gen -n 100 -m 20 -type alternating_actions\n./gen -n 100 -m 20 -type team1_picks_first\n./gen -n 100 -m 20 -type team2_picks_first\n./gen -n 100 -m 20 -type random\n./gen -n 50 -m 10 -type random\n./gen -n 30 -m 6 -type random\n./gen -n 2 -m 2 -type all_equal_strength\n./gen -n 2 -m 2 -type max_strength\n./gen -n 4 -m 4 -type all_bans\n./gen -n 4 -m 4 -type all_picks\n./gen -n 6 -m 6 -type increasing_strength\n./gen -n 6 -m 6 -type decreasing_strength\n./gen -n 20 -m 18 -type alternating_actions\n./gen -n 20 -m 20 -type random\n./gen -n 15 -m 10 -type random\n./gen -n 100 -m 20 -type random\n./gen -n 30 -m 8 -type alternating_actions\n./gen -n 40 -m 8 -type team1_picks_first\n./gen -n 40 -m 8 -type team2_picks_first\n./gen -n 100 -m 14 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:26.764037",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "377/D",
      "title": "D. Разработка игры",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится единственное целое число n (1 ≤ n ≤ 105) — количество сотрудников, нанятых Павлом.В каждой из следующих n строк содержатся три целых числа li, vi, ri (1 ≤ li ≤ vi ≤ ri ≤ 3·105), записанные через пробел — минимальное значение скилла сотрудников, с которыми готов вместе работать i-ый сотрудник, скилл самого i-ого сотрудника, и максимальное значение скилла сотрудников, с которыми готов вместе работать i-ый сотрудник.",
      "output_spec": "Выходные данныеВ первой строке выведите единственное целое число m — количество сотрудников, которых Павел должен направить на разработку игры.В следующей строке выведите m целых чисел через пробел — номера этих сотрудников, в любом порядке.Если существует несколько оптимальных решений, выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать42 8 91 4 73 6 85 8 10Выходные данныеСкопировать31 3 4Входные данныеСкопировать63 5 161 6 114 8 127 9 162 10 148 13 15Выходные данныеСкопировать41 2 3 5",
      "description": "D. Разработка игры\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке находится единственное целое число n (1 ≤ n ≤ 105) — количество сотрудников, нанятых Павлом.В каждой из следующих n строк содержатся три целых числа li, vi, ri (1 ≤ li ≤ vi ≤ ri ≤ 3·105), записанные через пробел — минимальное значение скилла сотрудников, с которыми готов вместе работать i-ый сотрудник, скилл самого i-ого сотрудника, и максимальное значение скилла сотрудников, с которыми готов вместе работать i-ый сотрудник.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите единственное целое число m — количество сотрудников, которых Павел должен направить на разработку игры.В следующей строке выведите m целых чисел через пробел — номера этих сотрудников, в любом порядке.Если существует несколько оптимальных решений, выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать42 8 91 4 73 6 85 8 10Выходные данныеСкопировать31 3 4Входные данныеСкопировать63 5 161 6 114 8 127 9 162 10 148 13 15Выходные данныеСкопировать41 2 3 5\n\nВходные данныеСкопировать42 8 91 4 73 6 85 8 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 3 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать63 5 161 6 114 8 127 9 162 10 148 13 15\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать41 2 3 5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Всем привет!Авторы сегодняшнего раунда — craus и dalex. Мы не могли просто так пропустить раунд с таким красивым номером, поэтому в 19.30 MSK вам придется решать задачи, которые Павел для вас придумал, а я подготовил.Благодарим Gerald и Delinur за помощь в подготовке соревнования и MikeMirzayanov за то, что у нас есть Codeforces.Систему подсчета баллов и их распределение вы узнаете вместе с началом раунда. Все равно эта информация не несет особого смысла, пока контест не начался.Полных решений и успешных взломов!UPD. Контест завершился, поздравляем победителей!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 674
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces",
          "content": "На всякий случай, ссылка на анонс и обсуждение.А теперь разбор.A div 2: 378A - Игра с кубикомЗаведем три счетчика: для побед каждого из игроков и для ничьи. Переберем все варианты, как можно выбросить кубик — их всего 6 штук. Для каждого варианта определим, кто выиграет, или будет ли ничья, и прибавим единицу к соответствующему счетчику.B div 2: 378B - ПолуфиналыМожно немного подумать и понять, что достаточно рассмотреть крайние случаи k = 0 и . Все остальные случаи будут средними между этими двумя.В случае k = 0 мы должны выбрать n максимальных элементов из двух посорченных списков, это можно сделать, например, двумя указателями. А в случае отметим первых спортсменов в каждом списке.A div 1 / C div 2: 377A - ЛабиринтЗапустим поиск в ширину или в глубину из любой свободной клетки. Так как лабиринт связный, этот поиск обойдет все s свободных клеток. Однако мы прервем этот поиск на том моменте, когда он посетит s - k свободных клеток. Очевидно, эти s - k клеток образуют связную область. Оставшиеся k клеток просто превратим в стены.Претесты проходило также решение, каждым ходом превращающее в стену ту клетку, у которой меньше всего соседей. Это неверно, например, на следующем тесте: ....\n.#..\n..##\n..##У левой верхней клетки не большее число соседей, чем у любой другой, однако ее нельзя превращать в стену.B div 1 / D div 2: 377B - Подготовка к соревнованиюОчевидно, что время исправления всех багов — функция монотонная: если можем сделать все за какое-то время, то сможем и за большее, поэтому будем искать ответ бинарным поиском. Так что пусть мы знаем время, за которое надо исправить все баги. Проверим, можно ли это сделать.Вначале отсортируем баги по сложности, а студентов по скиллу (это можно сделать один раз вне бинарного поиска). Посмотрим на самый сложный баг. Кто мог бы его исправить? Очевидно, его могут исправить те студенты, чей скилл не меньше сложности бага. Поместим всех таких студентов в очередь с приоритетами (в которой будет сортировка по стоимости студентов) и выберем оттуда самого дешевого. Так как мы проверяем время t, то этот студент должен пофиксить t самых сложных багов (он точно может их пофиксить). Отметим это, и перейдем к рассмотрению следующего непофикшенного бага. Снова поместим всех студентов, которые могли бы его исправить (по студентам надо проходиться параллельно с багами), в очередь с приоритетами и выберем самого дешевого. И так далее. Если в какой-то момент оказалось, что текущий баг не может исправить ни один студент (очередь с приоритетами пуста), значит время t не подходит в бинарном поиске. Если мы не уложились в требуемое количество зачетов — тоже не подходит. Иначе мы найдем нужное расписание.C div 1 / E div 2: 377C - Captains ModeЕсть несколько наблюдений, после которых задача становится очень простой. Первое наблюдение — пикать надо всегда самого сильного героя. А вот про баны ничего такого сказать нельзя, в разных ситуациях могут потребоваться самые разные баны. Самое важное наблюдение, которое поможет решить задачу — то, что рассматривать следует только m сильнейших героев. Действительно, при любой игре, где будут пикаться самые сильные герои в каждый момент времени, никакой герой, кроме первых m, не может быть пикнут вообще никогда. Значит, и банить их никогда не надо. И рассматривать тоже.В итоге у нас остается в худшем случае 20 героев, а, значит, можно решить задачу динамикой по подмножествам: dpmask — разность между силами команд в ситуации, когда пикнуты либо забанены те и только те герои, чьи биты в маске установлены в единицу. Для переходов перебираем героя, которого команда, чья очередь хода, будет пикать или банить. Проще всего реализовать это с помощью рекурсии с сохранением. Ответ будет храниться в dp2m - 1.К сожалению, мы неправильно оценили сложность этой задачи (несмотря на простое в реализации решение, придумать его, как выяснилось, было не так то и просто — стандартные 1500 баллов были бы лучше), и выставили неправильный TL (так что многие решения на C++ за m2·2m проходили — следовало опустить ограничение до одной секунды, а то и до 0.75 секунд). Так что если вы решили задачу за m2·2m, считайте, что вам повезло и что ваш вердикт — Time Limit Exceeded.Почему можно писать это за m·2m? Потому что пропуск бана не имеет смысла: вместо этого можно забанить самого слабого героя из доступных — ведь его точно никто никогда не пикнет.Здесь тоже были слабые претесты, поэтому можно было ломать тех, у кого в решении не было битмасок, чуть ли не любым большим случайным тестом.D div 1: 377D - Разработка игрыРассмотрим оптимальный ответ. Заметим, что каждый ответ характеризуется такими двумя числами L и R, что max{li} ≤ L, R ≤ min{ri}, и L ≤ vi ≤ R. Т.е., зная L и R, мы можем перебрать всех сотрудников и выбрать тех, что подходят под вышеперечисленные условия.Нарисуем плоскость, по оси абсцисс которой будем откладывать параметр L, а по оси ординат — R. Если точка (L, R) на этой плоскости является оптимальным ответом, то сотрудники, которые входят в ответ, обязательно удовлетворяют соотношениям li ≤ L ≤ vi и vi ≤ R ≤ ri. Эта область представляет собой прямоугольник на плоскости. Так как нам надо найти максимальное количество сотрудников, мы должны отыскать такую точку (L, R), что она входит в как можно большее количество указанных прямоугольников.Это уже совершенно стандартная задача, решающаяся с помощью сканирующей прямой по одной оси и дерева отрезков — по другой. Основная сложность — сведение к ней.E div 1: 377E - Cookie ClickerДля начала избавимся от вырожденных строений: оставим для каждого vi только строение с наименьшим ci при этом vi. А также выбросим все строения, скорость которых меньше скорости самого быстрого строения с ci = 0.Также довольно очевидно, что имеет смысл в каждый момент времени использовать только самое быстрое строение. И если мы будем в оптимальном ответе когда-нибудь использовать какое-либо строение, то купить его надо сразу же, как только появятся на это деньги (я буду называть печенья деньгами). И сразу же начать использовать.Представим себе плоскость (x, y), где по оси абсцисс будем откладывать время, а по оси ординат — деньги. Будем поддерживать график y = f(x) функции \"максимальное количество денег, которое можно заработать за время x\", добавляя на этот график поочередно по одному строению. Этот график представляет собой объединение отрезков прямых с угловыми коэффициентами vi, каждый из которых активен на некотором отрезке [xli, xri].К примеру, в начале это просто прямая y = v1x, где v1 — скорость строения, которое можно купить за 0 рублей. Пусть следующее по скорости строение можно купить за c2 рублей. Найдем минимальную точку x02, график функции в которой больше или равен y = f(x02) ≥ c2, и купим это строение в момент времени x02. Тогда мы должны построить прямую y = y02 + v2x, где y02 = f(x02) - c2 — сколько денег останется после покупки. Итого у нас есть две прямых. До какого-то момента (причем не до x02, а немного дольше) выгоднее будет старая прямая, но так как v2 > v1, найдется момент времени (это ceil(x12), где x12 — точка пересечения двух прямых), когда выгоднее станет новая прямая. Теперь отрезков прямых в графике две.Продолжим добавлять все строения таким образом. Отрезки прямых следует, как во всех задачах с выпуклой оболочкой, хранить в стеке и на каждом шаге отсекать те, которые уже не нужны (т.е. те, которые лежат в стеке после той, с которой было пересечение текущей добавляемой прямой). Обработав все строения, найдем минимальное время, за которое можно заработать S денег и выведем это число в ответ.Если требуется еще и сказать, какие строения надо при этом использовать, надо для каждого отрезка хранить тот, из которого он был получен (т.е. тот, который использовался перед тем, как мы купили этот). Имея такой \"массив предков\", нетрудно восстановить ответ. Чтобы задача стала немного проще, мы убрали из финальной версии вывод сертификата.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 377\\s*D"
          },
          "content_length": 7872
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "8\n100 100 100 99 0 0 0 0\n6\nb 1\np 2\np 1\np 1\np 2\nb 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "8\n100 100 100 99 0 0 0 0\n6\nb 1\np 2\np 1\np 1\np 2\nb 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 4",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 5",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 3",
          "code": "set <pll> :: iterator it = lower_bound( a.begin(), a.end(), make_pair(b[i].first, -1) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 4",
          "code": "set <pll> :: iterator it = lower_bound( a.begin(), a.end(), make_pair(b[i].first, -1) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 5",
          "code": "set <pll> :: iterator it = a.lower_bound(make_pair(b[i].first, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 6",
          "code": "set <pll> :: iterator it = a.lower_bound(make_pair(b[i].first, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 300000, \"li\");\n        inf.readSpace();\n        int vi = inf.readInt(li, 300000, \"vi\"); // ensures li ≤ vi ≤ 300000\n        inf.readSpace();\n        int ri = inf.readInt(vi, 300000, \"ri\"); // ensures vi ≤ ri ≤ 300000\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 300000, \"li\");\n        inf.readSpace();\n        int vi = inf.readInt(li, 300000, \"vi\"); // ensures li ≤ vi ≤ 300000\n        inf.readSpace();\n        int ri = inf.readInt(vi, 300000, \"ri\"); // ensures vi ≤ ri ≤ 300000\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 300000, \"li\");\n        inf.readSpace();\n        int vi = inf.readInt(li, 300000, \"vi\"); // ensures li ≤ vi ≤ 300000\n        inf.readSpace();\n        int ri = inf.readInt(vi, 300000, \"ri\"); // ensures vi ≤ ri ≤ 300000\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input file\n    int n = inf.readInt(1, 100000, \"n\");\n    vector<int> li(n + 1), vi(n + 1), ri(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        li[i] = inf.readInt(1, 300000, format(\"li[%d]\", i).c_str());\n        vi[i] = inf.readInt(li[i], 300000, format(\"vi[%d]\", i).c_str());\n        ri[i] = inf.readInt(vi[i], 300000, format(\"ri[%d]\", i).c_str());\n    }\n\n    // Read jury's answer\n    int m_jury = ans.readInt(0, n, \"jury's team size\");\n\n    // Read participant's answer\n    int m_participant = ouf.readInt(0, n, \"participant's team size\");\n\n    if (m_participant < m_jury) {\n        quitf(_wa, \"Not optimal team size: participant's team size = %d, expected maximum team size = %d\",\n              m_participant, m_jury);\n    } else if (m_participant > m_jury) {\n        quitf(_fail, \"Participant's team size = %d exceeds expected maximum team size = %d\",\n              m_participant, m_jury);\n    }\n\n    if (m_participant == 0) {\n        // Team size is zero, nothing more to check\n        quitf(_ok, \"Correct team size 0\");\n    }\n\n    vector<int> team;\n    set<int> worker_set;\n    for (int i = 0; i < m_participant; ++i) {\n        int idx = ouf.readInt(1, n, format(\"worker index %d\", i + 1).c_str());\n        if (worker_set.count(idx)) {\n            quitf(_wa, \"Duplicate worker index %d\", idx);\n        }\n        worker_set.insert(idx);\n        team.push_back(idx);\n    }\n\n    // Now check that each pair of workers in the team is willing to work with each other\n    for (size_t i = 0; i < team.size(); ++i) {\n        int u = team[i];\n        for (size_t j = i + 1; j < team.size(); ++j) {\n            int v = team[j];\n            // Check if u is willing to work with v\n            if (vi[v] < li[u] || vi[v] > ri[u]) {\n                quitf(_wa, \"Worker %d does not want to work with worker %d\", u, v);\n            }\n            // Check if v is willing to work with u\n            if (vi[u] < li[v] || vi[u] > ri[v]) {\n                quitf(_wa, \"Worker %d does not want to work with worker %d\", v, u);\n            }\n        }\n    }\n\n    quitf(_ok, \"Correct team of size %d\", m_participant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 300000);\n            int li = rnd.next(1, vi);\n            int ri = rnd.next(vi, 300000);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"fullrange\") {\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 300000);\n            int li = 1;\n            int ri = 300000;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"nointersect\") {\n        int step = 300000 / n;\n        for (int i = 0; i < n; ++i) {\n            int li = i * step + 1;\n            int vi = li;\n            int ri = li;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"samevi\") {\n        int vi = rnd.next(1, 300000);\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(1, vi);\n            int ri = rnd.next(vi, 300000);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"ascending\") {\n        int delta = 1000;\n        for (int i = 0; i < n; ++i) {\n            int vi = (int)((long long)i * 300000 / n) + 1;\n            int li = max(1, vi - delta);\n            int ri = min(300000, vi + delta);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"descending\") {\n        int delta = 1000;\n        for (int i = 0; i < n; ++i) {\n            int vi = 300000 - (int)((long long)i * 300000 / n);\n            int li = max(1, vi - delta);\n            int ri = min(300000, vi + delta);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"maxsize\") {\n        for (int i = 0; i < n; ++i) {\n            int vi = 300000;\n            int li = 1;\n            int ri = 300000;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"equalvi\") {\n        int vi = rnd.next(1, 300000);\n        for (int i = 0; i < n; ++i) {\n            int li = vi;\n            int ri = vi;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 300000);\n            int li = rnd.next(1, vi);\n            int ri = rnd.next(vi, 300000);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 300000);\n            int li = rnd.next(1, vi);\n            int ri = rnd.next(vi, 300000);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"fullrange\") {\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 300000);\n            int li = 1;\n            int ri = 300000;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"nointersect\") {\n        int step = 300000 / n;\n        for (int i = 0; i < n; ++i) {\n            int li = i * step + 1;\n            int vi = li;\n            int ri = li;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"samevi\") {\n        int vi = rnd.next(1, 300000);\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(1, vi);\n            int ri = rnd.next(vi, 300000);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"ascending\") {\n        int delta = 1000;\n        for (int i = 0; i < n; ++i) {\n            int vi = (int)((long long)i * 300000 / n) + 1;\n            int li = max(1, vi - delta);\n            int ri = min(300000, vi + delta);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"descending\") {\n        int delta = 1000;\n        for (int i = 0; i < n; ++i) {\n            int vi = 300000 - (int)((long long)i * 300000 / n);\n            int li = max(1, vi - delta);\n            int ri = min(300000, vi + delta);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"maxsize\") {\n        for (int i = 0; i < n; ++i) {\n            int vi = 300000;\n            int li = 1;\n            int ri = 300000;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else if (type == \"equalvi\") {\n        int vi = rnd.next(1, 300000);\n        for (int i = 0; i < n; ++i) {\n            int li = vi;\n            int ri = vi;\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 300000);\n            int li = rnd.next(1, vi);\n            int ri = rnd.next(vi, 300000);\n            printf(\"%d %d %d\\n\", li, vi, ri);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minsize\n./gen -n 2 -type random\n./gen -n 3 -type equalvi\n./gen -n 4 -type random\n./gen -n 5 -type samevi\n./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 50 -type nointersect\n./gen -n 100 -type random\n./gen -n 500 -type fullrange\n./gen -n 1000 -type random\n./gen -n 5000 -type ascending\n./gen -n 10000 -type descending\n./gen -n 20000 -type random\n./gen -n 30000 -type nointersect\n./gen -n 40000 -type equalvi\n./gen -n 50000 -type samevi\n./gen -n 60000 -type fullrange\n./gen -n 70000 -type ascending\n./gen -n 80000 -type descending\n./gen -n 90000 -type nointersect\n./gen -n 100000 -type random\n./gen -n 100000 -type equalvi\n./gen -n 100000 -type samevi\n./gen -n 100000 -type fullrange\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:29.593684",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "377/E",
      "title": "E. Cookie Clicker",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and s (1 ≤ n ≤ 2·105, 1 ≤ s ≤ 1016) — the number of buildings in the game and the number of cookies Kostya wants to earn.Each of the next n lines contains two integers vi and ci (1 ≤ vi ≤ 108, 0 ≤ ci ≤ 108) — the number of cookies the i-th building brings per second and the building's price.",
      "output_spec": "OutputOutput the only integer — the minimum number of seconds Kostya needs to earn at least s cookies. It is guaranteed that he can do it.",
      "sample_tests": "ExamplesInputCopy3 91 02 35 4OutputCopy6InputCopy3 61 02 25 4OutputCopy5InputCopy3 131 02 26 5OutputCopy7InputCopy1 100000000000000001 0OutputCopy10000000000000000",
      "description": "E. Cookie Clicker\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and s (1 ≤ n ≤ 2·105, 1 ≤ s ≤ 1016) — the number of buildings in the game and the number of cookies Kostya wants to earn.Each of the next n lines contains two integers vi and ci (1 ≤ vi ≤ 108, 0 ≤ ci ≤ 108) — the number of cookies the i-th building brings per second and the building's price.\n\nOutputOutput the only integer — the minimum number of seconds Kostya needs to earn at least s cookies. It is guaranteed that he can do it.\n\nInputCopy3 91 02 35 4OutputCopy6InputCopy3 61 02 25 4OutputCopy5InputCopy3 131 02 26 5OutputCopy7InputCopy1 100000000000000001 0OutputCopy10000000000000000\n\nInputCopy3 91 02 35 4\n\nOutputCopy6\n\nInputCopy3 61 02 25 4\n\nOutputCopy5\n\nInputCopy3 131 02 26 5\n\nOutputCopy7\n\nInputCopy1 100000000000000001 0\n\nOutputCopy10000000000000000",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 377\\s*E"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N_MAX = 200000;\nconst long long S_MAX = 10000000000000000LL;\nconst int V_MAX = 100000000;\nconst int C_MAX = 100000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    long long s = inf.readLong(1LL, S_MAX, \"s\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int vi = inf.readInt(1, V_MAX, \"vi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, C_MAX, \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N_MAX = 200000;\nconst long long S_MAX = 10000000000000000LL;\nconst int V_MAX = 100000000;\nconst int C_MAX = 100000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    long long s = inf.readLong(1LL, S_MAX, \"s\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int vi = inf.readInt(1, V_MAX, \"vi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, C_MAX, \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N_MAX = 200000;\nconst long long S_MAX = 10000000000000000LL;\nconst int V_MAX = 100000000;\nconst int C_MAX = 100000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    long long s = inf.readLong(1LL, S_MAX, \"s\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int vi = inf.readInt(1, V_MAX, \"vi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, C_MAX, \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of buildings\n    long long s = opt<long long>(\"s\"); // Target number of cookies\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> vi(n);\n    vector<int> ci(n);\n\n    if (type == \"random\")\n    {\n        // Ensure at least one building with ci = 0\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = rnd.next(0, int(1e8));\n        }\n    }\n    else if (type == \"max_vi\")\n    {\n        // vi = 1e8\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = int(1e8);\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = rnd.next(0, int(1e8));\n        }\n    }\n    else if (type == \"zero_ci\")\n    {\n        // All ci = 0\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            ci[i] = 0;\n        }\n    }\n    else if (type == \"max_ci\")\n    {\n        // ci = 1e8, ensure at least one ci = 0\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = int(1e8);\n        }\n    }\n    else if (type == \"increasing_vi\")\n    {\n        // vi increasing, ci random\n        vi[0] = rnd.next(1, int(1e2));\n        ci[0] = rnd.next(0, int(1e8));\n        for (int i = 1; i < n; ++i)\n        {\n            vi[i] = vi[i - 1] + rnd.next(0, int(1e8) / n);\n            if (vi[i] > int(1e8)) vi[i] = int(1e8);\n            ci[i] = rnd.next(0, int(1e8));\n        }\n        // Ensure at least one ci = 0\n        ci[rnd.next(0, n - 1)] = 0;\n    }\n    else if (type == \"decreasing_vi\")\n    {\n        // vi decreasing, ci random\n        vi[0] = int(1e8);\n        ci[0] = rnd.next(0, int(1e8));\n        for (int i = 1; i < n; ++i)\n        {\n            vi[i] = vi[i - 1] - rnd.next(0, vi[i - 1] / n);\n            if (vi[i] < 1) vi[i] = 1;\n            ci[i] = rnd.next(0, int(1e8));\n        }\n        // Ensure at least one ci = 0\n        ci[rnd.next(0, n - 1)] = 0;\n    }\n    else\n    {\n        // Default to random\n        // Ensure at least one building with ci = 0\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = rnd.next(0, int(1e8));\n        }\n    }\n\n    // Output n and s\n    printf(\"%d %lld\\n\", n, s);\n    // Output vi and ci\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d %d\\n\", vi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of buildings\n    long long s = opt<long long>(\"s\"); // Target number of cookies\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> vi(n);\n    vector<int> ci(n);\n\n    if (type == \"random\")\n    {\n        // Ensure at least one building with ci = 0\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = rnd.next(0, int(1e8));\n        }\n    }\n    else if (type == \"max_vi\")\n    {\n        // vi = 1e8\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = int(1e8);\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = rnd.next(0, int(1e8));\n        }\n    }\n    else if (type == \"zero_ci\")\n    {\n        // All ci = 0\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            ci[i] = 0;\n        }\n    }\n    else if (type == \"max_ci\")\n    {\n        // ci = 1e8, ensure at least one ci = 0\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = int(1e8);\n        }\n    }\n    else if (type == \"increasing_vi\")\n    {\n        // vi increasing, ci random\n        vi[0] = rnd.next(1, int(1e2));\n        ci[0] = rnd.next(0, int(1e8));\n        for (int i = 1; i < n; ++i)\n        {\n            vi[i] = vi[i - 1] + rnd.next(0, int(1e8) / n);\n            if (vi[i] > int(1e8)) vi[i] = int(1e8);\n            ci[i] = rnd.next(0, int(1e8));\n        }\n        // Ensure at least one ci = 0\n        ci[rnd.next(0, n - 1)] = 0;\n    }\n    else if (type == \"decreasing_vi\")\n    {\n        // vi decreasing, ci random\n        vi[0] = int(1e8);\n        ci[0] = rnd.next(0, int(1e8));\n        for (int i = 1; i < n; ++i)\n        {\n            vi[i] = vi[i - 1] - rnd.next(0, vi[i - 1] / n);\n            if (vi[i] < 1) vi[i] = 1;\n            ci[i] = rnd.next(0, int(1e8));\n        }\n        // Ensure at least one ci = 0\n        ci[rnd.next(0, n - 1)] = 0;\n    }\n    else\n    {\n        // Default to random\n        // Ensure at least one building with ci = 0\n        int index_zero_ci = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n        {\n            vi[i] = rnd.next(1, int(1e8));\n            if (i == index_zero_ci)\n                ci[i] = 0;\n            else\n                ci[i] = rnd.next(0, int(1e8));\n        }\n    }\n\n    // Output n and s\n    printf(\"%d %lld\\n\", n, s);\n    // Output vi and ci\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d %d\\n\", vi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -s 100 -type random\n./gen -n 100 -s 1000 -type random\n./gen -n 1000 -s 10000 -type random\n./gen -n 10000 -s 100000 -type random\n./gen -n 100000 -s 1000000 -type random\n./gen -n 200000 -s 10000000 -type random\n\n./gen -n 10 -s 500 -type max_vi\n./gen -n 10 -s 500 -type zero_ci\n./gen -n 10 -s 500 -type max_ci\n./gen -n 10 -s 500 -type increasing_vi\n./gen -n 10 -s 500 -type decreasing_vi\n\n./gen -n 1 -s 1 -type random\n./gen -n 1 -s 10000000000000000 -type random\n\n./gen -n 2 -s 1 -type random\n./gen -n 2 -s 1 -type max_vi\n./gen -n 2 -s 1 -type zero_ci\n./gen -n 2 -s 1 -type max_ci\n\n./gen -n 200000 -s 10000000000000000 -type random\n./gen -n 200000 -s 10000000000000000 -type max_vi\n./gen -n 200000 -s 10000000000000000 -type zero_ci\n./gen -n 200000 -s 10000000000000000 -type increasing_vi\n./gen -n 200000 -s 10000000000000000 -type decreasing_vi\n\n./gen -n 1000 -s 100000000000 -type max_vi\n./gen -n 1000 -s 100000000000 -type zero_ci\n./gen -n 1000 -s 100000000000 -type max_ci\n\n./gen -n 50000 -s 1000000000 -type increasing_vi\n./gen -n 50000 -s 1000000000 -type decreasing_vi\n\n./gen -n 200000 -s 5000000000000000 -type random\n./gen -n 100000 -s 10000000000000000 -type random\n./gen -n 100000 -s 10000000000000000 -type max_vi\n\n./gen -n 200000 -s 1 -type random\n./gen -n 200000 -s 1 -type max_vi\n./gen -n 200000 -s 1 -type zero_ci\n\n./gen -n 200000 -s 9999999999999999 -type random\n./gen -n 200000 -s 9999999999999999 -type decreasing_vi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:32.601588",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "378/A",
      "title": "A. Playing with Dice",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two integers a and b (1 ≤ a, b ≤ 6) — the numbers written on the paper by the first and second player, correspondingly.",
      "output_spec": "OutputPrint three integers: the number of ways to throw the dice at which the first player wins, the game ends with a draw or the second player wins, correspondingly.",
      "sample_tests": "ExamplesInputCopy2 5OutputCopy3 0 3InputCopy2 4OutputCopy2 1 3",
      "description": "A. Playing with Dice\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two integers a and b (1 ≤ a, b ≤ 6) — the numbers written on the paper by the first and second player, correspondingly.\n\nOutputPrint three integers: the number of ways to throw the dice at which the first player wins, the game ends with a draw or the second player wins, correspondingly.\n\nInputCopy2 5OutputCopy3 0 3InputCopy2 4OutputCopy2 1 3\n\nInputCopy2 5\n\nOutputCopy3 0 3\n\nInputCopy2 4\n\nOutputCopy2 1 3\n\nNoteThe dice is a standard cube-shaped six-sided object with each side containing a number from 1 to 6, and where all numbers on all sides are distinct.You can assume that number a is closer to number x than number b, if |a - x| < |b - x|.",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 378\\s*A"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 6, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 6, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 6, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 6, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 6, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 6, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int a, b;\n\n    if (type == \"random\") {\n        // Generate random numbers a and b between 1 and 6.\n        a = rnd.next(1, 6);\n        b = rnd.next(1, 6);\n    } else if (type == \"equal\") {\n        // Both players choose the same number.\n        a = rnd.next(1, 6);\n        b = a;\n    } else if (type == \"extremes\") {\n        // Players choose the minimum and maximum possible numbers.\n        a = 1;\n        b = 6;\n        if (rnd.next(2)) swap(a, b);\n    } else if (type == \"adjacent\") {\n        // Players choose adjacent numbers.\n        a = rnd.next(2, 5); // a is between 2 and 5.\n        if (rnd.next(2)) {\n            b = a + 1;\n        } else {\n            b = a - 1;\n        }\n    } else if (type == \"fixed\") {\n        // Players choose specific numbers provided as parameters.\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n    } else {\n        // Default to random if type is unrecognized.\n        a = rnd.next(1, 6);\n        b = rnd.next(1, 6);\n    }\n\n    // Output the numbers chosen by the players.\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int a, b;\n\n    if (type == \"random\") {\n        // Generate random numbers a and b between 1 and 6.\n        a = rnd.next(1, 6);\n        b = rnd.next(1, 6);\n    } else if (type == \"equal\") {\n        // Both players choose the same number.\n        a = rnd.next(1, 6);\n        b = a;\n    } else if (type == \"extremes\") {\n        // Players choose the minimum and maximum possible numbers.\n        a = 1;\n        b = 6;\n        if (rnd.next(2)) swap(a, b);\n    } else if (type == \"adjacent\") {\n        // Players choose adjacent numbers.\n        a = rnd.next(2, 5); // a is between 2 and 5.\n        if (rnd.next(2)) {\n            b = a + 1;\n        } else {\n            b = a - 1;\n        }\n    } else if (type == \"fixed\") {\n        // Players choose specific numbers provided as parameters.\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n    } else {\n        // Default to random if type is unrecognized.\n        a = rnd.next(1, 6);\n        b = rnd.next(1, 6);\n    }\n\n    // Output the numbers chosen by the players.\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Equal numbers (both players choose the same number)\n./gen -type equal\n./gen -type equal\n./gen -type equal\n\n# Extremes (players choose 1 and 6)\n./gen -type extremes\n./gen -type extremes\n./gen -type extremes\n\n# Adjacent numbers (players choose numbers that are next to each other)\n./gen -type adjacent\n./gen -type adjacent\n./gen -type adjacent\n\n# Fixed test cases with specific numbers to cover edge cases\n./gen -type fixed -a 1 -b 1\n./gen -type fixed -a 1 -b 2\n./gen -type fixed -a 1 -b 3\n./gen -type fixed -a 1 -b 4\n./gen -type fixed -a 1 -b 5\n./gen -type fixed -a 1 -b 6\n\n./gen -type fixed -a 2 -b 2\n./gen -type fixed -a 2 -b 3\n./gen -type fixed -a 2 -b 4\n./gen -type fixed -a 2 -b 5\n./gen -type fixed -a 2 -b 6\n\n./gen -type fixed -a 3 -b 3\n./gen -type fixed -a 3 -b 4\n./gen -type fixed -a 3 -b 6\n\n./gen -type fixed -a 4 -b 4\n./gen -type fixed -a 4 -b 5\n./gen -type fixed -a 4 -b 6\n\n./gen -type fixed -a 5 -b 5\n./gen -type fixed -a 5 -b 6\n\n./gen -type fixed -a 6 -b 6\n\n# Specific edge cases to catch potential errors\n./gen -type fixed -a 6 -b 1\n./gen -type fixed -a 5 -b 1\n./gen -type fixed -a 4 -b 1\n./gen -type fixed -a 6 -b 2\n./gen -type fixed -a 6 -b 3\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:35.382490",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "378/B",
      "title": "B. Semifinals",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of participants in each semifinal.Each of the next n lines contains two integers ai and bi (1 ≤ ai, bi ≤ 109) — the results of the i-th participant (the number of milliseconds he needs to cover the semifinals distance) of the first and second semifinals, correspondingly. All results are distinct. Sequences a1, a2, ..., an and b1, b2, ..., bn are sorted in ascending order, i.e. in the order the participants finished in the corresponding semifinal.",
      "output_spec": "OutputPrint two strings consisting of n characters, each equals either \"0\" or \"1\". The first line should correspond to the participants of the first semifinal, the second line should correspond to the participants of the second semifinal. The i-th character in the j-th line should equal \"1\" if the i-th participant of the j-th semifinal has any chances to advance to the finals, otherwise it should equal a \"0\".",
      "sample_tests": "ExamplesInputCopy49840 99209860 99809930 1002010040 10090OutputCopy11101100InputCopy49900 98509940 993010000 1002010060 10110OutputCopy11001100",
      "description": "B. Semifinals\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of participants in each semifinal.Each of the next n lines contains two integers ai and bi (1 ≤ ai, bi ≤ 109) — the results of the i-th participant (the number of milliseconds he needs to cover the semifinals distance) of the first and second semifinals, correspondingly. All results are distinct. Sequences a1, a2, ..., an and b1, b2, ..., bn are sorted in ascending order, i.e. in the order the participants finished in the corresponding semifinal.\n\nOutputPrint two strings consisting of n characters, each equals either \"0\" or \"1\". The first line should correspond to the participants of the first semifinal, the second line should correspond to the participants of the second semifinal. The i-th character in the j-th line should equal \"1\" if the i-th participant of the j-th semifinal has any chances to advance to the finals, otherwise it should equal a \"0\".\n\nInputCopy49840 99209860 99809930 1002010040 10090OutputCopy11101100InputCopy49900 98509940 993010000 1002010060 10110OutputCopy11001100\n\nInputCopy49840 99209860 99809930 1002010040 10090\n\nOutputCopy11101100\n\nInputCopy49900 98509940 993010000 1002010060 10110\n\nOutputCopy11001100\n\nNoteConsider the first sample. Each semifinal has 4 participants. The results of the first semifinal are 9840, 9860, 9930, 10040. The results of the second semifinal are 9920, 9980, 10020, 10090.  If k = 0, the finalists are determined by the time only, so players 9840, 9860, 9920 and 9930 advance to the finals.  If k = 1, the winners from both semifinals move to the finals (with results 9840 and 9920), and the other places are determined by the time (these places go to the sportsmen who run the distance in 9860 and 9930 milliseconds).  If k = 2, then first and second places advance from each seminfial, these are participants with results 9840, 9860, 9920 and 9980 milliseconds.",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 378\\s*B"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai(n), bi(n);\n    set<int> seen;\n\n    for (int i = 0; i < n; i++) {\n        ai[i] = inf.readInt(1, 1000000000, (\"ai[\" + to_string(i + 1) + \"]\").c_str());\n        inf.readSpace();\n        bi[i] = inf.readInt(1, 1000000000, (\"bi[\" + to_string(i + 1) + \"]\").c_str());\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(ai[i] > ai[i - 1], \"ai[%d]=%d is not greater than ai[%d]=%d\", i + 1, ai[i], i, ai[i - 1]);\n            ensuref(bi[i] > bi[i - 1], \"bi[%d]=%d is not greater than bi[%d]=%d\", i + 1, bi[i], i, bi[i - 1]);\n        }\n\n        auto res_ai = seen.insert(ai[i]);\n        ensuref(res_ai.second, \"Value ai[%d]=%d is not unique\", i + 1, ai[i]);\n\n        auto res_bi = seen.insert(bi[i]);\n        ensuref(res_bi.second, \"Value bi[%d]=%d is not unique\", i + 1, bi[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai(n), bi(n);\n    set<int> seen;\n\n    for (int i = 0; i < n; i++) {\n        ai[i] = inf.readInt(1, 1000000000, (\"ai[\" + to_string(i + 1) + \"]\").c_str());\n        inf.readSpace();\n        bi[i] = inf.readInt(1, 1000000000, (\"bi[\" + to_string(i + 1) + \"]\").c_str());\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(ai[i] > ai[i - 1], \"ai[%d]=%d is not greater than ai[%d]=%d\", i + 1, ai[i], i, ai[i - 1]);\n            ensuref(bi[i] > bi[i - 1], \"bi[%d]=%d is not greater than bi[%d]=%d\", i + 1, bi[i], i, bi[i - 1]);\n        }\n\n        auto res_ai = seen.insert(ai[i]);\n        ensuref(res_ai.second, \"Value ai[%d]=%d is not unique\", i + 1, ai[i]);\n\n        auto res_bi = seen.insert(bi[i]);\n        ensuref(res_bi.second, \"Value bi[%d]=%d is not unique\", i + 1, bi[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai(n), bi(n);\n    set<int> seen;\n\n    for (int i = 0; i < n; i++) {\n        ai[i] = inf.readInt(1, 1000000000, (\"ai[\" + to_string(i + 1) + \"]\").c_str());\n        inf.readSpace();\n        bi[i] = inf.readInt(1, 1000000000, (\"bi[\" + to_string(i + 1) + \"]\").c_str());\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(ai[i] > ai[i - 1], \"ai[%d]=%d is not greater than ai[%d]=%d\", i + 1, ai[i], i, ai[i - 1]);\n            ensuref(bi[i] > bi[i - 1], \"bi[%d]=%d is not greater than bi[%d]=%d\", i + 1, bi[i], i, bi[i - 1]);\n        }\n\n        auto res_ai = seen.insert(ai[i]);\n        ensuref(res_ai.second, \"Value ai[%d]=%d is not unique\", i + 1, ai[i]);\n\n        auto res_bi = seen.insert(bi[i]);\n        ensuref(res_bi.second, \"Value bi[%d]=%d is not unique\", i + 1, bi[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        // Generate random increasing sequences for a and b\n        set<int> used;\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            a[i] = value;\n        }\n        sort(a.begin(), a.end());\n        used.clear();\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            b[i] = value;\n        }\n        sort(b.begin(), b.end());\n    } else if (type == \"reverse\") {\n        // Generate sequences where a is in decreasing order\n        vector<int> temp(n);\n        set<int> used;\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            temp[i] = value;\n        }\n        sort(temp.rbegin(), temp.rend());\n        for(int i = 0; i < n; i++) {\n            a[i] = temp[i];\n        }\n        sort(a.begin(), a.end());\n        // Generate increasing sequence for b\n        used.clear();\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            b[i] = value;\n        }\n        sort(b.begin(), b.end());\n    } else if (type == \"all_chance\") {\n        // Ensure all participants have a chance to qualify\n        vector<int> totalResults(2*n);\n        set<int> used;\n        for(int i = 0; i < 2*n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            totalResults[i] = value;\n        }\n        sort(totalResults.begin(), totalResults.end());\n        for(int i = 0; i < n; i++) {\n            a[i] = totalResults[2*i];\n            b[i] = totalResults[2*i+1];\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"few_chance\") {\n        // Only a few participants have a chance to qualify\n        int k = n / 2;\n        set<int> used;\n        // First k participants have good times, rest have bad times\n        for(int i = 0; i < k; i++) {\n            a[i] = i + 1;\n            b[i] = i + 1;\n        }\n        for(int i = k; i < n; i++) {\n            a[i] = 1000000000 - (n - i);\n            b[i] = 1000000000 - (n - i);\n        }\n    } else if (type == \"edge_times\") {\n        // Times near the limits\n        for(int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        for(int i = 0; i < n; i++) {\n            b[i] = 1000000000 - n + i + 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai and bi\n    for(int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        // Generate random increasing sequences for a and b\n        set<int> used;\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            a[i] = value;\n        }\n        sort(a.begin(), a.end());\n        used.clear();\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            b[i] = value;\n        }\n        sort(b.begin(), b.end());\n    } else if (type == \"reverse\") {\n        // Generate sequences where a is in decreasing order\n        vector<int> temp(n);\n        set<int> used;\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            temp[i] = value;\n        }\n        sort(temp.rbegin(), temp.rend());\n        for(int i = 0; i < n; i++) {\n            a[i] = temp[i];\n        }\n        sort(a.begin(), a.end());\n        // Generate increasing sequence for b\n        used.clear();\n        for(int i = 0; i < n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            b[i] = value;\n        }\n        sort(b.begin(), b.end());\n    } else if (type == \"all_chance\") {\n        // Ensure all participants have a chance to qualify\n        vector<int> totalResults(2*n);\n        set<int> used;\n        for(int i = 0; i < 2*n; i++) {\n            int value;\n            do {\n                value = rnd.next(1, 1000000000);\n            } while (used.count(value));\n            used.insert(value);\n            totalResults[i] = value;\n        }\n        sort(totalResults.begin(), totalResults.end());\n        for(int i = 0; i < n; i++) {\n            a[i] = totalResults[2*i];\n            b[i] = totalResults[2*i+1];\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"few_chance\") {\n        // Only a few participants have a chance to qualify\n        int k = n / 2;\n        set<int> used;\n        // First k participants have good times, rest have bad times\n        for(int i = 0; i < k; i++) {\n            a[i] = i + 1;\n            b[i] = i + 1;\n        }\n        for(int i = k; i < n; i++) {\n            a[i] = 1000000000 - (n - i);\n            b[i] = 1000000000 - (n - i);\n        }\n    } else if (type == \"edge_times\") {\n        // Times near the limits\n        for(int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        for(int i = 0; i < n; i++) {\n            b[i] = 1000000000 - n + i + 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai and bi\n    for(int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 10 -type reverse\n./gen -n 10 -type all_chance\n./gen -n 10 -type few_chance\n./gen -n 10 -type edge_times\n\n./gen -n 100 -type random\n./gen -n 100 -type reverse\n./gen -n 100 -type all_chance\n./gen -n 100 -type few_chance\n./gen -n 100 -type edge_times\n\n./gen -n 1000 -type random\n./gen -n 1000 -type reverse\n./gen -n 1000 -type all_chance\n./gen -n 1000 -type few_chance\n./gen -n 1000 -type edge_times\n\n./gen -n 10000 -type random\n./gen -n 10000 -type reverse\n./gen -n 10000 -type all_chance\n./gen -n 10000 -type few_chance\n./gen -n 10000 -type edge_times\n\n./gen -n 100000 -type random\n./gen -n 100000 -type reverse\n./gen -n 100000 -type all_chance\n./gen -n 100000 -type few_chance\n./gen -n 100000 -type edge_times\n\n# Special cases\n./gen -n 1 -type edge_times\n./gen -n 2 -type all_chance\n./gen -n 99999 -type random\n./gen -n 50000 -type few_chance\n./gen -n 50000 -type reverse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:37.067132",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "378/C",
      "title": "C. Maze",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 500, 0 ≤ k < s), where n and m are the maze's height and width, correspondingly, k is the number of walls Pavel wants to add and letter s represents the number of empty cells in the original maze.Each of the next n lines contains m characters. They describe the original maze. If a character on a line equals \".\", then the corresponding cell is empty and if the character equals \"#\", then the cell is a wall.",
      "output_spec": "OutputPrint n lines containing m characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as \"X\", the other cells must be left without changes (that is, \".\" and \"#\").It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.",
      "sample_tests": "ExamplesInputCopy3 4 2#..#..#.#...OutputCopy#.X#X.#.#...InputCopy5 4 5#...#.#..#.....#.#.#OutputCopy#XXX#X#.X#.....#.#.#",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 500, 0 ≤ k < s), where n and m are the maze's height and width, correspondingly, k is the number of walls Pavel wants to add and letter s represents the number of empty cells in the original maze.Each of the next n lines contains m characters. They describe the original maze. If a character on a line equals \".\", then the corresponding cell is empty and if the character equals \"#\", then the cell is a wall.\n\nOutputPrint n lines containing m characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as \"X\", the other cells must be left without changes (that is, \".\" and \"#\").It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.\n\nInputCopy3 4 2#..#..#.#...OutputCopy#.X#X.#.#...InputCopy5 4 5#...#.#..#.....#.#.#OutputCopy#XXX#X#.X#.....#.#.#\n\nInputCopy3 4 2#..#..#.#...\n\nOutputCopy#.X#X.#.#...\n\nInputCopy5 4 5#...#.#..#.....#.#.#\n\nOutputCopy#XXX#X#.X#.....#.#.#",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 378 和字母"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nint n, m;\nvector<string> maze;\nvector<vector<bool>> visited;\nint s; // number of empty cells\nint empty_cells_reached;\nvoid dfs(int i, int j){\n    visited[i][j] = true;\n    empty_cells_reached++;\n    for(int dir = 0; dir < 4; dir++){\n        int ni = i + dx[dir];\n        int nj = j + dy[dir];\n        if(ni >=0 && ni < n && nj >=0 && nj < m){\n            if(maze[ni][nj] == '.' && !visited[ni][nj]){\n                dfs(ni,nj);\n            }\n        }       \n    }\n}\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    n = inf.readInt(1,500,\"n\");\n    inf.readSpace();\n    m = inf.readInt(1,500,\"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n*m, \"k\");\n    inf.readEoln();\n    maze.resize(n);\n    s = 0;\n    for(int i=0; i<n; i++){\n        maze[i] = inf.readLine();\n        ensuref(int(maze[i].length()) == m, \"Row %d should have length %d, but has length %d\", i+1, m, int(maze[i].length()));\n        for(int j=0; j<m;j++){\n            char c = maze[i][j];\n            ensuref(c == '.' || c == '#', \"Invalid character '%c' at row %d column %d\", c, i+1, j+1);\n            if(c == '.'){\n                s++;\n            }\n        }\n    }\n    ensuref(s >= 1, \"At least one empty cell expected, but found %d\", s);\n    ensuref(0 <= k && k < s, \"Invalid k=%d, expected 0 ≤ k < s=%d\", k, s);\n    visited.assign(n, vector<bool>(m,false));\n    int start_i = -1, start_j = -1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(maze[i][j] == '.'){\n                start_i = i;\n                start_j = j;\n                break;\n            }\n        }\n        if(start_i != -1)\n            break;\n    }\n    ensuref(start_i != -1, \"No empty cell found in the maze\");\n    empty_cells_reached = 0;\n    dfs(start_i,start_j);\n    ensuref(empty_cells_reached == s, \"Empty cells are not connected: reached %d out of %d empty cells\", empty_cells_reached, s);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nint n, m;\nvector<string> maze;\nvector<vector<bool>> visited;\nint s; // number of empty cells\nint empty_cells_reached;\nvoid dfs(int i, int j){\n    visited[i][j] = true;\n    empty_cells_reached++;\n    for(int dir = 0; dir < 4; dir++){\n        int ni = i + dx[dir];\n        int nj = j + dy[dir];\n        if(ni >=0 && ni < n && nj >=0 && nj < m){\n            if(maze[ni][nj] == '.' && !visited[ni][nj]){\n                dfs(ni,nj);\n            }\n        }       \n    }\n}\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    n = inf.readInt(1,500,\"n\");\n    inf.readSpace();\n    m = inf.readInt(1,500,\"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n*m, \"k\");\n    inf.readEoln();\n    maze.resize(n);\n    s = 0;\n    for(int i=0; i<n; i++){\n        maze[i] = inf.readLine();\n        ensuref(int(maze[i].length()) == m, \"Row %d should have length %d, but has length %d\", i+1, m, int(maze[i].length()));\n        for(int j=0; j<m;j++){\n            char c = maze[i][j];\n            ensuref(c == '.' || c == '#', \"Invalid character '%c' at row %d column %d\", c, i+1, j+1);\n            if(c == '.'){\n                s++;\n            }\n        }\n    }\n    ensuref(s >= 1, \"At least one empty cell expected, but found %d\", s);\n    ensuref(0 <= k && k < s, \"Invalid k=%d, expected 0 ≤ k < s=%d\", k, s);\n    visited.assign(n, vector<bool>(m,false));\n    int start_i = -1, start_j = -1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(maze[i][j] == '.'){\n                start_i = i;\n                start_j = j;\n                break;\n            }\n        }\n        if(start_i != -1)\n            break;\n    }\n    ensuref(start_i != -1, \"No empty cell found in the maze\");\n    empty_cells_reached = 0;\n    dfs(start_i,start_j);\n    ensuref(empty_cells_reached == s, \"Empty cells are not connected: reached %d out of %d empty cells\", empty_cells_reached, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nint n, m;\nvector<string> maze;\nvector<vector<bool>> visited;\nint s; // number of empty cells\nint empty_cells_reached;\nvoid dfs(int i, int j){\n    visited[i][j] = true;\n    empty_cells_reached++;\n    for(int dir = 0; dir < 4; dir++){\n        int ni = i + dx[dir];\n        int nj = j + dy[dir];\n        if(ni >=0 && ni < n && nj >=0 && nj < m){\n            if(maze[ni][nj] == '.' && !visited[ni][nj]){\n                dfs(ni,nj);\n            }\n        }       \n    }\n}\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    n = inf.readInt(1,500,\"n\");\n    inf.readSpace();\n    m = inf.readInt(1,500,\"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n*m, \"k\");\n    inf.readEoln();\n    maze.resize(n);\n    s = 0;\n    for(int i=0; i<n; i++){\n        maze[i] = inf.readLine();\n        ensuref(int(maze[i].length()) == m, \"Row %d should have length %d, but has length %d\", i+1, m, int(maze[i].length()));\n        for(int j=0; j<m;j++){\n            char c = maze[i][j];\n            ensuref(c == '.' || c == '#', \"Invalid character '%c' at row %d column %d\", c, i+1, j+1);\n            if(c == '.'){\n                s++;\n            }\n        }\n    }\n    ensuref(s >= 1, \"At least one empty cell expected, but found %d\", s);\n    ensuref(0 <= k && k < s, \"Invalid k=%d, expected 0 ≤ k < s=%d\", k, s);\n    visited.assign(n, vector<bool>(m,false));\n    int start_i = -1, start_j = -1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(maze[i][j] == '.'){\n                start_i = i;\n                start_j = j;\n                break;\n            }\n        }\n        if(start_i != -1)\n            break;\n    }\n    ensuref(start_i != -1, \"No empty cell found in the maze\");\n    empty_cells_reached = 0;\n    dfs(start_i,start_j);\n    ensuref(empty_cells_reached == s, \"Empty cells are not connected: reached %d out of %d empty cells\", empty_cells_reached, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, k;\nvector<string> originalMaze;\nvector<string> contestantMaze;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    m = inf.readInt();\n    k = inf.readInt();\n    inf.readEoln();\n\n    int s = 0;\n    originalMaze.resize(n);\n    for(int i = 0; i < n; i++) {\n        originalMaze[i] = inf.readLine();\n        if((int)originalMaze[i].length() != m)\n            quitf(_fail, \"Length of line %d in input is not equal to m\", i+1);\n        for(char c : originalMaze[i]) {\n            if(c == '.') s++;\n            else if(c != '#') quitf(_fail, \"Invalid character '%c' in input at line %d\", c, i+1);\n        }\n    }\n\n    if(k < 0 || k >= s)\n        quitf(_fail, \"Invalid value of k in input file\");\n\n    contestantMaze.resize(n);\n    for(int i = 0; i < n; i++) {\n        contestantMaze[i] = ouf.readLine();\n        if((int)contestantMaze[i].length() != m)\n            quitf(_wa, \"Line %d in contestant's output has incorrect length (expected %d, found %d)\",\n                  i+1, m, (int)contestantMaze[i].length());\n        for(char c : contestantMaze[i]) {\n            if(c != '.' && c != '#' && c != 'X')\n                quitf(_wa, \"Invalid character '%c' in contestant's output at line %d\", c, i+1);\n        }\n    }\n\n    int xCount = 0;\n    int emptyCellsContestant = 0;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            char c_original = originalMaze[i][j];\n            char c_contestant = contestantMaze[i][j];\n            if(c_contestant == 'X') {\n                if(c_original != '.')\n                    quitf(_wa, \"'X' at position (%d, %d) corresponds to a wall or invalid cell in original maze\", i+1, j+1);\n                xCount++;\n            } else if(c_contestant == '#') {\n                if(c_original != '#')\n                    quitf(_wa, \"Contestant placed a wall at position (%d, %d) which is not a wall in the original maze\",\n                          i+1, j+1);\n            } else if(c_contestant == '.') {\n                if(c_original == '#')\n                    quitf(_wa, \"Empty cell at position (%d, %d) corresponds to wall in original maze\", i+1, j+1);\n                emptyCellsContestant++;\n            }\n        }\n    }\n\n    if(xCount != k)\n        quitf(_wa, \"Number of 'X' in contestant's output is %d, expected %d\", xCount, k);\n\n    if(emptyCellsContestant == 0)\n        quitf(_wa, \"No empty cells in contestant's output\");\n\n    // Check that the remaining empty cells are connected\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<pair<int,int>> q;\n\n    // Find starting point\n    bool found_start = false;\n    for(int i = 0; i < n && !found_start; i++) {\n        for(int j = 0; j < m && !found_start; j++) {\n            if(contestantMaze[i][j] == '.') {\n                q.push({i, j});\n                visited[i][j] = true;\n                found_start = true;\n            }\n        }\n    }\n\n    int connectedEmptyCells = 0;\n\n    while(!q.empty()) {\n        auto [i, j] = q.front();\n        q.pop();\n        connectedEmptyCells++;\n        vector<pair<int,int>> neighbors = {{i-1,j}, {i+1,j}, {i,j-1}, {i,j+1}};\n        for(auto [ni, nj] : neighbors) {\n            if(ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                if(!visited[ni][nj] && contestantMaze[ni][nj] == '.') {\n                    visited[ni][nj] = true;\n                    q.push({ni, nj});\n                }\n            }\n        }\n    }\n\n    if(connectedEmptyCells != emptyCellsContestant)\n        quitf(_wa, \"Empty cells in contestant's output are not connected\");\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int s = 0; // number of empty cells\n\n    vector<string> maze(n, string(m, '#'));\n\n    if (type == \"full\") {\n        // All cells are empty\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n        }\n        s = n * m;\n    } else if (type == \"random\") {\n        // Generate a random connected maze\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        pair<int, int> start = {rnd.next(0, n - 1), rnd.next(0, m - 1)};\n\n        stack<pair<int, int>> stk;\n        stk.push(start);\n        visited[start.first][start.second] = true;\n        maze[start.first][start.second] = '.';\n        s = 1;\n        while (!stk.empty()) {\n            auto cell = stk.top();\n            int x = cell.first;\n            int y = cell.second;\n\n            vector<pair<int, int>> neighbors;\n            vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n            shuffle(dirs.begin(), dirs.end());\n\n            for (auto d : dirs) {\n                int nx = x + d.first;\n                int ny = y + d.second;\n                if (0 <= nx && nx < n && 0 <= ny && ny < m && !visited[nx][ny]) {\n                    neighbors.push_back({nx, ny});\n                }\n            }\n\n            if (!neighbors.empty()) {\n                int idx = rnd.next(0, (int)neighbors.size() - 1);\n                auto next_cell = neighbors[idx];\n                visited[next_cell.first][next_cell.second] = true;\n                maze[next_cell.first][next_cell.second] = '.';\n                s++;\n                stk.push(next_cell);\n            } else {\n                stk.pop();\n            }\n        }\n    } else if (type == \"snake\") {\n        // Create a snake-like path\n        int x = 0, y = 0;\n        maze[x][y] = '.';\n        s = 1;\n        bool dir = true; // true = right, false = left\n        while (true) {\n            if (dir) {\n                if (y + 1 < m) {\n                    y++;\n                } else if (x + 1 < n) {\n                    x++;\n                    dir = !dir;\n                } else\n                    break;\n            } else {\n                if (y - 1 >= 0) {\n                    y--;\n                } else if (x + 1 < n) {\n                    x++;\n                    dir = !dir;\n                } else\n                    break;\n            }\n            maze[x][y] = '.';\n            s++;\n        }\n    } else {\n        // Default to \"full\" if unknown type\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n        }\n        s = n * m;\n    }\n\n    // Now, check if k is in valid range\n    if (k < 0 || k >= s) {\n        fprintf(stderr, \"Invalid k: %d, number of empty cells: %d\\n\", k, s);\n        exit(1);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the maze\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", maze[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int s = 0; // number of empty cells\n\n    vector<string> maze(n, string(m, '#'));\n\n    if (type == \"full\") {\n        // All cells are empty\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n        }\n        s = n * m;\n    } else if (type == \"random\") {\n        // Generate a random connected maze\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        pair<int, int> start = {rnd.next(0, n - 1), rnd.next(0, m - 1)};\n\n        stack<pair<int, int>> stk;\n        stk.push(start);\n        visited[start.first][start.second] = true;\n        maze[start.first][start.second] = '.';\n        s = 1;\n        while (!stk.empty()) {\n            auto cell = stk.top();\n            int x = cell.first;\n            int y = cell.second;\n\n            vector<pair<int, int>> neighbors;\n            vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n            shuffle(dirs.begin(), dirs.end());\n\n            for (auto d : dirs) {\n                int nx = x + d.first;\n                int ny = y + d.second;\n                if (0 <= nx && nx < n && 0 <= ny && ny < m && !visited[nx][ny]) {\n                    neighbors.push_back({nx, ny});\n                }\n            }\n\n            if (!neighbors.empty()) {\n                int idx = rnd.next(0, (int)neighbors.size() - 1);\n                auto next_cell = neighbors[idx];\n                visited[next_cell.first][next_cell.second] = true;\n                maze[next_cell.first][next_cell.second] = '.';\n                s++;\n                stk.push(next_cell);\n            } else {\n                stk.pop();\n            }\n        }\n    } else if (type == \"snake\") {\n        // Create a snake-like path\n        int x = 0, y = 0;\n        maze[x][y] = '.';\n        s = 1;\n        bool dir = true; // true = right, false = left\n        while (true) {\n            if (dir) {\n                if (y + 1 < m) {\n                    y++;\n                } else if (x + 1 < n) {\n                    x++;\n                    dir = !dir;\n                } else\n                    break;\n            } else {\n                if (y - 1 >= 0) {\n                    y--;\n                } else if (x + 1 < n) {\n                    x++;\n                    dir = !dir;\n                } else\n                    break;\n            }\n            maze[x][y] = '.';\n            s++;\n        }\n    } else {\n        // Default to \"full\" if unknown type\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n        }\n        s = n * m;\n    }\n\n    // Now, check if k is in valid range\n    if (k < 0 || k >= s) {\n        fprintf(stderr, \"Invalid k: %d, number of empty cells: %d\\n\", k, s);\n        exit(1);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the maze\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", maze[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 0 -type full\n./gen -n 1 -m 1 -k 0 -type random\n\n./gen -n 2 -m 2 -k 0 -type full\n./gen -n 2 -m 2 -k 1 -type snake\n\n./gen -n 3 -m 3 -k 2 -type random\n\n./gen -n 10 -m 10 -k 0 -type full\n./gen -n 10 -m 10 -k 0 -type random\n\n./gen -n 20 -m 20 -k 399 -type full\n\n./gen -n 100 -m 100 -k 0 -type full\n./gen -n 100 -m 100 -k 9999 -type full\n\n./gen -n 500 -m 500 -k 0 -type full\n./gen -n 500 -m 500 -k 1 -type full\n./gen -n 500 -m 500 -k 249999 -type full\n\n./gen -n 50 -m 50 -k 100 -type random\n./gen -n 50 -m 50 -k 200 -type random\n\n./gen -n 100 -m 100 -k 10 -type snake\n./gen -n 100 -m 100 -k 50 -type snake\n\n./gen -n 5 -m 5 -k 0 -type snake\n./gen -n 5 -m 5 -k 3 -type snake\n\n./gen -n 30 -m 40 -k 300 -type random\n\n./gen -n 300 -m 400 -k 20000 -type random\n\n./gen -n 50 -m 50 -k 100 -type unknown\n\n./gen -n 500 -m 500 -k 50000 -type random\n\n./gen -n 500 -m 500 -k 100000 -type random\n\n./gen -n 500 -m 500 -k 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:39.467133",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "378/D",
      "title": "D. Preparing for the Contest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers: n, m and s (1 ≤ n, m ≤ 105, 0 ≤ s ≤ 109) — the number of students, the number of bugs in the system and the maximum number of passes the university is ready to give the students.The next line contains m space-separated integers a1, a2, ..., am (1 ≤ ai ≤ 109) — the bugs' complexities.The next line contains n space-separated integers b1, b2, ..., bn (1 ≤ bi ≤ 109) — the levels of the students' abilities.The next line contains n space-separated integers c1, c2, ..., cn (0 ≤ ci ≤ 109) — the numbers of the passes the students want to get for their help.",
      "output_spec": "OutputIf the university can't correct all bugs print \"NO\".Otherwise, on the first line print \"YES\", and on the next line print m space-separated integers: the i-th of these numbers should equal the number of the student who corrects the i-th bug in the optimal answer. The bugs should be corrected as quickly as possible (you must spend the minimum number of days), and the total given passes mustn't exceed s. If there are multiple optimal answers, you can output any of them.",
      "sample_tests": "ExamplesInputCopy3 4 91 3 1 22 1 34 3 6OutputCopyYES2 3 2 3InputCopy3 4 102 3 1 22 1 34 3 6OutputCopyYES1 3 1 3InputCopy3 4 92 3 1 22 1 34 3 6OutputCopyYES3 3 2 3InputCopy3 4 51 3 1 22 1 35 3 6OutputCopyNO",
      "description": "D. Preparing for the Contest\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers: n, m and s (1 ≤ n, m ≤ 105, 0 ≤ s ≤ 109) — the number of students, the number of bugs in the system and the maximum number of passes the university is ready to give the students.The next line contains m space-separated integers a1, a2, ..., am (1 ≤ ai ≤ 109) — the bugs' complexities.The next line contains n space-separated integers b1, b2, ..., bn (1 ≤ bi ≤ 109) — the levels of the students' abilities.The next line contains n space-separated integers c1, c2, ..., cn (0 ≤ ci ≤ 109) — the numbers of the passes the students want to get for their help.\n\nOutputIf the university can't correct all bugs print \"NO\".Otherwise, on the first line print \"YES\", and on the next line print m space-separated integers: the i-th of these numbers should equal the number of the student who corrects the i-th bug in the optimal answer. The bugs should be corrected as quickly as possible (you must spend the minimum number of days), and the total given passes mustn't exceed s. If there are multiple optimal answers, you can output any of them.\n\nInputCopy3 4 91 3 1 22 1 34 3 6OutputCopyYES2 3 2 3InputCopy3 4 102 3 1 22 1 34 3 6OutputCopyYES1 3 1 3InputCopy3 4 92 3 1 22 1 34 3 6OutputCopyYES3 3 2 3InputCopy3 4 51 3 1 22 1 35 3 6OutputCopyNO\n\nInputCopy3 4 91 3 1 22 1 34 3 6\n\nOutputCopyYES2 3 2 3\n\nInputCopy3 4 102 3 1 22 1 34 3 6\n\nOutputCopyYES1 3 1 3\n\nInputCopy3 4 92 3 1 22 1 34 3 6\n\nOutputCopyYES3 3 2 3\n\nInputCopy3 4 51 3 1 22 1 35 3 6\n\nOutputCopyNO\n\nNoteConsider the first sample.The third student (with level 3) must fix the 2nd and 4th bugs (complexities 3 and 2 correspondingly) and the second student (with level 1) must fix the 1st and 3rd bugs (their complexity also equals 1). Fixing each bug takes one day for each student, so it takes 2 days to fix all bugs (the students can work in parallel).The second student wants 3 passes for his assistance, the third student wants 6 passes. It meets the university's capabilities as it is ready to give at most 9 passes.",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Hi all!Authors of today's round are craus and dalex. We just couldn't miss the round with such a beautiful number, so at 19.30 MSK you will solve problems which were invented by Pavel and prepared by me.We thank Gerald and Delinur for their help in contest preparation and MikeMirzayanov for creating Codeforces.Scoring system and score distribution will be published when the round starts. Anyway this information makes no sense unless the round begins.We wish you accepted solutions and successful hacks!UPD. Contest is over, congratulations to the winners!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Problem analysis is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces",
          "content": "Link to announcement and discussion.And here is the problem analysis.A div 2: 378A - Playing with DiceMake three counters: for wins of both players and for a draw. Iterate over all six ways how they can throw a dice. For each way determine who wins or there is a draw and increment the corresponding counter.B div 2: 378B - SemifinalsYou can think a bit and understand that you should consider only corner cases: k = 0 and . All other cases will be something between them.If k = 0, we should choose n biggest elements from two sorted lists, one of the ways is to use two pointers method. And if , we just mark first people in each list.A div 1 / C div 2: 377A - MazeStart BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s - k free cells. It's obvious that these s - k cells are connected to each other. Remaining k cells can be transformed into the walls.Solutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test: ....\n.#..\n..##\n..##Top-left cell has no more neighbours than any other cell but we cannot transform it into the wall.B div 1 / D div 2: 377B - Preparing for the ContestIt's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.At first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money' — it's not enough as well. Otherwise we get the correct schedule.C div 1 / E div 2: 377C - Captains ModeThere are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans — in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.So now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m - 1.Unfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of — standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed — we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.Why it can be solved in m·2m? There is no point of missing a ban — if we ban the weakest hero, nothing will change since the weakest hero won't be picked.Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.D div 1: 377D - Developing GameLet's note that every answer is characterized with two numbers L and R so that max{li} ≤ L, R ≤ min{ri}, and L ≤ vi ≤ R. If we know L and R, we can check every person and choose those who satisfies the conditions above.Let's imagine a plane with the coordinate axes: one of the axes will be L, and the other will be R. If the point (L, R) on this plane is the optimal answer, people included in this answer for sure satisfy the conditions li ≤ L ≤ vi and vi ≤ R ≤ ri. These conditions specify the rectangle on the plane. Since we should find the maximum number of people, we should find such point (L, R) that it is inside the maximum number of the specified rectangles.Now it's the standard problem that can be solved using the scanline through one axis and the segment tree built on the other axis. The hardest part is to reduce the original problem to it.E div 1: 377E - Cookie ClickerFirst of all, throw away the buildings which cannot be used in any optimal answer: for each vi remain only one building that has speed equal to vi and minimal ci. Also throw away all buildings whose speed is less than the speed of the fastest building which has ci = 0.It's fairly obvious that at any time we should use the fastest building. And if some building is used in the optimal answer, it should be bought and used immediately when we have enough money (I will use the word 'money' instead of 'cookies').Let's imagine the plane (x, y) where x axis stands for the time and y axis stands for the money. We will maintain the graph of the function y = f(x) — 'maximal number of money that can be obtained at the time x' and process the buildings one by one, changing the graph. This function is the union of the line segments with the slopes equal to vi, and each of these line segments is active on a certain segment [xli, xri] of the axis x.For example, at the beginning the graph is just the line y = v1x, where v1 is the speed of building that can be bought for 0 units of money. Let the next building's price is c2. Find the minimal point x02 where value of our function is greater or equal to y = f(x02) ≥ c2 and buy this building at the moment x02. Then we should make the line y = y02 + v2x where y02 = f(x02) - c2 is the amount of money remaining after the purchase. Now we have two lines. Till some moment the first line is better (not till x02, maybe later), but as v2 > v1 there exists a moment of time (it's ceil(x12) where x12 is the x-coordinate of the lines' intersection) when the second line becomes better. Now we know the segments where a particular line is better than the others.Continue add all buildings to the graph this way. Line segments should be stored in stack, as in all problems with convex hull, and every step remove unnecessary line segments from the stack (these are the lines those position in the stack is after the line which has an intersection with the currently added line). After we process all buildings, we use our graph to find the minimal time when we have S untis of money.If we also should say which building we must use, we can store for any line segment its 'parent' — the line segment which was active when the current one was bought. With such parent array it's not hard to restore the sequence of buildings in the answer. We removed this part from the problem to make it a bit easier.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 378 和字母"
          },
          "content_length": 7318
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 — Problem Analysis - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000, \"b\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000, \"b\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(0, 1000000000, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000, \"b\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int m = inf.readInt();\n    long long s = inf.readLong();\n\n    vector<int> bugs(m);\n    for (int i = 0; i < m; ++i) {\n        bugs[i] = inf.readInt(1, 1000000000, format(\"bugs[%d]\", i + 1));\n    }\n\n    vector<int> abilities(n);\n    for (int i = 0; i < n; ++i) {\n        abilities[i] = inf.readInt(1, 1000000000, format(\"abilities[%d]\", i + 1));\n    }\n\n    vector<int> passes(n);\n    for (int i = 0; i < n; ++i) {\n        passes[i] = inf.readInt(0, 1000000000, format(\"passes[%d]\", i + 1));\n    }\n\n    // Read jury's answer\n    string jury_decision = ans.readToken();\n    if (jury_decision != \"YES\" && jury_decision != \"NO\")\n        quitf(_fail, \"Jury output is neither 'YES' nor 'NO', but '%s'\", jury_decision.c_str());\n\n    // Read participant's answer\n    string participant_decision = ouf.readToken();\n    if (participant_decision != \"YES\" && participant_decision != \"NO\")\n        quitf(_pe, \"Participant output is neither 'YES' nor 'NO', but '%s'\", participant_decision.c_str());\n\n    if (jury_decision == \"NO\") {\n        if (participant_decision != \"NO\") {\n            quitf(_wa, \"Participant claims a solution exists, but jury says it's impossible\");\n        } else {\n            // Both agree that no solution exists\n            quitf(_ok, \"Correctly outputs 'NO'\");\n        }\n    }\n\n    if (jury_decision == \"YES\") {\n        if (participant_decision != \"YES\") {\n            quitf(_wa, \"Participant outputs 'NO', but a valid solution exists\");\n        }\n\n        // Read jury's assignment\n        vector<int> jury_assignment(m);\n        set<int> jury_used_students;\n        long long jury_total_passes = 0;\n        map<int, int> jury_student_bug_count;\n\n        for (int i = 0; i < m; ++i) {\n            jury_assignment[i] = ans.readInt(1, n, format(\"jury_assignment[%d]\", i + 1)) - 1;\n            jury_used_students.insert(jury_assignment[i]);\n            jury_student_bug_count[jury_assignment[i]]++;\n        }\n\n        for (int student : jury_used_students) {\n            jury_total_passes += passes[student];\n        }\n\n        int jury_days = 0;\n        for (auto& p : jury_student_bug_count) {\n            jury_days = max(jury_days, p.second);\n        }\n\n        // Read participant's assignment\n        vector<int> participant_assignment(m);\n        set<int> participant_used_students;\n        long long participant_total_passes = 0;\n        map<int, int> participant_student_bug_count;\n\n        for (int i = 0; i < m; ++i) {\n            participant_assignment[i] = ouf.readInt(1, n, format(\"participant_assignment[%d]\", i + 1)) - 1;\n            int student = participant_assignment[i];\n            int bug = i;\n            int student_ability = abilities[student];\n            int bug_complexity = bugs[bug];\n            if (student_ability < bug_complexity) {\n                quitf(_wa, \"Student %d can't fix bug %d due to insufficient ability\", student + 1, bug + 1);\n            }\n            participant_used_students.insert(student);\n            participant_student_bug_count[student]++;\n        }\n\n        for (int student : participant_used_students) {\n            participant_total_passes += passes[student];\n            if (participant_total_passes > s) {\n                quitf(_wa, \"Total passes required (%lld) exceed 's' (%lld)\", participant_total_passes, s);\n            }\n        }\n\n        int participant_days = 0;\n        for (auto& p : participant_student_bug_count) {\n            participant_days = max(participant_days, p.second);\n        }\n\n        if (participant_days > jury_days) {\n            quitf(_wa, \"Participant's schedule requires more days (%d) than minimal days (%d)\", participant_days, jury_days);\n        } else if (participant_days == jury_days) {\n            quitf(_ok, \"Correct solution with minimal days (%d)\", participant_days);\n        } else { // participant_days < jury_days\n            quitf(_fail, \"Participant found a better solution (%d days) than the jury (%d days)\", participant_days, jury_days);\n        }\n    }\n\n    // Should never reach here\n    quitf(_fail, \"Unexpected end of checker\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n    vector<int> b(n);\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        // Generate random data\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else if (type == \"max_days\") {\n        // Generate data to maximize number of days\n        // Only one student can fix all the bugs\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        // Student 0 can fix all bugs\n        b[0] = (int)1e9; // Maximum ability\n        c[0] = 1; // Minimal passes\n        // Other students cannot fix any bug\n        for (int i = 1; i < n; ++i) {\n            b[i] = rnd.next(1, (int)(1e9/2)); // Abilities less than max(a_i)\n            c[i] = rnd.next(0, 10); // Random small c_i\n        }\n    } else if (type == \"min_s\") {\n        // Generate data where s is too small\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = rnd.next((int)1e9 - 1000, (int)1e9);\n        }\n        // Set s to a small value (already specified)\n    } else if (type == \"exact_s\") {\n        // Generate data where total c_i equals s\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        int k = min(n, m);\n        int c_total = 0;\n        for (int i = 0; i < k; ++i) {\n            b[i] = (int)1e9; // High ability\n            c[i] = s / k;\n            c_total += c[i];\n        }\n        int remainder = s - c_total;\n        c[0] += remainder; // Adjust to match s\n        // Other students\n        for (int i = k; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else if (type == \"unfixable\") {\n        // Generate data where bugs cannot be fixed\n        for (int i = 0; i < m; ++i)\n            a[i] = (int)1e9; // Max complexity\n        for (int i = 0; i < n; ++i) {\n            b[i] = 1; // Min ability\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else if (type == \"large_c\") {\n        // Set c_i to large values\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = (int)1e9; // Max passes\n        }\n    } else if (type == \"small_c\") {\n        // Set c_i to zero\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = 0; // Zero passes\n        }\n    } else if (type == \"edge_abilities\") {\n        // Set abilities equal to complexities\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = a[rnd.next(0, m - 1)]; // Abilities equal to some complexity\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the data\n\n    // First line: n m s\n    printf(\"%d %d %d\\n\", n, m, s);\n\n    // Second line: a1..am\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", a[i], (i+1==m)?'\\n':' ');\n\n    // Third line: b1..bn\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], (i+1==n)?'\\n':' ');\n\n    // Fourth line: c1..cn\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], (i+1==n)?'\\n':' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n    vector<int> b(n);\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        // Generate random data\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else if (type == \"max_days\") {\n        // Generate data to maximize number of days\n        // Only one student can fix all the bugs\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        // Student 0 can fix all bugs\n        b[0] = (int)1e9; // Maximum ability\n        c[0] = 1; // Minimal passes\n        // Other students cannot fix any bug\n        for (int i = 1; i < n; ++i) {\n            b[i] = rnd.next(1, (int)(1e9/2)); // Abilities less than max(a_i)\n            c[i] = rnd.next(0, 10); // Random small c_i\n        }\n    } else if (type == \"min_s\") {\n        // Generate data where s is too small\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = rnd.next((int)1e9 - 1000, (int)1e9);\n        }\n        // Set s to a small value (already specified)\n    } else if (type == \"exact_s\") {\n        // Generate data where total c_i equals s\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        int k = min(n, m);\n        int c_total = 0;\n        for (int i = 0; i < k; ++i) {\n            b[i] = (int)1e9; // High ability\n            c[i] = s / k;\n            c_total += c[i];\n        }\n        int remainder = s - c_total;\n        c[0] += remainder; // Adjust to match s\n        // Other students\n        for (int i = k; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else if (type == \"unfixable\") {\n        // Generate data where bugs cannot be fixed\n        for (int i = 0; i < m; ++i)\n            a[i] = (int)1e9; // Max complexity\n        for (int i = 0; i < n; ++i) {\n            b[i] = 1; // Min ability\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else if (type == \"large_c\") {\n        // Set c_i to large values\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = (int)1e9; // Max passes\n        }\n    } else if (type == \"small_c\") {\n        // Set c_i to zero\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = rnd.next(1, (int)1e9);\n            c[i] = 0; // Zero passes\n        }\n    } else if (type == \"edge_abilities\") {\n        // Set abilities equal to complexities\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            b[i] = a[rnd.next(0, m - 1)]; // Abilities equal to some complexity\n            c[i] = rnd.next(0, (int)1e9);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the data\n\n    // First line: n m s\n    printf(\"%d %d %d\\n\", n, m, s);\n\n    // Second line: a1..am\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", a[i], (i+1==m)?'\\n':' ');\n\n    // Third line: b1..bn\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], (i+1==n)?'\\n':' ');\n\n    // Fourth line: c1..cn\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], (i+1==n)?'\\n':' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -s 0 -type random\n./gen -n 1 -m 1 -s 0 -type random\n./gen -n 100000 -m 100000 -s 1000000000 -type random\n./gen -n 100000 -m 100000 -s 0 -type random\n./gen -n 1000 -m 100000 -s 500000 -type random\n./gen -n 1 -m 100000 -s 0 -type max_days\n./gen -n 100000 -m 1000 -s 1000000000 -type min_s\n./gen -n 100000 -m 100000 -s 1000000000 -type exact_s\n./gen -n 100000 -m 100000 -s 500000000 -type large_c\n./gen -n 100000 -m 100000 -s 0 -type small_c\n./gen -n 1000 -m 1000 -s 0 -type unfixable\n./gen -n 100000 -m 100000 -s 0 -type unfixable\n./gen -n 100000 -m 100000 -s 1000000000 -type edge_abilities\n./gen -n 50 -m 100000 -s 1000000000 -type max_days\n./gen -n 100000 -m 100000 -s 1000 -type min_s\n./gen -n 100000 -m 100000 -s 1000000000 -type exact_s\n./gen -n 2 -m 4 -s 10 -type random\n./gen -n 4 -m 2 -s 10 -type random\n./gen -n 1000 -m 1000 -s 1000000 -type large_c\n./gen -n 1000 -m 1000 -s 1000000 -type small_c\n./gen -n 100000 -m 10000 -s 1000000 -type edge_abilities\n./gen -n 50000 -m 50000 -s 999999999 -type random\n./gen -n 5 -m 5 -s 5 -type exact_s\n./gen -n 3 -m 4 -s 0 -type unfixable\n./gen -n 10 -m 10 -s 1 -type min_s\n./gen -n 10 -m 10 -s 1000000000 -type large_c\n./gen -n 1 -m 100000 -s 1000000000 -type max_days\n./gen -n 100000 -m 1 -s 1000000000 -type random\n./gen -n 1000 -m 100000 -s 1000000000 -type random\n./gen -n 100000 -m 100000 -s 0 -type small_c\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:41.558040",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "378/E",
      "title": "E. Captains Mode",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 100) — количество героев в Dota 2.Во второй строке записаны n целых чисел s1, s2, ..., sn (1 ≤ si ≤ 106) — силы всех героев.В третьей строке записано единственное целое число m (2 ≤ m ≤ min(n, 20)) — количество действий, которые должны выполнить капитаны команд.Следующие m строк имеют вид «action team», где action — действие, которое необходимо выполнить: пик (обозначающийся символом «p») или бан (обозначающийся символом «b»), а team — номер команды, которой предстоит выполнить это действие (число 1 или 2).Гарантируется, что каждая команда делает хотя бы один пик. Кроме того, количество пиков, совершаемых каждой командой, совпадает, и количество банов, совершаемых каждой командой, совпадает.",
      "output_spec": "Выходные данныеВыведите единственное целое число — разность между силой первой команды и силой второй команды, если капитаны обоих команд будут действовать оптимально.",
      "sample_tests": "ПримерыВходные данныеСкопировать22 12p 1p 2Выходные данныеСкопировать1Входные данныеСкопировать66 4 5 4 5 54b 2p 1b 1p 2Выходные данныеСкопировать0Входные данныеСкопировать41 2 3 44p 2b 2p 1b 1Выходные данныеСкопировать-2",
      "description": "E. Captains Mode\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 100) — количество героев в Dota 2.Во второй строке записаны n целых чисел s1, s2, ..., sn (1 ≤ si ≤ 106) — силы всех героев.В третьей строке записано единственное целое число m (2 ≤ m ≤ min(n, 20)) — количество действий, которые должны выполнить капитаны команд.Следующие m строк имеют вид «action team», где action — действие, которое необходимо выполнить: пик (обозначающийся символом «p») или бан (обозначающийся символом «b»), а team — номер команды, которой предстоит выполнить это действие (число 1 или 2).Гарантируется, что каждая команда делает хотя бы один пик. Кроме того, количество пиков, совершаемых каждой командой, совпадает, и количество банов, совершаемых каждой командой, совпадает.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — разность между силой первой команды и силой второй команды, если капитаны обоих команд будут действовать оптимально.\n\nВыходные данные\n\nВходные данныеСкопировать22 12p 1p 2Выходные данныеСкопировать1Входные данныеСкопировать66 4 5 4 5 54b 2p 1b 1p 2Выходные данныеСкопировать0Входные данныеСкопировать41 2 3 44p 2b 2p 1b 1Выходные данныеСкопировать-2\n\nВходные данныеСкопировать22 12p 1p 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать66 4 5 4 5 54b 2p 1b 1p 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 2 3 44p 2b 2p 1b 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #222 - Codeforces",
          "content": "Всем привет!Авторы сегодняшнего раунда — craus и dalex. Мы не могли просто так пропустить раунд с таким красивым номером, поэтому в 19.30 MSK вам придется решать задачи, которые Павел для вас придумал, а я подготовил.Благодарим Gerald и Delinur за помощь в подготовке соревнования и MikeMirzayanov за то, что у нас есть Codeforces.Систему подсчета баллов и их распределение вы узнаете вместе с началом раунда. Все равно эта информация не несет особого смысла, пока контест не начался.Полных решений и успешных взломов!UPD. Контест завершился, поздравляем победителей!Div. 1: 1. Petr 2. tourist 3. EgorDiv. 2: 1. k3e18 2. tongcx1988 3. LeMieuxUPD. 2 Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 674
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces",
          "content": "На всякий случай, ссылка на анонс и обсуждение.А теперь разбор.A div 2: 378A - Игра с кубикомЗаведем три счетчика: для побед каждого из игроков и для ничьи. Переберем все варианты, как можно выбросить кубик — их всего 6 штук. Для каждого варианта определим, кто выиграет, или будет ли ничья, и прибавим единицу к соответствующему счетчику.B div 2: 378B - ПолуфиналыМожно немного подумать и понять, что достаточно рассмотреть крайние случаи k = 0 и . Все остальные случаи будут средними между этими двумя.В случае k = 0 мы должны выбрать n максимальных элементов из двух посорченных списков, это можно сделать, например, двумя указателями. А в случае отметим первых спортсменов в каждом списке.A div 1 / C div 2: 377A - ЛабиринтЗапустим поиск в ширину или в глубину из любой свободной клетки. Так как лабиринт связный, этот поиск обойдет все s свободных клеток. Однако мы прервем этот поиск на том моменте, когда он посетит s - k свободных клеток. Очевидно, эти s - k клеток образуют связную область. Оставшиеся k клеток просто превратим в стены.Претесты проходило также решение, каждым ходом превращающее в стену ту клетку, у которой меньше всего соседей. Это неверно, например, на следующем тесте: ....\n.#..\n..##\n..##У левой верхней клетки не большее число соседей, чем у любой другой, однако ее нельзя превращать в стену.B div 1 / D div 2: 377B - Подготовка к соревнованиюОчевидно, что время исправления всех багов — функция монотонная: если можем сделать все за какое-то время, то сможем и за большее, поэтому будем искать ответ бинарным поиском. Так что пусть мы знаем время, за которое надо исправить все баги. Проверим, можно ли это сделать.Вначале отсортируем баги по сложности, а студентов по скиллу (это можно сделать один раз вне бинарного поиска). Посмотрим на самый сложный баг. Кто мог бы его исправить? Очевидно, его могут исправить те студенты, чей скилл не меньше сложности бага. Поместим всех таких студентов в очередь с приоритетами (в которой будет сортировка по стоимости студентов) и выберем оттуда самого дешевого. Так как мы проверяем время t, то этот студент должен пофиксить t самых сложных багов (он точно может их пофиксить). Отметим это, и перейдем к рассмотрению следующего непофикшенного бага. Снова поместим всех студентов, которые могли бы его исправить (по студентам надо проходиться параллельно с багами), в очередь с приоритетами и выберем самого дешевого. И так далее. Если в какой-то момент оказалось, что текущий баг не может исправить ни один студент (очередь с приоритетами пуста), значит время t не подходит в бинарном поиске. Если мы не уложились в требуемое количество зачетов — тоже не подходит. Иначе мы найдем нужное расписание.C div 1 / E div 2: 377C - Captains ModeЕсть несколько наблюдений, после которых задача становится очень простой. Первое наблюдение — пикать надо всегда самого сильного героя. А вот про баны ничего такого сказать нельзя, в разных ситуациях могут потребоваться самые разные баны. Самое важное наблюдение, которое поможет решить задачу — то, что рассматривать следует только m сильнейших героев. Действительно, при любой игре, где будут пикаться самые сильные герои в каждый момент времени, никакой герой, кроме первых m, не может быть пикнут вообще никогда. Значит, и банить их никогда не надо. И рассматривать тоже.В итоге у нас остается в худшем случае 20 героев, а, значит, можно решить задачу динамикой по подмножествам: dpmask — разность между силами команд в ситуации, когда пикнуты либо забанены те и только те герои, чьи биты в маске установлены в единицу. Для переходов перебираем героя, которого команда, чья очередь хода, будет пикать или банить. Проще всего реализовать это с помощью рекурсии с сохранением. Ответ будет храниться в dp2m - 1.К сожалению, мы неправильно оценили сложность этой задачи (несмотря на простое в реализации решение, придумать его, как выяснилось, было не так то и просто — стандартные 1500 баллов были бы лучше), и выставили неправильный TL (так что многие решения на C++ за m2·2m проходили — следовало опустить ограничение до одной секунды, а то и до 0.75 секунд). Так что если вы решили задачу за m2·2m, считайте, что вам повезло и что ваш вердикт — Time Limit Exceeded.Почему можно писать это за m·2m? Потому что пропуск бана не имеет смысла: вместо этого можно забанить самого слабого героя из доступных — ведь его точно никто никогда не пикнет.Здесь тоже были слабые претесты, поэтому можно было ломать тех, у кого в решении не было битмасок, чуть ли не любым большим случайным тестом.D div 1: 377D - Разработка игрыРассмотрим оптимальный ответ. Заметим, что каждый ответ характеризуется такими двумя числами L и R, что max{li} ≤ L, R ≤ min{ri}, и L ≤ vi ≤ R. Т.е., зная L и R, мы можем перебрать всех сотрудников и выбрать тех, что подходят под вышеперечисленные условия.Нарисуем плоскость, по оси абсцисс которой будем откладывать параметр L, а по оси ординат — R. Если точка (L, R) на этой плоскости является оптимальным ответом, то сотрудники, которые входят в ответ, обязательно удовлетворяют соотношениям li ≤ L ≤ vi и vi ≤ R ≤ ri. Эта область представляет собой прямоугольник на плоскости. Так как нам надо найти максимальное количество сотрудников, мы должны отыскать такую точку (L, R), что она входит в как можно большее количество указанных прямоугольников.Это уже совершенно стандартная задача, решающаяся с помощью сканирующей прямой по одной оси и дерева отрезков — по другой. Основная сложность — сведение к ней.E div 1: 377E - Cookie ClickerДля начала избавимся от вырожденных строений: оставим для каждого vi только строение с наименьшим ci при этом vi. А также выбросим все строения, скорость которых меньше скорости самого быстрого строения с ci = 0.Также довольно очевидно, что имеет смысл в каждый момент времени использовать только самое быстрое строение. И если мы будем в оптимальном ответе когда-нибудь использовать какое-либо строение, то купить его надо сразу же, как только появятся на это деньги (я буду называть печенья деньгами). И сразу же начать использовать.Представим себе плоскость (x, y), где по оси абсцисс будем откладывать время, а по оси ординат — деньги. Будем поддерживать график y = f(x) функции \"максимальное количество денег, которое можно заработать за время x\", добавляя на этот график поочередно по одному строению. Этот график представляет собой объединение отрезков прямых с угловыми коэффициентами vi, каждый из которых активен на некотором отрезке [xli, xri].К примеру, в начале это просто прямая y = v1x, где v1 — скорость строения, которое можно купить за 0 рублей. Пусть следующее по скорости строение можно купить за c2 рублей. Найдем минимальную точку x02, график функции в которой больше или равен y = f(x02) ≥ c2, и купим это строение в момент времени x02. Тогда мы должны построить прямую y = y02 + v2x, где y02 = f(x02) - c2 — сколько денег останется после покупки. Итого у нас есть две прямых. До какого-то момента (причем не до x02, а немного дольше) выгоднее будет старая прямая, но так как v2 > v1, найдется момент времени (это ceil(x12), где x12 — точка пересечения двух прямых), когда выгоднее станет новая прямая. Теперь отрезков прямых в графике две.Продолжим добавлять все строения таким образом. Отрезки прямых следует, как во всех задачах с выпуклой оболочкой, хранить в стеке и на каждом шаге отсекать те, которые уже не нужны (т.е. те, которые лежат в стеке после той, с которой было пересечение текущей добавляемой прямой). Обработав все строения, найдем минимальное время, за которое можно заработать S денег и выведем это число в ответ.Если требуется еще и сказать, какие строения надо при этом использовать, надо для каждого отрезка хранить тот, из которого он был получен (т.е. тот, который использовался перед тем, как мы купили этот). Имея такой \"массив предков\", нетрудно восстановить ответ. Чтобы задача стала немного проще, мы убрали из финальной версии вывод сертификата.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10157",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 378 和字母"
          },
          "content_length": 7872
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #222 - Codeforces - Code 1",
          "code": "successful hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 2",
          "code": "8\n100 100 100 99 0 0 0 0\n6\nb 1\np 2\np 1\np 1\np 2\nb 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 3",
          "code": "8\n100 100 100 99 0 0 0 0\n6\nb 1\np 2\np 1\np 1\np 2\nb 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 4",
          "code": "/usr/include/c++/4.8.2/bits/stl_queue.h:483:error: attempt to access an \n    element in an empty container.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffd9f148 {\n  type = St14priority_queueISt4pairIiiENSt7__debug6vectorIS1_SaIS1_EEESt7greaterIS1_EE;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #222 - Codeforces - Code 5",
          "code": "if(a[q[qe-1]].v<a[i].v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10138",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 1",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 2",
          "code": "....\n.#..\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 3",
          "code": "set <pll> :: iterator it = lower_bound( a.begin(), a.end(), make_pair(b[i].first, -1) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 4",
          "code": "set <pll> :: iterator it = lower_bound( a.begin(), a.end(), make_pair(b[i].first, -1) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 5",
          "code": "set <pll> :: iterator it = a.lower_bound(make_pair(b[i].first, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #222 - Codeforces - Code 6",
          "code": "set <pll> :: iterator it = a.lower_bound(make_pair(b[i].first, -1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10157",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n    \n    int m = inf.readInt(2, min(n, 20), \"m\");\n    inf.readEoln();\n    \n    int picks_team[3] = {0, 0, 0}; // Index 1 and 2\n    int bans_team[3] = {0, 0, 0};\n    int total_picks = 0;\n    int total_bans = 0;\n\n    for (int i = 0; i < m; ++i) {\n        string action = inf.readToken();\n        inf.readSpace();\n        int team = inf.readInt(1, 2, \"team\");\n        inf.readEoln();\n\n        ensuref(action == \"p\" || action == \"b\", \"action must be 'p' or 'b', but found '%s'\", action.c_str());\n\n        if (action == \"p\") {\n            picks_team[team]++;\n            total_picks++;\n        } else if (action == \"b\") {\n            bans_team[team]++;\n            total_bans++;\n        }\n    }\n\n    ensuref(picks_team[1] >= 1, \"Team 1 must make at least one pick\");\n    ensuref(picks_team[2] >= 1, \"Team 2 must make at least one pick\");\n\n    ensuref(picks_team[1] == picks_team[2], \"Both teams must have the same number of picks\");\n    ensuref(bans_team[1] == bans_team[2], \"Both teams must have the same number of bans\");\n\n    ensuref(total_picks + total_bans <= n, \"Total picks and bans (%d) cannot exceed n (%d)\", total_picks + total_bans, n);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n    \n    int m = inf.readInt(2, min(n, 20), \"m\");\n    inf.readEoln();\n    \n    int picks_team[3] = {0, 0, 0}; // Index 1 and 2\n    int bans_team[3] = {0, 0, 0};\n    int total_picks = 0;\n    int total_bans = 0;\n\n    for (int i = 0; i < m; ++i) {\n        string action = inf.readToken();\n        inf.readSpace();\n        int team = inf.readInt(1, 2, \"team\");\n        inf.readEoln();\n\n        ensuref(action == \"p\" || action == \"b\", \"action must be 'p' or 'b', but found '%s'\", action.c_str());\n\n        if (action == \"p\") {\n            picks_team[team]++;\n            total_picks++;\n        } else if (action == \"b\") {\n            bans_team[team]++;\n            total_bans++;\n        }\n    }\n\n    ensuref(picks_team[1] >= 1, \"Team 1 must make at least one pick\");\n    ensuref(picks_team[2] >= 1, \"Team 2 must make at least one pick\");\n\n    ensuref(picks_team[1] == picks_team[2], \"Both teams must have the same number of picks\");\n    ensuref(bans_team[1] == bans_team[2], \"Both teams must have the same number of bans\");\n\n    ensuref(total_picks + total_bans <= n, \"Total picks and bans (%d) cannot exceed n (%d)\", total_picks + total_bans, n);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> s = inf.readInts(n, 1, 1000000, \"s\");\n    inf.readEoln();\n    \n    int m = inf.readInt(2, min(n, 20), \"m\");\n    inf.readEoln();\n    \n    int picks_team[3] = {0, 0, 0}; // Index 1 and 2\n    int bans_team[3] = {0, 0, 0};\n    int total_picks = 0;\n    int total_bans = 0;\n\n    for (int i = 0; i < m; ++i) {\n        string action = inf.readToken();\n        inf.readSpace();\n        int team = inf.readInt(1, 2, \"team\");\n        inf.readEoln();\n\n        ensuref(action == \"p\" || action == \"b\", \"action must be 'p' or 'b', but found '%s'\", action.c_str());\n\n        if (action == \"p\") {\n            picks_team[team]++;\n            total_picks++;\n        } else if (action == \"b\") {\n            bans_team[team]++;\n            total_bans++;\n        }\n    }\n\n    ensuref(picks_team[1] >= 1, \"Team 1 must make at least one pick\");\n    ensuref(picks_team[2] >= 1, \"Team 2 must make at least one pick\");\n\n    ensuref(picks_team[1] == picks_team[2], \"Both teams must have the same number of picks\");\n    ensuref(bans_team[1] == bans_team[2], \"Both teams must have the same number of bans\");\n\n    ensuref(total_picks + total_bans <= n, \"Total picks and bans (%d) cannot exceed n (%d)\", total_picks + total_bans, n);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(2 <= n && n <= 100, \"n must be between 2 and 100\");\n    ensuref(2 <= m && m <= min(n, 20), \"m must be between 2 and min(n,20)\");\n\n    vector<int> strengths(n);\n\n    vector<pair<char, int>> actions;\n\n    if (type == \"random\") {\n        // Random strengths between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = rnd.next(1, 1000000);\n        }\n\n        // Decide p (number of picks per team)\n        int max_picks_per_team = m / 2;\n        int p = rnd.next(1, max_picks_per_team);\n        if ((m - 2 * p) % 2 != 0) {\n            if (p > 1) p--;\n            else p++;\n        }\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        ensuref(total_picks + total_bans == m, \"Total actions must sum up to m\");\n        ensuref(p >= 1, \"Each team must make at least one pick\");\n        ensuref(b >= 0, \"Number of bans per team cannot be negative\");\n        ensuref(total_picks + total_bans <= n, \"Total picks and bans cannot exceed n\");\n\n        // Generate picks and bans\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 1});\n            actions.push_back({'b', 2});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else if (type == \"equal_strength\") {\n        int s = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = s;\n        }\n\n        // Generate actions similar to \"random\"\n        int max_picks_per_team = m / 2;\n        int p = rnd.next(1, max_picks_per_team);\n        if ((m - 2 * p) % 2 != 0) {\n            if (p > 1) p--;\n            else p++;\n        }\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        ensuref(total_picks + total_bans == m, \"Total actions must sum up to m\");\n        ensuref(p >= 1, \"Each team must make at least one pick\");\n        ensuref(b >= 0, \"Number of bans per team cannot be negative\");\n        ensuref(total_picks + total_bans <= n, \"Total picks and bans cannot exceed n\");\n\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 1});\n            actions.push_back({'b', 2});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else if (type == \"max_advantage\") {\n        // Design strengths to give one team maximum advantage\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = 1000000 - i;\n        }\n\n        // Picks and bans favoring team 1\n        int p = m / 4; // At least one pick per team\n        if (p < 1) p = 1;\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n        }\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 2});\n            actions.push_back({'b', 1});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else if (type == \"miss_picks\") {\n        // Two high strengths, rest low\n        strengths[0] = 1000000;\n        strengths[1] = 999999;\n        for (int i = 2; i < n; ++i) {\n            strengths[i] = 1;\n        }\n\n        // Action sequence designed to test missed picks\n        m = 4;\n        actions.push_back({'b', 1});\n        actions.push_back({'p', 2});\n        actions.push_back({'b', 2});\n        actions.push_back({'p', 1});\n\n    } else if (type == \"alternate_picks_bans\") {\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = rnd.next(1, 1000000);\n        }\n\n        for (int i = 0; i < m / 4; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'b', 2});\n            actions.push_back({'p', 2});\n            actions.push_back({'b', 1});\n        }\n\n        while ((int)actions.size() < m) {\n            actions.push_back({'b', rnd.next(1,2)});\n        }\n\n    } else if (type == \"min_n_m\") {\n        n = 2; m = 2;\n        strengths[0] = 1;\n        strengths[1] = 1;\n        actions.push_back({'p', 1});\n        actions.push_back({'p', 2});\n    } else if (type == \"max_n_m\") {\n        n = 100; m = 20;\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = rnd.next(1, 1000000);\n        }\n\n        int p = m / 2 / 2;\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 1});\n            actions.push_back({'b', 2});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else {\n        printf(\"Unknown type!\\n\");\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", strengths[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%c %d\\n\", actions[i].first, actions[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(2 <= n && n <= 100, \"n must be between 2 and 100\");\n    ensuref(2 <= m && m <= min(n, 20), \"m must be between 2 and min(n,20)\");\n\n    vector<int> strengths(n);\n\n    vector<pair<char, int>> actions;\n\n    if (type == \"random\") {\n        // Random strengths between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = rnd.next(1, 1000000);\n        }\n\n        // Decide p (number of picks per team)\n        int max_picks_per_team = m / 2;\n        int p = rnd.next(1, max_picks_per_team);\n        if ((m - 2 * p) % 2 != 0) {\n            if (p > 1) p--;\n            else p++;\n        }\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        ensuref(total_picks + total_bans == m, \"Total actions must sum up to m\");\n        ensuref(p >= 1, \"Each team must make at least one pick\");\n        ensuref(b >= 0, \"Number of bans per team cannot be negative\");\n        ensuref(total_picks + total_bans <= n, \"Total picks and bans cannot exceed n\");\n\n        // Generate picks and bans\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 1});\n            actions.push_back({'b', 2});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else if (type == \"equal_strength\") {\n        int s = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = s;\n        }\n\n        // Generate actions similar to \"random\"\n        int max_picks_per_team = m / 2;\n        int p = rnd.next(1, max_picks_per_team);\n        if ((m - 2 * p) % 2 != 0) {\n            if (p > 1) p--;\n            else p++;\n        }\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        ensuref(total_picks + total_bans == m, \"Total actions must sum up to m\");\n        ensuref(p >= 1, \"Each team must make at least one pick\");\n        ensuref(b >= 0, \"Number of bans per team cannot be negative\");\n        ensuref(total_picks + total_bans <= n, \"Total picks and bans cannot exceed n\");\n\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 1});\n            actions.push_back({'b', 2});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else if (type == \"max_advantage\") {\n        // Design strengths to give one team maximum advantage\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = 1000000 - i;\n        }\n\n        // Picks and bans favoring team 1\n        int p = m / 4; // At least one pick per team\n        if (p < 1) p = 1;\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n        }\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 2});\n            actions.push_back({'b', 1});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else if (type == \"miss_picks\") {\n        // Two high strengths, rest low\n        strengths[0] = 1000000;\n        strengths[1] = 999999;\n        for (int i = 2; i < n; ++i) {\n            strengths[i] = 1;\n        }\n\n        // Action sequence designed to test missed picks\n        m = 4;\n        actions.push_back({'b', 1});\n        actions.push_back({'p', 2});\n        actions.push_back({'b', 2});\n        actions.push_back({'p', 1});\n\n    } else if (type == \"alternate_picks_bans\") {\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = rnd.next(1, 1000000);\n        }\n\n        for (int i = 0; i < m / 4; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'b', 2});\n            actions.push_back({'p', 2});\n            actions.push_back({'b', 1});\n        }\n\n        while ((int)actions.size() < m) {\n            actions.push_back({'b', rnd.next(1,2)});\n        }\n\n    } else if (type == \"min_n_m\") {\n        n = 2; m = 2;\n        strengths[0] = 1;\n        strengths[1] = 1;\n        actions.push_back({'p', 1});\n        actions.push_back({'p', 2});\n    } else if (type == \"max_n_m\") {\n        n = 100; m = 20;\n        for (int i = 0; i < n; ++i) {\n            strengths[i] = rnd.next(1, 1000000);\n        }\n\n        int p = m / 2 / 2;\n        int total_picks = 2 * p;\n        int total_bans = m - total_picks;\n        int b = total_bans / 2;\n\n        for (int i = 0; i < p; ++i) {\n            actions.push_back({'p', 1});\n            actions.push_back({'p', 2});\n        }\n        for (int i = 0; i < b; ++i) {\n            actions.push_back({'b', 1});\n            actions.push_back({'b', 2});\n        }\n\n        shuffle(actions.begin(), actions.end());\n\n    } else {\n        printf(\"Unknown type!\\n\");\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", strengths[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%c %d\\n\", actions[i].first, actions[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type min_n_m\n./gen -n 100 -m 20 -type max_n_m\n./gen -n 2 -m 2 -type random\n./gen -n 3 -m 2 -type random\n./gen -n 5 -m 4 -type random\n./gen -n 10 -m 6 -type random\n./gen -n 20 -m 10 -type random\n./gen -n 50 -m 14 -type random\n./gen -n 100 -m 20 -type random\n./gen -n 20 -m 8 -type equal_strength\n./gen -n 50 -m 10 -type equal_strength\n./gen -n 100 -m 20 -type equal_strength\n./gen -n 4 -m 4 -type miss_picks\n./gen -n 6 -m 6 -type miss_picks\n./gen -n 10 -m 8 -type miss_picks\n./gen -n 100 -m 20 -type miss_picks\n./gen -n 10 -m 6 -type alternate_picks_bans\n./gen -n 50 -m 14 -type alternate_picks_bans\n./gen -n 100 -m 20 -type alternate_picks_bans\n./gen -n 3 -m 2 -type max_advantage\n./gen -n 10 -m 6 -type max_advantage\n./gen -n 50 -m 10 -type max_advantage\n./gen -n 100 -m 20 -type max_advantage\n./gen -n 2 -m 2 -type equal_strength\n./gen -n 3 -m 2 -type equal_strength\n./gen -n 5 -m 4 -type equal_strength\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:43.846710",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "379/A",
      "title": "A. New Year Candles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two integers, a and b (1 ≤ a ≤ 1000; 2 ≤ b ≤ 1000).",
      "output_spec": "OutputPrint a single integer — the number of hours Vasily can light up the room for.",
      "sample_tests": "ExamplesInputCopy4 2OutputCopy7InputCopy6 3OutputCopy8",
      "description": "A. New Year Candles\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two integers, a and b (1 ≤ a ≤ 1000; 2 ≤ b ≤ 1000).\n\nOutputPrint a single integer — the number of hours Vasily can light up the room for.\n\nInputCopy4 2OutputCopy7InputCopy6 3OutputCopy8\n\nInputCopy4 2\n\nOutputCopy7\n\nInputCopy6 3\n\nOutputCopy8\n\nNoteConsider the first sample. For the first four hours Vasily lights up new candles, then he uses four burned out candles to make two new ones and lights them up. When these candles go out (stop burning), Vasily can make another candle. Overall, Vasily can light up the room for 7 hours.",
      "solutions": [
        {
          "title": "Good Bye 2013 - Codeforces",
          "content": "Good day)Welcome to the last Codeforces round in this year Good Bye 2013. This round will be unusual because it will be common for participants of both divisions.The problems were prepared by authors Gerald Agapov (Gerald) and Svechnikov Artur (ikar). Pavel Kholkin (HolkinPV) and Vitaly Aksenov (Aksenov239) also help us to prepare the problems. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is similar to standard — 500-1000-1500-2000-2500-3000-3500UPD2: Thanks to all participants, we hope everyone enjoyed prepared tasks. Problem analysis. UPD3: Congratulations to the winners of the last round in this year. Rating will be changed in a few hours.1. BaconLi2. Egor3. liympanda We wish everyone good luck, high rating and excellent mood)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10161",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 868
        },
        {
          "title": "Tutorial Good Bye 2013 - Codeforces",
          "content": "Excuse me for my english, but I tried very hard to.=)A: 379A - New Year CandlesLet cura amount of new candles, curb — amount of burnt out. Initially cura = a, curb = 0, after burning all cura new candles, amount of hours incremented by cura and curb +  = cura, lets make all burnt out candles into new cura = curb / b , repeat this algorithm until we can make at least one new candle. #### B: 379B - New Year Present If wallet contains more then one coin, then between orders to \"put a coin\" we can orders to move to adjacent wallet then back. Since for each orders to \"put a coin\" we spend at most 2 other orders, number of total orders for maximum test equals 300 * 300 * 3 = 270000 it less then 106.C: 379C - New Year Ratings ChangeWe can to sort ratings in nondecrease order, then iterate by them we can keep minimal rating not used before. If ai > cur, i's user recieve ai of rating and cur = ai + 1, else ai ≤ cur then i's user recieve cur of rating and cur increased by one. D: 379D - New Year LetterWe can't fairly calculate sk because of length of this string which can be very large. But note that whole string not need, we just need number of AC substrings, first and last letter. That help us to easy calculate number AC substrings for any sk for some s1, s2. Let's iterate through s1, s2 using alphabet of A, C, and any other letter. We need just first and last letter and number of AC. Using some s1, s2 we can calculate sk.E: 379E - New Year Tree DecorationsLet's keep union of first i pieces, S(i) denote the area of union for the first i pieces. Then to know visible part of i's piece we need to calculate S(i) - S(i - 1), (Unable to parse markup [type=CF_TEX] and with end at x = 1. Union looks like a downward convex polyline, lets represent it sequence of points, adjacent are connected. So calculate i's union, if new union will be contains new segment, this segment must intersects two segments of union, this intersection we can calculate for the amount of points in union. All points lower than new segment must be erased from union. Because each segment can add at most one point in union calculating of one range is O(n2).F: 379F - New Year TreeComing soon.G: 379G - New Year CactusThis problem can be solved for tree by using of dynamic programming d[v][c][a], where v — vertex, c — type of vertex(whose toys are hanged or nothing are hanged there), a — number of toys hanged by Jack for this subtree, d[v][c][a] denote of maximum number of toys which can be hanged by Jill. Value d[v][c][a] can be calculated iterated through sons of v vertext and type of these vertices. Let's compress our cactus into tree by compressing each cycle into vertex. Vertex of tree will be looks like sequence of vertex from cactus which have edges not from this cycle and intermediates that belongs only to this cycle. Now we can calculate all d[v][c][a] for this tree but we must be carefully processing a vertices.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 379\\s*A"
          },
          "content_length": 2925
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2013 - Codeforces - Code 1",
          "code": "while (vet[u] <= l) ++vet[u];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 2",
          "code": "while(v[i].a<=v[i-1].a) v[i].a++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 3",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 4",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 5",
          "code": "Codeforces Round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 6",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 7",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 8",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 9",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 10",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 11",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 12",
          "code": "a[i] < a[x]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 13",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 14",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 15",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(2, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(2, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(2, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int a_min = 1;\n    const int a_max = 1000;\n    const int b_min = 2;\n    const int b_max = 1000;\n\n    if (type == \"min_values\") {\n        a = a_min;\n        b = b_min;\n    } else if (type == \"max_values\") {\n        a = a_max;\n        b = b_max;\n    } else if (type == \"b_equals_2\") {\n        b = 2;\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n    } else if (type == \"b_equals_max\") {\n        b = b_max;\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n    } else if (type == \"a_equals_b\") {\n        if (a == -1)\n            a = rnd.next(max(a_min, b_min), min(a_max, b_max));\n        else\n            a = min(max(a, max(a_min, b_min)), min(a_max, b_max));\n        b = a;\n    } else if (type == \"b_greater_than_a\") {\n        if (a == -1)\n            a = rnd.next(a_min, a_max - 1);\n        else\n            a = min(max(a, a_min), a_max - 1);\n        if (b == -1)\n            b = rnd.next(a + 1, b_max);\n        else\n            b = min(max(b, a + 1), b_max);\n    } else if (type == \"a_is_1\") {\n        a = 1;\n        if (b == -1)\n            b = rnd.next(b_min, b_max);\n        else\n            b = min(max(b, b_min), b_max);\n    } else if (type == \"random\") {\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n        if (b == -1)\n            b = rnd.next(b_min, b_max);\n        else\n            b = min(max(b, b_min), b_max);\n    } else {\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n        if (b == -1)\n            b = rnd.next(b_min, b_max);\n        else\n            b = min(max(b, b_min), b_max);\n    }\n\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int a_min = 1;\n    const int a_max = 1000;\n    const int b_min = 2;\n    const int b_max = 1000;\n\n    if (type == \"min_values\") {\n        a = a_min;\n        b = b_min;\n    } else if (type == \"max_values\") {\n        a = a_max;\n        b = b_max;\n    } else if (type == \"b_equals_2\") {\n        b = 2;\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n    } else if (type == \"b_equals_max\") {\n        b = b_max;\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n    } else if (type == \"a_equals_b\") {\n        if (a == -1)\n            a = rnd.next(max(a_min, b_min), min(a_max, b_max));\n        else\n            a = min(max(a, max(a_min, b_min)), min(a_max, b_max));\n        b = a;\n    } else if (type == \"b_greater_than_a\") {\n        if (a == -1)\n            a = rnd.next(a_min, a_max - 1);\n        else\n            a = min(max(a, a_min), a_max - 1);\n        if (b == -1)\n            b = rnd.next(a + 1, b_max);\n        else\n            b = min(max(b, a + 1), b_max);\n    } else if (type == \"a_is_1\") {\n        a = 1;\n        if (b == -1)\n            b = rnd.next(b_min, b_max);\n        else\n            b = min(max(b, b_min), b_max);\n    } else if (type == \"random\") {\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n        if (b == -1)\n            b = rnd.next(b_min, b_max);\n        else\n            b = min(max(b, b_min), b_max);\n    } else {\n        if (a == -1)\n            a = rnd.next(a_min, a_max);\n        else\n            a = min(max(a, a_min), a_max);\n        if (b == -1)\n            b = rnd.next(b_min, b_max);\n        else\n            b = min(max(b, b_min), b_max);\n    }\n\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_values\n\n./gen -type max_values\n\n./gen -type b_equals_2\n\n./gen -type b_equals_2 -a 1\n\n./gen -type b_equals_2 -a 1000\n\n./gen -type b_equals_max\n\n./gen -type b_equals_max -a 1\n\n./gen -type b_equals_max -a 1000\n\n./gen -type a_equals_b\n\n./gen -type a_equals_b -a 2\n\n./gen -type a_equals_b -a 999\n\n./gen -type b_greater_than_a\n\n./gen -type b_greater_than_a -a 999\n\n./gen -type b_greater_than_a -a 1\n\n./gen -type a_is_1\n\n./gen -type a_is_1 -b 2\n\n./gen -type a_is_1 -b 1000\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -a 500 -b 2\n\n./gen -a 500 -b 1000\n\n./gen -a 1 -b 2\n\n./gen -a 1000 -b 2\n\n./gen -a 1000 -b 1000\n\n./gen -a 1 -b 1000\n\n./gen -type random\n\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:46.365108",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "379/B",
      "title": "B. New Year Present",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 300) — the number of wallets. The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 300).It is guaranteed that at least one ai is positive.",
      "output_spec": "OutputPrint the sequence that consists of k (1 ≤ k ≤ 106) characters, each of them equals: \"L\", \"R\" or \"P\". Each character of the sequence is an instruction to the robot. Character \"L\" orders to move to the left, character \"R\" orders to move to the right, character \"P\" orders the robot to put a coin in the wallet. The robot is not allowed to go beyond the wallet line. In other words, you cannot give instructions \"L\" if the robot is at wallet 1, or \"R\" at wallet n.As a result of the performed operations, the i-th wallet from the left must contain exactly ai coins. If there are multiple answers, you can print any of them.",
      "sample_tests": "ExamplesInputCopy21 2OutputCopyPRPLRPInputCopy40 2 0 2OutputCopyRPRRPLLPLRRRP",
      "description": "B. New Year Present\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 300) — the number of wallets. The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 300).It is guaranteed that at least one ai is positive.\n\nOutputPrint the sequence that consists of k (1 ≤ k ≤ 106) characters, each of them equals: \"L\", \"R\" or \"P\". Each character of the sequence is an instruction to the robot. Character \"L\" orders to move to the left, character \"R\" orders to move to the right, character \"P\" orders the robot to put a coin in the wallet. The robot is not allowed to go beyond the wallet line. In other words, you cannot give instructions \"L\" if the robot is at wallet 1, or \"R\" at wallet n.As a result of the performed operations, the i-th wallet from the left must contain exactly ai coins. If there are multiple answers, you can print any of them.\n\nInputCopy21 2OutputCopyPRPLRPInputCopy40 2 0 2OutputCopyRPRRPLLPLRRRP\n\nInputCopy21 2\n\nOutputCopyPRPLRP\n\nInputCopy40 2 0 2\n\nOutputCopyRPRRPLLPLRRRP",
      "solutions": [
        {
          "title": "Good Bye 2013 - Codeforces",
          "content": "Good day)Welcome to the last Codeforces round in this year Good Bye 2013. This round will be unusual because it will be common for participants of both divisions.The problems were prepared by authors Gerald Agapov (Gerald) and Svechnikov Artur (ikar). Pavel Kholkin (HolkinPV) and Vitaly Aksenov (Aksenov239) also help us to prepare the problems. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is similar to standard — 500-1000-1500-2000-2500-3000-3500UPD2: Thanks to all participants, we hope everyone enjoyed prepared tasks. Problem analysis. UPD3: Congratulations to the winners of the last round in this year. Rating will be changed in a few hours.1. BaconLi2. Egor3. liympanda We wish everyone good luck, high rating and excellent mood)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10161",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 868
        },
        {
          "title": "Tutorial Good Bye 2013 - Codeforces",
          "content": "Excuse me for my english, but I tried very hard to.=)A: 379A - New Year CandlesLet cura amount of new candles, curb — amount of burnt out. Initially cura = a, curb = 0, after burning all cura new candles, amount of hours incremented by cura and curb +  = cura, lets make all burnt out candles into new cura = curb / b , repeat this algorithm until we can make at least one new candle. #### B: 379B - New Year Present If wallet contains more then one coin, then between orders to \"put a coin\" we can orders to move to adjacent wallet then back. Since for each orders to \"put a coin\" we spend at most 2 other orders, number of total orders for maximum test equals 300 * 300 * 3 = 270000 it less then 106.C: 379C - New Year Ratings ChangeWe can to sort ratings in nondecrease order, then iterate by them we can keep minimal rating not used before. If ai > cur, i's user recieve ai of rating and cur = ai + 1, else ai ≤ cur then i's user recieve cur of rating and cur increased by one. D: 379D - New Year LetterWe can't fairly calculate sk because of length of this string which can be very large. But note that whole string not need, we just need number of AC substrings, first and last letter. That help us to easy calculate number AC substrings for any sk for some s1, s2. Let's iterate through s1, s2 using alphabet of A, C, and any other letter. We need just first and last letter and number of AC. Using some s1, s2 we can calculate sk.E: 379E - New Year Tree DecorationsLet's keep union of first i pieces, S(i) denote the area of union for the first i pieces. Then to know visible part of i's piece we need to calculate S(i) - S(i - 1), (Unable to parse markup [type=CF_TEX] and with end at x = 1. Union looks like a downward convex polyline, lets represent it sequence of points, adjacent are connected. So calculate i's union, if new union will be contains new segment, this segment must intersects two segments of union, this intersection we can calculate for the amount of points in union. All points lower than new segment must be erased from union. Because each segment can add at most one point in union calculating of one range is O(n2).F: 379F - New Year TreeComing soon.G: 379G - New Year CactusThis problem can be solved for tree by using of dynamic programming d[v][c][a], where v — vertex, c — type of vertex(whose toys are hanged or nothing are hanged there), a — number of toys hanged by Jack for this subtree, d[v][c][a] denote of maximum number of toys which can be hanged by Jill. Value d[v][c][a] can be calculated iterated through sons of v vertext and type of these vertices. Let's compress our cactus into tree by compressing each cycle into vertex. Vertex of tree will be looks like sequence of vertex from cactus which have edges not from this cycle and intermediates that belongs only to this cycle. Now we can calculate all d[v][c][a] for this tree but we must be carefully processing a vertices.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 379\\s*B"
          },
          "content_length": 2925
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2013 - Codeforces - Code 1",
          "code": "while (vet[u] <= l) ++vet[u];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 2",
          "code": "while(v[i].a<=v[i-1].a) v[i].a++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 3",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 4",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 5",
          "code": "Codeforces Round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 6",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 7",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 8",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 9",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 10",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 11",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 12",
          "code": "a[i] < a[x]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 13",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 14",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 15",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 300, \"a\");\n    inf.readEoln();\n    \n    int positive_count = 0;\n    for (int i = 0; i < n; i++) {\n        if (a[i] > 0) {\n            positive_count++;\n        }\n    }\n    ensuref(positive_count >= 1, \"At least one a_i must be positive\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 300, \"a\");\n    inf.readEoln();\n    \n    int positive_count = 0;\n    for (int i = 0; i < n; i++) {\n        if (a[i] > 0) {\n            positive_count++;\n        }\n    }\n    ensuref(positive_count >= 1, \"At least one a_i must be positive\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 300, \"a\");\n    inf.readEoln();\n    \n    int positive_count = 0;\n    for (int i = 0; i < n; i++) {\n        if (a[i] > 0) {\n            positive_count++;\n        }\n    }\n    ensuref(positive_count >= 1, \"At least one a_i must be positive\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(2, 300, \"n\");\n    vector<int> ai(n);\n\n    for (int i = 0; i < n; i++) {\n        ai[i] = inf.readInt(0, 300, format(\"a[%d]\", i + 1).c_str());\n    }\n\n    // Read the contestant's output\n    string instructions = ouf.readString();\n    int k = instructions.size();\n\n    if (k < 1 || k > 1000000)\n        quitf(_wa, \"Number of instructions is %d, which is outside the allowed range [1..10^6]\", k);\n\n    int pos = 1; // Robot's current position (1-indexed)\n    vector<int> wallets(n, 0); // Counts of coins in each wallet\n    char prev_c = 'X'; // Previous instruction character\n\n    for (int i = 0; i < k; i++) {\n        char c = instructions[i];\n        if (c != 'L' && c != 'R' && c != 'P')\n            quitf(_wa, \"Invalid instruction '%c' at position %d\", c, i + 1);\n\n        if (c == 'L') {\n            if (pos == 1) {\n                quitf(_wa, \"Robot tried to move left from position 1 at instruction %d\", i + 1);\n            }\n            pos--;\n        } else if (c == 'R') {\n            if (pos == n) {\n                quitf(_wa, \"Robot tried to move right from position %d (n = %d) at instruction %d\", n, n, i + 1);\n            }\n            pos++;\n        } else if (c == 'P') {\n            if (prev_c == 'P') {\n                quitf(_wa, \"Two 'P's in a row at instructions %d and %d\", i, i + 1);\n            }\n            wallets[pos - 1]++; // pos - 1 because wallets is 0-indexed\n        }\n        prev_c = c;\n    }\n\n    // Check that wallets contain the correct number of coins\n    for (int i = 0; i < n; i++) {\n        if (wallets[i] != ai[i]) {\n            quitf(_wa, \"Wallet %d contains %d coins instead of required %d\", i + 1, wallets[i], ai[i]);\n        }\n    }\n\n    quitf(_ok, \"Correct solution with %d instructions\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\")\n    {\n        int positive_count = 0;\n        for(int i = 0; i < n; ++i)\n        {\n            a[i] = rnd.next(0, 300);\n            if(a[i] > 0) positive_count++;\n        }\n        if(positive_count == 0)\n        {\n            a[rnd.next(0, n-1)] = rnd.next(1, 300);\n        }\n    }\n    else if (type == \"max_ai\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 300;\n    }\n    else if (type == \"min_ai\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[rnd.next(0, n-1)] = rnd.next(1, 300); // Ensure at least one positive ai\n    }\n    else if (type == \"increasing\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = (i * 300) / max(1, n-1);\n    }\n    else if (type == \"decreasing\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = ((n - 1 - i) * 300) / max(1, n-1);\n    }\n    else if (type == \"alternating\")\n    {\n        for(int i = 0; i < n; ++i)\n        {\n            if (i % 2 == 0)\n                a[i] = 0;\n            else\n                a[i] = 300;\n        }\n    }\n    else if (type == \"ones\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    }\n    else if (type == \"sparse\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        int k = rnd.next(1, min(n, 10)); // Random number of non-zero ai's up to 10\n        set<int> indices;\n        while ((int)indices.size() < k)\n        {\n            int idx = rnd.next(0, n-1);\n            indices.insert(idx);\n        }\n        for (int idx : indices)\n        {\n            a[idx] = rnd.next(1, 300);\n        }\n    }\n    else\n    {\n        // Default to random\n        int positive_count = 0;\n        for(int i = 0; i < n; ++i)\n        {\n            a[i] = rnd.next(0, 300);\n            if(a[i] > 0) positive_count++;\n        }\n        if(positive_count == 0)\n        {\n            a[rnd.next(0, n-1)] = rnd.next(1, 300);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai's\n    for(int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\")\n    {\n        int positive_count = 0;\n        for(int i = 0; i < n; ++i)\n        {\n            a[i] = rnd.next(0, 300);\n            if(a[i] > 0) positive_count++;\n        }\n        if(positive_count == 0)\n        {\n            a[rnd.next(0, n-1)] = rnd.next(1, 300);\n        }\n    }\n    else if (type == \"max_ai\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 300;\n    }\n    else if (type == \"min_ai\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[rnd.next(0, n-1)] = rnd.next(1, 300); // Ensure at least one positive ai\n    }\n    else if (type == \"increasing\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = (i * 300) / max(1, n-1);\n    }\n    else if (type == \"decreasing\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = ((n - 1 - i) * 300) / max(1, n-1);\n    }\n    else if (type == \"alternating\")\n    {\n        for(int i = 0; i < n; ++i)\n        {\n            if (i % 2 == 0)\n                a[i] = 0;\n            else\n                a[i] = 300;\n        }\n    }\n    else if (type == \"ones\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    }\n    else if (type == \"sparse\")\n    {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        int k = rnd.next(1, min(n, 10)); // Random number of non-zero ai's up to 10\n        set<int> indices;\n        while ((int)indices.size() < k)\n        {\n            int idx = rnd.next(0, n-1);\n            indices.insert(idx);\n        }\n        for (int idx : indices)\n        {\n            a[idx] = rnd.next(1, 300);\n        }\n    }\n    else\n    {\n        // Default to random\n        int positive_count = 0;\n        for(int i = 0; i < n; ++i)\n        {\n            a[i] = rnd.next(0, 300);\n            if(a[i] > 0) positive_count++;\n        }\n        if(positive_count == 0)\n        {\n            a[rnd.next(0, n-1)] = rnd.next(1, 300);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai's\n    for(int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type max_ai\n./gen -n 2 -type min_ai\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type alternating\n./gen -n 2 -type ones\n./gen -n 2 -type sparse\n\n./gen -n 3 -type random\n./gen -n 3 -type max_ai\n./gen -n 3 -type min_ai\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type alternating\n./gen -n 3 -type ones\n./gen -n 3 -type sparse\n\n./gen -n 10 -type random\n./gen -n 10 -type max_ai\n./gen -n 10 -type min_ai\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating\n./gen -n 10 -type ones\n./gen -n 10 -type sparse\n\n./gen -n 100 -type random\n./gen -n 100 -type max_ai\n./gen -n 100 -type min_ai\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n./gen -n 100 -type ones\n./gen -n 100 -type sparse\n\n./gen -n 299 -type random\n./gen -n 299 -type max_ai\n./gen -n 299 -type min_ai\n./gen -n 299 -type increasing\n./gen -n 299 -type decreasing\n./gen -n 299 -type alternating\n./gen -n 299 -type ones\n./gen -n 299 -type sparse\n\n./gen -n 300 -type random\n./gen -n 300 -type max_ai\n./gen -n 300 -type min_ai\n./gen -n 300 -type increasing\n./gen -n 300 -type decreasing\n./gen -n 300 -type alternating\n./gen -n 300 -type ones\n./gen -n 300 -type sparse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:48.574674",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "379/C",
      "title": "C. New Year Ratings Change",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of users on the site. The next line contains integer sequence a1, a2, ..., an (1 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint a sequence of integers b1, b2, ..., bn. Number bi means that user i gets bi of rating as a present. The printed sequence must meet the problem conditions. If there are multiple optimal solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy35 1 1OutputCopy5 1 2InputCopy11000000000OutputCopy1000000000",
      "description": "C. New Year Ratings Change\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of users on the site. The next line contains integer sequence a1, a2, ..., an (1 ≤ ai ≤ 109).\n\nOutputPrint a sequence of integers b1, b2, ..., bn. Number bi means that user i gets bi of rating as a present. The printed sequence must meet the problem conditions. If there are multiple optimal solutions, print any of them.\n\nInputCopy35 1 1OutputCopy5 1 2InputCopy11000000000OutputCopy1000000000\n\nInputCopy35 1 1\n\nOutputCopy5 1 2\n\nInputCopy11000000000\n\nOutputCopy1000000000",
      "solutions": [
        {
          "title": "Good Bye 2013 - Codeforces",
          "content": "Good day)Welcome to the last Codeforces round in this year Good Bye 2013. This round will be unusual because it will be common for participants of both divisions.The problems were prepared by authors Gerald Agapov (Gerald) and Svechnikov Artur (ikar). Pavel Kholkin (HolkinPV) and Vitaly Aksenov (Aksenov239) also help us to prepare the problems. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is similar to standard — 500-1000-1500-2000-2500-3000-3500UPD2: Thanks to all participants, we hope everyone enjoyed prepared tasks. Problem analysis. UPD3: Congratulations to the winners of the last round in this year. Rating will be changed in a few hours.1. BaconLi2. Egor3. liympanda We wish everyone good luck, high rating and excellent mood)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10161",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 868
        },
        {
          "title": "Tutorial Good Bye 2013 - Codeforces",
          "content": "Excuse me for my english, but I tried very hard to.=)A: 379A - New Year CandlesLet cura amount of new candles, curb — amount of burnt out. Initially cura = a, curb = 0, after burning all cura new candles, amount of hours incremented by cura and curb +  = cura, lets make all burnt out candles into new cura = curb / b , repeat this algorithm until we can make at least one new candle. #### B: 379B - New Year Present If wallet contains more then one coin, then between orders to \"put a coin\" we can orders to move to adjacent wallet then back. Since for each orders to \"put a coin\" we spend at most 2 other orders, number of total orders for maximum test equals 300 * 300 * 3 = 270000 it less then 106.C: 379C - New Year Ratings ChangeWe can to sort ratings in nondecrease order, then iterate by them we can keep minimal rating not used before. If ai > cur, i's user recieve ai of rating and cur = ai + 1, else ai ≤ cur then i's user recieve cur of rating and cur increased by one. D: 379D - New Year LetterWe can't fairly calculate sk because of length of this string which can be very large. But note that whole string not need, we just need number of AC substrings, first and last letter. That help us to easy calculate number AC substrings for any sk for some s1, s2. Let's iterate through s1, s2 using alphabet of A, C, and any other letter. We need just first and last letter and number of AC. Using some s1, s2 we can calculate sk.E: 379E - New Year Tree DecorationsLet's keep union of first i pieces, S(i) denote the area of union for the first i pieces. Then to know visible part of i's piece we need to calculate S(i) - S(i - 1), (Unable to parse markup [type=CF_TEX] and with end at x = 1. Union looks like a downward convex polyline, lets represent it sequence of points, adjacent are connected. So calculate i's union, if new union will be contains new segment, this segment must intersects two segments of union, this intersection we can calculate for the amount of points in union. All points lower than new segment must be erased from union. Because each segment can add at most one point in union calculating of one range is O(n2).F: 379F - New Year TreeComing soon.G: 379G - New Year CactusThis problem can be solved for tree by using of dynamic programming d[v][c][a], where v — vertex, c — type of vertex(whose toys are hanged or nothing are hanged there), a — number of toys hanged by Jack for this subtree, d[v][c][a] denote of maximum number of toys which can be hanged by Jill. Value d[v][c][a] can be calculated iterated through sons of v vertext and type of these vertices. Let's compress our cactus into tree by compressing each cycle into vertex. Vertex of tree will be looks like sequence of vertex from cactus which have edges not from this cycle and intermediates that belongs only to this cycle. Now we can calculate all d[v][c][a] for this tree but we must be carefully processing a vertices.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 379\\s*C"
          },
          "content_length": 2925
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2013 - Codeforces - Code 1",
          "code": "while (vet[u] <= l) ++vet[u];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 2",
          "code": "while(v[i].a<=v[i-1].a) v[i].a++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 3",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 4",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 5",
          "code": "Codeforces Round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 6",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 7",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 8",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 9",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 10",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 11",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 12",
          "code": "a[i] < a[x]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 13",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 14",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 15",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read input data from the input file\n    int n = inf.readInt(1, 300000, \"n\");\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readLong(1LL, 1000000000LL, \"a[i]\");\n    }\n    \n    // Read participant's output\n    vector<long long> b(n);\n    for (int i = 0; i < n; i++) {\n        b[i] = ouf.readLong(1LL, 2000000000000LL, // large upper bound to avoid overflow issues\n                            (\"b[\" + to_string(i + 1) + \"]\").c_str());\n    }\n    \n    // Check that all b[i] are distinct and satisfy b[i] >= a[i]\n    unordered_set<long long> used;\n    used.reserve(n);\n    long long sumB = 0;\n    for (int i = 0; i < n; i++) {\n        if (b[i] < a[i]) {\n            ouf.quitf(_wa, \"b[%d] = %lld is smaller than a[%d] = %lld\",\n                      i + 1, b[i], i + 1, a[i]);\n        }\n        if (used.find(b[i]) != used.end()) {\n            ouf.quitf(_wa, \"b[%d] = %lld is not distinct\", i + 1, b[i]);\n        }\n        used.insert(b[i]);\n        sumB += b[i];\n    }\n    \n    // Compute the minimal possible sum for a valid distribution\n    // Sort (a[i], i) by a[i] ascending\n    vector<pair<long long,int>> sortedA(n);\n    for (int i = 0; i < n; i++) {\n        sortedA[i] = {a[i], i};\n    }\n    sort(sortedA.begin(), sortedA.end());\n    \n    vector<long long> c(n, 0);\n    c[sortedA[0].second] = sortedA[0].first;\n    for (int i = 1; i < n; i++) {\n        long long needed = c[sortedA[i - 1].second] + 1; \n        long long desired = sortedA[i].first;\n        c[sortedA[i].second] = max(needed, desired);\n    }\n    \n    long long minSum = 0;\n    for (int i = 0; i < n; i++) {\n        minSum += c[i];\n    }\n    \n    // If participant's sum is not equal to the minimal sum, it's wrong\n    if (sumB != minSum) {\n        ouf.quitf(_wa, \"sum of b is not minimal: found %lld, expected %lld\", sumB, minSum);\n    }\n    \n    // If all checks pass, the solution is correct\n    ouf.quitf(_ok, \"correct solution with sum = %lld\", sumB);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000);\n    int minAi = opt<int>(\"minAi\", 1);\n\n    if (minAi > maxAi) {\n        swap(minAi, maxAi);\n    }\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random a_i between minAi and maxAi\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minAi, maxAi);\n        }\n    } else if (type == \"allSame\") {\n        // All a_i the same value\n        int val = opt<int>(\"value\", minAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        if (n == 1) {\n            a[0] = minAi;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                a[i] = minAi + ((long long)i * (maxAi - minAi)) / (n - 1);\n            }\n        }\n    } else if (type == \"decreasing\") {\n        if (n == 1) {\n            a[0] = maxAi;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                a[i] = maxAi - ((long long)i * (maxAi - minAi)) / (n - 1);\n            }\n        }\n    } else if (type == \"smallLarge\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = minAi;\n            else\n                a[i] = maxAi;\n        }\n    } else if (type == \"permutedSequence\") {\n        int range = maxAi - minAi + 1;\n        if (n > range) {\n            fprintf(stderr, \"Cannot generate permuted sequence: n is larger than the range\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = minAi + i;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"spikes\") {\n        // a_i mostly minAi, with some random spikes to maxAi\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, n - 1) < n / 10) // 10% chance\n                a[i] = rnd.next(minAi, maxAi);\n            else\n                a[i] = minAi;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000);\n    int minAi = opt<int>(\"minAi\", 1);\n\n    if (minAi > maxAi) {\n        swap(minAi, maxAi);\n    }\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random a_i between minAi and maxAi\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minAi, maxAi);\n        }\n    } else if (type == \"allSame\") {\n        // All a_i the same value\n        int val = opt<int>(\"value\", minAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        if (n == 1) {\n            a[0] = minAi;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                a[i] = minAi + ((long long)i * (maxAi - minAi)) / (n - 1);\n            }\n        }\n    } else if (type == \"decreasing\") {\n        if (n == 1) {\n            a[0] = maxAi;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                a[i] = maxAi - ((long long)i * (maxAi - minAi)) / (n - 1);\n            }\n        }\n    } else if (type == \"smallLarge\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = minAi;\n            else\n                a[i] = maxAi;\n        }\n    } else if (type == \"permutedSequence\") {\n        int range = maxAi - minAi + 1;\n        if (n > range) {\n            fprintf(stderr, \"Cannot generate permuted sequence: n is larger than the range\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = minAi + i;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"spikes\") {\n        // a_i mostly minAi, with some random spikes to maxAi\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, n - 1) < n / 10) // 10% chance\n                a[i] = rnd.next(minAi, maxAi);\n            else\n                a[i] = minAi;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -type random\n\n./gen -n 1 -type allSame -value 1\n\n./gen -n 1 -type allSame -value 1000000000\n\n# Moderate n\n./gen -n 10 -type random\n\n./gen -n 10 -type allSame -value 10\n\n./gen -n 10 -type increasing -minAi 1 -maxAi 10\n\n./gen -n 10 -type decreasing -minAi 1 -maxAi 10\n\n./gen -n 10 -type smallLarge -minAi 1 -maxAi 10\n\n./gen -n 10 -type permutedSequence -minAi 1 -maxAi 10\n\n./gen -n 10 -type spikes -minAi 1 -maxAi 10\n\n# Larger n\n./gen -n 1000 -type random\n\n./gen -n 1000 -type increasing -minAi 1 -maxAi 10000\n\n./gen -n 1000 -type decreasing -minAi 1 -maxAi 10000\n\n./gen -n 1000 -type smallLarge -minAi 1 -maxAi 10000\n\n./gen -n 1000 -type spikes -minAi 1 -maxAi 10000\n\n# Near maximum n\n./gen -n 300000 -type random\n\n./gen -n 300000 -type allSame -value 1\n\n./gen -n 300000 -type allSame -value 1000000000\n\n./gen -n 300000 -type increasing -minAi 1 -maxAi 1000000000\n\n./gen -n 300000 -type decreasing -minAi 1 -maxAi 1000000000\n\n./gen -n 300000 -type smallLarge -minAi 1 -maxAi 1000000000\n\n./gen -n 300000 -type permutedSequence -minAi 1 -maxAi 300000\n\n./gen -n 300000 -type permutedSequence -minAi 999700001 -maxAi 1000000000\n\n./gen -n 300000 -type spikes -minAi 1 -maxAi 1000000000\n\n# Edge cases\n./gen -n 300000 -type allSame -value 1\n\n./gen -n 300000 -type allSame -value 1000000000\n\n# Random with specific minAi and maxAi\n./gen -n 100000 -type random -minAi 1 -maxAi 1000\n\n./gen -n 100000 -type random -minAi 1000000000 -maxAi 1000000000\n\n# Special cases\n./gen -n 1 -type spikes -minAi 1 -maxAi 1\n\n./gen -n 2 -type smallLarge -minAi 1 -maxAi 1000000000\n\n# Maximum n with alternating small and large values\n./gen -n 300000 -type smallLarge -minAi 1 -maxAi 1000000000\n\n# Maximum n with spikes (mostly minAi, some maxAi)\n./gen -n 300000 -type spikes -minAi 1 -maxAi 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:51.064359",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "379/D",
      "title": "D. New Year Letter",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers k, x, n, m (3 ≤ k ≤ 50; 0 ≤ x ≤ 109; 1 ≤ n, m ≤ 100).",
      "output_spec": "OutputIn the first line print string s1, consisting of n uppercase English letters. In the second line print string s2, consisting of m uppercase English letters. If there are multiple valid strings, print any of them.If the required pair of strings doesn't exist, print \"Happy new year!\" without the quotes.",
      "sample_tests": "ExamplesInputCopy3 2 2 2OutputCopyACACInputCopy3 3 2 2OutputCopyHappy new year!InputCopy3 0 2 2OutputCopyAAAAInputCopy4 3 2 1OutputCopyHappy new year!InputCopy4 2 2 1OutputCopyHappy new year!",
      "description": "D. New Year Letter\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four integers k, x, n, m (3 ≤ k ≤ 50; 0 ≤ x ≤ 109; 1 ≤ n, m ≤ 100).\n\nOutputIn the first line print string s1, consisting of n uppercase English letters. In the second line print string s2, consisting of m uppercase English letters. If there are multiple valid strings, print any of them.If the required pair of strings doesn't exist, print \"Happy new year!\" without the quotes.\n\nInputCopy3 2 2 2OutputCopyACACInputCopy3 3 2 2OutputCopyHappy new year!InputCopy3 0 2 2OutputCopyAAAAInputCopy4 3 2 1OutputCopyHappy new year!InputCopy4 2 2 1OutputCopyHappy new year!\n\nInputCopy3 2 2 2\n\nOutputCopyACAC\n\nInputCopy3 3 2 2\n\nOutputCopyHappy new year!\n\nInputCopy3 0 2 2\n\nOutputCopyAAAA\n\nInputCopy4 3 2 1\n\nOutputCopyHappy new year!\n\nInputCopy4 2 2 1\n\nOutputCopyHappy new year!",
      "solutions": [
        {
          "title": "Good Bye 2013 - Codeforces",
          "content": "Good day)Welcome to the last Codeforces round in this year Good Bye 2013. This round will be unusual because it will be common for participants of both divisions.The problems were prepared by authors Gerald Agapov (Gerald) and Svechnikov Artur (ikar). Pavel Kholkin (HolkinPV) and Vitaly Aksenov (Aksenov239) also help us to prepare the problems. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is similar to standard — 500-1000-1500-2000-2500-3000-3500UPD2: Thanks to all participants, we hope everyone enjoyed prepared tasks. Problem analysis. UPD3: Congratulations to the winners of the last round in this year. Rating will be changed in a few hours.1. BaconLi2. Egor3. liympanda We wish everyone good luck, high rating and excellent mood)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10161",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 868
        },
        {
          "title": "Tutorial Good Bye 2013 - Codeforces",
          "content": "Excuse me for my english, but I tried very hard to.=)A: 379A - New Year CandlesLet cura amount of new candles, curb — amount of burnt out. Initially cura = a, curb = 0, after burning all cura new candles, amount of hours incremented by cura and curb +  = cura, lets make all burnt out candles into new cura = curb / b , repeat this algorithm until we can make at least one new candle. #### B: 379B - New Year Present If wallet contains more then one coin, then between orders to \"put a coin\" we can orders to move to adjacent wallet then back. Since for each orders to \"put a coin\" we spend at most 2 other orders, number of total orders for maximum test equals 300 * 300 * 3 = 270000 it less then 106.C: 379C - New Year Ratings ChangeWe can to sort ratings in nondecrease order, then iterate by them we can keep minimal rating not used before. If ai > cur, i's user recieve ai of rating and cur = ai + 1, else ai ≤ cur then i's user recieve cur of rating and cur increased by one. D: 379D - New Year LetterWe can't fairly calculate sk because of length of this string which can be very large. But note that whole string not need, we just need number of AC substrings, first and last letter. That help us to easy calculate number AC substrings for any sk for some s1, s2. Let's iterate through s1, s2 using alphabet of A, C, and any other letter. We need just first and last letter and number of AC. Using some s1, s2 we can calculate sk.E: 379E - New Year Tree DecorationsLet's keep union of first i pieces, S(i) denote the area of union for the first i pieces. Then to know visible part of i's piece we need to calculate S(i) - S(i - 1), (Unable to parse markup [type=CF_TEX] and with end at x = 1. Union looks like a downward convex polyline, lets represent it sequence of points, adjacent are connected. So calculate i's union, if new union will be contains new segment, this segment must intersects two segments of union, this intersection we can calculate for the amount of points in union. All points lower than new segment must be erased from union. Because each segment can add at most one point in union calculating of one range is O(n2).F: 379F - New Year TreeComing soon.G: 379G - New Year CactusThis problem can be solved for tree by using of dynamic programming d[v][c][a], where v — vertex, c — type of vertex(whose toys are hanged or nothing are hanged there), a — number of toys hanged by Jack for this subtree, d[v][c][a] denote of maximum number of toys which can be hanged by Jill. Value d[v][c][a] can be calculated iterated through sons of v vertext and type of these vertices. Let's compress our cactus into tree by compressing each cycle into vertex. Vertex of tree will be looks like sequence of vertex from cactus which have edges not from this cycle and intermediates that belongs only to this cycle. Now we can calculate all d[v][c][a] for this tree but we must be carefully processing a vertices.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 379\\s*D"
          },
          "content_length": 2925
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2013 - Codeforces - Code 1",
          "code": "while (vet[u] <= l) ++vet[u];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 2",
          "code": "while(v[i].a<=v[i-1].a) v[i].a++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 3",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 4",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 5",
          "code": "Codeforces Round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 6",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 7",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 8",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 9",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 10",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 11",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 12",
          "code": "a[i] < a[x]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 13",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 14",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 15",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int k = inf.readInt(3, 50, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int k = inf.readInt(3, 50, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int k = inf.readInt(3, 50, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    long long numAC;\n    char startsWith;\n    char endsWith;\n};\n\nstruct Answer {\n    bool happy_new_year;\n    string s1, s2;\n};\n\nAnswer readAnswer(InStream &stream, int n, int m) {\n    Answer ans;\n    string line = stream.readLine();\n    if (line == \"Happy new year!\") {\n        ans.happy_new_year = true;\n    } else {\n        ans.happy_new_year = false;\n        ans.s1 = line;\n        ans.s2 = stream.readLine();\n        if (int(ans.s1.size()) != n)\n            stream.quitf(_wa, \"The first string length is not %d\", n);\n        if (int(ans.s2.size()) != m)\n            stream.quitf(_wa, \"The second string length is not %d\", m);\n        for (char c : ans.s1) {\n            if (!isupper(c))\n                stream.quitf(_wa, \"The first string contains non-uppercase letters\");\n        }\n        for (char c : ans.s2) {\n            if (!isupper(c))\n                stream.quitf(_wa, \"The second string contains non-uppercase letters\");\n        }\n    }\n    return ans;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int k = inf.readInt();\n    long long x = inf.readLong();\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    Answer juryAns = readAnswer(ans, n, m);\n    Answer contAns = readAnswer(ouf, n, m);\n\n    if (juryAns.happy_new_year != contAns.happy_new_year) {\n        if (juryAns.happy_new_year)\n            quitf(_wa, \"Contestant found a solution while jury says it's impossible\");\n        else\n            quitf(_wa, \"Contestant says it's impossible while jury found a solution\");\n    }\n    if (contAns.happy_new_year) {\n        quitf(_ok, \"Happy new year!\");\n    }\n\n    // Compute numAC for s1 and s2\n    auto computeNode = [](const string& s) -> Node {\n        Node node;\n        node.startsWith = s[0];\n        node.endsWith = s.back();\n        node.numAC = 0;\n        for (size_t i = 0; i + 1 < s.size(); ++i) {\n            if (s[i] == 'A' && s[i + 1] == 'C')\n                node.numAC++;\n        }\n        return node;\n    };\n\n    Node nodes[51];\n    nodes[1] = computeNode(contAns.s1);\n    nodes[2] = computeNode(contAns.s2);\n\n    for (int i = 3; i <= k; ++i) {\n        nodes[i].numAC = nodes[i - 2].numAC + nodes[i - 1].numAC;\n        if (nodes[i - 2].endsWith == 'A' && nodes[i - 1].startsWith == 'C')\n            nodes[i].numAC++;\n        nodes[i].startsWith = nodes[i - 2].startsWith;\n        nodes[i].endsWith = nodes[i - 1].endsWith;\n    }\n\n    if (nodes[k].numAC != x) {\n        quitf(_wa, \"In contestant's strings, s_k has %lld occurrences of 'AC', expected %lld\", nodes[k].numAC, x);\n    }\n\n    quitf(_ok, \"Valid strings with s_k having %lld occurrences of 'AC'\", x);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters. If not provided, use these defaults:\n    int k = opt<int>(\"k\", 3);\n    long long x = opt<long long>(\"x\", 0);\n    int n = opt<int>(\"n\", 1);\n    int m = opt<int>(\"m\", 1);\n    string t = opt<string>(\"type\", \"direct\");\n\n    /*\n      We will produce exactly one test case each time this generator is run.\n      The problem input is just one line with 4 integers: k, x, n, m.\n\n      We provide \"type\" to allow special or random generation:\n        - direct : use (k, x, n, m) exactly as the command line arguments or defaults\n        - corner1, corner2, ... : corners we override\n        - small : random but with smaller ranges\n        - large : random but with near-bound ranges\n        - random : random in the full allowed range\n    */\n\n    if (t == \"corner1\") {\n        // A corner that is known from the examples\n        k = 3; x = 2; n = 2; m = 2;\n    } else if (t == \"corner2\") {\n        k = 3; x = 3; n = 2; m = 2;\n    } else if (t == \"corner3\") {\n        k = 3; x = 0; n = 2; m = 2;\n    } else if (t == \"corner4\") {\n        k = 4; x = 3; n = 2; m = 1;\n    } else if (t == \"corner5\") {\n        k = 4; x = 2; n = 2; m = 1;\n    } else if (t == \"small\") {\n        // Random small ranges\n        k = rnd.next(3, 10);\n        x = rnd.next(0LL, 20LL);\n        n = rnd.next(1, 5);\n        m = rnd.next(1, 5);\n    } else if (t == \"large\") {\n        // Random large ranges near constraints\n        k = rnd.next(40, 50);\n        x = rnd.next(900000000LL, 1000000000LL);\n        n = rnd.next(90, 100);\n        m = rnd.next(90, 100);\n    } else if (t == \"random\") {\n        // Totally random within overall constraints\n        k = rnd.next(3, 50);\n        x = rnd.next(0LL, 1000000000LL);\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n    }\n    // if t == \"direct\", do nothing special (use the arguments as-is)\n\n    // Output one test case: \"k x n m\"\n    printf(\"%d %lld %d %d\\n\", k, x, n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters. If not provided, use these defaults:\n    int k = opt<int>(\"k\", 3);\n    long long x = opt<long long>(\"x\", 0);\n    int n = opt<int>(\"n\", 1);\n    int m = opt<int>(\"m\", 1);\n    string t = opt<string>(\"type\", \"direct\");\n\n    /*\n      We will produce exactly one test case each time this generator is run.\n      The problem input is just one line with 4 integers: k, x, n, m.\n\n      We provide \"type\" to allow special or random generation:\n        - direct : use (k, x, n, m) exactly as the command line arguments or defaults\n        - corner1, corner2, ... : corners we override\n        - small : random but with smaller ranges\n        - large : random but with near-bound ranges\n        - random : random in the full allowed range\n    */\n\n    if (t == \"corner1\") {\n        // A corner that is known from the examples\n        k = 3; x = 2; n = 2; m = 2;\n    } else if (t == \"corner2\") {\n        k = 3; x = 3; n = 2; m = 2;\n    } else if (t == \"corner3\") {\n        k = 3; x = 0; n = 2; m = 2;\n    } else if (t == \"corner4\") {\n        k = 4; x = 3; n = 2; m = 1;\n    } else if (t == \"corner5\") {\n        k = 4; x = 2; n = 2; m = 1;\n    } else if (t == \"small\") {\n        // Random small ranges\n        k = rnd.next(3, 10);\n        x = rnd.next(0LL, 20LL);\n        n = rnd.next(1, 5);\n        m = rnd.next(1, 5);\n    } else if (t == \"large\") {\n        // Random large ranges near constraints\n        k = rnd.next(40, 50);\n        x = rnd.next(900000000LL, 1000000000LL);\n        n = rnd.next(90, 100);\n        m = rnd.next(90, 100);\n    } else if (t == \"random\") {\n        // Totally random within overall constraints\n        k = rnd.next(3, 50);\n        x = rnd.next(0LL, 1000000000LL);\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n    }\n    // if t == \"direct\", do nothing special (use the arguments as-is)\n\n    // Output one test case: \"k x n m\"\n    printf(\"%d %lld %d %d\\n\", k, x, n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to produce around 20 distinct test cases.\n# Each command runs the generator exactly once, printing one line of output (k, x, n, m).\n\n# Direct use of parameters (matching some of the problem examples / corners):\n./gen -k 3 -x 2 -n 2 -m 2\n./gen -k 3 -x 3 -n 2 -m 2\n./gen -k 3 -x 0 -n 2 -m 2\n./gen -k 4 -x 3 -n 2 -m 1\n./gen -k 4 -x 2 -n 2 -m 1\n\n# Corner cases using our predefined corner types:\n./gen -type corner1\n./gen -type corner2\n./gen -type corner3\n./gen -type corner4\n./gen -type corner5\n\n# Random small data:\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Random large data:\n./gen -type large\n./gen -type large\n./gen -type large\n\n# Fully random within full constraints:\n./gen -type random\n./gen -type random\n./gen -type random\n\n# More specific direct cases pushing boundaries:\n./gen -k 50 -x 1000000000 -n 100 -m 100\n./gen -k 49 -x 999999999 -n 99 -m 100\n./gen -k 50 -x 0 -n 100 -m 100\n./gen -k 3 -x 1 -n 1 -m 3\n./gen -k 3 -x 5 -n 1 -m 4\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:53.137099",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}