{
  "metadata": {
    "batch_number": 38,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.347865",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "319/D",
      "title": "D. Have You Ever Heard About the Word?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line of input you're given a string of small Latin characters with length between 1 to 50000, inclusive.",
      "output_spec": "OutputPrint the final string after applying changes.",
      "sample_tests": "ExamplesInputCopyabccabcOutputCopyabcInputCopyaaaabaaabOutputCopyabInputCopybirdbirdbirdisthewordOutputCopybirdistheword",
      "description": "D. Have You Ever Heard About the Word?\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn the first line of input you're given a string of small Latin characters with length between 1 to 50000, inclusive.\n\nOutputPrint the final string after applying changes.\n\nInputCopyabccabcOutputCopyabcInputCopyaaaabaaabOutputCopyabInputCopybirdbirdbirdisthewordOutputCopybirdistheword\n\nInputCopyabccabc\n\nOutputCopyabc\n\nInputCopyaaaabaaab\n\nOutputCopyab\n\nInputCopybirdbirdbirdistheword\n\nOutputCopybirdistheword\n\nNoteAt the first sample the string transforms as follows: abccabc  →  abcabc  →  abc.At the second sample the string transforms as follows: aaaabaaab  →  aaabaaab  →  aabaaab  →  abaaab  →  abaab  →  abab  →  ab.",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Hello, Codeforces! :-{DAs two important events IOI and ACM ICPC are coming soon, me and my friends as the Iranian IOI team decided to prepare a gift for all the Codeforces users who'll soon participate in one of these events, and also everybody else. :)This round authored by me (havaliza), dani1373 and keivan with help from fab. I want to thank all the Codeforces team for their kind and great effort to maintain this website.Hope you enjoy solving the problems as much as we're enjoying preparing them! ^.^Update 1. The score distribution for Div. 1 is 500-1000-1500-2500-2500 and for Div. 2 its regular.Update 2. Special thanks to Aksenov239 who helped us so much to prepare this round.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 746
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 319\\s*D"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,50000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,50000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,50000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 50000) {\n        cerr << \"Error: n must be between 1 and 50000 inclusive.\" << endl;\n        return 1;\n    }\n\n    int k = opt<int>(\"k\", -1);\n    if (k != -1 && (k < 1 || k > n)) {\n        cerr << \"Error: k must be between 1 and n inclusive.\" << endl;\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"single_char\") {\n        // Generate a string of length n consisting of the same character\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"repeat_small_pattern\") {\n        if (k == -1) k = 1 + rnd.next(min(10, n));\n        // Generate pattern of length k and repeat it\n        string pattern = \"\";\n        for (int i = 0; i < k; ++i) {\n            pattern += (char)('a' + rnd.next(26));\n        }\n        int repeats = n / k;\n        s = \"\";\n        for (int i = 0; i < repeats; ++i) {\n            s += pattern;\n        }\n        // Append random characters if any space remains\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"overlapping\") {\n        if (k == -1) k = 1 + rnd.next(min(10, n));\n        // Generate a string with overlapping patterns\n        string pattern = \"\";\n        for (int i = 0; i < k; ++i) {\n            pattern += (char)('a' + rnd.next(26));\n        }\n        s = \"\";\n        int repeats = n - k + 1;\n        for (int i = 0; i < repeats; ++i) {\n            s += pattern[i % k];\n        }\n        // Append random characters if any space remains\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"no_repeats\") {\n        // Generate a string with no repeating blocks (XX)\n        s = \"\";\n        char last_char = '\\0';\n        for (int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (c == last_char);\n            s += c;\n            last_char = c;\n        }\n    } else if (type == \"many_pairs\") {\n        // Generate a string where every two adjacent characters are the same\n        s = \"\";\n        char c = 'a';\n        for (int i = 0; i < n / 2; ++i) {\n            s += c;\n            s += c;\n            c = (c - 'a' + 1) % 26 + 'a'; // Next character\n        }\n        if (n % 2 == 1) {\n            s += (char)('a' + rnd.next(26));\n        }\n        s = s.substr(0, n);\n    } else if (type == \"multiple_choice\") {\n        // Create a string with multiple shortest repeating blocks\n        s = \"\";\n        string X = \"\";\n        int k_local = 2; // Fixed length for repeating blocks\n        for (int i = 0; i < k_local; ++i) {\n            X += (char)('a' + rnd.next(26));\n        }\n        s += X + X; // First repeating block at position 0\n        string Y = \"\";\n        for (int i = 0; i < k_local; ++i) {\n            Y += (char)('a' + rnd.next(26));\n        }\n        s += Y + Y; // Second repeating block starting at position 2\n        // Extend to length n\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n        s = s.substr(0, n);\n    } else {\n        // Default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 50000) {\n        cerr << \"Error: n must be between 1 and 50000 inclusive.\" << endl;\n        return 1;\n    }\n\n    int k = opt<int>(\"k\", -1);\n    if (k != -1 && (k < 1 || k > n)) {\n        cerr << \"Error: k must be between 1 and n inclusive.\" << endl;\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"single_char\") {\n        // Generate a string of length n consisting of the same character\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"repeat_small_pattern\") {\n        if (k == -1) k = 1 + rnd.next(min(10, n));\n        // Generate pattern of length k and repeat it\n        string pattern = \"\";\n        for (int i = 0; i < k; ++i) {\n            pattern += (char)('a' + rnd.next(26));\n        }\n        int repeats = n / k;\n        s = \"\";\n        for (int i = 0; i < repeats; ++i) {\n            s += pattern;\n        }\n        // Append random characters if any space remains\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"overlapping\") {\n        if (k == -1) k = 1 + rnd.next(min(10, n));\n        // Generate a string with overlapping patterns\n        string pattern = \"\";\n        for (int i = 0; i < k; ++i) {\n            pattern += (char)('a' + rnd.next(26));\n        }\n        s = \"\";\n        int repeats = n - k + 1;\n        for (int i = 0; i < repeats; ++i) {\n            s += pattern[i % k];\n        }\n        // Append random characters if any space remains\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"no_repeats\") {\n        // Generate a string with no repeating blocks (XX)\n        s = \"\";\n        char last_char = '\\0';\n        for (int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (c == last_char);\n            s += c;\n            last_char = c;\n        }\n    } else if (type == \"many_pairs\") {\n        // Generate a string where every two adjacent characters are the same\n        s = \"\";\n        char c = 'a';\n        for (int i = 0; i < n / 2; ++i) {\n            s += c;\n            s += c;\n            c = (c - 'a' + 1) % 26 + 'a'; // Next character\n        }\n        if (n % 2 == 1) {\n            s += (char)('a' + rnd.next(26));\n        }\n        s = s.substr(0, n);\n    } else if (type == \"multiple_choice\") {\n        // Create a string with multiple shortest repeating blocks\n        s = \"\";\n        string X = \"\";\n        int k_local = 2; // Fixed length for repeating blocks\n        for (int i = 0; i < k_local; ++i) {\n            X += (char)('a' + rnd.next(26));\n        }\n        s += X + X; // First repeating block at position 0\n        string Y = \"\";\n        for (int i = 0; i < k_local; ++i) {\n            Y += (char)('a' + rnd.next(26));\n        }\n        s += Y + Y; // Second repeating block starting at position 2\n        // Extend to length n\n        while ((int)s.length() < n) {\n            s += (char)('a' + rnd.next(26));\n        }\n        s = s.substr(0, n);\n    } else {\n        // Default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random strings of various sizes\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type random\n\n# Single character strings of various sizes\n./gen -n 1 -type single_char\n./gen -n 10 -type single_char\n./gen -n 100 -type single_char\n./gen -n 1000 -type single_char\n./gen -n 10000 -type single_char\n./gen -n 50000 -type single_char\n\n# Strings with small patterns repeated\n./gen -n 10 -k 2 -type repeat_small_pattern\n./gen -n 100 -k 3 -type repeat_small_pattern\n./gen -n 1000 -k 5 -type repeat_small_pattern\n./gen -n 10000 -k 7 -type repeat_small_pattern\n./gen -n 50000 -k 11 -type repeat_small_pattern\n\n# Overlapping patterns\n./gen -n 10 -k 2 -type overlapping\n./gen -n 100 -k 3 -type overlapping\n./gen -n 1000 -k 4 -type overlapping\n./gen -n 10000 -k 5 -type overlapping\n./gen -n 50000 -k 6 -type overlapping\n\n# Strings with no repeating blocks\n./gen -n 10 -type no_repeats\n./gen -n 100 -type no_repeats\n./gen -n 1000 -type no_repeats\n./gen -n 10000 -type no_repeats\n./gen -n 50000 -type no_repeats\n\n# Strings designed to cause maximum steps\n./gen -n 10 -type many_pairs\n./gen -n 100 -type many_pairs\n./gen -n 1000 -type many_pairs\n./gen -n 10000 -type many_pairs\n./gen -n 50000 -type many_pairs\n\n# Strings with multiple choices for repeating blocks\n./gen -n 5 -type multiple_choice\n./gen -n 10 -type multiple_choice\n./gen -n 100 -type multiple_choice\n./gen -n 1000 -type multiple_choice\n./gen -n 10000 -type multiple_choice\n\n# Edge case: Minimum size input\n./gen -n 1 -type random\n\n# Edge case: Maximum size input\n./gen -n 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:37.145917",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "319/E",
      "title": "E. Пинг-Понг",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105), обозначающее количество запросов. Каждая из следующих строк содержит запрос в формате, описанном выше. Все числа во входных данных целые и не превосходят по модулю 109.Гарантируется, что все запросы корректные.",
      "output_spec": "Выходные данныеДля каждого запроса второго типа выведите «YES» или «NO» в отдельной строке в зависимости от ответа на вопрос.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 1 51 5 112 1 21 2 92 1 2Выходные данныеСкопироватьNOYES",
      "description": "E. Пинг-Понг\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105), обозначающее количество запросов. Каждая из следующих строк содержит запрос в формате, описанном выше. Все числа во входных данных целые и не превосходят по модулю 109.Гарантируется, что все запросы корректные.\n\nВходные данные\n\nВыходные данныеДля каждого запроса второго типа выведите «YES» или «NO» в отдельной строке в зависимости от ответа на вопрос.\n\nВыходные данные\n\nВходные данныеСкопировать51 1 51 5 112 1 21 2 92 1 2Выходные данныеСкопироватьNOYES\n\nВходные данныеСкопировать51 1 51 5 112 1 21 2 92 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNOYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Привет, Codeforces! :-{DПо случаю двух важных событий в мире спортивного программирования (IOI и ACM ICPC) я и мои друзья (команда Ирана на IOI) решили сделать подарок всем пользователям Codeforces, которые будут участвовать хотя бы в одном из этих двух соревнования, а также всем остальным. :)Этот раунд подготовил я (havaliza), dani1373 и keivan, также нам помогал fab. Я хочу поблагодарить всю команду Codeforces за их усилия в поддержании этого веб-сайта.Надеюсь вам понравится решать задачи так же, как нам понравилось их готовить! ^.^Update 1. Распределение баллов по задачам в Div. 1: 500-1000-1500-2500-2500, в Div. 2 распределение стандартное.Update 2. Большое спасибо пользователю Aksenov239, который очень много помогал нам в подготовке раунда.Update 3. Here is the editorial. To be completed soon :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 811
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 319\\s*E"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 30",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 31",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 32",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 33",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    int num_intervals_added = 0;\n    int max_length_so_far = -1; // Initialize to -1 so first interval length is accepted\n\n    for (int i = 0; i < n; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n\n        if (t == 1) {\n            int x = inf.readInt(-1000000000, 1000000000, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(-1000000000, 1000000000, \"y\");\n            inf.readEoln();\n\n            ensuref(x < y, \"In query #%d, x should be less than y, but x=%d, y=%d\", i+1, x, y);\n\n            int length = y - x;\n            ensuref(length > max_length_so_far, \n                \"In query #%d, length of interval (%d,%d) must be strictly greater than all previous intervals\", \n                i+1, x, y);\n\n            max_length_so_far = length;\n            num_intervals_added++;\n\n        } else if (t == 2) {\n            int a = inf.readInt(1, num_intervals_added, \"a\");\n            inf.readSpace();\n            int b = inf.readInt(1, num_intervals_added, \"b\");\n            inf.readEoln();\n\n            ensuref(a != b, \"In query #%d, a must not be equal to b, but both are %d\", i+1, a);\n\n        } else {\n            ensuref(false, \"Invalid query type t=%d at query #%d\", t, i+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    int num_intervals_added = 0;\n    int max_length_so_far = -1; // Initialize to -1 so first interval length is accepted\n\n    for (int i = 0; i < n; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n\n        if (t == 1) {\n            int x = inf.readInt(-1000000000, 1000000000, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(-1000000000, 1000000000, \"y\");\n            inf.readEoln();\n\n            ensuref(x < y, \"In query #%d, x should be less than y, but x=%d, y=%d\", i+1, x, y);\n\n            int length = y - x;\n            ensuref(length > max_length_so_far, \n                \"In query #%d, length of interval (%d,%d) must be strictly greater than all previous intervals\", \n                i+1, x, y);\n\n            max_length_so_far = length;\n            num_intervals_added++;\n\n        } else if (t == 2) {\n            int a = inf.readInt(1, num_intervals_added, \"a\");\n            inf.readSpace();\n            int b = inf.readInt(1, num_intervals_added, \"b\");\n            inf.readEoln();\n\n            ensuref(a != b, \"In query #%d, a must not be equal to b, but both are %d\", i+1, a);\n\n        } else {\n            ensuref(false, \"Invalid query type t=%d at query #%d\", t, i+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    int num_intervals_added = 0;\n    int max_length_so_far = -1; // Initialize to -1 so first interval length is accepted\n\n    for (int i = 0; i < n; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n\n        if (t == 1) {\n            int x = inf.readInt(-1000000000, 1000000000, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(-1000000000, 1000000000, \"y\");\n            inf.readEoln();\n\n            ensuref(x < y, \"In query #%d, x should be less than y, but x=%d, y=%d\", i+1, x, y);\n\n            int length = y - x;\n            ensuref(length > max_length_so_far, \n                \"In query #%d, length of interval (%d,%d) must be strictly greater than all previous intervals\", \n                i+1, x, y);\n\n            max_length_so_far = length;\n            num_intervals_added++;\n\n        } else if (t == 2) {\n            int a = inf.readInt(1, num_intervals_added, \"a\");\n            inf.readSpace();\n            int b = inf.readInt(1, num_intervals_added, \"b\");\n            inf.readEoln();\n\n            ensuref(a != b, \"In query #%d, a must not be equal to b, but both are %d\", i+1, a);\n\n        } else {\n            ensuref(false, \"Invalid query type t=%d at query #%d\", t, i+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to keep track of intervals added\n    vector<pair<int, int>> intervals; // stores (x, y) of added intervals\n    int max_length_so_far = 0;\n\n    printf(\"%d\\n\", n);\n    int total_intervals_added = 0;\n\n    if (type == \"random\") {\n        // Generate random intervals and queries\n        for (int i = 0; i < n; ++i) {\n            // Decide whether to generate '1' or '2' query\n            int query_type;\n            if (total_intervals_added < 2) {\n                // Need at least two intervals to make a '2' query\n                query_type = 1;\n            } else {\n                // Randomly choose between '1' and '2'\n                query_type = rnd.next(1, 2);\n            }\n\n            if (query_type == 1) {\n                // Generate '1 x y' query\n                int L = 1000; // Maximum increment of length\n                int length_increment = rnd.next(1, L);\n                int length = max_length_so_far + length_increment;\n                int x_min = -1e9;\n                int x_max = 1e9 - length;\n                int x = rnd.next(x_min, x_max);\n                int y = x + length;\n\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"nested\") {\n        // Generate nested intervals with increasing lengths\n        int x = rnd.next(-1e9, 1e9 - 1e7);\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int increment = rnd.next(1, 1000);\n                int length = max_length_so_far + increment;\n                int y = x + length; // End point increases\n                if (y > 1e9) {\n                    x = rnd.next(-1e9, 1e9 - length);\n                    y = x + length;\n                }\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"disjoint\") {\n        // Generate disjoint intervals\n        int x = -1e9;\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length_increment = rnd.next(1, 1000);\n                int length = max_length_so_far + length_increment;\n                int y = x + length;\n                if (y > 1e9) {\n                    x = -1e9;\n                    y = x + length;\n                }\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n                x = y + rnd.next(1, 1000); // Move x to start after previous y\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"chain\") {\n        // Generate intervals that form a chain\n        int x = rnd.next(-1e9, 1e9 - 1e8);\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length_increment = 1;\n                int length = max_length_so_far + length_increment;\n                int y = x + length;\n                if (y > 1e9) {\n                    x = rnd.next(-1e9, 1e9 - length);\n                    y = x + length;\n                }\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n                x = x + rnd.next(1, 10); // Small increment\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added - 1);\n                int b = a + 1; // Ensure a chain\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"max_yes\") {\n        // Generate intervals to maximize YES answers\n        int x = -1e9;\n        int y = 1e9;\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length = max_length_so_far + rnd.next(1, 100);\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"max_no\") {\n        // Generate intervals to maximize NO answers\n        // Intervals are disjoint\n        int x = -1e9;\n        int length_increment = 1e7;\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length = max_length_so_far + 1;\n                int y = x + length;\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n                x = y + length_increment; // Ensure intervals are far apart\n                if (x > 1e9) {\n                    x = -1e9;\n                }\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            // Decide whether to generate '1' or '2' query\n            int query_type;\n            if (total_intervals_added < 2) {\n                // Need at least two intervals to make a '2' query\n                query_type = 1;\n            } else {\n                // Randomly choose between '1' and '2'\n                query_type = rnd.next(1, 2);\n            }\n\n            if (query_type == 1) {\n                // Generate '1 x y' query\n                int L = 1000; // Maximum increment of length\n                int length_increment = rnd.next(1, L);\n                int length = max_length_so_far + length_increment;\n                int x_min = -1e9;\n                int x_max = 1e9 - length;\n                int x = rnd.next(x_min, x_max);\n                int y = x + length;\n\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to keep track of intervals added\n    vector<pair<int, int>> intervals; // stores (x, y) of added intervals\n    int max_length_so_far = 0;\n\n    printf(\"%d\\n\", n);\n    int total_intervals_added = 0;\n\n    if (type == \"random\") {\n        // Generate random intervals and queries\n        for (int i = 0; i < n; ++i) {\n            // Decide whether to generate '1' or '2' query\n            int query_type;\n            if (total_intervals_added < 2) {\n                // Need at least two intervals to make a '2' query\n                query_type = 1;\n            } else {\n                // Randomly choose between '1' and '2'\n                query_type = rnd.next(1, 2);\n            }\n\n            if (query_type == 1) {\n                // Generate '1 x y' query\n                int L = 1000; // Maximum increment of length\n                int length_increment = rnd.next(1, L);\n                int length = max_length_so_far + length_increment;\n                int x_min = -1e9;\n                int x_max = 1e9 - length;\n                int x = rnd.next(x_min, x_max);\n                int y = x + length;\n\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"nested\") {\n        // Generate nested intervals with increasing lengths\n        int x = rnd.next(-1e9, 1e9 - 1e7);\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int increment = rnd.next(1, 1000);\n                int length = max_length_so_far + increment;\n                int y = x + length; // End point increases\n                if (y > 1e9) {\n                    x = rnd.next(-1e9, 1e9 - length);\n                    y = x + length;\n                }\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"disjoint\") {\n        // Generate disjoint intervals\n        int x = -1e9;\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length_increment = rnd.next(1, 1000);\n                int length = max_length_so_far + length_increment;\n                int y = x + length;\n                if (y > 1e9) {\n                    x = -1e9;\n                    y = x + length;\n                }\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n                x = y + rnd.next(1, 1000); // Move x to start after previous y\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"chain\") {\n        // Generate intervals that form a chain\n        int x = rnd.next(-1e9, 1e9 - 1e8);\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length_increment = 1;\n                int length = max_length_so_far + length_increment;\n                int y = x + length;\n                if (y > 1e9) {\n                    x = rnd.next(-1e9, 1e9 - length);\n                    y = x + length;\n                }\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n                x = x + rnd.next(1, 10); // Small increment\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added - 1);\n                int b = a + 1; // Ensure a chain\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"max_yes\") {\n        // Generate intervals to maximize YES answers\n        int x = -1e9;\n        int y = 1e9;\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length = max_length_so_far + rnd.next(1, 100);\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else if (type == \"max_no\") {\n        // Generate intervals to maximize NO answers\n        // Intervals are disjoint\n        int x = -1e9;\n        int length_increment = 1e7;\n        for (int i = 0; i < n; ++i) {\n            if (total_intervals_added < 2 || rnd.next(2) == 0) {\n                // Generate '1 x y' query\n                int length = max_length_so_far + 1;\n                int y = x + length;\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n                x = y + length_increment; // Ensure intervals are far apart\n                if (x > 1e9) {\n                    x = -1e9;\n                }\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            // Decide whether to generate '1' or '2' query\n            int query_type;\n            if (total_intervals_added < 2) {\n                // Need at least two intervals to make a '2' query\n                query_type = 1;\n            } else {\n                // Randomly choose between '1' and '2'\n                query_type = rnd.next(1, 2);\n            }\n\n            if (query_type == 1) {\n                // Generate '1 x y' query\n                int L = 1000; // Maximum increment of length\n                int length_increment = rnd.next(1, L);\n                int length = max_length_so_far + length_increment;\n                int x_min = -1e9;\n                int x_max = 1e9 - length;\n                int x = rnd.next(x_min, x_max);\n                int y = x + length;\n\n                printf(\"1 %d %d\\n\", x, y);\n                intervals.emplace_back(x, y);\n                max_length_so_far = length;\n                ++total_intervals_added;\n            } else {\n                // Generate '2 a b' query\n                int a = rnd.next(1, total_intervals_added);\n                int b = rnd.next(1, total_intervals_added);\n                while (b == a) {\n                    b = rnd.next(1, total_intervals_added);\n                }\n                printf(\"2 %d %d\\n\", a, b);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type nested\n./gen -n 10 -type disjoint\n./gen -n 10 -type chain\n./gen -n 10 -type max_yes\n./gen -n 10 -type max_no\n\n./gen -n 100 -type random\n./gen -n 100 -type nested\n./gen -n 100 -type disjoint\n./gen -n 100 -type chain\n./gen -n 100 -type max_yes\n./gen -n 100 -type max_no\n\n./gen -n 1000 -type random\n./gen -n 1000 -type nested\n./gen -n 1000 -type disjoint\n./gen -n 1000 -type chain\n./gen -n 1000 -type max_yes\n./gen -n 1000 -type max_no\n\n./gen -n 10000 -type random\n./gen -n 10000 -type nested\n./gen -n 10000 -type disjoint\n./gen -n 10000 -type chain\n./gen -n 10000 -type max_yes\n./gen -n 10000 -type max_no\n\n./gen -n 100000 -type random\n./gen -n 100000 -type nested\n./gen -n 100000 -type disjoint\n./gen -n 100000 -type chain\n./gen -n 100000 -type max_yes\n./gen -n 100000 -type max_no\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 1 -type nested\n./gen -n 2 -type nested\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:39.061864",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "32/A",
      "title": "A. Разведка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n и d (1 ≤ n ≤ 1000, 1 ≤ d ≤ 109) — количество солдат в Васином отряде и наибольшая допустимая разница в росте соответственно. Во второй строке через пробел записано n натуральных чисел — рост всех солдат в Васином отряде. Эти числа не превосходят 109.",
      "output_spec": "Выходные данныеВыведите одно число — количество способов отправить в разведку двух солдат, рост которых отличается не больше чем на d.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 1010 20 50 60 65Выходные данныеСкопировать6Входные данныеСкопировать5 155 30 29 31 55Выходные данныеСкопировать6",
      "description": "A. Разведка\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n и d (1 ≤ n ≤ 1000, 1 ≤ d ≤ 109) — количество солдат в Васином отряде и наибольшая допустимая разница в росте соответственно. Во второй строке через пробел записано n натуральных чисел — рост всех солдат в Васином отряде. Эти числа не превосходят 109.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество способов отправить в разведку двух солдат, рост которых отличается не больше чем на d.\n\nВыходные данные\n\nВходные данныеСкопировать5 1010 20 50 60 65Выходные данныеСкопировать6Входные данныеСкопировать5 155 30 29 31 55Выходные данныеСкопировать6\n\nВходные данныеСкопировать5 1010 20 50 60 65\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 155 30 29 31 55\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces",
          "content": "Внимание участникам Дивизиона 1! В Codeforces Beta Round #32 в качестве тестовой возможности будет доступно участие «Вне конкурса». Как вы все прекрасно знаете, 2-ое октября – День рожденья Махатмы Ганди. Мы посвящаем сегодняшний раунд ему, и многим другим замечательным людям, родившимся 2-го октября :) Раунд помогали готовить Михаил Мирзаянов, Матов Дмитрий и Макс Иванов.Отдельное спасибо Юлии Сатушиной за перевод большей части условий. Всем удачи! Артем Рахов и команда CodeforcesUPD:ЗадачиРезультатыПобедитель: ReiРешения участников из Дивизиона 1 будут протестированы чуть позже",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/714",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 32"
          },
          "content_length": 586
        },
        {
          "title": "Round 32 - Codeforces",
          "content": "Problem AIterate over all possible pairs of soldiers and count those having difference of their heights less than or equal to d.Problem BReplace all occurrences of '--' with '2', '-.' with '1' and '.' with '0'.Initially, there was some problem with the test cases but was rectified soon.Problem CI won't be discussing my approach to this problem as my solution was hacked :( and I haven't tried another approach yet.Earlier I thought that my code failed because I was using int for storing answer,but later found that its giving WA after changing it to long.Problem DSimple approach was to start finding stars in order of their indexes.For this, first try for stars with smaller radius, then for top and finally for left.Following code may explain it further.int radius, x, y;for(radius=1; k>0 && radius<=150;++radius) for(x=radius; k>0 && x < N-r;++x) for(y=radius; k>0 && y < N-r;++y) if(StarAt(x,y,radius)) k--;if(k==0) //display start at x,y,radiuselse //display -1Problem EHaven't yet solved this problem too. Will be updating soon.This was my second contest at Codeforces. I was able to solve more problems this time and enter div 1, so enjoyed it :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/720",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1156
        },
        {
          "title": "Beta Round 32 - Codeforces",
          "content": "Problem A is quite straight-forward. You can simply enumerate all pairs using two for loops since N is not greater than 1000. Or you can sort the list and for every Ai, find the first Aj such that Aj-Ai>d in the range [i+1,N] using binary search.Problem B doesn't need an array at all. You can consume a single character at a time using getchar and then output a '0' if the character is '.' or consume another character to determine whether to output '1' or '2' otherwise.Problem D requires you to scan the map multiple times with increasing radii.Problem C is a little tricky. Two cells are reachable from each other if and only if their horizontal or vertical distance is exactly S if they are on the same row or column, which is identical to the property that their indexes of one dimension is the same while those of the other are congruent modulo S. So you are to count the number of remainders modulo S whose occurrence is more frequent than others, which equals N%S when S divides N or N when not for rows. The number of such occurrences is the ceiling of N/S, the smallest integer no smaller than N/S. Multiplying the product of these two numbers for rows and that of the other two for columns together gives the answer.I failed the test of this problem for a silly typing error.I will write solutions for Problem E after I solve it. My knowledge and skills of computing geometry was poor, so I didn't have enough time coding during the contest.This is the first time I participated in the contest, for previous contests were always at midnight.Really enjoy it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1569
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "1000000 1000000 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "Answer is 1000000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "10 10 6\n.*..**.**.\n**********\n****.*****\n**.***....\n***.******\n****.**..*\n**.**.****\n****.**..*\n..**.**.*.\n.*.*..***.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 4",
          "code": "-8240 -4453\n8478 -878\n7033 7520 -1002 -3146\n-9913 8035 -9876 -8757",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Beta Round 32 - Codeforces - Code 1",
          "code": "I will write solutions for Problem E after I solve it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_h = opt<int>(\"min_h\", 1);\n    int max_h = opt<int>(\"max_h\", 1000000000);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_h, max_h);\n        }\n    } else if (type == \"all_equal\") {\n        int h = rnd.next(min_h, max_h);\n        fill(a.begin(), a.end(), h);\n    } else if (type == \"increasing\") {\n        long long step = (long long)(max_h - min_h) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_h + step * i;\n            if (a[i] > max_h) a[i] = max_h;\n        }\n    } else if (type == \"decreasing\") {\n        long long step = (long long)(max_h - min_h) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_h - step * i;\n            if (a[i] < min_h) a[i] = min_h;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? min_h : max_h;\n        }\n    } else if (type == \"small_differences\") {\n        // Heights with differences at most d\n        a[0] = rnd.next(min_h, max_h - d);\n        for (int i = 1; i < n; ++i) {\n            int max_inc = min(d, max_h - a[i - 1]);\n            a[i] = a[i - 1] + rnd.next(0, max_inc);\n        }\n    } else if (type == \"large_diffs\") {\n        // Heights with differences larger than d\n        a[0] = rnd.next(min_h, max_h - (d + 1) * (n - 1));\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + d + 1;\n            if (a[i] > max_h) a[i] = max_h;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_h, max_h);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, d);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_h = opt<int>(\"min_h\", 1);\n    int max_h = opt<int>(\"max_h\", 1000000000);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_h, max_h);\n        }\n    } else if (type == \"all_equal\") {\n        int h = rnd.next(min_h, max_h);\n        fill(a.begin(), a.end(), h);\n    } else if (type == \"increasing\") {\n        long long step = (long long)(max_h - min_h) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_h + step * i;\n            if (a[i] > max_h) a[i] = max_h;\n        }\n    } else if (type == \"decreasing\") {\n        long long step = (long long)(max_h - min_h) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_h - step * i;\n            if (a[i] < min_h) a[i] = min_h;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? min_h : max_h;\n        }\n    } else if (type == \"small_differences\") {\n        // Heights with differences at most d\n        a[0] = rnd.next(min_h, max_h - d);\n        for (int i = 1; i < n; ++i) {\n            int max_inc = min(d, max_h - a[i - 1]);\n            a[i] = a[i - 1] + rnd.next(0, max_inc);\n        }\n    } else if (type == \"large_diffs\") {\n        // Heights with differences larger than d\n        a[0] = rnd.next(min_h, max_h - (d + 1) * (n - 1));\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + d + 1;\n            if (a[i] > max_h) a[i] = max_h;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(min_h, max_h);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, d);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 0 -type all_equal\n./gen -n 2 -d 0 -type all_equal\n./gen -n 2 -d 0 -type random\n./gen -n 2 -d 1000000000 -type random\n./gen -n 2 -d 0 -type alternating\n\n./gen -n 10 -d 0 -type all_equal\n./gen -n 10 -d 1000000000 -type all_equal\n./gen -n 10 -d 0 -type random\n./gen -n 10 -d 1000000000 -type random\n\n./gen -n 100 -d 0 -type increasing\n./gen -n 100 -d 0 -type decreasing\n./gen -n 100 -d 1 -type small_differences\n./gen -n 100 -d 1 -type large_diffs\n./gen -n 100 -d 1000000000 -type random\n\n./gen -n 500 -d 0 -type all_equal\n./gen -n 500 -d 1000000000 -type random\n./gen -n 500 -d 1 -type small_differences\n./gen -n 500 -d 1 -type large_diffs\n\n./gen -n 1000 -d 1000000000 -type random\n./gen -n 1000 -d 0 -type all_equal\n./gen -n 1000 -d 1 -type small_differences\n./gen -n 1000 -d 1000000000 -type alternating\n./gen -n 1000 -d 1 -type large_diffs\n./gen -n 1000 -d 0 -type alternating\n./gen -n 1000 -d 0 -type random\n./gen -n 1000 -d 1000000000 -type decreasing\n./gen -n 1000 -d 1000000000 -type increasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:40.963227",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "32/B",
      "title": "B. Borze",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).",
      "output_spec": "OutputOutput the decoded ternary number. It can have leading zeroes.",
      "sample_tests": "ExamplesInputCopy.-.--OutputCopy012InputCopy--.OutputCopy20InputCopy-..-.--OutputCopy1012",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).\n\nOutputOutput the decoded ternary number. It can have leading zeroes.\n\nInputCopy.-.--OutputCopy012InputCopy--.OutputCopy20InputCopy-..-.--OutputCopy1012\n\nInputCopy.-.--\n\nOutputCopy012\n\nInputCopy--.\n\nOutputCopy20\n\nInputCopy-..-.--\n\nOutputCopy1012",
      "solutions": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces",
          "content": "Attention, participants from the Division 1! As a test feature, you can participate in Codeforces Beta Round #32 \"out of competition\".Everybody knows, that the 2nd of October - birthday of Mohandas Gandhi. We dedicate today's round to him, and many other great people who were born on October 2 :)Round was prepared by Mike Mirzayanov, Matov Dmitry and Max Ivanov.Special thanks to Julia Satushina for translation of statements.Good luck!Artem Rakhov and Codeforces teamUPD:ProblemsFinal standingsWinner: ReiSolutions of participants from Division 1 will be tested later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/714",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 32"
          },
          "content_length": 570
        },
        {
          "title": "Round 32 - Codeforces",
          "content": "Problem AIterate over all possible pairs of soldiers and count those having difference of their heights less than or equal to d.Problem BReplace all occurrences of '--' with '2', '-.' with '1' and '.' with '0'.Initially, there was some problem with the test cases but was rectified soon.Problem CI won't be discussing my approach to this problem as my solution was hacked :( and I haven't tried another approach yet.Earlier I thought that my code failed because I was using int for storing answer,but later found that its giving WA after changing it to long.Problem DSimple approach was to start finding stars in order of their indexes.For this, first try for stars with smaller radius, then for top and finally for left.Following code may explain it further.int radius, x, y;for(radius=1; k>0 && radius<=150;++radius) for(x=radius; k>0 && x < N-r;++x) for(y=radius; k>0 && y < N-r;++y) if(StarAt(x,y,radius)) k--;if(k==0) //display start at x,y,radiuselse //display -1Problem EHaven't yet solved this problem too. Will be updating soon.This was my second contest at Codeforces. I was able to solve more problems this time and enter div 1, so enjoyed it :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/720",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1156
        },
        {
          "title": "Beta Round 32 - Codeforces",
          "content": "Problem A is quite straight-forward. You can simply enumerate all pairs using two for loops since N is not greater than 1000. Or you can sort the list and for every Ai, find the first Aj such that Aj-Ai>d in the range [i+1,N] using binary search.Problem B doesn't need an array at all. You can consume a single character at a time using getchar and then output a '0' if the character is '.' or consume another character to determine whether to output '1' or '2' otherwise.Problem D requires you to scan the map multiple times with increasing radii.Problem C is a little tricky. Two cells are reachable from each other if and only if their horizontal or vertical distance is exactly S if they are on the same row or column, which is identical to the property that their indexes of one dimension is the same while those of the other are congruent modulo S. So you are to count the number of remainders modulo S whose occurrence is more frequent than others, which equals N%S when S divides N or N when not for rows. The number of such occurrences is the ceiling of N/S, the smallest integer no smaller than N/S. Multiplying the product of these two numbers for rows and that of the other two for columns together gives the answer.I failed the test of this problem for a silly typing error.I will write solutions for Problem E after I solve it. My knowledge and skills of computing geometry was poor, so I didn't have enough time coding during the contest.This is the first time I participated in the contest, for previous contests were always at midnight.Really enjoy it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1569
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "1000000 1000000 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "Answer is 1000000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Beta Round 32 - Codeforces - Code 1",
          "code": "I will write solutions for Problem E after I solve it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    inf.readEof();\n\n    int n = s.length();\n    ensuref(1 <= n && n <= 200, \"The input string length is %d, which is not between 1 and 200\", n);\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '.' || s[i] == '-', \"Invalid character at position %d: '%c'\", i+1, s[i]);\n    }\n\n    int i = 0;\n    while (i < n) {\n        if (s[i] == '.') {\n            i += 1;\n        }\n        else if (s[i] == '-') {\n            if (i+1 < n) {\n                if (s[i+1] == '.') {\n                    i += 2;\n                }\n                else if (s[i+1] == '-') {\n                    i += 2;\n                }\n                else {\n                    ensuref(false, \"Invalid sequence at position %d: '-%c'\", i+1, s[i+1]);\n                }\n            }\n            else {\n                ensuref(false, \"'-' at position %d is not followed by a character\", i+1);\n            }\n        }\n        else {\n            ensuref(false, \"Unexpected character at position %d: '%c'\", i+1, s[i]);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    inf.readEof();\n\n    int n = s.length();\n    ensuref(1 <= n && n <= 200, \"The input string length is %d, which is not between 1 and 200\", n);\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '.' || s[i] == '-', \"Invalid character at position %d: '%c'\", i+1, s[i]);\n    }\n\n    int i = 0;\n    while (i < n) {\n        if (s[i] == '.') {\n            i += 1;\n        }\n        else if (s[i] == '-') {\n            if (i+1 < n) {\n                if (s[i+1] == '.') {\n                    i += 2;\n                }\n                else if (s[i+1] == '-') {\n                    i += 2;\n                }\n                else {\n                    ensuref(false, \"Invalid sequence at position %d: '-%c'\", i+1, s[i+1]);\n                }\n            }\n            else {\n                ensuref(false, \"'-' at position %d is not followed by a character\", i+1);\n            }\n        }\n        else {\n            ensuref(false, \"Unexpected character at position %d: '%c'\", i+1, s[i]);\n        }\n    }\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    inf.readEof();\n\n    int n = s.length();\n    ensuref(1 <= n && n <= 200, \"The input string length is %d, which is not between 1 and 200\", n);\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '.' || s[i] == '-', \"Invalid character at position %d: '%c'\", i+1, s[i]);\n    }\n\n    int i = 0;\n    while (i < n) {\n        if (s[i] == '.') {\n            i += 1;\n        }\n        else if (s[i] == '-') {\n            if (i+1 < n) {\n                if (s[i+1] == '.') {\n                    i += 2;\n                }\n                else if (s[i+1] == '-') {\n                    i += 2;\n                }\n                else {\n                    ensuref(false, \"Invalid sequence at position %d: '-%c'\", i+1, s[i+1]);\n                }\n            }\n            else {\n                ensuref(false, \"'-' at position %d is not followed by a character\", i+1);\n            }\n        }\n        else {\n            ensuref(false, \"Unexpected character at position %d: '%c'\", i+1, s[i]);\n        }\n    }\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string code;\n\n    if (type == \"random\") {\n        while ((int)code.length() < len) {\n            int remaining = len - code.length();\n            if (remaining >= 2) {\n                // Can choose any symbol\n                int symbol_type = rnd.next(3); // 0 for '.', 1 for '-.', 2 for '--'\n                if (symbol_type == 0) {\n                    code += '.';\n                } else if (symbol_type == 1) {\n                    code += \"-.\";\n                } else {\n                    code += \"--\";\n                }\n            } else if (remaining == 1) {\n                // Only '.' can fit\n                code += '.';\n            } else {\n                // Should not happen\n                break;\n            }\n        }\n    } else if (type == \"dots\") {\n        // Code consisting of only '.'\n        code.assign(len, '.');\n    } else if (type == \"dashes1\") {\n        // Code consisting of only '-.'\n        // Length of each symbol is 2, so len must be even\n        if (len % 2 != 0) {\n            cerr << \"Invalid length for dashes1 type. Length must be even.\" << endl;\n            return 1;\n        }\n        int num_symbols = len / 2;\n        for (int i = 0; i < num_symbols; ++i) {\n            code += \"-.\";\n        }\n    } else if (type == \"dashes2\") {\n        // Code consisting of only '--'\n        // Length of each symbol is 2, so len must be even\n        if (len % 2 != 0) {\n            cerr << \"Invalid length for dashes2 type. Length must be even.\" << endl;\n            return 1;\n        }\n        int num_symbols = len / 2;\n        for (int i = 0; i < num_symbols; ++i) {\n            code += \"--\";\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between '.', '-.' and '--'\n        int positions = 0;\n        while ((int)code.length() < len) {\n            int remaining = len - code.length();\n            if (remaining >= 2) {\n                if (positions % 3 == 0) {\n                    code += '.';\n                } else if (positions % 3 == 1) {\n                    code += \"-.\";\n                } else {\n                    code += \"--\";\n                }\n                ++positions;\n            } else if (remaining == 1) {\n                code += '.';\n                ++positions;\n            } else {\n                break;\n            }\n        }\n    } else if (type == \"max_leading_zeros\") {\n        // Start with as many '.' as possible, leaving room for one non-zero digit\n        int num_dots = len;\n        if (len >= 3) {\n            num_dots = len - 2;\n        }\n        code.assign(num_dots, '.');\n        int remaining = len - num_dots;\n        if (remaining == 2) {\n            // Add one symbol of length 2\n            int symbol_type = rnd.next(2); // 0 for '-.', 1 for '--'\n            if (symbol_type == 0) {\n                code += \"-.\";\n            } else {\n                code += \"--\";\n            }\n        } else if (remaining == 1) {\n            code += '.';\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    \n    printf(\"%s\\n\", code.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string code;\n\n    if (type == \"random\") {\n        while ((int)code.length() < len) {\n            int remaining = len - code.length();\n            if (remaining >= 2) {\n                // Can choose any symbol\n                int symbol_type = rnd.next(3); // 0 for '.', 1 for '-.', 2 for '--'\n                if (symbol_type == 0) {\n                    code += '.';\n                } else if (symbol_type == 1) {\n                    code += \"-.\";\n                } else {\n                    code += \"--\";\n                }\n            } else if (remaining == 1) {\n                // Only '.' can fit\n                code += '.';\n            } else {\n                // Should not happen\n                break;\n            }\n        }\n    } else if (type == \"dots\") {\n        // Code consisting of only '.'\n        code.assign(len, '.');\n    } else if (type == \"dashes1\") {\n        // Code consisting of only '-.'\n        // Length of each symbol is 2, so len must be even\n        if (len % 2 != 0) {\n            cerr << \"Invalid length for dashes1 type. Length must be even.\" << endl;\n            return 1;\n        }\n        int num_symbols = len / 2;\n        for (int i = 0; i < num_symbols; ++i) {\n            code += \"-.\";\n        }\n    } else if (type == \"dashes2\") {\n        // Code consisting of only '--'\n        // Length of each symbol is 2, so len must be even\n        if (len % 2 != 0) {\n            cerr << \"Invalid length for dashes2 type. Length must be even.\" << endl;\n            return 1;\n        }\n        int num_symbols = len / 2;\n        for (int i = 0; i < num_symbols; ++i) {\n            code += \"--\";\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between '.', '-.' and '--'\n        int positions = 0;\n        while ((int)code.length() < len) {\n            int remaining = len - code.length();\n            if (remaining >= 2) {\n                if (positions % 3 == 0) {\n                    code += '.';\n                } else if (positions % 3 == 1) {\n                    code += \"-.\";\n                } else {\n                    code += \"--\";\n                }\n                ++positions;\n            } else if (remaining == 1) {\n                code += '.';\n                ++positions;\n            } else {\n                break;\n            }\n        }\n    } else if (type == \"max_leading_zeros\") {\n        // Start with as many '.' as possible, leaving room for one non-zero digit\n        int num_dots = len;\n        if (len >= 3) {\n            num_dots = len - 2;\n        }\n        code.assign(num_dots, '.');\n        int remaining = len - num_dots;\n        if (remaining == 2) {\n            // Add one symbol of length 2\n            int symbol_type = rnd.next(2); // 0 for '-.', 1 for '--'\n            if (symbol_type == 0) {\n                code += \"-.\";\n            } else {\n                code += \"--\";\n            }\n        } else if (remaining == 1) {\n            code += '.';\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    \n    printf(\"%s\\n\", code.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 1 -type dots\n./gen -len 1 -type random\n./gen -len 2 -type dashes1\n./gen -len 2 -type dashes2\n./gen -len 2 -type random\n./gen -len 3 -type random\n./gen -len 4 -type dashes1\n./gen -len 4 -type dashes2\n./gen -len 50 -type random\n./gen -len 50 -type dots\n./gen -len 50 -type dashes1\n./gen -len 50 -type dashes2\n./gen -len 50 -type max_leading_zeros\n./gen -len 50 -type alternating\n./gen -len 99 -type random\n./gen -len 99 -type max_leading_zeros\n./gen -len 100 -type random\n./gen -len 100 -type dots\n./gen -len 100 -type dashes1\n./gen -len 100 -type dashes2\n./gen -len 100 -type max_leading_zeros\n./gen -len 100 -type alternating\n./gen -len 199 -type random\n./gen -len 200 -type random\n./gen -len 200 -type dots\n./gen -len 200 -type dashes1\n./gen -len 200 -type dashes2\n./gen -len 200 -type max_leading_zeros\n./gen -len 200 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:42.837736",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "32/C",
      "title": "C. Flea",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, s (1 ≤ n, m, s ≤ 106) — length of the board, width of the board and length of the flea's jump.",
      "output_spec": "OutputOutput the only integer — the number of the required starting positions of the flea.",
      "sample_tests": "ExamplesInputCopy2 3 1000000OutputCopy6InputCopy3 3 2OutputCopy4",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, s (1 ≤ n, m, s ≤ 106) — length of the board, width of the board and length of the flea's jump.\n\nOutputOutput the only integer — the number of the required starting positions of the flea.\n\nInputCopy2 3 1000000OutputCopy6InputCopy3 3 2OutputCopy4\n\nInputCopy2 3 1000000\n\nOutputCopy6\n\nInputCopy3 3 2\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces",
          "content": "Attention, participants from the Division 1! As a test feature, you can participate in Codeforces Beta Round #32 \"out of competition\".Everybody knows, that the 2nd of October - birthday of Mohandas Gandhi. We dedicate today's round to him, and many other great people who were born on October 2 :)Round was prepared by Mike Mirzayanov, Matov Dmitry and Max Ivanov.Special thanks to Julia Satushina for translation of statements.Good luck!Artem Rakhov and Codeforces teamUPD:ProblemsFinal standingsWinner: ReiSolutions of participants from Division 1 will be tested later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/714",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 32"
          },
          "content_length": 570
        },
        {
          "title": "Round 32 - Codeforces",
          "content": "Problem AIterate over all possible pairs of soldiers and count those having difference of their heights less than or equal to d.Problem BReplace all occurrences of '--' with '2', '-.' with '1' and '.' with '0'.Initially, there was some problem with the test cases but was rectified soon.Problem CI won't be discussing my approach to this problem as my solution was hacked :( and I haven't tried another approach yet.Earlier I thought that my code failed because I was using int for storing answer,but later found that its giving WA after changing it to long.Problem DSimple approach was to start finding stars in order of their indexes.For this, first try for stars with smaller radius, then for top and finally for left.Following code may explain it further.int radius, x, y;for(radius=1; k>0 && radius<=150;++radius) for(x=radius; k>0 && x < N-r;++x) for(y=radius; k>0 && y < N-r;++y) if(StarAt(x,y,radius)) k--;if(k==0) //display start at x,y,radiuselse //display -1Problem EHaven't yet solved this problem too. Will be updating soon.This was my second contest at Codeforces. I was able to solve more problems this time and enter div 1, so enjoyed it :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/720",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1156
        },
        {
          "title": "Beta Round 32 - Codeforces",
          "content": "Problem A is quite straight-forward. You can simply enumerate all pairs using two for loops since N is not greater than 1000. Or you can sort the list and for every Ai, find the first Aj such that Aj-Ai>d in the range [i+1,N] using binary search.Problem B doesn't need an array at all. You can consume a single character at a time using getchar and then output a '0' if the character is '.' or consume another character to determine whether to output '1' or '2' otherwise.Problem D requires you to scan the map multiple times with increasing radii.Problem C is a little tricky. Two cells are reachable from each other if and only if their horizontal or vertical distance is exactly S if they are on the same row or column, which is identical to the property that their indexes of one dimension is the same while those of the other are congruent modulo S. So you are to count the number of remainders modulo S whose occurrence is more frequent than others, which equals N%S when S divides N or N when not for rows. The number of such occurrences is the ceiling of N/S, the smallest integer no smaller than N/S. Multiplying the product of these two numbers for rows and that of the other two for columns together gives the answer.I failed the test of this problem for a silly typing error.I will write solutions for Problem E after I solve it. My knowledge and skills of computing geometry was poor, so I didn't have enough time coding during the contest.This is the first time I participated in the contest, for previous contests were always at midnight.Really enjoy it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1569
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "1000000 1000000 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "Answer is 1000000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Beta Round 32 - Codeforces - Code 1",
          "code": "I will write solutions for Problem E after I solve it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"\");\n\n    // Adjust parameters according to 'type'\n    if (type == \"max\") {\n        n = 1000000;\n        m = 1000000;\n        s = 1000000;\n    } else if (type == \"min\") {\n        n = 1;\n        m = 1;\n        s = 1;\n    } else if (type == \"n_eq_s\") {\n        if (s == -1) {\n            s = rnd.next(1, 1000000);\n        }\n        n = s;\n        if (m == -1) {\n            m = rnd.next(1, 1000000);\n        }\n    } else if (type == \"m_eq_s\") {\n        if (s == -1) {\n            s = rnd.next(1, 1000000);\n        }\n        m = s;\n        if (n == -1) {\n            n = rnd.next(1, 1000000);\n        }\n    } else if (type == \"s_divides_n\") {\n        if (n == -1) {\n            n = rnd.next(1, 1000000);\n        }\n        s = rnd.next(1, n);\n        while (n % s != 0) {\n            s = rnd.next(1, n);\n        }\n        if (m == -1) {\n            m = rnd.next(1, 1000000);\n        }\n    } else if (type == \"s_divides_m\") {\n        if (m == -1) {\n            m = rnd.next(1, 1000000);\n        }\n        s = rnd.next(1, m);\n        while (m % s != 0) {\n            s = rnd.next(1, m);\n        }\n        if (n == -1) {\n            n = rnd.next(1, 1000000);\n        }\n    } else if (type == \"s_divides_n_m\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        if (m == -1) m = rnd.next(1, 1000000);\n        s = rnd.next(1, min(n, m));\n        while (n % s != 0 || m % s != 0) {\n            s = rnd.next(1, min(n, m));\n        }\n    } else if (type == \"s_coprime_n_m\") {\n        if (n == -1 || m == -1) {\n            fprintf(stderr, \"n and m must be provided for s_coprime_n_m\\n\");\n            exit(1);\n        }\n        s = rnd.next(1, min(n, m));\n        while (__gcd(s, n) != 1 || __gcd(s, m) != 1) {\n            s = rnd.next(1, min(n, m));\n        }\n    } else if (type == \"s_equals_1\") {\n        s = 1;\n        if (n == -1) n = rnd.next(1, 1000000);\n        if (m == -1) m = rnd.next(1, 1000000);\n    } else if (type == \"s_large\") {\n        s = 1000000;\n        if (n == -1) n = rnd.next(1, 1000000);\n        if (m == -1) m = rnd.next(1, 1000000);\n    } else if (type == \"s_equals_gcd\") {\n        if (n == -1 || m == -1) {\n            fprintf(stderr, \"n and m must be provided for s_equals_gcd\\n\");\n            exit(1);\n        }\n        s = __gcd(n, m);\n        if (s == 0) s = 1;\n    } else if (type == \"n_big_m_small\") {\n        n = 1000000;\n        m = 1;\n        s = rnd.next(1, n);\n    } else if (type == \"m_big_n_small\") {\n        n = 1;\n        m = 1000000;\n        s = rnd.next(1, m);\n    } else if (type == \"n_eq_m\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        m = n;\n        if (s == -1) s = rnd.next(1, 1000000);\n    } else if (type == \"s_max_n_m_min\") {\n        n = 1;\n        m = 1;\n        s = 1000000;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000000);\n        m = rnd.next(1, 1000000);\n        s = rnd.next(1, 1000000);\n    }\n\n    // Ensure that n, m, s are set and within constraints\n    if (n == -1) n = rnd.next(1, 1000000);\n    if (m == -1) m = rnd.next(1, 1000000);\n    if (s == -1) s = rnd.next(1, 1000000);\n\n    n = max(1, min(1000000, n));\n    m = max(1, min(1000000, m));\n    s = max(1, min(1000000, s));\n\n    printf(\"%d %d %d\\n\", n, m, s);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"\");\n\n    // Adjust parameters according to 'type'\n    if (type == \"max\") {\n        n = 1000000;\n        m = 1000000;\n        s = 1000000;\n    } else if (type == \"min\") {\n        n = 1;\n        m = 1;\n        s = 1;\n    } else if (type == \"n_eq_s\") {\n        if (s == -1) {\n            s = rnd.next(1, 1000000);\n        }\n        n = s;\n        if (m == -1) {\n            m = rnd.next(1, 1000000);\n        }\n    } else if (type == \"m_eq_s\") {\n        if (s == -1) {\n            s = rnd.next(1, 1000000);\n        }\n        m = s;\n        if (n == -1) {\n            n = rnd.next(1, 1000000);\n        }\n    } else if (type == \"s_divides_n\") {\n        if (n == -1) {\n            n = rnd.next(1, 1000000);\n        }\n        s = rnd.next(1, n);\n        while (n % s != 0) {\n            s = rnd.next(1, n);\n        }\n        if (m == -1) {\n            m = rnd.next(1, 1000000);\n        }\n    } else if (type == \"s_divides_m\") {\n        if (m == -1) {\n            m = rnd.next(1, 1000000);\n        }\n        s = rnd.next(1, m);\n        while (m % s != 0) {\n            s = rnd.next(1, m);\n        }\n        if (n == -1) {\n            n = rnd.next(1, 1000000);\n        }\n    } else if (type == \"s_divides_n_m\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        if (m == -1) m = rnd.next(1, 1000000);\n        s = rnd.next(1, min(n, m));\n        while (n % s != 0 || m % s != 0) {\n            s = rnd.next(1, min(n, m));\n        }\n    } else if (type == \"s_coprime_n_m\") {\n        if (n == -1 || m == -1) {\n            fprintf(stderr, \"n and m must be provided for s_coprime_n_m\\n\");\n            exit(1);\n        }\n        s = rnd.next(1, min(n, m));\n        while (__gcd(s, n) != 1 || __gcd(s, m) != 1) {\n            s = rnd.next(1, min(n, m));\n        }\n    } else if (type == \"s_equals_1\") {\n        s = 1;\n        if (n == -1) n = rnd.next(1, 1000000);\n        if (m == -1) m = rnd.next(1, 1000000);\n    } else if (type == \"s_large\") {\n        s = 1000000;\n        if (n == -1) n = rnd.next(1, 1000000);\n        if (m == -1) m = rnd.next(1, 1000000);\n    } else if (type == \"s_equals_gcd\") {\n        if (n == -1 || m == -1) {\n            fprintf(stderr, \"n and m must be provided for s_equals_gcd\\n\");\n            exit(1);\n        }\n        s = __gcd(n, m);\n        if (s == 0) s = 1;\n    } else if (type == \"n_big_m_small\") {\n        n = 1000000;\n        m = 1;\n        s = rnd.next(1, n);\n    } else if (type == \"m_big_n_small\") {\n        n = 1;\n        m = 1000000;\n        s = rnd.next(1, m);\n    } else if (type == \"n_eq_m\") {\n        if (n == -1) n = rnd.next(1, 1000000);\n        m = n;\n        if (s == -1) s = rnd.next(1, 1000000);\n    } else if (type == \"s_max_n_m_min\") {\n        n = 1;\n        m = 1;\n        s = 1000000;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000000);\n        m = rnd.next(1, 1000000);\n        s = rnd.next(1, 1000000);\n    }\n\n    // Ensure that n, m, s are set and within constraints\n    if (n == -1) n = rnd.next(1, 1000000);\n    if (m == -1) m = rnd.next(1, 1000000);\n    if (s == -1) s = rnd.next(1, 1000000);\n\n    n = max(1, min(1000000, n));\n    m = max(1, min(1000000, m));\n    s = max(1, min(1000000, s));\n\n    printf(\"%d %d %d\\n\", n, m, s);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -n 1000000 -m 1000000 -type s_equals_1\n./gen -n 1000000 -m 1000000 -type s_large\n./gen -type n_big_m_small\n./gen -type m_big_n_small\n./gen -type n_eq_s\n./gen -type m_eq_s\n./gen -n 999983 -m 999979 -s 1   # Large primes\n./gen -type n_eq_m\n./gen -n 999983 -m 999979 -type s_coprime_n_m # s co-prime to n and m\n./gen -n 1000000 -m 1 -type s_equals_1\n./gen -n 1000000 -m 1000000 -type s_equals_gcd\n./gen -n 123456 -m 789012\n./gen -n 5000 -m 5000 -s 2500\n./gen -n 1000000 -m 1000000 -type s_divides_n_m\n./gen -n 999999 -m 1000000 -s 1000000\n./gen -n 1000000 -m 999999 -s 999999\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -n 10 -m 10 -s 3\n./gen -type min\n./gen -type s_max_n_m_min\n./gen -n 1000000 -m 1000000 -s 500000\n./gen -n 999999 -m 1000000 -type s_equals_1\n./gen -n 1 -m 1000000 -type m_eq_s\n./gen -n 1 -m 1000000 -type s_equals_1\n./gen -n 1 -m 1 -type s_max_n_m_min\n./gen -n 500000 -m 500000 -type s_equals_1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:45.065732",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "32/D",
      "title": "D. Constellation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and k (1 ≤ n, m ≤ 300, 1 ≤ k ≤ 3·107) — height and width of the map and index of the required constellation respectively. The upper-left corner has coordinates (1, 1), and the lower-right — (n, m). Then there follow n lines, m characters each — description of the map. j-th character in i-th line is «*», if there is a star in the corresponding square, and «.» if this square is empty.",
      "output_spec": "OutputIf the number of the constellations is less than k, output -1. Otherwise output 5 lines, two integers each — coordinates of the required constellation. Output the stars in the following order: central, upper, lower, left, right.",
      "sample_tests": "ExamplesInputCopy5 6 1....*....***....*...*....***..OutputCopy2 51 53 52 42 6InputCopy5 6 2....*....***....*...*....***..OutputCopy-1InputCopy7 7 2...*.............*...*.***.*...*.............*...OutputCopy4 41 47 44 14 7",
      "description": "D. Constellation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and k (1 ≤ n, m ≤ 300, 1 ≤ k ≤ 3·107) — height and width of the map and index of the required constellation respectively. The upper-left corner has coordinates (1, 1), and the lower-right — (n, m). Then there follow n lines, m characters each — description of the map. j-th character in i-th line is «*», if there is a star in the corresponding square, and «.» if this square is empty.\n\nOutputIf the number of the constellations is less than k, output -1. Otherwise output 5 lines, two integers each — coordinates of the required constellation. Output the stars in the following order: central, upper, lower, left, right.\n\nInputCopy5 6 1....*....***....*...*....***..OutputCopy2 51 53 52 42 6InputCopy5 6 2....*....***....*...*....***..OutputCopy-1InputCopy7 7 2...*.............*...*.***.*...*.............*...OutputCopy4 41 47 44 14 7\n\nInputCopy5 6 1....*....***....*...*....***..\n\nOutputCopy2 51 53 52 42 6\n\nInputCopy5 6 2....*....***....*...*....***..\n\nOutputCopy-1\n\nInputCopy7 7 2...*.............*...*.***.*...*.............*...\n\nOutputCopy4 41 47 44 14 7",
      "solutions": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces",
          "content": "Attention, participants from the Division 1! As a test feature, you can participate in Codeforces Beta Round #32 \"out of competition\".Everybody knows, that the 2nd of October - birthday of Mohandas Gandhi. We dedicate today's round to him, and many other great people who were born on October 2 :)Round was prepared by Mike Mirzayanov, Matov Dmitry and Max Ivanov.Special thanks to Julia Satushina for translation of statements.Good luck!Artem Rakhov and Codeforces teamUPD:ProblemsFinal standingsWinner: ReiSolutions of participants from Division 1 will be tested later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/714",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 32"
          },
          "content_length": 570
        },
        {
          "title": "Round 32 - Codeforces",
          "content": "Problem AIterate over all possible pairs of soldiers and count those having difference of their heights less than or equal to d.Problem BReplace all occurrences of '--' with '2', '-.' with '1' and '.' with '0'.Initially, there was some problem with the test cases but was rectified soon.Problem CI won't be discussing my approach to this problem as my solution was hacked :( and I haven't tried another approach yet.Earlier I thought that my code failed because I was using int for storing answer,but later found that its giving WA after changing it to long.Problem DSimple approach was to start finding stars in order of their indexes.For this, first try for stars with smaller radius, then for top and finally for left.Following code may explain it further.int radius, x, y;for(radius=1; k>0 && radius<=150;++radius) for(x=radius; k>0 && x < N-r;++x) for(y=radius; k>0 && y < N-r;++y) if(StarAt(x,y,radius)) k--;if(k==0) //display start at x,y,radiuselse //display -1Problem EHaven't yet solved this problem too. Will be updating soon.This was my second contest at Codeforces. I was able to solve more problems this time and enter div 1, so enjoyed it :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/720",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1156
        },
        {
          "title": "Beta Round 32 - Codeforces",
          "content": "Problem A is quite straight-forward. You can simply enumerate all pairs using two for loops since N is not greater than 1000. Or you can sort the list and for every Ai, find the first Aj such that Aj-Ai>d in the range [i+1,N] using binary search.Problem B doesn't need an array at all. You can consume a single character at a time using getchar and then output a '0' if the character is '.' or consume another character to determine whether to output '1' or '2' otherwise.Problem D requires you to scan the map multiple times with increasing radii.Problem C is a little tricky. Two cells are reachable from each other if and only if their horizontal or vertical distance is exactly S if they are on the same row or column, which is identical to the property that their indexes of one dimension is the same while those of the other are congruent modulo S. So you are to count the number of remainders modulo S whose occurrence is more frequent than others, which equals N%S when S divides N or N when not for rows. The number of such occurrences is the ceiling of N/S, the smallest integer no smaller than N/S. Multiplying the product of these two numbers for rows and that of the other two for columns together gives the answer.I failed the test of this problem for a silly typing error.I will write solutions for Problem E after I solve it. My knowledge and skills of computing geometry was poor, so I didn't have enough time coding during the contest.This is the first time I participated in the contest, for previous contests were always at midnight.Really enjoy it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1569
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "1000000 1000000 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "Answer is 1000000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Beta Round 32 - Codeforces - Code 1",
          "code": "I will write solutions for Problem E after I solve it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30000000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '.' || c == '*', \"Invalid character '%c' in line %d at position %d\", c, i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30000000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '.' || c == '*', \"Invalid character '%c' in line %d at position %d\", c, i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30000000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '.' || c == '*', \"Invalid character '%c' in line %d at position %d\", c, i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of rows\n    int m = opt<int>(\"m\"); // number of columns\n    int k = opt<int>(\"k\", 1); // index of the required constellation\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize grid\n    vector<string> grid(n, string(m, '.')); // initialize with '.'\n\n    if (type == \"single\") {\n        // Place stars to form a single cross\n        int x = 1; // choose x = 1\n        int i = n / 2; // central position, row\n        int j = m / 2; // central position, column\n\n        // Check that the positions are within the grid\n        if (i - x >= 0 && i + x < n && j - x >= 0 && j + x < m) {\n            grid[i][j] = '*'; // central\n            grid[i - x][j] = '*'; // upper\n            grid[i + x][j] = '*'; // lower\n            grid[i][j - x] = '*'; // left\n            grid[i][j + x] = '*'; // right\n        }\n\n    } else if (type == \"full\") {\n        // Fill the grid with stars\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = '*';\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly fill the grid with stars or no stars\n        double prob = opt<double>(\"p\", 0.5); // probability of a star\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (rnd.next() < prob) {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    } else if (type == \"empty\") {\n        // Grid remains empty\n    } else if (type == \"max_constellations\") {\n        // Create a grid designed to maximize the number of constellations with x = 1\n        for (int i = 1; i < n - 1; i++) { // avoid borders\n            for (int j = 1; j < m - 1; j++) {\n                grid[i][j] = '*';\n            }\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of rows\n    int m = opt<int>(\"m\"); // number of columns\n    int k = opt<int>(\"k\", 1); // index of the required constellation\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize grid\n    vector<string> grid(n, string(m, '.')); // initialize with '.'\n\n    if (type == \"single\") {\n        // Place stars to form a single cross\n        int x = 1; // choose x = 1\n        int i = n / 2; // central position, row\n        int j = m / 2; // central position, column\n\n        // Check that the positions are within the grid\n        if (i - x >= 0 && i + x < n && j - x >= 0 && j + x < m) {\n            grid[i][j] = '*'; // central\n            grid[i - x][j] = '*'; // upper\n            grid[i + x][j] = '*'; // lower\n            grid[i][j - x] = '*'; // left\n            grid[i][j + x] = '*'; // right\n        }\n\n    } else if (type == \"full\") {\n        // Fill the grid with stars\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = '*';\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly fill the grid with stars or no stars\n        double prob = opt<double>(\"p\", 0.5); // probability of a star\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (rnd.next() < prob) {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    } else if (type == \"empty\") {\n        // Grid remains empty\n    } else if (type == \"max_constellations\") {\n        // Create a grid designed to maximize the number of constellations with x = 1\n        for (int i = 1; i < n - 1; i++) { // avoid borders\n            for (int j = 1; j < m - 1; j++) {\n                grid[i][j] = '*';\n            }\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 6 -k 1 -type single\n./gen -n 5 -m 6 -k 1 -type full\n./gen -n 5 -m 6 -k 1 -type random -p 0.7\n./gen -n 5 -m 6 -k 1 -type empty\n\n./gen -n 100 -m 100 -k 5000 -type random -p 0.3\n./gen -n 300 -m 300 -k 1000000 -type full\n./gen -n 300 -m 300 -k 10000000 -type max_constellations\n\n./gen -n 300 -m 300 -k 1 -type single\n\n./gen -n 1 -m 1 -k 1 -type single\n\n./gen -n 300 -m 1 -k 1 -type single\n\n./gen -n 300 -m 300 -k 1 -type empty\n\n./gen -n 300 -m 300 -k 30000000 -type random -p 0.9\n\n./gen -n 299 -m 300 -k 1000000 -type random -p 0.5\n\n./gen -n 123 -m 250 -k 500000 -type random -p 0.5\n\n./gen -n 150 -m 150 -k 100000 -type random -p 0.5\n\n./gen -n 300 -m 300 -k 30000000 -type full\n\n./gen -n 300 -m 300 -k 30000000 -type random -p 0.99\n\n./gen -n 300 -m 300 -k 2 -type random -p 0.01\n\n./gen -n 300 -m 300 -k 100000 -type random -p 0.05\n\n./gen -n 300 -m 300 -k 5000000 -type random -p 0.2\n\n./gen -n 300 -m 300 -k 5000000 -type random -p 0.8\n\n./gen -n 150 -m 150 -k 1 -type single\n\n./gen -n 300 -m 300 -k 25000000 -type random -p 0.5\n\n./gen -n 200 -m 200 -k 10 -type empty\n\n./gen -n 200 -m 200 -k 1000 -type random -p 0.05\n\n./gen -n 200 -m 200 -k 5000000 -type random -p 0.95\n\n./gen -n 300 -m 300 -k 29999999 -type random -p 0.99\n\n./gen -n 50 -m 50 -k 100000 -type random -p 0.5\n\n./gen -n 100 -m 100 -k 1000000 -type random -p 0.5\n\n./gen -n 300 -m 1 -k 1000 -type random -p 0.9\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:46.660344",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "32/E",
      "title": "E. Hide-and-Seek",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers xv and yv — coordinates of Victor.The second line contains two numbers xp and yp — coordinates of Peter.The third line contains 4 numbers xw, 1, yw, 1, xw, 2, yw, 2 — coordinates of the wall.The forth line contains 4 numbers xm, 1, ym, 1, xm, 2, ym, 2 — coordinates of the mirror.All the coordinates are integer numbers, and don't exceed 104 in absolute value. It's guaranteed, that the segments don't have common points, Victor and Peter are not on any of the segments, coordinates of Victor and Peter aren't the same, the segments don't degenerate into points.",
      "output_spec": "OutputOutput YES, if Victor can see Peter without leaving the initial spot. Otherwise output NO.",
      "sample_tests": "ExamplesInputCopy-1 31 30 2 0 40 0 0 1OutputCopyNOInputCopy0 01 10 1 1 0-100 -100 -101 -101OutputCopyNOInputCopy0 01 10 1 1 0-1 1 1 3OutputCopyYESInputCopy0 010 0100 100 101 1011 0 3 0OutputCopyYES",
      "description": "E. Hide-and-Seek\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two numbers xv and yv — coordinates of Victor.The second line contains two numbers xp and yp — coordinates of Peter.The third line contains 4 numbers xw, 1, yw, 1, xw, 2, yw, 2 — coordinates of the wall.The forth line contains 4 numbers xm, 1, ym, 1, xm, 2, ym, 2 — coordinates of the mirror.All the coordinates are integer numbers, and don't exceed 104 in absolute value. It's guaranteed, that the segments don't have common points, Victor and Peter are not on any of the segments, coordinates of Victor and Peter aren't the same, the segments don't degenerate into points.\n\nOutputOutput YES, if Victor can see Peter without leaving the initial spot. Otherwise output NO.\n\nInputCopy-1 31 30 2 0 40 0 0 1OutputCopyNOInputCopy0 01 10 1 1 0-100 -100 -101 -101OutputCopyNOInputCopy0 01 10 1 1 0-1 1 1 3OutputCopyYESInputCopy0 010 0100 100 101 1011 0 3 0OutputCopyYES\n\nInputCopy-1 31 30 2 0 40 0 0 1\n\nOutputCopyNO\n\nInputCopy0 01 10 1 1 0-100 -100 -101 -101\n\nOutputCopyNO\n\nInputCopy0 01 10 1 1 0-1 1 1 3\n\nOutputCopyYES\n\nInputCopy0 010 0100 100 101 1011 0 3 0\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces",
          "content": "Attention, participants from the Division 1! As a test feature, you can participate in Codeforces Beta Round #32 \"out of competition\".Everybody knows, that the 2nd of October - birthday of Mohandas Gandhi. We dedicate today's round to him, and many other great people who were born on October 2 :)Round was prepared by Mike Mirzayanov, Matov Dmitry and Max Ivanov.Special thanks to Julia Satushina for translation of statements.Good luck!Artem Rakhov and Codeforces teamUPD:ProblemsFinal standingsWinner: ReiSolutions of participants from Division 1 will be tested later",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/714",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 32"
          },
          "content_length": 570
        },
        {
          "title": "Round 32 - Codeforces",
          "content": "Problem AIterate over all possible pairs of soldiers and count those having difference of their heights less than or equal to d.Problem BReplace all occurrences of '--' with '2', '-.' with '1' and '.' with '0'.Initially, there was some problem with the test cases but was rectified soon.Problem CI won't be discussing my approach to this problem as my solution was hacked :( and I haven't tried another approach yet.Earlier I thought that my code failed because I was using int for storing answer,but later found that its giving WA after changing it to long.Problem DSimple approach was to start finding stars in order of their indexes.For this, first try for stars with smaller radius, then for top and finally for left.Following code may explain it further.int radius, x, y;for(radius=1; k>0 && radius<=150;++radius) for(x=radius; k>0 && x < N-r;++x) for(y=radius; k>0 && y < N-r;++y) if(StarAt(x,y,radius)) k--;if(k==0) //display start at x,y,radiuselse //display -1Problem EHaven't yet solved this problem too. Will be updating soon.This was my second contest at Codeforces. I was able to solve more problems this time and enter div 1, so enjoyed it :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/720",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1156
        },
        {
          "title": "Beta Round 32 - Codeforces",
          "content": "Problem A is quite straight-forward. You can simply enumerate all pairs using two for loops since N is not greater than 1000. Or you can sort the list and for every Ai, find the first Aj such that Aj-Ai>d in the range [i+1,N] using binary search.Problem B doesn't need an array at all. You can consume a single character at a time using getchar and then output a '0' if the character is '.' or consume another character to determine whether to output '1' or '2' otherwise.Problem D requires you to scan the map multiple times with increasing radii.Problem C is a little tricky. Two cells are reachable from each other if and only if their horizontal or vertical distance is exactly S if they are on the same row or column, which is identical to the property that their indexes of one dimension is the same while those of the other are congruent modulo S. So you are to count the number of remainders modulo S whose occurrence is more frequent than others, which equals N%S when S divides N or N when not for rows. The number of such occurrences is the ceiling of N/S, the smallest integer no smaller than N/S. Multiplying the product of these two numbers for rows and that of the other two for columns together gives the answer.I failed the test of this problem for a silly typing error.I will write solutions for Problem E after I solve it. My knowledge and skills of computing geometry was poor, so I didn't have enough time coding during the contest.This is the first time I participated in the contest, for previous contests were always at midnight.Really enjoy it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/715",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1569
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "1000000 1000000 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #32 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "Answer is 1000000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/714",
          "author": "jiangly"
        },
        {
          "title": "Beta Round 32 - Codeforces - Code 1",
          "code": "I will write solutions for Problem E after I solve it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/715",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -10000;\nconst int MAX_COORD = 10000;\n\nbool pointOnSegment(int x1, int y1, int x2, int y2, int x, int y) {\n    // Check if point (x,y) is colinear and lies on segment [(x1,y1), (x2,y2)]\n    // Compute cross product\n    long long cross = 1LL * (x2 - x1) * (y - y1) - 1LL * (x - x1) * (y2 - y1);\n    if (cross != 0)\n        return false; // Not colinear\n    // Now check if x lies between x1 and x2\n    int minX = min(x1, x2);\n    int maxX = max(x1, x2);\n    int minY = min(y1, y2);\n    int maxY = max(y1, y2);\n    return x >= minX && x <= maxX && y >= minY && y <= maxY;\n}\n\nbool segmentsIntersect(int x1, int y1, int x2, int y2,\n                       int x3, int y3, int x4, int y4) {\n    // Returns true if segments (x1,y1)-(x2,y2) and (x3,y3)-(x4,y4) intersect (i.e. have at least one point in common)\n    auto ccw = [](int ax, int ay, int bx, int by, int cx, int cy) -> int {\n        long long val = 1LL * (bx - ax) * (cy - ay) - 1LL * (cx - ax) * (by - ay);\n        if (val > 0) return +1;\n        if (val < 0) return -1;\n        return 0;\n    };\n    int d1 = ccw(x1, y1, x2, y2, x3, y3);\n    int d2 = ccw(x1, y1, x2, y2, x4, y4);\n    int d3 = ccw(x3, y3, x4, y4, x1, y1);\n    int d4 = ccw(x3, y3, x4, y4, x2, y2);\n\n    if (d1 * d2 < 0 && d3 * d4 < 0)\n        return true; // Intersection occurs\n\n    // Special cases when points are colinear\n    if (d1 == 0 && pointOnSegment(x1, y1, x2, y2, x3, y3)) return true;\n    if (d2 == 0 && pointOnSegment(x1, y1, x2, y2, x4, y4)) return true;\n    if (d3 == 0 && pointOnSegment(x3, y3, x4, y4, x1, y1)) return true;\n    if (d4 == 0 && pointOnSegment(x3, y3, x4, y4, x2, y2)) return true;\n\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read Victor's coordinates\n    int xv = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yv = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Read Peter's coordinates\n    int xp = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yp = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Read wall endpoints\n    int xw1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yw1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int xw2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yw2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Ensure wall segment is not degenerated\n    ensuref(!(xw1 == xw2 && yw1 == yw2), \"Wall segment endpoints coincide\");\n\n    // Read mirror endpoints\n    int xm1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int ym1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int xm2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int ym2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Ensure mirror segment is not degenerated\n    ensuref(!(xm1 == xm2 && ym1 == ym2), \"Mirror segment endpoints coincide\");\n\n    // Ensure Victor and Peter are not at the same point\n    ensuref(!(xv == xp && yv == yp), \"Victor and Peter should not be at the same point\");\n\n    // Ensure Victor is not on any segments\n    ensuref(!pointOnSegment(xw1, yw1, xw2, yw2, xv, yv), \"Victor should not be on wall segment\");\n    ensuref(!pointOnSegment(xm1, ym1, xm2, ym2, xv, yv), \"Victor should not be on mirror segment\");\n\n    // Ensure Peter is not on any segments\n    ensuref(!pointOnSegment(xw1, yw1, xw2, yw2, xp, yp), \"Peter should not be on wall segment\");\n    ensuref(!pointOnSegment(xm1, ym1, xm2, ym2, xp, yp), \"Peter should not be on mirror segment\");\n\n    // Ensure wall and mirror segments do not have common points\n    ensuref(!segmentsIntersect(xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2), \"Wall and mirror segments should not intersect\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -10000;\nconst int MAX_COORD = 10000;\n\nbool pointOnSegment(int x1, int y1, int x2, int y2, int x, int y) {\n    // Check if point (x,y) is colinear and lies on segment [(x1,y1), (x2,y2)]\n    // Compute cross product\n    long long cross = 1LL * (x2 - x1) * (y - y1) - 1LL * (x - x1) * (y2 - y1);\n    if (cross != 0)\n        return false; // Not colinear\n    // Now check if x lies between x1 and x2\n    int minX = min(x1, x2);\n    int maxX = max(x1, x2);\n    int minY = min(y1, y2);\n    int maxY = max(y1, y2);\n    return x >= minX && x <= maxX && y >= minY && y <= maxY;\n}\n\nbool segmentsIntersect(int x1, int y1, int x2, int y2,\n                       int x3, int y3, int x4, int y4) {\n    // Returns true if segments (x1,y1)-(x2,y2) and (x3,y3)-(x4,y4) intersect (i.e. have at least one point in common)\n    auto ccw = [](int ax, int ay, int bx, int by, int cx, int cy) -> int {\n        long long val = 1LL * (bx - ax) * (cy - ay) - 1LL * (cx - ax) * (by - ay);\n        if (val > 0) return +1;\n        if (val < 0) return -1;\n        return 0;\n    };\n    int d1 = ccw(x1, y1, x2, y2, x3, y3);\n    int d2 = ccw(x1, y1, x2, y2, x4, y4);\n    int d3 = ccw(x3, y3, x4, y4, x1, y1);\n    int d4 = ccw(x3, y3, x4, y4, x2, y2);\n\n    if (d1 * d2 < 0 && d3 * d4 < 0)\n        return true; // Intersection occurs\n\n    // Special cases when points are colinear\n    if (d1 == 0 && pointOnSegment(x1, y1, x2, y2, x3, y3)) return true;\n    if (d2 == 0 && pointOnSegment(x1, y1, x2, y2, x4, y4)) return true;\n    if (d3 == 0 && pointOnSegment(x3, y3, x4, y4, x1, y1)) return true;\n    if (d4 == 0 && pointOnSegment(x3, y3, x4, y4, x2, y2)) return true;\n\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read Victor's coordinates\n    int xv = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yv = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Read Peter's coordinates\n    int xp = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yp = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Read wall endpoints\n    int xw1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yw1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int xw2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yw2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Ensure wall segment is not degenerated\n    ensuref(!(xw1 == xw2 && yw1 == yw2), \"Wall segment endpoints coincide\");\n\n    // Read mirror endpoints\n    int xm1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int ym1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int xm2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int ym2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Ensure mirror segment is not degenerated\n    ensuref(!(xm1 == xm2 && ym1 == ym2), \"Mirror segment endpoints coincide\");\n\n    // Ensure Victor and Peter are not at the same point\n    ensuref(!(xv == xp && yv == yp), \"Victor and Peter should not be at the same point\");\n\n    // Ensure Victor is not on any segments\n    ensuref(!pointOnSegment(xw1, yw1, xw2, yw2, xv, yv), \"Victor should not be on wall segment\");\n    ensuref(!pointOnSegment(xm1, ym1, xm2, ym2, xv, yv), \"Victor should not be on mirror segment\");\n\n    // Ensure Peter is not on any segments\n    ensuref(!pointOnSegment(xw1, yw1, xw2, yw2, xp, yp), \"Peter should not be on wall segment\");\n    ensuref(!pointOnSegment(xm1, ym1, xm2, ym2, xp, yp), \"Peter should not be on mirror segment\");\n\n    // Ensure wall and mirror segments do not have common points\n    ensuref(!segmentsIntersect(xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2), \"Wall and mirror segments should not intersect\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -10000;\nconst int MAX_COORD = 10000;\n\nbool pointOnSegment(int x1, int y1, int x2, int y2, int x, int y) {\n    // Check if point (x,y) is colinear and lies on segment [(x1,y1), (x2,y2)]\n    // Compute cross product\n    long long cross = 1LL * (x2 - x1) * (y - y1) - 1LL * (x - x1) * (y2 - y1);\n    if (cross != 0)\n        return false; // Not colinear\n    // Now check if x lies between x1 and x2\n    int minX = min(x1, x2);\n    int maxX = max(x1, x2);\n    int minY = min(y1, y2);\n    int maxY = max(y1, y2);\n    return x >= minX && x <= maxX && y >= minY && y <= maxY;\n}\n\nbool segmentsIntersect(int x1, int y1, int x2, int y2,\n                       int x3, int y3, int x4, int y4) {\n    // Returns true if segments (x1,y1)-(x2,y2) and (x3,y3)-(x4,y4) intersect (i.e. have at least one point in common)\n    auto ccw = [](int ax, int ay, int bx, int by, int cx, int cy) -> int {\n        long long val = 1LL * (bx - ax) * (cy - ay) - 1LL * (cx - ax) * (by - ay);\n        if (val > 0) return +1;\n        if (val < 0) return -1;\n        return 0;\n    };\n    int d1 = ccw(x1, y1, x2, y2, x3, y3);\n    int d2 = ccw(x1, y1, x2, y2, x4, y4);\n    int d3 = ccw(x3, y3, x4, y4, x1, y1);\n    int d4 = ccw(x3, y3, x4, y4, x2, y2);\n\n    if (d1 * d2 < 0 && d3 * d4 < 0)\n        return true; // Intersection occurs\n\n    // Special cases when points are colinear\n    if (d1 == 0 && pointOnSegment(x1, y1, x2, y2, x3, y3)) return true;\n    if (d2 == 0 && pointOnSegment(x1, y1, x2, y2, x4, y4)) return true;\n    if (d3 == 0 && pointOnSegment(x3, y3, x4, y4, x1, y1)) return true;\n    if (d4 == 0 && pointOnSegment(x3, y3, x4, y4, x2, y2)) return true;\n\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read Victor's coordinates\n    int xv = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yv = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Read Peter's coordinates\n    int xp = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yp = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Read wall endpoints\n    int xw1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yw1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int xw2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int yw2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Ensure wall segment is not degenerated\n    ensuref(!(xw1 == xw2 && yw1 == yw2), \"Wall segment endpoints coincide\");\n\n    // Read mirror endpoints\n    int xm1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int ym1 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int xm2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readSpace();\n    int ym2 = inf.readInt(MIN_COORD, MAX_COORD);\n    inf.readEoln();\n\n    // Ensure mirror segment is not degenerated\n    ensuref(!(xm1 == xm2 && ym1 == ym2), \"Mirror segment endpoints coincide\");\n\n    // Ensure Victor and Peter are not at the same point\n    ensuref(!(xv == xp && yv == yp), \"Victor and Peter should not be at the same point\");\n\n    // Ensure Victor is not on any segments\n    ensuref(!pointOnSegment(xw1, yw1, xw2, yw2, xv, yv), \"Victor should not be on wall segment\");\n    ensuref(!pointOnSegment(xm1, ym1, xm2, ym2, xv, yv), \"Victor should not be on mirror segment\");\n\n    // Ensure Peter is not on any segments\n    ensuref(!pointOnSegment(xw1, yw1, xw2, yw2, xp, yp), \"Peter should not be on wall segment\");\n    ensuref(!pointOnSegment(xm1, ym1, xm2, ym2, xp, yp), \"Peter should not be on mirror segment\");\n\n    // Ensure wall and mirror segments do not have common points\n    ensuref(!segmentsIntersect(xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2), \"Wall and mirror segments should not intersect\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    string type = opt<string>(\"type\", \"random\");\n    int max_coord = opt<int>(\"max_coord\", 10000);\n\n    // Coordinates for Victor (xv, yv) and Peter (xp, yp)\n    int xv, yv, xp, yp;\n\n    // Coordinates for wall: (xw1, yw1), (xw2, yw2)\n    int xw1, yw1, xw2, yw2;\n\n    // Coordinates for mirror: (xm1, ym1), (xm2, ym2)\n    int xm1, ym1, xm2, ym2;\n\n    // To store used points to ensure Victor and Peter are not on any segments\n    vector<pair<int, int>> used_points;\n\n    // Function to generate a random point within bounds\n    auto gen_point = [&](vector<pair<int, int>>& exclude_points) {\n        int x, y;\n        do {\n            x = rnd.next(-max_coord, max_coord);\n            y = rnd.next(-max_coord, max_coord);\n        } while (find(exclude_points.begin(), exclude_points.end(), make_pair(x, y)) != exclude_points.end());\n        exclude_points.push_back(make_pair(x, y));\n        return make_pair(x, y);\n    };\n\n    // Function to generate a random segment (non-degenerate)\n    auto gen_segment = [&](vector<pair<int, int>>& exclude_points) {\n        pair<int, int> p1, p2;\n        do {\n            p1 = gen_point(exclude_points);\n            p2 = gen_point(exclude_points);\n        } while (p1 == p2); // Ensure segment is not degenerate\n        return make_pair(p1, p2);\n    };\n\n    // Function to check if two segments have common points\n    auto segments_share_point = [&](pair<pair<int, int>, pair<int, int>> seg1, pair<pair<int, int>, pair<int, int>> seg2) {\n        return\n            seg1.first == seg2.first ||\n            seg1.first == seg2.second ||\n            seg1.second == seg2.first ||\n            seg1.second == seg2.second;\n    };\n\n    // Now generate test case based on type\n    if (type == \"direct\") {\n        // Victor and Peter can see each other directly (no obstacles)\n        // Generate Victor and Peter\n        xv = rnd.next(-max_coord, max_coord);\n        yv = rnd.next(-max_coord, max_coord);\n        used_points.push_back({xv, yv});\n\n        do {\n            xp = rnd.next(-max_coord, max_coord);\n            yp = rnd.next(-max_coord, max_coord);\n        } while ((xp == xv && yp == yv));\n        used_points.push_back({xp, yp});\n\n        // Generate wall and mirror segments far from the line of sight\n        auto wall = gen_segment(used_points);\n        xw1 = wall.first.first;\n        yw1 = wall.first.second;\n        xw2 = wall.second.first;\n        yw2 = wall.second.second;\n\n        auto mirror = gen_segment(used_points);\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n\n    } else if (type == \"blocked\") {\n        // Victor and Peter cannot see each other directly or via mirror because the wall blocks the line of sight\n\n        // Generate Victor and Peter\n        xv = rnd.next(-max_coord/2, -max_coord/4);\n        yv = rnd.next(-max_coord/2, -max_coord/4);\n        used_points.push_back({xv, yv});\n\n        xp = rnd.next(max_coord/4, max_coord/2);\n        yp = rnd.next(max_coord/4, max_coord/2);\n        used_points.push_back({xp, yp});\n\n        // Place wall to block the line of sight\n        xw1 = xv + (xp - xv)/2 + (yp - yv);\n        yw1 = yv + (yp - yv)/2 - (xp - xv);\n        xw2 = xv + (xp - xv)/2 - (yp - yv);\n        yw2 = yv + (yp - yv)/2 + (xp - xv);\n\n        // Ensure coordinates are within bounds and wall is not degenerate\n        xw1 = max(-max_coord, min(max_coord, xw1));\n        yw1 = max(-max_coord, min(max_coord, yw1));\n        xw2 = max(-max_coord, min(max_coord, xw2));\n        yw2 = max(-max_coord, min(max_coord, yw2));\n        if (xw1 == xw2 && yw1 == yw2) {\n            xw2 += 1;\n        }\n\n        // Generate mirror somewhere else\n        auto mirror = gen_segment(used_points);\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n\n    } else if (type == \"mirror\") {\n        // Victor and Peter cannot see each other directly, but can see each other via mirror reflection\n\n        // Victor at (0, 0), Peter at (L, 0)\n        int L = rnd.next(max_coord/2, max_coord - 1);\n        xv = 0;\n        yv = 0;\n        xp = L;\n        yp = 0;\n        used_points.push_back({xv, yv});\n        used_points.push_back({xp, yp});\n\n        // Wall blocking direct sight\n        xw1 = L / 2;\n        yw1 = -max_coord;\n        xw2 = L / 2;\n        yw2 = max_coord;\n\n        // Mirror placed at 45 degrees between Victor and Peter\n        int D = rnd.next(1, L / 2);\n        xm1 = D;\n        ym1 = 0;\n        xm2 = 0;\n        ym2 = D;\n\n    } else if (type == \"nomirror\") {\n        // Victor and Peter cannot see each other directly, and can't see via mirror\n\n        // Victor at (0, 0), Peter at (L, 0)\n        int L = rnd.next(max_coord/2, max_coord - 1);\n        xv = 0;\n        yv = 0;\n        xp = L;\n        yp = 0;\n        used_points.push_back({xv, yv});\n        used_points.push_back({xp, yp});\n\n        // Wall blocking direct sight\n        xw1 = L / 2;\n        yw1 = -max_coord;\n        xw2 = L / 2;\n        yw2 = max_coord;\n\n        // Mirror placed away from possible reflection\n        xm1 = -max_coord;\n        ym1 = -max_coord;\n        xm2 = -max_coord + 1;\n        ym2 = max_coord;\n\n    } else if (type == \"edge\") {\n        // Edge cases: Victor or Peter very close to wall or mirror\n\n        // Victor at (0, 0), wall at x = 1\n        xv = 0;\n        yv = 0;\n        used_points.push_back({xv, yv});\n\n        xp = rnd.next(2, max_coord);\n        yp = rnd.next(-max_coord, max_coord);\n        used_points.push_back({xp, yp});\n\n        // Wall at x = 1\n        xw1 = 1;\n        yw1 = -max_coord;\n        xw2 = 1;\n        yw2 = max_coord;\n\n        // Mirror somewhere else\n        auto mirror = gen_segment(used_points);\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n\n    } else { // Random\n        // Generate random valid test case\n\n        // Generate Victor and Peter\n        xv = rnd.next(-max_coord, max_coord);\n        yv = rnd.next(-max_coord, max_coord);\n        used_points.push_back({xv, yv});\n\n        do {\n            xp = rnd.next(-max_coord, max_coord);\n            yp = rnd.next(-max_coord, max_coord);\n        } while ((xp == xv && yp == yv));\n        used_points.push_back({xp, yp});\n\n        // Generate wall and mirror segments ensuring they do not degenerate and do not share points\n        pair<pair<int, int>, pair<int, int>> wall;\n        pair<pair<int, int>, pair<int, int>> mirror;\n\n        do {\n            wall = gen_segment(used_points);\n            mirror = gen_segment(used_points);\n        } while (segments_share_point(wall, mirror));\n\n        xw1 = wall.first.first;\n        yw1 = wall.first.second;\n        xw2 = wall.second.first;\n        yw2 = wall.second.second;\n\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", xv, yv);\n    printf(\"%d %d\\n\", xp, yp);\n    printf(\"%d %d %d %d\\n\", xw1, yw1, xw2, yw2);\n    printf(\"%d %d %d %d\\n\", xm1, ym1, xm2, ym2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    string type = opt<string>(\"type\", \"random\");\n    int max_coord = opt<int>(\"max_coord\", 10000);\n\n    // Coordinates for Victor (xv, yv) and Peter (xp, yp)\n    int xv, yv, xp, yp;\n\n    // Coordinates for wall: (xw1, yw1), (xw2, yw2)\n    int xw1, yw1, xw2, yw2;\n\n    // Coordinates for mirror: (xm1, ym1), (xm2, ym2)\n    int xm1, ym1, xm2, ym2;\n\n    // To store used points to ensure Victor and Peter are not on any segments\n    vector<pair<int, int>> used_points;\n\n    // Function to generate a random point within bounds\n    auto gen_point = [&](vector<pair<int, int>>& exclude_points) {\n        int x, y;\n        do {\n            x = rnd.next(-max_coord, max_coord);\n            y = rnd.next(-max_coord, max_coord);\n        } while (find(exclude_points.begin(), exclude_points.end(), make_pair(x, y)) != exclude_points.end());\n        exclude_points.push_back(make_pair(x, y));\n        return make_pair(x, y);\n    };\n\n    // Function to generate a random segment (non-degenerate)\n    auto gen_segment = [&](vector<pair<int, int>>& exclude_points) {\n        pair<int, int> p1, p2;\n        do {\n            p1 = gen_point(exclude_points);\n            p2 = gen_point(exclude_points);\n        } while (p1 == p2); // Ensure segment is not degenerate\n        return make_pair(p1, p2);\n    };\n\n    // Function to check if two segments have common points\n    auto segments_share_point = [&](pair<pair<int, int>, pair<int, int>> seg1, pair<pair<int, int>, pair<int, int>> seg2) {\n        return\n            seg1.first == seg2.first ||\n            seg1.first == seg2.second ||\n            seg1.second == seg2.first ||\n            seg1.second == seg2.second;\n    };\n\n    // Now generate test case based on type\n    if (type == \"direct\") {\n        // Victor and Peter can see each other directly (no obstacles)\n        // Generate Victor and Peter\n        xv = rnd.next(-max_coord, max_coord);\n        yv = rnd.next(-max_coord, max_coord);\n        used_points.push_back({xv, yv});\n\n        do {\n            xp = rnd.next(-max_coord, max_coord);\n            yp = rnd.next(-max_coord, max_coord);\n        } while ((xp == xv && yp == yv));\n        used_points.push_back({xp, yp});\n\n        // Generate wall and mirror segments far from the line of sight\n        auto wall = gen_segment(used_points);\n        xw1 = wall.first.first;\n        yw1 = wall.first.second;\n        xw2 = wall.second.first;\n        yw2 = wall.second.second;\n\n        auto mirror = gen_segment(used_points);\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n\n    } else if (type == \"blocked\") {\n        // Victor and Peter cannot see each other directly or via mirror because the wall blocks the line of sight\n\n        // Generate Victor and Peter\n        xv = rnd.next(-max_coord/2, -max_coord/4);\n        yv = rnd.next(-max_coord/2, -max_coord/4);\n        used_points.push_back({xv, yv});\n\n        xp = rnd.next(max_coord/4, max_coord/2);\n        yp = rnd.next(max_coord/4, max_coord/2);\n        used_points.push_back({xp, yp});\n\n        // Place wall to block the line of sight\n        xw1 = xv + (xp - xv)/2 + (yp - yv);\n        yw1 = yv + (yp - yv)/2 - (xp - xv);\n        xw2 = xv + (xp - xv)/2 - (yp - yv);\n        yw2 = yv + (yp - yv)/2 + (xp - xv);\n\n        // Ensure coordinates are within bounds and wall is not degenerate\n        xw1 = max(-max_coord, min(max_coord, xw1));\n        yw1 = max(-max_coord, min(max_coord, yw1));\n        xw2 = max(-max_coord, min(max_coord, xw2));\n        yw2 = max(-max_coord, min(max_coord, yw2));\n        if (xw1 == xw2 && yw1 == yw2) {\n            xw2 += 1;\n        }\n\n        // Generate mirror somewhere else\n        auto mirror = gen_segment(used_points);\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n\n    } else if (type == \"mirror\") {\n        // Victor and Peter cannot see each other directly, but can see each other via mirror reflection\n\n        // Victor at (0, 0), Peter at (L, 0)\n        int L = rnd.next(max_coord/2, max_coord - 1);\n        xv = 0;\n        yv = 0;\n        xp = L;\n        yp = 0;\n        used_points.push_back({xv, yv});\n        used_points.push_back({xp, yp});\n\n        // Wall blocking direct sight\n        xw1 = L / 2;\n        yw1 = -max_coord;\n        xw2 = L / 2;\n        yw2 = max_coord;\n\n        // Mirror placed at 45 degrees between Victor and Peter\n        int D = rnd.next(1, L / 2);\n        xm1 = D;\n        ym1 = 0;\n        xm2 = 0;\n        ym2 = D;\n\n    } else if (type == \"nomirror\") {\n        // Victor and Peter cannot see each other directly, and can't see via mirror\n\n        // Victor at (0, 0), Peter at (L, 0)\n        int L = rnd.next(max_coord/2, max_coord - 1);\n        xv = 0;\n        yv = 0;\n        xp = L;\n        yp = 0;\n        used_points.push_back({xv, yv});\n        used_points.push_back({xp, yp});\n\n        // Wall blocking direct sight\n        xw1 = L / 2;\n        yw1 = -max_coord;\n        xw2 = L / 2;\n        yw2 = max_coord;\n\n        // Mirror placed away from possible reflection\n        xm1 = -max_coord;\n        ym1 = -max_coord;\n        xm2 = -max_coord + 1;\n        ym2 = max_coord;\n\n    } else if (type == \"edge\") {\n        // Edge cases: Victor or Peter very close to wall or mirror\n\n        // Victor at (0, 0), wall at x = 1\n        xv = 0;\n        yv = 0;\n        used_points.push_back({xv, yv});\n\n        xp = rnd.next(2, max_coord);\n        yp = rnd.next(-max_coord, max_coord);\n        used_points.push_back({xp, yp});\n\n        // Wall at x = 1\n        xw1 = 1;\n        yw1 = -max_coord;\n        xw2 = 1;\n        yw2 = max_coord;\n\n        // Mirror somewhere else\n        auto mirror = gen_segment(used_points);\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n\n    } else { // Random\n        // Generate random valid test case\n\n        // Generate Victor and Peter\n        xv = rnd.next(-max_coord, max_coord);\n        yv = rnd.next(-max_coord, max_coord);\n        used_points.push_back({xv, yv});\n\n        do {\n            xp = rnd.next(-max_coord, max_coord);\n            yp = rnd.next(-max_coord, max_coord);\n        } while ((xp == xv && yp == yv));\n        used_points.push_back({xp, yp});\n\n        // Generate wall and mirror segments ensuring they do not degenerate and do not share points\n        pair<pair<int, int>, pair<int, int>> wall;\n        pair<pair<int, int>, pair<int, int>> mirror;\n\n        do {\n            wall = gen_segment(used_points);\n            mirror = gen_segment(used_points);\n        } while (segments_share_point(wall, mirror));\n\n        xw1 = wall.first.first;\n        yw1 = wall.first.second;\n        xw2 = wall.second.first;\n        yw2 = wall.second.second;\n\n        xm1 = mirror.first.first;\n        ym1 = mirror.first.second;\n        xm2 = mirror.second.first;\n        ym2 = mirror.second.second;\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", xv, yv);\n    printf(\"%d %d\\n\", xp, yp);\n    printf(\"%d %d %d %d\\n\", xw1, yw1, xw2, yw2);\n    printf(\"%d %d %d %d\\n\", xm1, ym1, xm2, ym2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type direct -max_coord 10\n./gen -type direct -max_coord 100\n./gen -type direct -max_coord 10000\n\n./gen -type blocked -max_coord 10\n./gen -type blocked -max_coord 100\n./gen -type blocked -max_coord 10000\n\n./gen -type mirror -max_coord 10\n./gen -type mirror -max_coord 100\n./gen -type mirror -max_coord 10000\n\n./gen -type nomirror -max_coord 10\n./gen -type nomirror -max_coord 100\n./gen -type nomirror -max_coord 10000\n\n./gen -type edge -max_coord 10\n./gen -type edge -max_coord 100\n./gen -type edge -max_coord 10000\n\n# Generate multiple random test cases with small coordinates\nfor i in {1..10}; do\n    ./gen -type random -max_coord 10\ndone\n\n# Generate multiple random test cases with large coordinates\nfor i in {1..10}; do\n    ./gen -type random -max_coord 10000\ndone\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:48.471580",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "320/A",
      "title": "A. Magic Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n, (1 ≤ n ≤ 109). This number doesn't contain leading zeros.",
      "output_spec": "OutputPrint \"YES\" if n is a magic number or print \"NO\" if it's not.",
      "sample_tests": "ExamplesInputCopy114114OutputCopyYESInputCopy1111OutputCopyYESInputCopy441231OutputCopyNO",
      "description": "A. Magic Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n, (1 ≤ n ≤ 109). This number doesn't contain leading zeros.\n\nOutputPrint \"YES\" if n is a magic number or print \"NO\" if it's not.\n\nInputCopy114114OutputCopyYESInputCopy1111OutputCopyYESInputCopy441231OutputCopyNO\n\nInputCopy114114\n\nOutputCopyYES\n\nInputCopy1111\n\nOutputCopyYES\n\nInputCopy441231\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Hello, Codeforces! :-{DAs two important events IOI and ACM ICPC are coming soon, me and my friends as the Iranian IOI team decided to prepare a gift for all the Codeforces users who'll soon participate in one of these events, and also everybody else. :)This round authored by me (havaliza), dani1373 and keivan with help from fab. I want to thank all the Codeforces team for their kind and great effort to maintain this website.Hope you enjoy solving the problems as much as we're enjoying preparing them! ^.^Update 1. The score distribution for Div. 1 is 500-1000-1500-2500-2500 and for Div. 2 its regular.Update 2. Special thanks to Aksenov239 who helped us so much to prepare this round.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 746
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 320\\s*A"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    long long n = atoll(s.c_str());\n    ensuref(1 <= n && n <= 1000000000, \"n must be between 1 and 1e9, but found n = %lld\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    long long n = atoll(s.c_str());\n    ensuref(1 <= n && n <= 1000000000, \"n must be between 1 and 1e9, but found n = %lld\", n);\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    long long n = atoll(s.c_str());\n    ensuref(1 <= n && n <= 1000000000, \"n must be between 1 and 1e9, but found n = %lld\", n);\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nmax = opt<int>(\"nmax\", 1000000000);\n    string type = opt<string>(\"type\", \"magic\");\n\n    int n;\n    if (type == \"magic\") {\n        // Generate a magic number n ≤ nmax\n        vector<string> tokens = {\"1\", \"14\", \"144\"};\n\n        string n_str = \"\";\n        while (n_str.length() < 9) {  // Max 9 digits\n            // Choose a random token\n            string token = tokens[rnd.next(0, 2)];\n            // Tentative new n_str\n            string new_n_str = n_str + token;\n            if (new_n_str.length() > 9)\n                break;\n            long long n_ll = stoll(new_n_str);\n            if (n_ll > nmax)\n                break;\n            n_str = new_n_str;\n        }\n        // If n_str is empty, use \"1\"\n        if (n_str.empty()) n_str = \"1\";\n        // Convert to n\n        n = stoi(n_str);\n    } else if (type == \"nonmagic\") {\n        // Generate a non-magic number n ≤ nmax\n        vector<string> tokens = {\"1\", \"14\", \"144\"};\n        string n_str = \"\";\n        while (n_str.length() < 9) {\n            // Choose a random token\n            string token = tokens[rnd.next(0, 2)];\n            string new_n_str = n_str + token;\n            if (new_n_str.length() > 9)\n                break;\n            long long n_ll = stoll(new_n_str);\n            if (n_ll > nmax)\n                break;\n            n_str = new_n_str;\n        }\n        // Now, insert an invalid digit at a random position\n        if (!n_str.empty()) {\n            string invalidDigits = \"02356789\";\n            int pos = rnd.next(0, (int)n_str.length() - 1);\n            char orig_digit = n_str[pos];\n            // Replace with an invalid digit\n            char new_digit = invalidDigits[rnd.next(0, (int)invalidDigits.length() - 1)];\n            n_str[pos] = new_digit;\n        } else {\n            n_str = \"2\";\n        }\n        // Check if the modified n_str is ≤ nmax\n        long long n_ll = stoll(n_str);\n        if (n_ll > nmax) {\n            // Reduce n_ll\n            n_ll = nmax;\n            n_str = to_string(n_ll);\n        }\n        n = stoi(n_str);\n    } else if (type == \"edge\") {\n        // Generate an edge case n\n        vector<int> edge_cases = {1, 14, 144, 10, 100, 999999999, 1000000000};\n        n = edge_cases[rnd.next(0, (int)edge_cases.size() - 1)];\n        // Ensure n ≥ 1 and n ≤ nmax\n        if (n < 1) n = 1;\n        if (n > nmax) n = nmax;\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nmax = opt<int>(\"nmax\", 1000000000);\n    string type = opt<string>(\"type\", \"magic\");\n\n    int n;\n    if (type == \"magic\") {\n        // Generate a magic number n ≤ nmax\n        vector<string> tokens = {\"1\", \"14\", \"144\"};\n\n        string n_str = \"\";\n        while (n_str.length() < 9) {  // Max 9 digits\n            // Choose a random token\n            string token = tokens[rnd.next(0, 2)];\n            // Tentative new n_str\n            string new_n_str = n_str + token;\n            if (new_n_str.length() > 9)\n                break;\n            long long n_ll = stoll(new_n_str);\n            if (n_ll > nmax)\n                break;\n            n_str = new_n_str;\n        }\n        // If n_str is empty, use \"1\"\n        if (n_str.empty()) n_str = \"1\";\n        // Convert to n\n        n = stoi(n_str);\n    } else if (type == \"nonmagic\") {\n        // Generate a non-magic number n ≤ nmax\n        vector<string> tokens = {\"1\", \"14\", \"144\"};\n        string n_str = \"\";\n        while (n_str.length() < 9) {\n            // Choose a random token\n            string token = tokens[rnd.next(0, 2)];\n            string new_n_str = n_str + token;\n            if (new_n_str.length() > 9)\n                break;\n            long long n_ll = stoll(new_n_str);\n            if (n_ll > nmax)\n                break;\n            n_str = new_n_str;\n        }\n        // Now, insert an invalid digit at a random position\n        if (!n_str.empty()) {\n            string invalidDigits = \"02356789\";\n            int pos = rnd.next(0, (int)n_str.length() - 1);\n            char orig_digit = n_str[pos];\n            // Replace with an invalid digit\n            char new_digit = invalidDigits[rnd.next(0, (int)invalidDigits.length() - 1)];\n            n_str[pos] = new_digit;\n        } else {\n            n_str = \"2\";\n        }\n        // Check if the modified n_str is ≤ nmax\n        long long n_ll = stoll(n_str);\n        if (n_ll > nmax) {\n            // Reduce n_ll\n            n_ll = nmax;\n            n_str = to_string(n_ll);\n        }\n        n = stoi(n_str);\n    } else if (type == \"edge\") {\n        // Generate an edge case n\n        vector<int> edge_cases = {1, 14, 144, 10, 100, 999999999, 1000000000};\n        n = edge_cases[rnd.next(0, (int)edge_cases.size() - 1)];\n        // Ensure n ≥ 1 and n ≤ nmax\n        if (n < 1) n = 1;\n        if (n > nmax) n = nmax;\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type magic -nmax 10\n./gen -type magic -nmax 100\n./gen -type magic -nmax 1000\n./gen -type magic -nmax 10000\n./gen -type magic -nmax 100000\n./gen -type magic -nmax 1000000\n./gen -type magic -nmax 10000000\n./gen -type magic -nmax 100000000\n./gen -type magic -nmax 1000000000\n\n./gen -type nonmagic -nmax 10\n./gen -type nonmagic -nmax 100\n./gen -type nonmagic -nmax 1000\n./gen -type nonmagic -nmax 10000\n./gen -type nonmagic -nmax 100000\n./gen -type nonmagic -nmax 1000000\n./gen -type nonmagic -nmax 10000000\n./gen -type nonmagic -nmax 100000000\n./gen -type nonmagic -nmax 1000000000\n\n./gen -type edge\n./gen -type edge -nmax 1000\n./gen -type edge -nmax 1000000\n./gen -type edge -nmax 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:50.173853",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "320/B",
      "title": "B. Пинг-Понг (упрощенная версия)",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 100), обозначающее количество запросов. Каждая из следующих строк содержит запрос в формате, описанном выше. Все числа во входных данных целые и не превосходят по модулю 109.Гарантируется, что все запросы корректные.",
      "output_spec": "Выходные данныеДля каждого запроса второго типа выведите «YES» или «NO» в отдельной строке в зависимости от ответа на вопрос.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 1 51 5 112 1 21 2 92 1 2Выходные данныеСкопироватьNOYES",
      "description": "B. Пинг-Понг (упрощенная версия)\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 100), обозначающее количество запросов. Каждая из следующих строк содержит запрос в формате, описанном выше. Все числа во входных данных целые и не превосходят по модулю 109.Гарантируется, что все запросы корректные.\n\nВходные данные\n\nВыходные данныеДля каждого запроса второго типа выведите «YES» или «NO» в отдельной строке в зависимости от ответа на вопрос.\n\nВыходные данные\n\nВходные данныеСкопировать51 1 51 5 112 1 21 2 92 1 2Выходные данныеСкопироватьNOYES\n\nВходные данныеСкопировать51 1 51 5 112 1 21 2 92 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNOYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Привет, Codeforces! :-{DПо случаю двух важных событий в мире спортивного программирования (IOI и ACM ICPC) я и мои друзья (команда Ирана на IOI) решили сделать подарок всем пользователям Codeforces, которые будут участвовать хотя бы в одном из этих двух соревнования, а также всем остальным. :)Этот раунд подготовил я (havaliza), dani1373 и keivan, также нам помогал fab. Я хочу поблагодарить всю команду Codeforces за их усилия в поддержании этого веб-сайта.Надеюсь вам понравится решать задачи так же, как нам понравилось их готовить! ^.^Update 1. Распределение баллов по задачам в Div. 1: 500-1000-1500-2500-2500, в Div. 2 распределение стандартное.Update 2. Большое спасибо пользователю Aksenov239, который очень много помогал нам в подготовке раунда.Update 3. Here is the editorial. To be completed soon :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 811
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 320\\s*B"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 30",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 31",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 32",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 33",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<pair<int, int>> intervals;\n\n    for (int i = 0; i < n; i++) {\n\n        int lineNum = i + 2;\n\n        int queryType = inf.readInt(1, 2, \"queryType\");\n\n        inf.readSpace();\n\n        if (queryType == 1) {\n\n            int x = inf.readInt(-1000000000, 1000000000, \"x\");\n\n            inf.readSpace();\n\n            int y = inf.readInt(-1000000000, 1000000000, \"y\");\n\n            inf.readEoln();\n\n            ensuref(x < y, \"Line %d: For query type 1, x (%d) must be less than y (%d)\", lineNum, x, y);\n\n            int64_t length = (int64_t)y - x;\n\n            for (auto &interval : intervals) {\n\n                int64_t prevLength = (int64_t)interval.second - interval.first;\n\n                ensuref(length > prevLength, \"Line %d: Length of new interval (%lld) is not strictly greater than previous interval length (%lld)\", lineNum, length, prevLength);\n\n            }\n\n            intervals.push_back({x, y});\n\n        } else {\n\n            // queryType == 2\n\n            ensuref(intervals.size() >= 1, \"Line %d: No intervals added before query type 2\", lineNum);\n\n            int a = inf.readInt(1, intervals.size(), \"a\");\n\n            inf.readSpace();\n\n            int b = inf.readInt(1, intervals.size(), \"b\");\n\n            inf.readEoln();\n\n            ensuref(a != b, \"Line %d: For query type 2, a (%d) must not equal b (%d)\", lineNum, a, b);\n\n        }\n\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<pair<int, int>> intervals;\n\n    for (int i = 0; i < n; i++) {\n\n        int lineNum = i + 2;\n\n        int queryType = inf.readInt(1, 2, \"queryType\");\n\n        inf.readSpace();\n\n        if (queryType == 1) {\n\n            int x = inf.readInt(-1000000000, 1000000000, \"x\");\n\n            inf.readSpace();\n\n            int y = inf.readInt(-1000000000, 1000000000, \"y\");\n\n            inf.readEoln();\n\n            ensuref(x < y, \"Line %d: For query type 1, x (%d) must be less than y (%d)\", lineNum, x, y);\n\n            int64_t length = (int64_t)y - x;\n\n            for (auto &interval : intervals) {\n\n                int64_t prevLength = (int64_t)interval.second - interval.first;\n\n                ensuref(length > prevLength, \"Line %d: Length of new interval (%lld) is not strictly greater than previous interval length (%lld)\", lineNum, length, prevLength);\n\n            }\n\n            intervals.push_back({x, y});\n\n        } else {\n\n            // queryType == 2\n\n            ensuref(intervals.size() >= 1, \"Line %d: No intervals added before query type 2\", lineNum);\n\n            int a = inf.readInt(1, intervals.size(), \"a\");\n\n            inf.readSpace();\n\n            int b = inf.readInt(1, intervals.size(), \"b\");\n\n            inf.readEoln();\n\n            ensuref(a != b, \"Line %d: For query type 2, a (%d) must not equal b (%d)\", lineNum, a, b);\n\n        }\n\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<pair<int, int>> intervals;\n\n    for (int i = 0; i < n; i++) {\n\n        int lineNum = i + 2;\n\n        int queryType = inf.readInt(1, 2, \"queryType\");\n\n        inf.readSpace();\n\n        if (queryType == 1) {\n\n            int x = inf.readInt(-1000000000, 1000000000, \"x\");\n\n            inf.readSpace();\n\n            int y = inf.readInt(-1000000000, 1000000000, \"y\");\n\n            inf.readEoln();\n\n            ensuref(x < y, \"Line %d: For query type 1, x (%d) must be less than y (%d)\", lineNum, x, y);\n\n            int64_t length = (int64_t)y - x;\n\n            for (auto &interval : intervals) {\n\n                int64_t prevLength = (int64_t)interval.second - interval.first;\n\n                ensuref(length > prevLength, \"Line %d: Length of new interval (%lld) is not strictly greater than previous interval length (%lld)\", lineNum, length, prevLength);\n\n            }\n\n            intervals.push_back({x, y});\n\n        } else {\n\n            // queryType == 2\n\n            ensuref(intervals.size() >= 1, \"Line %d: No intervals added before query type 2\", lineNum);\n\n            int a = inf.readInt(1, intervals.size(), \"a\");\n\n            inf.readSpace();\n\n            int b = inf.readInt(1, intervals.size(), \"b\");\n\n            inf.readEoln();\n\n            ensuref(a != b, \"Line %d: For query type 2, a (%d) must not equal b (%d)\", lineNum, a, b);\n\n        }\n\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces test data for the \"Intervals\" problem.\n\n  Problem constraints (summarized):\n    - We have n queries (1 <= n <= 100).\n    - Two types of queries:\n        1) \"1 x y\" (x < y): add a new interval (x, y). The new interval's length\n           must be strictly greater than all previously added intervals.\n        2) \"2 a b\" (a != b): ask whether there is a path from the a-th added interval\n           to the b-th added interval (1-based index of intervals).\n\n    - The intervals must appear in strictly increasing order of length.\n    - All numbers must fit in |value| <= 1e9.\n    - The queries must be valid; that is, when a type-2 query is asked, its\n      referenced intervals must already exist (a and b cannot exceed the number\n      of intervals so far).\n\n  Usage:\n    You can compile this code (with testlib.h in the same folder) into an executable \"gen\".\n    Then run something like:\n      ./gen -n 10 -type random\n    to produce 10 queries with a \"random\" distribution of intervals.\n  \n  Parameters from the command line:\n    -n <int> : total number of queries (1 <= n <= 100).\n    -type <string> : one of {random, chain, nested, separate},\n                     default is \"random\".\n  \n  The generator logic:\n    1) We parse \"n\" and \"type\".\n    2) We will output exactly n queries.\n    3) We track how many intervals have been added so far (countIntervals).\n    4) We track the largest length so far (maxLengthSoFar) to ensure\n       strictly increasing interval lengths.\n    5) Depending on \"type\", we generate intervals in a certain pattern:\n       - random   : intervals placed arbitrarily (within reason).\n       - chain    : each new interval partially overlaps the previous one,\n                    forming a \"chain\" of intervals.\n       - nested   : each new interval entirely contains all previous intervals\n                    (so it must be larger and \"around\" them).\n       - separate : each new interval does not overlap with any previous interval.\n    6) We occasionally produce type-2 queries to check connectivity between\n       existing intervals.\n    7) We ensure correctness: no type-2 query if fewer than 2 intervals exist;\n       also we reference distinct valid indices in type-2 queries.\n\n  We do NOT set the random seed in the code; testlib will handle it.\n*/\n\nstatic const int BOUND = 1000000000; // to ensure we stay within |value| <= 1e9\n\nint main(int argc, char* argv[]) {\n    // Register the generator. \"1\" means the generator version.\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments.\n    int n = opt<int>(\"n\"); \n    string genType = opt<string>(\"type\", \"random\"); \n\n    // We will store the queries in a vector of strings, then print them at the end.\n    // Each element is a single line representing one query (\"1 x y\" or \"2 a b\").\n    vector<string> queries;\n    queries.reserve(n);\n\n    // Keep track of how many intervals have been added so far.\n    int countIntervals = 0;\n    // Keep track of the largest length used so far, to ensure strictly increasing lengths.\n    long long maxLengthSoFar = 0;\n\n    // We'll define some utility lambdas to generate intervals in different patterns.\n    \n    // 1) RANDOM: picks random start in [-10^6, 10^6], picks random length from 1..50, but\n    //    ensures the total length is > maxLengthSoFar.\n    // 2) CHAIN: ensure each newly added interval partially overlaps the previous one.\n    // 3) NESTED: each new interval strictly bigger and contains all previous intervals.\n    // 4) SEPARATE: each new interval does not overlap with any of the existing intervals\n    //    (push them further on the number line).\n    \n    // We maintain data about all intervals for patterns 2, 3, 4 that need reference to\n    // previously added intervals. \n    // For random we don't need all intervals to do the next, but let's store them anyway.\n    vector<pair<long long, long long>> intervals; // store (start, end) of each added interval\n    \n    auto addIntervalRandom = [&](int idx) {\n        // We want length > maxLengthSoFar\n        // We'll pick an increment length from 1..50\n        long long length = maxLengthSoFar + rnd.next(1, 50);\n        // Random start in a moderate range so that start + length is within ±1e9\n        long long startRangeLow = -1000000; \n        long long startRangeHigh =  1000000;\n        // We need to ensure end <= 1e9 and start >= -1e9, so let's do a safe approach:\n        long long startCandidate = 0;\n        while (true) {\n            long long candidate = rnd.next(startRangeLow, startRangeHigh);\n            long long end = candidate + length;\n            if (abs(candidate) <= BOUND && abs(end) <= BOUND && candidate < end) {\n                startCandidate = candidate;\n                break;\n            }\n        }\n        long long s = startCandidate;\n        long long e = s + length;\n        \n        // Update\n        maxLengthSoFar = length;\n        intervals.push_back({s, e});\n        \n        // Output the query\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n    };\n    \n    auto addIntervalChain = [&](int idx) {\n        // If it's the very first interval, just pick any random valid interval.\n        if (countIntervals == 0) {\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // We want the new interval to partially overlap with the last one.\n        // Let the last interval be (L, R).\n        auto [Lprev, Rprev] = intervals.back();\n        long long length = maxLengthSoFar + rnd.next(1, 50);\n        long long overlapPoint = rnd.next(Lprev + 1, Rprev - 1); \n        // The above ensures that Lprev < overlapPoint < Rprev, so the chain overlap condition is fine\n        // as long as the new interval includes that point in its interior as well.\n        \n        // We'll pick a random shift around overlapPoint such that we get the correct length.\n        // length = end - start\n        // ensure overlapPoint is strictly inside (start, end).\n        // overlapPoint - start >= 1 and end - overlapPoint >= 1\n        // so let's pick: start = overlapPoint - x, end = overlapPoint + (length - x)\n        // for some x in [1, length-1].\n        long long x = rnd.next(1LL, length - 1);\n        long long s = overlapPoint - x;\n        long long e = s + length; // = overlapPoint - x + length\n        \n        // Check bounds\n        if (abs(s) > BOUND || abs(e) > BOUND || s >= e) {\n            // If it fails (e.g. out of bounds), just fallback to random approach.\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // Update\n        maxLengthSoFar = length;\n        intervals.push_back({s, e});\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n    };\n    \n    auto addIntervalNested = [&](int idx) {\n        // If no intervals yet, just do random.\n        if (countIntervals == 0) {\n            addIntervalRandom(idx);\n            return;\n        }\n        // We want the new interval to contain ALL existing intervals if possible.\n        // So let's find the min start and max end among all intervals.\n        long long curMin = LLONG_MAX;\n        long long curMax = LLONG_MIN;\n        for (auto &iv : intervals) {\n            curMin = min(curMin, iv.first);\n            curMax = max(curMax, iv.second);\n        }\n        \n        long long oldSpan = curMax - curMin; \n        long long newLength = maxLengthSoFar + rnd.next(1, 50); // strictly bigger than any so far\n        // We want to choose a new start <= curMin and new end >= curMax, so that\n        // the new interval strictly contains all existing intervals in its interior.\n        // Because we have newLength > oldSpan, we have some room.\n        \n        // Let new interval be (s, e) with e - s = newLength.\n        // We need s < curMin, e > curMax. \n        // Let's define a small margin on each side. We'll pick a margin on the left from [0..someRange].\n        // Then the right side is determined as s + newLength. \n        // We'll pick s in [curMin - (newLength - oldSpan), curMin], ensuring that e = s + newLength >= curMax.\n        \n        long long minS = curMin - (newLength - oldSpan);\n        long long maxS = curMin; \n        if (minS > maxS) {\n            // Edge case if oldSpan is huge. Fallback to random approach.\n            addIntervalRandom(idx);\n            return;\n        }\n        // clamp minS, maxS to keep it in bounds\n        minS = max(minS, - (long long)BOUND);\n        maxS = min(maxS,  (long long)BOUND);\n        if (minS > maxS) {\n            // fallback\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        long long s = rnd.next(minS, maxS);\n        long long e = s + newLength;\n        if (abs(e) > BOUND) {\n            // fallback\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // we have a valid nested interval now\n        maxLengthSoFar = newLength;\n        intervals.push_back({s, e});\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n    };\n    \n    auto addIntervalSeparate = [&](int idx) {\n        // If no intervals yet, just do random.\n        if (countIntervals == 0) {\n            addIntervalRandom(idx);\n            return;\n        }\n        // We want the new interval not to overlap with any existing interval.\n        // The easiest approach: place each new interval to the right of all existing intervals.\n        // We'll keep track of the maxRight so far, place a gap, then place the next interval.\n        static long long maxRightUsed = 0; \n        if (idx == 0) {\n            // for the very first interval (which is actually index=0 in queries, \n            //   but let's just do random, then set maxRightUsed).\n            addIntervalRandom(idx);\n            maxRightUsed = intervals.back().second; \n            return;\n        }\n        \n        // Now place the new one well to the right of 'maxRightUsed'.\n        long long newLength = maxLengthSoFar + rnd.next(1, 50);\n        long long s = maxRightUsed + rnd.next(1, 10); // put a random gap\n        long long e = s + newLength;\n        if (abs(s) > BOUND || abs(e) > BOUND || s >= e) {\n            // fallback\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // Update\n        maxLengthSoFar = newLength;\n        intervals.push_back({s, e});\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n        \n        // Update maxRightUsed\n        maxRightUsed = e;\n    };\n    \n    // Decide which \"addInterval\" function to use depending on the type\n    function<void(int)> addInterval;\n    if (genType == \"chain\") {\n        addInterval = addIntervalChain;\n    } else if (genType == \"nested\") {\n        addInterval = addIntervalNested;\n    } else if (genType == \"separate\") {\n        addInterval = addIntervalSeparate;\n    } else {\n        addInterval = addIntervalRandom; // default\n    }\n\n    // We'll produce exactly n queries.\n    // Strategy: \n    //  - We must produce at least 2 intervals in total (so that type-2 queries are possible).\n    //  - We won't produce a type-2 query unless there's at least 2 intervals to reference.\n    //  - We'll produce queries in a random pattern, but guarantee we end up with enough intervals \n    //    so that we don't get stuck.\n\n    // Let half of them (rounded up) be type-1 queries (so we have intervals).\n    // The rest can be type-2 queries, referencing random existing intervals.\n    // If n=1, we must produce exactly 1 query -> must be type-1.\n\n    int minIntervals = min(n, (n + 1) / 2); \n    // We plan to produce exactly \"minIntervals\" type-1 queries in total, spread out among the n.\n\n    // Keep track of how many type-1 queries we've emitted so far.\n    int usedType1 = 0;\n\n    for (int i = 0; i < n; i++) {\n        // If we haven't yet reached minIntervals for type-1, but we also have enough queries left\n        // such that we can still do some type-2, let's let coin toss decide.\n        bool canProduceType2 = (usedType1 >= 2); // need at least 2 intervals to produce type-2\n        bool stillNeedType1 = (usedType1 < minIntervals);\n\n        // If we still must produce more type-1 queries to meet the quota, or we can't produce type-2 yet, do type-1\n        // otherwise choose randomly.\n        bool doType1 = false;\n        if (!canProduceType2) {\n            // must do type-1\n            doType1 = true;\n        } else if (!stillNeedType1) {\n            // we've reached the required number of intervals, so we are free to produce type-2\n            // maybe produce type-2 with some probability\n            doType1 = (rnd.next(0, 1) == 0) ? false : true; \n        } else {\n            // we can do either type-1 or type-2, choose randomly\n            // but we do want to ensure we get enough intervals in the end\n            // We'll produce type-1 with probability 50%, type-2 with probability 50%\n            doType1 = (rnd.next(0, 1) == 0);\n        }\n\n        if (i == n - 1 && usedType1 < minIntervals) {\n            // We are at the last query but haven't reached the needed intervals yet => must do type-1\n            doType1 = true;\n        }\n\n        if (doType1) {\n            // produce a type-1 query\n            addInterval(usedType1);\n            usedType1++;\n        } else {\n            // produce a type-2 query\n            // We have countIntervals so far, pick two distinct intervals\n            int a = rnd.next(1, countIntervals);\n            int b = rnd.next(1, countIntervals);\n            while (b == a) {\n                b = rnd.next(1, countIntervals);\n            }\n            // add query \"2 a b\"\n            queries.push_back(\"2 \" + to_string(a) + \" \" + to_string(b));\n        }\n    }\n\n    // Finally, output all queries\n    // The first line: n\n    cout << n << \"\\n\";\n    for (auto &q : queries) {\n        cout << q << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces test data for the \"Intervals\" problem.\n\n  Problem constraints (summarized):\n    - We have n queries (1 <= n <= 100).\n    - Two types of queries:\n        1) \"1 x y\" (x < y): add a new interval (x, y). The new interval's length\n           must be strictly greater than all previously added intervals.\n        2) \"2 a b\" (a != b): ask whether there is a path from the a-th added interval\n           to the b-th added interval (1-based index of intervals).\n\n    - The intervals must appear in strictly increasing order of length.\n    - All numbers must fit in |value| <= 1e9.\n    - The queries must be valid; that is, when a type-2 query is asked, its\n      referenced intervals must already exist (a and b cannot exceed the number\n      of intervals so far).\n\n  Usage:\n    You can compile this code (with testlib.h in the same folder) into an executable \"gen\".\n    Then run something like:\n      ./gen -n 10 -type random\n    to produce 10 queries with a \"random\" distribution of intervals.\n  \n  Parameters from the command line:\n    -n <int> : total number of queries (1 <= n <= 100).\n    -type <string> : one of {random, chain, nested, separate},\n                     default is \"random\".\n  \n  The generator logic:\n    1) We parse \"n\" and \"type\".\n    2) We will output exactly n queries.\n    3) We track how many intervals have been added so far (countIntervals).\n    4) We track the largest length so far (maxLengthSoFar) to ensure\n       strictly increasing interval lengths.\n    5) Depending on \"type\", we generate intervals in a certain pattern:\n       - random   : intervals placed arbitrarily (within reason).\n       - chain    : each new interval partially overlaps the previous one,\n                    forming a \"chain\" of intervals.\n       - nested   : each new interval entirely contains all previous intervals\n                    (so it must be larger and \"around\" them).\n       - separate : each new interval does not overlap with any previous interval.\n    6) We occasionally produce type-2 queries to check connectivity between\n       existing intervals.\n    7) We ensure correctness: no type-2 query if fewer than 2 intervals exist;\n       also we reference distinct valid indices in type-2 queries.\n\n  We do NOT set the random seed in the code; testlib will handle it.\n*/\n\nstatic const int BOUND = 1000000000; // to ensure we stay within |value| <= 1e9\n\nint main(int argc, char* argv[]) {\n    // Register the generator. \"1\" means the generator version.\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments.\n    int n = opt<int>(\"n\"); \n    string genType = opt<string>(\"type\", \"random\"); \n\n    // We will store the queries in a vector of strings, then print them at the end.\n    // Each element is a single line representing one query (\"1 x y\" or \"2 a b\").\n    vector<string> queries;\n    queries.reserve(n);\n\n    // Keep track of how many intervals have been added so far.\n    int countIntervals = 0;\n    // Keep track of the largest length used so far, to ensure strictly increasing lengths.\n    long long maxLengthSoFar = 0;\n\n    // We'll define some utility lambdas to generate intervals in different patterns.\n    \n    // 1) RANDOM: picks random start in [-10^6, 10^6], picks random length from 1..50, but\n    //    ensures the total length is > maxLengthSoFar.\n    // 2) CHAIN: ensure each newly added interval partially overlaps the previous one.\n    // 3) NESTED: each new interval strictly bigger and contains all previous intervals.\n    // 4) SEPARATE: each new interval does not overlap with any of the existing intervals\n    //    (push them further on the number line).\n    \n    // We maintain data about all intervals for patterns 2, 3, 4 that need reference to\n    // previously added intervals. \n    // For random we don't need all intervals to do the next, but let's store them anyway.\n    vector<pair<long long, long long>> intervals; // store (start, end) of each added interval\n    \n    auto addIntervalRandom = [&](int idx) {\n        // We want length > maxLengthSoFar\n        // We'll pick an increment length from 1..50\n        long long length = maxLengthSoFar + rnd.next(1, 50);\n        // Random start in a moderate range so that start + length is within ±1e9\n        long long startRangeLow = -1000000; \n        long long startRangeHigh =  1000000;\n        // We need to ensure end <= 1e9 and start >= -1e9, so let's do a safe approach:\n        long long startCandidate = 0;\n        while (true) {\n            long long candidate = rnd.next(startRangeLow, startRangeHigh);\n            long long end = candidate + length;\n            if (abs(candidate) <= BOUND && abs(end) <= BOUND && candidate < end) {\n                startCandidate = candidate;\n                break;\n            }\n        }\n        long long s = startCandidate;\n        long long e = s + length;\n        \n        // Update\n        maxLengthSoFar = length;\n        intervals.push_back({s, e});\n        \n        // Output the query\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n    };\n    \n    auto addIntervalChain = [&](int idx) {\n        // If it's the very first interval, just pick any random valid interval.\n        if (countIntervals == 0) {\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // We want the new interval to partially overlap with the last one.\n        // Let the last interval be (L, R).\n        auto [Lprev, Rprev] = intervals.back();\n        long long length = maxLengthSoFar + rnd.next(1, 50);\n        long long overlapPoint = rnd.next(Lprev + 1, Rprev - 1); \n        // The above ensures that Lprev < overlapPoint < Rprev, so the chain overlap condition is fine\n        // as long as the new interval includes that point in its interior as well.\n        \n        // We'll pick a random shift around overlapPoint such that we get the correct length.\n        // length = end - start\n        // ensure overlapPoint is strictly inside (start, end).\n        // overlapPoint - start >= 1 and end - overlapPoint >= 1\n        // so let's pick: start = overlapPoint - x, end = overlapPoint + (length - x)\n        // for some x in [1, length-1].\n        long long x = rnd.next(1LL, length - 1);\n        long long s = overlapPoint - x;\n        long long e = s + length; // = overlapPoint - x + length\n        \n        // Check bounds\n        if (abs(s) > BOUND || abs(e) > BOUND || s >= e) {\n            // If it fails (e.g. out of bounds), just fallback to random approach.\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // Update\n        maxLengthSoFar = length;\n        intervals.push_back({s, e});\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n    };\n    \n    auto addIntervalNested = [&](int idx) {\n        // If no intervals yet, just do random.\n        if (countIntervals == 0) {\n            addIntervalRandom(idx);\n            return;\n        }\n        // We want the new interval to contain ALL existing intervals if possible.\n        // So let's find the min start and max end among all intervals.\n        long long curMin = LLONG_MAX;\n        long long curMax = LLONG_MIN;\n        for (auto &iv : intervals) {\n            curMin = min(curMin, iv.first);\n            curMax = max(curMax, iv.second);\n        }\n        \n        long long oldSpan = curMax - curMin; \n        long long newLength = maxLengthSoFar + rnd.next(1, 50); // strictly bigger than any so far\n        // We want to choose a new start <= curMin and new end >= curMax, so that\n        // the new interval strictly contains all existing intervals in its interior.\n        // Because we have newLength > oldSpan, we have some room.\n        \n        // Let new interval be (s, e) with e - s = newLength.\n        // We need s < curMin, e > curMax. \n        // Let's define a small margin on each side. We'll pick a margin on the left from [0..someRange].\n        // Then the right side is determined as s + newLength. \n        // We'll pick s in [curMin - (newLength - oldSpan), curMin], ensuring that e = s + newLength >= curMax.\n        \n        long long minS = curMin - (newLength - oldSpan);\n        long long maxS = curMin; \n        if (minS > maxS) {\n            // Edge case if oldSpan is huge. Fallback to random approach.\n            addIntervalRandom(idx);\n            return;\n        }\n        // clamp minS, maxS to keep it in bounds\n        minS = max(minS, - (long long)BOUND);\n        maxS = min(maxS,  (long long)BOUND);\n        if (minS > maxS) {\n            // fallback\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        long long s = rnd.next(minS, maxS);\n        long long e = s + newLength;\n        if (abs(e) > BOUND) {\n            // fallback\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // we have a valid nested interval now\n        maxLengthSoFar = newLength;\n        intervals.push_back({s, e});\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n    };\n    \n    auto addIntervalSeparate = [&](int idx) {\n        // If no intervals yet, just do random.\n        if (countIntervals == 0) {\n            addIntervalRandom(idx);\n            return;\n        }\n        // We want the new interval not to overlap with any existing interval.\n        // The easiest approach: place each new interval to the right of all existing intervals.\n        // We'll keep track of the maxRight so far, place a gap, then place the next interval.\n        static long long maxRightUsed = 0; \n        if (idx == 0) {\n            // for the very first interval (which is actually index=0 in queries, \n            //   but let's just do random, then set maxRightUsed).\n            addIntervalRandom(idx);\n            maxRightUsed = intervals.back().second; \n            return;\n        }\n        \n        // Now place the new one well to the right of 'maxRightUsed'.\n        long long newLength = maxLengthSoFar + rnd.next(1, 50);\n        long long s = maxRightUsed + rnd.next(1, 10); // put a random gap\n        long long e = s + newLength;\n        if (abs(s) > BOUND || abs(e) > BOUND || s >= e) {\n            // fallback\n            addIntervalRandom(idx);\n            return;\n        }\n        \n        // Update\n        maxLengthSoFar = newLength;\n        intervals.push_back({s, e});\n        queries.push_back(\"1 \" + to_string(s) + \" \" + to_string(e));\n        countIntervals++;\n        \n        // Update maxRightUsed\n        maxRightUsed = e;\n    };\n    \n    // Decide which \"addInterval\" function to use depending on the type\n    function<void(int)> addInterval;\n    if (genType == \"chain\") {\n        addInterval = addIntervalChain;\n    } else if (genType == \"nested\") {\n        addInterval = addIntervalNested;\n    } else if (genType == \"separate\") {\n        addInterval = addIntervalSeparate;\n    } else {\n        addInterval = addIntervalRandom; // default\n    }\n\n    // We'll produce exactly n queries.\n    // Strategy: \n    //  - We must produce at least 2 intervals in total (so that type-2 queries are possible).\n    //  - We won't produce a type-2 query unless there's at least 2 intervals to reference.\n    //  - We'll produce queries in a random pattern, but guarantee we end up with enough intervals \n    //    so that we don't get stuck.\n\n    // Let half of them (rounded up) be type-1 queries (so we have intervals).\n    // The rest can be type-2 queries, referencing random existing intervals.\n    // If n=1, we must produce exactly 1 query -> must be type-1.\n\n    int minIntervals = min(n, (n + 1) / 2); \n    // We plan to produce exactly \"minIntervals\" type-1 queries in total, spread out among the n.\n\n    // Keep track of how many type-1 queries we've emitted so far.\n    int usedType1 = 0;\n\n    for (int i = 0; i < n; i++) {\n        // If we haven't yet reached minIntervals for type-1, but we also have enough queries left\n        // such that we can still do some type-2, let's let coin toss decide.\n        bool canProduceType2 = (usedType1 >= 2); // need at least 2 intervals to produce type-2\n        bool stillNeedType1 = (usedType1 < minIntervals);\n\n        // If we still must produce more type-1 queries to meet the quota, or we can't produce type-2 yet, do type-1\n        // otherwise choose randomly.\n        bool doType1 = false;\n        if (!canProduceType2) {\n            // must do type-1\n            doType1 = true;\n        } else if (!stillNeedType1) {\n            // we've reached the required number of intervals, so we are free to produce type-2\n            // maybe produce type-2 with some probability\n            doType1 = (rnd.next(0, 1) == 0) ? false : true; \n        } else {\n            // we can do either type-1 or type-2, choose randomly\n            // but we do want to ensure we get enough intervals in the end\n            // We'll produce type-1 with probability 50%, type-2 with probability 50%\n            doType1 = (rnd.next(0, 1) == 0);\n        }\n\n        if (i == n - 1 && usedType1 < minIntervals) {\n            // We are at the last query but haven't reached the needed intervals yet => must do type-1\n            doType1 = true;\n        }\n\n        if (doType1) {\n            // produce a type-1 query\n            addInterval(usedType1);\n            usedType1++;\n        } else {\n            // produce a type-2 query\n            // We have countIntervals so far, pick two distinct intervals\n            int a = rnd.next(1, countIntervals);\n            int b = rnd.next(1, countIntervals);\n            while (b == a) {\n                b = rnd.next(1, countIntervals);\n            }\n            // add query \"2 a b\"\n            queries.push_back(\"2 \" + to_string(a) + \" \" + to_string(b));\n        }\n    }\n\n    // Finally, output all queries\n    // The first line: n\n    cout << n << \"\\n\";\n    for (auto &q : queries) {\n        cout << q << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type chain\n./gen -n 5 -type nested\n./gen -n 5 -type separate\n./gen -n 5 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type nested\n./gen -n 10 -type separate\n./gen -n 10 -type random\n\n./gen -n 15 -type chain\n./gen -n 15 -type nested\n./gen -n 15 -type separate\n./gen -n 15 -type random\n\n./gen -n 20 -type chain\n./gen -n 20 -type nested\n./gen -n 20 -type separate\n./gen -n 20 -type random\n\n./gen -n 30 -type chain\n./gen -n 30 -type nested\n./gen -n 30 -type separate\n./gen -n 30 -type random\n\n./gen -n 50 -type random\n./gen -n 75 -type random\n./gen -n 100 -type chain\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:51.950534",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "320/C",
      "title": "C. Танцевальный клуб Малека",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится двоичное число x длины n, (1 ≤ n ≤ 100).Это число может содержать ведущие нули.",
      "output_spec": "Выходные данныеВыведите сложность данного распределения по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать11Выходные данныеСкопировать6Входные данныеСкопировать01Выходные данныеСкопировать2Входные данныеСкопировать1Выходные данныеСкопировать1",
      "description": "C. Танцевальный клуб Малека\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится двоичное число x длины n, (1 ≤ n ≤ 100).Это число может содержать ведущие нули.\n\nВходные данные\n\nВыходные данныеВыведите сложность данного распределения по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать11Выходные данныеСкопировать6Входные данныеСкопировать01Выходные данныеСкопировать2Входные данныеСкопировать1Выходные данныеСкопировать1\n\nВходные данныеСкопировать11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать01\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Привет, Codeforces! :-{DПо случаю двух важных событий в мире спортивного программирования (IOI и ACM ICPC) я и мои друзья (команда Ирана на IOI) решили сделать подарок всем пользователям Codeforces, которые будут участвовать хотя бы в одном из этих двух соревнования, а также всем остальным. :)Этот раунд подготовил я (havaliza), dani1373 и keivan, также нам помогал fab. Я хочу поблагодарить всю команду Codeforces за их усилия в поддержании этого веб-сайта.Надеюсь вам понравится решать задачи так же, как нам понравилось их готовить! ^.^Update 1. Распределение баллов по задачам в Div. 1: 500-1000-1500-2500-2500, в Div. 2 распределение стандартное.Update 2. Большое спасибо пользователю Aksenov239, который очень много помогал нам в подготовке раунда.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 811
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 320 和字母"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 30",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 31",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 32",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 33",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string x = inf.readLine(\"[01]{1,100}\", \"x\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string x = inf.readLine(\"[01]{1,100}\", \"x\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string x = inf.readLine(\"[01]{1,100}\", \"x\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"rand\");\n\n    string x(n, '0');\n\n    if (type == \"zeros\") {\n        // x is all zeros\n        x = string(n, '0');\n    } else if (type == \"ones\") {\n        // x is all ones\n        x = string(n, '1');\n    } else if (type == \"alt\") {\n        // x is alternating zeros and ones\n        for (int i = 0; i < n; ++i)\n            x[i] = (i % 2 == 0) ? '0' : '1';\n    } else if (type == \"pal\") {\n        // x is a palindrome\n        for (int i = 0; i < (n + 1) / 2; ++i)\n            x[i] = '0' + rnd.next(0, 1);\n        for (int i = 0; i < n / 2; ++i)\n            x[n - 1 - i] = x[i];\n    } else if (type == \"pow2\") {\n        // x is '1' followed by zeros\n        x[0] = '1';\n        for (int i = 1; i < n; ++i)\n            x[i] = '0';\n    } else if (type == \"high\") {\n        // x is '0' followed by ones\n        x[0] = '0';\n        for (int i = 1; i < n; ++i)\n            x[i] = '1';\n    } else if (type == \"rand\") {\n        // x is random\n        for (int i = 0; i < n; ++i)\n            x[i] = '0' + rnd.next(0, 1);\n    } else {\n        // unknown type\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output x\n    printf(\"%s\\n\", x.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"rand\");\n\n    string x(n, '0');\n\n    if (type == \"zeros\") {\n        // x is all zeros\n        x = string(n, '0');\n    } else if (type == \"ones\") {\n        // x is all ones\n        x = string(n, '1');\n    } else if (type == \"alt\") {\n        // x is alternating zeros and ones\n        for (int i = 0; i < n; ++i)\n            x[i] = (i % 2 == 0) ? '0' : '1';\n    } else if (type == \"pal\") {\n        // x is a palindrome\n        for (int i = 0; i < (n + 1) / 2; ++i)\n            x[i] = '0' + rnd.next(0, 1);\n        for (int i = 0; i < n / 2; ++i)\n            x[n - 1 - i] = x[i];\n    } else if (type == \"pow2\") {\n        // x is '1' followed by zeros\n        x[0] = '1';\n        for (int i = 1; i < n; ++i)\n            x[i] = '0';\n    } else if (type == \"high\") {\n        // x is '0' followed by ones\n        x[0] = '0';\n        for (int i = 1; i < n; ++i)\n            x[i] = '1';\n    } else if (type == \"rand\") {\n        // x is random\n        for (int i = 0; i < n; ++i)\n            x[i] = '0' + rnd.next(0, 1);\n    } else {\n        // unknown type\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output x\n    printf(\"%s\\n\", x.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type ones\n./gen -n 1 -type alt\n./gen -n 1 -type pal\n./gen -n 1 -type pow2\n./gen -n 1 -type high\n./gen -n 1 -type rand\n\n./gen -n 2 -type zeros\n./gen -n 2 -type ones\n./gen -n 2 -type alt\n./gen -n 2 -type pal\n./gen -n 2 -type pow2\n./gen -n 2 -type high\n./gen -n 2 -type rand\n\n./gen -n 5 -type zeros\n./gen -n 5 -type ones\n./gen -n 5 -type alt\n./gen -n 5 -type pal\n./gen -n 5 -type pow2\n./gen -n 5 -type high\n./gen -n 5 -type rand\n\n./gen -n 10 -type zeros\n./gen -n 10 -type ones\n./gen -n 10 -type alt\n./gen -n 10 -type pal\n./gen -n 10 -type pow2\n./gen -n 10 -type high\n./gen -n 10 -type rand\n\n./gen -n 50 -type zeros\n./gen -n 50 -type ones\n./gen -n 50 -type alt\n./gen -n 50 -type pal\n./gen -n 50 -type pow2\n./gen -n 50 -type high\n./gen -n 50 -type rand\n\n./gen -n 100 -type zeros\n./gen -n 100 -type ones\n./gen -n 100 -type alt\n./gen -n 100 -type pal\n./gen -n 100 -type pow2\n./gen -n 100 -type high\n./gen -n 100 -type rand\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:53.834891",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "320/D",
      "title": "D. Psychos in a Line",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n denoting the number of psychos, (1 ≤ n ≤ 105). In the second line there will be a list of n space separated distinct integers each in range 1 to n, inclusive — ids of the psychos in the line from left to right.",
      "output_spec": "OutputPrint the number of steps, so that the line remains the same afterward.",
      "sample_tests": "ExamplesInputCopy1010 9 7 8 6 5 3 4 2 1OutputCopy2InputCopy61 2 3 4 5 6OutputCopy0",
      "description": "D. Psychos in a Line\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains integer n denoting the number of psychos, (1 ≤ n ≤ 105). In the second line there will be a list of n space separated distinct integers each in range 1 to n, inclusive — ids of the psychos in the line from left to right.\n\nOutputPrint the number of steps, so that the line remains the same afterward.\n\nInputCopy1010 9 7 8 6 5 3 4 2 1OutputCopy2InputCopy61 2 3 4 5 6OutputCopy0\n\nInputCopy1010 9 7 8 6 5 3 4 2 1\n\nOutputCopy2\n\nInputCopy61 2 3 4 5 6\n\nOutputCopy0\n\nNoteIn the first sample line of the psychos transforms as follows: [10 9 7 8 6 5 3 4 2 1]  →  [10 8 4]  →  [10]. So, there are two steps.",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Hello, Codeforces! :-{DAs two important events IOI and ACM ICPC are coming soon, me and my friends as the Iranian IOI team decided to prepare a gift for all the Codeforces users who'll soon participate in one of these events, and also everybody else. :)This round authored by me (havaliza), dani1373 and keivan with help from fab. I want to thank all the Codeforces team for their kind and great effort to maintain this website.Hope you enjoy solving the problems as much as we're enjoying preparing them! ^.^Update 1. The score distribution for Div. 1 is 500-1000-1500-2500-2500 and for Div. 2 its regular.Update 2. Special thanks to Aksenov239 who helped us so much to prepare this round.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 746
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 320 和字母"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ids = inf.readInts(n, 1, n, \"ids\");\n    inf.readEoln();\n\n    set<int> s(ids.begin(), ids.end());\n    ensuref((int)s.size() == n, \"ids must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ids = inf.readInts(n, 1, n, \"ids\");\n    inf.readEoln();\n\n    set<int> s(ids.begin(), ids.end());\n    ensuref((int)s.size() == n, \"ids must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ids = inf.readInts(n, 1, n, \"ids\");\n    inf.readEoln();\n\n    set<int> s(ids.begin(), ids.end());\n    ensuref((int)s.size() == n, \"ids must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ids(n);\n\n    if (type == \"ascending\") {\n        // ids from 1 to n\n        for (int i = 0; i < n; ++i) {\n            ids[i] = i + 1;\n        }\n    } else if (type == \"descending\") {\n        // ids from n down to 1\n        for (int i = 0; i < n; ++i) {\n            ids[i] = n - i;\n        }\n    } else if (type == \"random\") {\n        // random permutation of 1..n\n        for (int i = 0; i < n; ++i) {\n            ids[i] = i + 1;\n        }\n        shuffle(ids.begin(), ids.end());\n    } else if (type == \"special1\") {\n        // Generate a sequence where the process lasts multiple steps\n        // Creating a sequence where death times increase\n        // For example, ids[i] = i % k + 1;\n        int k = n > 100 ? 100 : n;\n        for (int i = 0; i < n; ++i) {\n            ids[i] = n - i / k;\n        }\n    } else if (type == \"special2\") {\n        // Generate a sequence where death times can be large\n        // For example, alternating large and small numbers\n        int left = 1, right = n;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ids[i] = right--;\n            } else {\n                ids[i] = left++;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            ids[i] = i + 1;\n        }\n        shuffle(ids.begin(), ids.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the ids\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ids[i]);\n        if (i == n - 1)\n            printf(\"\\n\");\n        else\n            printf(\" \");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ids(n);\n\n    if (type == \"ascending\") {\n        // ids from 1 to n\n        for (int i = 0; i < n; ++i) {\n            ids[i] = i + 1;\n        }\n    } else if (type == \"descending\") {\n        // ids from n down to 1\n        for (int i = 0; i < n; ++i) {\n            ids[i] = n - i;\n        }\n    } else if (type == \"random\") {\n        // random permutation of 1..n\n        for (int i = 0; i < n; ++i) {\n            ids[i] = i + 1;\n        }\n        shuffle(ids.begin(), ids.end());\n    } else if (type == \"special1\") {\n        // Generate a sequence where the process lasts multiple steps\n        // Creating a sequence where death times increase\n        // For example, ids[i] = i % k + 1;\n        int k = n > 100 ? 100 : n;\n        for (int i = 0; i < n; ++i) {\n            ids[i] = n - i / k;\n        }\n    } else if (type == \"special2\") {\n        // Generate a sequence where death times can be large\n        // For example, alternating large and small numbers\n        int left = 1, right = n;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ids[i] = right--;\n            } else {\n                ids[i] = left++;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            ids[i] = i + 1;\n        }\n        shuffle(ids.begin(), ids.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the ids\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ids[i]);\n        if (i == n - 1)\n            printf(\"\\n\");\n        else\n            printf(\" \");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 10 -type random\n./gen -n 10 -type special1\n./gen -n 10 -type special2\n\n./gen -n 100 -type ascending\n./gen -n 100 -type descending\n./gen -n 100 -type random\n./gen -n 100 -type special1\n./gen -n 100 -type special2\n\n./gen -n 1000 -type ascending\n./gen -n 1000 -type descending\n./gen -n 1000 -type random\n./gen -n 1000 -type special1\n./gen -n 1000 -type special2\n\n./gen -n 10000 -type ascending\n./gen -n 10000 -type descending\n./gen -n 10000 -type random\n./gen -n 10000 -type special1\n./gen -n 10000 -type special2\n\n./gen -n 50000 -type ascending\n./gen -n 50000 -type descending\n./gen -n 50000 -type random\n./gen -n 50000 -type special1\n./gen -n 50000 -type special2\n\n./gen -n 100000 -type ascending\n./gen -n 100000 -type descending\n./gen -n 100000 -type random\n./gen -n 100000 -type special1\n./gen -n 100000 -type special2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:55.856378",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "320/E",
      "title": "E. Kalila and Dimna in the Logging Industry",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n (1 ≤ n ≤ 105). The second line of input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The third line of input contains n integers b1, b2, ..., bn (0 ≤ bi ≤ 109).It's guaranteed that a1 = 1, bn = 0, a1 < a2 < ... < an and b1 > b2 > ... > bn.",
      "output_spec": "OutputThe only line of output must contain the minimum cost of cutting all the trees completely.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy51 2 3 4 55 4 3 2 0OutputCopy25InputCopy61 2 3 10 20 306 5 4 3 2 0OutputCopy138",
      "description": "E. Kalila and Dimna in the Logging Industry\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n (1 ≤ n ≤ 105). The second line of input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The third line of input contains n integers b1, b2, ..., bn (0 ≤ bi ≤ 109).It's guaranteed that a1 = 1, bn = 0, a1 < a2 < ... < an and b1 > b2 > ... > bn.\n\nOutputThe only line of output must contain the minimum cost of cutting all the trees completely.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy51 2 3 4 55 4 3 2 0OutputCopy25InputCopy61 2 3 10 20 306 5 4 3 2 0OutputCopy138\n\nInputCopy51 2 3 4 55 4 3 2 0\n\nOutputCopy25\n\nInputCopy61 2 3 10 20 306 5 4 3 2 0\n\nOutputCopy138",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Hello, Codeforces! :-{DAs two important events IOI and ACM ICPC are coming soon, me and my friends as the Iranian IOI team decided to prepare a gift for all the Codeforces users who'll soon participate in one of these events, and also everybody else. :)This round authored by me (havaliza), dani1373 and keivan with help from fab. I want to thank all the Codeforces team for their kind and great effort to maintain this website.Hope you enjoy solving the problems as much as we're enjoying preparing them! ^.^Update 1. The score distribution for Div. 1 is 500-1000-1500-2500-2500 and for Div. 2 its regular.Update 2. Special thanks to Aksenov239 who helped us so much to prepare this round.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 746
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 320 和字母"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    // Check that a[0] == 1\n    ensuref(a[0] == 1, \"a[1]=%d must be equal to 1\", a[0]);\n\n    // Check that a[i] > a[i-1] for i = 1 to n-1\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a[%d]=%d must be less than a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    // Check that b[n - 1] == 0\n    ensuref(b[n - 1] == 0, \"b[%d]=%d must be equal to 0\", n, b[n - 1]);\n\n    // Check that b[i] > b[i+1] for i = 1 to n-1\n    for (int i = 1; i < n; ++i) {\n        ensuref(b[i - 1] > b[i], \"b[%d]=%d must be greater than b[%d]=%d\", i, b[i - 1], i + 1, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    // Check that a[0] == 1\n    ensuref(a[0] == 1, \"a[1]=%d must be equal to 1\", a[0]);\n\n    // Check that a[i] > a[i-1] for i = 1 to n-1\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a[%d]=%d must be less than a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    // Check that b[n - 1] == 0\n    ensuref(b[n - 1] == 0, \"b[%d]=%d must be equal to 0\", n, b[n - 1]);\n\n    // Check that b[i] > b[i+1] for i = 1 to n-1\n    for (int i = 1; i < n; ++i) {\n        ensuref(b[i - 1] > b[i], \"b[%d]=%d must be greater than b[%d]=%d\", i, b[i - 1], i + 1, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    // Check that a[0] == 1\n    ensuref(a[0] == 1, \"a[1]=%d must be equal to 1\", a[0]);\n\n    // Check that a[i] > a[i-1] for i = 1 to n-1\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a[%d]=%d must be less than a[%d]=%d\", i, a[i - 1], i + 1, a[i]);\n    }\n\n    // Check that b[n - 1] == 0\n    ensuref(b[n - 1] == 0, \"b[%d]=%d must be equal to 0\", n, b[n - 1]);\n\n    // Check that b[i] > b[i+1] for i = 1 to n-1\n    for (int i = 1; i < n; ++i) {\n        ensuref(b[i - 1] > b[i], \"b[%d]=%d must be greater than b[%d]=%d\", i, b[i - 1], i + 1, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(n < 1 || n > 100000){\n        fprintf(stderr, \"n is out of bounds\\n\");\n        return 1;\n    }\n\n    if (type == \"random\") {\n        /* Random heights and costs */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            int max_increment = int(1e9) - a[i-1] - (n - i); // Ensure a[i] ≤ 1e9\n            if (max_increment <= 0) max_increment = 1;\n            int increment = rnd.next(1, max_increment);\n            a[i] = a[i-1] + increment;\n        }\n        vector<int> b(n);\n        b[n-1] = 0; // bn = 0\n        for(int i = n - 2; i >= 0; --i) {\n            int min_b_i = b[i+1] + 1;\n            int max_b_i = int(1e9);\n            if (min_b_i > max_b_i) min_b_i = max_b_i;\n            b[i] = rnd.next(min_b_i, max_b_i);\n        }\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"max\") {\n        /* Maximize heights and costs */\n        vector<int> a(n);\n        a[0] = 1;\n        int increment = (int(1e9) - 1) / (n - 1);\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + increment;\n            if (a[i] > int(1e9) - (n - i)) a[i] = int(1e9) - (n - i);\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        b[0] = int(1e9);\n        int decrement = int(1e9) / (n - 1);\n        for(int i = n - 2; i >= 1; --i) {\n            b[i] = b[i+1] + decrement;\n            if (b[i] >= b[i-1]) b[i] = b[i-1] - 1; // Keep it decreasing\n        }\n        b[0] = int(1e9);\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"min\") {\n        /* Minimal heights and maximal decreasing costs */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + 1;\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        for(int i = n - 2; i >= 0; --i) {\n            b[i] = b[i+1] + 1;\n        }\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"special1\") {\n        /* Heights increase by 1, costs drop sharply in the middle */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + 1;\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        int high = int(1e9);\n        int middle = n / 2;\n        for(int i = 0; i < n; ++i) {\n            if (i < middle)\n                b[i] = high - i * (high / middle);\n            else\n                b[i] = 0;\n        }\n        for(int i = n - 2; i >= 0; --i) {\n            if(b[i] <= b[i+1]) b[i] = b[i+1] + 1;\n            if(b[i] > int(1e9)) b[i] = int(1e9);\n        }\n        b[0] = int(1e9);\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"special2\") {\n        /* Heights increase significantly, costs decrease slowly */\n        vector<int> a(n);\n        a[0] = 1;\n        int increment = (int(1e9) - 1) / (n - 1);\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + increment;\n            if (a[i] > int(1e9) - (n - i)) a[i] = int(1e9) - (n - i);\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        b[0] = int(1e9);\n        for(int i = 1; i < n - 1; ++i) {\n            b[i] = b[i-1] - 1;\n            if (b[i] <= b[i+1]) b[i] = b[i+1] + 1;\n        }\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type\\n\");\n        return 1;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(n < 1 || n > 100000){\n        fprintf(stderr, \"n is out of bounds\\n\");\n        return 1;\n    }\n\n    if (type == \"random\") {\n        /* Random heights and costs */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            int max_increment = int(1e9) - a[i-1] - (n - i); // Ensure a[i] ≤ 1e9\n            if (max_increment <= 0) max_increment = 1;\n            int increment = rnd.next(1, max_increment);\n            a[i] = a[i-1] + increment;\n        }\n        vector<int> b(n);\n        b[n-1] = 0; // bn = 0\n        for(int i = n - 2; i >= 0; --i) {\n            int min_b_i = b[i+1] + 1;\n            int max_b_i = int(1e9);\n            if (min_b_i > max_b_i) min_b_i = max_b_i;\n            b[i] = rnd.next(min_b_i, max_b_i);\n        }\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"max\") {\n        /* Maximize heights and costs */\n        vector<int> a(n);\n        a[0] = 1;\n        int increment = (int(1e9) - 1) / (n - 1);\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + increment;\n            if (a[i] > int(1e9) - (n - i)) a[i] = int(1e9) - (n - i);\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        b[0] = int(1e9);\n        int decrement = int(1e9) / (n - 1);\n        for(int i = n - 2; i >= 1; --i) {\n            b[i] = b[i+1] + decrement;\n            if (b[i] >= b[i-1]) b[i] = b[i-1] - 1; // Keep it decreasing\n        }\n        b[0] = int(1e9);\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"min\") {\n        /* Minimal heights and maximal decreasing costs */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + 1;\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        for(int i = n - 2; i >= 0; --i) {\n            b[i] = b[i+1] + 1;\n        }\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"special1\") {\n        /* Heights increase by 1, costs drop sharply in the middle */\n        vector<int> a(n);\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + 1;\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        int high = int(1e9);\n        int middle = n / 2;\n        for(int i = 0; i < n; ++i) {\n            if (i < middle)\n                b[i] = high - i * (high / middle);\n            else\n                b[i] = 0;\n        }\n        for(int i = n - 2; i >= 0; --i) {\n            if(b[i] <= b[i+1]) b[i] = b[i+1] + 1;\n            if(b[i] > int(1e9)) b[i] = int(1e9);\n        }\n        b[0] = int(1e9);\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else if (type == \"special2\") {\n        /* Heights increase significantly, costs decrease slowly */\n        vector<int> a(n);\n        a[0] = 1;\n        int increment = (int(1e9) - 1) / (n - 1);\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + increment;\n            if (a[i] > int(1e9) - (n - i)) a[i] = int(1e9) - (n - i);\n        }\n        vector<int> b(n);\n        b[n-1] = 0;\n        b[0] = int(1e9);\n        for(int i = 1; i < n - 1; ++i) {\n            b[i] = b[i-1] - 1;\n            if (b[i] <= b[i+1]) b[i] = b[i+1] + 1;\n        }\n\n        // Output n, a_i, and b_i\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n        }\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type\\n\");\n        return 1;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 5 -type max\n./gen -n 5 -type min\n./gen -n 5 -type special1\n./gen -n 5 -type special2\n\n./gen -n 10 -type random\n./gen -n 10 -type max\n./gen -n 10 -type min\n./gen -n 10 -type special1\n./gen -n 10 -type special2\n\n./gen -n 100 -type random\n./gen -n 100 -type max\n./gen -n 100 -type min\n./gen -n 100 -type special1\n./gen -n 100 -type special2\n\n./gen -n 1000 -type random\n./gen -n 1000 -type max\n./gen -n 1000 -type min\n./gen -n 1000 -type special1\n./gen -n 1000 -type special2\n\n./gen -n 10000 -type random\n./gen -n 10000 -type max\n./gen -n 10000 -type min\n./gen -n 10000 -type special1\n./gen -n 10000 -type special2\n\n./gen -n 100000 -type random\n./gen -n 100000 -type max\n./gen -n 100000 -type min\n./gen -n 100000 -type special1\n./gen -n 100000 -type special2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:57.834346",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "321/A",
      "title": "A. Ciel and Robot",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers a and b, ( - 109 ≤ a, b ≤ 109). The second line contains a string s (1 ≤ |s| ≤ 100, s only contains characters 'U', 'D', 'L', 'R') — the command.",
      "output_spec": "OutputPrint \"Yes\" if the robot will be located at (a, b), and \"No\" otherwise.",
      "sample_tests": "ExamplesInputCopy2 2RUOutputCopyYesInputCopy1 2RUOutputCopyNoInputCopy-1 1000000000LRRLUOutputCopyYesInputCopy0 0DOutputCopyYes",
      "description": "A. Ciel and Robot\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers a and b, ( - 109 ≤ a, b ≤ 109). The second line contains a string s (1 ≤ |s| ≤ 100, s only contains characters 'U', 'D', 'L', 'R') — the command.\n\nOutputPrint \"Yes\" if the robot will be located at (a, b), and \"No\" otherwise.\n\nInputCopy2 2RUOutputCopyYesInputCopy1 2RUOutputCopyNoInputCopy-1 1000000000LRRLUOutputCopyYesInputCopy0 0DOutputCopyYes\n\nInputCopy2 2RU\n\nOutputCopyYes\n\nInputCopy1 2RU\n\nOutputCopyNo\n\nInputCopy-1 1000000000LRRLU\n\nOutputCopyYes\n\nInputCopy0 0D\n\nOutputCopyYes\n\nNoteIn the first and second test case, command string is \"RU\", so the robot will go right, then go up, then right, and then up and so on.The locations of its moves are (0, 0)  →  (1, 0)  →  (1, 1)  →  (2, 1)  →  (2, 2)  →  ...So it can reach (2, 2) but not (1, 2).",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Hello, everyone!Do you want to train your skill by a contest before ACM/ICPC Finals?Codeforces Round #190 will take place on Friday, June 28th at 19:30 MSK. This is the last chance to practice, don't miss it!I am cgy4ever from China, and this is my first round on Codeforces, I hope you will love it.As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. I am the writer of them. And I would like to thank Gerald and sdya for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.Update 3: I have write a draft of editorial for this round when you are solving problems.You can read it here.Note that I didn't do any proof read and there are some typesetting issue. Anyway, I will improve it and this version is just for someone who is urgent to know the intended solutions.Update 4 Contest complete! This round will be rated!Congratulations to the winners:Div2: Baklazan phidnight kingofnumbers pawel.jasinski1986 Ronnoc Div1: YuukaKazami rng_58 Egor tmt514 chnlich And after this round, ivan.metelsky becomes our new International Grandmaster!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1505
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 321\\s*A"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[UDLR]{1,100}\", \"s\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[UDLR]{1,100}\", \"s\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[UDLR]{1,100}\", \"s\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    int a, b;\n\n    if (type == \"random\") {\n        // Generate random s of length n\n        string directions = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += directions[rnd.next(4)];\n        }\n        // Generate random a and b within [-1e9, 1e9]\n        a = rnd.next(-1000000000, 1000000000);\n        b = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"only_one_direction\") {\n        // Choose a random direction\n        string directions = \"UDLR\";\n        char dir = directions[rnd.next(4)];\n        s = string(n, dir);\n        // Generate random a and b within [-1e9, 1e9]\n        // Since movement is only in one direction, adjust a and b accordingly\n        if (dir == 'U' || dir == 'D') {\n            a = 0;\n            b = rnd.next(-1000000000, 1000000000);\n            if (dir == 'U') b = abs(b);\n            else b = -abs(b);\n        } else {\n            b = 0;\n            a = rnd.next(-1000000000, 1000000000);\n            if (dir == 'R') a = abs(a);\n            else a = -abs(a);\n        }\n    } else if (type == \"zero_sum\") {\n        // Generate s with net zero movement\n        string moves = \"UDLR\";\n        s = \"\";\n        vector<char> choices = {'U', 'D', 'L', 'R'};\n        shuffle(choices.begin(), choices.end());\n        char dir1 = choices[0];\n        char dir2 = (dir1 == 'U') ? 'D' : (dir1 == 'D') ? 'U' : (dir1 == 'L') ? 'R' : 'L';\n        int half_n = n / 2;\n        for (int i = 0; i < half_n; ++i) s += dir1;\n        for (int i = half_n; i < n; ++i) s += dir2;\n        shuffle(s.begin(), s.end());\n        // Since net movement is zero, pick a reachable point during the cycle\n        // Simulate positions during one cycle\n        int x = 0, y = 0;\n        set<pair<int, int>> positions;\n        positions.insert({0, 0});\n        for (char c : s) {\n            if (c == 'U') y += 1;\n            else if (c == 'D') y -= 1;\n            else if (c == 'L') x -= 1;\n            else if (c == 'R') x += 1;\n            positions.insert({x, y});\n        }\n        // Select a random position from positions\n        auto it = positions.begin();\n        advance(it, rnd.next(positions.size()));\n        a = it->first;\n        b = it->second;\n    } else if (type == \"unreachable\") {\n        // Generate s that moves in specific directions only\n        vector<string> possible_directions = {\"U\", \"D\", \"L\", \"R\", \"UD\", \"LR\"};\n        string s_options = possible_directions[rnd.next(possible_directions.size())];\n        for (int i = 0; i < n; ++i) {\n            s += s_options[rnd.next(s_options.size())];\n        }\n        // Identify missing directions\n        set<char> present_dirs(s_options.begin(), s_options.end());\n        vector<char> missing_dirs;\n        for (char c : \"UDLR\") {\n            if (!present_dirs.count(c)) missing_dirs.push_back(c);\n        }\n        // Generate a and/or b that require the missing direction(s)\n        if (!missing_dirs.empty()) {\n            // For simplicity, set a or b to a value that requires missing movement\n            char missing_dir = missing_dirs[rnd.next(missing_dirs.size())];\n            if (missing_dir == 'U') b = rnd.next(1, 1000000000);\n            else if (missing_dir == 'D') b = rnd.next(-1000000000, -1);\n            else if (missing_dir == 'L') a = rnd.next(-1000000000, -1);\n            else if (missing_dir == 'R') a = rnd.next(1, 1000000000);\n\n            // Set the other coordinate randomly\n            if (missing_dir == 'U' || missing_dir == 'D') {\n                a = rnd.next(-1000000000, 1000000000);\n            } else {\n                b = rnd.next(-1000000000, 1000000000);\n            }\n        } else {\n            // All directions are present; set a and b to an unreachable point\n            a = 1000000000 + rnd.next(1, 1000000000);\n            b = 1000000000 + rnd.next(1, 1000000000);\n        }\n    } else if (type == \"max_coordinates\") {\n        // Generate random s of length n\n        string directions = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += directions[rnd.next(4)];\n        }\n        // Set a and b to maximum or minimum\n        a = rnd.next(0,1) ? 1000000000 : -1000000000;\n        b = rnd.next(0,1) ? 1000000000 : -1000000000;\n    } else if (type == \"cycle_movement\") {\n        // Generate s with net non-zero movement\n        int dx_total = 0, dy_total = 0;\n        do {\n            s.clear();\n            dx_total = 0; dy_total = 0;\n            for (int i = 0; i < n; ++i) {\n                char c = \"UDLR\"[rnd.next(4)];\n                s += c;\n                if (c == 'U') dy_total += 1;\n                else if (c == 'D') dy_total -= 1;\n                else if (c == 'L') dx_total -= 1;\n                else if (c == 'R') dx_total += 1;\n            }\n        } while (dx_total == 0 && dy_total == 0);\n\n        // Choose k to scale dx_total and dy_total to reach large positions\n        int k = rnd.next(1, 1000000);\n        a = dx_total * k;\n        b = dy_total * k;\n\n        // Optionally adjust a and b randomly within a small range to test edge cases\n        a += rnd.next(-100, 100);\n        b += rnd.next(-100, 100);\n\n        // Ensure a and b are within constraints\n        a = max(-1000000000, min(1000000000, a));\n        b = max(-1000000000, min(1000000000, b));\n    } else {\n        // Default to random\n        string directions = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += directions[rnd.next(4)];\n        }\n        a = rnd.next(-1000000000, 1000000000);\n        b = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    int a, b;\n\n    if (type == \"random\") {\n        // Generate random s of length n\n        string directions = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += directions[rnd.next(4)];\n        }\n        // Generate random a and b within [-1e9, 1e9]\n        a = rnd.next(-1000000000, 1000000000);\n        b = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"only_one_direction\") {\n        // Choose a random direction\n        string directions = \"UDLR\";\n        char dir = directions[rnd.next(4)];\n        s = string(n, dir);\n        // Generate random a and b within [-1e9, 1e9]\n        // Since movement is only in one direction, adjust a and b accordingly\n        if (dir == 'U' || dir == 'D') {\n            a = 0;\n            b = rnd.next(-1000000000, 1000000000);\n            if (dir == 'U') b = abs(b);\n            else b = -abs(b);\n        } else {\n            b = 0;\n            a = rnd.next(-1000000000, 1000000000);\n            if (dir == 'R') a = abs(a);\n            else a = -abs(a);\n        }\n    } else if (type == \"zero_sum\") {\n        // Generate s with net zero movement\n        string moves = \"UDLR\";\n        s = \"\";\n        vector<char> choices = {'U', 'D', 'L', 'R'};\n        shuffle(choices.begin(), choices.end());\n        char dir1 = choices[0];\n        char dir2 = (dir1 == 'U') ? 'D' : (dir1 == 'D') ? 'U' : (dir1 == 'L') ? 'R' : 'L';\n        int half_n = n / 2;\n        for (int i = 0; i < half_n; ++i) s += dir1;\n        for (int i = half_n; i < n; ++i) s += dir2;\n        shuffle(s.begin(), s.end());\n        // Since net movement is zero, pick a reachable point during the cycle\n        // Simulate positions during one cycle\n        int x = 0, y = 0;\n        set<pair<int, int>> positions;\n        positions.insert({0, 0});\n        for (char c : s) {\n            if (c == 'U') y += 1;\n            else if (c == 'D') y -= 1;\n            else if (c == 'L') x -= 1;\n            else if (c == 'R') x += 1;\n            positions.insert({x, y});\n        }\n        // Select a random position from positions\n        auto it = positions.begin();\n        advance(it, rnd.next(positions.size()));\n        a = it->first;\n        b = it->second;\n    } else if (type == \"unreachable\") {\n        // Generate s that moves in specific directions only\n        vector<string> possible_directions = {\"U\", \"D\", \"L\", \"R\", \"UD\", \"LR\"};\n        string s_options = possible_directions[rnd.next(possible_directions.size())];\n        for (int i = 0; i < n; ++i) {\n            s += s_options[rnd.next(s_options.size())];\n        }\n        // Identify missing directions\n        set<char> present_dirs(s_options.begin(), s_options.end());\n        vector<char> missing_dirs;\n        for (char c : \"UDLR\") {\n            if (!present_dirs.count(c)) missing_dirs.push_back(c);\n        }\n        // Generate a and/or b that require the missing direction(s)\n        if (!missing_dirs.empty()) {\n            // For simplicity, set a or b to a value that requires missing movement\n            char missing_dir = missing_dirs[rnd.next(missing_dirs.size())];\n            if (missing_dir == 'U') b = rnd.next(1, 1000000000);\n            else if (missing_dir == 'D') b = rnd.next(-1000000000, -1);\n            else if (missing_dir == 'L') a = rnd.next(-1000000000, -1);\n            else if (missing_dir == 'R') a = rnd.next(1, 1000000000);\n\n            // Set the other coordinate randomly\n            if (missing_dir == 'U' || missing_dir == 'D') {\n                a = rnd.next(-1000000000, 1000000000);\n            } else {\n                b = rnd.next(-1000000000, 1000000000);\n            }\n        } else {\n            // All directions are present; set a and b to an unreachable point\n            a = 1000000000 + rnd.next(1, 1000000000);\n            b = 1000000000 + rnd.next(1, 1000000000);\n        }\n    } else if (type == \"max_coordinates\") {\n        // Generate random s of length n\n        string directions = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += directions[rnd.next(4)];\n        }\n        // Set a and b to maximum or minimum\n        a = rnd.next(0,1) ? 1000000000 : -1000000000;\n        b = rnd.next(0,1) ? 1000000000 : -1000000000;\n    } else if (type == \"cycle_movement\") {\n        // Generate s with net non-zero movement\n        int dx_total = 0, dy_total = 0;\n        do {\n            s.clear();\n            dx_total = 0; dy_total = 0;\n            for (int i = 0; i < n; ++i) {\n                char c = \"UDLR\"[rnd.next(4)];\n                s += c;\n                if (c == 'U') dy_total += 1;\n                else if (c == 'D') dy_total -= 1;\n                else if (c == 'L') dx_total -= 1;\n                else if (c == 'R') dx_total += 1;\n            }\n        } while (dx_total == 0 && dy_total == 0);\n\n        // Choose k to scale dx_total and dy_total to reach large positions\n        int k = rnd.next(1, 1000000);\n        a = dx_total * k;\n        b = dy_total * k;\n\n        // Optionally adjust a and b randomly within a small range to test edge cases\n        a += rnd.next(-100, 100);\n        b += rnd.next(-100, 100);\n\n        // Ensure a and b are within constraints\n        a = max(-1000000000, min(1000000000, a));\n        b = max(-1000000000, min(1000000000, b));\n    } else {\n        // Default to random\n        string directions = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += directions[rnd.next(4)];\n        }\n        a = rnd.next(-1000000000, 1000000000);\n        b = rnd.next(-1000000000, 1000000000);\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type only_one_direction\n./gen -n 1 -type zero_sum\n./gen -n 1 -type unreachable\n\n./gen -n 2 -type random\n./gen -n 2 -type only_one_direction\n./gen -n 2 -type zero_sum\n./gen -n 2 -type unreachable\n\n./gen -n 5 -type random\n./gen -n 5 -type cycle_movement\n./gen -n 5 -type zero_sum\n\n./gen -n 50 -type random\n./gen -n 50 -type only_one_direction\n./gen -n 50 -type zero_sum\n./gen -n 50 -type unreachable\n./gen -n 50 -type max_coordinates\n./gen -n 50 -type cycle_movement\n\n./gen -n 100 -type random\n./gen -n 100 -type only_one_direction\n./gen -n 100 -type zero_sum\n./gen -n 100 -type unreachable\n./gen -n 100 -type max_coordinates\n./gen -n 100 -type cycle_movement\n\n# Additional random test cases\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n\n# Edge cases with negative coordinates\n./gen -n 100 -type random\n./gen -n 100 -type unreachable\n\n# Test cases with maximum net movement per cycle\n./gen -n 100 -type cycle_movement\n\n# Test cases to validate net zero movement handling\n./gen -n 100 -type zero_sum\n\n# Small test cases with net zero movement\n./gen -n 2 -type zero_sum\n./gen -n 4 -type zero_sum\n\n# Test cases using only one type of movement\n./gen -n 20 -type only_one_direction\n./gen -n 50 -type only_one_direction\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:59.816818",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "321/B",
      "title": "B. Ciel and Duel",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 100) — the number of cards Jiro and Ciel have.Each of the next n lines contains a string position and an integer strength (0 ≤ strength ≤ 8000) — the position and strength of Jiro's current card. Position is the string \"ATK\" for attack, and the string \"DEF\" for defense.Each of the next m lines contains an integer strength (0 ≤ strength ≤ 8000) — the strength of Ciel's current card.",
      "output_spec": "OutputOutput an integer: the maximal damage Jiro can get.",
      "sample_tests": "ExamplesInputCopy2 3ATK 2000DEF 1700250025002500OutputCopy3000InputCopy3 4ATK 10ATK 100ATK 10001111011001OutputCopy992InputCopy2 4DEF 0ATK 00011OutputCopy1",
      "description": "B. Ciel and Duel\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 100) — the number of cards Jiro and Ciel have.Each of the next n lines contains a string position and an integer strength (0 ≤ strength ≤ 8000) — the position and strength of Jiro's current card. Position is the string \"ATK\" for attack, and the string \"DEF\" for defense.Each of the next m lines contains an integer strength (0 ≤ strength ≤ 8000) — the strength of Ciel's current card.\n\nOutputOutput an integer: the maximal damage Jiro can get.\n\nInputCopy2 3ATK 2000DEF 1700250025002500OutputCopy3000InputCopy3 4ATK 10ATK 100ATK 10001111011001OutputCopy992InputCopy2 4DEF 0ATK 00011OutputCopy1\n\nInputCopy2 3ATK 2000DEF 1700250025002500\n\nOutputCopy3000\n\nInputCopy3 4ATK 10ATK 100ATK 10001111011001\n\nOutputCopy992\n\nInputCopy2 4DEF 0ATK 00011\n\nOutputCopy1\n\nNoteIn the first test case, Ciel has 3 cards with same strength. The best strategy is as follows. First she uses one of these 3 cards to attack \"ATK 2000\" card first, this attack destroys that card and Jiro gets 2500 - 2000 = 500 damage. Then she uses the second card to destroy the \"DEF 1700\" card. Jiro doesn't get damage that time. Now Jiro has no cards so she can use the third card to attack and Jiro gets 2500 damage. So the answer is 500 + 2500 = 3000.In the second test case, she should use the \"1001\" card to attack the \"ATK 100\" card, then use the \"101\" card to attack the \"ATK 10\" card. Now Ciel still has cards but she can choose to end her battle phase. The total damage equals (1001 - 100) + (101 - 10) = 992.In the third test case note that she can destroy the \"ATK 0\" card by a card with strength equal to 0, but she can't destroy a \"DEF 0\" card with that card.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Hello, everyone!Do you want to train your skill by a contest before ACM/ICPC Finals?Codeforces Round #190 will take place on Friday, June 28th at 19:30 MSK. This is the last chance to practice, don't miss it!I am cgy4ever from China, and this is my first round on Codeforces, I hope you will love it.As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. I am the writer of them. And I would like to thank Gerald and sdya for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.Update 3: I have write a draft of editorial for this round when you are solving problems.You can read it here.Note that I didn't do any proof read and there are some typesetting issue. Anyway, I will improve it and this version is just for someone who is urgent to know the intended solutions.Update 4 Contest complete! This round will be rated!Congratulations to the winners:Div2: Baklazan phidnight kingofnumbers pawel.jasinski1986 Ronnoc Div1: YuukaKazami rng_58 Egor tmt514 chnlich And after this round, ivan.metelsky becomes our new International Grandmaster!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1505
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 321\\s*B"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string pos = inf.readToken(\"ATK|DEF\", \"position\");\n        inf.readSpace();\n        int strength = inf.readInt(0, 8000, \"Jiro's card strength\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; i++) {\n        int strength = inf.readInt(0, 8000, \"Ciel's card strength\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string pos = inf.readToken(\"ATK|DEF\", \"position\");\n        inf.readSpace();\n        int strength = inf.readInt(0, 8000, \"Jiro's card strength\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; i++) {\n        int strength = inf.readInt(0, 8000, \"Ciel's card strength\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string pos = inf.readToken(\"ATK|DEF\", \"position\");\n        inf.readSpace();\n        int strength = inf.readInt(0, 8000, \"Jiro's card strength\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; i++) {\n        int strength = inf.readInt(0, 8000, \"Ciel's card strength\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within [1,100]\n    n = max(1, min(100, n));\n    m = max(1, min(100, m));\n\n    vector<string> jiro_positions(n);\n    vector<int> jiro_strengths(n);\n    vector<int> ciel_strengths(m);\n\n    if (type == \"zeros\") {\n        // Strengths are zeros\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = 0;\n        }\n    } else if (type == \"max_strength\") {\n        // Strengths are 8000\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = 8000;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = 8000;\n        }\n    } else if (type == \"only_ATK\") {\n        // Jiro's cards are only ATK\n        for (int i = 0; i < n; ++i) {\n            jiro_positions[i] = \"ATK\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"only_DEF\") {\n        // Jiro's cards are only DEF\n        for (int i = 0; i < n; ++i) {\n            jiro_positions[i] = \"DEF\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"ascending_jiro_strengths\") {\n        // Jiro's strengths are ascending\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = i * (8000 / max(1, n -1));\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"descending_jiro_strengths\") {\n        // Jiro's strengths are descending\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = 8000 - i * (8000 / max(1, n -1));\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"matching_strengths\") {\n        // Ciel's strengths match Jiro's strengths\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        ciel_strengths = jiro_strengths;\n        // If m > n, fill extra strengths\n        for (int i = n; i < m; ++i) {\n            ciel_strengths.push_back(rnd.next(0, 8000));\n        }\n        // If m < n, truncate\n        ciel_strengths.resize(m);\n    } else {\n        // Default random case\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s %d\\n\", jiro_positions[i].c_str(), jiro_strengths[i]);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\\n\", ciel_strengths[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within [1,100]\n    n = max(1, min(100, n));\n    m = max(1, min(100, m));\n\n    vector<string> jiro_positions(n);\n    vector<int> jiro_strengths(n);\n    vector<int> ciel_strengths(m);\n\n    if (type == \"zeros\") {\n        // Strengths are zeros\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = 0;\n        }\n    } else if (type == \"max_strength\") {\n        // Strengths are 8000\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = 8000;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = 8000;\n        }\n    } else if (type == \"only_ATK\") {\n        // Jiro's cards are only ATK\n        for (int i = 0; i < n; ++i) {\n            jiro_positions[i] = \"ATK\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"only_DEF\") {\n        // Jiro's cards are only DEF\n        for (int i = 0; i < n; ++i) {\n            jiro_positions[i] = \"DEF\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"ascending_jiro_strengths\") {\n        // Jiro's strengths are ascending\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = i * (8000 / max(1, n -1));\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"descending_jiro_strengths\") {\n        // Jiro's strengths are descending\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = 8000 - i * (8000 / max(1, n -1));\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    } else if (type == \"matching_strengths\") {\n        // Ciel's strengths match Jiro's strengths\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        ciel_strengths = jiro_strengths;\n        // If m > n, fill extra strengths\n        for (int i = n; i < m; ++i) {\n            ciel_strengths.push_back(rnd.next(0, 8000));\n        }\n        // If m < n, truncate\n        ciel_strengths.resize(m);\n    } else {\n        // Default random case\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(2);\n            jiro_positions[i] = pos == 0 ? \"ATK\" : \"DEF\";\n            jiro_strengths[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strengths[i] = rnd.next(0, 8000);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s %d\\n\", jiro_positions[i].c_str(), jiro_strengths[i]);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\\n\", ciel_strengths[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type zeros\n./gen -n 1 -m 1 -type max_strength\n./gen -n 1 -m 1 -type only_ATK\n./gen -n 1 -m 1 -type only_DEF\n./gen -n 1 -m 1 -type matching_strengths\n\n./gen -n 10 -m 10 -type zeros\n./gen -n 10 -m 10 -type max_strength\n./gen -n 10 -m 10 -type only_ATK\n./gen -n 10 -m 10 -type only_DEF\n./gen -n 10 -m 10 -type matching_strengths\n./gen -n 10 -m 10 -type ascending_jiro_strengths\n./gen -n 10 -m 10 -type descending_jiro_strengths\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 70 -type matching_strengths\n./gen -n 50 -m 30 -type matching_strengths\n\n./gen -n 100 -m 100 -type zeros\n./gen -n 100 -m 100 -type max_strength\n./gen -n 100 -m 100 -type only_ATK\n./gen -n 100 -m 100 -type only_DEF\n./gen -n 100 -m 100 -type ascending_jiro_strengths\n./gen -n 100 -m 100 -type descending_jiro_strengths\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 80 -type random\n./gen -n 80 -m 100 -type random\n\n./gen -n 99 -m 1 -type random\n./gen -n 1 -m 99 -type random\n./gen -n 100 -m 1 -type only_ATK\n./gen -n 1 -m 100 -type only_DEF\n\n./gen -n 2 -m 2 -type matching_strengths\n./gen -n 2 -m 2 -type zeros\n./gen -n 2 -m 2 -type max_strength\n\n./gen -n 1 -m 100 -type zeros\n./gen -n 100 -m 1 -type max_strength\n./gen -n 50 -m 100 -type only_ATK\n./gen -n 100 -m 50 -type only_DEF\n\n./gen -n 70 -m 100 -type ascending_jiro_strengths\n./gen -n 100 -m 70 -type descending_jiro_strengths\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:01.517953",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "321/C",
      "title": "C. Ciel the Commander",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (2 ≤ n ≤ 105) — the number of cities in Tree Land.Each of the following n - 1 lines contains two integers a and b (1 ≤ a, b ≤ n, a ≠ b) — they mean that there will be an undirected road between a and b. Consider all the cities are numbered from 1 to n.It guaranteed that the given graph will be a tree.",
      "output_spec": "OutputIf there is a valid plane, output n space-separated characters in a line — i-th character is the rank of officer in the city with number i. Otherwise output \"Impossible!\".",
      "sample_tests": "ExamplesInputCopy41 21 31 4OutputCopyA B B BInputCopy101 22 33 44 55 66 77 88 99 10OutputCopyD C B A D C B D C D",
      "description": "C. Ciel the Commander\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (2 ≤ n ≤ 105) — the number of cities in Tree Land.Each of the following n - 1 lines contains two integers a and b (1 ≤ a, b ≤ n, a ≠ b) — they mean that there will be an undirected road between a and b. Consider all the cities are numbered from 1 to n.It guaranteed that the given graph will be a tree.\n\nOutputIf there is a valid plane, output n space-separated characters in a line — i-th character is the rank of officer in the city with number i. Otherwise output \"Impossible!\".\n\nInputCopy41 21 31 4OutputCopyA B B BInputCopy101 22 33 44 55 66 77 88 99 10OutputCopyD C B A D C B D C D\n\nInputCopy41 21 31 4\n\nOutputCopyA B B B\n\nInputCopy101 22 33 44 55 66 77 88 99 10\n\nOutputCopyD C B A D C B D C D\n\nNoteIn the first example, for any two officers of rank 'B', an officer with rank 'A' will be on the path between them. So it is a valid solution.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Hello, everyone!Do you want to train your skill by a contest before ACM/ICPC Finals?Codeforces Round #190 will take place on Friday, June 28th at 19:30 MSK. This is the last chance to practice, don't miss it!I am cgy4ever from China, and this is my first round on Codeforces, I hope you will love it.As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. I am the writer of them. And I would like to thank Gerald and sdya for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.Update 3: I have write a draft of editorial for this round when you are solving problems.You can read it here.Note that I didn't do any proof read and there are some typesetting issue. Anyway, I will improve it and this version is just for someone who is urgent to know the intended solutions.Update 4 Contest complete! This round will be rated!Congratulations to the winners:Div2: Baklazan phidnight kingofnumbers pawel.jasinski1986 Ronnoc Div1: YuukaKazami rng_58 Egor tmt514 chnlich And after this round, ivan.metelsky becomes our new International Grandmaster!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1505
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 321\\s*C"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> edgeSet;\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d connects node to itself\", i + 1);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edgeSet.insert({u, v}).second, \"Duplicate edge between %d and %d\", u, v);\n\n        int pu = find(a);\n        int pv = find(b);\n        ensuref(pu != pv, \"Graph contains a cycle between %d and %d\", a, b);\n        parent[pu] = pv;\n    }\n\n    // Check that all nodes belong to the same connected component\n    int comp = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == comp, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> edgeSet;\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d connects node to itself\", i + 1);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edgeSet.insert({u, v}).second, \"Duplicate edge between %d and %d\", u, v);\n\n        int pu = find(a);\n        int pv = find(b);\n        ensuref(pu != pv, \"Graph contains a cycle between %d and %d\", a, b);\n        parent[pu] = pv;\n    }\n\n    // Check that all nodes belong to the same connected component\n    int comp = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == comp, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> edgeSet;\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d connects node to itself\", i + 1);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edgeSet.insert({u, v}).second, \"Duplicate edge between %d and %d\", u, v);\n\n        int pu = find(a);\n        int pv = find(b);\n        ensuref(pu != pv, \"Graph contains a cycle between %d and %d\", a, b);\n        parent[pu] = pv;\n    }\n\n    // Check that all nodes belong to the same connected component\n    int comp = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == comp, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid readTree(InStream& inf, int n, vector<pair<int, int>>& edges) {\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n);\n        int v = inf.readInt(1, n);\n        edges.emplace_back(u, v);\n    }\n}\n\nbool readAssignment(InStream& stream, int n, vector<char>& assignment) {\n    string s = stream.readToken();\n    if (s == \"Impossible!\") {\n        return false;\n    } else {\n        assignment.resize(n + 1); // Nodes are numbered from 1 to n\n        vector<string> tokens;\n        tokens.push_back(s);\n        while ((int)tokens.size() < n) {\n            tokens.push_back(stream.readToken());\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (tokens[i - 1].size() != 1 || tokens[i - 1][0] < 'A' || tokens[i - 1][0] > 'Z') {\n                stream.quitf(_pe, \"Invalid rank at position %d: %s\", i, tokens[i - 1].c_str());\n            }\n            assignment[i] = tokens[i - 1][0];\n        }\n        return true;\n    }\n}\n\nvoid checkValidity(InStream& stream, const vector<pair<int, int>>& edges, const vector<char>& assignment) {\n    for (auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        if (assignment[u] == assignment[v]) {\n            stream.quitf(_wa, \"Edge between nodes %d and %d has same rank '%c'\", u, v, assignment[u]);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    vector<pair<int, int>> edges;\n    readTree(inf, n, edges);\n\n    bool jury_possible, participant_possible;\n    vector<char> jury_assignment, participant_assignment;\n\n    if (!readAssignment(ans, n, jury_assignment)) {\n        // Jury's answer is \"Impossible!\"\n        jury_possible = false;\n    } else {\n        jury_possible = true;\n        // Check validity\n        checkValidity(ans, edges, jury_assignment); // If invalid, ans.quitf(_fail,...)\n    }\n\n    if (!readAssignment(ouf, n, participant_assignment)) {\n        // Participant's answer is \"Impossible!\"\n        participant_possible = false;\n        if (!jury_possible) {\n            // Both impossible\n            quitf(_ok, \"Both outputs are Impossible!\");\n        } else {\n            // Participant says impossible, jury has valid assignment\n            quitf(_wa, \"Participant outputs Impossible! but jury has a valid assignment\");\n        }\n    } else {\n        participant_possible = true;\n        // Check validity\n        checkValidity(ouf, edges, participant_assignment); // If invalid, ouf.quitf(_wa,...)\n        if (!jury_possible) {\n            // Participant has assignment, jury says impossible\n            quitf(_fail, \"Participant found a valid assignment but jury said Impossible!\");\n        } else {\n            // Both have assignments\n            // No need to compare assignments since multiple valid assignments exist\n            quitf(_ok, \"Participant's assignment is valid\");\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Create a chain (path) graph\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i -1, i});\n    } else if (type == \"star\") {\n        // Create a star graph\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"balanced\") {\n        // Create a balanced binary tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i / 2, i});\n    } else if (type == \"caterpillar\") {\n        // Create a caterpillar tree\n        int backboneLength = max(1, n / 2);\n        for (int i = 2; i <= backboneLength; ++i)\n            edges.push_back({i - 1, i});\n        for (int i = backboneLength + 1; i <= n; ++i) {\n            int backboneNode = rnd.next(1, backboneLength);\n            edges.push_back({backboneNode, i});\n        }\n    } else if (type == \"two_paths\") {\n        // Create two long paths connected at node 1\n        int mid = n / 2;\n        for (int i = 2; i <= mid; ++i)\n            edges.push_back({i - 1, i});\n        for (int i = mid + 1; i <= n; ++i)\n            edges.push_back({mid, i});\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Create a chain (path) graph\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i -1, i});\n    } else if (type == \"star\") {\n        // Create a star graph\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"balanced\") {\n        // Create a balanced binary tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i / 2, i});\n    } else if (type == \"caterpillar\") {\n        // Create a caterpillar tree\n        int backboneLength = max(1, n / 2);\n        for (int i = 2; i <= backboneLength; ++i)\n            edges.push_back({i - 1, i});\n        for (int i = backboneLength + 1; i <= n; ++i) {\n            int backboneNode = rnd.next(1, backboneLength);\n            edges.push_back({backboneNode, i});\n        }\n    } else if (type == \"two_paths\") {\n        // Create two long paths connected at node 1\n        int mid = n / 2;\n        for (int i = 2; i <= mid; ++i)\n            edges.push_back({i - 1, i});\n        for (int i = mid + 1; i <= n; ++i)\n            edges.push_back({mid, i});\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type balanced\n./gen -n 2 -type random\n./gen -n 2 -type caterpillar\n./gen -n 2 -type two_paths\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type balanced\n./gen -n 10 -type random\n./gen -n 10 -type caterpillar\n./gen -n 10 -type two_paths\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type balanced\n./gen -n 100 -type random\n./gen -n 100 -type caterpillar\n./gen -n 100 -type two_paths\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type balanced\n./gen -n 1000 -type random\n./gen -n 1000 -type caterpillar\n./gen -n 1000 -type two_paths\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type balanced\n./gen -n 10000 -type random\n./gen -n 10000 -type caterpillar\n./gen -n 10000 -type two_paths\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type balanced\n./gen -n 100000 -type random\n./gen -n 100000 -type caterpillar\n./gen -n 100000 -type two_paths\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:03.598881",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "321/D",
      "title": "D. Ciel и доска",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n, (1 ≤ n ≤ 33, и n — нечетное число) — размер таблицы.В каждой из следующих n строк записано n целых чисел — числа, записанные на доске. Каждое число не превышает по модулю 1000.",
      "output_spec": "Выходные данныеВыведите единственное целое число: максимальную достижимую сумму чисел на доске.",
      "sample_tests": "ПримерыВходные данныеСкопировать3-1 -1 1-1 1 -11 -1 -1Выходные данныеСкопировать9Входные данныеСкопировать5-2 0 0 0 -20 -2 0 -2 00 0 -2 0 00 -2 0 -2 0-2 0 0 0 -2Выходные данныеСкопировать18",
      "description": "D. Ciel и доска\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n, (1 ≤ n ≤ 33, и n — нечетное число) — размер таблицы.В каждой из следующих n строк записано n целых чисел — числа, записанные на доске. Каждое число не превышает по модулю 1000.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число: максимальную достижимую сумму чисел на доске.\n\nВыходные данные\n\nВходные данныеСкопировать3-1 -1 1-1 1 -11 -1 -1Выходные данныеСкопировать9Входные данныеСкопировать5-2 0 0 0 -20 -2 0 -2 00 0 -2 0 00 -2 0 -2 0-2 0 0 0 -2Выходные данныеСкопировать18\n\nВходные данныеСкопировать3-1 -1 1-1 1 -11 -1 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5-2 0 0 0 -20 -2 0 -2 00 0 -2 0 00 -2 0 -2 0-2 0 0 0 -2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать18\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте можно применить операцию дважды: сперва на подтаблице размера 2 × 2 в левом верхнем углу, затем — на подтаблице размера 2 × 2 в правом нижнем углу. Тогда все числа станут положительными.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Привет всем!Не хотите ли Вы потренироваться перед предстоящим контестом ACM/ICPC Finals?Codeforces Round #190 пройдет в пятницу, 28-го июня, в 19:30 MSK. Это последний шанс потренироваться перед финалом, не упустите его!Я cgy4ever из Китая, и это мой первый раунд Codeforces. Я надеюсь, он понравится вам.Как обычно, будет 7 задач: 2 для Div2, 2 для Div1 и 3 для обоих дивизионов. Я готовил эти задачи. Хотелось бы поблагодарить Gerald и sdya за тестирование задач, и MikeMirzayanov за проект Codeforces и Polygon.Удачи и фана вам на раунде!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 933
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 321\\s*D"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 33, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be an odd integer\");\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"row\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 33, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be an odd integer\");\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"row\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 33, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be an odd integer\");\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"row\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000);\n\n    if (n < 1 || n > 33)\n        quitf(_fail, \"n is out of bounds (1 ≤ n ≤ 33)\");\n\n    if (n % 2 == 0)\n        quitf(_fail, \"n must be an odd integer\");\n\n    if (max_value < 1 || max_value > 1000)\n        quitf(_fail, \"max_value must be between 1 and 1000\");\n\n    vector<vector<int>> grid(n, vector<int>(n));\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = rnd.next(-max_value, max_value);\n                grid[i][j] = val;\n            }\n        }\n    } else if (type == \"all_positive\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = rnd.next(1, max_value);\n                grid[i][j] = val;\n            }\n        }\n    } else if (type == \"all_negative\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = -rnd.next(1, max_value);\n                grid[i][j] = val;\n            }\n        }\n    } else if (type == \"zeros\") {\n        // grid is already initialized to zeros\n    } else if (type == \"checkerboard\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = rnd.next(1, max_value);\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = val;\n                else\n                    grid[i][j] = -val;\n            }\n        }\n    } else if (type == \"max\") {\n        // Fill with max_value and -max_value\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = max_value;\n                else\n                    grid[i][j] = -max_value;\n            }\n        }\n    } else if (type == \"special1\") {\n        // All numbers are -max_value, except center cell is max_value\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                grid[i][j] = -max_value;\n            }\n        }\n        grid[n/2][n/2] = max_value;\n    } else if (type == \"special2\") {\n        // Numbers increase from -max_value to max_value in a specific pattern\n        int val = -max_value;\n        int total_cells = n * n;\n        int increment = (2 * max_value) / max(1, total_cells - 1);\n        if (increment == 0) increment = 1;\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                grid[i][j] = val;\n                val += increment;\n                if (val > max_value) val = max_value;\n            }\n        }\n    } else if (type == \"spiral\") {\n        // Fill the grid with numbers in a spiral\n        int val = -max_value;\n        int i_min = 0, i_max = n - 1;\n        int j_min = 0, j_max = n - 1;\n        while (i_min <= i_max && j_min <= j_max) {\n            for (int j = j_min; j <= j_max; ++j) {\n                grid[i_min][j] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            for (int i = i_min + 1; i <= i_max; ++i) {\n                grid[i][j_max] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            for (int j = j_max - 1; j >= j_min; --j) {\n                grid[i_max][j] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            for (int i = i_max - 1; i > i_min; --i) {\n                grid[i][j_min] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            ++i_min; --i_max; ++j_min; --j_max;\n        }\n    } else {\n        quitf(_fail, \"Unknown type '%s'\", type.c_str());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output grid\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000);\n\n    if (n < 1 || n > 33)\n        quitf(_fail, \"n is out of bounds (1 ≤ n ≤ 33)\");\n\n    if (n % 2 == 0)\n        quitf(_fail, \"n must be an odd integer\");\n\n    if (max_value < 1 || max_value > 1000)\n        quitf(_fail, \"max_value must be between 1 and 1000\");\n\n    vector<vector<int>> grid(n, vector<int>(n));\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = rnd.next(-max_value, max_value);\n                grid[i][j] = val;\n            }\n        }\n    } else if (type == \"all_positive\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = rnd.next(1, max_value);\n                grid[i][j] = val;\n            }\n        }\n    } else if (type == \"all_negative\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = -rnd.next(1, max_value);\n                grid[i][j] = val;\n            }\n        }\n    } else if (type == \"zeros\") {\n        // grid is already initialized to zeros\n    } else if (type == \"checkerboard\") {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                int val = rnd.next(1, max_value);\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = val;\n                else\n                    grid[i][j] = -val;\n            }\n        }\n    } else if (type == \"max\") {\n        // Fill with max_value and -max_value\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = max_value;\n                else\n                    grid[i][j] = -max_value;\n            }\n        }\n    } else if (type == \"special1\") {\n        // All numbers are -max_value, except center cell is max_value\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                grid[i][j] = -max_value;\n            }\n        }\n        grid[n/2][n/2] = max_value;\n    } else if (type == \"special2\") {\n        // Numbers increase from -max_value to max_value in a specific pattern\n        int val = -max_value;\n        int total_cells = n * n;\n        int increment = (2 * max_value) / max(1, total_cells - 1);\n        if (increment == 0) increment = 1;\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                grid[i][j] = val;\n                val += increment;\n                if (val > max_value) val = max_value;\n            }\n        }\n    } else if (type == \"spiral\") {\n        // Fill the grid with numbers in a spiral\n        int val = -max_value;\n        int i_min = 0, i_max = n - 1;\n        int j_min = 0, j_max = n - 1;\n        while (i_min <= i_max && j_min <= j_max) {\n            for (int j = j_min; j <= j_max; ++j) {\n                grid[i_min][j] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            for (int i = i_min + 1; i <= i_max; ++i) {\n                grid[i][j_max] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            for (int j = j_max - 1; j >= j_min; --j) {\n                grid[i_max][j] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            for (int i = i_max - 1; i > i_min; --i) {\n                grid[i][j_min] = val;\n                val += 1;\n                if (val > max_value) val = -max_value;\n            }\n            ++i_min; --i_max; ++j_min; --j_max;\n        }\n    } else {\n        quitf(_fail, \"Unknown type '%s'\", type.c_str());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output grid\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_positive\n./gen -n 1 -type all_negative\n./gen -n 1 -type zeros\n\n./gen -n 3 -type random\n./gen -n 3 -type checkerboard\n./gen -n 3 -type max\n./gen -n 3 -type special1\n\n./gen -n 7 -type spiral\n\n./gen -n 9 -type random -max_value 1\n./gen -n 9 -type random -max_value 500\n./gen -n 9 -type random -max_value 999\n\n./gen -n 11 -type random\n./gen -n 11 -type all_positive\n./gen -n 11 -type all_negative\n./gen -n 11 -type checkerboard\n\n./gen -n 15 -type special1\n./gen -n 15 -type special2\n./gen -n 15 -type spiral\n\n./gen -n 17 -type special2\n\n./gen -n 25 -type zeros\n./gen -n 25 -type random\n./gen -n 25 -type random -max_value 1000\n\n./gen -n 31 -type all_positive -max_value 1000\n./gen -n 31 -type all_negative -max_value 1000\n./gen -n 31 -type checkerboard -max_value 1000\n\n./gen -n 33 -type random\n./gen -n 33 -type checkerboard\n./gen -n 33 -type max\n./gen -n 33 -type zeros\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:05.612596",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "321/E",
      "title": "E. Ciel and Gondolas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 4000 and 1 ≤ k ≤ min(n, 800)) — the number of people in the queue and the number of gondolas. Each of the following n lines contains n integers — matrix u, (0 ≤ uij ≤ 9, uij = uji and uii = 0).Please, use fast input methods (for example, please use BufferedReader instead of Scanner for Java).",
      "output_spec": "OutputPrint an integer — the minimal possible total unfamiliar value.",
      "sample_tests": "ExamplesInputCopy5 20 0 1 1 10 0 1 1 11 1 0 0 01 1 0 0 01 1 0 0 0OutputCopy0InputCopy8 30 1 1 1 1 1 1 11 0 1 1 1 1 1 11 1 0 1 1 1 1 11 1 1 0 1 1 1 11 1 1 1 0 1 1 11 1 1 1 1 0 1 11 1 1 1 1 1 0 11 1 1 1 1 1 1 0OutputCopy7InputCopy3 20 2 02 0 30 3 0OutputCopy2",
      "description": "E. Ciel and Gondolas\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 4000 and 1 ≤ k ≤ min(n, 800)) — the number of people in the queue and the number of gondolas. Each of the following n lines contains n integers — matrix u, (0 ≤ uij ≤ 9, uij = uji and uii = 0).Please, use fast input methods (for example, please use BufferedReader instead of Scanner for Java).\n\nOutputPrint an integer — the minimal possible total unfamiliar value.\n\nInputCopy5 20 0 1 1 10 0 1 1 11 1 0 0 01 1 0 0 01 1 0 0 0OutputCopy0InputCopy8 30 1 1 1 1 1 1 11 0 1 1 1 1 1 11 1 0 1 1 1 1 11 1 1 0 1 1 1 11 1 1 1 0 1 1 11 1 1 1 1 0 1 11 1 1 1 1 1 0 11 1 1 1 1 1 1 0OutputCopy7InputCopy3 20 2 02 0 30 3 0OutputCopy2\n\nInputCopy5 20 0 1 1 10 0 1 1 11 1 0 0 01 1 0 0 01 1 0 0 0\n\nOutputCopy0\n\nInputCopy8 30 1 1 1 1 1 1 11 0 1 1 1 1 1 11 1 0 1 1 1 1 11 1 1 0 1 1 1 11 1 1 1 0 1 1 11 1 1 1 1 0 1 11 1 1 1 1 1 0 11 1 1 1 1 1 1 0\n\nOutputCopy7\n\nInputCopy3 20 2 02 0 30 3 0\n\nOutputCopy2\n\nNoteIn the first example, we can allocate people like this: {1, 2} goes into a gondolas, {3, 4, 5} goes into another gondolas.In the second example, an optimal solution is : {1, 2, 3} | {4, 5, 6} | {7, 8}.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Hello, everyone!Do you want to train your skill by a contest before ACM/ICPC Finals?Codeforces Round #190 will take place on Friday, June 28th at 19:30 MSK. This is the last chance to practice, don't miss it!I am cgy4ever from China, and this is my first round on Codeforces, I hope you will love it.As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. I am the writer of them. And I would like to thank Gerald and sdya for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.Update 3: I have write a draft of editorial for this round when you are solving problems.You can read it here.Note that I didn't do any proof read and there are some typesetting issue. Anyway, I will improve it and this version is just for someone who is urgent to know the intended solutions.Update 4 Contest complete! This round will be rated!Congratulations to the winners:Div2: Baklazan phidnight kingofnumbers pawel.jasinski1986 Ronnoc Div1: YuukaKazami rng_58 Egor tmt514 chnlich And after this round, ivan.metelsky becomes our new International Grandmaster!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1505
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 321\\s*E"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000);\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 800));\n    inf.readEoln();\n\n    vector<vector<int>> u(n);\n\n    for (int i = 0; i < n; ++i) {\n\n        vector<int> row = inf.readInts(n, 0, 9);\n        inf.readEoln();\n\n        for (int j = 0; j < n; ++j) {\n\n            int val = row[j];\n\n            if (i == j) {\n                ensuref(val == 0, \"u[%d][%d] must be 0\", i + 1, j + 1);\n            } else if (i > j) {\n                ensuref(val == u[j][i], \"u[%d][%d] must be equal to u[%d][%d]\", i + 1, j + 1, j + 1, i + 1);\n            }\n\n        }\n\n        u[i] = row;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000);\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 800));\n    inf.readEoln();\n\n    vector<vector<int>> u(n);\n\n    for (int i = 0; i < n; ++i) {\n\n        vector<int> row = inf.readInts(n, 0, 9);\n        inf.readEoln();\n\n        for (int j = 0; j < n; ++j) {\n\n            int val = row[j];\n\n            if (i == j) {\n                ensuref(val == 0, \"u[%d][%d] must be 0\", i + 1, j + 1);\n            } else if (i > j) {\n                ensuref(val == u[j][i], \"u[%d][%d] must be equal to u[%d][%d]\", i + 1, j + 1, j + 1, i + 1);\n            }\n\n        }\n\n        u[i] = row;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000);\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 800));\n    inf.readEoln();\n\n    vector<vector<int>> u(n);\n\n    for (int i = 0; i < n; ++i) {\n\n        vector<int> row = inf.readInts(n, 0, 9);\n        inf.readEoln();\n\n        for (int j = 0; j < n; ++j) {\n\n            int val = row[j];\n\n            if (i == j) {\n                ensuref(val == 0, \"u[%d][%d] must be 0\", i + 1, j + 1);\n            } else if (i > j) {\n                ensuref(val == u[j][i], \"u[%d][%d] must be equal to u[%d][%d]\", i + 1, j + 1, j + 1, i + 1);\n            }\n\n        }\n\n        u[i] = row;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"c\", -1); // Optional parameter for \"constant\" type\n    int density = opt<int>(\"density\", 10); // Optional parameter for \"random_sparse\" type\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<vector<int>> u(n, vector<int>(n, 0));\n\n    if (type == \"zeros\") {\n        // uij = 0 for all i != j\n        // uii = 0 already initialized\n    } else if (type == \"max\") {\n        // uij = 9 for all i != j\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = 9;\n    } else if (type == \"constant\") {\n        // uij = c for all i != j\n        if (c == -1) c = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = c;\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = min(9, (i + j) % 10);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = max(0, (n - i - j) % 10);\n    } else if (type == \"mod\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    u[i][j] = abs(i - j) % 10;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                u[i][j] = rnd.next(10); // 0 to 9\n                u[j][i] = u[i][j];\n            }\n    } else if (type == \"random_sparse\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (rnd.next(100) < density) {\n                    u[i][j] = rnd.next(10);\n                } else {\n                    u[i][j] = 0;\n                }\n                u[j][i] = u[i][j];\n            }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d%c\", u[i][j], j + 1 == n ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"c\", -1); // Optional parameter for \"constant\" type\n    int density = opt<int>(\"density\", 10); // Optional parameter for \"random_sparse\" type\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<vector<int>> u(n, vector<int>(n, 0));\n\n    if (type == \"zeros\") {\n        // uij = 0 for all i != j\n        // uii = 0 already initialized\n    } else if (type == \"max\") {\n        // uij = 9 for all i != j\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = 9;\n    } else if (type == \"constant\") {\n        // uij = c for all i != j\n        if (c == -1) c = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = c;\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = min(9, (i + j) % 10);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                u[i][j] = u[j][i] = max(0, (n - i - j) % 10);\n    } else if (type == \"mod\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    u[i][j] = abs(i - j) % 10;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                u[i][j] = rnd.next(10); // 0 to 9\n                u[j][i] = u[i][j];\n            }\n    } else if (type == \"random_sparse\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (rnd.next(100) < density) {\n                    u[i][j] = rnd.next(10);\n                } else {\n                    u[i][j] = 0;\n                }\n                u[j][i] = u[i][j];\n            }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d%c\", u[i][j], j + 1 == n ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type zeros\n./gen -n 1 -k 1 -type max\n./gen -n 1 -k 1 -type random\n\n./gen -n 2 -k 1 -type zeros\n./gen -n 2 -k 2 -type zeros\n\n./gen -n 2 -k 1 -type max\n./gen -n 2 -k 2 -type max\n\n./gen -n 3 -k 2 -type random\n\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 10 -type random\n\n./gen -n 100 -k 1 -type random\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 100 -type random\n\n./gen -n 1000 -k 1 -type zeros\n./gen -n 1000 -k 1000 -type zeros\n\n./gen -n 2000 -k 1 -type max\n./gen -n 2000 -k 2000 -type max\n\n./gen -n 4000 -k 1 -type zeros\n./gen -n 4000 -k 1 -type max\n./gen -n 4000 -k 1 -type random\n\n./gen -n 4000 -k 800 -type random\n./gen -n 4000 -k 800 -type zeros\n./gen -n 4000 -k 800 -type max\n\n./gen -n 4000 -k 4000 -type zeros\n./gen -n 4000 -k 4000 -type max\n./gen -n 4000 -k 3999 -type random\n\n./gen -n 4000 -k 1 -type increasing\n./gen -n 4000 -k 1 -type decreasing\n\n./gen -n 4000 -k 800 -type constant -c 5\n\n./gen -n 4000 -k 500 -type random_sparse -density 5\n./gen -n 4000 -k 500 -type random_sparse -density 95\n\n./gen -n 3000 -k 700 -type mod\n\n./gen -n 4000 -k 1 -type random\n./gen -n 4000 -k 800 -type random\n\n./gen -n 3999 -k 1 -type random\n./gen -n 3999 -k 800 -type random\n\n./gen -n 4000 -k 799 -type random\n\n./gen -n 4000 -k 2 -type random\n\n./gen -n 4000 -k 4000 -type random\n\n./gen -n 4000 -k 4000 -type constant -c 1\n\n./gen -n 4000 -k 1 -type constant -c 9\n\n./gen -n 4000 -k 4000 -type increasing\n\n./gen -n 4000 -k 4000 -type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:07.288037",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "322/A",
      "title": "A. Сiel и танцы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 100) — количество мальчиков и девочек в танцевальной комнате.",
      "output_spec": "Выходные данныеВ первой строке выведите k — количество песен, которые можно будет протанцевать. Затем на следующих k строках выведите порядковые номера мальчиков и девочек, танцующих во время песен, в хронологическом порядке. Считайте, что мальчики пронумерованы от 1 до n, а девочки пронумерованы от 1 до m.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 1Выходные данныеСкопировать21 12 1Входные данныеСкопировать2 2Выходные данныеСкопировать31 11 22 2",
      "description": "A. Сiel и танцы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 100) — количество мальчиков и девочек в танцевальной комнате.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите k — количество песен, которые можно будет протанцевать. Затем на следующих k строках выведите порядковые номера мальчиков и девочек, танцующих во время песен, в хронологическом порядке. Считайте, что мальчики пронумерованы от 1 до n, а девочки пронумерованы от 1 до m.\n\nВыходные данные\n\nВходные данныеСкопировать2 1Выходные данныеСкопировать21 12 1Входные данныеСкопировать2 2Выходные данныеСкопировать31 11 22 2\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 12 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 11 22 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте есть 2 мальчика и 1 девочка. Можно провести 2 танца: 1-ый мальчик и 1-ая девочка (во время первой песни), 2-ой мальчик и 1-ая девочка (во время второй песни).Во втором тесте есть 2 мальчика и 2 девочки, ответ — 3.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Привет всем!Не хотите ли Вы потренироваться перед предстоящим контестом ACM/ICPC Finals?Codeforces Round #190 пройдет в пятницу, 28-го июня, в 19:30 MSK. Это последний шанс потренироваться перед финалом, не упустите его!Я cgy4ever из Китая, и это мой первый раунд Codeforces. Я надеюсь, он понравится вам.Как обычно, будет 7 задач: 2 для Div2, 2 для Div1 и 3 для обоих дивизионов. Я готовил эти задачи. Хотелось бы поблагодарить Gerald и sdya за тестирование задач, и MikeMirzayanov за проект Codeforces и Polygon.Удачи и фана вам на раунде!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 933
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 322\\s*A"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint readAns(InStream& stream, int n, int m, const char* who) {\n    int max_k = n * m;\n    int k = stream.readInt(0, max_k, format(\"%s's k\", who).c_str());\n    vector<bool> boy_danced(n + 1, false);\n    vector<bool> girl_danced(m + 1, false);\n    for (int i = 1; i <= k; ++i) {\n        int b = stream.readInt(1, n, format(\"%s's boy index at line %d\", who, i + 1).c_str());\n        int g = stream.readInt(1, m, format(\"%s's girl index at line %d\", who, i + 1).c_str());\n        if (boy_danced[b] && girl_danced[g]) {\n            stream.quitf(_wa, \"%s's schedule violates the rule at song %d: both boy %d and girl %d have danced before\", who, i, b, g);\n        }\n        boy_danced[b] = true;\n        girl_danced[g] = true;\n    }\n    return k;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and m from input file\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    // Read and validate jury's answer\n    int k_jury = readAns(ans, n, m, \"jury\");\n\n    // Read and validate contestant's answer\n    int k_contestant = readAns(ouf, n, m, \"contestant\");\n\n    if (k_contestant > k_jury)\n        quitf(_fail, \"Contestant's answer is better than the jury's: k_contestant = %d, k_jury = %d\", k_contestant, k_jury);\n    else if (k_contestant < k_jury)\n        quitf(_wa, \"Contestant's number of dances is less than required: k_contestant = %d, k_jury = %d\", k_contestant, k_jury);\n    else\n        quitf(_ok, \"Correct schedule with k = %d\", k_contestant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"fixed\");\n    int n, m;\n    if(type == \"random\") {\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n    } else if(type == \"min\") {\n        n = m = 1;\n    } else if(type == \"max_equal\") {\n        n = m = 100;\n    } else if(type == \"max_n\") {\n        n = 100;\n        m = rnd.next(1, 99);\n    } else if(type == \"max_m\") {\n        m = 100;\n        n = rnd.next(1, 99);\n    } else if(type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n    } else if(type == \"n_eq_m\") {\n        n = m = rnd.next(1, 100);\n    } else if(type == \"n_gt_m\") {\n        m = rnd.next(1, 99);\n        n = rnd.next(m+1, 100);\n    } else if(type == \"m_gt_n\") {\n        n = rnd.next(1, 99);\n        m = rnd.next(n+1, 100);\n    } else if(type == \"n_eq_1\") {\n        n = 1;\n        m = rnd.next(1, 100);\n    } else if(type == \"m_eq_1\") {\n        m = 1;\n        n = rnd.next(1, 100);\n    } else if(type == \"fixed\") {\n        n = opt<int>(\"n\");\n        m = opt<int>(\"m\");\n    } else {\n        // Default to random\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n    }\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"fixed\");\n    int n, m;\n    if(type == \"random\") {\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n    } else if(type == \"min\") {\n        n = m = 1;\n    } else if(type == \"max_equal\") {\n        n = m = 100;\n    } else if(type == \"max_n\") {\n        n = 100;\n        m = rnd.next(1, 99);\n    } else if(type == \"max_m\") {\n        m = 100;\n        n = rnd.next(1, 99);\n    } else if(type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n    } else if(type == \"n_eq_m\") {\n        n = m = rnd.next(1, 100);\n    } else if(type == \"n_gt_m\") {\n        m = rnd.next(1, 99);\n        n = rnd.next(m+1, 100);\n    } else if(type == \"m_gt_n\") {\n        n = rnd.next(1, 99);\n        m = rnd.next(n+1, 100);\n    } else if(type == \"n_eq_1\") {\n        n = 1;\n        m = rnd.next(1, 100);\n    } else if(type == \"m_eq_1\") {\n        m = 1;\n        n = rnd.next(1, 100);\n    } else if(type == \"fixed\") {\n        n = opt<int>(\"n\");\n        m = opt<int>(\"m\");\n    } else {\n        // Default to random\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n    }\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max_equal\n\n./gen -type max_n\n\n./gen -type max_m\n\n./gen -type n_eq_m\n\n./gen -type n_eq_m\n\n./gen -type n_eq_m\n\n./gen -type n_eq_1\n\n./gen -type m_eq_1\n\n./gen -type n_gt_m\n\n./gen -type m_gt_n\n\n./gen -type small\n\n./gen -type small\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -n 1 -m 2 -type fixed\n\n./gen -n 2 -m 1 -type fixed\n\n./gen -n 50 -m 1 -type fixed\n\n./gen -n 1 -m 50 -type fixed\n\n./gen -n 100 -m 2 -type fixed\n\n./gen -n 2 -m 100 -type fixed\n\n./gen -n 75 -m 25 -type fixed\n\n./gen -n 25 -m 75 -type fixed\n\n./gen -n 99 -m 99 -type fixed\n\n./gen -n 100 -m 100 -type fixed\n\n./gen -n 1 -m 99 -type fixed\n\n./gen -n 99 -m 1 -type fixed\n\n./gen -n 100 -m 99 -type fixed\n\n./gen -n 99 -m 100 -type fixed\n\n./gen -n 100 -m 100 -type fixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:08.936064",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "322/B",
      "title": "B. Ciel and Flowers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers r, g and b (0 ≤ r, g, b ≤ 109) — the number of red, green and blue flowers.",
      "output_spec": "OutputPrint the maximal number of bouquets Fox Ciel can make.",
      "sample_tests": "ExamplesInputCopy3 6 9OutputCopy6InputCopy4 4 4OutputCopy4InputCopy0 0 0OutputCopy0",
      "description": "B. Ciel and Flowers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers r, g and b (0 ≤ r, g, b ≤ 109) — the number of red, green and blue flowers.\n\nOutputPrint the maximal number of bouquets Fox Ciel can make.\n\nInputCopy3 6 9OutputCopy6InputCopy4 4 4OutputCopy4InputCopy0 0 0OutputCopy0\n\nInputCopy3 6 9\n\nOutputCopy6\n\nInputCopy4 4 4\n\nOutputCopy4\n\nInputCopy0 0 0\n\nOutputCopy0\n\nNoteIn test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Hello, everyone!Do you want to train your skill by a contest before ACM/ICPC Finals?Codeforces Round #190 will take place on Friday, June 28th at 19:30 MSK. This is the last chance to practice, don't miss it!I am cgy4ever from China, and this is my first round on Codeforces, I hope you will love it.As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. I am the writer of them. And I would like to thank Gerald and sdya for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.Update 3: I have write a draft of editorial for this round when you are solving problems.You can read it here.Note that I didn't do any proof read and there are some typesetting issue. Anyway, I will improve it and this version is just for someone who is urgent to know the intended solutions.Update 4 Contest complete! This round will be rated!Congratulations to the winners:Div2: Baklazan phidnight kingofnumbers pawel.jasinski1986 Ronnoc Div1: YuukaKazami rng_58 Egor tmt514 chnlich And after this round, ivan.metelsky becomes our new International Grandmaster!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1505
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 322\\s*B"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(0, 1000000000, \"r\");\n    inf.readSpace();\n    int g = inf.readInt(0, 1000000000, \"g\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(0, 1000000000, \"r\");\n    inf.readSpace();\n    int g = inf.readInt(0, 1000000000, \"g\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(0, 1000000000, \"r\");\n    inf.readSpace();\n    int g = inf.readInt(0, 1000000000, \"g\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long maxValue = opt<long long>(\"maxValue\", 1000000000LL); // Default to 1e9\n    string type = opt<string>(\"type\", \"random\"); // Default to random\n\n    // Read specific values if provided\n    long long r = opt<long long>(\"r\", -1LL);\n    long long g = opt<long long>(\"g\", -1LL);\n    long long b = opt<long long>(\"b\", -1LL);\n\n    if (r != -1 && g != -1 && b != -1) {\n        // Use the provided values directly\n        // Ensure they are within the constraints\n        ensure(0 <= r && r <= maxValue);\n        ensure(0 <= g && g <= maxValue);\n        ensure(0 <= b && b <= maxValue);\n    } else {\n        // Generate values based on the specified type\n        if (type == \"max\") {\n            r = g = b = maxValue;\n        } else if (type == \"zero\") {\n            r = g = b = 0;\n        } else if (type == \"one_zero\") {\n            r = 0;\n            g = rnd.next(0LL, maxValue);\n            b = rnd.next(0LL, maxValue);\n        } else if (type == \"two_zeros\") {\n            r = 0;\n            g = 0;\n            b = rnd.next(0LL, maxValue);\n        } else if (type == \"small\") {\n            r = rnd.next(0LL, 10LL);\n            g = rnd.next(0LL, 10LL);\n            b = rnd.next(0LL, 10LL);\n        } else if (type == \"large\") {\n            r = rnd.next(maxValue - 10LL, maxValue);\n            g = rnd.next(maxValue - 10LL, maxValue);\n            b = rnd.next(maxValue - 10LL, maxValue);\n        } else if (type == \"random\") {\n            r = rnd.next(0LL, maxValue);\n            g = rnd.next(0LL, maxValue);\n            b = rnd.next(0LL, maxValue);\n        } else {\n            // Default random values\n            r = rnd.next(0LL, maxValue);\n            g = rnd.next(0LL, maxValue);\n            b = rnd.next(0LL, maxValue);\n        }\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld\\n\", r, g, b);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long maxValue = opt<long long>(\"maxValue\", 1000000000LL); // Default to 1e9\n    string type = opt<string>(\"type\", \"random\"); // Default to random\n\n    // Read specific values if provided\n    long long r = opt<long long>(\"r\", -1LL);\n    long long g = opt<long long>(\"g\", -1LL);\n    long long b = opt<long long>(\"b\", -1LL);\n\n    if (r != -1 && g != -1 && b != -1) {\n        // Use the provided values directly\n        // Ensure they are within the constraints\n        ensure(0 <= r && r <= maxValue);\n        ensure(0 <= g && g <= maxValue);\n        ensure(0 <= b && b <= maxValue);\n    } else {\n        // Generate values based on the specified type\n        if (type == \"max\") {\n            r = g = b = maxValue;\n        } else if (type == \"zero\") {\n            r = g = b = 0;\n        } else if (type == \"one_zero\") {\n            r = 0;\n            g = rnd.next(0LL, maxValue);\n            b = rnd.next(0LL, maxValue);\n        } else if (type == \"two_zeros\") {\n            r = 0;\n            g = 0;\n            b = rnd.next(0LL, maxValue);\n        } else if (type == \"small\") {\n            r = rnd.next(0LL, 10LL);\n            g = rnd.next(0LL, 10LL);\n            b = rnd.next(0LL, 10LL);\n        } else if (type == \"large\") {\n            r = rnd.next(maxValue - 10LL, maxValue);\n            g = rnd.next(maxValue - 10LL, maxValue);\n            b = rnd.next(maxValue - 10LL, maxValue);\n        } else if (type == \"random\") {\n            r = rnd.next(0LL, maxValue);\n            g = rnd.next(0LL, maxValue);\n            b = rnd.next(0LL, maxValue);\n        } else {\n            // Default random values\n            r = rnd.next(0LL, maxValue);\n            g = rnd.next(0LL, maxValue);\n            b = rnd.next(0LL, maxValue);\n        }\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld\\n\", r, g, b);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# All zeros\n./gen -r 0 -g 0 -b 0\n\n# One zero color\n./gen -r 0 -g 100 -b 100\n./gen -r 100 -g 0 -b 100\n./gen -r 100 -g 100 -b 0\n\n# Two zero colors\n./gen -r 0 -g 0 -b 100\n./gen -r 0 -g 100 -b 0\n./gen -r 100 -g 0 -b 0\n\n# All maximum values\n./gen -r 1000000000 -g 1000000000 -b 1000000000\n\n# One maximum, others zero\n./gen -r 1000000000 -g 0 -b 0\n./gen -r 0 -g 1000000000 -b 0\n./gen -r 0 -g 0 -b 1000000000\n\n# Small numbers\n./gen -r 1 -g 2 -b 3\n./gen -r 3 -g 3 -b 3\n./gen -r 4 -g 4 -b 4\n./gen -r 5 -g 6 -b 7\n\n# Random small numbers\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Random large numbers\n./gen -type large\n./gen -type large\n./gen -type large\n\n# Random numbers\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Counts just below multiples of 3\n./gen -r 2 -g 2 -b 2\n./gen -r 5 -g 5 -b 5\n\n# Counts just above multiples of 3\n./gen -r 4 -g 4 -b 4\n./gen -r 7 -g 7 -b 7\n\n# Maximum counts just below limit\n./gen -r 999999999 -g 999999999 -b 999999999\n\n# Single large value, others small\n./gen -r 999999999 -g 2 -b 2\n./gen -r 2 -g 999999999 -b 2\n./gen -r 2 -g 2 -b 999999999\n\n# Edge cases with minimum numbers\n./gen -r 1 -g 1 -b 1\n./gen -r 0 -g 1 -b 1\n./gen -r 1 -g 0 -b 1\n./gen -r 1 -g 1 -b 0\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:10.757382",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "322/C",
      "title": "C. Ciel и робот",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа a и b, ( - 109 ≤ a, b ≤ 109). Вторая строка содержит строку s (1 ≤ |s| ≤ 100, s состоит только из символов 'U', 'D', 'L', 'R') — программа робота.",
      "output_spec": "Выходные данныеВыведите \"Yes\", если робот окажется в (a, b), в противном случае выведите \"No\".",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2RUВыходные данныеСкопироватьYesВходные данныеСкопировать1 2RUВыходные данныеСкопироватьNoВходные данныеСкопировать-1 1000000000LRRLUВыходные данныеСкопироватьYesВходные данныеСкопировать0 0DВыходные данныеСкопироватьYes",
      "description": "C. Ciel и робот\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа a и b, ( - 109 ≤ a, b ≤ 109). Вторая строка содержит строку s (1 ≤ |s| ≤ 100, s состоит только из символов 'U', 'D', 'L', 'R') — программа робота.\n\nВходные данные\n\nВыходные данныеВыведите \"Yes\", если робот окажется в (a, b), в противном случае выведите \"No\".\n\nВыходные данные\n\nВходные данныеСкопировать2 2RUВыходные данныеСкопироватьYesВходные данныеСкопировать1 2RUВыходные данныеСкопироватьNoВходные данныеСкопировать-1 1000000000LRRLUВыходные данныеСкопироватьYesВходные данныеСкопировать0 0DВыходные данныеСкопироватьYes\n\nВходные данныеСкопировать2 2RU\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYes\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2RU\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать-1 1000000000LRRLU\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYes\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 0D\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYes\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом и втором тесте программа — это строка \"RU\", так что робот пойдет вправо, затем вверх, затем вправо, затем вверх и так далее.Робот пройдет по точкам (0, 0)  →  (1, 0)  →  (1, 1)  →  (2, 1)  →  (2, 2)  →  ...Итак, он может дойти до (2, 2), но не до (1, 2).",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Привет всем!Не хотите ли Вы потренироваться перед предстоящим контестом ACM/ICPC Finals?Codeforces Round #190 пройдет в пятницу, 28-го июня, в 19:30 MSK. Это последний шанс потренироваться перед финалом, не упустите его!Я cgy4ever из Китая, и это мой первый раунд Codeforces. Я надеюсь, он понравится вам.Как обычно, будет 7 задач: 2 для Div2, 2 для Div1 и 3 для обоих дивизионов. Я готовил эти задачи. Хотелось бы поблагодарить Gerald и sdya за тестирование задач, и MikeMirzayanov за проект Codeforces и Polygon.Удачи и фана вам на раунде!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 933
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 322\\s*C"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[UDLR]{1,100}\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[UDLR]{1,100}\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[UDLR]{1,100}\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Get the parameters\n    string type = opt<string>(\"type\", \"random\");\n    int maxAbsCoord = opt<int>(\"maxAbsCoord\", (int)1e9);\n    int strlen = opt<int>(\"strlen\", 100);\n\n    // Generate test case according to type\n    int a, b;\n    string s;\n\n    if (type == \"random\") {\n        // Random s and random a,b\n\n        // Generate s of length between 1 and strlen\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        // Generate a and b between -maxAbsCoord and maxAbsCoord\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if (type == \"zero_vector\") {\n        // Generate s such that net movement is zero\n        // For that, we can generate pairs of opposite directions\n\n        s = \"\";\n        string pairs[2] = {\"UD\", \"LR\"};\n\n        // We can generate random pairs to get length between 2 and strlen\n        int len = rnd.next(2, strlen);\n\n        for(int i = 0; i < len/2; ++i) {\n            string p = pairs[rnd.next(2)];\n            // Shuffle the pair\n            if(rnd.next(2)) swap(p[0], p[1]);\n            s += p;\n        }\n\n        if(len %2 ==1)\n            s += pairs[rnd.next(2)][0]; // Add one more direction\n\n        // Net movement is zero\n        // Now pick a,b not equal to starting point (0,0)\n        // Robot cannot reach any point other than positions in s\n\n        do {\n            a = rnd.next(-maxAbsCoord, maxAbsCoord);\n            b = rnd.next(-maxAbsCoord, maxAbsCoord);\n        } while(a == 0 && b == 0);\n\n    } else if (type == \"unreachable\") {\n        // Generate s and a,b such that (a,b) is not reachable\n        // One way is to create s with movement in only one axis,\n        // Then choose a,b such that it's impossible to reach\n\n        // Let's generate s consisting only of 'U' and 'D'\n        int len = rnd.next(1, strlen);\n        s = \"\";\n        for(int i = 0; i < len; ++i)\n            s += rnd.next(2) ? 'U' : 'D';\n\n        // Net movement in x is zero\n        // So any position with non-zero x is unreachable\n\n        // So we can set a random non-zero a\n        do {\n            a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        } while(a == 0);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"large_values\") {\n        // Generate s and large a and b values\n\n        // s of length up to strlen\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        // a,b near the limits\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"starting_point\") {\n        // Test case where (a,b) == (0,0)\n\n        s = \"\";\n        int len = rnd.next(1, strlen);\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        a = 0;\n        b = 0;\n\n    } else if(type == \"minimal_s\") {\n        // s of length 1\n\n        s = \"\";\n        s += \"UDLR\"[rnd.next(4)];\n\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"maximal_s\") {\n        // s of length 100\n\n        s = \"\";\n        string directions = \"UDLR\";\n        for(int i = 0; i < 100; ++i)\n            s += directions[rnd.next(4)];\n\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"reach_in_one\") {\n        // s such that (a,b) is reached within one iteration\n\n        // Generate random s\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        // Calculate positions during one iteration\n        int x = 0, y = 0;\n        vector<pair<int,int>> positions;\n        positions.emplace_back(0, 0);\n        for(char c : s){\n            if(c == 'L') x--;\n            else if(c == 'R') x++;\n            else if(c == 'U') y++;\n            else if(c == 'D') y--;\n            positions.emplace_back(x, y);\n        }\n\n        // Pick a random position from positions\n        auto p = positions[rnd.next(positions.size())];\n        a = p.first;\n        b = p.second;\n\n    } else if(type == \"unreachable_due_to_obstruction\") {\n        // Make s move in one direction and pick a,b that can't be reached\n\n        // s moves only in positive x direction\n        s = \"\";\n        int len = rnd.next(1, strlen);\n        for(int i = 0; i < len; ++i)\n            s += 'R';\n\n        // Now pick a negative a, which is unreachable\n        a = rnd.next(-maxAbsCoord, -1);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else {\n        // Default to random test case\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", a, b);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Get the parameters\n    string type = opt<string>(\"type\", \"random\");\n    int maxAbsCoord = opt<int>(\"maxAbsCoord\", (int)1e9);\n    int strlen = opt<int>(\"strlen\", 100);\n\n    // Generate test case according to type\n    int a, b;\n    string s;\n\n    if (type == \"random\") {\n        // Random s and random a,b\n\n        // Generate s of length between 1 and strlen\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        // Generate a and b between -maxAbsCoord and maxAbsCoord\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if (type == \"zero_vector\") {\n        // Generate s such that net movement is zero\n        // For that, we can generate pairs of opposite directions\n\n        s = \"\";\n        string pairs[2] = {\"UD\", \"LR\"};\n\n        // We can generate random pairs to get length between 2 and strlen\n        int len = rnd.next(2, strlen);\n\n        for(int i = 0; i < len/2; ++i) {\n            string p = pairs[rnd.next(2)];\n            // Shuffle the pair\n            if(rnd.next(2)) swap(p[0], p[1]);\n            s += p;\n        }\n\n        if(len %2 ==1)\n            s += pairs[rnd.next(2)][0]; // Add one more direction\n\n        // Net movement is zero\n        // Now pick a,b not equal to starting point (0,0)\n        // Robot cannot reach any point other than positions in s\n\n        do {\n            a = rnd.next(-maxAbsCoord, maxAbsCoord);\n            b = rnd.next(-maxAbsCoord, maxAbsCoord);\n        } while(a == 0 && b == 0);\n\n    } else if (type == \"unreachable\") {\n        // Generate s and a,b such that (a,b) is not reachable\n        // One way is to create s with movement in only one axis,\n        // Then choose a,b such that it's impossible to reach\n\n        // Let's generate s consisting only of 'U' and 'D'\n        int len = rnd.next(1, strlen);\n        s = \"\";\n        for(int i = 0; i < len; ++i)\n            s += rnd.next(2) ? 'U' : 'D';\n\n        // Net movement in x is zero\n        // So any position with non-zero x is unreachable\n\n        // So we can set a random non-zero a\n        do {\n            a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        } while(a == 0);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"large_values\") {\n        // Generate s and large a and b values\n\n        // s of length up to strlen\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        // a,b near the limits\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"starting_point\") {\n        // Test case where (a,b) == (0,0)\n\n        s = \"\";\n        int len = rnd.next(1, strlen);\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        a = 0;\n        b = 0;\n\n    } else if(type == \"minimal_s\") {\n        // s of length 1\n\n        s = \"\";\n        s += \"UDLR\"[rnd.next(4)];\n\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"maximal_s\") {\n        // s of length 100\n\n        s = \"\";\n        string directions = \"UDLR\";\n        for(int i = 0; i < 100; ++i)\n            s += directions[rnd.next(4)];\n\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else if(type == \"reach_in_one\") {\n        // s such that (a,b) is reached within one iteration\n\n        // Generate random s\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        // Calculate positions during one iteration\n        int x = 0, y = 0;\n        vector<pair<int,int>> positions;\n        positions.emplace_back(0, 0);\n        for(char c : s){\n            if(c == 'L') x--;\n            else if(c == 'R') x++;\n            else if(c == 'U') y++;\n            else if(c == 'D') y--;\n            positions.emplace_back(x, y);\n        }\n\n        // Pick a random position from positions\n        auto p = positions[rnd.next(positions.size())];\n        a = p.first;\n        b = p.second;\n\n    } else if(type == \"unreachable_due_to_obstruction\") {\n        // Make s move in one direction and pick a,b that can't be reached\n\n        // s moves only in positive x direction\n        s = \"\";\n        int len = rnd.next(1, strlen);\n        for(int i = 0; i < len; ++i)\n            s += 'R';\n\n        // Now pick a negative a, which is unreachable\n        a = rnd.next(-maxAbsCoord, -1);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n\n    } else {\n        // Default to random test case\n        int len = rnd.next(1, strlen);\n        s = \"\";\n\n        string directions = \"UDLR\";\n        for(int i = 0; i < len; ++i)\n            s += directions[rnd.next(4)];\n\n        a = rnd.next(-maxAbsCoord, maxAbsCoord);\n        b = rnd.next(-maxAbsCoord, maxAbsCoord);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", a, b);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -maxAbsCoord 100 -strlen 10\n./gen -type random -maxAbsCoord 1000 -strlen 20\n./gen -type random -maxAbsCoord 1000000000 -strlen 100\n\n./gen -type zero_vector -maxAbsCoord 100 -strlen 10\n./gen -type zero_vector -maxAbsCoord 1000 -strlen 20\n./gen -type zero_vector -maxAbsCoord 1000000000 -strlen 100\n\n./gen -type unreachable -maxAbsCoord 100 -strlen 10\n./gen -type unreachable -maxAbsCoord 1000 -strlen 20\n./gen -type unreachable -maxAbsCoord 1000000000 -strlen 100\n\n./gen -type large_values -maxAbsCoord 1000000000 -strlen 100\n\n./gen -type starting_point -strlen 10\n./gen -type starting_point -strlen 100\n\n./gen -type minimal_s -maxAbsCoord 100\n./gen -type minimal_s -maxAbsCoord 1000000000\n\n./gen -type maximal_s -maxAbsCoord 100\n./gen -type maximal_s -maxAbsCoord 1000000000\n\n./gen -type reach_in_one -strlen 10\n./gen -type reach_in_one -strlen 100\n\n./gen -type unreachable_due_to_obstruction -maxAbsCoord 1000 -strlen 50\n./gen -type unreachable_due_to_obstruction -maxAbsCoord 1000000000 -strlen 100\n\n./gen -type random -maxAbsCoord 0 -strlen 100\n\n./gen -type random -maxAbsCoord 1000000000 -strlen 1\n\n./gen -type zero_vector -maxAbsCoord 1000000000 -strlen 2\n\n./gen -type reach_in_one -strlen 1\n\n./gen -type reach_in_one -strlen 100\n\n./gen -type unreachable -maxAbsCoord 1000000000 -strlen 1\n\n./gen -type starting_point -strlen 1\n\n./gen -type maximal_s\n\n./gen -type minimal_s\n\n./gen -type unreachable_due_to_obstruction -maxAbsCoord 10000 -strlen 80\n\n./gen -type zero_vector -maxAbsCoord 10000 -strlen 80\n\n./gen -type starting_point -strlen 1\n\n./gen -type reach_in_one -strlen 2\n\n./gen -type reach_in_one -strlen 50\n\n./gen -type unreachable -maxAbsCoord 1000000000 -strlen 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:12.689899",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "322/D",
      "title": "D. Ciel и дуэль",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n и m (1 ≤ n, m ≤ 100) — количество карт у Jiro и Ciel. Каждая из следующих n строк содержит строку position и целое число strength (0 ≤ strength ≤ 8000) — позиция и сила текущей карты Jiro. Позиция position — это строка «ATK» для позиции атака, и строка «DEF» для позиции защита.Каждая из следующих m строк содержит целое число strength (0 ≤ strength ≤ 8000) — сила текущей карты Ciel.",
      "output_spec": "Выходные данныеВыведите целое число: максимальный ущерб, который можно нанести Jiro.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 3ATK 2000DEF 1700250025002500Выходные данныеСкопировать3000Входные данныеСкопировать3 4ATK 10ATK 100ATK 10001111011001Выходные данныеСкопировать992Входные данныеСкопировать2 4DEF 0ATK 00011Выходные данныеСкопировать1",
      "description": "D. Ciel и дуэль\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа n и m (1 ≤ n, m ≤ 100) — количество карт у Jiro и Ciel. Каждая из следующих n строк содержит строку position и целое число strength (0 ≤ strength ≤ 8000) — позиция и сила текущей карты Jiro. Позиция position — это строка «ATK» для позиции атака, и строка «DEF» для позиции защита.Каждая из следующих m строк содержит целое число strength (0 ≤ strength ≤ 8000) — сила текущей карты Ciel.\n\nВходные данные\n\nВыходные данныеВыведите целое число: максимальный ущерб, который можно нанести Jiro.\n\nВыходные данные\n\nВходные данныеСкопировать2 3ATK 2000DEF 1700250025002500Выходные данныеСкопировать3000Входные данныеСкопировать3 4ATK 10ATK 100ATK 10001111011001Выходные данныеСкопировать992Входные данныеСкопировать2 4DEF 0ATK 00011Выходные данныеСкопировать1\n\nВходные данныеСкопировать2 3ATK 2000DEF 1700250025002500\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4ATK 10ATK 100ATK 10001111011001\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать992\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 4DEF 0ATK 00011\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте все карты Ciel имеют одинаковую силу. Оптимальнее всего сначала напасть на карту «ATK 2000», уничтожить эту карту, тогда Jiro получит 2500 - 2000 = 500 единиц урона. Затем используем вторую карту для уничтожения карты «DEF 1700». Jiro не получает урона. Теперь у Jiro нет карт и можно использовать третью карту — нападаем на Jiro, он получает 2500 урона. Таким образом, ответ равняется 500 + 2500 = 3000.Во втором тесте нужно использовать карту «1001» для атаки на карту «ATK 100», затем с помощью карты «101» напасть на карту «ATK 10». После этого у Ciel еще есть карты, но она может закончить атаковать. Таким образом, общий урон равен (1001 - 100) + (101 - 10) = 992.В третьем случае заметьте, что Ciel может уничтожить карту «ATK 0» картой с силой, равной 0. Но не может уничтожить карту «DEF 0» картой с силой, равной 0.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Привет всем!Не хотите ли Вы потренироваться перед предстоящим контестом ACM/ICPC Finals?Codeforces Round #190 пройдет в пятницу, 28-го июня, в 19:30 MSK. Это последний шанс потренироваться перед финалом, не упустите его!Я cgy4ever из Китая, и это мой первый раунд Codeforces. Я надеюсь, он понравится вам.Как обычно, будет 7 задач: 2 для Div2, 2 для Div1 и 3 для обоих дивизионов. Я готовил эти задачи. Хотелось бы поблагодарить Gerald и sdya за тестирование задач, и MikeMirzayanov за проект Codeforces и Polygon.Удачи и фана вам на раунде!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 933
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 322\\s*D"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string position = inf.readToken(\"(ATK|DEF)\", \"position\");\n        inf.readSpace();\n        int strength = inf.readInt(0, 8000, \"strength\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int strength = inf.readInt(0, 8000, \"Ciel_strength\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string position = inf.readToken(\"(ATK|DEF)\", \"position\");\n        inf.readSpace();\n        int strength = inf.readInt(0, 8000, \"strength\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int strength = inf.readInt(0, 8000, \"Ciel_strength\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string position = inf.readToken(\"(ATK|DEF)\", \"position\");\n        inf.readSpace();\n        int strength = inf.readInt(0, 8000, \"strength\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int strength = inf.readInt(0, 8000, \"Ciel_strength\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_position() {\n    if (rnd.next(2)) return \"ATK\";\n    else return \"DEF\";\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n\n    vector<string> jiro_position(n);\n    vector<int> jiro_strength(n);\n\n    vector<int> ciel_strength;\n\n    if (type == \"random\") {\n        // Generate random positions for Jiro's cards\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        // Generate random strengths for Ciel's cards\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n    else if (type == \"all_attack\") {\n        // Jiro's cards are all ATTACK position\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = \"ATK\";\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n    else if (type == \"all_defense\") {\n        // Jiro's cards are all DEFENSE position\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = \"DEF\";\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n    else if (type == \"strengths_zero\") {\n        // All strengths are zero\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(0);\n        }\n    }\n    else if (type == \"strengths_max\") {\n        // All strengths are 8000\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = 8000;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(8000);\n        }\n    }\n    else if (type == \"strengths_equal\") {\n        // All strengths are equal\n        int equal_strength = rnd.next(0, 8000);\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = equal_strength;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(equal_strength);\n        }\n    }\n    else if (type == \"strengths_edge\") {\n        // Generate strengths that test the boundaries\n        // For positions, we can mix them\n        // Use strengths like 0,1,7999,8000\n        int strengths[] = {0,1,7999,8000};\n        int strengths_size = 4;\n\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = strengths[rnd.next(0, strengths_size-1)];\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(strengths[rnd.next(0, strengths_size-1)]);\n        }\n    }\n    else if (type == \"ciel_weak\") {\n        // Ciel's cards are weaker than Jiro's\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = rnd.next(4000,8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0,4000));\n        }\n    }\n    else if (type == \"fully_defeated\") {\n        // Generate Jiro's cards\n        for (int i = 0; i < n; ++i) {\n            // Generate Jiro's cards\n            // For Jiro's \"DEF\", limit strength to 7999 to ensure Ciel can defeat\n            jiro_position[i] = random_position();\n            if (jiro_position[i] == \"DEF\") {\n                jiro_strength[i] = rnd.next(0,7999);\n            } else {\n                jiro_strength[i] = rnd.next(0,8000);\n            }\n        }\n\n        // Sort Jiro's cards from weakest to strongest\n        vector<pair<int, string>> jiro_cards(n);\n        for (int i = 0; i < n; ++i) {\n            jiro_cards[i] = {jiro_strength[i], jiro_position[i]};\n        }\n        sort(jiro_cards.begin(), jiro_cards.end());\n\n        int min_cards = min(n, m);\n        ciel_strength.resize(m);\n        // Generate Ciel's strengths\n        // First min(n,m) Ciel's cards to defeat Jiro's cards\n        for (int i = 0; i < min_cards; ++i) {\n            string position = jiro_cards[i].second;\n            int strength = jiro_cards[i].first;\n            int ciel_s;\n            if (position == \"ATK\") {\n                // Ciel's strength >= Jiro's strength\n                ciel_s = rnd.next(strength,8000);\n            } else {\n                // \"DEF\", Ciel's strength > Jiro's strength\n                ciel_s = rnd.next(strength+1,8000);\n            }\n            ciel_strength[i] = ciel_s;\n        }\n        // For remaining Ciel's cards\n        for (int i = min_cards; i < m; ++i) {\n            ciel_strength[i] = rnd.next(0,8000);\n        }\n\n        // Now, update Jiro's strengths and positions from sorted cards\n        for (int i = 0; i < n; ++i) {\n            jiro_strength[i] = jiro_cards[i].first;\n            jiro_position[i] = jiro_cards[i].second;\n        }\n    }\n    else {\n        // Default to random\n        // Generate random positions for Jiro's cards\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        // Generate random strengths for Ciel's cards\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n\n    // Output the test case\n    cout << n << \" \" << m << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << jiro_position[i] << \" \" << jiro_strength[i] << \"\\n\";\n    }\n    for (int i = 0; i < m; ++i) {\n        cout << ciel_strength[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_position() {\n    if (rnd.next(2)) return \"ATK\";\n    else return \"DEF\";\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n\n    vector<string> jiro_position(n);\n    vector<int> jiro_strength(n);\n\n    vector<int> ciel_strength;\n\n    if (type == \"random\") {\n        // Generate random positions for Jiro's cards\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        // Generate random strengths for Ciel's cards\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n    else if (type == \"all_attack\") {\n        // Jiro's cards are all ATTACK position\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = \"ATK\";\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n    else if (type == \"all_defense\") {\n        // Jiro's cards are all DEFENSE position\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = \"DEF\";\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n    else if (type == \"strengths_zero\") {\n        // All strengths are zero\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(0);\n        }\n    }\n    else if (type == \"strengths_max\") {\n        // All strengths are 8000\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = 8000;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(8000);\n        }\n    }\n    else if (type == \"strengths_equal\") {\n        // All strengths are equal\n        int equal_strength = rnd.next(0, 8000);\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = equal_strength;\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(equal_strength);\n        }\n    }\n    else if (type == \"strengths_edge\") {\n        // Generate strengths that test the boundaries\n        // For positions, we can mix them\n        // Use strengths like 0,1,7999,8000\n        int strengths[] = {0,1,7999,8000};\n        int strengths_size = 4;\n\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = strengths[rnd.next(0, strengths_size-1)];\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(strengths[rnd.next(0, strengths_size-1)]);\n        }\n    }\n    else if (type == \"ciel_weak\") {\n        // Ciel's cards are weaker than Jiro's\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = rnd.next(4000,8000);\n        }\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0,4000));\n        }\n    }\n    else if (type == \"fully_defeated\") {\n        // Generate Jiro's cards\n        for (int i = 0; i < n; ++i) {\n            // Generate Jiro's cards\n            // For Jiro's \"DEF\", limit strength to 7999 to ensure Ciel can defeat\n            jiro_position[i] = random_position();\n            if (jiro_position[i] == \"DEF\") {\n                jiro_strength[i] = rnd.next(0,7999);\n            } else {\n                jiro_strength[i] = rnd.next(0,8000);\n            }\n        }\n\n        // Sort Jiro's cards from weakest to strongest\n        vector<pair<int, string>> jiro_cards(n);\n        for (int i = 0; i < n; ++i) {\n            jiro_cards[i] = {jiro_strength[i], jiro_position[i]};\n        }\n        sort(jiro_cards.begin(), jiro_cards.end());\n\n        int min_cards = min(n, m);\n        ciel_strength.resize(m);\n        // Generate Ciel's strengths\n        // First min(n,m) Ciel's cards to defeat Jiro's cards\n        for (int i = 0; i < min_cards; ++i) {\n            string position = jiro_cards[i].second;\n            int strength = jiro_cards[i].first;\n            int ciel_s;\n            if (position == \"ATK\") {\n                // Ciel's strength >= Jiro's strength\n                ciel_s = rnd.next(strength,8000);\n            } else {\n                // \"DEF\", Ciel's strength > Jiro's strength\n                ciel_s = rnd.next(strength+1,8000);\n            }\n            ciel_strength[i] = ciel_s;\n        }\n        // For remaining Ciel's cards\n        for (int i = min_cards; i < m; ++i) {\n            ciel_strength[i] = rnd.next(0,8000);\n        }\n\n        // Now, update Jiro's strengths and positions from sorted cards\n        for (int i = 0; i < n; ++i) {\n            jiro_strength[i] = jiro_cards[i].first;\n            jiro_position[i] = jiro_cards[i].second;\n        }\n    }\n    else {\n        // Default to random\n        // Generate random positions for Jiro's cards\n        for (int i = 0; i < n; ++i) {\n            jiro_position[i] = random_position();\n            jiro_strength[i] = rnd.next(0, 8000);\n        }\n        // Generate random strengths for Ciel's cards\n        for (int i = 0; i < m; ++i) {\n            ciel_strength.push_back(rnd.next(0, 8000));\n        }\n    }\n\n    // Output the test case\n    cout << n << \" \" << m << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << jiro_position[i] << \" \" << jiro_strength[i] << \"\\n\";\n    }\n    for (int i = 0; i < m; ++i) {\n        cout << ciel_strength[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type strengths_zero\n./gen -n 2 -m 2 -type strengths_max\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type all_attack\n./gen -n 100 -m 100 -type all_defense\n./gen -n 50 -m 50 -type strengths_equal\n./gen -n 50 -m 50 -type strengths_edge\n./gen -n 100 -m 100 -type strengths_edge\n./gen -n 100 -m 100 -type fully_defeated\n./gen -n 100 -m 100 -type ciel_weak\n./gen -n 1 -m 100 -type fully_defeated\n./gen -n 100 -m 1 -type fully_defeated\n./gen -n 1 -m 100 -type strengths_max\n./gen -n 100 -m 1 -type strengths_zero\n./gen -n 1 -m 1 -type strengths_edge\n./gen -n 100 -m 100 -type strengths_max\n./gen -n 100 -m 100 -type strengths_zero\n./gen -n 1 -m 1 -type ciel_weak\n./gen -n 100 -m 100 -type strengths_equal\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type strengths_equal\n./gen -n 1 -m 99 -type strengths_edge\n./gen -n 99 -m 1 -type strengths_edge\n./gen -n 100 -m 50 -type strengths_edge\n./gen -n 50 -m 100 -type strengths_edge\n./gen -n 100 -m 100 -type strengths_edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:14.435241",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "322/E",
      "title": "E. Ciel the Commander",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (2 ≤ n ≤ 105) — the number of cities in Tree Land.Each of the following n - 1 lines contains two integers a and b (1 ≤ a, b ≤ n, a ≠ b) — they mean that there will be an undirected road between a and b. Consider all the cities are numbered from 1 to n.It guaranteed that the given graph will be a tree.",
      "output_spec": "OutputIf there is a valid plane, output n space-separated characters in a line — i-th character is the rank of officer in the city with number i. Otherwise output \"Impossible!\".",
      "sample_tests": "ExamplesInputCopy41 21 31 4OutputCopyA B B BInputCopy101 22 33 44 55 66 77 88 99 10OutputCopyD C B A D C B D C D",
      "description": "E. Ciel the Commander\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (2 ≤ n ≤ 105) — the number of cities in Tree Land.Each of the following n - 1 lines contains two integers a and b (1 ≤ a, b ≤ n, a ≠ b) — they mean that there will be an undirected road between a and b. Consider all the cities are numbered from 1 to n.It guaranteed that the given graph will be a tree.\n\nOutputIf there is a valid plane, output n space-separated characters in a line — i-th character is the rank of officer in the city with number i. Otherwise output \"Impossible!\".\n\nInputCopy41 21 31 4OutputCopyA B B BInputCopy101 22 33 44 55 66 77 88 99 10OutputCopyD C B A D C B D C D\n\nInputCopy41 21 31 4\n\nOutputCopyA B B B\n\nInputCopy101 22 33 44 55 66 77 88 99 10\n\nOutputCopyD C B A D C B D C D\n\nNoteIn the first example, for any two officers of rank 'B', an officer with rank 'A' will be on the path between them. So it is a valid solution.",
      "solutions": [
        {
          "title": "Codeforces Round #190 - Codeforces",
          "content": "Hello, everyone!Do you want to train your skill by a contest before ACM/ICPC Finals?Codeforces Round #190 will take place on Friday, June 28th at 19:30 MSK. This is the last chance to practice, don't miss it!I am cgy4ever from China, and this is my first round on Codeforces, I hope you will love it.As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. I am the writer of them. And I would like to thank Gerald and sdya for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!Update 1: The score distribution for Both Division is regular (500-1000-1500-2000-2500). The main character of all problem will be: Fox Ciel. (See here for more info)Update 2: Also thanks Aksenov239 for helping prepared this round, including translate the problem statement into Russian. And I'm sorry for the delay of judgement at the beginning of this round. Fortunately it goes better now.Update 3: I have write a draft of editorial for this round when you are solving problems.You can read it here.Note that I didn't do any proof read and there are some typesetting issue. Anyway, I will improve it and this version is just for someone who is urgent to know the intended solutions.Update 4 Contest complete! This round will be rated!Congratulations to the winners:Div2: Baklazan phidnight kingofnumbers pawel.jasinski1986 Ronnoc Div1: YuukaKazami rng_58 Egor tmt514 chnlich And after this round, ivan.metelsky becomes our new International Grandmaster!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8163",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1505
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces",
          "content": "Update 1 Added links to my code.Update 2 The links to my code seems not work, so I push my codes on github, and you find all of them here: https://github.com/cgy4ever/cf190Update 3 Fixed my solution of Div1-C (Div2-E). In this problem, we must find centroid of tree instead of center of tree. Thanks RomaWhite for pointing this out and provide test case. And it seems that many solutions can pass the system test will fail on his test case (including my model solution). I feel apologetic for the weak test cases and wrong solution.Update 4 Reformat the passage, I hope it would looks better.322A - Ciel and DancingLet's define remainNew = # of people haven't danced before. So at beginning remainNew = n+m, and we have: During the 1st song, remainNew must decreased by at least 2. (Because the boy and girl must haven't danced before.) During the k-th (k>1) song, remainNew must decreased by at least 1. (Because one of the boy or girl must haven't danced before.) So the answer must be no more than n+m-1. And it's not hard to construct one schedule get this maximal possible answer: 1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1322B - Ciel and FlowersIf there are no \"mixing bouquet\" then the answer will be r/3 + g/3 + b/3. One important observation is that: There always exist an optimal solution with less than 3 mixing bouquet.The proof is here: Once we get 3 mixing bouquet, we can change it to (1 red bouquet + 1 green bouquet + 1 blue bouquet)So we can try 0, 1, 2 mixing bouquet and make the remain 3 kind of bouquets use above greedy method. Output one with largest outcome.322C - Ciel and Robot 321A - Ciel and RobotNote that after Ciel execute string s, it will moves (dx, dy). And for each repeat, it will alway moves (dx, dy). So the total movement will be k * (dx, dy) + (dx[p], dy[p]) which (dx[p], dy[p]) denotes the movement after execute first p characters. We can enumerate p since (0 <= p < |s| <= 100), and check if there are such k exists.Note that there are some tricks: We can divide dx or dy directly because they both can become zero. Another trick is that k must be non-negative. Many people failed on this test case (which no included in the pretest): -1 -1\nUR322D - Ciel and Duel 321B - Ciel and DuelWe have 3 solutions to this problem:= 1. greedy =There are 2 cases: we killed all Jiro's cards, or not.If we are not killed all of Jiro's cards, then: We never attack his DEF cards, it's meaningless. Suppose we make k attacks, then it must be: use Ciel's k cards with highest strength to attack Jiro's k cards with lowest strength, and we can sort the both k cards by strength to make attack one by one. (If there are an invalid attack, then we can't have k attack) If we kill all Jiro's card: Then for all DEF cards, we consider it from lower strength to higher: if its strength is L, then we find a card of Ciel with strength more than L (If there are many, we choose one with lowest strength). Then we can know if we can kill all DEF cards. And then we choose |x| cards with highest strength of Ciel, try to kill Jiro's remain card.Note that if we could kill all ATK cards, the order doesn't matter: the total damage will be (sum of strength of Ciel's remain card) — (sum of strength of Jiro's remain card).= 2. DP =Above solution looks complicated, can we solve it with few observation? Yes we can. The only observation is that:There always exist an optimal solution that: If Ciel's two card X's strength > Y's strength, and X, Y attacks on A and B with the same position, then A's strength > B's strength. We already use this observation in above solution.Then what can we do? Yes, we can sort all Ciel's card, all ATK card of Jiro, all DEF card of Jiro.Let's DP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card of Ciel, Jiro's ATk, Jiro's DEF are pCiel, pATK, pJiro, and killAll=1 if and only if we assume at the end we can kill all Jiro's card.Then we have 4 choice: Skip, this card don't attack. Attack on the next ATK card. Attack on the next DEF card. Assume Jiro has no cards and make a direct attack. = 3. MinCostMaxFlow =Well, what if we want to solve this problem with no observation?Ok, if you are good at construct flow algorithm, it's an easy thing to solve this by flow.Please see my solution for details. It just considered the matching relationship.322E - Ciel the Commander 321C - Ciel the CommanderThis is a problem with construction on trees. And for these kind of problems, we usually use two method: up-down or down-up. So we have 1 solution for each method:= 1. up-down construction =Suppose we assign an officer with rank A at node x. Then for two distinct subtree rooted by x, says T1 and T2: There can't be any invalid path cross T1 and T2, because it is blocked by node x. (It's clear that we can't make 2 rank A officer.)So we can solve these subtree independently: the only different is that we can't use rank A anymore.Then the question is: which node should x be? It could be good if any subtree will has a small size. And if you have the knowledge of \"centroid of tree\", then you can quickly find that if x be the centroid of this tree, the subtree's size will be no more than half of the original tree. So we only needs about log2(n) nodes and 26 is enough.= 2. down-up construction =The above solution involves the concept of \"centroid of tree\" but you might not heard about that, don't worry, we have another solution can solve this problem without knowing that, and it's easier to implement.Suppose we choose 1 as the root and consider it as a directed tree, and on some day we have the following problem:We have some subtree rooted at T1, T2, ..., Tk, and they are already assigned an officer, we need to assign an officer to node x and link them to this node. Well, a normal idea is: we choose one with lowest possible rank.The rank of x should satisfy: If there are a node with rank t exposes at Ti and a node with t exposes at Tj (i!=j), then rank of x must be higher than t. (Otherwise the path between them will be invalid.) If there are a node with rank t exposes at Ti, then the rank of x can't be t. So we can use this rule to choose the lowest possible rank. But can it passes? Yes, it can, but the proof is not such easy, I'll introduce the main idea here: We assign each node a potential: p(x) = {2^('Z' — w) | w is exposed}. For example, if 'Y' and 'Z' are exposed, then p(x) = 1 + 2 = 3. We can proof p(x) <= |# of nodes of the subtree rooted by x| by proof this lemma: When we synthesis x with T1, T2, ..., Tk, p(x) <= 1 + p(T1) + ... + p(Tk). It's not hard to proof, but might have some cases to deal with. 321D - Ciel and FlipboardFor this problem we need a big \"observation\": what setup of \"flips\" are valid? What means set up of \"flips\", well, for example, after the 1st step operation of example 1, we get: 1 1 0\n1 1 0\n0 0 0It means the left top 2x2 cells are negatived.Given a 0-1 matrix of a set up of \"flips\", how can you determine if we can get it by some N x N (I use N instead of x here, it don't make sense to write something like x x x.) flips.To solve this problem, we need the following observation: For any i, any j<=x: setUp[i][j]^setUp[i][x]^setUp[i][j+x] will be 0. For any i, any j<=x: setUp[j][i]^setUp[x][i]^setUp[j+x][i] will be 0. It's quite easy to proof than find that: after each operation, there always be 0 or 2 cells lay in {setUp[i][j], setUp[i][x], setUp[i][j+x]} or {setUp[j][i], setUp[x][i], setUp[j+x][i]}.So what? Well, then there must be no more than 2^(N*N) solutions, since if we determine the left top N x N cells, we can determine others by above equations.And then? Magically we can proof if one set up meets all above equations, we can get it. And the proof only needs one line: think the operation as addition of vectors in GF2, then we have N*N independent vector, so there must be 2^(N*N) different setups we can get. (Yes, I admit it need some knowledge, or feeling in linear algebra)Then the things are easy: we enumerate {setUp[1][N], setUp[2][N], ..., setUp[N][N]}, and determine others by greedy. (More detailed, by columns.)You can find details in my code.321E - Ciel and GondolasThis problem may jog your memory of OI times (if you have been an OIer and now grows up, like me). Maybe some Chinese contestants might think this problem doesn't worth 2500, but DP optimization is an advanced topic in programming contest for many regions. It's quite easy to find an O(N^2 K) DP: dp[i][j] = max{ k | dp[i-1][k] + cost(k+1...j)} (dp[i][j] means the minimal cost if we divide 1...j foxes into i groups)There are many ways to optimize this kind of dp equation, but a large part of them based one the property of cost function. So we need to find some property independent of cost function.Let opt[i][j] = the smallest k such that dp[i][j] = dp[i][k] + cost(k+1...j) Then intuitively we have opt[i][1] <= opt[i][2] <= ... <= opt[i][n]. (I admit some people don't think it's intuitively correct, but it can proof by some high school algebra)Then how to use this stuff?Let n = 200 and suppose we already get dp[i][j] for i<=3 and now we have to compute dp[4][j]: If we first compute dp[4][100], then we can have opt[4][100] at the same time.And when we compute dp[4][1] ... dp[4][99], we know that the k must lay in 1...opt[4][100]. When we compute dp[4][101] ... dp[4][200], we know that k must lay in opt[4][100]...n.Let's formalize this thing: We use compute(d, L, R, optL, optR) to denote we are computing dp[d][L...R], and we know the k must be in range optL...optR.Then we have: compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)One can show that this solution will run in O(NlogN * K). Note that we don't need opt[d][M] at the center of interval optL...optR. We can proof at each recursive depth, the total cost by line 2 will be no more than 2n. And there are at most O(log(n)) depths.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 322\\s*E"
          },
          "content_length": 10018
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #190 - Codeforces - Code 1",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 - Codeforces - Code 2",
          "code": "<h2>cgy.ac</h2>\n<br>\nHi! I'm <b>cgy4ever</b> and this is my new website.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8163",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 1",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 2",
          "code": "1 1\n1 2\n...\n1 m\n2 1\n3 1\n...\nn 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 3",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 4",
          "code": "1 1 0\n1 1 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 5",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 6",
          "code": "compute(d, L, R, optL, optR) = \n\n\t1. special case: L==R.\n\n\t2. let M = (L+R) / 2, we solve dp[d][M] as well as opt[d][M]. Uses about (optR-optL+1) operations.\n\n\t3. compute(d, L, M-1, optL, opt[d][M])\n\n\t4. compute(d, M+1, R, opt[d][M], optR)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 7",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 8",
          "code": "scanf(\"%d%d\",&n,&m);\nfor(int i=1; i<=n; i++)\n  for(int j=1; j<=n; j++)\n    scanf(\"%d\",&a[i][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 9",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #190 — Editorial - Codeforces - Code 10",
          "code": "scanf(\"%d%d\\n\",&n,&m);\nchar buffer[10000];\nfor(int i=1; i<=n; i++) {\n  gets(buffer);\n  for(int j=1; j<=n; j++)\n    a[i][j] = buffer[2 * (j - 1)] - '0';\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8192",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return false; // Cycle detected\n        parent[y] = x;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge connects a node to itself at edge %d: node %d\", i + 1, a);\n\n        bool merged = unite(a, b);\n        ensuref(merged, \"Edge %d creates a cycle between node %d and node %d\", i + 1, a, b);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"Graph is not connected: node %d is not connected to node 1\", i);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return false; // Cycle detected\n        parent[y] = x;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge connects a node to itself at edge %d: node %d\", i + 1, a);\n\n        bool merged = unite(a, b);\n        ensuref(merged, \"Edge %d creates a cycle between node %d and node %d\", i + 1, a, b);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"Graph is not connected: node %d is not connected to node 1\", i);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return false; // Cycle detected\n        parent[y] = x;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge connects a node to itself at edge %d: node %d\", i + 1, a);\n\n        bool merged = unite(a, b);\n        ensuref(merged, \"Edge %d creates a cycle between node %d and node %d\", i + 1, a, b);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"Graph is not connected: node %d is not connected to node 1\", i);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> graph;\n\nclass DSU {\npublic:\n    vector<int> parent;\n    DSU(int n) {\n        parent.resize(n);\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y)\n            parent[y] = x;\n    }\n};\n\nvoid readAssignment(InStream &stream, vector<int> &assignment) {\n    assignment.clear();\n    string line = stream.readString();\n    if (line == \"Impossible!\") {\n        assignment.push_back(-1); // Indicate impossible\n    } else {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            if (token.size() != 1 || token[0] < 'A' || token[0] > 'Z')\n                stream.quitf(_pe, \"Invalid rank: %s\", token.c_str());\n            assignment.push_back(token[0] - 'A'); // Convert rank to integer (0-25)\n        }\n        if ((int)assignment.size() != n)\n            stream.quitf(_pe, \"Wrong number of ranks: expected %d, found %d\", n, (int)assignment.size());\n    }\n}\n\nbool checkAssignment(vector<int> &assignment) {\n    if (assignment.size() != n)\n        return false; // Should not happen\n    DSU dsu(n);\n    vector<vector<int>> nodes_by_rank(26);\n    for (int i = 0; i < n; ++i) {\n        int r = assignment[i];\n        nodes_by_rank[r].push_back(i);\n    }\n    // For each rank from 'Z' (25) down to 'A' (0)\n    for (int r = 25; r >= 0; --r) {\n        for (int u : nodes_by_rank[r]) {\n            for (int v : graph[u]) {\n                if (assignment[v] >= assignment[u]) {\n                    dsu.unite(u, v);\n                }\n            }\n        }\n        // Now, check connected components of nodes with rank == r\n        map<int, vector<int>> components;\n        for (int u : nodes_by_rank[r]) {\n            int parent_u = dsu.find(u);\n            components[parent_u].push_back(u);\n        }\n        // If any component has more than one node, it's invalid\n        for (auto &comp : components) {\n            if (comp.second.size() > 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input graph\n    n = inf.readInt();\n    graph.resize(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt() - 1;\n        int b = inf.readInt() - 1;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    vector<int> jury_assignment;\n    readAssignment(ans, jury_assignment);\n\n    vector<int> cont_assignment;\n    readAssignment(ouf, cont_assignment);\n\n    if (cont_assignment.size() == 1 && cont_assignment[0] == -1) {\n        // Contestant outputs \"Impossible!\"\n        if (jury_assignment.size() == 1 && jury_assignment[0] == -1) {\n            // Jury also outputs \"Impossible!\"\n            quitf(_ok, \"Both outputs are Impossible!\");\n        } else {\n            // Jury has an assignment, contestant outputs impossible\n            quitf(_wa, \"Contestant outputs Impossible! but a valid assignment exists\");\n        }\n    } else {\n        // Contestant outputs an assignment\n        if ((int)cont_assignment.size() != n) {\n            quitf(_pe, \"Contestant outputs incorrect number of ranks\");\n        }\n        // Check if assignment is valid\n        if (!checkAssignment(cont_assignment)) {\n            quitf(_wa, \"Contestant's assignment is invalid\");\n        }\n        // Assignment is valid\n        if (jury_assignment.size() == 1 && jury_assignment[0] == -1) {\n            // Jury outputs impossible, but contestant found valid assignment\n            quitf(_fail, \"Jury outputs Impossible! but contestant found valid assignment\");\n        } else {\n            // Jury also has assignment, accept\n            quitf(_ok, \"Contestant's assignment is valid\");\n        }\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i - 1, i});\n    } else if (type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"binary\") {\n        // Generate a binary tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i / 2, i});\n    } else if (type == \"balanced\") {\n        // Generate a balanced k-ary tree, here k = 3\n        int k = 3;\n        int idx = 2;\n        queue<int> q;\n        q.push(1);\n        while (idx <= n && !q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i < k && idx <= n; ++i) {\n                edges.push_back({u, idx});\n                q.push(idx);\n                ++idx;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i){\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    \n    // Shuffle the nodes\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n    \n    // Relabel the edges\n    for (auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n    \n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for (auto &e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i - 1, i});\n    } else if (type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"binary\") {\n        // Generate a binary tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i / 2, i});\n    } else if (type == \"balanced\") {\n        // Generate a balanced k-ary tree, here k = 3\n        int k = 3;\n        int idx = 2;\n        queue<int> q;\n        q.push(1);\n        while (idx <= n && !q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i < k && idx <= n; ++i) {\n                edges.push_back({u, idx});\n                q.push(idx);\n                ++idx;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i){\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    \n    // Shuffle the nodes\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n    \n    // Relabel the edges\n    for (auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n    \n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for (auto &e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small size test cases\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type binary\n./gen -n 2 -type balanced\n./gen -n 2 -type random\n\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type binary\n./gen -n 5 -type balanced\n./gen -n 5 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type balanced\n./gen -n 10 -type random\n\n# Medium size test cases\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type balanced\n./gen -n 100 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type balanced\n./gen -n 1000 -type random\n\n# Large size test cases\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type binary\n./gen -n 10000 -type balanced\n./gen -n 10000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type balanced\n./gen -n 100000 -type random\n\n# Extreme size test cases\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type random\n\n# Additional varied test cases\n./gen -n 99999 -type chain\n./gen -n 99999 -type star\n./gen -n 99999 -type binary\n./gen -n 99999 -type balanced\n./gen -n 99999 -type random\n\n./gen -n 50000 -type chain\n./gen -n 50000 -type star\n./gen -n 50000 -type binary\n./gen -n 50000 -type balanced\n./gen -n 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:16.316071",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "323/A",
      "title": "A. Черно-белый куб",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест0.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных задано целое число k (1 ≤ k ≤ 100) — размер куба.",
      "output_spec": "Выходные данныеЕсли решения не существует, то выведите -1. Иначе выведите искомую раскраску куба последовательно по слоям. В первых k строках выведите матрицу k × k — как должен быть раскрашен первый слой куба. В следующих k строках выведите матрицу k × k — как должен быть раскрашен второй слой куба. И так далее до последнего k-го слоя. Обратите внимание, что ориентация куба в пространстве не имеет значения.Единичный куб белого цвета обозначайте символом «w», черного — «b». Следуйте формату выходных данных, который указан в тестовых примерах. При проверке правильности ответа пустые строки никак не учитываются.",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать-1Входные данныеСкопировать2Выходные данныеСкопироватьbbwwbbww",
      "description": "A. Черно-белый куб\n\nограничение по времени на тест0.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных задано целое число k (1 ≤ k ≤ 100) — размер куба.\n\nВходные данные\n\nВыходные данныеЕсли решения не существует, то выведите -1. Иначе выведите искомую раскраску куба последовательно по слоям. В первых k строках выведите матрицу k × k — как должен быть раскрашен первый слой куба. В следующих k строках выведите матрицу k × k — как должен быть раскрашен второй слой куба. И так далее до последнего k-го слоя. Обратите внимание, что ориентация куба в пространстве не имеет значения.Единичный куб белого цвета обозначайте символом «w», черного — «b». Следуйте формату выходных данных, который указан в тестовых примерах. При проверке правильности ответа пустые строки никак не учитываются.\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать-1Входные данныеСкопировать2Выходные данныеСкопироватьbbwwbbww\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьbbwwbbww\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Testing Round #7 - Codeforces",
          "content": "Завтра, 28-го июня 2013 года в 00:00 состоится Testing Round #7. Цель этого раунда — хорошенько протестировать платформу. Недавно было сделано много улучшений/нововведений. В частности, большая часть проекта Codeforces была перенесена на другой сервер.Приглашаю вас принять участие. Раунд будет происходить по схеме Div.2 + неофициальное участие Div.1. Он будет состоять из трех задач, как определенная разминка — будет интересно всем. Я попрошу не участвовать тех, кто был на зимней школе в Харькове в этом году — вам эти задачи могут оказаться знакомы. Претесты в задачах будут необычно слабыми, чтобы спровоцировать побольше взломов. Конечно, раунд не будет влиять на рейтинг.Спасибо всем, кто примет участие!Upd. Раунд прошел удачно, огромная благодарность всем поучаствовавшим!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 782
        }
      ],
      "code_examples": [
        {
          "title": "Testing Round #7 - Codeforces - Code 1",
          "code": "В частности, большая часть проекта Codeforces была перенесена на другой сервер.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8177",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #7 - Codeforces - Code 2",
          "code": "a[x][y] = 1;\n    for (size_t i = 0; i < p; i++) { a[i][x] = 1; a[y][i] = 1; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8177",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #7 - Codeforces - Code 3",
          "code": "a[x][y] = 1;\n    for (size_t i = 0; i < p; i++) { a[i][x] = 1; a[y][i] = 1; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8177",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint k;\n\nint dx[6] = {1, -1, 0, 0, 0, 0};\nint dy[6] = {0, 0, 1, -1, 0, 0};\nint dz[6] = {0, 0, 0, 0, 1, -1};\n\nvoid readPainting(InStream& stream, int k, vector<vector<vector<char> > >& cube) {\n    vector<char> paintingData;\n    string token;\n\n    // We assume that the first token is already read before calling this function\n    while ((int)paintingData.size() < k * k * k) {\n        if (stream.eof()) {\n            stream.quitf(_wa, \"Unexpected end of file while reading painting\");\n        }\n        string line = stream.readLine();\n        for (char c : line) {\n            if (c == 'b' || c == 'w') {\n                paintingData.push_back(c);\n            } else if (isspace(c)) {\n                continue;\n            } else {\n                stream.quitf(_wa, \"Invalid character '%c' in painting\", c);\n            }\n            if ((int)paintingData.size() == k * k * k) {\n                break;\n            }\n        }\n    }\n\n    int index = 0;\n    for (int z = 0; z < k; z++) {\n        for (int y = 0; y < k; y++) {\n            for (int x = 0; x < k; x++) {\n                cube[z][y][x] = paintingData[index++];\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    k = inf.readInt(1, 100, \"k\");\n\n    // Read jury's answer\n    bool juryHasSolution;\n    string juryFirstToken = ans.readToken();\n    if (juryFirstToken == \"-1\") {\n        juryHasSolution = false;\n    } else {\n        juryHasSolution = true;\n        // We don't need to read the entire painting from ans\n    }\n\n    // Read participant's answer\n    bool participantHasSolution;\n    string participantFirstToken = ouf.readToken();\n    vector<vector<vector<char> > > cube;\n    if (participantFirstToken == \"-1\") {\n        participantHasSolution = false;\n    } else {\n        participantHasSolution = true;\n        // Initialize the cube\n        cube.assign(k, vector<vector<char> >(k, vector<char>(k)));\n        // Process participantFirstToken as part of painting data\n        vector<char> paintingData;\n        // Process participantFirstToken\n        for (char c : participantFirstToken) {\n            if (c == 'b' || c == 'w') {\n                paintingData.push_back(c);\n            } else {\n                ouf.quitf(_wa, \"Invalid character '%c' in painting\", c);\n            }\n        }\n        // Continue reading the painting data\n        while ((int)paintingData.size() < k * k * k) {\n            if (ouf.eof()) {\n                ouf.quitf(_wa, \"Unexpected end of file while reading painting\");\n            }\n            string line = ouf.readLine();\n            for (char c : line) {\n                if (c == 'b' || c == 'w') {\n                    paintingData.push_back(c);\n                } else if (isspace(c)) {\n                    continue;\n                } else {\n                    ouf.quitf(_wa, \"Invalid character '%c' in painting\", c);\n                }\n                if ((int)paintingData.size() == k * k * k) {\n                    break;\n                }\n            }\n        }\n        // Now build the cube\n        int index = 0;\n        for (int z = 0; z < k; z++) {\n            for (int y = 0; y < k; y++) {\n                for (int x = 0; x < k; x++) {\n                    cube[z][y][x] = paintingData[index++];\n                }\n            }\n        }\n        // Now check the conditions\n        for (int z = 0; z < k; z++) {\n            for (int y = 0; y < k; y++) {\n                for (int x = 0; x < k; x++) {\n                    int sameColorNeighborCount = 0;\n                    char currentColor = cube[z][y][x];\n                    for (int dir = 0; dir < 6; dir++) {\n                        int nx = x + dx[dir];\n                        int ny = y + dy[dir];\n                        int nz = z + dz[dir];\n                        if (nx >= 0 && nx < k && ny >= 0 && ny < k && nz >= 0 && nz < k) {\n                            if (cube[nz][ny][nx] == currentColor) {\n                                sameColorNeighborCount++;\n                            }\n                        }\n                    }\n                    if (sameColorNeighborCount != 2) {\n                        ouf.quitf(_wa, \"Cube at position (%d, %d, %d) has %d neighboring cubes of the same color, expected 2\",\n                                  x + 1, y + 1, z + 1, sameColorNeighborCount);\n                    }\n                }\n            }\n        }\n    }\n\n    // Now compare jury's and participant's answers\n    if (!juryHasSolution && !participantHasSolution) {\n        quitf(_ok, \"Correct: No solution exists\");\n    } else if (!juryHasSolution && participantHasSolution) {\n        ouf.quitf(_wa, \"Participant found a solution when none exists\");\n    } else if (juryHasSolution && !participantHasSolution) {\n        ouf.quitf(_wa, \"Participant claims no solution exists, but a solution exists\");\n    } else {\n        // Both have solutions, participant's solution is valid\n        quitf(_ok, \"Participant's solution is valid\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    int k_min = opt<int>(\"k_min\", 1);\n    int k_max = opt<int>(\"k_max\", 100);\n\n    ensure(1 <= k_min && k_min <= k_max && k_max <= 100);\n\n    if (k == -1){\n        if (type == \"small\"){\n            k = rnd.next(k_min, min(k_max,10));\n        } else if (type == \"large\"){\n            k = rnd.next(max(k_min,90), k_max);\n        } else if (type == \"even\"){\n            k = rnd.next((k_min+1)/2, k_max/2)*2;\n            if(k < k_min) k += 2;\n            if(k > k_max) k -= 2;\n        } else if (type == \"odd\"){\n            k = rnd.next(k_min/2, (k_max-1)/2)*2+1;\n            if(k < k_min) k += 2;\n            if(k > k_max) k -= 2;\n        } else if (type == \"max\"){\n            k = k_max;\n        } else if (type == \"min\"){\n            k = k_min;\n        } else if (type == \"random\"){\n            k = rnd.next(k_min, k_max);\n        } else {\n            k = rnd.next(k_min, k_max);\n        }\n    }\n    ensure(1 <= k && k <= 100);\n    printf(\"%d\\n\", k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    int k_min = opt<int>(\"k_min\", 1);\n    int k_max = opt<int>(\"k_max\", 100);\n\n    ensure(1 <= k_min && k_min <= k_max && k_max <= 100);\n\n    if (k == -1){\n        if (type == \"small\"){\n            k = rnd.next(k_min, min(k_max,10));\n        } else if (type == \"large\"){\n            k = rnd.next(max(k_min,90), k_max);\n        } else if (type == \"even\"){\n            k = rnd.next((k_min+1)/2, k_max/2)*2;\n            if(k < k_min) k += 2;\n            if(k > k_max) k -= 2;\n        } else if (type == \"odd\"){\n            k = rnd.next(k_min/2, (k_max-1)/2)*2+1;\n            if(k < k_min) k += 2;\n            if(k > k_max) k -= 2;\n        } else if (type == \"max\"){\n            k = k_max;\n        } else if (type == \"min\"){\n            k = k_min;\n        } else if (type == \"random\"){\n            k = rnd.next(k_min, k_max);\n        } else {\n            k = rnd.next(k_min, k_max);\n        }\n    }\n    ensure(1 <= k && k <= 100);\n    printf(\"%d\\n\", k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 1\n./gen -k 2\n./gen -k 3\n./gen -k 4\n./gen -k 5\n./gen -k 6\n./gen -k 7\n./gen -k 8\n./gen -k 9\n./gen -k 10\n\n./gen -k_min 1 -k_max 10 -type random\n./gen -k_min 1 -k_max 10 -type random\n\n./gen -k_min 1 -k_max 100 -type even\n./gen -k_min 1 -k_max 100 -type odd\n\n./gen -k_min 1 -k_max 100 -type small\n./gen -k_min 90 -k_max 100 -type large\n\n./gen -k_max 100 -type max\n./gen -k_min 1 -type min\n\n./gen -k 50\n./gen -k 99\n./gen -k 100\n\n./gen -k 17\n./gen -k 31\n./gen -k 52\n\n./gen -k_min 1 -k_max 100 -type random\n./gen -k_min 1 -k_max 100 -type random\n./gen -k_min 1 -k_max 100 -type random\n\n./gen -k 20\n./gen -k 40\n./gen -k 60\n./gen -k 80\n./gen -k 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:18.309181",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "323/B",
      "title": "Problem 323/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from input\n    int n = inf.readInt(3, 1000, \"n\");\n\n    // Read judge's answer\n    string jans = ans.readToken();\n\n    // Read participant's answer\n    string pans = ouf.readToken();\n\n    if (jans == \"-1\") {\n        // Judge output is \"-1\"\n        if (pans != \"-1\") {\n            quitf(_wa, \"Expected '-1', but participant output '%s'\", pans.c_str());\n        }\n        else {\n            // Correct, accept\n            quitf(_ok, \"Correctly output '-1'\");\n        }\n    }\n    else {\n        // Judge output is an adjacency matrix.\n        if (pans == \"-1\") {\n            quitf(_wa, \"Participant output '-1' but a solution exists\");\n        }\n\n        // Now, read the participant's adjacency matrix\n        vector<vector<int>> adj(n, vector<int>(n));\n\n        // Process the first token (pans)\n        int firstValue;\n        try {\n            firstValue = std::stoi(pans);\n        }\n        catch (...) {\n            quitf(_pe, \"Expected integer in participant's output, got '%s'\", pans.c_str());\n        }\n        if (firstValue != 0 && firstValue != 1) {\n            quitf(_wa, \"Matrix elements must be 0 or 1, got %d\", firstValue);\n        }\n        adj[0][0] = firstValue;\n\n        // Read the rest of the first line\n        for (int j = 1; j < n; ++j) {\n            adj[0][j] = ouf.readInt(0, 1, format(\"adj[1][%d]\", j+1).c_str());\n        }\n\n        // Read remaining n-1 lines\n        for (int i = 1; i < n; ++i) {\n            // Read n integers from the line\n            vector<int> row = ouf.readInts(n, 0, 1, format(\"adj[%d][*]\", i+1).c_str());\n            if ((int)row.size() != n) {\n                quitf(_pe, \"Expected %d integers in line %d, got %d\", n, i+1, (int)row.size());\n            }\n            adj[i] = row;\n        }\n\n        // Now perform the validations\n\n        // Check that av,v = 0 for all v\n        for (int v = 0; v < n; ++v) {\n            if (adj[v][v] != 0) {\n                quitf(_wa, \"adj[%d][%d] should be 0, found %d\", v+1, v+1, adj[v][v]);\n            }\n        }\n\n        // Check that for all v≠u, adj[v][u] + adj[u][v] == 1\n        for (int v = 0; v < n; ++v) {\n            for (int u = 0; u < n; ++u) {\n                if (v != u) {\n                    int sum = adj[v][u] + adj[u][v];\n                    if (sum != 1) {\n                        quitf(_wa, \"For vertices %d and %d, adj[%d][%d] + adj[%d][%d] = %d, should be 1\",\n                              v+1, u+1, v+1, u+1, u+1, v+1, sum);\n                    }\n                }\n            }\n        }\n\n        // Now check that for any pair of vertices v≠u,\n        // there is a path from v to u of length at most 2\n        for (int v = 0; v < n; ++v) {\n            for (int u = 0; u < n; ++u) {\n                if (v != u) {\n                    if (adj[v][u] == 1) {\n                        // There is a direct edge from v to u\n                        continue;\n                    } else {\n                        // Check if there is an intermediate w such that adj[v][w] ==1 and adj[w][u]==1\n                        bool found = false;\n                        for (int w = 0; w < n; ++w) {\n                            if (w != v && w != u && adj[v][w] == 1 && adj[w][u] == 1) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            quitf(_wa, \"No path from %d to %d of length at most 2\", v+1, u+1);\n                        }\n                    }\n                }\n            }\n        }\n\n        // All checks passed\n        quitf(_ok, \"Correct adjacency matrix\");\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 3;\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"odd\") {\n        n = rnd.next(3, 1000);\n        if (n % 2 == 0) {\n            if (n < 1000)\n                n = n + 1;\n            else\n                n = n - 1;\n        }\n    } else if (type == \"even\") {\n        n = rnd.next(3, 1000);\n        if (n % 2 == 1) {\n            if (n < 1000)\n                n = n + 1;\n            else\n                n = n - 1;\n        }\n    } else if (type == \"random\") {\n        n = rnd.next(3, 1000);\n    } else if (n == -1) {\n        n = rnd.next(3, 1000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 3;\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"odd\") {\n        n = rnd.next(3, 1000);\n        if (n % 2 == 0) {\n            if (n < 1000)\n                n = n + 1;\n            else\n                n = n - 1;\n        }\n    } else if (type == \"even\") {\n        n = rnd.next(3, 1000);\n        if (n % 2 == 1) {\n            if (n < 1000)\n                n = n + 1;\n            else\n                n = n - 1;\n        }\n    } else if (type == \"random\") {\n        n = rnd.next(3, 1000);\n    } else if (n == -1) {\n        n = rnd.next(3, 1000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n\n# Random odd n\n./gen -type odd\n./gen -type odd\n./gen -type odd\n\n# Random even n\n./gen -type even\n./gen -type even\n./gen -type even\n\n# Random n\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases\n./gen -type min\n./gen -type max\n\n# Large n values\n./gen -n 1000\n./gen -n 999\n./gen -n 998\n\n# Random n (repeats)\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Some specific values\n./gen -n 11\n./gen -n 12\n./gen -n 13\n./gen -n 14\n\n# Additional random n to reach about 30 commands\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:19.966976",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "323/C",
      "title": "C. Two permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains one integer n (1 ≤ n ≤ 106), the number of elements in both permutations. The following line contains n integers, separated with spaces: p1, p2, ..., pn (1 ≤ pi ≤ n). These are elements of the first permutation. The next line contains the second permutation q1, q2, ..., qn in same format.The following line contains an integer m (1 ≤ m ≤ 2·105), that is the number of queries.The following m lines contain descriptions of queries one in a line. The description of the i-th query consists of four integers: a, b, c, d (1 ≤ a, b, c, d ≤ n). Query parameters l1, r1, l2, r2 are obtained from the numbers a, b, c, d using the following algorithm:   Introduce variable x. If it is the first query, then the variable equals 0, else it equals the response for the previous query plus one.  Introduce function f(z) = ((z - 1 + x) mod n) + 1.  Suppose l1 = min(f(a), f(b)), r1 = max(f(a), f(b)), l2 = min(f(c), f(d)), r2 = max(f(c), f(d)).",
      "output_spec": "OutputPrint a response for each query in a separate line.",
      "sample_tests": "ExamplesInputCopy33 1 23 2 111 2 3 3OutputCopy1InputCopy44 3 2 12 3 4 131 2 3 41 3 2 11 4 2 3OutputCopy112",
      "description": "C. Two permutations\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains one integer n (1 ≤ n ≤ 106), the number of elements in both permutations. The following line contains n integers, separated with spaces: p1, p2, ..., pn (1 ≤ pi ≤ n). These are elements of the first permutation. The next line contains the second permutation q1, q2, ..., qn in same format.The following line contains an integer m (1 ≤ m ≤ 2·105), that is the number of queries.The following m lines contain descriptions of queries one in a line. The description of the i-th query consists of four integers: a, b, c, d (1 ≤ a, b, c, d ≤ n). Query parameters l1, r1, l2, r2 are obtained from the numbers a, b, c, d using the following algorithm:   Introduce variable x. If it is the first query, then the variable equals 0, else it equals the response for the previous query plus one.  Introduce function f(z) = ((z - 1 + x) mod n) + 1.  Suppose l1 = min(f(a), f(b)), r1 = max(f(a), f(b)), l2 = min(f(c), f(d)), r2 = max(f(c), f(d)).\n\nOutputPrint a response for each query in a separate line.\n\nInputCopy33 1 23 2 111 2 3 3OutputCopy1InputCopy44 3 2 12 3 4 131 2 3 41 3 2 11 4 2 3OutputCopy112\n\nInputCopy33 1 23 2 111 2 3 3\n\nOutputCopy1\n\nInputCopy44 3 2 12 3 4 131 2 3 41 3 2 11 4 2 3\n\nOutputCopy112",
      "solutions": [
        {
          "title": "Testing Round #7 - Codeforces",
          "content": "Testing Round #7 will start tomorrow on 28th of June 2013 at 00:00. Our goal is to test the platform after recent improvements. Recently, there have been many improvements / innovations. In particular, a large part of Codeforces was moved to another server.I invite you to take part. It will be Div.2 + unofficials from Div.1. It will contain three obsolescent problems. But I think it will be interesting for many of you. I ask not to compete those who have been on a winter school in Kharkov this year — perhaps, you can know the problems. The problems contain very weak pretests to force more hacks. Of course, the round will not affect the rating.Thanks to all who take part!Upd. Round has finished successfully, great thanks to all participants!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 750
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> q = inf.readInts(n, 1, n, \"q\");\n    inf.readEoln();\n\n    // Check that p is a permutation of 1..n\n    {\n        vector<bool> used_p(n+1, false);\n        for (int i = 0; i < n; ++i) {\n            int val = p[i];\n            ensuref(!used_p[val], \"p contains duplicate %d at position %d\", val, i+1);\n            used_p[val] = true;\n        }\n    }\n\n    // Check that q is a permutation of 1..n\n    {\n        vector<bool> used_q(n+1, false);\n        for (int i = 0; i < n; ++i) {\n            int val = q[i];\n            ensuref(!used_q[val], \"q contains duplicate %d at position %d\", val, i+1);\n            used_q[val] = true;\n        }\n    }\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c_i\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> q = inf.readInts(n, 1, n, \"q\");\n    inf.readEoln();\n\n    // Check that p is a permutation of 1..n\n    {\n        vector<bool> used_p(n+1, false);\n        for (int i = 0; i < n; ++i) {\n            int val = p[i];\n            ensuref(!used_p[val], \"p contains duplicate %d at position %d\", val, i+1);\n            used_p[val] = true;\n        }\n    }\n\n    // Check that q is a permutation of 1..n\n    {\n        vector<bool> used_q(n+1, false);\n        for (int i = 0; i < n; ++i) {\n            int val = q[i];\n            ensuref(!used_q[val], \"q contains duplicate %d at position %d\", val, i+1);\n            used_q[val] = true;\n        }\n    }\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c_i\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> q = inf.readInts(n, 1, n, \"q\");\n    inf.readEoln();\n\n    // Check that p is a permutation of 1..n\n    {\n        vector<bool> used_p(n+1, false);\n        for (int i = 0; i < n; ++i) {\n            int val = p[i];\n            ensuref(!used_p[val], \"p contains duplicate %d at position %d\", val, i+1);\n            used_p[val] = true;\n        }\n    }\n\n    // Check that q is a permutation of 1..n\n    {\n        vector<bool> used_q(n+1, false);\n        for (int i = 0; i < n; ++i) {\n            int val = q[i];\n            ensuref(!used_q[val], \"q contains duplicate %d at position %d\", val, i+1);\n            used_q[val] = true;\n        }\n    }\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c_i\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string ptype = opt<string>(\"ptype\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n    string qgen = opt<string>(\"qgen\", \"random\");\n\n    // Generate permutation p\n    vector<int> p(n);\n    if (ptype == \"identity\") {\n        for(int i = 0; i < n; ++i) p[i] = i + 1;\n    } else if (ptype == \"reverse\") {\n        for(int i = 0; i < n; ++i) p[i] = n - i;\n    } else if (ptype == \"random\") {\n        for(int i = 0; i < n; ++i) p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else if (ptype == \"almost_sorted\") {\n        for(int i = 0; i < n; ++i) p[i] = i + 1;\n        int swaps = n / 100; // Swap 1% of elements\n        for(int i = 0; i < swaps; ++i) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            swap(p[x], p[y]);\n        }\n    }\n\n    // Generate permutation q\n    vector<int> q(n);\n    if (qtype == \"identity\") {\n        for(int i = 0; i < n; ++i) q[i] = i + 1;\n    } else if (qtype == \"reverse\") {\n        for(int i = 0; i < n; ++i) q[i] = n - i;\n    } else if (qtype == \"same_as_p\") {\n        q = p;\n    } else if (qtype == \"random\") {\n        for(int i = 0; i < n; ++i) q[i] = i + 1;\n        shuffle(q.begin(), q.end());\n    } else if (qtype == \"shift\") {\n        int shift = opt<int>(\"shift\", 1);\n        for(int i = 0; i < n; ++i) {\n            q[i] = p[(i + shift) % n];\n        }\n    } else if (qtype == \"almost_p\") {\n        q = p;\n        int swaps = n / 100; // Swap 1% of elements\n        for(int i = 0; i < swaps; ++i) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            swap(q[x], q[y]);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output permutation p\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output permutation q\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", q[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Generate queries\n    for(int i = 0; i < m; ++i) {\n        int a, b, c, d;\n        if (qgen == \"random\") {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n            d = rnd.next(1, n);\n        } else if (qgen == \"max_segments\") {\n            a = 1; b = n;\n            c = 1; d = n;\n        } else if (qgen == \"min_segments\") {\n            a = b = rnd.next(1, n);\n            c = d = rnd.next(1, n);\n        } else {\n            // Default to random\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n            d = rnd.next(1, n);\n        }\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string ptype = opt<string>(\"ptype\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n    string qgen = opt<string>(\"qgen\", \"random\");\n\n    // Generate permutation p\n    vector<int> p(n);\n    if (ptype == \"identity\") {\n        for(int i = 0; i < n; ++i) p[i] = i + 1;\n    } else if (ptype == \"reverse\") {\n        for(int i = 0; i < n; ++i) p[i] = n - i;\n    } else if (ptype == \"random\") {\n        for(int i = 0; i < n; ++i) p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else if (ptype == \"almost_sorted\") {\n        for(int i = 0; i < n; ++i) p[i] = i + 1;\n        int swaps = n / 100; // Swap 1% of elements\n        for(int i = 0; i < swaps; ++i) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            swap(p[x], p[y]);\n        }\n    }\n\n    // Generate permutation q\n    vector<int> q(n);\n    if (qtype == \"identity\") {\n        for(int i = 0; i < n; ++i) q[i] = i + 1;\n    } else if (qtype == \"reverse\") {\n        for(int i = 0; i < n; ++i) q[i] = n - i;\n    } else if (qtype == \"same_as_p\") {\n        q = p;\n    } else if (qtype == \"random\") {\n        for(int i = 0; i < n; ++i) q[i] = i + 1;\n        shuffle(q.begin(), q.end());\n    } else if (qtype == \"shift\") {\n        int shift = opt<int>(\"shift\", 1);\n        for(int i = 0; i < n; ++i) {\n            q[i] = p[(i + shift) % n];\n        }\n    } else if (qtype == \"almost_p\") {\n        q = p;\n        int swaps = n / 100; // Swap 1% of elements\n        for(int i = 0; i < swaps; ++i) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            swap(q[x], q[y]);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output permutation p\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output permutation q\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", q[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Generate queries\n    for(int i = 0; i < m; ++i) {\n        int a, b, c, d;\n        if (qgen == \"random\") {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n            d = rnd.next(1, n);\n        } else if (qgen == \"max_segments\") {\n            a = 1; b = n;\n            c = 1; d = n;\n        } else if (qgen == \"min_segments\") {\n            a = b = rnd.next(1, n);\n            c = d = rnd.next(1, n);\n        } else {\n            // Default to random\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n            d = rnd.next(1, n);\n        }\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -m 1 -ptype identity -qtype identity -qgen random\n./gen -n 2 -m 1 -ptype identity -qtype reverse -qgen random\n./gen -n 5 -m 3 -ptype random -qtype random -qgen random\n./gen -n 10 -m 5 -ptype identity -qtype same_as_p -qgen random\n\n# Edge cases\n./gen -n 1 -m 1 -ptype identity -qtype identity -qgen max_segments\n./gen -n 1 -m 1 -ptype identity -qtype identity -qgen min_segments\n\n# Maximum size test cases\n./gen -n 1000000 -m 200000 -ptype random -qtype random -qgen random\n./gen -n 1000000 -m 200000 -ptype identity -qtype identity -qgen random\n./gen -n 1000000 -m 200000 -ptype identity -qtype reverse -qgen random\n./gen -n 1000000 -m 200000 -ptype random -qtype same_as_p -qgen random\n./gen -n 1000000 -m 200000 -ptype reverse -qtype reverse -qgen random\n\n# Special permutations\n./gen -n 1000000 -m 200000 -ptype reverse -qtype identity -qgen random\n./gen -n 1000000 -m 200000 -ptype identity -qtype shift -shift 1 -qgen random\n./gen -n 1000000 -m 200000 -ptype identity -qtype shift -shift 2 -qgen random\n./gen -n 1000000 -m 200000 -ptype identity -qtype shift -shift 500000 -qgen random\n\n# Queries with large segments\n./gen -n 1000000 -m 200000 -ptype random -qtype random -qgen max_segments\n\n# Queries with small segments\n./gen -n 1000000 -m 200000 -ptype random -qtype random -qgen min_segments\n\n# Mixed small n and large m\n./gen -n 10 -m 200000 -ptype random -qtype random -qgen random\n\n# Permutations that are almost the same\n./gen -n 1000000 -m 200000 -ptype random -qtype almost_p -qgen random\n\n# Permutations that are almost sorted\n./gen -n 1000000 -m 200000 -ptype almost_sorted -qtype almost_sorted -qgen random\n\n# Different combinations\n./gen -n 500000 -m 100000 -ptype random -qtype identity -qgen random\n./gen -n 500000 -m 100000 -ptype random -qtype reverse -qgen random\n\n# Edge case with n=1e6, m=1\n./gen -n 1000000 -m 1 -ptype random -qtype random -qgen random\n\n# Edge case with n=1, m=200000\n./gen -n 1 -m 200000 -ptype identity -qtype identity -qgen random\n\n# First query covering the whole range\n./gen -n 1000000 -m 1 -ptype random -qtype random -qgen max_segments\n\n# First query covering a single point\n./gen -n 1000000 -m 1 -ptype random -qtype random -qgen min_segments\n\n# Shifted permutations\n./gen -n 1000000 -m 200000 -ptype random -qtype shift -shift 100000 -qgen random\n\n# Small shifts\n./gen -n 1000000 -m 200000 -ptype random -qtype shift -shift 1 -qgen random\n\n# Reverse permutations\n./gen -n 1000000 -m 200000 -ptype random -qtype reverse -qgen random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:22.011084",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "325/A",
      "title": "A. Square and Rectangles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 5). Next n lines contain four integers each, describing a single rectangle: x1, y1, x2, y2 (0 ≤ x1 < x2 ≤ 31400, 0 ≤ y1 < y2 ≤ 31400) — x1 and x2 are x-coordinates of the left and right edges of the rectangle, and y1 and y2 are y-coordinates of the bottom and top edges of the rectangle. No two rectangles overlap (that is, there are no points that belong to the interior of more than one rectangle).",
      "output_spec": "OutputIn a single line print \"YES\", if the given rectangles form a square, or \"NO\" otherwise.",
      "sample_tests": "ExamplesInputCopy50 0 2 30 3 3 52 0 5 23 2 5 52 2 3 3OutputCopyYESInputCopy40 0 2 30 3 3 52 0 5 23 2 5 5OutputCopyNO",
      "description": "A. Square and Rectangles\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 5). Next n lines contain four integers each, describing a single rectangle: x1, y1, x2, y2 (0 ≤ x1 < x2 ≤ 31400, 0 ≤ y1 < y2 ≤ 31400) — x1 and x2 are x-coordinates of the left and right edges of the rectangle, and y1 and y2 are y-coordinates of the bottom and top edges of the rectangle. No two rectangles overlap (that is, there are no points that belong to the interior of more than one rectangle).\n\nOutputIn a single line print \"YES\", if the given rectangles form a square, or \"NO\" otherwise.\n\nInputCopy50 0 2 30 3 3 52 0 5 23 2 5 52 2 3 3OutputCopyYESInputCopy40 0 2 30 3 3 52 0 5 23 2 5 5OutputCopyNO\n\nInputCopy50 0 2 30 3 3 52 0 5 23 2 5 52 2 3 3\n\nOutputCopyYES\n\nInputCopy40 0 2 30 3 3 52 0 5 23 2 5 5\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces",
          "content": "Hello everyone!The first round of start[c]up is upon us. It is open to all participants. Registration works as a normal CodeForces round, and will close five minutes before the start of the contest.The contest uses normal Codeforces rules, and will be rated. The score distribution is 500-1000-2000-2000-2500.The problem set has been developed by MemSQL engineers pieguy, nika, exod40, SkidanovAlex and dolphinigle.Top 500 competitors will advance to the second round, with the top 25 Silicon Valley residents invited to participate on-site, where there will be special prizes.Good luck and happy coding!UPDATE: Please note that the score distribution has changed.UPDATE: Editorial is up now!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 692
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces",
          "content": "Square and RectanglesAuthor: AlexSkidanovWhat happens if the rectangles form an N × N square? Then these two conditions are necessary.1) The area must be exactly N × N.2) The length of its sides must be N. That means, the difference between the right side of the rightmost rectangle — the left side of the leftmost rectangle is N. Same for topmost and bottommost rectangles.We claim that, since the rectangles do not intersect, those two conditions are also sufficient.This is since if there are only N × N space inside the box bounded by the leftmost, rightmost, topmost, and bottommost rectangles.Thus if the sum of the area is exactly N × N, all space must be filled -- which forms a square.Stadium and GamesAuthor: nikaSuppose the \"divide-by-two\" stage happens exactly D times, and the round robin happens with M people.Then, the number of games held is: We would like that This is an equation with two variables -- to solve it, we can enumerate the value of one of the variables and calculate the value of the other one. We cannot enumerate the possible values of M, since M can vary from 1 to 10^9. However, we can enumerate D, since the number scales exponentially with D -- that is, we should only enumerate 0 ≤ D ≤ 62.Thus, the equation is reduced to Since this function is increasing, this can be solved via binary search on M.Monsters and DiamondsAuthor: AlexSkidanovFirst part of the problem is to find minimum number of diamonds one can achieve by starting with a given monster. To do so, we will be using Dijkstra algorithm. Originally we don't know the minimum for any monster. For every rule we will maintain how many monsters with unknown minimums it has (let's call it ki for the i-th rule). Let's take every rule that has only diamonds in it (i.e. which has ki = 0), and assign number of diamonds in that rule as a tentative minimum for the monster (if a monster has several diamonds-only rules, take the smallest one). Then take the monster, that has the smallest tentative minimum currently assigned. For that monster the tentative value is the actual minimum due to the same reasoning we use when we prove correctness of Dijkstra algorithm. Now, since we know the minimum for that monster, for every rule i that has that monster in its result subtract 1 from ki for every occurrence of the monster in the result of that rule. If for any rule the value of ki becomes zero, update the tentative minimum for the monster that rule belongs to with the sum of minimum values for each monster that rule generates plus the number of diamonds that rule generates. Then from all the monsters for which we don't known the minimum yet, but for which we know the tentative minimum, pick the one with the smallest tentative minimum, and continue on.At the end we will end up in a state, when each monster either has an actual minimum value assigned, or has no tentative value assigned. The latter monsters will have  - 1 - 1 as their answer. For the former monsters we know the minimum, but don't know the maximum yet.The second part of the problem is to find all the rules, after applying which we are guaranteed to never get rid of all the monsters. We will call such a rule bad. It is easy to show, that the rule bad if and only if it generates at least one monster with minimum value of -1. Remove all the bad rules from the set of rules.When bad rules are removed, finding maximums is trivial. Starting from every node for which maximum is not assigned yet, we traverse all the monsters in a DFS order. For a given monster, we consider every rule. For a given rule, for each monster it generates, we call DFS to find its maximum value, and then sum them up, add number of diamonds for the rule, and check if this rule gives bigger max value than the one currently known for the monster. If we ever call DFS for a monster, for which we already have a DFS call on the stack, that means that that monster has some way of producing itself (directly or indirectly) and some non-zero number of diamonds (this is why problem statement has a constraint that every rule generates at least one diamond), so the answer for the monster is -2. If, processing any rule, we encounter a monster with max value -2, we immediately assign -2 as a max value for the monster the rule belongs to and return from the DFS.As an exercise, think of a solution for the same problem, if rules are not guarantee to have at least one diamond in them.ReclamationAuthor: dolphinigleAssume there's an extra sea cells on a row above the topmost row, and a row below the bottom most row. Hence, we can assume that the top and bottom row consists entirely of sea.We claim that: There does not exist a sea route if and only if there exists a sequence of land cells that circumfere the planet (2 cells are adjacent if they share at least one point).The \"sufficient\" part of the proof is easy -- since there exists such a sequence, it separates the sea into the northern and southern hemisphere and this forms a barrier disallowing passage between the two.The \"necessary\" part. Suppose there does not exist such route. Then, if you perform a flood fill from any of the sea cell in the top row, you obtain a set of sea cells.Trace the southern boundary of these set of cells, and you obtain the sequence of land circumfering the planet.Thus, the algorithm works by simulating the reclamations one by one. Each time a land is going to be reclamated, we check if it would create a circumefering sequence. We will show that there's a way to do this check very quickly -- thus the algorithm should work within the time limit.Stick two copies of the grid together side-by-side, forming a Rx(2*C) grid. The leftmost and rightmost cells of any row in this new grid are also adjacent, similar to the given grid.Each time we're going to reclamate a land in row r and column c, we check if by doing so we would create a path going from (r, c) to (r, c + C). If it would, then we cancel the reclamation. Otherwise, we perform it, and add a land in cell (r, c) and (r, c+C).This \"is there a path from node X to node Y\" queries can be answered very very quickly using union find -- we check whether is it possible to go from one of the 8 neighbors of (r, c) to one of the 8 neighbors of (r, c+C).Correctness follows from the following: There exists a circumefering sequence IFF there exists a path from (r, c) to (r, c+C). Sufficient is easy. Suppose there exist a path from (r, c) to (r, c+C). We can form our circumfering sequence by overlapping the path from (r, c) to (r, c+C) with the same path, but going from (r, c+C) to (r, c) (we can do this since the grid is a two copies of the same grid sticked together).Necessary. Suppose there exists a circumfering sequence. We claim that there must exist a path to go from (r, c) to (r, c+C). Consider the concatenation of an infinite number of our initial grid, forming an Rx(infinite * C) grid. If there exists a circumfering sequence, we claim that within this grid, there exists a path from (r, c) to (r, c+C).Suppose there does not exist such a path. Since there exists a circumfering sequence, it must be possible to go from (r, c) to (r, c+ t * C), where t is an integer >= 2. Now, you should overlap all the paths taken to go from (r, c) to (r, c+t*C) in the grid (r', c' + C) (the grid immediately to the right of the grid where (r, c) is located). There must be a path from (r, c) to (r, c+C) in this new overlapped path.Proofing the final part is difficult without interactive illustration -- basically since t >= 2, there exists a path that goes from the left side to the right side of the grid (r', c' + C). This path must intersect with one of the overlapping paths, and that path must be connected to (r, c+C). The details are left as... exercise :p.The Red ButtonAuthor: nikaIn this part of editorial, all numbers we speak are in modulo N. So, if I say 10, it actually means 10 modulo N.First, observe that this problem asks us to find a cycle that visits each node exactly once, i.e., a hamiltonian cycle. Thus, for each node X, there exists one other node that we used to go to node X, and one node that we visit after node X. We call them bef(X) and aft(X) (shorthand for before and after).First we will show that if N is odd, then the answer is  - 1.Proof...? Consider node 0. What nodes points to node 0? Such node H must satisfy either of the following conditions:2H = 02H + 1 = 0The first condition is satisfied only by H = 0. The second condition is satisfied only by one value of H: floor(N / 2).So, since we need a hamiltonian cycle, pre[0] must be floor(N/2), and aft[floor(N/2)] = 0Now, consider node N - 1. What nodes points to node N - 1?2H = N - 12H + 1 = N - 1The second condition is satisfied only by H = N - 1. The first condition is satisfied only by H = floor(N / 2)But we need a hamiltonian cycle, so aft[floor(N/2)] must be N - 1. This is a contradiction with that aft[floor(N/2)] must be 0. Now, N is even. This case is much more interesting.Consider a node X. It is connected to 2X and 2X + 1. Consider the node X + N / 2. It is connected to 2X + N and 2X + 1 + N, which reduces to 2X and 2X + 1.So, apparently node X and node X + N / 2 are connected to the same set of values.Now, notice that each node X will have exactly two nodes pointing to it. This is since such node H must satisfy2H = X2H + 1 = Xmodulo N, each of those two equations have exactly one solution.So, this combined with that node X and X + N / 2 have the same set of connected nodes means that the only way to go to node 2X or 2X + 1 is from nodes X and X + N / 2.Thus, if you choose to go from node X to node 2X, you HAVE to go from node X + N / 2 to node 2X + 1 (or vice versa).Now, try to follow the rule above and generate any such configuration. This configuration will consists of cycles, possibly more than 1. Can we join them into a single large cycle, visiting all nodes?Yes we can, since those cycles are special.Weird theorem: If there are 2 +  cycles, then there must exist X and such node X and node X + N / 2 are in different cycles.Proof: Suppose not. We show that there must exist one cycle in that case. Since node X and X + N / 2 are in the same cycle, they must also be in the same cycle as node 2X and 2X + 1. In particular, node X and 2X and 2X + 1 are all in the same cycle. It is possible to go from any node X to any node Y by following this pattern (left as exercise). Now, consider the X such that node X and node X + N / 2 are in different cycles. Suppose we go from node X to node 2X + A, and from X + N / 2 to 2X + B (such that A + B = 1). Switch the route -- we go from node X to 2X + B and X + N / 2 to 2X + A instead. This will merge the two cycles -- very similar to how we merge two cycles when finding an eulerian path. Thus, we can keep doing this to obtain our cycle! ...It's not entirely obvious to do that in O(N) time. An example solution: use DFS. DFS from node 0. For each node X: if it has been visited, return if X + N / 2 has been visited, go to either 2X or 2X + 1 and recurse, depending on which route used by node X + N / 2 otherwise, we go to node 2X and recurse. Then, check if X + N / 2 was visited in the recursion. If it was not, then the two of them forms two different cycles. We merge them by switching our route to 2X + 1 instead, and recurse again.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11327
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 1",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 2",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces - Code 1",
          "code": "each of those two equations have exactly one solution.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces - Code 2",
          "code": "2 H + 1 = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces - Code 3",
          "code": "2 H = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readEoln();\n    vector<Rectangle> rects(n);\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(0, 31400, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(0, 31400, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(0, 31400, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(0, 31400, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"Rectangle %d: x1 must be less than x2\", i+1);\n        ensuref(y1 < y2, \"Rectangle %d: y1 must be less than y2\", i+1);\n\n        rects[i] = {x1, y1, x2, y2};\n    }\n\n    // Check that no two rectangles overlap in their interiors\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int xi1 = rects[i].x1;\n            int xi2 = rects[i].x2;\n            int xj1 = rects[j].x1;\n            int xj2 = rects[j].x2;\n            int yi1 = rects[i].y1;\n            int yi2 = rects[i].y2;\n            int yj1 = rects[j].y1;\n            int yj2 = rects[j].y2;\n            if (max(xi1, xj1) < min(xi2, xj2)\n                && max(yi1, yj1) < min(yi2, yj2))  {\n                ensuref(false, \"Rectangles %d and %d overlap in their interiors\", i + 1, j + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readEoln();\n    vector<Rectangle> rects(n);\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(0, 31400, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(0, 31400, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(0, 31400, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(0, 31400, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"Rectangle %d: x1 must be less than x2\", i+1);\n        ensuref(y1 < y2, \"Rectangle %d: y1 must be less than y2\", i+1);\n\n        rects[i] = {x1, y1, x2, y2};\n    }\n\n    // Check that no two rectangles overlap in their interiors\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int xi1 = rects[i].x1;\n            int xi2 = rects[i].x2;\n            int xj1 = rects[j].x1;\n            int xj2 = rects[j].x2;\n            int yi1 = rects[i].y1;\n            int yi2 = rects[i].y2;\n            int yj1 = rects[j].y1;\n            int yj2 = rects[j].y2;\n            if (max(xi1, xj1) < min(xi2, xj2)\n                && max(yi1, yj1) < min(yi2, yj2))  {\n                ensuref(false, \"Rectangles %d and %d overlap in their interiors\", i + 1, j + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readEoln();\n    vector<Rectangle> rects(n);\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(0, 31400, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(0, 31400, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(0, 31400, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(0, 31400, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"Rectangle %d: x1 must be less than x2\", i+1);\n        ensuref(y1 < y2, \"Rectangle %d: y1 must be less than y2\", i+1);\n\n        rects[i] = {x1, y1, x2, y2};\n    }\n\n    // Check that no two rectangles overlap in their interiors\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int xi1 = rects[i].x1;\n            int xi2 = rects[i].x2;\n            int xj1 = rects[j].x1;\n            int xj2 = rects[j].x2;\n            int yi1 = rects[i].y1;\n            int yi2 = rects[i].y2;\n            int yj1 = rects[j].y1;\n            int yj2 = rects[j].y2;\n            if (max(xi1, xj1) < min(xi2, xj2)\n                && max(yi1, yj1) < min(yi2, yj2))  {\n                ensuref(false, \"Rectangles %d and %d overlap in their interiors\", i + 1, j + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the parameters from the command line.\n    int n = opt<int>(\"n\", 1);\n    string type = opt<string>(\"type\", \"single_square\");\n\n    if (type == \"single_square\") {\n        n = 1; // Ensure n is 1\n        int maxCoord = 31400;\n        // Generate x1, y1\n        int maxStart = maxCoord - 1;\n        int x1 = rnd.next(0, maxStart);\n        int y1 = rnd.next(0, maxStart);\n        // Maximum possible side length\n        int maxLength = min(maxCoord - x1, maxCoord - y1);\n        int length = rnd.next(1, maxLength);\n        int x2 = x1 + length;\n        int y2 = y1 + length;\n        printf(\"%d\\n\", n);\n        printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    } else if (type == \"multiple_form_square\") {\n        // Ensure that n >= 2 and n <= 5\n        if (n < 2 || n > 5) n = 2 + rnd.next(0, 3); // Ensure n between 2 and 5\n\n        int maxCoord = 31400;\n        int maxStart = maxCoord - 1;\n        // Generate x1, y1\n        int x1 = rnd.next(0, maxStart);\n        int y1 = rnd.next(0, maxStart);\n        // Maximum possible side length\n        int maxLength = min(maxCoord - x1, maxCoord - y1);\n        int side_length = rnd.next(1, maxLength);\n\n        vector<tuple<int, int, int, int>> rectangles;\n\n        if (n == 2) {\n            // Split into two rectangles horizontally or vertically\n            if (rnd.next(0,1) == 0) {\n                // Vertical split\n                int split = rnd.next(1, side_length -1);\n                rectangles.push_back(make_tuple(x1, y1, x1 + split, y1 + side_length));\n                rectangles.push_back(make_tuple(x1 + split, y1, x1 + side_length, y1 + side_length));\n            } else {\n                // Horizontal split\n                int split = rnd.next(1, side_length -1);\n                rectangles.push_back(make_tuple(x1, y1, x1 + side_length, y1 + split));\n                rectangles.push_back(make_tuple(x1, y1 + split, x1 + side_length, y1 + side_length));\n            }\n        } else if (n == 3) {\n            // Split into three vertical slices\n            vector<int> splits;\n            splits.push_back(0);\n            splits.push_back(rnd.next(1, side_length - 2));\n            splits.push_back(rnd.next(splits[1] + 1, side_length - 1));\n            splits.push_back(side_length);\n            for (int i = 0; i < 3; ++i)\n                rectangles.push_back(make_tuple(x1 + splits[i], y1, x1 + splits[i+1], y1 + side_length));\n        } else if (n == 4) {\n            // Split into four smaller squares\n            int half = side_length / 2;\n            rectangles.push_back(make_tuple(x1, y1, x1 + half, y1 + half));\n            rectangles.push_back(make_tuple(x1 + half, y1, x1 + side_length, y1 + half));\n            rectangles.push_back(make_tuple(x1, y1 + half, x1 + half, y1 + side_length));\n            rectangles.push_back(make_tuple(x1 + half, y1 + half, x1 + side_length, y1 + side_length));\n        } else if (n == 5) {\n            // Split into five rectangles along x-axis\n            int segment = side_length / 5;\n            for (int i = 0; i < 5; ++i) {\n                int x_start = x1 + i * segment;\n                int x_end = (i == 4) ? x1 + side_length : x_start + segment;\n                rectangles.push_back(make_tuple(x_start, y1, x_end, y1 + side_length));\n            }\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"missing_piece\") {\n        // We generate a complete square and remove one rectangle\n        int total_rectangles = rnd.next(2, 5); // Number of rectangles before removal\n        int n_final = total_rectangles - 1; // Number of rectangles after removal\n\n        int maxCoord = 31400;\n        int maxStart = maxCoord - 1;\n        int x1 = rnd.next(0, maxStart);\n        int y1 = rnd.next(0, maxStart);\n        int maxLength = min(maxCoord - x1, maxCoord - y1);\n        int side_length = rnd.next(1, maxLength);\n\n        vector<tuple<int, int, int, int>> rectangles;\n\n        // Split the square into total_rectangles slices along x-axis\n        int segment = side_length / total_rectangles;\n        for (int i = 0; i < total_rectangles; ++i) {\n            int x_start = x1 + i * segment;\n            int x_end = (i == total_rectangles - 1) ? x1 + side_length : x_start + segment;\n            rectangles.push_back(make_tuple(x_start, y1, x_end, y1 + side_length));\n        }\n\n        // Remove one rectangle\n        int remove_idx = rnd.next(0, total_rectangles - 1);\n        rectangles.erase(rectangles.begin() + remove_idx);\n\n        n = n_final;\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"non_square_rectangle\") {\n        if (n < 1 || n > 5) n = 1 + rnd.next(0, 4);\n        int maxCoord = 31400;\n        int x1 = rnd.next(0, maxCoord - 1);\n        int y1 = rnd.next(0, maxCoord - 1);\n        int maxWidth = maxCoord - x1;\n        int maxHeight = maxCoord - y1;\n        int width = rnd.next(1, maxWidth);\n        int height;\n        do {\n            height = rnd.next(1, maxHeight);\n        } while (height == width); // Ensure it's not a square\n\n        vector<tuple<int, int, int, int>> rectangles;\n\n        if (n == 1) {\n            rectangles.push_back(make_tuple(x1, y1, x1 + width, y1 + height));\n        } else {\n            // Split along x or y axis\n            if (rnd.next(0,1) == 0) {\n                int segment = width / n;\n                for (int i = 0; i < n; ++i) {\n                    int x_start = x1 + i * segment;\n                    int x_end = (i == n - 1) ? x1 + width : x_start + segment;\n                    rectangles.push_back(make_tuple(x_start, y1, x_end, y1 + height));\n                }\n            } else {\n                int segment = height / n;\n                for (int i = 0; i < n; ++i) {\n                    int y_start = y1 + i * segment;\n                    int y_end = (i == n - 1) ? y1 + height : y_start + segment;\n                    rectangles.push_back(make_tuple(x1, y_start, x1 + width, y_end));\n                }\n            }\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"disconnected_pieces\") {\n        if (n < 1 || n > 5) n = 1 + rnd.next(0, 4);\n\n        int maxCoord = 31400;\n        vector<tuple<int, int, int, int>> rectangles;\n\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2;\n            bool valid = false;\n            while (!valid) {\n                x1 = rnd.next(0, maxCoord - 1);\n                y1 = rnd.next(0, maxCoord - 1);\n                int maxWidth = maxCoord - x1;\n                int maxHeight = maxCoord - y1;\n                x2 = x1 + rnd.next(1, maxWidth);\n                y2 = y1 + rnd.next(1, maxHeight);\n                valid = true;\n                for (const auto& rect : rectangles) {\n                    int xa1, ya1, xa2, ya2;\n                    tie(xa1, ya1, xa2, ya2) = rect;\n                    if (!(x2 <= xa1 || xa2 <= x1 || y2 <= ya1 || ya2 <= y1)) {\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n            rectangles.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"random\") {\n        if (n < 1 || n > 5) n = 1 + rnd.next(0, 4);\n\n        int maxCoord = 31400;\n        vector<tuple<int, int, int, int>> rectangles;\n\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2;\n            bool valid = false;\n            while (!valid) {\n                x1 = rnd.next(0, maxCoord - 1);\n                y1 = rnd.next(0, maxCoord - 1);\n                int maxWidth = maxCoord - x1;\n                int maxHeight = maxCoord - y1;\n                x2 = x1 + rnd.next(1, maxWidth);\n                y2 = y1 + rnd.next(1, maxHeight);\n                valid = true;\n                for (const auto& rect : rectangles) {\n                    int xa1, ya1, xa2, ya2;\n                    tie(xa1, ya1, xa2, ya2) = rect;\n                    if (!(x2 <= xa1 || xa2 <= x1 || y2 <= ya1 || ya2 <= y1)) {\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n            rectangles.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the parameters from the command line.\n    int n = opt<int>(\"n\", 1);\n    string type = opt<string>(\"type\", \"single_square\");\n\n    if (type == \"single_square\") {\n        n = 1; // Ensure n is 1\n        int maxCoord = 31400;\n        // Generate x1, y1\n        int maxStart = maxCoord - 1;\n        int x1 = rnd.next(0, maxStart);\n        int y1 = rnd.next(0, maxStart);\n        // Maximum possible side length\n        int maxLength = min(maxCoord - x1, maxCoord - y1);\n        int length = rnd.next(1, maxLength);\n        int x2 = x1 + length;\n        int y2 = y1 + length;\n        printf(\"%d\\n\", n);\n        printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    } else if (type == \"multiple_form_square\") {\n        // Ensure that n >= 2 and n <= 5\n        if (n < 2 || n > 5) n = 2 + rnd.next(0, 3); // Ensure n between 2 and 5\n\n        int maxCoord = 31400;\n        int maxStart = maxCoord - 1;\n        // Generate x1, y1\n        int x1 = rnd.next(0, maxStart);\n        int y1 = rnd.next(0, maxStart);\n        // Maximum possible side length\n        int maxLength = min(maxCoord - x1, maxCoord - y1);\n        int side_length = rnd.next(1, maxLength);\n\n        vector<tuple<int, int, int, int>> rectangles;\n\n        if (n == 2) {\n            // Split into two rectangles horizontally or vertically\n            if (rnd.next(0,1) == 0) {\n                // Vertical split\n                int split = rnd.next(1, side_length -1);\n                rectangles.push_back(make_tuple(x1, y1, x1 + split, y1 + side_length));\n                rectangles.push_back(make_tuple(x1 + split, y1, x1 + side_length, y1 + side_length));\n            } else {\n                // Horizontal split\n                int split = rnd.next(1, side_length -1);\n                rectangles.push_back(make_tuple(x1, y1, x1 + side_length, y1 + split));\n                rectangles.push_back(make_tuple(x1, y1 + split, x1 + side_length, y1 + side_length));\n            }\n        } else if (n == 3) {\n            // Split into three vertical slices\n            vector<int> splits;\n            splits.push_back(0);\n            splits.push_back(rnd.next(1, side_length - 2));\n            splits.push_back(rnd.next(splits[1] + 1, side_length - 1));\n            splits.push_back(side_length);\n            for (int i = 0; i < 3; ++i)\n                rectangles.push_back(make_tuple(x1 + splits[i], y1, x1 + splits[i+1], y1 + side_length));\n        } else if (n == 4) {\n            // Split into four smaller squares\n            int half = side_length / 2;\n            rectangles.push_back(make_tuple(x1, y1, x1 + half, y1 + half));\n            rectangles.push_back(make_tuple(x1 + half, y1, x1 + side_length, y1 + half));\n            rectangles.push_back(make_tuple(x1, y1 + half, x1 + half, y1 + side_length));\n            rectangles.push_back(make_tuple(x1 + half, y1 + half, x1 + side_length, y1 + side_length));\n        } else if (n == 5) {\n            // Split into five rectangles along x-axis\n            int segment = side_length / 5;\n            for (int i = 0; i < 5; ++i) {\n                int x_start = x1 + i * segment;\n                int x_end = (i == 4) ? x1 + side_length : x_start + segment;\n                rectangles.push_back(make_tuple(x_start, y1, x_end, y1 + side_length));\n            }\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"missing_piece\") {\n        // We generate a complete square and remove one rectangle\n        int total_rectangles = rnd.next(2, 5); // Number of rectangles before removal\n        int n_final = total_rectangles - 1; // Number of rectangles after removal\n\n        int maxCoord = 31400;\n        int maxStart = maxCoord - 1;\n        int x1 = rnd.next(0, maxStart);\n        int y1 = rnd.next(0, maxStart);\n        int maxLength = min(maxCoord - x1, maxCoord - y1);\n        int side_length = rnd.next(1, maxLength);\n\n        vector<tuple<int, int, int, int>> rectangles;\n\n        // Split the square into total_rectangles slices along x-axis\n        int segment = side_length / total_rectangles;\n        for (int i = 0; i < total_rectangles; ++i) {\n            int x_start = x1 + i * segment;\n            int x_end = (i == total_rectangles - 1) ? x1 + side_length : x_start + segment;\n            rectangles.push_back(make_tuple(x_start, y1, x_end, y1 + side_length));\n        }\n\n        // Remove one rectangle\n        int remove_idx = rnd.next(0, total_rectangles - 1);\n        rectangles.erase(rectangles.begin() + remove_idx);\n\n        n = n_final;\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"non_square_rectangle\") {\n        if (n < 1 || n > 5) n = 1 + rnd.next(0, 4);\n        int maxCoord = 31400;\n        int x1 = rnd.next(0, maxCoord - 1);\n        int y1 = rnd.next(0, maxCoord - 1);\n        int maxWidth = maxCoord - x1;\n        int maxHeight = maxCoord - y1;\n        int width = rnd.next(1, maxWidth);\n        int height;\n        do {\n            height = rnd.next(1, maxHeight);\n        } while (height == width); // Ensure it's not a square\n\n        vector<tuple<int, int, int, int>> rectangles;\n\n        if (n == 1) {\n            rectangles.push_back(make_tuple(x1, y1, x1 + width, y1 + height));\n        } else {\n            // Split along x or y axis\n            if (rnd.next(0,1) == 0) {\n                int segment = width / n;\n                for (int i = 0; i < n; ++i) {\n                    int x_start = x1 + i * segment;\n                    int x_end = (i == n - 1) ? x1 + width : x_start + segment;\n                    rectangles.push_back(make_tuple(x_start, y1, x_end, y1 + height));\n                }\n            } else {\n                int segment = height / n;\n                for (int i = 0; i < n; ++i) {\n                    int y_start = y1 + i * segment;\n                    int y_end = (i == n - 1) ? y1 + height : y_start + segment;\n                    rectangles.push_back(make_tuple(x1, y_start, x1 + width, y_end));\n                }\n            }\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"disconnected_pieces\") {\n        if (n < 1 || n > 5) n = 1 + rnd.next(0, 4);\n\n        int maxCoord = 31400;\n        vector<tuple<int, int, int, int>> rectangles;\n\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2;\n            bool valid = false;\n            while (!valid) {\n                x1 = rnd.next(0, maxCoord - 1);\n                y1 = rnd.next(0, maxCoord - 1);\n                int maxWidth = maxCoord - x1;\n                int maxHeight = maxCoord - y1;\n                x2 = x1 + rnd.next(1, maxWidth);\n                y2 = y1 + rnd.next(1, maxHeight);\n                valid = true;\n                for (const auto& rect : rectangles) {\n                    int xa1, ya1, xa2, ya2;\n                    tie(xa1, ya1, xa2, ya2) = rect;\n                    if (!(x2 <= xa1 || xa2 <= x1 || y2 <= ya1 || ya2 <= y1)) {\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n            rectangles.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    } else if (type == \"random\") {\n        if (n < 1 || n > 5) n = 1 + rnd.next(0, 4);\n\n        int maxCoord = 31400;\n        vector<tuple<int, int, int, int>> rectangles;\n\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2;\n            bool valid = false;\n            while (!valid) {\n                x1 = rnd.next(0, maxCoord - 1);\n                y1 = rnd.next(0, maxCoord - 1);\n                int maxWidth = maxCoord - x1;\n                int maxHeight = maxCoord - y1;\n                x2 = x1 + rnd.next(1, maxWidth);\n                y2 = y1 + rnd.next(1, maxHeight);\n                valid = true;\n                for (const auto& rect : rectangles) {\n                    int xa1, ya1, xa2, ya2;\n                    tie(xa1, ya1, xa2, ya2) = rect;\n                    if (!(x2 <= xa1 || xa2 <= x1 || y2 <= ya1 || ya2 <= y1)) {\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n            rectangles.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n and the rectangles\n        printf(\"%d\\n\", n);\n        for (const auto& rect : rectangles) {\n            int x1_r, y1_r, x2_r, y2_r;\n            tie(x1_r, y1_r, x2_r, y2_r) = rect;\n            printf(\"%d %d %d %d\\n\", x1_r, y1_r, x2_r, y2_r);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_square\n\n./gen -n 2 -type multiple_form_square\n./gen -n 3 -type multiple_form_square\n./gen -n 4 -type multiple_form_square\n./gen -n 5 -type multiple_form_square\n\n./gen -n 2 -type missing_piece\n./gen -n 3 -type missing_piece\n./gen -n 4 -type missing_piece\n\n./gen -n 1 -type non_square_rectangle\n./gen -n 2 -type non_square_rectangle\n./gen -n 3 -type non_square_rectangle\n./gen -n 4 -type non_square_rectangle\n./gen -n 5 -type non_square_rectangle\n\n./gen -n 2 -type disconnected_pieces\n./gen -n 3 -type disconnected_pieces\n./gen -n 4 -type disconnected_pieces\n./gen -n 5 -type disconnected_pieces\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:24.204764",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "325/B",
      "title": "B. Стадион и игры",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 1018), количество игр, которое следует сыграть.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите все возможные количества команд, при которых будет сыграно ровно n игр, в порядке возрастания. Если ни при каком количестве команд не будет сыграно ровно n игр, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать3Выходные данныеСкопировать34Входные данныеСкопировать25Выходные данныеСкопировать20Входные данныеСкопировать2Выходные данныеСкопировать-1",
      "description": "B. Стадион и игры\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 1018), количество игр, которое следует сыграть.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите все возможные количества команд, при которых будет сыграно ровно n игр, в порядке возрастания. Если ни при каком количестве команд не будет сыграно ровно n игр, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать3Выходные данныеСкопировать34Входные данныеСкопировать25Выходные данныеСкопировать20Входные данныеСкопировать2Выходные данныеСкопировать-1\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать34\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать25\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать20\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces",
          "content": "Всем привет!Первый раунд start[c]up начнется совсем скоро. Участвовать могут все желающие, никакой дополнительной регистрации, кроме регистрации на сам раунд, не требуется. Регистрация закрывается за пять минут до начала раунда.Раунд пройдет по правилам codeforces и будет рейтинговым. Распределение баллов будет следующее: 500-1000-2000-2000-2500.Задачи приготовлены разработчиками MemSQL pieguy, nika, exod40, SkidanovAlex и dolphinigle.Лучшие 500 участников пройдут во второй раунд, а 25 лучших участников из Кремниевой Долины будут приглашены участвовать во втором раунде онсайт, где будут разыгрываться специальные призы.Удачи на раунде и приятного кодинга!UPDATE: Обратите внимание, что распределение баллов изменилосьUPDATE: Опубликован разбор задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 757
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces",
          "content": "Квадрат и ПрямоугольникиАвтор: AlexSkidanovЕсли несколько прямоугольников образуют квадрат N × N, то следующие два условия обязательно выплняются:1) Суммарная площадь прямоугольников равна N × N.2) Разница между правой границей самого правого прямоугольника и левой границей самого левого прямоугольника ровно N. Аналогично для нижней и верхней границы.Легко показать, что эти условия являются также и достаточными.Стадион и ИгрыАвтор: nikaПусть прошло D раундов на выбывание, и круговой раунд с M командами.Тогда общее количество сыгранных игр: Мы хотим, чтобы Это уравнение с двумя неизвестными, чтобы его решить, можно зафиксировать значение одной из них, и найти значение другой. Мы не можем перебрать все значения для M, так как M может достигать 10^9. Однако, мы можем перебрать все значения D, так как количество игр растет экспоненциально с ростом D -- поэтому D может принять значения только в интервале 0 ≤ D ≤ 62.Когда D зафиксировано, остается решить следующее уравнение: Так как левая часть уравнения возрастает, M можно найти двоичным поиском.Монстры и БриллиантыАвтор: AlexSkidanovПервая часть задачи -- найти минимум для каждого монстра. Чтобы это сделать, мы будем использовать алгоритм Дейкстры. Изначально минимум не известен ни для одного монстра. Для каждого превращения будем поддерживать величину, указывающую на количество монстров, которые это превращение создает, для которых минимум еще не известен (назовем его ki для i-ого превращения). Сначала рассмотрим каждое превращение, которое создает только бриллианты (то есть для которого ki = 0), и скажем, что это количество бриллиантов -- это временный минимум для монстра, которому принадлежит превращение (если у монстра есть более одного превращения в бриллианты, надо взять то, которое создает минимальное количество бриллиантов). Затем возьмем монстра с минимальным временным минимумом. Для этого монстра временный минимум является финальным минимумом. Это можно доказать используя подход, похожий на подход к доказательству алгоритма Дейкстры. Так как для этого монстра минимум известен, уменьшим ki для каждого превращения, которое производит этого монстра. Если для какого-то превращения ki стало равно нулю, обновим временный минимум для монстра, которому принадлежит это преврещение суммой минимумов по всем монстрам, которых это превращение производит, и количества бриллиантов, которые это превращение производит. Затем, среди всех монстров, для которых финальный минимум еще не известен, но известен временный, выберем того, для которого временный минимум минимален, и повторим процесс.Когда монстров, для которых есть временный минимум, но нет финального, не осталось, все монстры, для которых минимум не нашелся, будут иметь  - 1 - 1 в качестве ответа. Для остальных монстров мы знаем минимум, но не знаем максимум.Вторая часть решения -- избавиться от превращений, выполнив которые мы никогда не сможем избавиться от всех монстров. Легко показать, что такими превращениями являются те, в результате которых появляется хотя бы один монстр, для которого минимум равен  - 1. Уберем все такие превращения из набора превращений.После этого найти максимумы очень легко. Начиная из каждого монстра, для которого максимум еще не известен, будем обходить монстров обходом в глубину. Для данного монстра, рассмотрим все превращения. Для конкретного превращения, для каждого монстра, который появляется в результате этого превращения, вызовем DFS чтобы найти максимум для этого монстра, просуммируем эти величины, прибавим количество бриллиантов, которые это превращение создает, и улучшим известный максимум для монстра, которому принадлежит это правило, полученной величиной. Если мы в какой-то момент времени попадаем в ситуацию, когда DFS вызван для монстра, для которого уже есть вызов DFS на стеке, это значит, что этот монстр может превратиться сам в себя (непосредственно или через других монстров) и ненулевое количество бриллиантов (по этой причине в условии оговаривается, что каждое превращение генерирует хотя бы один бриллиант), поэтому ответ для такого монстра -2. Если, обрабатывая одно из превращений, мы обнаружили, что в результате применения превращения появится монстр, для которого максимум равен -2, мы можем сразу назначить максимум для текущего монстра в -2 и выйти из DFS.В качестве упражнения подумайте, как решить эту же задачу, если не гарантируется, что каждое превращение содержит хотя бы один бриллиант.Царство и ГосударствоАвтор: dolphinigleДля простоты допустим, что над самой первой строкой и под самой последней строкой есть по дополнительной строке с морем.Раздвоим поверхность цилиндра, добавив его справа к самому себе (при этом левый столбец раздвоенного моря по прежднему смежен с правым столбцом). Каждое превращение будем осуществлять в обеих половинах. Утверждается, что торгового маршрута не существует тогда и только тогда, когда для некоторой превращенной ячейки она достижима из своей копии по превращенным ячейкам (две превращенных ячейки смежны, если у них есть хотя бы одна общая точка, не обязательно общая сторона).Доказать тот факт, что это услвоие достаточно, очень легко. Путь между ячейкой и ее копией разбивает море на северную и южную часть, и представляет из себя барьер между этими половинами, который ни один торговый маршрут не может пересечь.Докажем необходимость условия. Пусть ни для какой превращенной ячейки ее копия не достижима по превращенным ячейкам. Тогда возьмем все ячейки, содержащие море, прилегающие к верхней границе, и найдем все достижимые из них ячейки с морем (две ячейки с морем смежны, если у них есть общая сторона). Пусть ни одна ячейка с морем, достижимая таким образом, не прилегает к нижней границе. Тогда возьмем самую нижнюю достижимую ячейку с морем (любую если их несколько), и начнем двигаться вправо вдоль морских ячеек, по превращенным ячейкам. Легко показать, что двигаясь по превращенным ячейкам, имеющим хотя бы одну общую точку, вдоль границы моря, мы опишем круг вокруг цилиндра и вернемся в ячейку, с который мы начали, что противоречит тому, что ни для какой превращенной ячейки ее копия не достижима из нее.Дальше будем решать задачу моделируя запросы. Будем поддерживать компоненты связности превращенных ячеек используя систему непересекающихся множеств. Каждый раз, когда ячейка превращается, убедимся, что эта ячейка и ее копия не содержат соседей, принадлежащих одной компоненте связности. Если такие соседи есть, то после превращение этой ячейки, она и ее копия окажутся в одной компоненте связности, тем самым не оставив ни одного торгового маршрута. Если таких соседей нет, то превращаем ячейку, и объединяем все компоненты связности, прилегающие к ней, затем превращаем копию ячейки, и объединяем все компоненты связности, прилегающие к ней.В этой задаче стоит отдельно рассмотреть случай, когда столбец только один (тогда ни одно превращение нельзя осуществить), и когда столбцов два (тогда у каждой ячейки только 5 соседей, а не восемь, что может привести к ошибкам в некоторых реализациях).Тропинки и ПолянкиАвтор: nikaВ этом разборе все числа подрузмеваются по модулю N. Если в разборе встречается число 10, имеется ввиду 10 по модулю N.В задаче нас просят найти гамильтонов цикл в графе. Для каждой вершины гамильтонова цикла через bef(X) будем обозначать предыдущую вершину в цикле а через aft(X) -- следующую.Сначала покажем, что ответ -1 для любого нечетного N.Рассмотрим вершину 0. Для любой вершины H, ведущей в 0, выполняются два условия:2H = 02H + 1 = 0Первому условию удовлетворяет только H = 0. Второму условию удовлетворяет только floor(N / 2).Иными словами, pre[0] = floor(N/2), и aft[floor(N/2)] = 0Теперь рассмотрим вершину N - 1. В нее ведут вершины, для которых верно2H = N - 12H + 1 = N - 1Второе условие выполняется только при H = N - 1. Первое условие выполняется только при H = floor(N / 2)Иными словами, aft[floor(N/2)] равен N - 1. Это противоречит тому, что aft[floor(N/2)] должен быть 0. Тем самым доказано, что N четно. Этот случай намного интереснее.Рассмотрим вершину X. Из нее есть ребра в 2X и 2X + 1. Рассмотрим вершину X + N / 2. Из нее есть ребра в.... 2X + N и 2X + 1 + N. ...что по модулю N равно 2X и 2X + 1.Значит, для вершин X и X + N / 2 множество исходящий ребер идентично.Легко показать, что для каждой вершины X есть ровно два входящий ребра. Это следует из того, что в вершину X ребра идут только из вершин таких, что2H = X2H + 1 = Xпо модулю N, и каждое из этих уравнений имеет ровно одно решение.Факт, что каждая вершина имеет ровно два входящий ребра, вместе с фактом что X и X + N / 2 имеют одинаковое множество исходящий ребер, дает нам понять, что в вершины 2X и 2X + 1 есть ребра только из X и X + N / 2.Иными словами, если мы решили взять ребро из X в 2X в гамильтонов цикл, мы обязаны взять ребро из X + N / 2 в 2X + 1 в цикл тоже (и наоборот).Теперь, следуя правилу выше, для вершин X, X + N / 2 возьмем любые два из четырех ребер в 2X, 2X + 1. В итоге мы возьмем ровно N ребер, которые образуют некоторое количество простых циклов. Можем ли мы легко объединить? Оказывается, что в силу особенностей этих циклов, мы можем это сделать.Утверждение: если есть два или более цикла, то есть вершина X такая, что X и X + N / 2 принадлежат разным циклам.Доказательство: Пусть это не так. Покажем, что в этом случае есть только один цикл. Так как вершины X и X + N / 2 принадлежат одному циклу, они должны быть в одном цикле с 2X и 2X + 1. Так как X и 2X и 2X + 1 все принадлежат одному циклу, легко показать, что из любой вершины X можно попасть в любую другую вершину Y (доказательство этого остается в качестве упражнения). Теперь, расммотрим X такое, что X и X + N / 2 принадлежат разным циклам. Пусть из вершины X сейчас выбрано ребро в 2X + A, а из вершины X + N / 2 -- в 2X + B (A + B = 1). Поменяем их местрами -- пойдем из X в 2X + B и из X + N / 2 в 2X + A. Это соединит два цикла в один -- идея очень похожа на идею построения эйлерова цикла. После каждой такой операции количество циклов уменьшается на один, и в итоге останется только один цикл. Осталось понять, как это сделать за O(N). Примером решения может быть DFS из вершины 0. Для каждой вершины X: если мы в ней уже были, возвращаемся из DFS если X + N / 2 была посещена, идем либо в 2X либо в 2X + 1 рекурсивно, в зависимсти от того, куда сейчас ведет ребро, выбранное для X + N / 2 (пойдем в вершину, в которую то ребро не ведет) иначе, идем рекурсивно в 2X. Затем проверяем, смогли ли мы посетить в рекурсии X + N / 2. Если нет, значит они принадлежат разным циклам. Соединим их, и рекурсивно спустимся в 2X + 1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 10528
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 1",
          "code": "хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 2",
          "code": "множество точек, лежащих внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 3",
          "code": "Даны множества. Объединение множеств - набор элементов, лежащих хотя бы в одном множестве",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 4",
          "code": "проверьте если данные прямоугольники составляют квадрат",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 5",
          "code": "множество точек, лежащих внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 6",
          "code": "внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 7",
          "code": "Как по мне, так это в чистом виде определение объединения",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 8",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 9",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 10",
          "code": "codeforces.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 11",
          "code": "[относительные ссылки](/blog/entry/8341)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 1",
          "code": "each of those two equations have exactly one solution.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 2",
          "code": "2 H + 1 = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 3",
          "code": "2 H = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll compute_games(ll t) {\n    ll total_games = 0;\n    ll teams = t;\n    while (teams >= 2 && teams % 2 == 0) {\n        ll games_in_stage = teams / 2;\n        total_games += games_in_stage;\n        teams /= 2;\n    }\n    if (teams > 1) {\n        // Round robin stage\n        total_games += teams * (teams - 1) / 2;\n    }\n    return total_games;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int cases = opt<int>(\"cases\", 1);\n\n    for (int i = 0; i < cases; ++i) {\n        if (type == \"sample\") {\n            // Sample inputs from the problem statement\n            if (i % 3 == 0) printf(\"3\\n\"); // Sample input 1\n            else if (i % 3 == 1) printf(\"25\\n\"); // Sample input 2\n            else printf(\"2\\n\"); // Sample input 3 (no solution)\n        } else if (type == \"small\") {\n            // Small t values\n            ll t = rnd.next(1LL, 10LL);\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"large\") {\n            // Large t values\n            ll t = rnd.next(1e17 + 1, 1e18);\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"edge\") {\n            // Edge cases for t\n            ll t;\n            if (i % 3 == 0) t = 1; // Minimum t\n            else if (i % 3 == 1) t = 2; // Small even t\n            else t = 1000000000000000000LL; // Maximum t\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"no-solution\") {\n            // n values with no possible t\n            // Known n with no solution is 2 (from sample)\n            ll n = 2;\n            if (i % 2 == 0) n = 2;\n            else n = 0; // Zero games (invalid)\n            printf(\"%lld\\n\", n);\n        } else if (type == \"multiple-solutions\") {\n            // n values that can be achieved by multiple t\n            ll n;\n            if (i % 2 == 0) n = 3; // n = 3 corresponds to t = 3 and t = 4\n            else n = 6; // n = 6 can correspond to multiple t\n            printf(\"%lld\\n\", n);\n        } else if (type == \"random\") {\n            // Random n values\n            ll n = rnd.next(1LL, 1000000000000000000LL);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"specific-t\") {\n            // Specific t value provided\n            ll t = opt<ll>(\"t\");\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else {\n            // Default random n\n            ll n = rnd.next(1LL, 1000000000000000000LL);\n            printf(\"%lld\\n\", n);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll compute_games(ll t) {\n    ll total_games = 0;\n    ll teams = t;\n    while (teams >= 2 && teams % 2 == 0) {\n        ll games_in_stage = teams / 2;\n        total_games += games_in_stage;\n        teams /= 2;\n    }\n    if (teams > 1) {\n        // Round robin stage\n        total_games += teams * (teams - 1) / 2;\n    }\n    return total_games;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int cases = opt<int>(\"cases\", 1);\n\n    for (int i = 0; i < cases; ++i) {\n        if (type == \"sample\") {\n            // Sample inputs from the problem statement\n            if (i % 3 == 0) printf(\"3\\n\"); // Sample input 1\n            else if (i % 3 == 1) printf(\"25\\n\"); // Sample input 2\n            else printf(\"2\\n\"); // Sample input 3 (no solution)\n        } else if (type == \"small\") {\n            // Small t values\n            ll t = rnd.next(1LL, 10LL);\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"large\") {\n            // Large t values\n            ll t = rnd.next(1e17 + 1, 1e18);\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"edge\") {\n            // Edge cases for t\n            ll t;\n            if (i % 3 == 0) t = 1; // Minimum t\n            else if (i % 3 == 1) t = 2; // Small even t\n            else t = 1000000000000000000LL; // Maximum t\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"no-solution\") {\n            // n values with no possible t\n            // Known n with no solution is 2 (from sample)\n            ll n = 2;\n            if (i % 2 == 0) n = 2;\n            else n = 0; // Zero games (invalid)\n            printf(\"%lld\\n\", n);\n        } else if (type == \"multiple-solutions\") {\n            // n values that can be achieved by multiple t\n            ll n;\n            if (i % 2 == 0) n = 3; // n = 3 corresponds to t = 3 and t = 4\n            else n = 6; // n = 6 can correspond to multiple t\n            printf(\"%lld\\n\", n);\n        } else if (type == \"random\") {\n            // Random n values\n            ll n = rnd.next(1LL, 1000000000000000000LL);\n            printf(\"%lld\\n\", n);\n        } else if (type == \"specific-t\") {\n            // Specific t value provided\n            ll t = opt<ll>(\"t\");\n            ll n = compute_games(t);\n            printf(\"%lld\\n\", n);\n        } else {\n            // Default random n\n            ll n = rnd.next(1LL, 1000000000000000000LL);\n            printf(\"%lld\\n\", n);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Sample test cases from the problem statement\n./gen -type sample -cases 3\n\n# Small t test cases\n./gen -type small -cases 1\n./gen -type small -cases 1\n./gen -type small -cases 1\n./gen -type small -cases 1\n./gen -type small -cases 1\n\n# Large t test cases\n./gen -type large -cases 1\n./gen -type large -cases 1\n./gen -type large -cases 1\n./gen -type large -cases 1\n./gen -type large -cases 1\n\n# Edge case test cases\n./gen -type edge -cases 1\n./gen -type edge -cases 1\n./gen -type edge -cases 1\n./gen -type edge -cases 1\n./gen -type edge -cases 1\n\n# No solution test cases\n./gen -type no-solution -cases 1\n./gen -type no-solution -cases 1\n./gen -type no-solution -cases 1\n./gen -type no-solution -cases 1\n./gen -type no-solution -cases 1\n\n# Multiple solutions test cases\n./gen -type multiple-solutions -cases 1\n./gen -type multiple-solutions -cases 1\n./gen -type multiple-solutions -cases 1\n./gen -type multiple-solutions -cases 1\n./gen -type multiple-solutions -cases 1\n\n# Random n test cases\n./gen -type random -cases 1\n./gen -type random -cases 1\n./gen -type random -cases 1\n./gen -type random -cases 1\n./gen -type random -cases 1\n\n# Specific t test cases\n./gen -type specific-t -t 1\n./gen -type specific-t -t 2\n./gen -type specific-t -t 3\n./gen -type specific-t -t 4\n./gen -type specific-t -t 5\n\n./gen -type specific-t -t 10\n./gen -type specific-t -t 100\n./gen -type specific-t -t 1000\n./gen -type specific-t -t 1000000\n./gen -type specific-t -t 1000000000\n\n./gen -type specific-t -t 999999999999999999\n./gen -type specific-t -t 1000000000000000000\n\n# Additional random test cases\n./gen -type random -cases 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:26.074387",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "325/C",
      "title": "C. Монстры и бриллианты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится два целых числа: m и n (1 ≤ m, n ≤ 105), количество возможных превращений и количество различных типов монстров. В последующих m строках перечислены превращения по одному в строке. Описание каждого превращения начинается с целого числа (типа монстра) mi (1 ≤ mi ≤ n), а затем положительного целого числа li, обозначающего количество монстров и бриллиантов, в которые может превратиться текущий монстр. Далее в строке следуют li целых чисел — во что превращается текущий монстр: положительное число обозначает монстра соответствующего типа, -1 обозначает бриллиант.Для каждого типа монстра существует хотя бы одно превращение. Каждое превращение содержит хотя бы один бриллиант. Сумма всех li не превышает 105.",
      "output_spec": "Выходные данныеДля каждого типа монстра, в порядке их номеров, выведите одну строку с двумя целыми числами: минимальное и максимальное количество бриллиантов, которое можно получить к моменту, когда на полянке не останется ни одного монстра, если начать с одним монстром этого типа. Если, начав с этого монстра, Красная Шапочка не имеет никакого шанса остаться без монстров на полянке, выведите -1 вместо минимального и -1 вместо максимального значения. Если, начав с этим монстром, Красная Шапочка может получить произвольно большое количество бриллиантов, выведите -2 вместо максимального значения. Если любое значение в выходных данных превышает 314000000 (но является конечным), выведите 314000000 вместо этого значения.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 41 3 -1 1 -11 2 -1 -12 3 -1 3 -12 3 -1 -1 -13 2 -1 -14 2 4 -1Выходные данныеСкопировать2 -23 42 2-1 -1Входные данныеСкопировать3 21 2 1 -12 2 -1 -12 3 2 1 -1Выходные данныеСкопировать-1 -12 2",
      "description": "C. Монстры и бриллианты\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится два целых числа: m и n (1 ≤ m, n ≤ 105), количество возможных превращений и количество различных типов монстров. В последующих m строках перечислены превращения по одному в строке. Описание каждого превращения начинается с целого числа (типа монстра) mi (1 ≤ mi ≤ n), а затем положительного целого числа li, обозначающего количество монстров и бриллиантов, в которые может превратиться текущий монстр. Далее в строке следуют li целых чисел — во что превращается текущий монстр: положительное число обозначает монстра соответствующего типа, -1 обозначает бриллиант.Для каждого типа монстра существует хотя бы одно превращение. Каждое превращение содержит хотя бы один бриллиант. Сумма всех li не превышает 105.\n\nВходные данные\n\nВыходные данныеДля каждого типа монстра, в порядке их номеров, выведите одну строку с двумя целыми числами: минимальное и максимальное количество бриллиантов, которое можно получить к моменту, когда на полянке не останется ни одного монстра, если начать с одним монстром этого типа. Если, начав с этого монстра, Красная Шапочка не имеет никакого шанса остаться без монстров на полянке, выведите -1 вместо минимального и -1 вместо максимального значения. Если, начав с этим монстром, Красная Шапочка может получить произвольно большое количество бриллиантов, выведите -2 вместо максимального значения. Если любое значение в выходных данных превышает 314000000 (но является конечным), выведите 314000000 вместо этого значения.\n\nВыходные данные\n\nВходные данныеСкопировать6 41 3 -1 1 -11 2 -1 -12 3 -1 3 -12 3 -1 -1 -13 2 -1 -14 2 4 -1Выходные данныеСкопировать2 -23 42 2-1 -1Входные данныеСкопировать3 21 2 1 -12 2 -1 -12 3 2 1 -1Выходные данныеСкопировать-1 -12 2\n\nВходные данныеСкопировать6 41 3 -1 1 -11 2 -1 -12 3 -1 3 -12 3 -1 -1 -13 2 -1 -14 2 4 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 -23 42 2-1 -1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 21 2 1 -12 2 -1 -12 3 2 1 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1 -12 2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces",
          "content": "Всем привет!Первый раунд start[c]up начнется совсем скоро. Участвовать могут все желающие, никакой дополнительной регистрации, кроме регистрации на сам раунд, не требуется. Регистрация закрывается за пять минут до начала раунда.Раунд пройдет по правилам codeforces и будет рейтинговым. Распределение баллов будет следующее: 500-1000-2000-2000-2500.Задачи приготовлены разработчиками MemSQL pieguy, nika, exod40, SkidanovAlex и dolphinigle.Лучшие 500 участников пройдут во второй раунд, а 25 лучших участников из Кремниевой Долины будут приглашены участвовать во втором раунде онсайт, где будут разыгрываться специальные призы.Удачи на раунде и приятного кодинга!UPDATE: Обратите внимание, что распределение баллов изменилосьUPDATE: Опубликован разбор задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 757
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces",
          "content": "Квадрат и ПрямоугольникиАвтор: AlexSkidanovЕсли несколько прямоугольников образуют квадрат N × N, то следующие два условия обязательно выплняются:1) Суммарная площадь прямоугольников равна N × N.2) Разница между правой границей самого правого прямоугольника и левой границей самого левого прямоугольника ровно N. Аналогично для нижней и верхней границы.Легко показать, что эти условия являются также и достаточными.Стадион и ИгрыАвтор: nikaПусть прошло D раундов на выбывание, и круговой раунд с M командами.Тогда общее количество сыгранных игр: Мы хотим, чтобы Это уравнение с двумя неизвестными, чтобы его решить, можно зафиксировать значение одной из них, и найти значение другой. Мы не можем перебрать все значения для M, так как M может достигать 10^9. Однако, мы можем перебрать все значения D, так как количество игр растет экспоненциально с ростом D -- поэтому D может принять значения только в интервале 0 ≤ D ≤ 62.Когда D зафиксировано, остается решить следующее уравнение: Так как левая часть уравнения возрастает, M можно найти двоичным поиском.Монстры и БриллиантыАвтор: AlexSkidanovПервая часть задачи -- найти минимум для каждого монстра. Чтобы это сделать, мы будем использовать алгоритм Дейкстры. Изначально минимум не известен ни для одного монстра. Для каждого превращения будем поддерживать величину, указывающую на количество монстров, которые это превращение создает, для которых минимум еще не известен (назовем его ki для i-ого превращения). Сначала рассмотрим каждое превращение, которое создает только бриллианты (то есть для которого ki = 0), и скажем, что это количество бриллиантов -- это временный минимум для монстра, которому принадлежит превращение (если у монстра есть более одного превращения в бриллианты, надо взять то, которое создает минимальное количество бриллиантов). Затем возьмем монстра с минимальным временным минимумом. Для этого монстра временный минимум является финальным минимумом. Это можно доказать используя подход, похожий на подход к доказательству алгоритма Дейкстры. Так как для этого монстра минимум известен, уменьшим ki для каждого превращения, которое производит этого монстра. Если для какого-то превращения ki стало равно нулю, обновим временный минимум для монстра, которому принадлежит это преврещение суммой минимумов по всем монстрам, которых это превращение производит, и количества бриллиантов, которые это превращение производит. Затем, среди всех монстров, для которых финальный минимум еще не известен, но известен временный, выберем того, для которого временный минимум минимален, и повторим процесс.Когда монстров, для которых есть временный минимум, но нет финального, не осталось, все монстры, для которых минимум не нашелся, будут иметь  - 1 - 1 в качестве ответа. Для остальных монстров мы знаем минимум, но не знаем максимум.Вторая часть решения -- избавиться от превращений, выполнив которые мы никогда не сможем избавиться от всех монстров. Легко показать, что такими превращениями являются те, в результате которых появляется хотя бы один монстр, для которого минимум равен  - 1. Уберем все такие превращения из набора превращений.После этого найти максимумы очень легко. Начиная из каждого монстра, для которого максимум еще не известен, будем обходить монстров обходом в глубину. Для данного монстра, рассмотрим все превращения. Для конкретного превращения, для каждого монстра, который появляется в результате этого превращения, вызовем DFS чтобы найти максимум для этого монстра, просуммируем эти величины, прибавим количество бриллиантов, которые это превращение создает, и улучшим известный максимум для монстра, которому принадлежит это правило, полученной величиной. Если мы в какой-то момент времени попадаем в ситуацию, когда DFS вызван для монстра, для которого уже есть вызов DFS на стеке, это значит, что этот монстр может превратиться сам в себя (непосредственно или через других монстров) и ненулевое количество бриллиантов (по этой причине в условии оговаривается, что каждое превращение генерирует хотя бы один бриллиант), поэтому ответ для такого монстра -2. Если, обрабатывая одно из превращений, мы обнаружили, что в результате применения превращения появится монстр, для которого максимум равен -2, мы можем сразу назначить максимум для текущего монстра в -2 и выйти из DFS.В качестве упражнения подумайте, как решить эту же задачу, если не гарантируется, что каждое превращение содержит хотя бы один бриллиант.Царство и ГосударствоАвтор: dolphinigleДля простоты допустим, что над самой первой строкой и под самой последней строкой есть по дополнительной строке с морем.Раздвоим поверхность цилиндра, добавив его справа к самому себе (при этом левый столбец раздвоенного моря по прежднему смежен с правым столбцом). Каждое превращение будем осуществлять в обеих половинах. Утверждается, что торгового маршрута не существует тогда и только тогда, когда для некоторой превращенной ячейки она достижима из своей копии по превращенным ячейкам (две превращенных ячейки смежны, если у них есть хотя бы одна общая точка, не обязательно общая сторона).Доказать тот факт, что это услвоие достаточно, очень легко. Путь между ячейкой и ее копией разбивает море на северную и южную часть, и представляет из себя барьер между этими половинами, который ни один торговый маршрут не может пересечь.Докажем необходимость условия. Пусть ни для какой превращенной ячейки ее копия не достижима по превращенным ячейкам. Тогда возьмем все ячейки, содержащие море, прилегающие к верхней границе, и найдем все достижимые из них ячейки с морем (две ячейки с морем смежны, если у них есть общая сторона). Пусть ни одна ячейка с морем, достижимая таким образом, не прилегает к нижней границе. Тогда возьмем самую нижнюю достижимую ячейку с морем (любую если их несколько), и начнем двигаться вправо вдоль морских ячеек, по превращенным ячейкам. Легко показать, что двигаясь по превращенным ячейкам, имеющим хотя бы одну общую точку, вдоль границы моря, мы опишем круг вокруг цилиндра и вернемся в ячейку, с который мы начали, что противоречит тому, что ни для какой превращенной ячейки ее копия не достижима из нее.Дальше будем решать задачу моделируя запросы. Будем поддерживать компоненты связности превращенных ячеек используя систему непересекающихся множеств. Каждый раз, когда ячейка превращается, убедимся, что эта ячейка и ее копия не содержат соседей, принадлежащих одной компоненте связности. Если такие соседи есть, то после превращение этой ячейки, она и ее копия окажутся в одной компоненте связности, тем самым не оставив ни одного торгового маршрута. Если таких соседей нет, то превращаем ячейку, и объединяем все компоненты связности, прилегающие к ней, затем превращаем копию ячейки, и объединяем все компоненты связности, прилегающие к ней.В этой задаче стоит отдельно рассмотреть случай, когда столбец только один (тогда ни одно превращение нельзя осуществить), и когда столбцов два (тогда у каждой ячейки только 5 соседей, а не восемь, что может привести к ошибкам в некоторых реализациях).Тропинки и ПолянкиАвтор: nikaВ этом разборе все числа подрузмеваются по модулю N. Если в разборе встречается число 10, имеется ввиду 10 по модулю N.В задаче нас просят найти гамильтонов цикл в графе. Для каждой вершины гамильтонова цикла через bef(X) будем обозначать предыдущую вершину в цикле а через aft(X) -- следующую.Сначала покажем, что ответ -1 для любого нечетного N.Рассмотрим вершину 0. Для любой вершины H, ведущей в 0, выполняются два условия:2H = 02H + 1 = 0Первому условию удовлетворяет только H = 0. Второму условию удовлетворяет только floor(N / 2).Иными словами, pre[0] = floor(N/2), и aft[floor(N/2)] = 0Теперь рассмотрим вершину N - 1. В нее ведут вершины, для которых верно2H = N - 12H + 1 = N - 1Второе условие выполняется только при H = N - 1. Первое условие выполняется только при H = floor(N / 2)Иными словами, aft[floor(N/2)] равен N - 1. Это противоречит тому, что aft[floor(N/2)] должен быть 0. Тем самым доказано, что N четно. Этот случай намного интереснее.Рассмотрим вершину X. Из нее есть ребра в 2X и 2X + 1. Рассмотрим вершину X + N / 2. Из нее есть ребра в.... 2X + N и 2X + 1 + N. ...что по модулю N равно 2X и 2X + 1.Значит, для вершин X и X + N / 2 множество исходящий ребер идентично.Легко показать, что для каждой вершины X есть ровно два входящий ребра. Это следует из того, что в вершину X ребра идут только из вершин таких, что2H = X2H + 1 = Xпо модулю N, и каждое из этих уравнений имеет ровно одно решение.Факт, что каждая вершина имеет ровно два входящий ребра, вместе с фактом что X и X + N / 2 имеют одинаковое множество исходящий ребер, дает нам понять, что в вершины 2X и 2X + 1 есть ребра только из X и X + N / 2.Иными словами, если мы решили взять ребро из X в 2X в гамильтонов цикл, мы обязаны взять ребро из X + N / 2 в 2X + 1 в цикл тоже (и наоборот).Теперь, следуя правилу выше, для вершин X, X + N / 2 возьмем любые два из четырех ребер в 2X, 2X + 1. В итоге мы возьмем ровно N ребер, которые образуют некоторое количество простых циклов. Можем ли мы легко объединить? Оказывается, что в силу особенностей этих циклов, мы можем это сделать.Утверждение: если есть два или более цикла, то есть вершина X такая, что X и X + N / 2 принадлежат разным циклам.Доказательство: Пусть это не так. Покажем, что в этом случае есть только один цикл. Так как вершины X и X + N / 2 принадлежат одному циклу, они должны быть в одном цикле с 2X и 2X + 1. Так как X и 2X и 2X + 1 все принадлежат одному циклу, легко показать, что из любой вершины X можно попасть в любую другую вершину Y (доказательство этого остается в качестве упражнения). Теперь, расммотрим X такое, что X и X + N / 2 принадлежат разным циклам. Пусть из вершины X сейчас выбрано ребро в 2X + A, а из вершины X + N / 2 -- в 2X + B (A + B = 1). Поменяем их местрами -- пойдем из X в 2X + B и из X + N / 2 в 2X + A. Это соединит два цикла в один -- идея очень похожа на идею построения эйлерова цикла. После каждой такой операции количество циклов уменьшается на один, и в итоге останется только один цикл. Осталось понять, как это сделать за O(N). Примером решения может быть DFS из вершины 0. Для каждой вершины X: если мы в ней уже были, возвращаемся из DFS если X + N / 2 была посещена, идем либо в 2X либо в 2X + 1 рекурсивно, в зависимсти от того, куда сейчас ведет ребро, выбранное для X + N / 2 (пойдем в вершину, в которую то ребро не ведет) иначе, идем рекурсивно в 2X. Затем проверяем, смогли ли мы посетить в рекурсии X + N / 2. Если нет, значит они принадлежат разным циклам. Соединим их, и рекурсивно спустимся в 2X + 1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 10528
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 1",
          "code": "хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 2",
          "code": "множество точек, лежащих внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 3",
          "code": "Даны множества. Объединение множеств - набор элементов, лежащих хотя бы в одном множестве",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 4",
          "code": "проверьте если данные прямоугольники составляют квадрат",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 5",
          "code": "множество точек, лежащих внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 6",
          "code": "внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 7",
          "code": "Как по мне, так это в чистом виде определение объединения",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 8",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 9",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 10",
          "code": "codeforces.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 11",
          "code": "[относительные ссылки](/blog/entry/8341)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 1",
          "code": "each of those two equations have exactly one solution.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 2",
          "code": "2 H + 1 = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 3",
          "code": "2 H = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<bool> monster_has_rule(n+1, false);\n    int total_li = 0;\n    for (int i = 0; i < m; ++i) {\n        int mi = inf.readInt(1, n, \"mi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 100000, \"li\");\n        ensuref(li >=1, \"li must be at least 1\");\n        total_li += li;\n        ensuref(total_li <= 100000, \"Sum of li over all split rules exceeds 1e5\");\n        monster_has_rule[mi] = true;\n        bool has_diamond = false;\n        for (int j = 0; j < li; ++j) {\n            inf.readSpace();\n            int x = inf.readInt(-1, n, \"split_element\");\n            ensuref(x != 0, \"Split element cannot be 0\");\n            ensuref(x == -1 || (x >= 1 && x <= n), \"Split element must be -1 or integer in [1, n], but got %d\", x);\n            if (x == -1)\n                has_diamond = true;\n        }\n        inf.readEoln();\n        ensuref(has_diamond, \"Each split rule must contain at least one diamond (-1)\");\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(monster_has_rule[i], \"Monster %d does not have any split rules\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<bool> monster_has_rule(n+1, false);\n    int total_li = 0;\n    for (int i = 0; i < m; ++i) {\n        int mi = inf.readInt(1, n, \"mi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 100000, \"li\");\n        ensuref(li >=1, \"li must be at least 1\");\n        total_li += li;\n        ensuref(total_li <= 100000, \"Sum of li over all split rules exceeds 1e5\");\n        monster_has_rule[mi] = true;\n        bool has_diamond = false;\n        for (int j = 0; j < li; ++j) {\n            inf.readSpace();\n            int x = inf.readInt(-1, n, \"split_element\");\n            ensuref(x != 0, \"Split element cannot be 0\");\n            ensuref(x == -1 || (x >= 1 && x <= n), \"Split element must be -1 or integer in [1, n], but got %d\", x);\n            if (x == -1)\n                has_diamond = true;\n        }\n        inf.readEoln();\n        ensuref(has_diamond, \"Each split rule must contain at least one diamond (-1)\");\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(monster_has_rule[i], \"Monster %d does not have any split rules\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<bool> monster_has_rule(n+1, false);\n    int total_li = 0;\n    for (int i = 0; i < m; ++i) {\n        int mi = inf.readInt(1, n, \"mi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 100000, \"li\");\n        ensuref(li >=1, \"li must be at least 1\");\n        total_li += li;\n        ensuref(total_li <= 100000, \"Sum of li over all split rules exceeds 1e5\");\n        monster_has_rule[mi] = true;\n        bool has_diamond = false;\n        for (int j = 0; j < li; ++j) {\n            inf.readSpace();\n            int x = inf.readInt(-1, n, \"split_element\");\n            ensuref(x != 0, \"Split element cannot be 0\");\n            ensuref(x == -1 || (x >= 1 && x <= n), \"Split element must be -1 or integer in [1, n], but got %d\", x);\n            if (x == -1)\n                has_diamond = true;\n        }\n        inf.readEoln();\n        ensuref(has_diamond, \"Each split rule must contain at least one diamond (-1)\");\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(monster_has_rule[i], \"Monster %d does not have any split rules\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxM = 100000;\n    int maxLiSum = 100000;\n\n    if (type == \"random\") {\n        if (m == -1) m = min(maxM, n + rnd.next(0, n));\n\n        vector<vector<int>> monsterSplits(n+1); // monsterSplits[i] is a list of indexes into splitRules\n\n        vector<vector<int>> splitRules; // Each split rule: [mi, li, items...]\n\n        int totalLiSum = 0;\n\n        // First, ensure each monster has at least one split rule\n\n        for (int i = 1; i <= n; ++i)\n        {\n            // Create at least one split rule for monster i\n            int mi = i;\n            int li = rnd.next(1, 3); // number of items in the split, can adjust\n            vector<int> items;\n            int diamonds = rnd.next(1, li); // Must have at least one diamond\n            for (int j = 0; j < diamonds; ++j)\n                items.push_back(-1); // diamonds\n\n            for (int j = diamonds; j < li; ++j)\n                items.push_back(rnd.next(1, n)); // random monster ID\n\n            shuffle(items.begin(), items.end());\n\n            totalLiSum += li;\n            if (totalLiSum > maxLiSum)\n                break; // Reached the limit\n\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n            monsterSplits[mi].push_back(splitRules.size() -1);\n        }\n\n        // Now, create remaining split rules randomly until m or totalLiSum reaches the limit\n\n        while ((int)splitRules.size() < m && totalLiSum < maxLiSum)\n        {\n            int mi = rnd.next(1, n); // Random monster\n            int li = rnd.next(1, 4);\n            vector<int> items;\n            int diamonds = rnd.next(1, li); // Must have at least one diamond\n            for (int j = 0; j < diamonds; ++j)\n                items.push_back(-1); // diamonds\n\n            for (int j = diamonds; j < li; ++j)\n                items.push_back(rnd.next(1, n)); // random monster ID\n\n            shuffle(items.begin(), items.end());\n\n            totalLiSum += li;\n            if (totalLiSum > maxLiSum)\n                break; // Reached the limit\n\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n            monsterSplits[mi].push_back(splitRules.size() -1);\n        }\n\n        // Output m and n\n        printf(\"%d %d\\n\", (int)splitRules.size(), n);\n\n        // Output split rules\n        for (auto &rule : splitRules)\n        {\n            for (size_t i = 0; i < rule.size(); ++i)\n            {\n                if (i > 0) printf(\" \");\n                printf(\"%d\", rule[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"impossible\")\n    {\n        if (m == -1) m = n;\n\n        int totalLiSum = 0;\n        vector<vector<int>> splitRules;\n\n        // For first monster, create split rules that always produce itself\n        {\n            int mi = 1;\n            int li = 2; // One diamond and itself\n            vector<int> items;\n            items.push_back(-1); // diamond\n            items.push_back(1); // itself\n\n            totalLiSum += li;\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // For other monsters, generate random split rules that can be eliminated\n        for (int mi = 2; mi <= n; ++mi)\n        {\n            int li = 1;\n            vector<int> items;\n            items.push_back(-1); // diamond\n\n            totalLiSum += li;\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Output\n        printf(\"%d %d\\n\", (int)splitRules.size(), n);\n        for (auto &rule : splitRules)\n        {\n            for (size_t i = 0; i < rule.size(); ++i)\n            {\n                if (i > 0) printf(\" \");\n                printf(\"%d\", rule[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"infinite\")\n    {\n        if (n < 2) n = 2;\n        if (m == -1) m = n;\n\n        vector<vector<int>> splitRules;\n\n        // Monster 1 split rule 1: splits into -1 (diamond) and Monster 2\n        {\n            int mi = 1;\n            int li = 2;\n            vector<int> items = {-1, 2}; // diamond and Monster 2\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Monster 1 split rule 2: splits into diamond only\n        {\n            int mi = 1;\n            int li = 1;\n            vector<int> items = {-1}; // diamond only\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Monster 2 split rule: splits into Monster 1 only\n        {\n            int mi = 2;\n            int li = 1;\n            vector<int> items = {1}; // Monster 1\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // For remaining monsters, generate random rules\n        for (int mi = 3; mi <= n && (int)splitRules.size() < m; ++mi)\n        {\n            int li = 1;\n            vector<int> items;\n            items.push_back(-1); // diamond\n\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Output\n        printf(\"%d %d\\n\", (int)splitRules.size(), n);\n        for (auto &rule : splitRules)\n        {\n            for (size_t i = 0; i < rule.size(); ++i)\n            {\n                if (i > 0) printf(\" \");\n                printf(\"%d\", rule[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"minimal\")\n    {\n        int mi = 1;\n        int li = 1;\n\n        vector<int> items = {-1}; // Only a diamond\n\n        // Output\n        printf(\"1 %d\\n\", n);\n        printf(\"%d %d %d\\n\", mi, li, items[0]);\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxM = 100000;\n    int maxLiSum = 100000;\n\n    if (type == \"random\") {\n        if (m == -1) m = min(maxM, n + rnd.next(0, n));\n\n        vector<vector<int>> monsterSplits(n+1); // monsterSplits[i] is a list of indexes into splitRules\n\n        vector<vector<int>> splitRules; // Each split rule: [mi, li, items...]\n\n        int totalLiSum = 0;\n\n        // First, ensure each monster has at least one split rule\n\n        for (int i = 1; i <= n; ++i)\n        {\n            // Create at least one split rule for monster i\n            int mi = i;\n            int li = rnd.next(1, 3); // number of items in the split, can adjust\n            vector<int> items;\n            int diamonds = rnd.next(1, li); // Must have at least one diamond\n            for (int j = 0; j < diamonds; ++j)\n                items.push_back(-1); // diamonds\n\n            for (int j = diamonds; j < li; ++j)\n                items.push_back(rnd.next(1, n)); // random monster ID\n\n            shuffle(items.begin(), items.end());\n\n            totalLiSum += li;\n            if (totalLiSum > maxLiSum)\n                break; // Reached the limit\n\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n            monsterSplits[mi].push_back(splitRules.size() -1);\n        }\n\n        // Now, create remaining split rules randomly until m or totalLiSum reaches the limit\n\n        while ((int)splitRules.size() < m && totalLiSum < maxLiSum)\n        {\n            int mi = rnd.next(1, n); // Random monster\n            int li = rnd.next(1, 4);\n            vector<int> items;\n            int diamonds = rnd.next(1, li); // Must have at least one diamond\n            for (int j = 0; j < diamonds; ++j)\n                items.push_back(-1); // diamonds\n\n            for (int j = diamonds; j < li; ++j)\n                items.push_back(rnd.next(1, n)); // random monster ID\n\n            shuffle(items.begin(), items.end());\n\n            totalLiSum += li;\n            if (totalLiSum > maxLiSum)\n                break; // Reached the limit\n\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n            monsterSplits[mi].push_back(splitRules.size() -1);\n        }\n\n        // Output m and n\n        printf(\"%d %d\\n\", (int)splitRules.size(), n);\n\n        // Output split rules\n        for (auto &rule : splitRules)\n        {\n            for (size_t i = 0; i < rule.size(); ++i)\n            {\n                if (i > 0) printf(\" \");\n                printf(\"%d\", rule[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"impossible\")\n    {\n        if (m == -1) m = n;\n\n        int totalLiSum = 0;\n        vector<vector<int>> splitRules;\n\n        // For first monster, create split rules that always produce itself\n        {\n            int mi = 1;\n            int li = 2; // One diamond and itself\n            vector<int> items;\n            items.push_back(-1); // diamond\n            items.push_back(1); // itself\n\n            totalLiSum += li;\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // For other monsters, generate random split rules that can be eliminated\n        for (int mi = 2; mi <= n; ++mi)\n        {\n            int li = 1;\n            vector<int> items;\n            items.push_back(-1); // diamond\n\n            totalLiSum += li;\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Output\n        printf(\"%d %d\\n\", (int)splitRules.size(), n);\n        for (auto &rule : splitRules)\n        {\n            for (size_t i = 0; i < rule.size(); ++i)\n            {\n                if (i > 0) printf(\" \");\n                printf(\"%d\", rule[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"infinite\")\n    {\n        if (n < 2) n = 2;\n        if (m == -1) m = n;\n\n        vector<vector<int>> splitRules;\n\n        // Monster 1 split rule 1: splits into -1 (diamond) and Monster 2\n        {\n            int mi = 1;\n            int li = 2;\n            vector<int> items = {-1, 2}; // diamond and Monster 2\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Monster 1 split rule 2: splits into diamond only\n        {\n            int mi = 1;\n            int li = 1;\n            vector<int> items = {-1}; // diamond only\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Monster 2 split rule: splits into Monster 1 only\n        {\n            int mi = 2;\n            int li = 1;\n            vector<int> items = {1}; // Monster 1\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // For remaining monsters, generate random rules\n        for (int mi = 3; mi <= n && (int)splitRules.size() < m; ++mi)\n        {\n            int li = 1;\n            vector<int> items;\n            items.push_back(-1); // diamond\n\n            splitRules.push_back({mi, li});\n            splitRules.back().insert(splitRules.back().end(), items.begin(), items.end());\n        }\n\n        // Output\n        printf(\"%d %d\\n\", (int)splitRules.size(), n);\n        for (auto &rule : splitRules)\n        {\n            for (size_t i = 0; i < rule.size(); ++i)\n            {\n                if (i > 0) printf(\" \");\n                printf(\"%d\", rule[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"minimal\")\n    {\n        int mi = 1;\n        int li = 1;\n\n        vector<int> items = {-1}; // Only a diamond\n\n        // Output\n        printf(\"1 %d\\n\", n);\n        printf(\"%d %d %d\\n\", mi, li, items[0]);\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal\n./gen -n 2 -type minimal\n./gen -n 5 -type impossible\n./gen -n 10 -type impossible\n./gen -n 10000 -type impossible\n./gen -n 100000 -type impossible\n\n./gen -n 2 -type infinite\n./gen -n 5 -type infinite\n./gen -n 10 -type infinite\n./gen -n 10000 -type infinite\n./gen -n 100000 -type infinite\n\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 50000 -type random\n./gen -n 50000 -m 100000 -type random\n./gen -n 1 -m 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:27.995195",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "325/D",
      "title": "D. Reclamation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line consists of three integers r, c, and n (1 ≤ r, c ≤ 3000, 1 ≤ n ≤ 3·105). Then, n lines follow, describing the cells in the order you will reclamate them. Each line will consists of two integers: ri and ci (1 ≤ ri ≤ r, 1 ≤ ci ≤ c), which represents the cell located at row ri and column ci. All of the lines describing the cells will be distinct.",
      "output_spec": "OutputYou should output a single number representing the number of cells that were successfully turned to land.",
      "sample_tests": "ExamplesInputCopy3 4 92 23 22 33 43 11 32 11 11 4OutputCopy6",
      "description": "D. Reclamation\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line consists of three integers r, c, and n (1 ≤ r, c ≤ 3000, 1 ≤ n ≤ 3·105). Then, n lines follow, describing the cells in the order you will reclamate them. Each line will consists of two integers: ri and ci (1 ≤ ri ≤ r, 1 ≤ ci ≤ c), which represents the cell located at row ri and column ci. All of the lines describing the cells will be distinct.\n\nOutputYou should output a single number representing the number of cells that were successfully turned to land.\n\nInputCopy3 4 92 23 22 33 43 11 32 11 11 4OutputCopy6\n\nInputCopy3 4 92 23 22 33 43 11 32 11 11 4\n\nOutputCopy6\n\nNoteThe pictures below show the sequence of reclamations that are performed in the example input. Blue cells represent the cells occupied by sea, while other colored cells represent land. The latest cell that are reclamated is colored either yellow or red, depending on whether the addition violates the condition in the statement. The dashed red line represents a possible trade route, if it exists.No route exists, so this reclamation is not performed.No route exists, skipped.Remember that the leftmost and rightmost cells in the same row are adjacent.No route exists, skipped.Hence the result is:There are 6 successful reclamation and 3 failed ones.",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces",
          "content": "Hello everyone!The first round of start[c]up is upon us. It is open to all participants. Registration works as a normal CodeForces round, and will close five minutes before the start of the contest.The contest uses normal Codeforces rules, and will be rated. The score distribution is 500-1000-2000-2000-2500.The problem set has been developed by MemSQL engineers pieguy, nika, exod40, SkidanovAlex and dolphinigle.Top 500 competitors will advance to the second round, with the top 25 Silicon Valley residents invited to participate on-site, where there will be special prizes.Good luck and happy coding!UPDATE: Please note that the score distribution has changed.UPDATE: Editorial is up now!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 692
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces",
          "content": "Square and RectanglesAuthor: AlexSkidanovWhat happens if the rectangles form an N × N square? Then these two conditions are necessary.1) The area must be exactly N × N.2) The length of its sides must be N. That means, the difference between the right side of the rightmost rectangle — the left side of the leftmost rectangle is N. Same for topmost and bottommost rectangles.We claim that, since the rectangles do not intersect, those two conditions are also sufficient.This is since if there are only N × N space inside the box bounded by the leftmost, rightmost, topmost, and bottommost rectangles.Thus if the sum of the area is exactly N × N, all space must be filled -- which forms a square.Stadium and GamesAuthor: nikaSuppose the \"divide-by-two\" stage happens exactly D times, and the round robin happens with M people.Then, the number of games held is: We would like that This is an equation with two variables -- to solve it, we can enumerate the value of one of the variables and calculate the value of the other one. We cannot enumerate the possible values of M, since M can vary from 1 to 10^9. However, we can enumerate D, since the number scales exponentially with D -- that is, we should only enumerate 0 ≤ D ≤ 62.Thus, the equation is reduced to Since this function is increasing, this can be solved via binary search on M.Monsters and DiamondsAuthor: AlexSkidanovFirst part of the problem is to find minimum number of diamonds one can achieve by starting with a given monster. To do so, we will be using Dijkstra algorithm. Originally we don't know the minimum for any monster. For every rule we will maintain how many monsters with unknown minimums it has (let's call it ki for the i-th rule). Let's take every rule that has only diamonds in it (i.e. which has ki = 0), and assign number of diamonds in that rule as a tentative minimum for the monster (if a monster has several diamonds-only rules, take the smallest one). Then take the monster, that has the smallest tentative minimum currently assigned. For that monster the tentative value is the actual minimum due to the same reasoning we use when we prove correctness of Dijkstra algorithm. Now, since we know the minimum for that monster, for every rule i that has that monster in its result subtract 1 from ki for every occurrence of the monster in the result of that rule. If for any rule the value of ki becomes zero, update the tentative minimum for the monster that rule belongs to with the sum of minimum values for each monster that rule generates plus the number of diamonds that rule generates. Then from all the monsters for which we don't known the minimum yet, but for which we know the tentative minimum, pick the one with the smallest tentative minimum, and continue on.At the end we will end up in a state, when each monster either has an actual minimum value assigned, or has no tentative value assigned. The latter monsters will have  - 1 - 1 as their answer. For the former monsters we know the minimum, but don't know the maximum yet.The second part of the problem is to find all the rules, after applying which we are guaranteed to never get rid of all the monsters. We will call such a rule bad. It is easy to show, that the rule bad if and only if it generates at least one monster with minimum value of -1. Remove all the bad rules from the set of rules.When bad rules are removed, finding maximums is trivial. Starting from every node for which maximum is not assigned yet, we traverse all the monsters in a DFS order. For a given monster, we consider every rule. For a given rule, for each monster it generates, we call DFS to find its maximum value, and then sum them up, add number of diamonds for the rule, and check if this rule gives bigger max value than the one currently known for the monster. If we ever call DFS for a monster, for which we already have a DFS call on the stack, that means that that monster has some way of producing itself (directly or indirectly) and some non-zero number of diamonds (this is why problem statement has a constraint that every rule generates at least one diamond), so the answer for the monster is -2. If, processing any rule, we encounter a monster with max value -2, we immediately assign -2 as a max value for the monster the rule belongs to and return from the DFS.As an exercise, think of a solution for the same problem, if rules are not guarantee to have at least one diamond in them.ReclamationAuthor: dolphinigleAssume there's an extra sea cells on a row above the topmost row, and a row below the bottom most row. Hence, we can assume that the top and bottom row consists entirely of sea.We claim that: There does not exist a sea route if and only if there exists a sequence of land cells that circumfere the planet (2 cells are adjacent if they share at least one point).The \"sufficient\" part of the proof is easy -- since there exists such a sequence, it separates the sea into the northern and southern hemisphere and this forms a barrier disallowing passage between the two.The \"necessary\" part. Suppose there does not exist such route. Then, if you perform a flood fill from any of the sea cell in the top row, you obtain a set of sea cells.Trace the southern boundary of these set of cells, and you obtain the sequence of land circumfering the planet.Thus, the algorithm works by simulating the reclamations one by one. Each time a land is going to be reclamated, we check if it would create a circumefering sequence. We will show that there's a way to do this check very quickly -- thus the algorithm should work within the time limit.Stick two copies of the grid together side-by-side, forming a Rx(2*C) grid. The leftmost and rightmost cells of any row in this new grid are also adjacent, similar to the given grid.Each time we're going to reclamate a land in row r and column c, we check if by doing so we would create a path going from (r, c) to (r, c + C). If it would, then we cancel the reclamation. Otherwise, we perform it, and add a land in cell (r, c) and (r, c+C).This \"is there a path from node X to node Y\" queries can be answered very very quickly using union find -- we check whether is it possible to go from one of the 8 neighbors of (r, c) to one of the 8 neighbors of (r, c+C).Correctness follows from the following: There exists a circumefering sequence IFF there exists a path from (r, c) to (r, c+C). Sufficient is easy. Suppose there exist a path from (r, c) to (r, c+C). We can form our circumfering sequence by overlapping the path from (r, c) to (r, c+C) with the same path, but going from (r, c+C) to (r, c) (we can do this since the grid is a two copies of the same grid sticked together).Necessary. Suppose there exists a circumfering sequence. We claim that there must exist a path to go from (r, c) to (r, c+C). Consider the concatenation of an infinite number of our initial grid, forming an Rx(infinite * C) grid. If there exists a circumfering sequence, we claim that within this grid, there exists a path from (r, c) to (r, c+C).Suppose there does not exist such a path. Since there exists a circumfering sequence, it must be possible to go from (r, c) to (r, c+ t * C), where t is an integer >= 2. Now, you should overlap all the paths taken to go from (r, c) to (r, c+t*C) in the grid (r', c' + C) (the grid immediately to the right of the grid where (r, c) is located). There must be a path from (r, c) to (r, c+C) in this new overlapped path.Proofing the final part is difficult without interactive illustration -- basically since t >= 2, there exists a path that goes from the left side to the right side of the grid (r', c' + C). This path must intersect with one of the overlapping paths, and that path must be connected to (r, c+C). The details are left as... exercise :p.The Red ButtonAuthor: nikaIn this part of editorial, all numbers we speak are in modulo N. So, if I say 10, it actually means 10 modulo N.First, observe that this problem asks us to find a cycle that visits each node exactly once, i.e., a hamiltonian cycle. Thus, for each node X, there exists one other node that we used to go to node X, and one node that we visit after node X. We call them bef(X) and aft(X) (shorthand for before and after).First we will show that if N is odd, then the answer is  - 1.Proof...? Consider node 0. What nodes points to node 0? Such node H must satisfy either of the following conditions:2H = 02H + 1 = 0The first condition is satisfied only by H = 0. The second condition is satisfied only by one value of H: floor(N / 2).So, since we need a hamiltonian cycle, pre[0] must be floor(N/2), and aft[floor(N/2)] = 0Now, consider node N - 1. What nodes points to node N - 1?2H = N - 12H + 1 = N - 1The second condition is satisfied only by H = N - 1. The first condition is satisfied only by H = floor(N / 2)But we need a hamiltonian cycle, so aft[floor(N/2)] must be N - 1. This is a contradiction with that aft[floor(N/2)] must be 0. Now, N is even. This case is much more interesting.Consider a node X. It is connected to 2X and 2X + 1. Consider the node X + N / 2. It is connected to 2X + N and 2X + 1 + N, which reduces to 2X and 2X + 1.So, apparently node X and node X + N / 2 are connected to the same set of values.Now, notice that each node X will have exactly two nodes pointing to it. This is since such node H must satisfy2H = X2H + 1 = Xmodulo N, each of those two equations have exactly one solution.So, this combined with that node X and X + N / 2 have the same set of connected nodes means that the only way to go to node 2X or 2X + 1 is from nodes X and X + N / 2.Thus, if you choose to go from node X to node 2X, you HAVE to go from node X + N / 2 to node 2X + 1 (or vice versa).Now, try to follow the rule above and generate any such configuration. This configuration will consists of cycles, possibly more than 1. Can we join them into a single large cycle, visiting all nodes?Yes we can, since those cycles are special.Weird theorem: If there are 2 +  cycles, then there must exist X and such node X and node X + N / 2 are in different cycles.Proof: Suppose not. We show that there must exist one cycle in that case. Since node X and X + N / 2 are in the same cycle, they must also be in the same cycle as node 2X and 2X + 1. In particular, node X and 2X and 2X + 1 are all in the same cycle. It is possible to go from any node X to any node Y by following this pattern (left as exercise). Now, consider the X such that node X and node X + N / 2 are in different cycles. Suppose we go from node X to node 2X + A, and from X + N / 2 to 2X + B (such that A + B = 1). Switch the route -- we go from node X to 2X + B and X + N / 2 to 2X + A instead. This will merge the two cycles -- very similar to how we merge two cycles when finding an eulerian path. Thus, we can keep doing this to obtain our cycle! ...It's not entirely obvious to do that in O(N) time. An example solution: use DFS. DFS from node 0. For each node X: if it has been visited, return if X + N / 2 has been visited, go to either 2X or 2X + 1 and recurse, depending on which route used by node X + N / 2 otherwise, we go to node 2X and recurse. Then, check if X + N / 2 was visited in the recursion. If it was not, then the two of them forms two different cycles. We merge them by switching our route to 2X + 1 instead, and recurse again.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11327
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 1",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 2",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces - Code 1",
          "code": "each of those two equations have exactly one solution.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces - Code 2",
          "code": "2 H + 1 = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 editorial - Codeforces - Code 3",
          "code": "2 H = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 3000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 3000, \"c\");\n    inf.readSpace();\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, r, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, c, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.count(pos) == 0, \"Duplicate cell at line %d: (%d, %d)\", i + 2, ri, ci);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 3000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 3000, \"c\");\n    inf.readSpace();\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, r, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, c, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.count(pos) == 0, \"Duplicate cell at line %d: (%d, %d)\", i + 2, ri, ci);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 3000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 3000, \"c\");\n    inf.readSpace();\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, r, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, c, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.count(pos) == 0, \"Duplicate cell at line %d: (%d, %d)\", i + 2, ri, ci);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> positions;\n\n    if (type == \"random\") {\n        // Collect all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 1; i <= r; ++i) {\n            for (int j = 1; j <= c; ++j) {\n                all_positions.push_back({i, j});\n            }\n        }\n        shuffle(all_positions.begin(), all_positions.end());\n        n = min(n, (int)all_positions.size());\n        positions.assign(all_positions.begin(), all_positions.begin() + n);\n    } else if (type == \"horizontal-cut\") {\n        int r_cut = r / 2;\n        if (r >= 1) r_cut = rnd.next(1, r);\n        vector<int> cols;\n        for (int j = 1; j <= c; ++j) {\n            cols.push_back(j);\n        }\n        shuffle(cols.begin(), cols.end());\n        n = min(n, (int)cols.size());\n        cols.resize(n);\n        for (int j : cols) {\n            positions.push_back({r_cut, j});\n        }\n    } else if (type == \"vertical-cut\") {\n        int c_cut = c / 2;\n        if (c >= 1) c_cut = rnd.next(1, c);\n        vector<int> rows;\n        for (int i = 1; i <= r; ++i) {\n            rows.push_back(i);\n        }\n        shuffle(rows.begin(), rows.end());\n        n = min(n, (int)rows.size());\n        rows.resize(n);\n        for (int i : rows) {\n            positions.push_back({i, c_cut});\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 1; i <= r; ++i) {\n            for (int j = 1; j <= c; ++j) {\n                if ((i + j) % 2 == 0) {\n                    positions.push_back({i, j});\n                }\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        n = min(n, (int)positions.size());\n        positions.resize(n);\n    } else if (type == \"snake\") {\n        int i = 1, j = 1;\n        int dir = 1; // 1 for right, -1 for left\n        while (positions.size() < n && i <= r) {\n            positions.push_back({i, j});\n            if ((dir == 1 && j == c) || (dir == -1 && j == 1)) {\n                // Change to next row\n                ++i;\n                dir *= -1;\n            } else {\n                j += dir;\n            }\n        }\n    } else if (type == \"staircase\") {\n        int i = 1, j = 1;\n        while (positions.size() < n && i <= r && j <= c) {\n            positions.push_back({i, j});\n            ++i;\n            ++j;\n        }\n    } else if (type == \"single-cell\") {\n        positions.push_back({rnd.next(1, r), rnd.next(1, c)});\n    } else if (type == \"all\") {\n        for (int i = 1; i <= r; ++i) {\n            for (int j = 1; j <= c; ++j) {\n                positions.push_back({i, j});\n            }\n        }\n        n = min(n, (int)positions.size());\n    } else {\n        // Other types can be added here\n    }\n\n    // Ensure positions are unique\n    sort(positions.begin(), positions.end());\n    positions.erase(unique(positions.begin(), positions.end()), positions.end());\n\n    // Adjust n in case we have fewer positions\n    n = min(n, (int)positions.size());\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", r, c, n);\n    for (int k = 0; k < n; ++k) {\n        printf(\"%d %d\\n\", positions[k].first, positions[k].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> positions;\n\n    if (type == \"random\") {\n        // Collect all positions\n        vector<pair<int, int>> all_positions;\n        for (int i = 1; i <= r; ++i) {\n            for (int j = 1; j <= c; ++j) {\n                all_positions.push_back({i, j});\n            }\n        }\n        shuffle(all_positions.begin(), all_positions.end());\n        n = min(n, (int)all_positions.size());\n        positions.assign(all_positions.begin(), all_positions.begin() + n);\n    } else if (type == \"horizontal-cut\") {\n        int r_cut = r / 2;\n        if (r >= 1) r_cut = rnd.next(1, r);\n        vector<int> cols;\n        for (int j = 1; j <= c; ++j) {\n            cols.push_back(j);\n        }\n        shuffle(cols.begin(), cols.end());\n        n = min(n, (int)cols.size());\n        cols.resize(n);\n        for (int j : cols) {\n            positions.push_back({r_cut, j});\n        }\n    } else if (type == \"vertical-cut\") {\n        int c_cut = c / 2;\n        if (c >= 1) c_cut = rnd.next(1, c);\n        vector<int> rows;\n        for (int i = 1; i <= r; ++i) {\n            rows.push_back(i);\n        }\n        shuffle(rows.begin(), rows.end());\n        n = min(n, (int)rows.size());\n        rows.resize(n);\n        for (int i : rows) {\n            positions.push_back({i, c_cut});\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 1; i <= r; ++i) {\n            for (int j = 1; j <= c; ++j) {\n                if ((i + j) % 2 == 0) {\n                    positions.push_back({i, j});\n                }\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        n = min(n, (int)positions.size());\n        positions.resize(n);\n    } else if (type == \"snake\") {\n        int i = 1, j = 1;\n        int dir = 1; // 1 for right, -1 for left\n        while (positions.size() < n && i <= r) {\n            positions.push_back({i, j});\n            if ((dir == 1 && j == c) || (dir == -1 && j == 1)) {\n                // Change to next row\n                ++i;\n                dir *= -1;\n            } else {\n                j += dir;\n            }\n        }\n    } else if (type == \"staircase\") {\n        int i = 1, j = 1;\n        while (positions.size() < n && i <= r && j <= c) {\n            positions.push_back({i, j});\n            ++i;\n            ++j;\n        }\n    } else if (type == \"single-cell\") {\n        positions.push_back({rnd.next(1, r), rnd.next(1, c)});\n    } else if (type == \"all\") {\n        for (int i = 1; i <= r; ++i) {\n            for (int j = 1; j <= c; ++j) {\n                positions.push_back({i, j});\n            }\n        }\n        n = min(n, (int)positions.size());\n    } else {\n        // Other types can be added here\n    }\n\n    // Ensure positions are unique\n    sort(positions.begin(), positions.end());\n    positions.erase(unique(positions.begin(), positions.end()), positions.end());\n\n    // Adjust n in case we have fewer positions\n    n = min(n, (int)positions.size());\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", r, c, n);\n    for (int k = 0; k < n; ++k) {\n        printf(\"%d %d\\n\", positions[k].first, positions[k].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -r 1 -c 1 -n 1 -type single-cell\n./gen -r 1 -c 1 -n 0 -type random\n./gen -r 5 -c 1 -n 5 -type snake\n./gen -r 1 -c 5 -n 5 -type snake\n./gen -r 10 -c 10 -n 50 -type random\n./gen -r 10 -c 10 -n 50 -type checkerboard\n./gen -r 100 -c 100 -n 10000 -type random\n./gen -r 100 -c 100 -n 5000 -type checkerboard\n./gen -r 1000 -c 1000 -n 1000000 -type random\n./gen -r 1000 -c 1000 -n 500000 -type checkerboard\n./gen -r 3000 -c 3000 -n 300000 -type random\n./gen -r 3000 -c 3000 -n 300000 -type horizontal-cut\n./gen -r 3000 -c 3000 -n 300000 -type vertical-cut\n./gen -r 3000 -c 3000 -n 4500000 -type checkerboard\n./gen -r 3000 -c 3000 -n 9000000 -type all\n./gen -r 3000 -c 3000 -n 300000 -type snake\n./gen -r 1 -c 3000 -n 3000 -type horizontal-cut\n./gen -r 3000 -c 1 -n 3000 -type vertical-cut\n./gen -r 3000 -c 3000 -n 1 -type horizontal-cut\n./gen -r 2 -c 3000 -n 3000 -type horizontal-cut\n./gen -r 1000 -c 1000 -n 1000 -type staircase\n./gen -r 1000 -c 1000 -n 500 -type staircase\n./gen -r 3000 -c 3000 -n 300000 -type staircase\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:30.360433",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "325/E",
      "title": "E. Тропинки и полянки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеЕдинственная строка содержит целое число n (2 ≤ n ≤ 105) — количество полянок.",
      "output_spec": "Выходные данныеВыведите порядок, в котором следует обойти полянки. Каждая полянка должна быть выведена ровно один раз, кроме полянки 0, которая должна быть выведена ровно дважды: первой и последней в списке. Если решения не существует, выведите -1. Если решений несколько, выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать2Выходные данныеСкопировать0 1 0Входные данныеСкопировать3Выходные данныеСкопировать-1Входные данныеСкопировать4Выходные данныеСкопировать0 1 3 2 0Входные данныеСкопировать16Выходные данныеСкопировать0 1 2 4 9 3 6 13 10 5 11 7 15 14 12 8 0",
      "description": "E. Тропинки и полянки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеЕдинственная строка содержит целое число n (2 ≤ n ≤ 105) — количество полянок.\n\nВходные данные\n\nВыходные данныеВыведите порядок, в котором следует обойти полянки. Каждая полянка должна быть выведена ровно один раз, кроме полянки 0, которая должна быть выведена ровно дважды: первой и последней в списке. Если решения не существует, выведите -1. Если решений несколько, выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать2Выходные данныеСкопировать0 1 0Входные данныеСкопировать3Выходные данныеСкопировать-1Входные данныеСкопировать4Выходные данныеСкопировать0 1 3 2 0Входные данныеСкопировать16Выходные данныеСкопировать0 1 2 4 9 3 6 13 10 5 11 7 15 14 12 8 0\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 1 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 1 3 2 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать16\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 1 2 4 9 3 6 13 10 5 11 7 15 14 12 8 0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces",
          "content": "Всем привет!Первый раунд start[c]up начнется совсем скоро. Участвовать могут все желающие, никакой дополнительной регистрации, кроме регистрации на сам раунд, не требуется. Регистрация закрывается за пять минут до начала раунда.Раунд пройдет по правилам codeforces и будет рейтинговым. Распределение баллов будет следующее: 500-1000-2000-2000-2500.Задачи приготовлены разработчиками MemSQL pieguy, nika, exod40, SkidanovAlex и dolphinigle.Лучшие 500 участников пройдут во второй раунд, а 25 лучших участников из Кремниевой Долины будут приглашены участвовать во втором раунде онсайт, где будут разыгрываться специальные призы.Удачи на раунде и приятного кодинга!UPDATE: Обратите внимание, что распределение баллов изменилосьUPDATE: Опубликован разбор задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 757
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces",
          "content": "Квадрат и ПрямоугольникиАвтор: AlexSkidanovЕсли несколько прямоугольников образуют квадрат N × N, то следующие два условия обязательно выплняются:1) Суммарная площадь прямоугольников равна N × N.2) Разница между правой границей самого правого прямоугольника и левой границей самого левого прямоугольника ровно N. Аналогично для нижней и верхней границы.Легко показать, что эти условия являются также и достаточными.Стадион и ИгрыАвтор: nikaПусть прошло D раундов на выбывание, и круговой раунд с M командами.Тогда общее количество сыгранных игр: Мы хотим, чтобы Это уравнение с двумя неизвестными, чтобы его решить, можно зафиксировать значение одной из них, и найти значение другой. Мы не можем перебрать все значения для M, так как M может достигать 10^9. Однако, мы можем перебрать все значения D, так как количество игр растет экспоненциально с ростом D -- поэтому D может принять значения только в интервале 0 ≤ D ≤ 62.Когда D зафиксировано, остается решить следующее уравнение: Так как левая часть уравнения возрастает, M можно найти двоичным поиском.Монстры и БриллиантыАвтор: AlexSkidanovПервая часть задачи -- найти минимум для каждого монстра. Чтобы это сделать, мы будем использовать алгоритм Дейкстры. Изначально минимум не известен ни для одного монстра. Для каждого превращения будем поддерживать величину, указывающую на количество монстров, которые это превращение создает, для которых минимум еще не известен (назовем его ki для i-ого превращения). Сначала рассмотрим каждое превращение, которое создает только бриллианты (то есть для которого ki = 0), и скажем, что это количество бриллиантов -- это временный минимум для монстра, которому принадлежит превращение (если у монстра есть более одного превращения в бриллианты, надо взять то, которое создает минимальное количество бриллиантов). Затем возьмем монстра с минимальным временным минимумом. Для этого монстра временный минимум является финальным минимумом. Это можно доказать используя подход, похожий на подход к доказательству алгоритма Дейкстры. Так как для этого монстра минимум известен, уменьшим ki для каждого превращения, которое производит этого монстра. Если для какого-то превращения ki стало равно нулю, обновим временный минимум для монстра, которому принадлежит это преврещение суммой минимумов по всем монстрам, которых это превращение производит, и количества бриллиантов, которые это превращение производит. Затем, среди всех монстров, для которых финальный минимум еще не известен, но известен временный, выберем того, для которого временный минимум минимален, и повторим процесс.Когда монстров, для которых есть временный минимум, но нет финального, не осталось, все монстры, для которых минимум не нашелся, будут иметь  - 1 - 1 в качестве ответа. Для остальных монстров мы знаем минимум, но не знаем максимум.Вторая часть решения -- избавиться от превращений, выполнив которые мы никогда не сможем избавиться от всех монстров. Легко показать, что такими превращениями являются те, в результате которых появляется хотя бы один монстр, для которого минимум равен  - 1. Уберем все такие превращения из набора превращений.После этого найти максимумы очень легко. Начиная из каждого монстра, для которого максимум еще не известен, будем обходить монстров обходом в глубину. Для данного монстра, рассмотрим все превращения. Для конкретного превращения, для каждого монстра, который появляется в результате этого превращения, вызовем DFS чтобы найти максимум для этого монстра, просуммируем эти величины, прибавим количество бриллиантов, которые это превращение создает, и улучшим известный максимум для монстра, которому принадлежит это правило, полученной величиной. Если мы в какой-то момент времени попадаем в ситуацию, когда DFS вызван для монстра, для которого уже есть вызов DFS на стеке, это значит, что этот монстр может превратиться сам в себя (непосредственно или через других монстров) и ненулевое количество бриллиантов (по этой причине в условии оговаривается, что каждое превращение генерирует хотя бы один бриллиант), поэтому ответ для такого монстра -2. Если, обрабатывая одно из превращений, мы обнаружили, что в результате применения превращения появится монстр, для которого максимум равен -2, мы можем сразу назначить максимум для текущего монстра в -2 и выйти из DFS.В качестве упражнения подумайте, как решить эту же задачу, если не гарантируется, что каждое превращение содержит хотя бы один бриллиант.Царство и ГосударствоАвтор: dolphinigleДля простоты допустим, что над самой первой строкой и под самой последней строкой есть по дополнительной строке с морем.Раздвоим поверхность цилиндра, добавив его справа к самому себе (при этом левый столбец раздвоенного моря по прежднему смежен с правым столбцом). Каждое превращение будем осуществлять в обеих половинах. Утверждается, что торгового маршрута не существует тогда и только тогда, когда для некоторой превращенной ячейки она достижима из своей копии по превращенным ячейкам (две превращенных ячейки смежны, если у них есть хотя бы одна общая точка, не обязательно общая сторона).Доказать тот факт, что это услвоие достаточно, очень легко. Путь между ячейкой и ее копией разбивает море на северную и южную часть, и представляет из себя барьер между этими половинами, который ни один торговый маршрут не может пересечь.Докажем необходимость условия. Пусть ни для какой превращенной ячейки ее копия не достижима по превращенным ячейкам. Тогда возьмем все ячейки, содержащие море, прилегающие к верхней границе, и найдем все достижимые из них ячейки с морем (две ячейки с морем смежны, если у них есть общая сторона). Пусть ни одна ячейка с морем, достижимая таким образом, не прилегает к нижней границе. Тогда возьмем самую нижнюю достижимую ячейку с морем (любую если их несколько), и начнем двигаться вправо вдоль морских ячеек, по превращенным ячейкам. Легко показать, что двигаясь по превращенным ячейкам, имеющим хотя бы одну общую точку, вдоль границы моря, мы опишем круг вокруг цилиндра и вернемся в ячейку, с который мы начали, что противоречит тому, что ни для какой превращенной ячейки ее копия не достижима из нее.Дальше будем решать задачу моделируя запросы. Будем поддерживать компоненты связности превращенных ячеек используя систему непересекающихся множеств. Каждый раз, когда ячейка превращается, убедимся, что эта ячейка и ее копия не содержат соседей, принадлежащих одной компоненте связности. Если такие соседи есть, то после превращение этой ячейки, она и ее копия окажутся в одной компоненте связности, тем самым не оставив ни одного торгового маршрута. Если таких соседей нет, то превращаем ячейку, и объединяем все компоненты связности, прилегающие к ней, затем превращаем копию ячейки, и объединяем все компоненты связности, прилегающие к ней.В этой задаче стоит отдельно рассмотреть случай, когда столбец только один (тогда ни одно превращение нельзя осуществить), и когда столбцов два (тогда у каждой ячейки только 5 соседей, а не восемь, что может привести к ошибкам в некоторых реализациях).Тропинки и ПолянкиАвтор: nikaВ этом разборе все числа подрузмеваются по модулю N. Если в разборе встречается число 10, имеется ввиду 10 по модулю N.В задаче нас просят найти гамильтонов цикл в графе. Для каждой вершины гамильтонова цикла через bef(X) будем обозначать предыдущую вершину в цикле а через aft(X) -- следующую.Сначала покажем, что ответ -1 для любого нечетного N.Рассмотрим вершину 0. Для любой вершины H, ведущей в 0, выполняются два условия:2H = 02H + 1 = 0Первому условию удовлетворяет только H = 0. Второму условию удовлетворяет только floor(N / 2).Иными словами, pre[0] = floor(N/2), и aft[floor(N/2)] = 0Теперь рассмотрим вершину N - 1. В нее ведут вершины, для которых верно2H = N - 12H + 1 = N - 1Второе условие выполняется только при H = N - 1. Первое условие выполняется только при H = floor(N / 2)Иными словами, aft[floor(N/2)] равен N - 1. Это противоречит тому, что aft[floor(N/2)] должен быть 0. Тем самым доказано, что N четно. Этот случай намного интереснее.Рассмотрим вершину X. Из нее есть ребра в 2X и 2X + 1. Рассмотрим вершину X + N / 2. Из нее есть ребра в.... 2X + N и 2X + 1 + N. ...что по модулю N равно 2X и 2X + 1.Значит, для вершин X и X + N / 2 множество исходящий ребер идентично.Легко показать, что для каждой вершины X есть ровно два входящий ребра. Это следует из того, что в вершину X ребра идут только из вершин таких, что2H = X2H + 1 = Xпо модулю N, и каждое из этих уравнений имеет ровно одно решение.Факт, что каждая вершина имеет ровно два входящий ребра, вместе с фактом что X и X + N / 2 имеют одинаковое множество исходящий ребер, дает нам понять, что в вершины 2X и 2X + 1 есть ребра только из X и X + N / 2.Иными словами, если мы решили взять ребро из X в 2X в гамильтонов цикл, мы обязаны взять ребро из X + N / 2 в 2X + 1 в цикл тоже (и наоборот).Теперь, следуя правилу выше, для вершин X, X + N / 2 возьмем любые два из четырех ребер в 2X, 2X + 1. В итоге мы возьмем ровно N ребер, которые образуют некоторое количество простых циклов. Можем ли мы легко объединить? Оказывается, что в силу особенностей этих циклов, мы можем это сделать.Утверждение: если есть два или более цикла, то есть вершина X такая, что X и X + N / 2 принадлежат разным циклам.Доказательство: Пусть это не так. Покажем, что в этом случае есть только один цикл. Так как вершины X и X + N / 2 принадлежат одному циклу, они должны быть в одном цикле с 2X и 2X + 1. Так как X и 2X и 2X + 1 все принадлежат одному циклу, легко показать, что из любой вершины X можно попасть в любую другую вершину Y (доказательство этого остается в качестве упражнения). Теперь, расммотрим X такое, что X и X + N / 2 принадлежат разным циклам. Пусть из вершины X сейчас выбрано ребро в 2X + A, а из вершины X + N / 2 -- в 2X + B (A + B = 1). Поменяем их местрами -- пойдем из X в 2X + B и из X + N / 2 в 2X + A. Это соединит два цикла в один -- идея очень похожа на идею построения эйлерова цикла. После каждой такой операции количество циклов уменьшается на один, и в итоге останется только один цикл. Осталось понять, как это сделать за O(N). Примером решения может быть DFS из вершины 0. Для каждой вершины X: если мы в ней уже были, возвращаемся из DFS если X + N / 2 была посещена, идем либо в 2X либо в 2X + 1 рекурсивно, в зависимсти от того, куда сейчас ведет ребро, выбранное для X + N / 2 (пойдем в вершину, в которую то ребро не ведет) иначе, идем рекурсивно в 2X. Затем проверяем, смогли ли мы посетить в рекурсии X + N / 2. Если нет, значит они принадлежат разным циклам. Соединим их, и рекурсивно спустимся в 2X + 1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 10528
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 1",
          "code": "хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 2",
          "code": "множество точек, лежащих внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 3",
          "code": "Даны множества. Объединение множеств - набор элементов, лежащих хотя бы в одном множестве",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 4",
          "code": "проверьте если данные прямоугольники составляют квадрат",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 5",
          "code": "множество точек, лежащих внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 6",
          "code": "внутри или на границе хотя бы одного прямоугольника",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 7",
          "code": "Как по мне, так это в чистом виде определение объединения",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 8",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 9",
          "code": "$ g++ -Wall -Wextra marcin_smu.c++\nmarcin_smu.c++:32:6: warning: ISO C++ forbids declaration of ‘main’ with no type [-Wreturn-type]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 10",
          "code": "codeforces.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 - Codeforces - Code 11",
          "code": "[относительные ссылки](/blog/entry/8341)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8341",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 1",
          "code": "each of those two equations have exactly one solution.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 2",
          "code": "2 H + 1 = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 1 -- разбор задач - Codeforces - Code 3",
          "code": "2 H = X (mod N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   We interpret an empty vector as the participant (or jury) printing \"-1\".\n   Otherwise, the vector should represent a valid sequence of length n+1\n   where:\n     1) The first element is 0.\n     2) The last element is 0.\n     3) Each node i (1 <= i <= n-1) appears exactly once, and node 0 appears exactly twice.\n     4) For consecutive nodes x -> y in the path, y must be either (2*x) mod n or (2*x+1) mod n.\n*/\n\nstatic bool isNoSolution(const vector<int> &v)\n{\n    // We treat an empty vector as \"-1\".\n    return v.empty();\n}\n\nstatic bool isValidSolution(const vector<int> &v, int n)\n{\n    // Must be of length n+1\n    if (int(v.size()) != n + 1) {\n        return false;\n    }\n\n    // Check first and last are 0\n    if (v.front() != 0 || v.back() != 0) {\n        return false;\n    }\n\n    // Check frequencies of nodes\n    vector<int> freq(n, 0);\n    for (int node : v) {\n        // Also verify node range\n        if (node < 0 || node >= n) {\n            return false;\n        }\n        freq[node]++;\n    }\n\n    // Node 0 must appear exactly 2 times, others exactly once\n    if (freq[0] != 2) {\n        return false;\n    }\n    for (int i = 1; i < n; i++) {\n        if (freq[i] != 1) {\n            return false;\n        }\n    }\n\n    // Check the step rule:\n    // after disarming node x, next must be (2*x mod n) or (2*x+1 mod n)\n    for (int i = 0; i + 1 < int(v.size()); i++) {\n        int x = v[i];\n        int y = v[i + 1];\n        int c1 = (2LL * x) % n;\n        int c2 = (2LL * x + 1) % n;\n        if (y != c1 && y != c2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Reads the entire output from the stream. If the first token is \"-1\", returns an empty vector.\n// Otherwise, returns all tokens as integers in a vector.\nstatic vector<int> readAnswer(InStream &stream, int n)\n{\n    vector<int> result;\n\n    // If there's no token at all, interpret as \"-1\"\n    if (!stream.seekEof()) {\n        // Read first token\n        string first = stream.readToken();\n        if (first == \"-1\") {\n            // should not have anything else\n            if (!stream.seekEof()) {\n                stream.quitf(_wa, \"Unexpected extra tokens after -1\");\n            }\n            return {}; // empty => no solution\n        } else {\n            // first token is not \"-1\". Parse it as integer, then read the rest.\n            long long val;\n            try {\n                // Use testlib's stringToLongLong with the correct signature\n                val = stringToLongLong(stream, first);\n            } catch (...) {\n                stream.quitf(_wa, \"Invalid integer format: %s\", first.c_str());\n            }\n            if (val < 0 || val >= n) {\n                stream.quitf(_wa, \"Invalid node value: %lld\", val);\n            }\n            result.push_back((int) val);\n\n            while (!stream.seekEof()) {\n                int node = stream.readInt(0, n - 1, \"node in path\");\n                result.push_back(node);\n            }\n        }\n    }\n    // if we reach here and didn't read anything, interpret as \"-1\"\n    return result;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // The input has only one integer: n\n    int n = inf.readInt(2, 100000, \"n\");\n\n    // Read jury's solution (ans) and participant's solution (ouf)\n    vector<int> juryAns = readAnswer(ans, n);\n    vector<int> partAns = readAnswer(ouf, n);\n\n    // If the jury says there's no solution\n    if (isNoSolution(juryAns)) {\n        // If participant also says no solution, accept\n        if (isNoSolution(partAns)) {\n            quitf(_ok, \"Both jury and participant print -1 => no solution\");\n        } else {\n            // Participant claims a solution\n            if (isValidSolution(partAns, n)) {\n                quitf(_wa, \"Jury says no solution, but participant found one\");\n            } else {\n                quitf(_wa, \"Participant output is invalid anyway\");\n            }\n        }\n    }\n    // Jury has a valid solution\n    else {\n        // If participant says no solution\n        if (isNoSolution(partAns)) {\n            quitf(_wa, \"Jury has a solution, but participant printed -1\");\n        } else {\n            // Participant also claims to have a solution; check it\n            if (isValidSolution(partAns, n)) {\n                quitf(_ok, \"Valid solution\");\n            } else {\n                quitf(_wa, \"Invalid solution\");\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    // Ensure n is within the allowed bounds\n    n = min(max(n, 2), 100000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    // Ensure n is within the allowed bounds\n    n = min(max(n, 2), 100000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Small even n (solvable)\n./gen -n 2\n# Test case 2: Small even n (solvable)\n./gen -n 4\n# Test case 3: Small even n (solvable)\n./gen -n 6\n# Test case 4: Small even n (solvable)\n./gen -n 8\n# Test case 5: Small even n (solvable)\n./gen -n 10\n\n# Test case 6: Small odd n (unsolvable)\n./gen -n 3\n# Test case 7: Small odd n (unsolvable)\n./gen -n 5\n# Test case 8: Small odd n (unsolvable)\n./gen -n 7\n# Test case 9: Small odd n (unsolvable)\n./gen -n 9\n# Test case 10: Small odd n (unsolvable)\n./gen -n 11\n\n# Test case 11: Large even n (solvable)\n./gen -n 99998\n# Test case 12: Maximum n (even, solvable)\n./gen -n 100000\n\n# Test case 13: Large odd n (unsolvable)\n./gen -n 99999\n# Test case 14: Large odd n (unsolvable)\n./gen -n 99997\n\n# Test case 15: Edge case (minimum n, even, solvable)\n./gen -n 2\n# Test case 16: Edge case (maximum n, even, solvable)\n./gen -n 100000\n\n# Test case 17: Random even n (solvable)\n./gen -n 50000\n# Test case 18: Random even n (solvable)\n./gen -n 60000\n# Test case 19: Random even n (solvable)\n./gen -n 70000\n\n# Test case 20: Random odd n (unsolvable)\n./gen -n 50001\n# Test case 21: Random odd n (unsolvable)\n./gen -n 60001\n# Test case 22: Random odd n (unsolvable)\n./gen -n 70001\n\n# Test case 23: Prime odd n (unsolvable)\n./gen -n 99991\n# Test case 24: Prime odd n (unsolvable)\n./gen -n 99989\n\n# Test case 25: Random n value (solvable or unsolvable)\n./gen -n 12345\n# Test case 26: Random n value (solvable or unsolvable)\n./gen -n 98765\n\n# Test case 27: Maximum odd n (unsolvable)\n./gen -n 99999\n\n# Test case 28: Edge case (minimum n, even, solvable)\n./gen -n 2\n# Test case 29: Edge case (maximum n, even, solvable)\n./gen -n 100000\n# Test case 30: Maximum odd n (unsolvable)\n./gen -n 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:32.299347",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "327/A",
      "title": "A. Flipping Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n (1 ≤ n ≤ 100). In the second line of the input there are n integers: a1, a2, ..., an. It is guaranteed that each of those n values is either 0 or 1.",
      "output_spec": "OutputPrint an integer — the maximal number of 1s that can be obtained after exactly one move.",
      "sample_tests": "ExamplesInputCopy51 0 0 1 0OutputCopy4InputCopy41 0 0 1OutputCopy4",
      "description": "A. Flipping Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n (1 ≤ n ≤ 100). In the second line of the input there are n integers: a1, a2, ..., an. It is guaranteed that each of those n values is either 0 or 1.\n\nOutputPrint an integer — the maximal number of 1s that can be obtained after exactly one move.\n\nInputCopy51 0 0 1 0OutputCopy4InputCopy41 0 0 1OutputCopy4\n\nInputCopy51 0 0 1 0\n\nOutputCopy4\n\nInputCopy41 0 0 1\n\nOutputCopy4\n\nNoteIn the first case, flip the segment from 2 to 5 (i = 2, j = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].In the second case, flipping only the second and the third element (i = 2, j = 3) will turn all numbers into 1.",
      "solutions": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces",
          "content": "Welcome to another Codeforces Round!Please note that the time of round #191 was changed. Contest will start at Thursday 12:30 UTC.My name is Linh (ll931110). I'm from Vietnam, and I'm glad to present to you my first Codeforces round. It is for Div 2 only; however, I welcome participants from Div. 1 to participate and enjoy challenging problems. I hope this would be a pleasant gift for those who are going to IOI 2013 (and participants from World Finals), which will take place in just a couple of days. This round is prepared by me and fchirica (from Romania). Also, I would like to thank the Codeforces team who puts efforts on making Codeforces and Polygon possible.Happy solving!UPD1: The score of problems in this round will be dynamic. The problems will be sorted in increasing difficulty order, at least in our perspective.UPD2: The contest is over! Congratulations for everybody, especially for those who solved E. You proved to be smarter than I am (your solutions were totally unexpected to us). Thank Gerald, Aksenov239 and Delinur for helping us on preparing the round!Div. 2 winners: SillyHook02 Tsukiko Quit_Quickly Zhengxu sevenzplus Those are five people who nail all problems!Unofficial winners: Kissshot R_R_ xchernoff wakaka phtniit The editorial will be completed soon after revising and adding possible alternative solutions. You are welcome to post your answers in comments.Thank you and see you in the next round!UPD3: Editorial is now available. Remind that it is not the final version, as we are writing possible alternative solutions for problems. Stay tuned!UPD4: Editorial is now completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1620
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces",
          "content": "327A - Игра с переворачиваниемI’ll present here the O(N ^ 3) algorithm, which is enough to solve this task. Then, for those interested, I’ll show a method to achieve O(N) complexity.O(N ^ 3) method: The first thing to observe is that constrains are slow enough to allow a brute force algorithm. Using brute force, I can calculate for each possible single move the number of 1s resulting after applying it and take maximum. For consider each move, I can just generate with 2 FOR loops all indices i, j such as i <= j. So far we have O(N ^ 2) complexity. Suppose I have now 2 fixed vaIues i and j. I need to calculate variable cnt (initially 0) representing the number of ones if I do the move. For do this, I choose another indice k to go in a[] array (taking O(N) time, making the total of O(N ^ 3) complexity). We have two cases: either k is in range [i, j] (this means i <= k AND k <= j) or not (if that condition is not met). If it’s in range, then it gets flipped, so we add to count variable 1 – a[k] (observe that it makes 0 to 1 and 1 to 0). If it’s not in range, we simply add to cnt variable a[k]. The answer is maximum of all cnt obtained.O(N) method: For achieve this complexity, we need to make an observation. Suppose I flip an interval (it does not matter what interval, it can be any interval). Also suppose that S is the number of ones before flipiing it. What happens? Every time I flip a 0 value, S increases by 1 (I get a new 1 value). Every time I flip a 1 value, S decreases by 1 (I loose a 1 value). What would be the “gain” from a flip? I consider winning “+1” when I get a 0 value and “-1” when I get a 1 value. The “gain” would be simply a sum of +1 and -1. This gives us idea to make another vector b[]. B[i] is 1 if A[i] is 0 and B[i] is -1 if A[i] is 1. We want to maximize S + gain_after_one_move sum. As S is constant, I want to maximize gain_after_one_move. In other words, I want to find a subsequence in b[] which gives the maximal sum. If I flip it, I get maximal number of 1s too. This can be founded trivially in O(N ^ 2). How to get O(N)? A relative experienced programmer in dynamic programming will immediately recognize it as a classical problem “subsequence of maximal sum”. If you never heard about it, come back to this approach after you learn it. 327B - Голодная последовательностьWe’ll present two different solutions for this task.Solution 1. What if we solve a more general task? What if each hungry number from the solution isn’t allowed to be divided by any number smaller than it (except 1, which is divides every natural number). If this more general condition would be met, then the “hungry” condition would be met, too (as a[i] won’t be divided by a number smaller than it (except 1), it won’t be divided by a[j], too, with j < i, assuming that a[j] is different from 1). Now how to find numbers for this more general condition? We can rephrase it as: each number from more general condition has 2 divisors: 1 and itself. So if we print N numbers with 2 divisors in increasing order, that would be a good solution. As you probably know, numbers with 2 divisors are called “prime numbers”. The task reduces to finding first N prime numbers. This can be done via brute force, or via Sieve of Eratosthenes (however, not necessarily to get an AC solution).Solution 2. Suppose we are given the number N. We can observe that for big enough consecutive numbers, the array is always hungry. For example, we can print 3 * N + 0, 3 * N + 1, 3 * N + 2, …, 3 * N + (N – 1). Magic, isn’t it? Why does it work now? Pick an arbitrary a[i]. The solution would be bad if one of numbers 2 * a[i], 3 * a[i], 4 * a[i] and so on would be in a[] array. However, it will never happen. The smallest multiple from that ones will be 2 * 3 * N = 6 * N. There is not possible to obtain a smallest multiple than that one. On the other hand, the biggest number from a[] array would be 3 * N + N – 1 = 4 * N — 1. Since smallest multiple is bigger than biggest term of the array, it (and of course other multiples bigger than it) will never exist in a[] array. So the above solution is correct also. 327C - Волшебная пятеркаProperty: A number is divisible by 5 if and only if its last digit is either 0 or 5.A first solution: Suppose you’re given a plate S, not so big, so we can iterate all its elements. Can we get the answer? I build a new array sol[]. In explanation, both S and sol will be 1-based. Denote N = size of S. Also, denote sol[i] = the number of ways to delete digits from plate S such as we obtain a magic number which has the last digit on position i. The answer is sol[1] + sol[2] + … + sol[N]. Let’s focus now on calculating sol[i]. If S[i] (digit of the plate corresponding to ith position) is different than 0 or 5, then sol[i] is 0 (see “property”). Otherwise we have to ask ourself: in how many ways I can delete digits in “left” and in “right” of position i. In the “right”, we have only one way: delete all digits (if one digit from right still stands, then the number isn’t ending at position i). Now in the “left”: there are digits on positions 1, 2, …, i – 1. We can either delete a digit or keep it – anyhow he’d do we still get a magic number. So on position 1 I have 2 ways (delete or keep it), on position 2 I have also 2 ways, …, on position i – 1 I have also 2 ways. Next, we apply what mathematics call “rule of product” and we get 2 * 2 * 2 … * 2 (i – 1 times) = 2 ^ (i – 1). Applying “rule of product” on both “left” and “right” I get 2 ^ (i – 1) * 1 = 2 ^ (i – 1). To sum it up: If S[i] is 0 or 5 we add to the answer 2 ^ (i – 1). Otherwise, we add nothing. The only problem remained for this simple version is how we calculate A ^ B modulo one number. This is a well known problem as well, called “Exponentiation by squaring”. Coming back to our problem: So what’s different in our problem? It’s the fact that we can’t iterate all elements of plate. However, we can use “concatenation” property. We know that if an element is a position i in the first copy, it will also be on positions i + n, i + 2 * n, i + 3 * n, …, i + (k – 1) * n (we don’t call here about trivial case when k = 1). What if iterate only one copy and calculate for all K copies. If in the first copy, at the position i is either 0 or 5, we have to calculate the sum 2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n). By now on, in calculus I'll denote i as i — 1 (it's a simple mathematical substitution). A first idea would be just to iterate each term and calculate it with exponentiation by squaring. However, it takes in the worst case the same complexity as iterating all plate. We need to find something smarter.2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n) = = 2 ^ i * 1 + 2 ^ i * 2 ^ n + 2 ^ i * 2 ^ (2 * n) + … + 2 ^ i * 2 ^ ((k – 1) * N) == 2 ^ i * (2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ ((k – 1) * n)We reduced the problem to calculate sum S = 2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ (X * n).What’s the value of 2 ^ n * S ? It is 2 ^ n + 2 ^ (2 * n) + 2 ^ (3 * n) + … + 2 ^ ((X + 1) * n). And what you get by making 2 ^ n * S – S ? 2 ^ n * S – S = 2 ^ ((X + 1) * n) – 1S * (2 ^ n – 1) = 2 ^ ((X + 1) * n) – 1S = (2 ^ ((X + 1) * n) – 1) / (2 ^ n – 1).We can calculate both 2 ^ i and S with exponentiation by squaring and the problem is done. For \"/\" operator, we can use multiplicative inverse (you can read about that and about Fermat Little's theorem, taking care that 10^9 + 7 is a prime number). The time complexity is O(N * logK). Note: that kind of reduction of powers is called “power series” in math.Alternative solution: For this alternative solution, we don't need to use any special properties of 5. In fact, we can replace 5 by any integer p and still have the same solution. So for now, I shall write p in place of 5.This suggests a dynamic programming solution: denote dp(x,y) be the number of ways of deleting some digits in the first x digits to form a number that has remainder y (modulo p). For simplicity, we accept “empty” plate be a number that is divisible by p. Writing the DP formula is not difficult. We start with dp(0,0) = 1, and suppose we already have the value dp(x,y). We shall use dp(x,y) to update for dp(x + 1,*), which has two possible cases: either keeping the (x + 1)-th digit or by deleting it. I won't go into much detail here. The answer is therefore dp(N,0).Clearly, applying this DP directly would time out. For a better algorithm, we resort on the periodicity of the actual plate. The key idea is that, we imagine each digit in the plate as a linear transformation from (x0, x1, .., x(p – 1)) to (y0, y1, y(p-1)). Obviously, (x0, x1, .., x(p — 1)) corresponds to some dp(i, 0), dp(i, 1) .. dp(i, p — 1) and (y0, y1, y(p-1)) corresponds to some (dp(i + 1, 0)), dp((i + 1), 1), ..., dp(i + 1, p — 1) .So we can write X * M(d) = Y, where X and Y are vectors of length p, and M(d) is the matrix of size p * p representing digit d (note that M(d) is independent from X and Y). By multiplying all |a|.K such matrices together, we obtain a transformation from (1, 0, 0, .., 0) to (T0, T1, .., T(p – 1)) where T0 is actually our answer (including the empty plate).What's the difference? We can group the matrices in groups of length |a|, and lift to the exponent K. That leads to an algorithm with time complexity O(p^3(|a| + log K)), which could be risky. To improve, we should go back to our original DP function and observe that it is actually a linear transformation from (1, 0, 0, .., 0) to (R0, R1, …, R(p – 1)), if we restrict ourselves in the first fragment of length |a|. So instead of multiplying |a| matrices together, we can run DP p times with initial conditions (0, 0, .., 0, 1, 0, .., 0) to obtain the matrix transformation. The overall time complexity becomes O(|a| * p^2 + p^3 log K) . 327D - Башни из кирпичейIn case you want to try some examples on your own, you may play this game, which is the origin of this problem: http://en.wikipedia.org/wiki/Tower_BloxxNow back to the analysis :)The restriction given in the problem poses you to think of building as many Red Towers as possible, and fill the rest with Blue Towers (since there is no profit of letting cells empty, such cells can be filled by Blue Towers). Also, it's quite obvious to see that each connected component (containing empty cells only) is independent from each other, so we shall iterate the component one by one. Denote the current component be S.Lemma 1 is impossible to build S so that it contains all Red Towers only.Proof Suppose there exists such a way. Look up the last cell that is built (denote by x). Clearly x is a Red Tower, so at the moment it is built, x must be adjacent to a cell than contains a Blue Tower. However, it's obvious that there's no such cell (if there is, it must belong to S, which is impossible).As it's impossible to have all Red Towers, it's natural to look up at the next best solution: the one with exactly one Blue Tower, and among them, we need to find the least lexicographic solution. Fortunately, we can prove that such a configuration is always possible. Such proof is quite tricky, indeed:Lemma 2 Pick any cell b in S. It is possible to build a configuration that has all but b be Red Towers, and b is a Blue Tower.Proof Construct a graph whose vertices correspond to the cells of S, and the edges correspond to cells that are adjacent. Since S is connected, it is possible to build a tree that spans to all vertices of S. Pick b as the root and do the following: Build all cells of S blue Move from the leaf to the root. At each cell (except the root), destroy the Blue Tower and rebuild with the Red Tower. To be precise, u can be destroyed (and rebuilt) if all vertices in the subtree rooted at u have already been rebuilt. How can it be the valid solution? Take any vertex u which is about to be rebuilt. Clearly u is not b, and u has its parent to be blue, so the condition for rebuilding can be met. When the building is completed, only b remains intact, while others have been transformed into Red Towers.So we get the following algorithm: do a BFS / DFS search to find connected components. Then, apply Lemma 2 to build a valid configuration.327E - Идем по осиUsually when dealing with complicated problems, a good idea is to solve them for small cases. Let’s try this here.First case: K = 0. The answer is obviously N! (each permutation of p1, p2, …, pn would be good).Next case: K = 1. The answer of this one is N! – |L1|. By L1 I denote all routes for which a prefix sum is equal to first lucky number. Obviously, if from all routes I exclude the wrong ones, I get my answer. If we can find an algorithm to provide |L1| in good time, then problem is solved for K = 1. We can just try all N! permutations. Despite this method is simple, it has complexity O(N!), too much for the constraints. Suppose we’ve founded a set of positions p1, p2, .., pk such as a[p1] + a[p2] + ..+ a[pk] = U1 (first unlucky number). How many permutations can we make? The first k positions need to be p1, p2, .., pk, but in any order. Hence we get k! . The not used positions can also appeared in any order, starting from k + 1 position. As they are n – k, we can permute them in (n – k)! ways. Hence, the answer is k! * (n – k)! Instead of permuting {1, 2, .., n}, now we need to find subsets of it. Hence, the running time becomes O(2^n). This is still too much. Meet in the middle. We make all subsets for first half of positions (from 1 to N / 2) and them for second half (from N / 2 + 1 to N). For each subset we keep 2 information: (sum, cnt) representing that there is a subset of sum “sum” containing “cnt” elements. For each (X, Y) from left we iterate in the right. After choosing one element from the left and one from the right we just “split” them. To split 2 states (A, B) and (C, D), the new state becomes (A + C, B + D). But we know that A + C = U1. This comes us to the idea: for each (X, Y) in the left, I check (U1 – X, 1), (U1 – X, 2), … , (U1 – X, K) from the right. For each of them, the answer would be (Y + K)! * (N – Y – K)! . I can store (using any data structure that allows this operations, I suggest a hash) how(C, D) = how many times does state (C, D) appear in the right. So, for a state (A, B) the answer becomes a sum of how(U1 — A, K) * (B + K)! * (N — B — K)!. Doing the sum for all states (A, B), we get our answer. The complexity of this method is O(2 ^ (N / 2) * N). Final Case: K = 2 The whole \"meet in the middle\" explanation worthed. We will do something very similar to solve this case. Suppose U1 and U2 are the unlucky numbers. Without loosing the generality, let's assume U1 <= U2.Following \"Principle of inclusion and exclusion\" paradigm (google about it if you never heard before) we can write our solution as N! — |L1| — |L2| + |intersection between L1 and L2|. Again, by L1,2 I denote the number of routes which have a prefix sum equal to number U1,2. The |X| is again the cardinal of this set. Basically we can calculate |X| as for K = 1. The only problem remained is calculating |intersection between L1 and L2|.The |intersection between L1 and L2| is the number of permutations which have a prefix sum equal to U1 and a prefix sum equal to U2. Since U1 <= U2, we can split a permutation from this set in 3 parts: 1/ p1, p2, ...pk such as a[p1] + a[p2] + ... + a[pk] = U1.2/ pk+1, pk+2, ..., pm such as a[pk+1], a[pk+2], ..., a[pm] = U2 — U1. Note that a[p1] + a[p2] + ... + a[pm] = U2. 3/ The rest of elements until position n.By a perfectly identical logic from K = 1 case, the number of permutations given those p[] would be k! * (m — k)! * (n — m)!.So the problem reduces to: find all indices set p1, p2, ... and q1, q2, .. such as a[p1] + a[p2] + ... + a[pn1] = U1 and a[q1] + a[q2] + ... + a[qn2] = U2 — U1. Then, we can apply formula using n1 and n2 described above. The first idea would be O(3 ^ N) — for each position from {1, 2, .., n} atribute all combinations of {0, 1, 2}. 0 means that position i is 1/, 1 means that position i is in 2/ and 2 means that position i is in 3/ . This would time out.Happily, we can improve it with meet in the middle principle. The solution is very similar with K = 1 case. I won't fully explain it here, if you understood principle from K = 1 this shouldn't be a problem. The base idea is to keep (S1, S2, cnt1, cnt2) for both \"left\" and \"right\". (S1, S2, cnt1, cnt2) represents a subset which has sum of elements from 1/ equal to S1, sum of elements from 2/ equal to S2, in 1/ we have cnt1 element and in 2/ we get cnt2 elements. For a (S1, S2, cnt1, cnt2) state from \"left\" we are looking in the right for something like (U1 — S1, U2 — U1 — S2, i, j). We get O(3 ^ (N / 2) * N ^ 2) complexity.Unexpected solution During the round, we saw a lot of O(2 ^ N * N) solutions passing. This was totally out of expectations. I believe if would make tests stronger, this solution won't pass and round would be more challenging. That's it, nothing is perfect. As requested, I'll explain that solution here. Before explaining the solution, I assume you have some experience with \"bitmask dp\" technique. If you don't, please read before: http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=bitManipulationhttp://codeforces.com/blog/entry/337In this problem we'll assume that a is 0-based. For a mask, consider bits from right to left, noting them bit 0, bit 1 and so on. Bit i is 1 if and only if a[i] is in the subset which is in a bijective replation with the mask. For example, for mask 100011101 the subset is {a0, a2, a3, a4, a8}. I'll call from now on the subset \"subset of mask\". Also, the sum of all elements in a subset will be called \"sum of mask\" (i.e. a0 + a2 + a3 + a4 + a8). We'll explain the solution based by watashi's submission. 4017915First step of the algorithm is to calculate sum of each mask. Let dp[i] the sum of mask i. Remove exactly one element from the subset of mask. Suppose the new mask obtained is k and removed element is j. Then, dp[i] = dp[k] + a[j]. dp[k] is always calculated before dp[i] (to proof, write both k and i in base 10. k is always smaller than i). Having j an element from subset of mask i, we can compute mask k by doing i ^ (1 << j). Bit j is 1, and by xor-ing it with another 1 bit, it becomes 0. Other bits are unchanged by being xor-ed by 0. This method works very fast to compute sum of each mask.From now on, let's denote a new array dp2[i] = how many good routes can I obtain with elements from subset of mask i. Watashi uses same dp[] array, but for making it clear, in editorial I'll use 2 separate arrays. Suppose that CNT(i) is number of elements from subset of mask i. We are interested in how many ways we can fill positions {1, 2, ..., CNT(i)} with elements from subset of mask i such as each prefix sum is different by each unlucky number. Next step of the algorithm is to see which sum of masks are equal to one of unlucky numbers. We mark them as \"-1\" in dp2[]. Suppose we founded a subset {a1, a2, ..., ax} for which a1 + a2 + ... + ax = one of unlucky numbers. Then, none permutation of {a1, a2, ..., ax} is allowed to appear on first x positions. When we arrive to a \"-1\" state, we know that the number of good routes for its subset of mask is 0.Now, finally the main dp recurrence. If for the current mask i, dp2[i] = -1, then dp2[i] = 0 and continue (we discard the state as explained above). Otherwise, we know that there could exist at least one way to complete positions {1, 2, ... CNT(i)} with elements of subset of mask i. But how to calculate it? We fix the last element (the element from the position CNT(I)) with some j from subset of mask i. The problem reduces now with how many good routes can I fill in positions {1, 2, ..., CNT(i) — 1} with elements from subset of mask i, from which we erased element j. With same explanation of sum of mask calculations, this is already calculated in dp2[i ^ (1 << j)]. The result is dp2[(1 << N) — 1] (number of good routes containing all positions). Editorial has been made by me and ll931110.The authors of the problems: Div.2 A & Div.2 B — meDiv.2 C & Div.2 D & Div.2 E — ll931110",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8274",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 327\\s*A"
          },
          "content_length": 20131
        },
        {
          "title": "2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest - Codeforces",
          "content": "Welcome to the contest of Saratov State U on Petrozavodsk Winter Training Camp 2012-2013. This contest was prepared with diligence and love by jury team of ACM-ICPC NEERC Subregional (Saratov) Contest. Here is the complete list of writers: MikeMirzayanov Nerevar RAD e-maxx natalia NALP Dmitry Klenov Dmitry Mescheryakov Dmitry Stepanenko Thanks to all of them!All the authors invite you to take part in the contest virtually in Gym, if: You didn't take part in it previously You (or your team) is high skilled that you will take part (or took part) on ACM-ICPC World Finals or other high-level competitions. The problemset seems to be hard for not experienced participants. Hope, you will enjoy the contest!Contest link: 2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6656",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 1",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 2",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 1",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 2",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 3",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 4",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 5",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 6",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 7",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 8",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Random 0s and 1s */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"all_zero\") {\n        /* All zeros */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        /* All ones */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternate_zero\") {\n        /* Alternating 0 and 1, starting with 0 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n        }\n    } else if (type == \"alternate_one\") {\n        /* Alternating 1 and 0, starting with 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i + 1) % 2;\n        }\n    } else if (type == \"one_zero\") {\n        /* All ones except one zero at a random position */\n        fill(a.begin(), a.end(), 1);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 0;\n    } else if (type == \"one_one\") {\n        /* All zeros except one one at a random position */\n        fill(a.begin(), a.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    } else if (type == \"first_half_zero\") {\n        /* First half zeros, second half ones */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i < n / 2) ? 0 : 1;\n        }\n    } else if (type == \"first_half_one\") {\n        /* First half ones, second half zeros */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i < n / 2) ? 1 : 0;\n        }\n    } else if (type == \"max_no_full_flip\") {\n        /* Cannot flip to all ones */\n        if (n >= 2) {\n            fill(a.begin(), a.end(), 1);\n            a[0] = 0;\n            a[n - 1] = 0;\n        } else {\n            a[0] = 0;\n        }\n    } else {\n        /* Default random */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    }\n\n    /* Output the array */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Random 0s and 1s */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"all_zero\") {\n        /* All zeros */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        /* All ones */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternate_zero\") {\n        /* Alternating 0 and 1, starting with 0 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n        }\n    } else if (type == \"alternate_one\") {\n        /* Alternating 1 and 0, starting with 1 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i + 1) % 2;\n        }\n    } else if (type == \"one_zero\") {\n        /* All ones except one zero at a random position */\n        fill(a.begin(), a.end(), 1);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 0;\n    } else if (type == \"one_one\") {\n        /* All zeros except one one at a random position */\n        fill(a.begin(), a.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    } else if (type == \"first_half_zero\") {\n        /* First half zeros, second half ones */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i < n / 2) ? 0 : 1;\n        }\n    } else if (type == \"first_half_one\") {\n        /* First half ones, second half zeros */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i < n / 2) ? 1 : 0;\n        }\n    } else if (type == \"max_no_full_flip\") {\n        /* Cannot flip to all ones */\n        if (n >= 2) {\n            fill(a.begin(), a.end(), 1);\n            a[0] = 0;\n            a[n - 1] = 0;\n        } else {\n            a[0] = 0;\n        }\n    } else {\n        /* Default random */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    }\n\n    /* Output the array */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_one\n./gen -n 1 -type random\n\n./gen -n 2 -type all_zero\n./gen -n 2 -type all_one\n./gen -n 2 -type random\n\n./gen -n 2 -type one_zero\n./gen -n 2 -type one_one\n./gen -n 2 -type max_no_full_flip\n\n./gen -n 10 -type random\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n./gen -n 10 -type alternate_zero\n./gen -n 10 -type alternate_one\n./gen -n 10 -type one_zero\n./gen -n 10 -type one_one\n\n./gen -n 50 -type random\n./gen -n 50 -type first_half_zero\n./gen -n 50 -type first_half_one\n./gen -n 50 -type max_no_full_flip\n\n./gen -n 99 -type max_no_full_flip\n\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type all_zero\n./gen -n 100 -type all_one\n./gen -n 100 -type one_zero\n./gen -n 100 -type one_one\n./gen -n 100 -type alternate_zero\n./gen -n 100 -type alternate_one\n./gen -n 100 -type max_no_full_flip\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:33.913234",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "327/B",
      "title": "B. Hungry Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains a single integer: n (1 ≤ n ≤ 105).",
      "output_spec": "OutputOutput a line that contains n space-separated integers a1 a2, ..., an (1 ≤ ai ≤ 107), representing a possible Hungry sequence. Note, that each ai must not be greater than 10000000 (107) and less than 1.If there are multiple solutions you can output any one.",
      "sample_tests": "ExamplesInputCopy3OutputCopy2 9 15InputCopy5OutputCopy11 14 20 27 31",
      "description": "B. Hungry Sequence\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains a single integer: n (1 ≤ n ≤ 105).\n\nOutputOutput a line that contains n space-separated integers a1 a2, ..., an (1 ≤ ai ≤ 107), representing a possible Hungry sequence. Note, that each ai must not be greater than 10000000 (107) and less than 1.If there are multiple solutions you can output any one.\n\nInputCopy3OutputCopy2 9 15InputCopy5OutputCopy11 14 20 27 31\n\nOutputCopy2 9 15\n\nOutputCopy11 14 20 27 31",
      "solutions": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces",
          "content": "Welcome to another Codeforces Round!Please note that the time of round #191 was changed. Contest will start at Thursday 12:30 UTC.My name is Linh (ll931110). I'm from Vietnam, and I'm glad to present to you my first Codeforces round. It is for Div 2 only; however, I welcome participants from Div. 1 to participate and enjoy challenging problems. I hope this would be a pleasant gift for those who are going to IOI 2013 (and participants from World Finals), which will take place in just a couple of days. This round is prepared by me and fchirica (from Romania). Also, I would like to thank the Codeforces team who puts efforts on making Codeforces and Polygon possible.Happy solving!UPD1: The score of problems in this round will be dynamic. The problems will be sorted in increasing difficulty order, at least in our perspective.UPD2: The contest is over! Congratulations for everybody, especially for those who solved E. You proved to be smarter than I am (your solutions were totally unexpected to us). Thank Gerald, Aksenov239 and Delinur for helping us on preparing the round!Div. 2 winners: SillyHook02 Tsukiko Quit_Quickly Zhengxu sevenzplus Those are five people who nail all problems!Unofficial winners: Kissshot R_R_ xchernoff wakaka phtniit The editorial will be completed soon after revising and adding possible alternative solutions. You are welcome to post your answers in comments.Thank you and see you in the next round!UPD3: Editorial is now available. Remind that it is not the final version, as we are writing possible alternative solutions for problems. Stay tuned!UPD4: Editorial is now completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1620
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces",
          "content": "327A - Игра с переворачиваниемI’ll present here the O(N ^ 3) algorithm, which is enough to solve this task. Then, for those interested, I’ll show a method to achieve O(N) complexity.O(N ^ 3) method: The first thing to observe is that constrains are slow enough to allow a brute force algorithm. Using brute force, I can calculate for each possible single move the number of 1s resulting after applying it and take maximum. For consider each move, I can just generate with 2 FOR loops all indices i, j such as i <= j. So far we have O(N ^ 2) complexity. Suppose I have now 2 fixed vaIues i and j. I need to calculate variable cnt (initially 0) representing the number of ones if I do the move. For do this, I choose another indice k to go in a[] array (taking O(N) time, making the total of O(N ^ 3) complexity). We have two cases: either k is in range [i, j] (this means i <= k AND k <= j) or not (if that condition is not met). If it’s in range, then it gets flipped, so we add to count variable 1 – a[k] (observe that it makes 0 to 1 and 1 to 0). If it’s not in range, we simply add to cnt variable a[k]. The answer is maximum of all cnt obtained.O(N) method: For achieve this complexity, we need to make an observation. Suppose I flip an interval (it does not matter what interval, it can be any interval). Also suppose that S is the number of ones before flipiing it. What happens? Every time I flip a 0 value, S increases by 1 (I get a new 1 value). Every time I flip a 1 value, S decreases by 1 (I loose a 1 value). What would be the “gain” from a flip? I consider winning “+1” when I get a 0 value and “-1” when I get a 1 value. The “gain” would be simply a sum of +1 and -1. This gives us idea to make another vector b[]. B[i] is 1 if A[i] is 0 and B[i] is -1 if A[i] is 1. We want to maximize S + gain_after_one_move sum. As S is constant, I want to maximize gain_after_one_move. In other words, I want to find a subsequence in b[] which gives the maximal sum. If I flip it, I get maximal number of 1s too. This can be founded trivially in O(N ^ 2). How to get O(N)? A relative experienced programmer in dynamic programming will immediately recognize it as a classical problem “subsequence of maximal sum”. If you never heard about it, come back to this approach after you learn it. 327B - Голодная последовательностьWe’ll present two different solutions for this task.Solution 1. What if we solve a more general task? What if each hungry number from the solution isn’t allowed to be divided by any number smaller than it (except 1, which is divides every natural number). If this more general condition would be met, then the “hungry” condition would be met, too (as a[i] won’t be divided by a number smaller than it (except 1), it won’t be divided by a[j], too, with j < i, assuming that a[j] is different from 1). Now how to find numbers for this more general condition? We can rephrase it as: each number from more general condition has 2 divisors: 1 and itself. So if we print N numbers with 2 divisors in increasing order, that would be a good solution. As you probably know, numbers with 2 divisors are called “prime numbers”. The task reduces to finding first N prime numbers. This can be done via brute force, or via Sieve of Eratosthenes (however, not necessarily to get an AC solution).Solution 2. Suppose we are given the number N. We can observe that for big enough consecutive numbers, the array is always hungry. For example, we can print 3 * N + 0, 3 * N + 1, 3 * N + 2, …, 3 * N + (N – 1). Magic, isn’t it? Why does it work now? Pick an arbitrary a[i]. The solution would be bad if one of numbers 2 * a[i], 3 * a[i], 4 * a[i] and so on would be in a[] array. However, it will never happen. The smallest multiple from that ones will be 2 * 3 * N = 6 * N. There is not possible to obtain a smallest multiple than that one. On the other hand, the biggest number from a[] array would be 3 * N + N – 1 = 4 * N — 1. Since smallest multiple is bigger than biggest term of the array, it (and of course other multiples bigger than it) will never exist in a[] array. So the above solution is correct also. 327C - Волшебная пятеркаProperty: A number is divisible by 5 if and only if its last digit is either 0 or 5.A first solution: Suppose you’re given a plate S, not so big, so we can iterate all its elements. Can we get the answer? I build a new array sol[]. In explanation, both S and sol will be 1-based. Denote N = size of S. Also, denote sol[i] = the number of ways to delete digits from plate S such as we obtain a magic number which has the last digit on position i. The answer is sol[1] + sol[2] + … + sol[N]. Let’s focus now on calculating sol[i]. If S[i] (digit of the plate corresponding to ith position) is different than 0 or 5, then sol[i] is 0 (see “property”). Otherwise we have to ask ourself: in how many ways I can delete digits in “left” and in “right” of position i. In the “right”, we have only one way: delete all digits (if one digit from right still stands, then the number isn’t ending at position i). Now in the “left”: there are digits on positions 1, 2, …, i – 1. We can either delete a digit or keep it – anyhow he’d do we still get a magic number. So on position 1 I have 2 ways (delete or keep it), on position 2 I have also 2 ways, …, on position i – 1 I have also 2 ways. Next, we apply what mathematics call “rule of product” and we get 2 * 2 * 2 … * 2 (i – 1 times) = 2 ^ (i – 1). Applying “rule of product” on both “left” and “right” I get 2 ^ (i – 1) * 1 = 2 ^ (i – 1). To sum it up: If S[i] is 0 or 5 we add to the answer 2 ^ (i – 1). Otherwise, we add nothing. The only problem remained for this simple version is how we calculate A ^ B modulo one number. This is a well known problem as well, called “Exponentiation by squaring”. Coming back to our problem: So what’s different in our problem? It’s the fact that we can’t iterate all elements of plate. However, we can use “concatenation” property. We know that if an element is a position i in the first copy, it will also be on positions i + n, i + 2 * n, i + 3 * n, …, i + (k – 1) * n (we don’t call here about trivial case when k = 1). What if iterate only one copy and calculate for all K copies. If in the first copy, at the position i is either 0 or 5, we have to calculate the sum 2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n). By now on, in calculus I'll denote i as i — 1 (it's a simple mathematical substitution). A first idea would be just to iterate each term and calculate it with exponentiation by squaring. However, it takes in the worst case the same complexity as iterating all plate. We need to find something smarter.2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n) = = 2 ^ i * 1 + 2 ^ i * 2 ^ n + 2 ^ i * 2 ^ (2 * n) + … + 2 ^ i * 2 ^ ((k – 1) * N) == 2 ^ i * (2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ ((k – 1) * n)We reduced the problem to calculate sum S = 2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ (X * n).What’s the value of 2 ^ n * S ? It is 2 ^ n + 2 ^ (2 * n) + 2 ^ (3 * n) + … + 2 ^ ((X + 1) * n). And what you get by making 2 ^ n * S – S ? 2 ^ n * S – S = 2 ^ ((X + 1) * n) – 1S * (2 ^ n – 1) = 2 ^ ((X + 1) * n) – 1S = (2 ^ ((X + 1) * n) – 1) / (2 ^ n – 1).We can calculate both 2 ^ i and S with exponentiation by squaring and the problem is done. For \"/\" operator, we can use multiplicative inverse (you can read about that and about Fermat Little's theorem, taking care that 10^9 + 7 is a prime number). The time complexity is O(N * logK). Note: that kind of reduction of powers is called “power series” in math.Alternative solution: For this alternative solution, we don't need to use any special properties of 5. In fact, we can replace 5 by any integer p and still have the same solution. So for now, I shall write p in place of 5.This suggests a dynamic programming solution: denote dp(x,y) be the number of ways of deleting some digits in the first x digits to form a number that has remainder y (modulo p). For simplicity, we accept “empty” plate be a number that is divisible by p. Writing the DP formula is not difficult. We start with dp(0,0) = 1, and suppose we already have the value dp(x,y). We shall use dp(x,y) to update for dp(x + 1,*), which has two possible cases: either keeping the (x + 1)-th digit or by deleting it. I won't go into much detail here. The answer is therefore dp(N,0).Clearly, applying this DP directly would time out. For a better algorithm, we resort on the periodicity of the actual plate. The key idea is that, we imagine each digit in the plate as a linear transformation from (x0, x1, .., x(p – 1)) to (y0, y1, y(p-1)). Obviously, (x0, x1, .., x(p — 1)) corresponds to some dp(i, 0), dp(i, 1) .. dp(i, p — 1) and (y0, y1, y(p-1)) corresponds to some (dp(i + 1, 0)), dp((i + 1), 1), ..., dp(i + 1, p — 1) .So we can write X * M(d) = Y, where X and Y are vectors of length p, and M(d) is the matrix of size p * p representing digit d (note that M(d) is independent from X and Y). By multiplying all |a|.K such matrices together, we obtain a transformation from (1, 0, 0, .., 0) to (T0, T1, .., T(p – 1)) where T0 is actually our answer (including the empty plate).What's the difference? We can group the matrices in groups of length |a|, and lift to the exponent K. That leads to an algorithm with time complexity O(p^3(|a| + log K)), which could be risky. To improve, we should go back to our original DP function and observe that it is actually a linear transformation from (1, 0, 0, .., 0) to (R0, R1, …, R(p – 1)), if we restrict ourselves in the first fragment of length |a|. So instead of multiplying |a| matrices together, we can run DP p times with initial conditions (0, 0, .., 0, 1, 0, .., 0) to obtain the matrix transformation. The overall time complexity becomes O(|a| * p^2 + p^3 log K) . 327D - Башни из кирпичейIn case you want to try some examples on your own, you may play this game, which is the origin of this problem: http://en.wikipedia.org/wiki/Tower_BloxxNow back to the analysis :)The restriction given in the problem poses you to think of building as many Red Towers as possible, and fill the rest with Blue Towers (since there is no profit of letting cells empty, such cells can be filled by Blue Towers). Also, it's quite obvious to see that each connected component (containing empty cells only) is independent from each other, so we shall iterate the component one by one. Denote the current component be S.Lemma 1 is impossible to build S so that it contains all Red Towers only.Proof Suppose there exists such a way. Look up the last cell that is built (denote by x). Clearly x is a Red Tower, so at the moment it is built, x must be adjacent to a cell than contains a Blue Tower. However, it's obvious that there's no such cell (if there is, it must belong to S, which is impossible).As it's impossible to have all Red Towers, it's natural to look up at the next best solution: the one with exactly one Blue Tower, and among them, we need to find the least lexicographic solution. Fortunately, we can prove that such a configuration is always possible. Such proof is quite tricky, indeed:Lemma 2 Pick any cell b in S. It is possible to build a configuration that has all but b be Red Towers, and b is a Blue Tower.Proof Construct a graph whose vertices correspond to the cells of S, and the edges correspond to cells that are adjacent. Since S is connected, it is possible to build a tree that spans to all vertices of S. Pick b as the root and do the following: Build all cells of S blue Move from the leaf to the root. At each cell (except the root), destroy the Blue Tower and rebuild with the Red Tower. To be precise, u can be destroyed (and rebuilt) if all vertices in the subtree rooted at u have already been rebuilt. How can it be the valid solution? Take any vertex u which is about to be rebuilt. Clearly u is not b, and u has its parent to be blue, so the condition for rebuilding can be met. When the building is completed, only b remains intact, while others have been transformed into Red Towers.So we get the following algorithm: do a BFS / DFS search to find connected components. Then, apply Lemma 2 to build a valid configuration.327E - Идем по осиUsually when dealing with complicated problems, a good idea is to solve them for small cases. Let’s try this here.First case: K = 0. The answer is obviously N! (each permutation of p1, p2, …, pn would be good).Next case: K = 1. The answer of this one is N! – |L1|. By L1 I denote all routes for which a prefix sum is equal to first lucky number. Obviously, if from all routes I exclude the wrong ones, I get my answer. If we can find an algorithm to provide |L1| in good time, then problem is solved for K = 1. We can just try all N! permutations. Despite this method is simple, it has complexity O(N!), too much for the constraints. Suppose we’ve founded a set of positions p1, p2, .., pk such as a[p1] + a[p2] + ..+ a[pk] = U1 (first unlucky number). How many permutations can we make? The first k positions need to be p1, p2, .., pk, but in any order. Hence we get k! . The not used positions can also appeared in any order, starting from k + 1 position. As they are n – k, we can permute them in (n – k)! ways. Hence, the answer is k! * (n – k)! Instead of permuting {1, 2, .., n}, now we need to find subsets of it. Hence, the running time becomes O(2^n). This is still too much. Meet in the middle. We make all subsets for first half of positions (from 1 to N / 2) and them for second half (from N / 2 + 1 to N). For each subset we keep 2 information: (sum, cnt) representing that there is a subset of sum “sum” containing “cnt” elements. For each (X, Y) from left we iterate in the right. After choosing one element from the left and one from the right we just “split” them. To split 2 states (A, B) and (C, D), the new state becomes (A + C, B + D). But we know that A + C = U1. This comes us to the idea: for each (X, Y) in the left, I check (U1 – X, 1), (U1 – X, 2), … , (U1 – X, K) from the right. For each of them, the answer would be (Y + K)! * (N – Y – K)! . I can store (using any data structure that allows this operations, I suggest a hash) how(C, D) = how many times does state (C, D) appear in the right. So, for a state (A, B) the answer becomes a sum of how(U1 — A, K) * (B + K)! * (N — B — K)!. Doing the sum for all states (A, B), we get our answer. The complexity of this method is O(2 ^ (N / 2) * N). Final Case: K = 2 The whole \"meet in the middle\" explanation worthed. We will do something very similar to solve this case. Suppose U1 and U2 are the unlucky numbers. Without loosing the generality, let's assume U1 <= U2.Following \"Principle of inclusion and exclusion\" paradigm (google about it if you never heard before) we can write our solution as N! — |L1| — |L2| + |intersection between L1 and L2|. Again, by L1,2 I denote the number of routes which have a prefix sum equal to number U1,2. The |X| is again the cardinal of this set. Basically we can calculate |X| as for K = 1. The only problem remained is calculating |intersection between L1 and L2|.The |intersection between L1 and L2| is the number of permutations which have a prefix sum equal to U1 and a prefix sum equal to U2. Since U1 <= U2, we can split a permutation from this set in 3 parts: 1/ p1, p2, ...pk such as a[p1] + a[p2] + ... + a[pk] = U1.2/ pk+1, pk+2, ..., pm such as a[pk+1], a[pk+2], ..., a[pm] = U2 — U1. Note that a[p1] + a[p2] + ... + a[pm] = U2. 3/ The rest of elements until position n.By a perfectly identical logic from K = 1 case, the number of permutations given those p[] would be k! * (m — k)! * (n — m)!.So the problem reduces to: find all indices set p1, p2, ... and q1, q2, .. such as a[p1] + a[p2] + ... + a[pn1] = U1 and a[q1] + a[q2] + ... + a[qn2] = U2 — U1. Then, we can apply formula using n1 and n2 described above. The first idea would be O(3 ^ N) — for each position from {1, 2, .., n} atribute all combinations of {0, 1, 2}. 0 means that position i is 1/, 1 means that position i is in 2/ and 2 means that position i is in 3/ . This would time out.Happily, we can improve it with meet in the middle principle. The solution is very similar with K = 1 case. I won't fully explain it here, if you understood principle from K = 1 this shouldn't be a problem. The base idea is to keep (S1, S2, cnt1, cnt2) for both \"left\" and \"right\". (S1, S2, cnt1, cnt2) represents a subset which has sum of elements from 1/ equal to S1, sum of elements from 2/ equal to S2, in 1/ we have cnt1 element and in 2/ we get cnt2 elements. For a (S1, S2, cnt1, cnt2) state from \"left\" we are looking in the right for something like (U1 — S1, U2 — U1 — S2, i, j). We get O(3 ^ (N / 2) * N ^ 2) complexity.Unexpected solution During the round, we saw a lot of O(2 ^ N * N) solutions passing. This was totally out of expectations. I believe if would make tests stronger, this solution won't pass and round would be more challenging. That's it, nothing is perfect. As requested, I'll explain that solution here. Before explaining the solution, I assume you have some experience with \"bitmask dp\" technique. If you don't, please read before: http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=bitManipulationhttp://codeforces.com/blog/entry/337In this problem we'll assume that a is 0-based. For a mask, consider bits from right to left, noting them bit 0, bit 1 and so on. Bit i is 1 if and only if a[i] is in the subset which is in a bijective replation with the mask. For example, for mask 100011101 the subset is {a0, a2, a3, a4, a8}. I'll call from now on the subset \"subset of mask\". Also, the sum of all elements in a subset will be called \"sum of mask\" (i.e. a0 + a2 + a3 + a4 + a8). We'll explain the solution based by watashi's submission. 4017915First step of the algorithm is to calculate sum of each mask. Let dp[i] the sum of mask i. Remove exactly one element from the subset of mask. Suppose the new mask obtained is k and removed element is j. Then, dp[i] = dp[k] + a[j]. dp[k] is always calculated before dp[i] (to proof, write both k and i in base 10. k is always smaller than i). Having j an element from subset of mask i, we can compute mask k by doing i ^ (1 << j). Bit j is 1, and by xor-ing it with another 1 bit, it becomes 0. Other bits are unchanged by being xor-ed by 0. This method works very fast to compute sum of each mask.From now on, let's denote a new array dp2[i] = how many good routes can I obtain with elements from subset of mask i. Watashi uses same dp[] array, but for making it clear, in editorial I'll use 2 separate arrays. Suppose that CNT(i) is number of elements from subset of mask i. We are interested in how many ways we can fill positions {1, 2, ..., CNT(i)} with elements from subset of mask i such as each prefix sum is different by each unlucky number. Next step of the algorithm is to see which sum of masks are equal to one of unlucky numbers. We mark them as \"-1\" in dp2[]. Suppose we founded a subset {a1, a2, ..., ax} for which a1 + a2 + ... + ax = one of unlucky numbers. Then, none permutation of {a1, a2, ..., ax} is allowed to appear on first x positions. When we arrive to a \"-1\" state, we know that the number of good routes for its subset of mask is 0.Now, finally the main dp recurrence. If for the current mask i, dp2[i] = -1, then dp2[i] = 0 and continue (we discard the state as explained above). Otherwise, we know that there could exist at least one way to complete positions {1, 2, ... CNT(i)} with elements of subset of mask i. But how to calculate it? We fix the last element (the element from the position CNT(I)) with some j from subset of mask i. The problem reduces now with how many good routes can I fill in positions {1, 2, ..., CNT(i) — 1} with elements from subset of mask i, from which we erased element j. With same explanation of sum of mask calculations, this is already calculated in dp2[i ^ (1 << j)]. The result is dp2[(1 << N) — 1] (number of good routes containing all positions). Editorial has been made by me and ll931110.The authors of the problems: Div.2 A & Div.2 B — meDiv.2 C & Div.2 D & Div.2 E — ll931110",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8274",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 327\\s*B"
          },
          "content_length": 20131
        },
        {
          "title": "2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest - Codeforces",
          "content": "Welcome to the contest of Saratov State U on Petrozavodsk Winter Training Camp 2012-2013. This contest was prepared with diligence and love by jury team of ACM-ICPC NEERC Subregional (Saratov) Contest. Here is the complete list of writers: MikeMirzayanov Nerevar RAD e-maxx natalia NALP Dmitry Klenov Dmitry Mescheryakov Dmitry Stepanenko Thanks to all of them!All the authors invite you to take part in the contest virtually in Gym, if: You didn't take part in it previously You (or your team) is high skilled that you will take part (or took part) on ACM-ICPC World Finals or other high-level competitions. The problemset seems to be hard for not experienced participants. Hope, you will enjoy the contest!Contest link: 2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6656",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 1",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 2",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 1",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 2",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 3",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 4",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 5",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 6",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 7",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 8",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from the input file\n    int n = inf.readInt(1, 100000, \"n\");\n\n    // Read the contestant's output\n    vector<int> seq(n);\n    for (int i = 0; i < n; i++) {\n        seq[i] = ouf.readInt(1, 10000000, format(\"a[%d]\", i + 1).c_str());\n        if (i > 0 && seq[i] <= seq[i - 1]) {\n            quitf(_wa, \"Sequence is not strictly increasing at position %d: a[%d] = %d, a[%d] = %d\", \n                  i, i, seq[i - 1], i + 1, seq[i]);\n        }\n    }\n\n    // Map to store the position of each element\n    unordered_map<int, int> ai_to_index;\n    for (int i = 0; i < n; i++) {\n        ai_to_index[seq[i]] = i;\n    }\n\n    int max_ai = seq[n - 1];\n\n    // Check the non-divisibility condition\n    for (int i = 0; i < n; i++) {\n        int ai = seq[i];\n        for (long long multiple = 2LL * ai; multiple <= max_ai; multiple += ai) {\n            if (multiple > 10000000) break;\n            if (ai_to_index.count((int)multiple)) {\n                int j = ai_to_index[(int)multiple];\n                if (j > i) {\n                    quitf(_wa, \"Element a[%d] = %d is divisible by a[%d] = %d\", j + 1, seq[j], i + 1, ai);\n                }\n            }\n        }\n    }\n\n    // If all checks passed\n    quitf(_ok, \"Sequence is valid\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 1);\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 1);\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 50\n./gen -n 100\n./gen -n 500\n./gen -n 1000\n./gen -n 5000\n./gen -n 10000\n./gen -n 20000\n./gen -n 50000\n./gen -n 70000\n./gen -n 90000\n./gen -n 99999\n./gen -n 100000\n./gen -n 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:35.743656",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "327/C",
      "title": "C. Magic Five",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line you're given a string a (1 ≤ |a| ≤ 105), containing digits only. In the second line you're given an integer k (1 ≤ k ≤ 109). The plate s is formed by concatenating k copies of a together. That is n = |a|·k.",
      "output_spec": "OutputPrint a single integer — the required number of ways modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy12561OutputCopy4InputCopy139902OutputCopy528InputCopy5552OutputCopy63",
      "description": "C. Magic Five\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn the first line you're given a string a (1 ≤ |a| ≤ 105), containing digits only. In the second line you're given an integer k (1 ≤ k ≤ 109). The plate s is formed by concatenating k copies of a together. That is n = |a|·k.\n\nOutputPrint a single integer — the required number of ways modulo 1000000007 (109 + 7).\n\nInputCopy12561OutputCopy4InputCopy139902OutputCopy528InputCopy5552OutputCopy63\n\nInputCopy12561\n\nOutputCopy4\n\nInputCopy139902\n\nOutputCopy528\n\nInputCopy5552\n\nOutputCopy63\n\nNoteIn the first case, there are four possible ways to make a number that is divisible by 5: 5, 15, 25 and 125.In the second case, remember to concatenate the copies of a. The actual plate is 1399013990.In the third case, except deleting all digits, any choice will do. Therefore there are 26 - 1 = 63 possible ways to delete digits.",
      "solutions": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces",
          "content": "Welcome to another Codeforces Round!Please note that the time of round #191 was changed. Contest will start at Thursday 12:30 UTC.My name is Linh (ll931110). I'm from Vietnam, and I'm glad to present to you my first Codeforces round. It is for Div 2 only; however, I welcome participants from Div. 1 to participate and enjoy challenging problems. I hope this would be a pleasant gift for those who are going to IOI 2013 (and participants from World Finals), which will take place in just a couple of days. This round is prepared by me and fchirica (from Romania). Also, I would like to thank the Codeforces team who puts efforts on making Codeforces and Polygon possible.Happy solving!UPD1: The score of problems in this round will be dynamic. The problems will be sorted in increasing difficulty order, at least in our perspective.UPD2: The contest is over! Congratulations for everybody, especially for those who solved E. You proved to be smarter than I am (your solutions were totally unexpected to us). Thank Gerald, Aksenov239 and Delinur for helping us on preparing the round!Div. 2 winners: SillyHook02 Tsukiko Quit_Quickly Zhengxu sevenzplus Those are five people who nail all problems!Unofficial winners: Kissshot R_R_ xchernoff wakaka phtniit The editorial will be completed soon after revising and adding possible alternative solutions. You are welcome to post your answers in comments.Thank you and see you in the next round!UPD3: Editorial is now available. Remind that it is not the final version, as we are writing possible alternative solutions for problems. Stay tuned!UPD4: Editorial is now completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1620
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces",
          "content": "327A - Игра с переворачиваниемI’ll present here the O(N ^ 3) algorithm, which is enough to solve this task. Then, for those interested, I’ll show a method to achieve O(N) complexity.O(N ^ 3) method: The first thing to observe is that constrains are slow enough to allow a brute force algorithm. Using brute force, I can calculate for each possible single move the number of 1s resulting after applying it and take maximum. For consider each move, I can just generate with 2 FOR loops all indices i, j such as i <= j. So far we have O(N ^ 2) complexity. Suppose I have now 2 fixed vaIues i and j. I need to calculate variable cnt (initially 0) representing the number of ones if I do the move. For do this, I choose another indice k to go in a[] array (taking O(N) time, making the total of O(N ^ 3) complexity). We have two cases: either k is in range [i, j] (this means i <= k AND k <= j) or not (if that condition is not met). If it’s in range, then it gets flipped, so we add to count variable 1 – a[k] (observe that it makes 0 to 1 and 1 to 0). If it’s not in range, we simply add to cnt variable a[k]. The answer is maximum of all cnt obtained.O(N) method: For achieve this complexity, we need to make an observation. Suppose I flip an interval (it does not matter what interval, it can be any interval). Also suppose that S is the number of ones before flipiing it. What happens? Every time I flip a 0 value, S increases by 1 (I get a new 1 value). Every time I flip a 1 value, S decreases by 1 (I loose a 1 value). What would be the “gain” from a flip? I consider winning “+1” when I get a 0 value and “-1” when I get a 1 value. The “gain” would be simply a sum of +1 and -1. This gives us idea to make another vector b[]. B[i] is 1 if A[i] is 0 and B[i] is -1 if A[i] is 1. We want to maximize S + gain_after_one_move sum. As S is constant, I want to maximize gain_after_one_move. In other words, I want to find a subsequence in b[] which gives the maximal sum. If I flip it, I get maximal number of 1s too. This can be founded trivially in O(N ^ 2). How to get O(N)? A relative experienced programmer in dynamic programming will immediately recognize it as a classical problem “subsequence of maximal sum”. If you never heard about it, come back to this approach after you learn it. 327B - Голодная последовательностьWe’ll present two different solutions for this task.Solution 1. What if we solve a more general task? What if each hungry number from the solution isn’t allowed to be divided by any number smaller than it (except 1, which is divides every natural number). If this more general condition would be met, then the “hungry” condition would be met, too (as a[i] won’t be divided by a number smaller than it (except 1), it won’t be divided by a[j], too, with j < i, assuming that a[j] is different from 1). Now how to find numbers for this more general condition? We can rephrase it as: each number from more general condition has 2 divisors: 1 and itself. So if we print N numbers with 2 divisors in increasing order, that would be a good solution. As you probably know, numbers with 2 divisors are called “prime numbers”. The task reduces to finding first N prime numbers. This can be done via brute force, or via Sieve of Eratosthenes (however, not necessarily to get an AC solution).Solution 2. Suppose we are given the number N. We can observe that for big enough consecutive numbers, the array is always hungry. For example, we can print 3 * N + 0, 3 * N + 1, 3 * N + 2, …, 3 * N + (N – 1). Magic, isn’t it? Why does it work now? Pick an arbitrary a[i]. The solution would be bad if one of numbers 2 * a[i], 3 * a[i], 4 * a[i] and so on would be in a[] array. However, it will never happen. The smallest multiple from that ones will be 2 * 3 * N = 6 * N. There is not possible to obtain a smallest multiple than that one. On the other hand, the biggest number from a[] array would be 3 * N + N – 1 = 4 * N — 1. Since smallest multiple is bigger than biggest term of the array, it (and of course other multiples bigger than it) will never exist in a[] array. So the above solution is correct also. 327C - Волшебная пятеркаProperty: A number is divisible by 5 if and only if its last digit is either 0 or 5.A first solution: Suppose you’re given a plate S, not so big, so we can iterate all its elements. Can we get the answer? I build a new array sol[]. In explanation, both S and sol will be 1-based. Denote N = size of S. Also, denote sol[i] = the number of ways to delete digits from plate S such as we obtain a magic number which has the last digit on position i. The answer is sol[1] + sol[2] + … + sol[N]. Let’s focus now on calculating sol[i]. If S[i] (digit of the plate corresponding to ith position) is different than 0 or 5, then sol[i] is 0 (see “property”). Otherwise we have to ask ourself: in how many ways I can delete digits in “left” and in “right” of position i. In the “right”, we have only one way: delete all digits (if one digit from right still stands, then the number isn’t ending at position i). Now in the “left”: there are digits on positions 1, 2, …, i – 1. We can either delete a digit or keep it – anyhow he’d do we still get a magic number. So on position 1 I have 2 ways (delete or keep it), on position 2 I have also 2 ways, …, on position i – 1 I have also 2 ways. Next, we apply what mathematics call “rule of product” and we get 2 * 2 * 2 … * 2 (i – 1 times) = 2 ^ (i – 1). Applying “rule of product” on both “left” and “right” I get 2 ^ (i – 1) * 1 = 2 ^ (i – 1). To sum it up: If S[i] is 0 or 5 we add to the answer 2 ^ (i – 1). Otherwise, we add nothing. The only problem remained for this simple version is how we calculate A ^ B modulo one number. This is a well known problem as well, called “Exponentiation by squaring”. Coming back to our problem: So what’s different in our problem? It’s the fact that we can’t iterate all elements of plate. However, we can use “concatenation” property. We know that if an element is a position i in the first copy, it will also be on positions i + n, i + 2 * n, i + 3 * n, …, i + (k – 1) * n (we don’t call here about trivial case when k = 1). What if iterate only one copy and calculate for all K copies. If in the first copy, at the position i is either 0 or 5, we have to calculate the sum 2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n). By now on, in calculus I'll denote i as i — 1 (it's a simple mathematical substitution). A first idea would be just to iterate each term and calculate it with exponentiation by squaring. However, it takes in the worst case the same complexity as iterating all plate. We need to find something smarter.2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n) = = 2 ^ i * 1 + 2 ^ i * 2 ^ n + 2 ^ i * 2 ^ (2 * n) + … + 2 ^ i * 2 ^ ((k – 1) * N) == 2 ^ i * (2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ ((k – 1) * n)We reduced the problem to calculate sum S = 2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ (X * n).What’s the value of 2 ^ n * S ? It is 2 ^ n + 2 ^ (2 * n) + 2 ^ (3 * n) + … + 2 ^ ((X + 1) * n). And what you get by making 2 ^ n * S – S ? 2 ^ n * S – S = 2 ^ ((X + 1) * n) – 1S * (2 ^ n – 1) = 2 ^ ((X + 1) * n) – 1S = (2 ^ ((X + 1) * n) – 1) / (2 ^ n – 1).We can calculate both 2 ^ i and S with exponentiation by squaring and the problem is done. For \"/\" operator, we can use multiplicative inverse (you can read about that and about Fermat Little's theorem, taking care that 10^9 + 7 is a prime number). The time complexity is O(N * logK). Note: that kind of reduction of powers is called “power series” in math.Alternative solution: For this alternative solution, we don't need to use any special properties of 5. In fact, we can replace 5 by any integer p and still have the same solution. So for now, I shall write p in place of 5.This suggests a dynamic programming solution: denote dp(x,y) be the number of ways of deleting some digits in the first x digits to form a number that has remainder y (modulo p). For simplicity, we accept “empty” plate be a number that is divisible by p. Writing the DP formula is not difficult. We start with dp(0,0) = 1, and suppose we already have the value dp(x,y). We shall use dp(x,y) to update for dp(x + 1,*), which has two possible cases: either keeping the (x + 1)-th digit or by deleting it. I won't go into much detail here. The answer is therefore dp(N,0).Clearly, applying this DP directly would time out. For a better algorithm, we resort on the periodicity of the actual plate. The key idea is that, we imagine each digit in the plate as a linear transformation from (x0, x1, .., x(p – 1)) to (y0, y1, y(p-1)). Obviously, (x0, x1, .., x(p — 1)) corresponds to some dp(i, 0), dp(i, 1) .. dp(i, p — 1) and (y0, y1, y(p-1)) corresponds to some (dp(i + 1, 0)), dp((i + 1), 1), ..., dp(i + 1, p — 1) .So we can write X * M(d) = Y, where X and Y are vectors of length p, and M(d) is the matrix of size p * p representing digit d (note that M(d) is independent from X and Y). By multiplying all |a|.K such matrices together, we obtain a transformation from (1, 0, 0, .., 0) to (T0, T1, .., T(p – 1)) where T0 is actually our answer (including the empty plate).What's the difference? We can group the matrices in groups of length |a|, and lift to the exponent K. That leads to an algorithm with time complexity O(p^3(|a| + log K)), which could be risky. To improve, we should go back to our original DP function and observe that it is actually a linear transformation from (1, 0, 0, .., 0) to (R0, R1, …, R(p – 1)), if we restrict ourselves in the first fragment of length |a|. So instead of multiplying |a| matrices together, we can run DP p times with initial conditions (0, 0, .., 0, 1, 0, .., 0) to obtain the matrix transformation. The overall time complexity becomes O(|a| * p^2 + p^3 log K) . 327D - Башни из кирпичейIn case you want to try some examples on your own, you may play this game, which is the origin of this problem: http://en.wikipedia.org/wiki/Tower_BloxxNow back to the analysis :)The restriction given in the problem poses you to think of building as many Red Towers as possible, and fill the rest with Blue Towers (since there is no profit of letting cells empty, such cells can be filled by Blue Towers). Also, it's quite obvious to see that each connected component (containing empty cells only) is independent from each other, so we shall iterate the component one by one. Denote the current component be S.Lemma 1 is impossible to build S so that it contains all Red Towers only.Proof Suppose there exists such a way. Look up the last cell that is built (denote by x). Clearly x is a Red Tower, so at the moment it is built, x must be adjacent to a cell than contains a Blue Tower. However, it's obvious that there's no such cell (if there is, it must belong to S, which is impossible).As it's impossible to have all Red Towers, it's natural to look up at the next best solution: the one with exactly one Blue Tower, and among them, we need to find the least lexicographic solution. Fortunately, we can prove that such a configuration is always possible. Such proof is quite tricky, indeed:Lemma 2 Pick any cell b in S. It is possible to build a configuration that has all but b be Red Towers, and b is a Blue Tower.Proof Construct a graph whose vertices correspond to the cells of S, and the edges correspond to cells that are adjacent. Since S is connected, it is possible to build a tree that spans to all vertices of S. Pick b as the root and do the following: Build all cells of S blue Move from the leaf to the root. At each cell (except the root), destroy the Blue Tower and rebuild with the Red Tower. To be precise, u can be destroyed (and rebuilt) if all vertices in the subtree rooted at u have already been rebuilt. How can it be the valid solution? Take any vertex u which is about to be rebuilt. Clearly u is not b, and u has its parent to be blue, so the condition for rebuilding can be met. When the building is completed, only b remains intact, while others have been transformed into Red Towers.So we get the following algorithm: do a BFS / DFS search to find connected components. Then, apply Lemma 2 to build a valid configuration.327E - Идем по осиUsually when dealing with complicated problems, a good idea is to solve them for small cases. Let’s try this here.First case: K = 0. The answer is obviously N! (each permutation of p1, p2, …, pn would be good).Next case: K = 1. The answer of this one is N! – |L1|. By L1 I denote all routes for which a prefix sum is equal to first lucky number. Obviously, if from all routes I exclude the wrong ones, I get my answer. If we can find an algorithm to provide |L1| in good time, then problem is solved for K = 1. We can just try all N! permutations. Despite this method is simple, it has complexity O(N!), too much for the constraints. Suppose we’ve founded a set of positions p1, p2, .., pk such as a[p1] + a[p2] + ..+ a[pk] = U1 (first unlucky number). How many permutations can we make? The first k positions need to be p1, p2, .., pk, but in any order. Hence we get k! . The not used positions can also appeared in any order, starting from k + 1 position. As they are n – k, we can permute them in (n – k)! ways. Hence, the answer is k! * (n – k)! Instead of permuting {1, 2, .., n}, now we need to find subsets of it. Hence, the running time becomes O(2^n). This is still too much. Meet in the middle. We make all subsets for first half of positions (from 1 to N / 2) and them for second half (from N / 2 + 1 to N). For each subset we keep 2 information: (sum, cnt) representing that there is a subset of sum “sum” containing “cnt” elements. For each (X, Y) from left we iterate in the right. After choosing one element from the left and one from the right we just “split” them. To split 2 states (A, B) and (C, D), the new state becomes (A + C, B + D). But we know that A + C = U1. This comes us to the idea: for each (X, Y) in the left, I check (U1 – X, 1), (U1 – X, 2), … , (U1 – X, K) from the right. For each of them, the answer would be (Y + K)! * (N – Y – K)! . I can store (using any data structure that allows this operations, I suggest a hash) how(C, D) = how many times does state (C, D) appear in the right. So, for a state (A, B) the answer becomes a sum of how(U1 — A, K) * (B + K)! * (N — B — K)!. Doing the sum for all states (A, B), we get our answer. The complexity of this method is O(2 ^ (N / 2) * N). Final Case: K = 2 The whole \"meet in the middle\" explanation worthed. We will do something very similar to solve this case. Suppose U1 and U2 are the unlucky numbers. Without loosing the generality, let's assume U1 <= U2.Following \"Principle of inclusion and exclusion\" paradigm (google about it if you never heard before) we can write our solution as N! — |L1| — |L2| + |intersection between L1 and L2|. Again, by L1,2 I denote the number of routes which have a prefix sum equal to number U1,2. The |X| is again the cardinal of this set. Basically we can calculate |X| as for K = 1. The only problem remained is calculating |intersection between L1 and L2|.The |intersection between L1 and L2| is the number of permutations which have a prefix sum equal to U1 and a prefix sum equal to U2. Since U1 <= U2, we can split a permutation from this set in 3 parts: 1/ p1, p2, ...pk such as a[p1] + a[p2] + ... + a[pk] = U1.2/ pk+1, pk+2, ..., pm such as a[pk+1], a[pk+2], ..., a[pm] = U2 — U1. Note that a[p1] + a[p2] + ... + a[pm] = U2. 3/ The rest of elements until position n.By a perfectly identical logic from K = 1 case, the number of permutations given those p[] would be k! * (m — k)! * (n — m)!.So the problem reduces to: find all indices set p1, p2, ... and q1, q2, .. such as a[p1] + a[p2] + ... + a[pn1] = U1 and a[q1] + a[q2] + ... + a[qn2] = U2 — U1. Then, we can apply formula using n1 and n2 described above. The first idea would be O(3 ^ N) — for each position from {1, 2, .., n} atribute all combinations of {0, 1, 2}. 0 means that position i is 1/, 1 means that position i is in 2/ and 2 means that position i is in 3/ . This would time out.Happily, we can improve it with meet in the middle principle. The solution is very similar with K = 1 case. I won't fully explain it here, if you understood principle from K = 1 this shouldn't be a problem. The base idea is to keep (S1, S2, cnt1, cnt2) for both \"left\" and \"right\". (S1, S2, cnt1, cnt2) represents a subset which has sum of elements from 1/ equal to S1, sum of elements from 2/ equal to S2, in 1/ we have cnt1 element and in 2/ we get cnt2 elements. For a (S1, S2, cnt1, cnt2) state from \"left\" we are looking in the right for something like (U1 — S1, U2 — U1 — S2, i, j). We get O(3 ^ (N / 2) * N ^ 2) complexity.Unexpected solution During the round, we saw a lot of O(2 ^ N * N) solutions passing. This was totally out of expectations. I believe if would make tests stronger, this solution won't pass and round would be more challenging. That's it, nothing is perfect. As requested, I'll explain that solution here. Before explaining the solution, I assume you have some experience with \"bitmask dp\" technique. If you don't, please read before: http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=bitManipulationhttp://codeforces.com/blog/entry/337In this problem we'll assume that a is 0-based. For a mask, consider bits from right to left, noting them bit 0, bit 1 and so on. Bit i is 1 if and only if a[i] is in the subset which is in a bijective replation with the mask. For example, for mask 100011101 the subset is {a0, a2, a3, a4, a8}. I'll call from now on the subset \"subset of mask\". Also, the sum of all elements in a subset will be called \"sum of mask\" (i.e. a0 + a2 + a3 + a4 + a8). We'll explain the solution based by watashi's submission. 4017915First step of the algorithm is to calculate sum of each mask. Let dp[i] the sum of mask i. Remove exactly one element from the subset of mask. Suppose the new mask obtained is k and removed element is j. Then, dp[i] = dp[k] + a[j]. dp[k] is always calculated before dp[i] (to proof, write both k and i in base 10. k is always smaller than i). Having j an element from subset of mask i, we can compute mask k by doing i ^ (1 << j). Bit j is 1, and by xor-ing it with another 1 bit, it becomes 0. Other bits are unchanged by being xor-ed by 0. This method works very fast to compute sum of each mask.From now on, let's denote a new array dp2[i] = how many good routes can I obtain with elements from subset of mask i. Watashi uses same dp[] array, but for making it clear, in editorial I'll use 2 separate arrays. Suppose that CNT(i) is number of elements from subset of mask i. We are interested in how many ways we can fill positions {1, 2, ..., CNT(i)} with elements from subset of mask i such as each prefix sum is different by each unlucky number. Next step of the algorithm is to see which sum of masks are equal to one of unlucky numbers. We mark them as \"-1\" in dp2[]. Suppose we founded a subset {a1, a2, ..., ax} for which a1 + a2 + ... + ax = one of unlucky numbers. Then, none permutation of {a1, a2, ..., ax} is allowed to appear on first x positions. When we arrive to a \"-1\" state, we know that the number of good routes for its subset of mask is 0.Now, finally the main dp recurrence. If for the current mask i, dp2[i] = -1, then dp2[i] = 0 and continue (we discard the state as explained above). Otherwise, we know that there could exist at least one way to complete positions {1, 2, ... CNT(i)} with elements of subset of mask i. But how to calculate it? We fix the last element (the element from the position CNT(I)) with some j from subset of mask i. The problem reduces now with how many good routes can I fill in positions {1, 2, ..., CNT(i) — 1} with elements from subset of mask i, from which we erased element j. With same explanation of sum of mask calculations, this is already calculated in dp2[i ^ (1 << j)]. The result is dp2[(1 << N) — 1] (number of good routes containing all positions). Editorial has been made by me and ll931110.The authors of the problems: Div.2 A & Div.2 B — meDiv.2 C & Div.2 D & Div.2 E — ll931110",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8274",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 327\\s*C"
          },
          "content_length": 20131
        },
        {
          "title": "2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest - Codeforces",
          "content": "Welcome to the contest of Saratov State U on Petrozavodsk Winter Training Camp 2012-2013. This contest was prepared with diligence and love by jury team of ACM-ICPC NEERC Subregional (Saratov) Contest. Here is the complete list of writers: MikeMirzayanov Nerevar RAD e-maxx natalia NALP Dmitry Klenov Dmitry Mescheryakov Dmitry Stepanenko Thanks to all of them!All the authors invite you to take part in the contest virtually in Gym, if: You didn't take part in it previously You (or your team) is high skilled that you will take part (or took part) on ACM-ICPC World Finals or other high-level competitions. The problemset seems to be hard for not experienced participants. Hope, you will enjoy the contest!Contest link: 2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6656",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 1",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 2",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 1",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 2",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 3",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 4",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 5",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 6",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 7",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 8",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string a = inf.readToken(\"[0-9]{1,100000}\", \"a\");\n    inf.readEoln();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string a = inf.readToken(\"[0-9]{1,100000}\", \"a\");\n    inf.readEoln();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string a = inf.readToken(\"[0-9]{1,100000}\", \"a\");\n    inf.readEoln();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // length of string a\n    int k = opt<int>(\"k\"); // number of times to concatenate a\n    string a_type = opt<string>(\"a_type\", \"random\"); // type of a to generate\n\n    string a(n, '0');\n\n    if (a_type == \"all_zero\") {\n        // a consists of all zeros\n        fill(a.begin(), a.end(), '0');\n    } else if (a_type == \"all_five\") {\n        // a consists of all fives\n        fill(a.begin(), a.end(), '5');\n    } else if (a_type == \"ends_with_zero\") {\n        // a ends with zero\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next('0', '9');\n        a[n - 1] = '0';\n    } else if (a_type == \"ends_with_five\") {\n        // a ends with five\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next('0', '9');\n        a[n - 1] = '5';\n    } else if (a_type == \"no_zero_five\") {\n        // a contains digits but no zeros or fives\n        for (int i = 0; i < n; ++i) {\n            char digit;\n            do {\n                digit = rnd.next('1', '9');\n            } while (digit == '5');\n            a[i] = digit;\n        }\n    } else if (a_type == \"starts_with_zero\") {\n        // a starts with zero\n        a[0] = '0';\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next('0', '9');\n    } else if (a_type == \"only_zero_five\") {\n        // a consists of only zeros and fives\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) == 0 ? '0' : '5';\n    } else if (a_type == \"random\") {\n        // a is a random string of digits\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next('0', '9');\n    } else {\n        // default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next('0', '9');\n    }\n\n    // Output the string a and integer k\n    cout << a << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // length of string a\n    int k = opt<int>(\"k\"); // number of times to concatenate a\n    string a_type = opt<string>(\"a_type\", \"random\"); // type of a to generate\n\n    string a(n, '0');\n\n    if (a_type == \"all_zero\") {\n        // a consists of all zeros\n        fill(a.begin(), a.end(), '0');\n    } else if (a_type == \"all_five\") {\n        // a consists of all fives\n        fill(a.begin(), a.end(), '5');\n    } else if (a_type == \"ends_with_zero\") {\n        // a ends with zero\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next('0', '9');\n        a[n - 1] = '0';\n    } else if (a_type == \"ends_with_five\") {\n        // a ends with five\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next('0', '9');\n        a[n - 1] = '5';\n    } else if (a_type == \"no_zero_five\") {\n        // a contains digits but no zeros or fives\n        for (int i = 0; i < n; ++i) {\n            char digit;\n            do {\n                digit = rnd.next('1', '9');\n            } while (digit == '5');\n            a[i] = digit;\n        }\n    } else if (a_type == \"starts_with_zero\") {\n        // a starts with zero\n        a[0] = '0';\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next('0', '9');\n    } else if (a_type == \"only_zero_five\") {\n        // a consists of only zeros and fives\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) == 0 ? '0' : '5';\n    } else if (a_type == \"random\") {\n        // a is a random string of digits\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next('0', '9');\n    } else {\n        // default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next('0', '9');\n    }\n\n    // Output the string a and integer k\n    cout << a << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -a_type random\n./gen -n 1 -k 1 -a_type all_zero\n./gen -n 1 -k 1 -a_type all_five\n./gen -n 1 -k 1000000000 -a_type all_zero\n./gen -n 1 -k 1000000000 -a_type all_five\n./gen -n 1 -k 1000000000 -a_type random\n\n./gen -n 10 -k 10 -a_type random\n\n./gen -n 100 -k 1000 -a_type random\n./gen -n 100 -k 1000 -a_type ends_with_zero\n./gen -n 100 -k 1000 -a_type ends_with_five\n./gen -n 100 -k 1000 -a_type no_zero_five\n./gen -n 100 -k 1000 -a_type only_zero_five\n\n./gen -n 1000 -k 5000 -a_type starts_with_zero\n./gen -n 1000 -k 5000 -a_type all_zero\n./gen -n 1000 -k 5000 -a_type all_five\n\n./gen -n 5000 -k 1000 -a_type random\n\n./gen -n 99999 -k 999999999 -a_type random\n./gen -n 99999 -k 999999999 -a_type no_zero_five\n\n./gen -n 100000 -k 1000000000 -a_type random\n./gen -n 100000 -k 1000000000 -a_type only_zero_five\n\n./gen -n 100000 -k 1 -a_type all_zero\n./gen -n 100000 -k 1 -a_type all_five\n./gen -n 100000 -k 1 -a_type random\n./gen -n 100000 -k 1 -a_type ends_with_zero\n./gen -n 100000 -k 1 -a_type ends_with_five\n\n./gen -n 50000 -k 200000000 -a_type random\n./gen -n 50000 -k 200000000 -a_type starts_with_zero\n./gen -n 50000 -k 200000000 -a_type no_zero_five\n./gen -n 50000 -k 200000000 -a_type only_zero_five\n\n./gen -n 12345 -k 67890 -a_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:37.401344",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "327/D",
      "title": "D. Block Tower",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 500). Each of the next n lines contains m characters, describing the grid. The j-th character in the i-th line is '.' if you're allowed to build at the cell with coordinates (i, j) a tower (empty cell) or '#' if there is a big hole there.",
      "output_spec": "OutputPrint an integer k in the first line (0 ≤ k ≤ 106) — the number of operations Iahub should perform to obtain optimal result.Each of the following k lines must contain a single operation in the following format:  «B x y» (1 ≤ x ≤ n, 1 ≤ y ≤ m) — building a blue tower at the cell (x, y);  «R x y» (1 ≤ x ≤ n, 1 ≤ y ≤ m) — building a red tower at the cell (x, y);  «D x y» (1 ≤ x ≤ n, 1 ≤ y ≤ m) — destroying a tower at the cell (x, y). If there are multiple solutions you can output any of them. Note, that you shouldn't minimize the number of operations.",
      "sample_tests": "ExamplesInputCopy2 3..#.#.OutputCopy4B 1 1R 1 2R 2 1B 2 3InputCopy1 3...OutputCopy5B 1 1B 1 2R 1 3D 1 2R 1 2",
      "description": "D. Block Tower\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 500). Each of the next n lines contains m characters, describing the grid. The j-th character in the i-th line is '.' if you're allowed to build at the cell with coordinates (i, j) a tower (empty cell) or '#' if there is a big hole there.\n\nOutputPrint an integer k in the first line (0 ≤ k ≤ 106) — the number of operations Iahub should perform to obtain optimal result.Each of the following k lines must contain a single operation in the following format:  «B x y» (1 ≤ x ≤ n, 1 ≤ y ≤ m) — building a blue tower at the cell (x, y);  «R x y» (1 ≤ x ≤ n, 1 ≤ y ≤ m) — building a red tower at the cell (x, y);  «D x y» (1 ≤ x ≤ n, 1 ≤ y ≤ m) — destroying a tower at the cell (x, y). If there are multiple solutions you can output any of them. Note, that you shouldn't minimize the number of operations.\n\nInputCopy2 3..#.#.OutputCopy4B 1 1R 1 2R 2 1B 2 3InputCopy1 3...OutputCopy5B 1 1B 1 2R 1 3D 1 2R 1 2\n\nInputCopy2 3..#.#.\n\nOutputCopy4B 1 1R 1 2R 2 1B 2 3\n\nInputCopy1 3...\n\nOutputCopy5B 1 1B 1 2R 1 3D 1 2R 1 2",
      "solutions": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces",
          "content": "Welcome to another Codeforces Round!Please note that the time of round #191 was changed. Contest will start at Thursday 12:30 UTC.My name is Linh (ll931110). I'm from Vietnam, and I'm glad to present to you my first Codeforces round. It is for Div 2 only; however, I welcome participants from Div. 1 to participate and enjoy challenging problems. I hope this would be a pleasant gift for those who are going to IOI 2013 (and participants from World Finals), which will take place in just a couple of days. This round is prepared by me and fchirica (from Romania). Also, I would like to thank the Codeforces team who puts efforts on making Codeforces and Polygon possible.Happy solving!UPD1: The score of problems in this round will be dynamic. The problems will be sorted in increasing difficulty order, at least in our perspective.UPD2: The contest is over! Congratulations for everybody, especially for those who solved E. You proved to be smarter than I am (your solutions were totally unexpected to us). Thank Gerald, Aksenov239 and Delinur for helping us on preparing the round!Div. 2 winners: SillyHook02 Tsukiko Quit_Quickly Zhengxu sevenzplus Those are five people who nail all problems!Unofficial winners: Kissshot R_R_ xchernoff wakaka phtniit The editorial will be completed soon after revising and adding possible alternative solutions. You are welcome to post your answers in comments.Thank you and see you in the next round!UPD3: Editorial is now available. Remind that it is not the final version, as we are writing possible alternative solutions for problems. Stay tuned!UPD4: Editorial is now completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1620
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces",
          "content": "327A - Игра с переворачиваниемI’ll present here the O(N ^ 3) algorithm, which is enough to solve this task. Then, for those interested, I’ll show a method to achieve O(N) complexity.O(N ^ 3) method: The first thing to observe is that constrains are slow enough to allow a brute force algorithm. Using brute force, I can calculate for each possible single move the number of 1s resulting after applying it and take maximum. For consider each move, I can just generate with 2 FOR loops all indices i, j such as i <= j. So far we have O(N ^ 2) complexity. Suppose I have now 2 fixed vaIues i and j. I need to calculate variable cnt (initially 0) representing the number of ones if I do the move. For do this, I choose another indice k to go in a[] array (taking O(N) time, making the total of O(N ^ 3) complexity). We have two cases: either k is in range [i, j] (this means i <= k AND k <= j) or not (if that condition is not met). If it’s in range, then it gets flipped, so we add to count variable 1 – a[k] (observe that it makes 0 to 1 and 1 to 0). If it’s not in range, we simply add to cnt variable a[k]. The answer is maximum of all cnt obtained.O(N) method: For achieve this complexity, we need to make an observation. Suppose I flip an interval (it does not matter what interval, it can be any interval). Also suppose that S is the number of ones before flipiing it. What happens? Every time I flip a 0 value, S increases by 1 (I get a new 1 value). Every time I flip a 1 value, S decreases by 1 (I loose a 1 value). What would be the “gain” from a flip? I consider winning “+1” when I get a 0 value and “-1” when I get a 1 value. The “gain” would be simply a sum of +1 and -1. This gives us idea to make another vector b[]. B[i] is 1 if A[i] is 0 and B[i] is -1 if A[i] is 1. We want to maximize S + gain_after_one_move sum. As S is constant, I want to maximize gain_after_one_move. In other words, I want to find a subsequence in b[] which gives the maximal sum. If I flip it, I get maximal number of 1s too. This can be founded trivially in O(N ^ 2). How to get O(N)? A relative experienced programmer in dynamic programming will immediately recognize it as a classical problem “subsequence of maximal sum”. If you never heard about it, come back to this approach after you learn it. 327B - Голодная последовательностьWe’ll present two different solutions for this task.Solution 1. What if we solve a more general task? What if each hungry number from the solution isn’t allowed to be divided by any number smaller than it (except 1, which is divides every natural number). If this more general condition would be met, then the “hungry” condition would be met, too (as a[i] won’t be divided by a number smaller than it (except 1), it won’t be divided by a[j], too, with j < i, assuming that a[j] is different from 1). Now how to find numbers for this more general condition? We can rephrase it as: each number from more general condition has 2 divisors: 1 and itself. So if we print N numbers with 2 divisors in increasing order, that would be a good solution. As you probably know, numbers with 2 divisors are called “prime numbers”. The task reduces to finding first N prime numbers. This can be done via brute force, or via Sieve of Eratosthenes (however, not necessarily to get an AC solution).Solution 2. Suppose we are given the number N. We can observe that for big enough consecutive numbers, the array is always hungry. For example, we can print 3 * N + 0, 3 * N + 1, 3 * N + 2, …, 3 * N + (N – 1). Magic, isn’t it? Why does it work now? Pick an arbitrary a[i]. The solution would be bad if one of numbers 2 * a[i], 3 * a[i], 4 * a[i] and so on would be in a[] array. However, it will never happen. The smallest multiple from that ones will be 2 * 3 * N = 6 * N. There is not possible to obtain a smallest multiple than that one. On the other hand, the biggest number from a[] array would be 3 * N + N – 1 = 4 * N — 1. Since smallest multiple is bigger than biggest term of the array, it (and of course other multiples bigger than it) will never exist in a[] array. So the above solution is correct also. 327C - Волшебная пятеркаProperty: A number is divisible by 5 if and only if its last digit is either 0 or 5.A first solution: Suppose you’re given a plate S, not so big, so we can iterate all its elements. Can we get the answer? I build a new array sol[]. In explanation, both S and sol will be 1-based. Denote N = size of S. Also, denote sol[i] = the number of ways to delete digits from plate S such as we obtain a magic number which has the last digit on position i. The answer is sol[1] + sol[2] + … + sol[N]. Let’s focus now on calculating sol[i]. If S[i] (digit of the plate corresponding to ith position) is different than 0 or 5, then sol[i] is 0 (see “property”). Otherwise we have to ask ourself: in how many ways I can delete digits in “left” and in “right” of position i. In the “right”, we have only one way: delete all digits (if one digit from right still stands, then the number isn’t ending at position i). Now in the “left”: there are digits on positions 1, 2, …, i – 1. We can either delete a digit or keep it – anyhow he’d do we still get a magic number. So on position 1 I have 2 ways (delete or keep it), on position 2 I have also 2 ways, …, on position i – 1 I have also 2 ways. Next, we apply what mathematics call “rule of product” and we get 2 * 2 * 2 … * 2 (i – 1 times) = 2 ^ (i – 1). Applying “rule of product” on both “left” and “right” I get 2 ^ (i – 1) * 1 = 2 ^ (i – 1). To sum it up: If S[i] is 0 or 5 we add to the answer 2 ^ (i – 1). Otherwise, we add nothing. The only problem remained for this simple version is how we calculate A ^ B modulo one number. This is a well known problem as well, called “Exponentiation by squaring”. Coming back to our problem: So what’s different in our problem? It’s the fact that we can’t iterate all elements of plate. However, we can use “concatenation” property. We know that if an element is a position i in the first copy, it will also be on positions i + n, i + 2 * n, i + 3 * n, …, i + (k – 1) * n (we don’t call here about trivial case when k = 1). What if iterate only one copy and calculate for all K copies. If in the first copy, at the position i is either 0 or 5, we have to calculate the sum 2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n). By now on, in calculus I'll denote i as i — 1 (it's a simple mathematical substitution). A first idea would be just to iterate each term and calculate it with exponentiation by squaring. However, it takes in the worst case the same complexity as iterating all plate. We need to find something smarter.2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n) = = 2 ^ i * 1 + 2 ^ i * 2 ^ n + 2 ^ i * 2 ^ (2 * n) + … + 2 ^ i * 2 ^ ((k – 1) * N) == 2 ^ i * (2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ ((k – 1) * n)We reduced the problem to calculate sum S = 2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ (X * n).What’s the value of 2 ^ n * S ? It is 2 ^ n + 2 ^ (2 * n) + 2 ^ (3 * n) + … + 2 ^ ((X + 1) * n). And what you get by making 2 ^ n * S – S ? 2 ^ n * S – S = 2 ^ ((X + 1) * n) – 1S * (2 ^ n – 1) = 2 ^ ((X + 1) * n) – 1S = (2 ^ ((X + 1) * n) – 1) / (2 ^ n – 1).We can calculate both 2 ^ i and S with exponentiation by squaring and the problem is done. For \"/\" operator, we can use multiplicative inverse (you can read about that and about Fermat Little's theorem, taking care that 10^9 + 7 is a prime number). The time complexity is O(N * logK). Note: that kind of reduction of powers is called “power series” in math.Alternative solution: For this alternative solution, we don't need to use any special properties of 5. In fact, we can replace 5 by any integer p and still have the same solution. So for now, I shall write p in place of 5.This suggests a dynamic programming solution: denote dp(x,y) be the number of ways of deleting some digits in the first x digits to form a number that has remainder y (modulo p). For simplicity, we accept “empty” plate be a number that is divisible by p. Writing the DP formula is not difficult. We start with dp(0,0) = 1, and suppose we already have the value dp(x,y). We shall use dp(x,y) to update for dp(x + 1,*), which has two possible cases: either keeping the (x + 1)-th digit or by deleting it. I won't go into much detail here. The answer is therefore dp(N,0).Clearly, applying this DP directly would time out. For a better algorithm, we resort on the periodicity of the actual plate. The key idea is that, we imagine each digit in the plate as a linear transformation from (x0, x1, .., x(p – 1)) to (y0, y1, y(p-1)). Obviously, (x0, x1, .., x(p — 1)) corresponds to some dp(i, 0), dp(i, 1) .. dp(i, p — 1) and (y0, y1, y(p-1)) corresponds to some (dp(i + 1, 0)), dp((i + 1), 1), ..., dp(i + 1, p — 1) .So we can write X * M(d) = Y, where X and Y are vectors of length p, and M(d) is the matrix of size p * p representing digit d (note that M(d) is independent from X and Y). By multiplying all |a|.K such matrices together, we obtain a transformation from (1, 0, 0, .., 0) to (T0, T1, .., T(p – 1)) where T0 is actually our answer (including the empty plate).What's the difference? We can group the matrices in groups of length |a|, and lift to the exponent K. That leads to an algorithm with time complexity O(p^3(|a| + log K)), which could be risky. To improve, we should go back to our original DP function and observe that it is actually a linear transformation from (1, 0, 0, .., 0) to (R0, R1, …, R(p – 1)), if we restrict ourselves in the first fragment of length |a|. So instead of multiplying |a| matrices together, we can run DP p times with initial conditions (0, 0, .., 0, 1, 0, .., 0) to obtain the matrix transformation. The overall time complexity becomes O(|a| * p^2 + p^3 log K) . 327D - Башни из кирпичейIn case you want to try some examples on your own, you may play this game, which is the origin of this problem: http://en.wikipedia.org/wiki/Tower_BloxxNow back to the analysis :)The restriction given in the problem poses you to think of building as many Red Towers as possible, and fill the rest with Blue Towers (since there is no profit of letting cells empty, such cells can be filled by Blue Towers). Also, it's quite obvious to see that each connected component (containing empty cells only) is independent from each other, so we shall iterate the component one by one. Denote the current component be S.Lemma 1 is impossible to build S so that it contains all Red Towers only.Proof Suppose there exists such a way. Look up the last cell that is built (denote by x). Clearly x is a Red Tower, so at the moment it is built, x must be adjacent to a cell than contains a Blue Tower. However, it's obvious that there's no such cell (if there is, it must belong to S, which is impossible).As it's impossible to have all Red Towers, it's natural to look up at the next best solution: the one with exactly one Blue Tower, and among them, we need to find the least lexicographic solution. Fortunately, we can prove that such a configuration is always possible. Such proof is quite tricky, indeed:Lemma 2 Pick any cell b in S. It is possible to build a configuration that has all but b be Red Towers, and b is a Blue Tower.Proof Construct a graph whose vertices correspond to the cells of S, and the edges correspond to cells that are adjacent. Since S is connected, it is possible to build a tree that spans to all vertices of S. Pick b as the root and do the following: Build all cells of S blue Move from the leaf to the root. At each cell (except the root), destroy the Blue Tower and rebuild with the Red Tower. To be precise, u can be destroyed (and rebuilt) if all vertices in the subtree rooted at u have already been rebuilt. How can it be the valid solution? Take any vertex u which is about to be rebuilt. Clearly u is not b, and u has its parent to be blue, so the condition for rebuilding can be met. When the building is completed, only b remains intact, while others have been transformed into Red Towers.So we get the following algorithm: do a BFS / DFS search to find connected components. Then, apply Lemma 2 to build a valid configuration.327E - Идем по осиUsually when dealing with complicated problems, a good idea is to solve them for small cases. Let’s try this here.First case: K = 0. The answer is obviously N! (each permutation of p1, p2, …, pn would be good).Next case: K = 1. The answer of this one is N! – |L1|. By L1 I denote all routes for which a prefix sum is equal to first lucky number. Obviously, if from all routes I exclude the wrong ones, I get my answer. If we can find an algorithm to provide |L1| in good time, then problem is solved for K = 1. We can just try all N! permutations. Despite this method is simple, it has complexity O(N!), too much for the constraints. Suppose we’ve founded a set of positions p1, p2, .., pk such as a[p1] + a[p2] + ..+ a[pk] = U1 (first unlucky number). How many permutations can we make? The first k positions need to be p1, p2, .., pk, but in any order. Hence we get k! . The not used positions can also appeared in any order, starting from k + 1 position. As they are n – k, we can permute them in (n – k)! ways. Hence, the answer is k! * (n – k)! Instead of permuting {1, 2, .., n}, now we need to find subsets of it. Hence, the running time becomes O(2^n). This is still too much. Meet in the middle. We make all subsets for first half of positions (from 1 to N / 2) and them for second half (from N / 2 + 1 to N). For each subset we keep 2 information: (sum, cnt) representing that there is a subset of sum “sum” containing “cnt” elements. For each (X, Y) from left we iterate in the right. After choosing one element from the left and one from the right we just “split” them. To split 2 states (A, B) and (C, D), the new state becomes (A + C, B + D). But we know that A + C = U1. This comes us to the idea: for each (X, Y) in the left, I check (U1 – X, 1), (U1 – X, 2), … , (U1 – X, K) from the right. For each of them, the answer would be (Y + K)! * (N – Y – K)! . I can store (using any data structure that allows this operations, I suggest a hash) how(C, D) = how many times does state (C, D) appear in the right. So, for a state (A, B) the answer becomes a sum of how(U1 — A, K) * (B + K)! * (N — B — K)!. Doing the sum for all states (A, B), we get our answer. The complexity of this method is O(2 ^ (N / 2) * N). Final Case: K = 2 The whole \"meet in the middle\" explanation worthed. We will do something very similar to solve this case. Suppose U1 and U2 are the unlucky numbers. Without loosing the generality, let's assume U1 <= U2.Following \"Principle of inclusion and exclusion\" paradigm (google about it if you never heard before) we can write our solution as N! — |L1| — |L2| + |intersection between L1 and L2|. Again, by L1,2 I denote the number of routes which have a prefix sum equal to number U1,2. The |X| is again the cardinal of this set. Basically we can calculate |X| as for K = 1. The only problem remained is calculating |intersection between L1 and L2|.The |intersection between L1 and L2| is the number of permutations which have a prefix sum equal to U1 and a prefix sum equal to U2. Since U1 <= U2, we can split a permutation from this set in 3 parts: 1/ p1, p2, ...pk such as a[p1] + a[p2] + ... + a[pk] = U1.2/ pk+1, pk+2, ..., pm such as a[pk+1], a[pk+2], ..., a[pm] = U2 — U1. Note that a[p1] + a[p2] + ... + a[pm] = U2. 3/ The rest of elements until position n.By a perfectly identical logic from K = 1 case, the number of permutations given those p[] would be k! * (m — k)! * (n — m)!.So the problem reduces to: find all indices set p1, p2, ... and q1, q2, .. such as a[p1] + a[p2] + ... + a[pn1] = U1 and a[q1] + a[q2] + ... + a[qn2] = U2 — U1. Then, we can apply formula using n1 and n2 described above. The first idea would be O(3 ^ N) — for each position from {1, 2, .., n} atribute all combinations of {0, 1, 2}. 0 means that position i is 1/, 1 means that position i is in 2/ and 2 means that position i is in 3/ . This would time out.Happily, we can improve it with meet in the middle principle. The solution is very similar with K = 1 case. I won't fully explain it here, if you understood principle from K = 1 this shouldn't be a problem. The base idea is to keep (S1, S2, cnt1, cnt2) for both \"left\" and \"right\". (S1, S2, cnt1, cnt2) represents a subset which has sum of elements from 1/ equal to S1, sum of elements from 2/ equal to S2, in 1/ we have cnt1 element and in 2/ we get cnt2 elements. For a (S1, S2, cnt1, cnt2) state from \"left\" we are looking in the right for something like (U1 — S1, U2 — U1 — S2, i, j). We get O(3 ^ (N / 2) * N ^ 2) complexity.Unexpected solution During the round, we saw a lot of O(2 ^ N * N) solutions passing. This was totally out of expectations. I believe if would make tests stronger, this solution won't pass and round would be more challenging. That's it, nothing is perfect. As requested, I'll explain that solution here. Before explaining the solution, I assume you have some experience with \"bitmask dp\" technique. If you don't, please read before: http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=bitManipulationhttp://codeforces.com/blog/entry/337In this problem we'll assume that a is 0-based. For a mask, consider bits from right to left, noting them bit 0, bit 1 and so on. Bit i is 1 if and only if a[i] is in the subset which is in a bijective replation with the mask. For example, for mask 100011101 the subset is {a0, a2, a3, a4, a8}. I'll call from now on the subset \"subset of mask\". Also, the sum of all elements in a subset will be called \"sum of mask\" (i.e. a0 + a2 + a3 + a4 + a8). We'll explain the solution based by watashi's submission. 4017915First step of the algorithm is to calculate sum of each mask. Let dp[i] the sum of mask i. Remove exactly one element from the subset of mask. Suppose the new mask obtained is k and removed element is j. Then, dp[i] = dp[k] + a[j]. dp[k] is always calculated before dp[i] (to proof, write both k and i in base 10. k is always smaller than i). Having j an element from subset of mask i, we can compute mask k by doing i ^ (1 << j). Bit j is 1, and by xor-ing it with another 1 bit, it becomes 0. Other bits are unchanged by being xor-ed by 0. This method works very fast to compute sum of each mask.From now on, let's denote a new array dp2[i] = how many good routes can I obtain with elements from subset of mask i. Watashi uses same dp[] array, but for making it clear, in editorial I'll use 2 separate arrays. Suppose that CNT(i) is number of elements from subset of mask i. We are interested in how many ways we can fill positions {1, 2, ..., CNT(i)} with elements from subset of mask i such as each prefix sum is different by each unlucky number. Next step of the algorithm is to see which sum of masks are equal to one of unlucky numbers. We mark them as \"-1\" in dp2[]. Suppose we founded a subset {a1, a2, ..., ax} for which a1 + a2 + ... + ax = one of unlucky numbers. Then, none permutation of {a1, a2, ..., ax} is allowed to appear on first x positions. When we arrive to a \"-1\" state, we know that the number of good routes for its subset of mask is 0.Now, finally the main dp recurrence. If for the current mask i, dp2[i] = -1, then dp2[i] = 0 and continue (we discard the state as explained above). Otherwise, we know that there could exist at least one way to complete positions {1, 2, ... CNT(i)} with elements of subset of mask i. But how to calculate it? We fix the last element (the element from the position CNT(I)) with some j from subset of mask i. The problem reduces now with how many good routes can I fill in positions {1, 2, ..., CNT(i) — 1} with elements from subset of mask i, from which we erased element j. With same explanation of sum of mask calculations, this is already calculated in dp2[i ^ (1 << j)]. The result is dp2[(1 << N) — 1] (number of good routes containing all positions). Editorial has been made by me and ll931110.The authors of the problems: Div.2 A & Div.2 B — meDiv.2 C & Div.2 D & Div.2 E — ll931110",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8274",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 327\\s*D"
          },
          "content_length": 20131
        },
        {
          "title": "2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest - Codeforces",
          "content": "Welcome to the contest of Saratov State U on Petrozavodsk Winter Training Camp 2012-2013. This contest was prepared with diligence and love by jury team of ACM-ICPC NEERC Subregional (Saratov) Contest. Here is the complete list of writers: MikeMirzayanov Nerevar RAD e-maxx natalia NALP Dmitry Klenov Dmitry Mescheryakov Dmitry Stepanenko Thanks to all of them!All the authors invite you to take part in the contest virtually in Gym, if: You didn't take part in it previously You (or your team) is high skilled that you will take part (or took part) on ACM-ICPC World Finals or other high-level competitions. The problemset seems to be hard for not experienced participants. Hope, you will enjoy the contest!Contest link: 2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6656",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 1",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 2",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 1",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 2",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 3",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 4",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 5",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 6",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 7",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 8",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must be of length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '#', \"Invalid character '%c' at position (%d,%d)\", s[j], i + 1, j +1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must be of length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '#', \"Invalid character '%c' at position (%d,%d)\", s[j], i + 1, j +1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must be of length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '#', \"Invalid character '%c' at position (%d,%d)\", s[j], i + 1, j +1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<string> grid;\n\nint readAns(InStream& stream) {\n    // Initialize the grid state\n    vector<string> currentGrid = grid; // Starting from initial grid\n    int totalPopulation = 0;\n\n    // Read the number of operations\n    int k = stream.readInt(0, 1000000, \"number of operations\"); // 0 ≤ k ≤ 1e6\n\n    for (int op_num = 1; op_num <= k; ++op_num) {\n        string operation = stream.readToken(); // Read operation type\n\n        int x = stream.readInt(1, n, \"x coordinate\"); // 1 ≤ x ≤ n\n        int y = stream.readInt(1, m, \"y coordinate\"); // 1 ≤ y ≤ m\n\n        int i = x - 1; // zero-based index\n        int j = y - 1;\n\n        if (operation == \"B\") {\n            // Build blue tower\n            if (currentGrid[i][j] == '#') {\n                stream.quitf(_wa, \"Operation %d: Cannot build on hole cell at (%d, %d)\", op_num, x, y);\n            } else if (currentGrid[i][j] != '.') {\n                stream.quitf(_wa, \"Operation %d: Cell (%d, %d) is not empty\", op_num, x, y);\n            } else {\n                currentGrid[i][j] = 'B';\n                totalPopulation += 100;\n            }\n        } else if (operation == \"R\") {\n            // Build red tower\n            if (currentGrid[i][j] == '#') {\n                stream.quitf(_wa, \"Operation %d: Cannot build on hole cell at (%d, %d)\", op_num, x, y);\n            } else if (currentGrid[i][j] != '.') {\n                stream.quitf(_wa, \"Operation %d: Cell (%d, %d) is not empty\", op_num, x, y);\n            } else {\n                bool hasBlueNeighbor = false;\n                int dx[] = {-1, 0, 1, 0};\n                int dy[] = {0, -1, 0, 1};\n                for (int d = 0; d < 4; ++d) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                        if (currentGrid[ni][nj] == 'B') {\n                            hasBlueNeighbor = true;\n                            break;\n                        }\n                    }\n                }\n                if (!hasBlueNeighbor) {\n                    stream.quitf(_wa, \"Operation %d: Cannot build red tower at (%d, %d) without blue neighbor\", op_num, x, y);\n                } else {\n                    currentGrid[i][j] = 'R';\n                    totalPopulation += 200;\n                }\n            }\n        } else if (operation == \"D\") {\n            // Destroy tower\n            char towerType = currentGrid[i][j];\n            if (towerType != 'B' && towerType != 'R') {\n                stream.quitf(_wa, \"Operation %d: No tower to destroy at (%d, %d)\", op_num, x, y);\n            } else {\n                if (towerType == 'B') {\n                    totalPopulation -= 100;\n                } else if (towerType == 'R') {\n                    totalPopulation -= 200;\n                }\n                currentGrid[i][j] = '.';\n            }\n        } else {\n            stream.quitf(_wa, \"Operation %d: Invalid operation '%s'\", op_num, operation.c_str());\n        }\n    }\n    return totalPopulation;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    m = inf.readInt();\n    grid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readToken();\n    }\n\n    int jans = readAns(ans);\n    int pans = readAns(ouf);\n\n    if (pans < jans) {\n        quitf(_wa, \"Participant's total population limit (%d) is less than jury's (%d)\", pans, jans);\n    } else if (pans == jans) {\n        quitf(_ok, \"Answer is correct, total population limit = %d\", pans);\n    } else {\n        quitf(_fail, \"Participant's total population limit (%d) is greater than jury's (%d)\", pans, jans);\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5); // For random type, probability of empty cell\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"full\") {\n        // All cells are '.'\n        // Already initialized\n    } else if (type == \"empty\") {\n        // All cells are '#'\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '#');\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '#';\n            }\n        }\n    } else if (type == \"perimeter\") {\n        // '#' on the edges, '.' inside\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (i == 0 || i == n -1 || j == 0 || j == m -1)\n                    grid[i][j] = '#';\n                else\n                    grid[i][j] = '.';\n            }\n        }\n    } else if (type == \"single_empty\") {\n        // All '#' except one '.'\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '#');\n        }\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '.';\n    } else if (type == \"single_hole\") {\n        // All '.' except one '#'\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '.');\n        }\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '#';\n    } else if (type == \"random\") {\n        // Random grid based on probability p\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                double u = rnd.next();\n                if (u < p)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '#';\n            }\n        }\n    } else if (type == \"large_connected_area\") {\n        // Create large connected empty areas\n        int mid_n = n / 2;\n        int mid_m = m / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '#');\n        }\n        // Top-left quadrant\n        for (int i = 0; i < mid_n; ++i) {\n            for (int j = 0; j < mid_m; ++j) {\n                grid[i][j] = '.';\n            }\n        }\n        // Bottom-right quadrant\n        for (int i = mid_n; i < n; ++i) {\n            for (int j = mid_m; j < m; ++j) {\n                grid[i][j] = '.';\n            }\n        }\n    } else {\n        // Default to random grid\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '.');\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5); // For random type, probability of empty cell\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"full\") {\n        // All cells are '.'\n        // Already initialized\n    } else if (type == \"empty\") {\n        // All cells are '#'\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '#');\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '#';\n            }\n        }\n    } else if (type == \"perimeter\") {\n        // '#' on the edges, '.' inside\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (i == 0 || i == n -1 || j == 0 || j == m -1)\n                    grid[i][j] = '#';\n                else\n                    grid[i][j] = '.';\n            }\n        }\n    } else if (type == \"single_empty\") {\n        // All '#' except one '.'\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '#');\n        }\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '.';\n    } else if (type == \"single_hole\") {\n        // All '.' except one '#'\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '.');\n        }\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '#';\n    } else if (type == \"random\") {\n        // Random grid based on probability p\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                double u = rnd.next();\n                if (u < p)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '#';\n            }\n        }\n    } else if (type == \"large_connected_area\") {\n        // Create large connected empty areas\n        int mid_n = n / 2;\n        int mid_m = m / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '#');\n        }\n        // Top-left quadrant\n        for (int i = 0; i < mid_n; ++i) {\n            for (int j = 0; j < mid_m; ++j) {\n                grid[i][j] = '.';\n            }\n        }\n        // Bottom-right quadrant\n        for (int i = mid_n; i < n; ++i) {\n            for (int j = mid_m; j < m; ++j) {\n                grid[i][j] = '.';\n            }\n        }\n    } else {\n        // Default to random grid\n        for (int i = 0; i < n; ++i) {\n            grid[i].assign(m, '.');\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grid tests\n./gen -n 1 -m 1 -type full\n./gen -n 1 -m 1 -type empty\n./gen -n 1 -m 1 -type random -p 0.5\n./gen -n 1 -m 1 -type checkerboard\n\n# Single row grids\n./gen -n 1 -m 500 -type full\n./gen -n 1 -m 500 -type empty\n./gen -n 1 -m 500 -type random -p 0.7\n./gen -n 1 -m 500 -type checkerboard\n\n# Single column grids\n./gen -n 500 -m 1 -type full\n./gen -n 500 -m 1 -type empty\n./gen -n 500 -m 1 -type random -p 0.3\n./gen -n 500 -m 1 -type checkerboard\n\n# Maximum size grids\n./gen -n 500 -m 500 -type full\n./gen -n 500 -m 500 -type empty\n./gen -n 500 -m 500 -type random -p 0.5\n./gen -n 500 -m 500 -type random -p 0.1\n./gen -n 500 -m 500 -type random -p 0.9\n\n# Grids with special patterns\n./gen -n 500 -m 500 -type checkerboard\n./gen -n 500 -m 500 -type perimeter\n./gen -n 100 -m 100 -type perimeter\n./gen -n 100 -m 100 -type single_empty\n./gen -n 100 -m 100 -type single_hole\n\n# Grids with large connected areas\n./gen -n 500 -m 500 -type large_connected_area\n./gen -n 200 -m 300 -type large_connected_area\n\n# Grids with varying probabilities for random grids\n./gen -n 300 -m 300 -type random -p 0.2\n./gen -n 300 -m 300 -type random -p 0.8\n\n# Additional small and medium grids\n./gen -n 100 -m 100 -type random -p 0.5\n./gen -n 100 -m 100 -type random -p 0.0\n./gen -n 100 -m 100 -type random -p 1.0\n\n# Edge cases with a single empty cell or a single hole\n./gen -n 500 -m 500 -type single_empty\n./gen -n 500 -m 500 -type single_hole\n\n# Completely empty and completely full grids\n./gen -n 500 -m 500 -type full\n./gen -n 500 -m 500 -type empty\n\n# Random small and medium grids\n./gen -n 10 -m 15 -type random -p 0.4\n./gen -n 250 -m 250 -type random -p 0.6\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:39.335125",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "327/E",
      "title": "E. Axis Walking",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 24). The following line contains n integers: a1, a2, ..., an (1 ≤ ai ≤ 109). The third line contains integer k (0 ≤ k ≤ 2). The fourth line contains k positive integers, representing the numbers that give Iahub bad luck. Each of these numbers does not exceed 109.",
      "output_spec": "OutputOutput a single integer — the answer of Iahub's dilemma modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy32 3 525 7OutputCopy1InputCopy32 2 221 3OutputCopy6",
      "description": "E. Axis Walking\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 24). The following line contains n integers: a1, a2, ..., an (1 ≤ ai ≤ 109). The third line contains integer k (0 ≤ k ≤ 2). The fourth line contains k positive integers, representing the numbers that give Iahub bad luck. Each of these numbers does not exceed 109.\n\nOutputOutput a single integer — the answer of Iahub's dilemma modulo 1000000007 (109 + 7).\n\nInputCopy32 3 525 7OutputCopy1InputCopy32 2 221 3OutputCopy6\n\nInputCopy32 3 525 7\n\nOutputCopy1\n\nInputCopy32 2 221 3\n\nOutputCopy6\n\nNoteIn the first case consider six possible orderings:  [2, 3, 5]. Iahub will stop at position 2, 5 and 10. Among them, 5 is bad luck for him.  [2, 5, 3]. Iahub will stop at position 2, 7 and 10. Among them, 7 is bad luck for him.  [3, 2, 5]. He will stop at the unlucky 5.  [3, 5, 2]. This is a valid ordering.  [5, 2, 3]. He got unlucky twice (5 and 7).  [5, 3, 2]. Iahub would reject, as it sends him to position 5. In the second case, note that it is possible that two different ways have the identical set of stopping. In fact, all six possible ways have the same stops: [2, 4, 6], so there's no bad luck for Iahub.",
      "solutions": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces",
          "content": "Welcome to another Codeforces Round!Please note that the time of round #191 was changed. Contest will start at Thursday 12:30 UTC.My name is Linh (ll931110). I'm from Vietnam, and I'm glad to present to you my first Codeforces round. It is for Div 2 only; however, I welcome participants from Div. 1 to participate and enjoy challenging problems. I hope this would be a pleasant gift for those who are going to IOI 2013 (and participants from World Finals), which will take place in just a couple of days. This round is prepared by me and fchirica (from Romania). Also, I would like to thank the Codeforces team who puts efforts on making Codeforces and Polygon possible.Happy solving!UPD1: The score of problems in this round will be dynamic. The problems will be sorted in increasing difficulty order, at least in our perspective.UPD2: The contest is over! Congratulations for everybody, especially for those who solved E. You proved to be smarter than I am (your solutions were totally unexpected to us). Thank Gerald, Aksenov239 and Delinur for helping us on preparing the round!Div. 2 winners: SillyHook02 Tsukiko Quit_Quickly Zhengxu sevenzplus Those are five people who nail all problems!Unofficial winners: Kissshot R_R_ xchernoff wakaka phtniit The editorial will be completed soon after revising and adding possible alternative solutions. You are welcome to post your answers in comments.Thank you and see you in the next round!UPD3: Editorial is now available. Remind that it is not the final version, as we are writing possible alternative solutions for problems. Stay tuned!UPD4: Editorial is now completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1620
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces",
          "content": "327A - Игра с переворачиваниемI’ll present here the O(N ^ 3) algorithm, which is enough to solve this task. Then, for those interested, I’ll show a method to achieve O(N) complexity.O(N ^ 3) method: The first thing to observe is that constrains are slow enough to allow a brute force algorithm. Using brute force, I can calculate for each possible single move the number of 1s resulting after applying it and take maximum. For consider each move, I can just generate with 2 FOR loops all indices i, j such as i <= j. So far we have O(N ^ 2) complexity. Suppose I have now 2 fixed vaIues i and j. I need to calculate variable cnt (initially 0) representing the number of ones if I do the move. For do this, I choose another indice k to go in a[] array (taking O(N) time, making the total of O(N ^ 3) complexity). We have two cases: either k is in range [i, j] (this means i <= k AND k <= j) or not (if that condition is not met). If it’s in range, then it gets flipped, so we add to count variable 1 – a[k] (observe that it makes 0 to 1 and 1 to 0). If it’s not in range, we simply add to cnt variable a[k]. The answer is maximum of all cnt obtained.O(N) method: For achieve this complexity, we need to make an observation. Suppose I flip an interval (it does not matter what interval, it can be any interval). Also suppose that S is the number of ones before flipiing it. What happens? Every time I flip a 0 value, S increases by 1 (I get a new 1 value). Every time I flip a 1 value, S decreases by 1 (I loose a 1 value). What would be the “gain” from a flip? I consider winning “+1” when I get a 0 value and “-1” when I get a 1 value. The “gain” would be simply a sum of +1 and -1. This gives us idea to make another vector b[]. B[i] is 1 if A[i] is 0 and B[i] is -1 if A[i] is 1. We want to maximize S + gain_after_one_move sum. As S is constant, I want to maximize gain_after_one_move. In other words, I want to find a subsequence in b[] which gives the maximal sum. If I flip it, I get maximal number of 1s too. This can be founded trivially in O(N ^ 2). How to get O(N)? A relative experienced programmer in dynamic programming will immediately recognize it as a classical problem “subsequence of maximal sum”. If you never heard about it, come back to this approach after you learn it. 327B - Голодная последовательностьWe’ll present two different solutions for this task.Solution 1. What if we solve a more general task? What if each hungry number from the solution isn’t allowed to be divided by any number smaller than it (except 1, which is divides every natural number). If this more general condition would be met, then the “hungry” condition would be met, too (as a[i] won’t be divided by a number smaller than it (except 1), it won’t be divided by a[j], too, with j < i, assuming that a[j] is different from 1). Now how to find numbers for this more general condition? We can rephrase it as: each number from more general condition has 2 divisors: 1 and itself. So if we print N numbers with 2 divisors in increasing order, that would be a good solution. As you probably know, numbers with 2 divisors are called “prime numbers”. The task reduces to finding first N prime numbers. This can be done via brute force, or via Sieve of Eratosthenes (however, not necessarily to get an AC solution).Solution 2. Suppose we are given the number N. We can observe that for big enough consecutive numbers, the array is always hungry. For example, we can print 3 * N + 0, 3 * N + 1, 3 * N + 2, …, 3 * N + (N – 1). Magic, isn’t it? Why does it work now? Pick an arbitrary a[i]. The solution would be bad if one of numbers 2 * a[i], 3 * a[i], 4 * a[i] and so on would be in a[] array. However, it will never happen. The smallest multiple from that ones will be 2 * 3 * N = 6 * N. There is not possible to obtain a smallest multiple than that one. On the other hand, the biggest number from a[] array would be 3 * N + N – 1 = 4 * N — 1. Since smallest multiple is bigger than biggest term of the array, it (and of course other multiples bigger than it) will never exist in a[] array. So the above solution is correct also. 327C - Волшебная пятеркаProperty: A number is divisible by 5 if and only if its last digit is either 0 or 5.A first solution: Suppose you’re given a plate S, not so big, so we can iterate all its elements. Can we get the answer? I build a new array sol[]. In explanation, both S and sol will be 1-based. Denote N = size of S. Also, denote sol[i] = the number of ways to delete digits from plate S such as we obtain a magic number which has the last digit on position i. The answer is sol[1] + sol[2] + … + sol[N]. Let’s focus now on calculating sol[i]. If S[i] (digit of the plate corresponding to ith position) is different than 0 or 5, then sol[i] is 0 (see “property”). Otherwise we have to ask ourself: in how many ways I can delete digits in “left” and in “right” of position i. In the “right”, we have only one way: delete all digits (if one digit from right still stands, then the number isn’t ending at position i). Now in the “left”: there are digits on positions 1, 2, …, i – 1. We can either delete a digit or keep it – anyhow he’d do we still get a magic number. So on position 1 I have 2 ways (delete or keep it), on position 2 I have also 2 ways, …, on position i – 1 I have also 2 ways. Next, we apply what mathematics call “rule of product” and we get 2 * 2 * 2 … * 2 (i – 1 times) = 2 ^ (i – 1). Applying “rule of product” on both “left” and “right” I get 2 ^ (i – 1) * 1 = 2 ^ (i – 1). To sum it up: If S[i] is 0 or 5 we add to the answer 2 ^ (i – 1). Otherwise, we add nothing. The only problem remained for this simple version is how we calculate A ^ B modulo one number. This is a well known problem as well, called “Exponentiation by squaring”. Coming back to our problem: So what’s different in our problem? It’s the fact that we can’t iterate all elements of plate. However, we can use “concatenation” property. We know that if an element is a position i in the first copy, it will also be on positions i + n, i + 2 * n, i + 3 * n, …, i + (k – 1) * n (we don’t call here about trivial case when k = 1). What if iterate only one copy and calculate for all K copies. If in the first copy, at the position i is either 0 or 5, we have to calculate the sum 2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n). By now on, in calculus I'll denote i as i — 1 (it's a simple mathematical substitution). A first idea would be just to iterate each term and calculate it with exponentiation by squaring. However, it takes in the worst case the same complexity as iterating all plate. We need to find something smarter.2 ^ i + 2 ^ (i + n) + 2 ^ (i + 2 * n) + … + 2 ^ (i + (k – 1) * n) = = 2 ^ i * 1 + 2 ^ i * 2 ^ n + 2 ^ i * 2 ^ (2 * n) + … + 2 ^ i * 2 ^ ((k – 1) * N) == 2 ^ i * (2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ ((k – 1) * n)We reduced the problem to calculate sum S = 2 ^ 0 + 2 ^ n + 2 ^ (2 * n) + … + 2 ^ (X * n).What’s the value of 2 ^ n * S ? It is 2 ^ n + 2 ^ (2 * n) + 2 ^ (3 * n) + … + 2 ^ ((X + 1) * n). And what you get by making 2 ^ n * S – S ? 2 ^ n * S – S = 2 ^ ((X + 1) * n) – 1S * (2 ^ n – 1) = 2 ^ ((X + 1) * n) – 1S = (2 ^ ((X + 1) * n) – 1) / (2 ^ n – 1).We can calculate both 2 ^ i and S with exponentiation by squaring and the problem is done. For \"/\" operator, we can use multiplicative inverse (you can read about that and about Fermat Little's theorem, taking care that 10^9 + 7 is a prime number). The time complexity is O(N * logK). Note: that kind of reduction of powers is called “power series” in math.Alternative solution: For this alternative solution, we don't need to use any special properties of 5. In fact, we can replace 5 by any integer p and still have the same solution. So for now, I shall write p in place of 5.This suggests a dynamic programming solution: denote dp(x,y) be the number of ways of deleting some digits in the first x digits to form a number that has remainder y (modulo p). For simplicity, we accept “empty” plate be a number that is divisible by p. Writing the DP formula is not difficult. We start with dp(0,0) = 1, and suppose we already have the value dp(x,y). We shall use dp(x,y) to update for dp(x + 1,*), which has two possible cases: either keeping the (x + 1)-th digit or by deleting it. I won't go into much detail here. The answer is therefore dp(N,0).Clearly, applying this DP directly would time out. For a better algorithm, we resort on the periodicity of the actual plate. The key idea is that, we imagine each digit in the plate as a linear transformation from (x0, x1, .., x(p – 1)) to (y0, y1, y(p-1)). Obviously, (x0, x1, .., x(p — 1)) corresponds to some dp(i, 0), dp(i, 1) .. dp(i, p — 1) and (y0, y1, y(p-1)) corresponds to some (dp(i + 1, 0)), dp((i + 1), 1), ..., dp(i + 1, p — 1) .So we can write X * M(d) = Y, where X and Y are vectors of length p, and M(d) is the matrix of size p * p representing digit d (note that M(d) is independent from X and Y). By multiplying all |a|.K such matrices together, we obtain a transformation from (1, 0, 0, .., 0) to (T0, T1, .., T(p – 1)) where T0 is actually our answer (including the empty plate).What's the difference? We can group the matrices in groups of length |a|, and lift to the exponent K. That leads to an algorithm with time complexity O(p^3(|a| + log K)), which could be risky. To improve, we should go back to our original DP function and observe that it is actually a linear transformation from (1, 0, 0, .., 0) to (R0, R1, …, R(p – 1)), if we restrict ourselves in the first fragment of length |a|. So instead of multiplying |a| matrices together, we can run DP p times with initial conditions (0, 0, .., 0, 1, 0, .., 0) to obtain the matrix transformation. The overall time complexity becomes O(|a| * p^2 + p^3 log K) . 327D - Башни из кирпичейIn case you want to try some examples on your own, you may play this game, which is the origin of this problem: http://en.wikipedia.org/wiki/Tower_BloxxNow back to the analysis :)The restriction given in the problem poses you to think of building as many Red Towers as possible, and fill the rest with Blue Towers (since there is no profit of letting cells empty, such cells can be filled by Blue Towers). Also, it's quite obvious to see that each connected component (containing empty cells only) is independent from each other, so we shall iterate the component one by one. Denote the current component be S.Lemma 1 is impossible to build S so that it contains all Red Towers only.Proof Suppose there exists such a way. Look up the last cell that is built (denote by x). Clearly x is a Red Tower, so at the moment it is built, x must be adjacent to a cell than contains a Blue Tower. However, it's obvious that there's no such cell (if there is, it must belong to S, which is impossible).As it's impossible to have all Red Towers, it's natural to look up at the next best solution: the one with exactly one Blue Tower, and among them, we need to find the least lexicographic solution. Fortunately, we can prove that such a configuration is always possible. Such proof is quite tricky, indeed:Lemma 2 Pick any cell b in S. It is possible to build a configuration that has all but b be Red Towers, and b is a Blue Tower.Proof Construct a graph whose vertices correspond to the cells of S, and the edges correspond to cells that are adjacent. Since S is connected, it is possible to build a tree that spans to all vertices of S. Pick b as the root and do the following: Build all cells of S blue Move from the leaf to the root. At each cell (except the root), destroy the Blue Tower and rebuild with the Red Tower. To be precise, u can be destroyed (and rebuilt) if all vertices in the subtree rooted at u have already been rebuilt. How can it be the valid solution? Take any vertex u which is about to be rebuilt. Clearly u is not b, and u has its parent to be blue, so the condition for rebuilding can be met. When the building is completed, only b remains intact, while others have been transformed into Red Towers.So we get the following algorithm: do a BFS / DFS search to find connected components. Then, apply Lemma 2 to build a valid configuration.327E - Идем по осиUsually when dealing with complicated problems, a good idea is to solve them for small cases. Let’s try this here.First case: K = 0. The answer is obviously N! (each permutation of p1, p2, …, pn would be good).Next case: K = 1. The answer of this one is N! – |L1|. By L1 I denote all routes for which a prefix sum is equal to first lucky number. Obviously, if from all routes I exclude the wrong ones, I get my answer. If we can find an algorithm to provide |L1| in good time, then problem is solved for K = 1. We can just try all N! permutations. Despite this method is simple, it has complexity O(N!), too much for the constraints. Suppose we’ve founded a set of positions p1, p2, .., pk such as a[p1] + a[p2] + ..+ a[pk] = U1 (first unlucky number). How many permutations can we make? The first k positions need to be p1, p2, .., pk, but in any order. Hence we get k! . The not used positions can also appeared in any order, starting from k + 1 position. As they are n – k, we can permute them in (n – k)! ways. Hence, the answer is k! * (n – k)! Instead of permuting {1, 2, .., n}, now we need to find subsets of it. Hence, the running time becomes O(2^n). This is still too much. Meet in the middle. We make all subsets for first half of positions (from 1 to N / 2) and them for second half (from N / 2 + 1 to N). For each subset we keep 2 information: (sum, cnt) representing that there is a subset of sum “sum” containing “cnt” elements. For each (X, Y) from left we iterate in the right. After choosing one element from the left and one from the right we just “split” them. To split 2 states (A, B) and (C, D), the new state becomes (A + C, B + D). But we know that A + C = U1. This comes us to the idea: for each (X, Y) in the left, I check (U1 – X, 1), (U1 – X, 2), … , (U1 – X, K) from the right. For each of them, the answer would be (Y + K)! * (N – Y – K)! . I can store (using any data structure that allows this operations, I suggest a hash) how(C, D) = how many times does state (C, D) appear in the right. So, for a state (A, B) the answer becomes a sum of how(U1 — A, K) * (B + K)! * (N — B — K)!. Doing the sum for all states (A, B), we get our answer. The complexity of this method is O(2 ^ (N / 2) * N). Final Case: K = 2 The whole \"meet in the middle\" explanation worthed. We will do something very similar to solve this case. Suppose U1 and U2 are the unlucky numbers. Without loosing the generality, let's assume U1 <= U2.Following \"Principle of inclusion and exclusion\" paradigm (google about it if you never heard before) we can write our solution as N! — |L1| — |L2| + |intersection between L1 and L2|. Again, by L1,2 I denote the number of routes which have a prefix sum equal to number U1,2. The |X| is again the cardinal of this set. Basically we can calculate |X| as for K = 1. The only problem remained is calculating |intersection between L1 and L2|.The |intersection between L1 and L2| is the number of permutations which have a prefix sum equal to U1 and a prefix sum equal to U2. Since U1 <= U2, we can split a permutation from this set in 3 parts: 1/ p1, p2, ...pk such as a[p1] + a[p2] + ... + a[pk] = U1.2/ pk+1, pk+2, ..., pm such as a[pk+1], a[pk+2], ..., a[pm] = U2 — U1. Note that a[p1] + a[p2] + ... + a[pm] = U2. 3/ The rest of elements until position n.By a perfectly identical logic from K = 1 case, the number of permutations given those p[] would be k! * (m — k)! * (n — m)!.So the problem reduces to: find all indices set p1, p2, ... and q1, q2, .. such as a[p1] + a[p2] + ... + a[pn1] = U1 and a[q1] + a[q2] + ... + a[qn2] = U2 — U1. Then, we can apply formula using n1 and n2 described above. The first idea would be O(3 ^ N) — for each position from {1, 2, .., n} atribute all combinations of {0, 1, 2}. 0 means that position i is 1/, 1 means that position i is in 2/ and 2 means that position i is in 3/ . This would time out.Happily, we can improve it with meet in the middle principle. The solution is very similar with K = 1 case. I won't fully explain it here, if you understood principle from K = 1 this shouldn't be a problem. The base idea is to keep (S1, S2, cnt1, cnt2) for both \"left\" and \"right\". (S1, S2, cnt1, cnt2) represents a subset which has sum of elements from 1/ equal to S1, sum of elements from 2/ equal to S2, in 1/ we have cnt1 element and in 2/ we get cnt2 elements. For a (S1, S2, cnt1, cnt2) state from \"left\" we are looking in the right for something like (U1 — S1, U2 — U1 — S2, i, j). We get O(3 ^ (N / 2) * N ^ 2) complexity.Unexpected solution During the round, we saw a lot of O(2 ^ N * N) solutions passing. This was totally out of expectations. I believe if would make tests stronger, this solution won't pass and round would be more challenging. That's it, nothing is perfect. As requested, I'll explain that solution here. Before explaining the solution, I assume you have some experience with \"bitmask dp\" technique. If you don't, please read before: http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=bitManipulationhttp://codeforces.com/blog/entry/337In this problem we'll assume that a is 0-based. For a mask, consider bits from right to left, noting them bit 0, bit 1 and so on. Bit i is 1 if and only if a[i] is in the subset which is in a bijective replation with the mask. For example, for mask 100011101 the subset is {a0, a2, a3, a4, a8}. I'll call from now on the subset \"subset of mask\". Also, the sum of all elements in a subset will be called \"sum of mask\" (i.e. a0 + a2 + a3 + a4 + a8). We'll explain the solution based by watashi's submission. 4017915First step of the algorithm is to calculate sum of each mask. Let dp[i] the sum of mask i. Remove exactly one element from the subset of mask. Suppose the new mask obtained is k and removed element is j. Then, dp[i] = dp[k] + a[j]. dp[k] is always calculated before dp[i] (to proof, write both k and i in base 10. k is always smaller than i). Having j an element from subset of mask i, we can compute mask k by doing i ^ (1 << j). Bit j is 1, and by xor-ing it with another 1 bit, it becomes 0. Other bits are unchanged by being xor-ed by 0. This method works very fast to compute sum of each mask.From now on, let's denote a new array dp2[i] = how many good routes can I obtain with elements from subset of mask i. Watashi uses same dp[] array, but for making it clear, in editorial I'll use 2 separate arrays. Suppose that CNT(i) is number of elements from subset of mask i. We are interested in how many ways we can fill positions {1, 2, ..., CNT(i)} with elements from subset of mask i such as each prefix sum is different by each unlucky number. Next step of the algorithm is to see which sum of masks are equal to one of unlucky numbers. We mark them as \"-1\" in dp2[]. Suppose we founded a subset {a1, a2, ..., ax} for which a1 + a2 + ... + ax = one of unlucky numbers. Then, none permutation of {a1, a2, ..., ax} is allowed to appear on first x positions. When we arrive to a \"-1\" state, we know that the number of good routes for its subset of mask is 0.Now, finally the main dp recurrence. If for the current mask i, dp2[i] = -1, then dp2[i] = 0 and continue (we discard the state as explained above). Otherwise, we know that there could exist at least one way to complete positions {1, 2, ... CNT(i)} with elements of subset of mask i. But how to calculate it? We fix the last element (the element from the position CNT(I)) with some j from subset of mask i. The problem reduces now with how many good routes can I fill in positions {1, 2, ..., CNT(i) — 1} with elements from subset of mask i, from which we erased element j. With same explanation of sum of mask calculations, this is already calculated in dp2[i ^ (1 << j)]. The result is dp2[(1 << N) — 1] (number of good routes containing all positions). Editorial has been made by me and ll931110.The authors of the problems: Div.2 A & Div.2 B — meDiv.2 C & Div.2 D & Div.2 E — ll931110",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8274",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 327\\s*E"
          },
          "content_length": 20131
        },
        {
          "title": "2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest - Codeforces",
          "content": "Welcome to the contest of Saratov State U on Petrozavodsk Winter Training Camp 2012-2013. This contest was prepared with diligence and love by jury team of ACM-ICPC NEERC Subregional (Saratov) Contest. Here is the complete list of writers: MikeMirzayanov Nerevar RAD e-maxx natalia NALP Dmitry Klenov Dmitry Mescheryakov Dmitry Stepanenko Thanks to all of them!All the authors invite you to take part in the contest virtually in Gym, if: You didn't take part in it previously You (or your team) is high skilled that you will take part (or took part) on ACM-ICPC World Finals or other high-level competitions. The problemset seems to be hard for not experienced participants. Hope, you will enjoy the contest!Contest link: 2012-2013 Petrozavodsk Winter Training Camp, Saratov SU Contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/6656",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 1",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 (Div. 2) - Codeforces - Code 2",
          "code": "\"When I run this code(I type it by my own on contest) on my PC , I use 10+ s\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 1",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 2",
          "code": "t =  ((1 - fastexp(r, k)) / (1 - r)) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 3",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 4",
          "code": "ans.Enqueue(String.Format(\"B {0} {1}\", i, j));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 5",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 6",
          "code": "for (int i = 0; i < k; i++)\n            {\n                Console.WriteLine(ans.Dequeue());\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 7",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 8",
          "code": "ans.Enqueue('B');\n            q1.Enqueue(i);\n            q2.Enqueue(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < k; i++)\n            {\n                char c = ans.Dequeue();\n                int x = q1.Dequeue();\n                int y = q2.Dequeue();\n                Console.WriteLine(\"{0} {1} {2}\",c,x,y);\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #191 — Tutorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n\n    vector<int> pre(n + 1, 0);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (a[i] == 1 ? 1 : 0);\n\n    vector<int> f(n + 1, 0);\n    for (int k = 0; k <= n; k++) f[k] = k - 2 * pre[k];\n\n    vector<int> g(n, 0);\n    g[0] = f[0];\n    for (int k = 1; k < n; k++) g[k] = min(g[k - 1], f[k]);\n\n    int ans = -INT_MAX;\n    for (int j = 1; j <= n; j++) ans = max(ans, f[j] - g[j - 1] + pre[n]);\n    \n    cout << ans;\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8274",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 1LL, 1000000000LL, \"a\");\n    inf.readEoln();\n    int k = inf.readInt(0, 2, \"k\");\n    inf.readEoln();\n    if (k > 0) {\n        vector<long long> bad_numbers = inf.readLongs(k, 1LL, 1000000000LL, \"bad_numbers\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 1LL, 1000000000LL, \"a\");\n    inf.readEoln();\n    int k = inf.readInt(0, 2, \"k\");\n    inf.readEoln();\n    if (k > 0) {\n        vector<long long> bad_numbers = inf.readLongs(k, 1LL, 1000000000LL, \"bad_numbers\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 1LL, 1000000000LL, \"a\");\n    inf.readEoln();\n    int k = inf.readInt(0, 2, \"k\");\n    inf.readEoln();\n    if (k > 0) {\n        vector<long long> bad_numbers = inf.readLongs(k, 1LL, 1000000000LL, \"bad_numbers\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long D_MAX = 1000000000LL;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"all_same\") {\n        /* All elements are the same */\n        long long val = rnd.next(1LL, D_MAX / n);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"max_elements\") {\n        /* All elements are maximal to keep sum <= D_MAX */\n        long long val = D_MAX / n;\n        if (val == 0) val = 1;\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"min_elements\") {\n        /* All elements are minimal */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"unlucky_overlap\") {\n        /* Elements are 1 so cumulative sums are 1..n */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"large_elements\") {\n        /* Elements are large so sums exceed D_MAX */\n        long long val = D_MAX + rnd.next(1LL, D_MAX);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else { // \"random\"\n        /* Generate random elements ensuring sum <= D_MAX */\n        long long sum = 0;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, D_MAX / n);\n            sum += a[i];\n        }\n    }\n\n    // Adjust total sum to not exceed D_MAX if necessary\n    long long sum = accumulate(a.begin(), a.end(), 0LL);\n    if (sum > D_MAX && (type != \"large_elements\")) {\n        for(int i = 0; i < n; ++i)\n            a[i] = (a[i] * D_MAX) / sum;\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output a1, a2, ..., an */\n    for (int i = 0; i < n; i++) {\n        printf(\"%lld%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    /* Output k */\n    printf(\"%d\\n\", k);\n    vector<long long> unlucky;\n    if (type == \"unlucky_overlap\") {\n        /* Unlucky numbers are cumulative sums */\n        for (int i = 1; i <= k; ++i) {\n            unlucky.push_back(i);\n        }\n    } else {\n        /* Generate random unlucky numbers in [1, D_MAX] */\n        set<long long> unlucky_set;\n        while (unlucky_set.size() < k) {\n            long long num = rnd.next(1LL, D_MAX);\n            unlucky_set.insert(num);\n        }\n        unlucky.assign(unlucky_set.begin(), unlucky_set.end());\n    }\n    /* Output unlucky numbers */\n    for (int i = 0; i < k; i++) {\n        printf(\"%lld%c\", unlucky[i], \" \\n\"[i == k - 1]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long D_MAX = 1000000000LL;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"all_same\") {\n        /* All elements are the same */\n        long long val = rnd.next(1LL, D_MAX / n);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"max_elements\") {\n        /* All elements are maximal to keep sum <= D_MAX */\n        long long val = D_MAX / n;\n        if (val == 0) val = 1;\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"min_elements\") {\n        /* All elements are minimal */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"unlucky_overlap\") {\n        /* Elements are 1 so cumulative sums are 1..n */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"large_elements\") {\n        /* Elements are large so sums exceed D_MAX */\n        long long val = D_MAX + rnd.next(1LL, D_MAX);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else { // \"random\"\n        /* Generate random elements ensuring sum <= D_MAX */\n        long long sum = 0;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, D_MAX / n);\n            sum += a[i];\n        }\n    }\n\n    // Adjust total sum to not exceed D_MAX if necessary\n    long long sum = accumulate(a.begin(), a.end(), 0LL);\n    if (sum > D_MAX && (type != \"large_elements\")) {\n        for(int i = 0; i < n; ++i)\n            a[i] = (a[i] * D_MAX) / sum;\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output a1, a2, ..., an */\n    for (int i = 0; i < n; i++) {\n        printf(\"%lld%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    /* Output k */\n    printf(\"%d\\n\", k);\n    vector<long long> unlucky;\n    if (type == \"unlucky_overlap\") {\n        /* Unlucky numbers are cumulative sums */\n        for (int i = 1; i <= k; ++i) {\n            unlucky.push_back(i);\n        }\n    } else {\n        /* Generate random unlucky numbers in [1, D_MAX] */\n        set<long long> unlucky_set;\n        while (unlucky_set.size() < k) {\n            long long num = rnd.next(1LL, D_MAX);\n            unlucky_set.insert(num);\n        }\n        unlucky.assign(unlucky_set.begin(), unlucky_set.end());\n    }\n    /* Output unlucky numbers */\n    for (int i = 0; i < k; i++) {\n        printf(\"%lld%c\", unlucky[i], \" \\n\"[i == k - 1]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type min_elements\n./gen -n 1 -k 2 -type min_elements\n./gen -n 1 -k 0 -type max_elements\n./gen -n 1 -k 2 -type max_elements\n\n./gen -n 2 -k 0 -type min_elements\n./gen -n 2 -k 2 -type min_elements\n./gen -n 2 -k 2 -type unlucky_overlap\n\n./gen -n 5 -k 0 -type all_same\n./gen -n 5 -k 2 -type unlucky_overlap\n\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 2 -type random\n./gen -n 10 -k 2 -type unlucky_overlap\n./gen -n 10 -k 2 -type large_elements\n\n./gen -n 15 -k 0 -type random\n./gen -n 20 -k 2 -type random\n\n./gen -n 24 -k 0 -type random\n./gen -n 24 -k 2 -type random\n./gen -n 24 -k 2 -type unlucky_overlap\n\n./gen -n 24 -k 2 -type large_elements\n\n./gen -n 24 -k 0 -type all_same\n./gen -n 24 -k 2 -type all_same\n\n./gen -n 6 -k 0 -type min_elements\n./gen -n 6 -k 2 -type min_elements\n\n./gen -n 6 -k 2 -type unlucky_overlap\n\n./gen -n 12 -k 2 -type random\n\n./gen -n 24 -k 2 -type min_elements\n\n./gen -n 24 -k 0 -type large_elements\n\n./gen -n 15 -k 2 -type large_elements\n\n./gen -n 15 -k 2 -type all_same\n\n./gen -n 8 -k 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:41.530549",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "328/A",
      "title": "A. IQ-тест",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задана последовательность из четырех целых чисел от 1 до 1000 включительно.",
      "output_spec": "Выходные данныеВыведите одно целое число — ответ на задачу. Если заданные четыре числа образуют арифметическую прогрессию, то выведите ее следующий член. Аналогично, если заданные четыре числа образуют геометрическую прогрессию, то выведите ее следующий член. В противном случае выведите 42.",
      "sample_tests": "ПримерыВходные данныеСкопировать836 624 412 200Выходные данныеСкопировать-12Входные данныеСкопировать1 334 667 1000Выходные данныеСкопировать1333",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задана последовательность из четырех целых чисел от 1 до 1000 включительно.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — ответ на задачу. Если заданные четыре числа образуют арифметическую прогрессию, то выведите ее следующий член. Аналогично, если заданные четыре числа образуют геометрическую прогрессию, то выведите ее следующий член. В противном случае выведите 42.\n\nВыходные данные\n\nВходные данныеСкопировать836 624 412 200Выходные данныеСкопировать-12Входные данныеСкопировать1 334 667 1000Выходные данныеСкопировать1333\n\nВходные данныеСкопировать836 624 412 200\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 334 667 1000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1333\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ этой задаче очень слабые претесты!",
      "solutions": [
        {
          "title": "Testing Round 8 — для тех, кто еще не спит - Codeforces",
          "content": "Всем привет.Если вам не хочется спать и нечего делать — присоединяйтесь к Testing Round 8. Спасибо.Спасибо за участие. До встречи завтра на раунде MemSQL!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8343",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 154
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a1 = inf.readInt(1, 1000, \"a1\");\n    inf.readSpace();\n    int a2 = inf.readInt(1, 1000, \"a2\");\n    inf.readSpace();\n    int a3 = inf.readInt(1, 1000, \"a3\");\n    inf.readSpace();\n    int a4 = inf.readInt(1, 1000, \"a4\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a1 = inf.readInt(1, 1000, \"a1\");\n    inf.readSpace();\n    int a2 = inf.readInt(1, 1000, \"a2\");\n    inf.readSpace();\n    int a3 = inf.readInt(1, 1000, \"a3\");\n    inf.readSpace();\n    int a4 = inf.readInt(1, 1000, \"a4\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a1 = inf.readInt(1, 1000, \"a1\");\n    inf.readSpace();\n    int a2 = inf.readInt(1, 1000, \"a2\");\n    inf.readSpace();\n    int a3 = inf.readInt(1, 1000, \"a3\");\n    inf.readSpace();\n    int a4 = inf.readInt(1, 1000, \"a4\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly 4 integers in the range [1..maxVal].\n  The mode of generation is controlled by the \"mode\" parameter:\n     1) mode = \"corner\"\n        - outputs one of several predefined corner-case test sets\n          chosen by \"cornerIndex\"\n     2) mode = \"ap\"\n        - outputs a random valid arithmetic progression\n     3) mode = \"gp\"\n        - outputs a random valid integer-ratio geometric progression\n          (ratio != 1, ratio != 0, and next must be an integer)\n     4) mode = \"neither\"\n        - attempts to produce random 4 numbers that form neither a valid\n          arithmetic progression nor a valid integer-ratio geometric progression\n     5) mode = \"random\"\n        - simply outputs 4 random integers in [1..maxVal], no constraints\n\n  The parameter \"maxVal\" (default 1000) controls the maximum value of each integer.\n  We do NOT set any random seed, nor do we allow passing it as a parameter.\n */\n\nstatic bool isArithmetic(const vector<int> &v) {\n    // Check if v is an arithmetic progression\n    // v has size 4\n    int d1 = v[1] - v[0];\n    int d2 = v[2] - v[1];\n    int d3 = v[3] - v[2];\n    return (d1 == d2 && d2 == d3);\n}\n\nstatic bool isGeometric(const vector<int> &v) {\n    // Check if v is a *valid integer-ratio* geometric progression\n    // ratio != 1, ratio != 0, and next must remain integral\n    // We only check ratio consistency for v[0]->v[1]->v[2]->v[3].\n    // v[i] != 0 (given v[i] in [1..1000], so all are positive).\n    // ratio must be (v[i+1]/v[i]) if it's consistent, and this ratio must be the same\n    // for i=0..2. Also that ratio must be integer, ratio != 1, ratio != 0.\n\n    // If any v[i] == 0 in general problems, that would be invalid, but here it can't happen\n    // because input range is [1..1000].\n\n    // Check that consecutive divisions are integer and the same\n    // i.e. if r = v[1]/v[0], v[1] % v[0] == 0, etc.\n    // Then check r != 1, r != 0.\n\n    // If v[0] = 0 this is automatically invalid, but can't happen in [1..1000].\n    // We'll proceed.\n    if (v[0] == 0 || v[1] == 0 || v[2] == 0) return false;\n\n    // Check integer ratio from v[0] to v[1].\n    if (v[1] % v[0] != 0) return false;\n    int r = v[1] / v[0];\n    if (r == 0 || r == 1) return false;\n\n    // Now check the rest\n    if (v[2] % v[1] != 0) return false;\n    int rr = v[2] / v[1];\n    if (rr != r) return false;\n\n    if (v[3] % v[2] != 0) return false;\n    rr = v[3] / v[2];\n    if (rr != r) return false;\n\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // maxVal: the upper bound for each of the 4 integers.\n    int maxVal = opt<int>(\"maxVal\", 1000);\n\n    // mode: one of {\"corner\", \"ap\", \"gp\", \"neither\", \"random\"}\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // For \"corner\" mode, we choose from a predefined set using cornerIndex.\n    int cornerIndex = opt<int>(\"cornerIndex\", 0);\n\n    // We'll store 4 integers to output in this vector.\n    vector<int> arr(4, 1);\n\n    // Predefined corner cases. Some are valid AP, some are valid GP,\n    // some lead to \"42\" according to the logic.\n    // All of them remain in [1..1000].\n    static vector<vector<int>> cornerCases = {\n        // 0) 1 1 1 1 => ratio=1 => not valid GP, but is valid AP with d=0 => next=1\n        //    so for the correct solution, next=1. It's an arithmetic progression, not geometric.\n        {1, 1, 1, 1}, \n        // 1) 2 2 2 2 => ratio=1 => not valid GP, but valid AP => next=2\n        {2, 2, 2, 2}, \n        // 2) 1 2 3 4 => valid AP => next=5\n        {1, 2, 3, 4},\n        // 3) 1 2 4 8 => valid GP with ratio=2 => next=16\n        {1, 2, 4, 8},\n        // 4) 2 4 8 16 => valid GP with ratio=2 => next=32\n        {2, 4, 8, 16},\n        // 5) 500 500 500 500 => valid AP => next=500\n        {500, 500, 500, 500},\n        // 6) 1 3 9 27 => valid GP => ratio=3 => next=81\n        {1, 3, 9, 27},\n        // 7) 1000 999 998 997 => valid AP => d=-1 => next=996\n        {1000, 999, 998, 997},\n        // 8) 999 1000 1000 999 => likely neither (check difference: +1 then 0 then -1; ratio doesn't hold)\n        {999, 1000, 1000, 999}\n    };\n\n    if (mode == \"corner\") {\n        // Output one of the corner cases\n        cornerIndex = max(0, min((int)cornerCases.size()-1, cornerIndex));\n        arr = cornerCases[cornerIndex];\n    }\n    else if (mode == \"ap\") {\n        // Generate a random arithmetic progression a1, a1+d, a1+2d, a1+3d in [1..maxVal].\n        // We'll attempt random a1, random d (can be negative, zero, or positive)\n        // and ensure the last element is still in range.\n\n        // We'll do up to 1000 tries to find something valid.\n        bool ok = false;\n        for (int _try = 0; _try < 1000 && !ok; _try++) {\n            int a1 = rnd.next(1, maxVal);\n            // Let d range from -1000..1000\n            int d = rnd.next(-1000, 1000);\n            // We want a1 + 3d in [1..maxVal].\n            int a2 = a1 + d;\n            int a3 = a1 + 2*d;\n            int a4 = a1 + 3*d;\n            if (a2 >= 1 && a2 <= maxVal &&\n                a3 >= 1 && a3 <= maxVal &&\n                a4 >= 1 && a4 <= maxVal) {\n                arr[0] = a1;\n                arr[1] = a2;\n                arr[2] = a3;\n                arr[3] = a4;\n                ok = true;\n            }\n        }\n        // In worst case, if no valid found (extremely unlikely), fallback to corner case #0.\n        if (!ok) {\n            arr = {1, 1, 1, 1};\n        }\n    }\n    else if (mode == \"gp\") {\n        // Generate a random integer-ratio geometric progression a1, a1*r, a1*r^2, a1*r^3 in [1..maxVal].\n        // ratio != 1, ratio != 0, ratio in [2..something].\n        bool ok = false;\n        for (int _try = 0; _try < 2000 && !ok; _try++) {\n            // choose ratio in [2..10] for variety\n            int r = rnd.next(2, 10);\n\n            // We want to pick a1 so that a1*r^3 <= maxVal and a1>=1\n            // So a1 <= floor(maxVal / (r^3)).\n            // We'll let a1 range within [1.. thatValue].\n            long long limit = (long long)maxVal;\n            long long denom = 1;\n            for (int i = 0; i < 3; i++) denom *= r;\n            if (denom > 0 && denom <= limit) {\n                long long upperA1 = limit / denom;\n                if (upperA1 >= 1) {\n                    int a1 = rnd.next(1, (int)upperA1);\n                    // construct\n                    long long a2 = (long long) a1 * r;\n                    long long a3 = a2 * r;\n                    long long a4 = a3 * r;\n                    // all must fit in [1..maxVal]\n                    if (a2 >= 1 && a2 <= maxVal &&\n                        a3 >= 1 && a3 <= maxVal &&\n                        a4 >= 1 && a4 <= maxVal) {\n                        arr[0] = a1;\n                        arr[1] = (int)a2;\n                        arr[2] = (int)a3;\n                        arr[3] = (int)a4;\n                        ok = true;\n                    }\n                }\n            }\n        }\n        // fallback if not found\n        if (!ok) {\n            arr = {1, 2, 4, 8}; // a known valid GP\n        }\n    }\n    else if (mode == \"neither\") {\n        // Generate 4 random numbers, ensure they're not a valid AP or valid GP\n        bool ok = false;\n        for (int attempt = 0; attempt < 2000 && !ok; attempt++) {\n            for (int i = 0; i < 4; i++) {\n                arr[i] = rnd.next(1, maxVal);\n            }\n            if (!isArithmetic(arr) && !isGeometric(arr)) {\n                ok = true;\n            }\n        }\n        // If we couldn't find it after many tries (extremely unlikely),\n        // forcibly create an obviously \"neither\" set.\n        if (!ok) {\n            // This set is not arithmetic: diffs are +1, then 0, then -1\n            // nor geometric with integer ratio\n            arr = {10, 11, 11, 10};\n        }\n    }\n    else {\n        // mode == \"random\" => any 4 random numbers in [1..maxVal].\n        for (int i = 0; i < 4; i++) {\n            arr[i] = rnd.next(1, maxVal);\n        }\n    }\n\n    // Output the 4 integers in one line\n    // The problem statement says \"The first line contains exactly four integers\".\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < 3) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly 4 integers in the range [1..maxVal].\n  The mode of generation is controlled by the \"mode\" parameter:\n     1) mode = \"corner\"\n        - outputs one of several predefined corner-case test sets\n          chosen by \"cornerIndex\"\n     2) mode = \"ap\"\n        - outputs a random valid arithmetic progression\n     3) mode = \"gp\"\n        - outputs a random valid integer-ratio geometric progression\n          (ratio != 1, ratio != 0, and next must be an integer)\n     4) mode = \"neither\"\n        - attempts to produce random 4 numbers that form neither a valid\n          arithmetic progression nor a valid integer-ratio geometric progression\n     5) mode = \"random\"\n        - simply outputs 4 random integers in [1..maxVal], no constraints\n\n  The parameter \"maxVal\" (default 1000) controls the maximum value of each integer.\n  We do NOT set any random seed, nor do we allow passing it as a parameter.\n */\n\nstatic bool isArithmetic(const vector<int> &v) {\n    // Check if v is an arithmetic progression\n    // v has size 4\n    int d1 = v[1] - v[0];\n    int d2 = v[2] - v[1];\n    int d3 = v[3] - v[2];\n    return (d1 == d2 && d2 == d3);\n}\n\nstatic bool isGeometric(const vector<int> &v) {\n    // Check if v is a *valid integer-ratio* geometric progression\n    // ratio != 1, ratio != 0, and next must remain integral\n    // We only check ratio consistency for v[0]->v[1]->v[2]->v[3].\n    // v[i] != 0 (given v[i] in [1..1000], so all are positive).\n    // ratio must be (v[i+1]/v[i]) if it's consistent, and this ratio must be the same\n    // for i=0..2. Also that ratio must be integer, ratio != 1, ratio != 0.\n\n    // If any v[i] == 0 in general problems, that would be invalid, but here it can't happen\n    // because input range is [1..1000].\n\n    // Check that consecutive divisions are integer and the same\n    // i.e. if r = v[1]/v[0], v[1] % v[0] == 0, etc.\n    // Then check r != 1, r != 0.\n\n    // If v[0] = 0 this is automatically invalid, but can't happen in [1..1000].\n    // We'll proceed.\n    if (v[0] == 0 || v[1] == 0 || v[2] == 0) return false;\n\n    // Check integer ratio from v[0] to v[1].\n    if (v[1] % v[0] != 0) return false;\n    int r = v[1] / v[0];\n    if (r == 0 || r == 1) return false;\n\n    // Now check the rest\n    if (v[2] % v[1] != 0) return false;\n    int rr = v[2] / v[1];\n    if (rr != r) return false;\n\n    if (v[3] % v[2] != 0) return false;\n    rr = v[3] / v[2];\n    if (rr != r) return false;\n\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // maxVal: the upper bound for each of the 4 integers.\n    int maxVal = opt<int>(\"maxVal\", 1000);\n\n    // mode: one of {\"corner\", \"ap\", \"gp\", \"neither\", \"random\"}\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // For \"corner\" mode, we choose from a predefined set using cornerIndex.\n    int cornerIndex = opt<int>(\"cornerIndex\", 0);\n\n    // We'll store 4 integers to output in this vector.\n    vector<int> arr(4, 1);\n\n    // Predefined corner cases. Some are valid AP, some are valid GP,\n    // some lead to \"42\" according to the logic.\n    // All of them remain in [1..1000].\n    static vector<vector<int>> cornerCases = {\n        // 0) 1 1 1 1 => ratio=1 => not valid GP, but is valid AP with d=0 => next=1\n        //    so for the correct solution, next=1. It's an arithmetic progression, not geometric.\n        {1, 1, 1, 1}, \n        // 1) 2 2 2 2 => ratio=1 => not valid GP, but valid AP => next=2\n        {2, 2, 2, 2}, \n        // 2) 1 2 3 4 => valid AP => next=5\n        {1, 2, 3, 4},\n        // 3) 1 2 4 8 => valid GP with ratio=2 => next=16\n        {1, 2, 4, 8},\n        // 4) 2 4 8 16 => valid GP with ratio=2 => next=32\n        {2, 4, 8, 16},\n        // 5) 500 500 500 500 => valid AP => next=500\n        {500, 500, 500, 500},\n        // 6) 1 3 9 27 => valid GP => ratio=3 => next=81\n        {1, 3, 9, 27},\n        // 7) 1000 999 998 997 => valid AP => d=-1 => next=996\n        {1000, 999, 998, 997},\n        // 8) 999 1000 1000 999 => likely neither (check difference: +1 then 0 then -1; ratio doesn't hold)\n        {999, 1000, 1000, 999}\n    };\n\n    if (mode == \"corner\") {\n        // Output one of the corner cases\n        cornerIndex = max(0, min((int)cornerCases.size()-1, cornerIndex));\n        arr = cornerCases[cornerIndex];\n    }\n    else if (mode == \"ap\") {\n        // Generate a random arithmetic progression a1, a1+d, a1+2d, a1+3d in [1..maxVal].\n        // We'll attempt random a1, random d (can be negative, zero, or positive)\n        // and ensure the last element is still in range.\n\n        // We'll do up to 1000 tries to find something valid.\n        bool ok = false;\n        for (int _try = 0; _try < 1000 && !ok; _try++) {\n            int a1 = rnd.next(1, maxVal);\n            // Let d range from -1000..1000\n            int d = rnd.next(-1000, 1000);\n            // We want a1 + 3d in [1..maxVal].\n            int a2 = a1 + d;\n            int a3 = a1 + 2*d;\n            int a4 = a1 + 3*d;\n            if (a2 >= 1 && a2 <= maxVal &&\n                a3 >= 1 && a3 <= maxVal &&\n                a4 >= 1 && a4 <= maxVal) {\n                arr[0] = a1;\n                arr[1] = a2;\n                arr[2] = a3;\n                arr[3] = a4;\n                ok = true;\n            }\n        }\n        // In worst case, if no valid found (extremely unlikely), fallback to corner case #0.\n        if (!ok) {\n            arr = {1, 1, 1, 1};\n        }\n    }\n    else if (mode == \"gp\") {\n        // Generate a random integer-ratio geometric progression a1, a1*r, a1*r^2, a1*r^3 in [1..maxVal].\n        // ratio != 1, ratio != 0, ratio in [2..something].\n        bool ok = false;\n        for (int _try = 0; _try < 2000 && !ok; _try++) {\n            // choose ratio in [2..10] for variety\n            int r = rnd.next(2, 10);\n\n            // We want to pick a1 so that a1*r^3 <= maxVal and a1>=1\n            // So a1 <= floor(maxVal / (r^3)).\n            // We'll let a1 range within [1.. thatValue].\n            long long limit = (long long)maxVal;\n            long long denom = 1;\n            for (int i = 0; i < 3; i++) denom *= r;\n            if (denom > 0 && denom <= limit) {\n                long long upperA1 = limit / denom;\n                if (upperA1 >= 1) {\n                    int a1 = rnd.next(1, (int)upperA1);\n                    // construct\n                    long long a2 = (long long) a1 * r;\n                    long long a3 = a2 * r;\n                    long long a4 = a3 * r;\n                    // all must fit in [1..maxVal]\n                    if (a2 >= 1 && a2 <= maxVal &&\n                        a3 >= 1 && a3 <= maxVal &&\n                        a4 >= 1 && a4 <= maxVal) {\n                        arr[0] = a1;\n                        arr[1] = (int)a2;\n                        arr[2] = (int)a3;\n                        arr[3] = (int)a4;\n                        ok = true;\n                    }\n                }\n            }\n        }\n        // fallback if not found\n        if (!ok) {\n            arr = {1, 2, 4, 8}; // a known valid GP\n        }\n    }\n    else if (mode == \"neither\") {\n        // Generate 4 random numbers, ensure they're not a valid AP or valid GP\n        bool ok = false;\n        for (int attempt = 0; attempt < 2000 && !ok; attempt++) {\n            for (int i = 0; i < 4; i++) {\n                arr[i] = rnd.next(1, maxVal);\n            }\n            if (!isArithmetic(arr) && !isGeometric(arr)) {\n                ok = true;\n            }\n        }\n        // If we couldn't find it after many tries (extremely unlikely),\n        // forcibly create an obviously \"neither\" set.\n        if (!ok) {\n            // This set is not arithmetic: diffs are +1, then 0, then -1\n            // nor geometric with integer ratio\n            arr = {10, 11, 11, 10};\n        }\n    }\n    else {\n        // mode == \"random\" => any 4 random numbers in [1..maxVal].\n        for (int i = 0; i < 4; i++) {\n            arr[i] = rnd.next(1, maxVal);\n        }\n    }\n\n    // Output the 4 integers in one line\n    // The problem statement says \"The first line contains exactly four integers\".\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < 3) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are about 20+ sample commands that run this generator with various parameters.\n# Each command prints exactly one test of 4 integers on standard output.\n\n# 1) Corner cases (9 examples)\n./gen -mode corner -cornerIndex 0\n./gen -mode corner -cornerIndex 1\n./gen -mode corner -cornerIndex 2\n./gen -mode corner -cornerIndex 3\n./gen -mode corner -cornerIndex 4\n./gen -mode corner -cornerIndex 5\n./gen -mode corner -cornerIndex 6\n./gen -mode corner -cornerIndex 7\n./gen -mode corner -cornerIndex 8\n\n# 2) Random sets (no constraints), default maxVal=1000\n./gen -mode random\n./gen -mode random\n./gen -mode random\n\n# 3) Random arithmetic progressions with default maxVal=1000\n./gen -mode ap\n./gen -mode ap\n./gen -mode ap\n\n# 4) Random integer-ratio geometric progressions with default maxVal=1000\n./gen -mode gp\n./gen -mode gp\n./gen -mode gp\n\n# 5) Random \"neither\" sets with default maxVal=1000\n./gen -mode neither\n./gen -mode neither\n./gen -mode neither\n\n# 6) Lower maxVal for random sets, might produce smaller but tricky data\n./gen -mode random -maxVal 10\n./gen -mode ap -maxVal 10\n./gen -mode gp -maxVal 10\n./gen -mode neither -maxVal 10\n\n# 7) Larger maxVal for more variety\n./gen -mode random -maxVal 1000\n./gen -mode ap -maxVal 1000\n./gen -mode gp -maxVal 1000\n./gen -mode neither -maxVal 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:43.332600",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "328/B",
      "title": "Problem 328/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[0-9]{1,200}\", \"sequence\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[0-9]{1,200}\", \"sequence\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[0-9]{1,200}\", \"sequence\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1); // t between 1 and 10000\n    int n = opt<int>(\"n\", 1); // n between 1 and 200\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure t and n are within the constraints\n    t = max(1, min(t, 10000));\n    n = max(1, min(n, 200));\n\n    vector<int> pieces(n); // the sequence of digits\n\n    if (type == \"random\") {\n        // Generate n random digits between 0 and 9\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = rnd.next(10); // random number in [0,9]\n        }\n    }\n    else if (type == \"mimicry_max\") {\n        // Generate the pieces to maximize the number of instances of t using mimicry\n        string t_str = to_string(t);\n        vector<char> digits_for_t;\n        for (char c : t_str) {\n            // Add c and its mimic if any\n            digits_for_t.push_back(c);\n            if (c == '6') digits_for_t.push_back('9');\n            else if (c == '9') digits_for_t.push_back('6');\n            else if (c == '2') digits_for_t.push_back('5');\n            else if (c == '5') digits_for_t.push_back('2');\n        }\n        // Fill the pieces with digits_for_t\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = digits_for_t[rnd.next(digits_for_t.size())] - '0';\n        }\n    }\n    else if (type == \"mimicry_zero\") {\n        // Generate pieces that avoid the mimicry digits 2,5,6,9\n        vector<int> digits = {0,1,3,4,7,8};\n        for (int i =0; i < n; ++i) {\n            pieces[i] = digits[rnd.next(digits.size())];\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate pieces such that t cannot be formed\n        string t_str = to_string(t);\n        set<char> needed_digits(t_str.begin(), t_str.end());\n        // Remove one digit needed for t from the possible digits\n        char missing_digit = t_str[rnd.next(t_str.size())];\n\n        vector<char> digits_possible;\n        for (char c = '0'; c <= '9'; ++c) {\n            if (c != missing_digit) digits_possible.push_back(c);\n        }\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = digits_possible[rnd.next(digits_possible.size())] - '0';\n        }\n    }\n    else if (type == \"large_instances\") {\n        // Generate pieces to enable maximum instances of t\n        string t_str = to_string(t);\n        vector<char> digits_for_t;\n        for (char c : t_str) {\n            // Add c and its mimic if any\n            digits_for_t.push_back(c);\n            if (c == '6') digits_for_t.push_back('9');\n            else if (c == '9') digits_for_t.push_back('6');\n            else if (c == '2') digits_for_t.push_back('5');\n            else if (c == '5') digits_for_t.push_back('2');\n        }\n        // Fill the pieces with digits_for_t\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = digits_for_t[rnd.next(digits_for_t.size())] - '0';\n        }\n    }\n    else if (type == \"single_instance\") {\n        // Generate pieces to allow only one instance of t\n        string t_str = to_string(t);\n        vector<int> digits_needed;\n        for (char c : t_str) {\n            digits_needed.push_back(c - '0');\n        }\n        // Shuffle the digits needed\n        shuffle(digits_needed.begin(), digits_needed.end());\n        // Fill the pieces with digits needed for t, plus random digits\n        for (int i = 0; i < n; ++i) {\n            if (i < (int)digits_needed.size()) {\n                pieces[i] = digits_needed[i];\n            } else {\n                pieces[i] = rnd.next(10);\n            }\n        }\n        shuffle(pieces.begin(), pieces.end());\n    }\n    else {\n        // default: generate random digits\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = rnd.next(10); // random number in [0,9]\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", pieces[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1); // t between 1 and 10000\n    int n = opt<int>(\"n\", 1); // n between 1 and 200\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure t and n are within the constraints\n    t = max(1, min(t, 10000));\n    n = max(1, min(n, 200));\n\n    vector<int> pieces(n); // the sequence of digits\n\n    if (type == \"random\") {\n        // Generate n random digits between 0 and 9\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = rnd.next(10); // random number in [0,9]\n        }\n    }\n    else if (type == \"mimicry_max\") {\n        // Generate the pieces to maximize the number of instances of t using mimicry\n        string t_str = to_string(t);\n        vector<char> digits_for_t;\n        for (char c : t_str) {\n            // Add c and its mimic if any\n            digits_for_t.push_back(c);\n            if (c == '6') digits_for_t.push_back('9');\n            else if (c == '9') digits_for_t.push_back('6');\n            else if (c == '2') digits_for_t.push_back('5');\n            else if (c == '5') digits_for_t.push_back('2');\n        }\n        // Fill the pieces with digits_for_t\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = digits_for_t[rnd.next(digits_for_t.size())] - '0';\n        }\n    }\n    else if (type == \"mimicry_zero\") {\n        // Generate pieces that avoid the mimicry digits 2,5,6,9\n        vector<int> digits = {0,1,3,4,7,8};\n        for (int i =0; i < n; ++i) {\n            pieces[i] = digits[rnd.next(digits.size())];\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate pieces such that t cannot be formed\n        string t_str = to_string(t);\n        set<char> needed_digits(t_str.begin(), t_str.end());\n        // Remove one digit needed for t from the possible digits\n        char missing_digit = t_str[rnd.next(t_str.size())];\n\n        vector<char> digits_possible;\n        for (char c = '0'; c <= '9'; ++c) {\n            if (c != missing_digit) digits_possible.push_back(c);\n        }\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = digits_possible[rnd.next(digits_possible.size())] - '0';\n        }\n    }\n    else if (type == \"large_instances\") {\n        // Generate pieces to enable maximum instances of t\n        string t_str = to_string(t);\n        vector<char> digits_for_t;\n        for (char c : t_str) {\n            // Add c and its mimic if any\n            digits_for_t.push_back(c);\n            if (c == '6') digits_for_t.push_back('9');\n            else if (c == '9') digits_for_t.push_back('6');\n            else if (c == '2') digits_for_t.push_back('5');\n            else if (c == '5') digits_for_t.push_back('2');\n        }\n        // Fill the pieces with digits_for_t\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = digits_for_t[rnd.next(digits_for_t.size())] - '0';\n        }\n    }\n    else if (type == \"single_instance\") {\n        // Generate pieces to allow only one instance of t\n        string t_str = to_string(t);\n        vector<int> digits_needed;\n        for (char c : t_str) {\n            digits_needed.push_back(c - '0');\n        }\n        // Shuffle the digits needed\n        shuffle(digits_needed.begin(), digits_needed.end());\n        // Fill the pieces with digits needed for t, plus random digits\n        for (int i = 0; i < n; ++i) {\n            if (i < (int)digits_needed.size()) {\n                pieces[i] = digits_needed[i];\n            } else {\n                pieces[i] = rnd.next(10);\n            }\n        }\n        shuffle(pieces.begin(), pieces.end());\n    }\n    else {\n        // default: generate random digits\n        for (int i = 0; i < n; ++i) {\n            pieces[i] = rnd.next(10); // random number in [0,9]\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", pieces[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -n 1 -type random\n./gen -t 9999 -n 200 -type random\n./gen -t 69 -n 20 -type mimicry_max\n./gen -t 96 -n 20 -type mimicry_zero\n./gen -t 9998 -n 200 -type impossible\n./gen -t 9997 -n 200 -type impossible\n./gen -t 42 -n 50 -type large_instances\n./gen -t 4242 -n 200 -type large_instances\n./gen -t 99 -n 5 -type single_instance\n./gen -t 9999 -n 10 -type single_instance\n./gen -t 25 -n 20 -type mimicry_max\n./gen -t 258 -n 50 -type mimicry_max\n./gen -t 333 -n 200 -type large_instances\n./gen -t 6666 -n 200 -type large_instances\n./gen -t 123 -n 20 -type random\n./gen -t 4567 -n 100 -type random\n./gen -t 89 -n 15 -type impossible\n./gen -t 10000 -n 200 -type mimicry_zero\n./gen -t 1 -n 1 -type impossible\n./gen -t 8888 -n 200 -type mimicry_zero\n./gen -t 1234 -n 200 -type mimicry_max\n./gen -t 24 -n 100 -type single_instance\n./gen -t 9876 -n 200 -type random\n./gen -t 1111 -n 50 -type large_instances\n./gen -t 1212 -n 100 -type single_instance\n./gen -t 6969 -n 200 -type large_instances\n./gen -t 2525 -n 200 -type large_instances\n./gen -t 5432 -n 50 -type mimicry_zero\n./gen -t 7777 -n 100 -type large_instances\n./gen -t 2 -n 10 -type mimicry_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:45.077876",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "329/A",
      "title": "A. Purification",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line will contain a single integer n (1 ≤ n ≤ 100). Then, n lines follows, each contains n characters. The j-th character in the i-th row represents the cell located at row i and column j. It will be the character 'E' if it is a particularly more evil cell, and '.' otherwise.",
      "output_spec": "OutputIf there exists no way to purify all the cells, output -1. Otherwise, if your solution casts x \"Purification\" spells (where x is the minimum possible number of spells), output x lines. Each line should consist of two integers denoting the row and column numbers of the cell on which you should cast the \"Purification\" spell.",
      "sample_tests": "ExamplesInputCopy3.E.E.E.E.OutputCopy1 12 23 3InputCopy3EEEE..E.EOutputCopy-1InputCopy5EE.EEE.EE.E...E.EE.EEE.EEOutputCopy3 31 32 24 45 3",
      "description": "A. Purification\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line will contain a single integer n (1 ≤ n ≤ 100). Then, n lines follows, each contains n characters. The j-th character in the i-th row represents the cell located at row i and column j. It will be the character 'E' if it is a particularly more evil cell, and '.' otherwise.\n\nOutputIf there exists no way to purify all the cells, output -1. Otherwise, if your solution casts x \"Purification\" spells (where x is the minimum possible number of spells), output x lines. Each line should consist of two integers denoting the row and column numbers of the cell on which you should cast the \"Purification\" spell.\n\nInputCopy3.E.E.E.E.OutputCopy1 12 23 3InputCopy3EEEE..E.EOutputCopy-1InputCopy5EE.EEE.EE.E...E.EE.EEE.EEOutputCopy3 31 32 24 45 3\n\nInputCopy3.E.E.E.E.\n\nOutputCopy1 12 23 3\n\nInputCopy3EEEE..E.E\n\nOutputCopy-1\n\nInputCopy5EE.EEE.EE.E...E.EE.EEE.EE\n\nOutputCopy3 31 32 24 45 3\n\nNoteThe first example is illustrated as follows. Purple tiles are evil tiles that have not yet been purified. Red tile is the tile on which \"Purification\" is cast. Yellow tiles are the tiles being purified as a result of the current \"Purification\" spell. Green tiles are tiles that have been purified previously.   In the second example, it is impossible to purify the cell located at row 1 and column 1.For the third example:",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 329 和字母"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 329\\s*A"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == n, \"Line %d should contain exactly %d characters, but length is %d\", i + 1, n, int(s.length()));\n        for (int j = 0; j < n; ++j) {\n            char c = s[j];\n            ensuref(c == 'E' || c == '.', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1, c);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == n, \"Line %d should contain exactly %d characters, but length is %d\", i + 1, n, int(s.length()));\n        for (int j = 0; j < n; ++j) {\n            char c = s[j];\n            ensuref(c == 'E' || c == '.', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1, c);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == n, \"Line %d should contain exactly %d characters, but length is %d\", i + 1, n, int(s.length()));\n        for (int j = 0; j < n; ++j) {\n            char c = s[j];\n            ensuref(c == 'E' || c == '.', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1, c);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We will interpret the jury's solution (ans) as the official minimal solution.\n// Then we will compare the participant's solution (ouf) against it.\n\nstatic const int MAXN = 100;\nstatic bool jurPurified[MAXN][MAXN];\nstatic bool parPurified[MAXN][MAXN];\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read n and the grid\n    int n = inf.readInt(1, 100, \"n\");\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readToken();\n    }\n\n    // A helper function to apply the purification spells.\n    auto applyPurification = [&](bool purified[MAXN][MAXN],\n                                 const vector<pair<int,int>>& spells) {\n        // Initially nothing is purified\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                purified[i][j] = false;\n\n        for (auto &sp : spells) {\n            int r = sp.first, c = sp.second;\n            // Purify the row\n            for (int cc = 0; cc < n; cc++)\n                purified[r][cc] = true;\n            // Purify the column\n            for (int rr = 0; rr < n; rr++)\n                purified[rr][c] = true;\n        }\n    };\n\n    // A helper function to check if all cells are purified.\n    auto allPurified = [&](bool purified[MAXN][MAXN]) {\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                if (!purified[i][j]) return false;\n        return true;\n    };\n\n    // A helper to read an answer (spells) from a given stream, check basic correctness,\n    // and return the list of spells. If it is -1, return empty and interpret that as no solution.\n    // We do not finalize verdict here; we just collect data and let main logic handle verdict.\n    auto readSolution = [&](InStream& stream, bool isParticipant) -> vector<pair<int,int>> {\n        // Read first token\n        // either it must be \"-1\" or a valid integer (the row of the first spell)\n        // We do not strictly require they print the number of spells first, because\n        // the statement just says \"output x lines if solution, or -1 if no solution\".\n        // We'll handle that logic carefully.\n        stream.skipBlanks();\n        if (!stream.seekEof()) {\n            string firstToken = stream.readToken();\n            if (firstToken == \"-1\") {\n                // The solution indicates \"no way\"\n                // Return empty vector to represent no solution.\n                return {};\n            }\n            else {\n                // firstToken should represent a row index\n                // parse it as integer\n                int r = 0;\n                bool error = false;\n                try {\n                    r = stoi(firstToken);\n                } catch(...) {\n                    // parse error => reject\n                    stream.quitf(_wa, \"could not parse row of the first spell\");\n                }\n                // check valid row\n                if (r < 1 || r > n)\n                    stream.quitf(_wa, \"first row index out of bounds: %d\", r);\n\n                // Next, read the column index\n                if (stream.seekEof()) {\n                    stream.quitf(_wa, \"incomplete row-col pair for the first spell\");\n                }\n                int c = 0;\n                try {\n                    c = stoi(stream.readToken());\n                } catch(...) {\n                    stream.quitf(_wa, \"could not parse column of the first spell\");\n                }\n                if (c < 1 || c > n)\n                    stream.quitf(_wa, \"first column index out of bounds: %d\", c);\n\n                // We'll collect spells in a vector\n                vector<pair<int,int>> spells;\n                spells.push_back({r-1, c-1}); // store 0-based internally\n\n                // Now read the remaining lines until EOF or we can't parse further\n                while (!stream.seekEof()) {\n                    stream.skipBlanks();\n                    if (stream.seekEof()) break;\n                    // Attempt to parse next row, col\n                    string sr = stream.readToken();\n                    if (sr.empty()) break;\n                    int rr = 0;\n                    try {\n                        rr = stoi(sr);\n                    } catch(...) {\n                        stream.quitf(_wa, \"could not parse row index\");\n                    }\n                    if (rr < 1 || rr > n)\n                        stream.quitf(_wa, \"row index out of bounds: %d\", rr);\n\n                    if (stream.seekEof()) {\n                        stream.quitf(_wa, \"incomplete row-col pair in spells list\");\n                    }\n                    string sc = stream.readToken();\n                    int cc=0;\n                    try {\n                        cc = stoi(sc);\n                    } catch(...) {\n                        stream.quitf(_wa, \"could not parse column index\");\n                    }\n                    if (cc < 1 || cc > n)\n                        stream.quitf(_wa, \"column index out of bounds: %d\", cc);\n\n                    spells.push_back({rr-1, cc-1});\n                }\n                // Return that spells vector\n                return spells;\n            }\n        }\n        else {\n            // If there's no token, that means participant output is empty => interpret as no solution\n            return {};\n        }\n    };\n\n    // Read official solution\n    vector<pair<int,int>> jurSpells = readSolution(ans, /*isParticipant=*/false);\n    bool juryNoSolution = jurSpells.empty();\n\n    // Check if official solution is truly correct or not. If it claims no solution, we accept that as final\n    // unless participant proves there's a solution. If it provides a solution, we verify correctness.\n    int jurSpellCount = (int)jurSpells.size();\n    bool juryAllPurified = false;\n\n    if (!juryNoSolution) {\n        // Verify that no spells are cast on 'E'\n        // and apply them to see if indeed all cells are purified\n        for (auto &sp : jurSpells) {\n            // sp is 0-based\n            int r = sp.first, c = sp.second;\n            if (grid[r][c] == 'E') {\n                ans.quitf(_fail, \"jury casts purification on an 'E' cell at (%d,%d)\", r+1, c+1);\n            }\n        }\n        applyPurification(jurPurified, jurSpells);\n        // check if all purified\n        juryAllPurified = allPurified(jurPurified);\n        if (!juryAllPurified) {\n            ans.quitf(_fail,\"jury's solution does not purify all cells\");\n        }\n    }\n\n    // Read participant's solution\n    vector<pair<int,int>> parSpells = readSolution(ouf, /*isParticipant=*/true);\n    bool participantNoSolution = parSpells.empty();\n\n    // If the jury claims NO solution:\n    if (juryNoSolution) {\n        // If participant also claims no solution => _ok\n        if (participantNoSolution) {\n            quitf(_ok, \"both claim no solution\");\n        }\n        else {\n            // The participant claims some solution. Let's check validity\n            // If the participant's solution is valid, we do _fail\n            // If it's invalid, we do _wa\n            // Because the jury insists there's no solution, but participant found one\n            // => if participant's solution is actually correct, then jury solution is flawed => _fail\n            // => else _wa\n            // First, check if they cast on any 'E'\n            for (auto &sp : parSpells) {\n                if (grid[sp.first][sp.second] == 'E') {\n                    quitf(_wa, \"casted purification on an 'E' cell at (%d,%d)\", sp.first+1, sp.second+1);\n                }\n            }\n            applyPurification(parPurified, parSpells);\n            if (!allPurified(parPurified)) {\n                quitf(_wa, \"participant's solution does not purify all cells\");\n            }\n            // If we get here, the participant DID purify all => jury is incorrect\n            quitf(_fail, \"jury said no solution, but participant found one\");\n        }\n    }\n    else {\n        // The jury solution is a valid solution that purifies everything in jurSpellCount spells\n        // If participant says no solution => that is definitely wrong\n        if (participantNoSolution) {\n            quitf(_wa, \"participant claims no solution but jury found one\");\n        }\n        else {\n            // The participant found a solution. Check correctness\n            // 1) no cast on 'E'\n            for (auto &sp : parSpells) {\n                if (grid[sp.first][sp.second] == 'E') {\n                    quitf(_wa, \"casted purification on an 'E' cell at (%d,%d)\", sp.first+1, sp.second+1);\n                }\n            }\n            // 2) apply it, check if all purified\n            applyPurification(parPurified, parSpells);\n            if (!allPurified(parPurified)) {\n                quitf(_wa, \"participant's solution does not purify all cells\");\n            }\n            // 3) compare participant's number of spells to jury's\n            int parCount = (int)parSpells.size();\n            if (parCount > jurSpellCount) {\n                // More spells => not minimal => WA\n                quitf(_wa, \"participant uses more spells than the jury's minimal solution\");\n            }\n            else if (parCount < jurSpellCount) {\n                // Less spells => the jury solution was not minimal => _fail\n                quitf(_fail, \"the participant's solution uses fewer spells than the jury's solution\");\n            }\n            else {\n                // parCount == jurSpellCount => OK\n                quitf(_ok, \"both solutions are valid and use %d spells\", parCount);\n            }\n        }\n    }\n\n    // Should never reach here\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"random\") {\n        // Generate a random grid with specified 'E' density\n        double density = opt<double>(\"density\", 0.5); // default 50% 'E's if not specified\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = rnd.next(0.0, 1.0) < density ? 'E' : '.';\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Create a grid where it's impossible to purify all cells (e.g., cell (0,0) cannot be purified)\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = 'E';\n            grid[0][i] = 'E';\n        }\n        // Fill the rest of the grid randomly\n        for (int i = 1; i < n; ++i)\n            for (int j = 1; j < n; ++j)\n                grid[i][j] = rnd.next(0, 1) ? 'E' : '.';\n    } else if (type == \"max_moves\") {\n        // A grid where the minimal number of spells is n\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'E');\n            grid[i][i] = '.'; // Only the main diagonal cells can be used to cast the spell\n        }\n    } else if (type == \"min_moves\") {\n        // A grid where all cells are '.' and can be purified with minimal spells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, '.');\n    } else if (type == \"sparse_E\") {\n        // Generate a grid with a few 'E's placed randomly\n        int e_count = opt<int>(\"e_count\", 1);\n        set<pair<int,int>> positions;\n        while (positions.size() < e_count) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, n - 1);\n            positions.insert({i, j});\n        }\n        for (auto [i, j] : positions)\n            grid[i][j] = 'E';\n    } else if (type == \"dense_E\") {\n        // Generate a grid with many 'E's\n        int e_count = opt<int>(\"e_count\", n * n - 1);\n        vector<int> positions(n * n);\n        iota(positions.begin(), positions.end(), 0);\n        shuffle(positions.begin(), positions.end());\n        for (int idx = 0; idx < e_count; ++idx) {\n            int pos = positions[idx];\n            int i = pos / n;\n            int j = pos % n;\n            grid[i][j] = 'E';\n        }\n    } else if (type == \"edge_case_n1\") {\n        // Grid with n = 1\n        grid[0][0] = '.'; // Only one cell\n    } else if (type == \"edge_case_n100\") {\n        // Grid with n = 100, all cells are '.'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, '.');\n    } else if (type == \"only_E\") {\n        // All cells are 'E'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, 'E');\n    } else if (type == \"checkerboard\") {\n        // Generate a checkerboard pattern of 'E's and '.'\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? '.' : 'E';\n    } else if (type == \"row_of_E\") {\n        // Generate a grid with one full row of 'E's\n        int row = opt<int>(\"row\", 0);\n        for (int i = 0; i < n; ++i)\n            grid[row][i] = 'E';\n    } else if (type == \"column_of_E\") {\n        // Generate a grid with one full column of 'E's\n        int col = opt<int>(\"col\", 0);\n        for (int i = 0; i < n; ++i)\n            grid[i][col] = 'E';\n    } else {\n        // Default to random grid if unknown type\n        double density = opt<double>(\"density\", 0.5);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(0.0, 1.0) < density ? 'E' : '.';\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"random\") {\n        // Generate a random grid with specified 'E' density\n        double density = opt<double>(\"density\", 0.5); // default 50% 'E's if not specified\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                grid[i][j] = rnd.next(0.0, 1.0) < density ? 'E' : '.';\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Create a grid where it's impossible to purify all cells (e.g., cell (0,0) cannot be purified)\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = 'E';\n            grid[0][i] = 'E';\n        }\n        // Fill the rest of the grid randomly\n        for (int i = 1; i < n; ++i)\n            for (int j = 1; j < n; ++j)\n                grid[i][j] = rnd.next(0, 1) ? 'E' : '.';\n    } else if (type == \"max_moves\") {\n        // A grid where the minimal number of spells is n\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'E');\n            grid[i][i] = '.'; // Only the main diagonal cells can be used to cast the spell\n        }\n    } else if (type == \"min_moves\") {\n        // A grid where all cells are '.' and can be purified with minimal spells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, '.');\n    } else if (type == \"sparse_E\") {\n        // Generate a grid with a few 'E's placed randomly\n        int e_count = opt<int>(\"e_count\", 1);\n        set<pair<int,int>> positions;\n        while (positions.size() < e_count) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, n - 1);\n            positions.insert({i, j});\n        }\n        for (auto [i, j] : positions)\n            grid[i][j] = 'E';\n    } else if (type == \"dense_E\") {\n        // Generate a grid with many 'E's\n        int e_count = opt<int>(\"e_count\", n * n - 1);\n        vector<int> positions(n * n);\n        iota(positions.begin(), positions.end(), 0);\n        shuffle(positions.begin(), positions.end());\n        for (int idx = 0; idx < e_count; ++idx) {\n            int pos = positions[idx];\n            int i = pos / n;\n            int j = pos % n;\n            grid[i][j] = 'E';\n        }\n    } else if (type == \"edge_case_n1\") {\n        // Grid with n = 1\n        grid[0][0] = '.'; // Only one cell\n    } else if (type == \"edge_case_n100\") {\n        // Grid with n = 100, all cells are '.'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, '.');\n    } else if (type == \"only_E\") {\n        // All cells are 'E'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, 'E');\n    } else if (type == \"checkerboard\") {\n        // Generate a checkerboard pattern of 'E's and '.'\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? '.' : 'E';\n    } else if (type == \"row_of_E\") {\n        // Generate a grid with one full row of 'E's\n        int row = opt<int>(\"row\", 0);\n        for (int i = 0; i < n; ++i)\n            grid[row][i] = 'E';\n    } else if (type == \"column_of_E\") {\n        // Generate a grid with one full column of 'E's\n        int col = opt<int>(\"col\", 0);\n        for (int i = 0; i < n; ++i)\n            grid[i][col] = 'E';\n    } else {\n        // Default to random grid if unknown type\n        double density = opt<double>(\"density\", 0.5);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(0.0, 1.0) < density ? 'E' : '.';\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type edge_case_n1\n\n./gen -n 2 -type only_E\n\n./gen -n 3 -type random -density 0.3\n./gen -n 3 -type random -density 0.7\n\n./gen -n 4 -type impossible\n\n./gen -n 5 -type checkerboard\n\n./gen -n 6 -type max_moves\n\n./gen -n 7 -type min_moves\n\n./gen -n 8 -type sparse_E -e_count 5\n\n./gen -n 9 -type dense_E -e_count 70\n\n./gen -n 10 -type random -density 0.5\n\n./gen -n 12 -type row_of_E -row 0\n\n./gen -n 13 -type column_of_E -col 0\n\n./gen -n 14 -type column_of_E -col 13\n\n./gen -n 15 -type row_of_E -row 14\n\n./gen -n 20 -type impossible\n\n./gen -n 30 -type random -density 0.4\n\n./gen -n 40 -type checkerboard\n\n./gen -n 50 -type random -density 0.3\n\n./gen -n 60 -type sparse_E -e_count 10\n\n./gen -n 70 -type dense_E -e_count 4900\n\n./gen -n 80 -type max_moves\n\n./gen -n 90 -type min_moves\n\n./gen -n 100 -type edge_case_n100\n\n./gen -n 100 -type dense_E -e_count 9999\n\n./gen -n 100 -type sparse_E -e_count 1\n\n./gen -n 100 -type random -density 0.05\n\n./gen -n 100 -type random -density 0.95\n\n./gen -n 100 -type impossible\n\n./gen -n 100 -type max_moves\n\n./gen -n 100 -type min_moves\n\n./gen -n 100 -type checkerboard\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:47.335975",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "329/B",
      "title": "B. Биридианский лес",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа: r и c (1 ≤ r, c ≤ 1000), обозначающих количества строк и столбцов в Биридианском лесу. В следующих r строках записано по строке карты, где каждый символ представляет содержимое соответствующей ячейки:   'T': Ячейка, содержащая дерево.  'S': Пустая ячейка и Ваша начальная позиция. Эта ячейка встретится на карте ровно один раз.  'E': Пустая ячейка, содержащая выход. Эта ячейка встретится на карте ровно один раз.  Цифра (0-9): Ячейка, содержащая цифру X обозначает, что ячейка пустая и в ней стоят X разводчиков (если X равняется нулю, это значит, что ячейка не занята ни одним разводчиком). Гарантируется, что Вы можете дойти от начальной позиции до ячейки выхода.",
      "output_spec": "Выходные данныеВ единственной строке выведите минимально возможное количество битв микемонов, в которых Вам придется принять участие, если Вы выберете стратегию минимизации количества битв микемонов.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 7000E0T3T0TT0T0010T0T02T0T0T00T0S000Выходные данныеСкопировать3Входные данныеСкопировать1 4SE23Выходные данныеСкопировать2",
      "description": "B. Биридианский лес\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа: r и c (1 ≤ r, c ≤ 1000), обозначающих количества строк и столбцов в Биридианском лесу. В следующих r строках записано по строке карты, где каждый символ представляет содержимое соответствующей ячейки:   'T': Ячейка, содержащая дерево.  'S': Пустая ячейка и Ваша начальная позиция. Эта ячейка встретится на карте ровно один раз.  'E': Пустая ячейка, содержащая выход. Эта ячейка встретится на карте ровно один раз.  Цифра (0-9): Ячейка, содержащая цифру X обозначает, что ячейка пустая и в ней стоят X разводчиков (если X равняется нулю, это значит, что ячейка не занята ни одним разводчиком). Гарантируется, что Вы можете дойти от начальной позиции до ячейки выхода.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите минимально возможное количество битв микемонов, в которых Вам придется принять участие, если Вы выберете стратегию минимизации количества битв микемонов.\n\nВыходные данные\n\nВходные данныеСкопировать5 7000E0T3T0TT0T0010T0T02T0T0T00T0S000Выходные данныеСкопировать3Входные данныеСкопировать1 4SE23Выходные данныеСкопировать2\n\nВходные данныеСкопировать5 7000E0T3T0TT0T0010T0T02T0T0T00T0S000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 4SE23\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеСледующий рисунок иллюстрирует первый пример. Возможная последовательность движений, которую надо опубликовать в блоге, такова:  С Вами смогут сразиться три разводчика с левой стороны карты — одинокий разводчик может просто стоять на месте, пока Вы не подойдете, а два других разводчика могут двигаться к одинокому и стоять с ним, поджидая Вас. У трех разводчиков справа не будет возможности сразиться с Вами, и они будут стоять на месте.Для второго примера надо опубликовать следующую последовательность в блоге:  Случается вот что. Сначала надо шагнуть на ячейку вправо.  Затем, два разводчика правее Вас одновременно шагнут навстречу Вам. Остальные три разводчика не могу с Вами сразиться, поэтому не делают ничего.  Вы находитесь в одной клетке с 2 разводчиками, а значит тут же случится 2 битвы микемонов. После этих битв Ваши противники покинут лес.  И наконец, надо сделать еще один шаг и выйти из леса.",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: разборUPD:D2: 500 1000 1500 2000 2500D1: 500 1000 1500 1500 2500UPD: Важно: контест проводится в необычное время! http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166Привет!После шквала нестандартных соревнований (memSQL, ABBYY, Yandex), мы представляем вам стандартный, забавный (и странный) раунд Codeforces. Этот раунд подготовлен группой авторов из Индонезии: fushar, jonathanirvings, и я (dolphinigle)! fushar готовил D2-E/D1-C, jonathanirvings готовил D2-B, остальное делал я. Для меня — это мой четвертый раунд после Codeforces Beta Round 87 (Div. 1 Only), Чемпионат КРОК 2012 - Финал, и раунда на прошлой неделе MemSQL start[c]up Round 1 (там была только одна моя задача). Мы также хотим поблагодарить Gerald за помощь с контестом, Delinur за перевод, и MikeMirzayanov за систему!Мне кажется, что этот контест более странный, чем обычные контесты — условия странные, куча картинок везде и тому подобное. Есть даже одна задача с очень длинным условием (к сожалению, я не могу сделать его короче не теряя сути условия). Остальные задачи имеют короткие условия.fushar оставил для вас сообщение:Мы думаем, что решения всех задач очень интересные для \"придумывания\". Вам может показаться, что решения задач не такие-то \"обыкновенные\".Приятного решения задач!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1319
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 329\\s*B"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "if(clock()>2800000.){\n\tputs(\"-1\");\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "if(clock()>2800000.){\n\tputs(\"-1\");\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 17",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 18",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n    vector<string> grid(r);\n    int sCount = 0, eCount = 0;\n    int sx = -1, sy = -1, ex = -1, ey = -1;\n    for (int i = 0; i < r; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == c, \"Row %d length is %d, should be %d\", i+1, int(grid[i].length()), c);\n        for (int j = 0; j < c; j++) {\n            char ch = grid[i][j];\n            ensuref(ch == 'T' || ch == 'S' || ch == 'E' || ('0' <= ch && ch <= '9'), \n                    \"Invalid character '%c' at position (%d, %d)\", ch, i+1, j+1);\n            if (ch == 'S') {\n                sCount++;\n                sx = i; sy = j;\n            }\n            if (ch == 'E') {\n                eCount++;\n                ex = i; ey = j;\n            }\n        }\n    }\n    ensuref(sCount == 1, \"Number of starting positions 'S' is %d, should be 1\", sCount);\n    ensuref(eCount == 1, \"Number of exit positions 'E' is %d, should be 1\", eCount);\n\n    // Now check that E is reachable from S\n\n    vector<vector<bool>> visited(r, vector<bool>(c, false));\n    queue<pair<int, int>> q;\n    q.push({sx, sy});\n    visited[sx][sy] = true;\n    int dx[] = { -1, 1, 0, 0 };\n    int dy[] = { 0, 0, -1, 1 };\n    while (!q.empty()) {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        if (x == ex && y == ey) {\n            break;\n        }\n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (0 <= nx && nx < r && 0 <= ny && ny < c) {\n                if (!visited[nx][ny] && grid[nx][ny] != 'T') {\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    ensuref(visited[ex][ey], \"Exit 'E' is not reachable from starting position 'S'\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n    vector<string> grid(r);\n    int sCount = 0, eCount = 0;\n    int sx = -1, sy = -1, ex = -1, ey = -1;\n    for (int i = 0; i < r; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == c, \"Row %d length is %d, should be %d\", i+1, int(grid[i].length()), c);\n        for (int j = 0; j < c; j++) {\n            char ch = grid[i][j];\n            ensuref(ch == 'T' || ch == 'S' || ch == 'E' || ('0' <= ch && ch <= '9'), \n                    \"Invalid character '%c' at position (%d, %d)\", ch, i+1, j+1);\n            if (ch == 'S') {\n                sCount++;\n                sx = i; sy = j;\n            }\n            if (ch == 'E') {\n                eCount++;\n                ex = i; ey = j;\n            }\n        }\n    }\n    ensuref(sCount == 1, \"Number of starting positions 'S' is %d, should be 1\", sCount);\n    ensuref(eCount == 1, \"Number of exit positions 'E' is %d, should be 1\", eCount);\n\n    // Now check that E is reachable from S\n\n    vector<vector<bool>> visited(r, vector<bool>(c, false));\n    queue<pair<int, int>> q;\n    q.push({sx, sy});\n    visited[sx][sy] = true;\n    int dx[] = { -1, 1, 0, 0 };\n    int dy[] = { 0, 0, -1, 1 };\n    while (!q.empty()) {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        if (x == ex && y == ey) {\n            break;\n        }\n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (0 <= nx && nx < r && 0 <= ny && ny < c) {\n                if (!visited[nx][ny] && grid[nx][ny] != 'T') {\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    ensuref(visited[ex][ey], \"Exit 'E' is not reachable from starting position 'S'\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n    vector<string> grid(r);\n    int sCount = 0, eCount = 0;\n    int sx = -1, sy = -1, ex = -1, ey = -1;\n    for (int i = 0; i < r; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == c, \"Row %d length is %d, should be %d\", i+1, int(grid[i].length()), c);\n        for (int j = 0; j < c; j++) {\n            char ch = grid[i][j];\n            ensuref(ch == 'T' || ch == 'S' || ch == 'E' || ('0' <= ch && ch <= '9'), \n                    \"Invalid character '%c' at position (%d, %d)\", ch, i+1, j+1);\n            if (ch == 'S') {\n                sCount++;\n                sx = i; sy = j;\n            }\n            if (ch == 'E') {\n                eCount++;\n                ex = i; ey = j;\n            }\n        }\n    }\n    ensuref(sCount == 1, \"Number of starting positions 'S' is %d, should be 1\", sCount);\n    ensuref(eCount == 1, \"Number of exit positions 'E' is %d, should be 1\", eCount);\n\n    // Now check that E is reachable from S\n\n    vector<vector<bool>> visited(r, vector<bool>(c, false));\n    queue<pair<int, int>> q;\n    q.push({sx, sy});\n    visited[sx][sy] = true;\n    int dx[] = { -1, 1, 0, 0 };\n    int dy[] = { 0, 0, -1, 1 };\n    while (!q.empty()) {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        if (x == ex && y == ey) {\n            break;\n        }\n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (0 <= nx && nx < r && 0 <= ny && ny < c) {\n                if (!visited[nx][ny] && grid[nx][ny] != 'T') {\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    ensuref(visited[ex][ey], \"Exit 'E' is not reachable from starting position 'S'\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid createPath(vector<string>& grid, int sy, int sx, int ey, int ex) {\n    int r = grid.size();\n    int c = grid[0].size();\n    int y = sy, x = sx;\n    grid[y][x] = 'S';\n    while (y != ey || x != ex) {\n        int dy = 0, dx = 0;\n        if (y != ey) dy = (ey > y) ? 1 : -1;\n        else dy = 0;\n        if (x != ex) dx = (ex > x) ? 1 : -1;\n        else dx = 0;\n        // Randomly choose to move in y or x direction\n        if (dy != 0 && dx != 0) {\n            if (rnd.next(2)) dy = 0; // 50% chance to choose x or y direction\n            else dx = 0;\n        }\n        y += dy;\n        x += dx;\n        if (grid[y][x] == 'T') grid[y][x] = '0'; // Clear the path\n    }\n    grid[ey][ex] = 'E';\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(r, string(c, '0'));\n\n    // Positions of 'S' and 'E'\n    int sy, sx;\n    int ey, ex;\n\n    if (type == \"random\") {\n        // Random 'S' and 'E'\n        sy = rnd.next(0, r - 1);\n        sx = rnd.next(0, c - 1);\n        do {\n            ey = rnd.next(0, r - 1);\n            ex = rnd.next(0, c - 1);\n        } while (ey == sy && ex == sx);\n\n        // Initialize grid with random 'T's and digits\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, 'T');\n            for (int j = 0; j < c; ++j) {\n                int t = rnd.next(100);\n                if (t < 70) grid[i][j] = '0' + rnd.next(0, 9); // 70% digits\n                else if (t < 85) grid[i][j] = '0'; // 15% empty\n                // else 'T' remains\n            }\n        }\n\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"max_breeders\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        // Initialize grid with '9's\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '9');\n        }\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"no_breeders\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '0');\n        }\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"dense_obstacles\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, 'T');\n        }\n        int y = sy, x = sx;\n        while (y != ey || x != ex) {\n            grid[y][x] = '0'; // Empty path\n            if (y < ey) y++;\n            else if (x < ex) x++;\n            else break;\n        }\n        grid[ey][ex] = 'E';\n    } else if (type == \"empty\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        // Initialize grid with '0's\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '0');\n        }\n        grid[sy][sx] = 'S';\n        grid[ey][ex] = 'E';\n\n    } else if (type == \"path_with_breeders\") {\n        sy = 0; sx = 0;\n        ey = min(r - 1, c - 1); ex = ey; // Diagonal\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, 'T');\n        }\n        int y = sy, x = sx;\n        grid[y][x] = 'S';\n        while (y != ey || x != ex) {\n            if (grid[y][x] != 'S') grid[y][x] = '1'; // Breeder\n            if (y < ey) y++;\n            if (x < ex) x++;\n        }\n        grid[ey][ex] = 'E';\n\n    } else if (type == \"isolated_breeders\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '0');\n        }\n        grid[sy][sx] = 'S';\n        grid[ey][ex] = 'E';\n        int num_isolated = min(5, r * c / 10);\n        for (int k = 0; k < num_isolated; ++k) {\n            int y = rnd.next(0, r - 1);\n            int x = rnd.next(0, c - 1);\n            grid[y][x] = '1';\n            for (int dy = -1; dy <= 1; ++dy)\n                for (int dx = -1; dx <= 1; ++dx) {\n                    int ny = y + dy;\n                    int nx = x + dx;\n                    if (ny >= 0 && ny < r && nx >= 0 && nx < c && !(ny == y && nx == x)) {\n                        if (grid[ny][nx] != 'S' && grid[ny][nx] != 'E') {\n                            grid[ny][nx] = 'T';\n                        }\n                    }\n                }\n        }\n\n    } else if (type == \"max_battles\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '9');\n        }\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"small\") {\n        r = min(r, 2);\n        c = min(c, 2);\n        grid.resize(r);\n        for (int i = 0; i < r; ++i) grid[i] = string(c, '0');\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        grid[sy][sx] = 'S';\n        grid[ey][ex] = 'E';\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", r, c);\n    for (int i = 0; i < r; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid createPath(vector<string>& grid, int sy, int sx, int ey, int ex) {\n    int r = grid.size();\n    int c = grid[0].size();\n    int y = sy, x = sx;\n    grid[y][x] = 'S';\n    while (y != ey || x != ex) {\n        int dy = 0, dx = 0;\n        if (y != ey) dy = (ey > y) ? 1 : -1;\n        else dy = 0;\n        if (x != ex) dx = (ex > x) ? 1 : -1;\n        else dx = 0;\n        // Randomly choose to move in y or x direction\n        if (dy != 0 && dx != 0) {\n            if (rnd.next(2)) dy = 0; // 50% chance to choose x or y direction\n            else dx = 0;\n        }\n        y += dy;\n        x += dx;\n        if (grid[y][x] == 'T') grid[y][x] = '0'; // Clear the path\n    }\n    grid[ey][ex] = 'E';\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(r, string(c, '0'));\n\n    // Positions of 'S' and 'E'\n    int sy, sx;\n    int ey, ex;\n\n    if (type == \"random\") {\n        // Random 'S' and 'E'\n        sy = rnd.next(0, r - 1);\n        sx = rnd.next(0, c - 1);\n        do {\n            ey = rnd.next(0, r - 1);\n            ex = rnd.next(0, c - 1);\n        } while (ey == sy && ex == sx);\n\n        // Initialize grid with random 'T's and digits\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, 'T');\n            for (int j = 0; j < c; ++j) {\n                int t = rnd.next(100);\n                if (t < 70) grid[i][j] = '0' + rnd.next(0, 9); // 70% digits\n                else if (t < 85) grid[i][j] = '0'; // 15% empty\n                // else 'T' remains\n            }\n        }\n\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"max_breeders\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        // Initialize grid with '9's\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '9');\n        }\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"no_breeders\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '0');\n        }\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"dense_obstacles\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, 'T');\n        }\n        int y = sy, x = sx;\n        while (y != ey || x != ex) {\n            grid[y][x] = '0'; // Empty path\n            if (y < ey) y++;\n            else if (x < ex) x++;\n            else break;\n        }\n        grid[ey][ex] = 'E';\n    } else if (type == \"empty\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        // Initialize grid with '0's\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '0');\n        }\n        grid[sy][sx] = 'S';\n        grid[ey][ex] = 'E';\n\n    } else if (type == \"path_with_breeders\") {\n        sy = 0; sx = 0;\n        ey = min(r - 1, c - 1); ex = ey; // Diagonal\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, 'T');\n        }\n        int y = sy, x = sx;\n        grid[y][x] = 'S';\n        while (y != ey || x != ex) {\n            if (grid[y][x] != 'S') grid[y][x] = '1'; // Breeder\n            if (y < ey) y++;\n            if (x < ex) x++;\n        }\n        grid[ey][ex] = 'E';\n\n    } else if (type == \"isolated_breeders\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '0');\n        }\n        grid[sy][sx] = 'S';\n        grid[ey][ex] = 'E';\n        int num_isolated = min(5, r * c / 10);\n        for (int k = 0; k < num_isolated; ++k) {\n            int y = rnd.next(0, r - 1);\n            int x = rnd.next(0, c - 1);\n            grid[y][x] = '1';\n            for (int dy = -1; dy <= 1; ++dy)\n                for (int dx = -1; dx <= 1; ++dx) {\n                    int ny = y + dy;\n                    int nx = x + dx;\n                    if (ny >= 0 && ny < r && nx >= 0 && nx < c && !(ny == y && nx == x)) {\n                        if (grid[ny][nx] != 'S' && grid[ny][nx] != 'E') {\n                            grid[ny][nx] = 'T';\n                        }\n                    }\n                }\n        }\n\n    } else if (type == \"max_battles\") {\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        for (int i = 0; i < r; ++i) {\n            grid[i] = string(c, '9');\n        }\n        createPath(grid, sy, sx, ey, ex);\n\n    } else if (type == \"small\") {\n        r = min(r, 2);\n        c = min(c, 2);\n        grid.resize(r);\n        for (int i = 0; i < r; ++i) grid[i] = string(c, '0');\n        sy = 0; sx = 0;\n        ey = r - 1; ex = c - 1;\n        grid[sy][sx] = 'S';\n        grid[ey][ex] = 'E';\n\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", r, c);\n    for (int i = 0; i < r; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -r 5 -c 7 -type random\n./gen -r 1 -c 4 -type random\n./gen -r 10 -c 10 -type random\n./gen -r 50 -c 50 -type random\n./gen -r 100 -c 100 -type random\n./gen -r 500 -c 500 -type random\n./gen -r 1000 -c 1000 -type random\n\n./gen -r 5 -c 7 -type max_breeders\n./gen -r 1000 -c 1000 -type max_breeders\n\n./gen -r 5 -c 7 -type no_breeders\n./gen -r 1000 -c 1000 -type no_breeders\n\n./gen -r 5 -c 7 -type dense_obstacles\n./gen -r 1000 -c 1000 -type dense_obstacles\n\n./gen -r 5 -c 7 -type empty\n./gen -r 1000 -c 1000 -type empty\n\n./gen -r 5 -c 7 -type path_with_breeders\n./gen -r 1000 -c 1000 -type path_with_breeders\n\n./gen -r 5 -c 7 -type isolated_breeders\n./gen -r 1000 -c 1000 -type isolated_breeders\n\n./gen -r 5 -c 7 -type max_battles\n./gen -r 1000 -c 1000 -type max_battles\n\n./gen -r 1 -c 1 -type small\n./gen -r 2 -c 2 -type small\n\n./gen -r 5 -c 5 -type random\n./gen -r 10 -c 10 -type path_with_breeders\n./gen -r 20 -c 20 -type dense_obstacles\n./gen -r 1000 -c 1000 -type max_battles\n./gen -r 1000 -c 1000 -type empty\n\n./gen -r 999 -c 1000 -type random\n./gen -r 1000 -c 999 -type random\n./gen -r 1000 -c 1000 -type random\n./gen -r 500 -c 1000 -type path_with_breeders\n./gen -r 1000 -c 500 -type isolated_breeders\n./gen -r 1000 -c 1000 -type no_breeders\n./gen -r 1000 -c 1000 -type dense_obstacles\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:49.014799",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "329/C",
      "title": "C. Graph Reconstruction",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line consists of two space-separated integers: n and m (1 ≤ m ≤ n ≤ 105), denoting the number of nodes and edges, respectively. Then m lines follow. Each of the m lines consists of two space-separated integers u and v (1 ≤ u, v ≤ n; u ≠ v), denoting an edge between nodes u and v.",
      "output_spec": "OutputIf it is not possible to construct a new graph with the mentioned properties, output a single line consisting of -1. Otherwise, output exactly m lines. Each line should contain a description of edge in the same way as used in the input format.",
      "sample_tests": "ExamplesInputCopy8 71 22 34 55 66 88 77 4OutputCopy1 44 61 62 77 58 52 8InputCopy3 21 22 3OutputCopy-1InputCopy5 41 22 33 44 1OutputCopy1 33 55 22 4",
      "description": "C. Graph Reconstruction\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line consists of two space-separated integers: n and m (1 ≤ m ≤ n ≤ 105), denoting the number of nodes and edges, respectively. Then m lines follow. Each of the m lines consists of two space-separated integers u and v (1 ≤ u, v ≤ n; u ≠ v), denoting an edge between nodes u and v.\n\nOutputIf it is not possible to construct a new graph with the mentioned properties, output a single line consisting of -1. Otherwise, output exactly m lines. Each line should contain a description of edge in the same way as used in the input format.\n\nInputCopy8 71 22 34 55 66 88 77 4OutputCopy1 44 61 62 77 58 52 8InputCopy3 21 22 3OutputCopy-1InputCopy5 41 22 33 44 1OutputCopy1 33 55 22 4\n\nInputCopy8 71 22 34 55 66 88 77 4\n\nOutputCopy1 44 61 62 77 58 52 8\n\nInputCopy3 21 22 3\n\nOutputCopy-1\n\nInputCopy5 41 22 33 44 1\n\nOutputCopy1 33 55 22 4\n\nNoteThe old graph of the first example:A possible new graph for the first example:In the second example, we cannot create any new graph.The old graph of the third example:A possible new graph for the third example:",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 329 和字母"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 329\\s*C"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> degree(n + 1, 0);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge connects a node to itself (u = v = %d) on line %d\", u, i + 2);\n\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edges.find(edge) == edges.end(),\n                \"Duplicate edge between nodes %d and %d on line %d\", u, v, i + 2);\n        edges.insert(edge);\n\n        degree[u]++;\n        ensuref(degree[u] <= 2, \"Node %d has more than two incident edges\", u);\n\n        degree[v]++;\n        ensuref(degree[v] <= 2, \"Node %d has more than two incident edges\", v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> degree(n + 1, 0);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge connects a node to itself (u = v = %d) on line %d\", u, i + 2);\n\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edges.find(edge) == edges.end(),\n                \"Duplicate edge between nodes %d and %d on line %d\", u, v, i + 2);\n        edges.insert(edge);\n\n        degree[u]++;\n        ensuref(degree[u] <= 2, \"Node %d has more than two incident edges\", u);\n\n        degree[v]++;\n        ensuref(degree[v] <= 2, \"Node %d has more than two incident edges\", v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> degree(n + 1, 0);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge connects a node to itself (u = v = %d) on line %d\", u, i + 2);\n\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edges.find(edge) == edges.end(),\n                \"Duplicate edge between nodes %d and %d on line %d\", u, v, i + 2);\n        edges.insert(edge);\n\n        degree[u]++;\n        ensuref(degree[u] <= 2, \"Node %d has more than two incident edges\", u);\n\n        degree[v]++;\n        ensuref(degree[v] <= 2, \"Node %d has more than two incident edges\", v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct PairHash {\n    size_t operator()(const pair<int,int> &p) const {\n        // A typical way to combine two 32-bit integers into one 64-bit hash\n        // and then apply std::hash<long long>.\n        auto h1 = std::hash<long long>()(\n            (static_cast<long long>(p.first) << 32) ^ static_cast<long long>(p.second)\n        );\n        return h1;\n    }\n};\n\n// Reads the participant (or jury) output,\n// returning true if a valid solution with m edges was provided,\n// or false if the output is just \"-1\" (indicating impossible).\nbool readAnswer(\n    InStream &stream,\n    int n,\n    int m,\n    const unordered_set<pair<int,int>, PairHash> &oldEdges,\n    vector<pair<int,int>> &res\n){\n    // We attempt to read the first integer. This may be -1 or a valid node index.\n    // Let's allow range -1..n to detect -1 or normal node indices [1..n].\n    int firstVal = stream.readInt(-1, n, \"edge node or -1\");\n    if (firstVal == -1) {\n        // The solution claims \"impossible\".\n        // We require that there are no extra tokens.\n        if (!stream.seekEof()) {\n            stream.quitf(_wa, \"Extra tokens after -1\");\n        }\n        return false;\n    }\n\n    // If we are here, then firstVal is the first node of the first edge.\n    // We must read a second node for the first edge.\n    int firstV = stream.readInt(1, n, \"edge node\");\n    res.clear();\n    res.push_back({firstVal, firstV});\n\n    // Then read the remaining m-1 edges.\n    for (int i = 1; i < m; i++) {\n        int u = stream.readInt(1, n, \"edge node\");\n        int v = stream.readInt(1, n, \"edge node\");\n        res.push_back({u, v});\n    }\n\n    // Now we validate the new edges:\n    //  1) No self loops.\n    //  2) Edge wasn't in oldEdges.\n    //  3) No duplicates among new edges.\n    //  4) Each node has degree <= 2.\n    unordered_set<pair<int,int>, PairHash> newEdges;\n    vector<int> degree(n+1, 0);\n\n    for (auto &e : res) {\n        int u = e.first;\n        int v = e.second;\n        if (u == v) {\n            stream.quitf(_wa, \"Self-loop edge found (%d, %d)\", u, v);\n        }\n        pair<int,int> p = {min(u, v), max(u, v)};\n\n        // Edge must not exist in the old graph.\n        if (oldEdges.find(p) != oldEdges.end()) {\n            stream.quitf(_wa, \"Edge (%d, %d) already exists in the old graph\", u, v);\n        }\n        // No duplicates in the new solution.\n        if (newEdges.find(p) != newEdges.end()) {\n            stream.quitf(_wa, \"Duplicate edge in the output: (%d, %d)\", u, v);\n        }\n        newEdges.insert(p);\n\n        degree[u]++;\n        degree[v]++;\n        if (degree[u] > 2 || degree[v] > 2) {\n            stream.quitf(_wa,\n                \"Node %d or %d has degree more than 2 in the new graph\", u, v);\n        }\n    }\n\n    // If we reach here, we have a valid solution.\n    // We do not explicitly check if there are extra tokens after the edges,\n    // but you may enforce that with \"if (!stream.seekEof()) { ... }\" if needed.\n    return true;\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // Read from the input file (inf) the values of n and m\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    // Read the m edges of the old graph; each node can have at most 2 edges,\n    // and there are no duplicates/self-loops by the statement, so we trust that.\n    unordered_set<pair<int,int>, PairHash> oldEdges;\n    oldEdges.reserve(m);\n\n    for(int i = 0; i < m; i++){\n        int u = inf.readInt();\n        int v = inf.readInt();\n        if (u > v) std::swap(u, v);\n        oldEdges.insert({u, v});\n    }\n\n    // Now read the official (jury) answer and check it\n    vector<pair<int,int>> juryGraph;\n    bool juryHasSolution = readAnswer(ans, n, m, oldEdges, juryGraph);\n    // If juryHasSolution == false, that means the jury claims -1 (impossible).\n\n    // Now read the participant's answer\n    vector<pair<int,int>> participantGraph;\n    bool participantHasSolution = readAnswer(ouf, n, m, oldEdges, participantGraph);\n\n    // Compare\n    if (!juryHasSolution && participantHasSolution) {\n        // Jury says impossible, but participant found a valid solution => _fail\n        quitf(_fail, \"Jury claims impossible, but participant found a valid solution\");\n    }\n    if (juryHasSolution && !participantHasSolution) {\n        // Jury has a valid solution, but participant says impossible => WA\n        quitf(_wa, \"Participant claims impossible, but jury has a valid solution\");\n    }\n    if (!juryHasSolution && !participantHasSolution) {\n        // Both say impossible => OK\n        quitf(_ok, \"Both claim impossible\");\n    }\n\n    // Otherwise, both have valid solutions => OK\n    quitf(_ok, \"Both have valid solutions\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    Edge(int _u, int _v) {\n        u = min(_u, _v);\n        v = max(_u, _v);\n    }\n    bool operator<(const Edge &other) const {\n        if (u != other.u)\n            return u < other.u;\n        return v < other.v;\n    }\n};\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(1 <= m && m <= n, \"m should be in range [1, n]\");\n    ensuref(n <= 100000 && m <= 100000, \"n and m should be at most 1e5\");\n\n    vector<pair<int,int>> edges;\n    vector<int> degree(n + 1, 0);\n    set<pair<int,int>> edge_set;\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i + 1;\n\n    if (type == \"chain\") {\n        int num_edges = min(m, n - 1);\n        for (int i = 0; i < num_edges; ++i) {\n            edges.push_back({nodes[i], nodes[i+1]});\n            degree[nodes[i]]++;\n            degree[nodes[i+1]]++;\n            edge_set.insert({min(nodes[i], nodes[i+1]), max(nodes[i], nodes[i+1])});\n        }\n        // If m < n - 1, we have isolated nodes\n    } else if (type == \"cycle\") {\n        if (n < 3) {\n            // Cannot form a cycle with less than 3 nodes\n            m = 0;\n        } else {\n            int num_edges = min(m, n);\n            for (int i = 0; i < num_edges - 1; ++i) {\n                edges.push_back({nodes[i], nodes[i+1]});\n                degree[nodes[i]]++;\n                degree[nodes[i+1]]++;\n                edge_set.insert({min(nodes[i], nodes[i+1]), max(nodes[i], nodes[i+1])});\n            }\n            if (num_edges == n) {\n                // Close the cycle\n                edges.push_back({nodes[n-1], nodes[0]});\n                degree[nodes[n-1]]++;\n                degree[nodes[0]]++;\n                edge_set.insert({min(nodes[n-1], nodes[0]), max(nodes[n-1], nodes[0])});\n            }\n        }\n    } else if (type == \"components\") {\n        shuffle(nodes.begin(), nodes.end());\n        int remaining_edges = m;\n        int idx = 0;\n        while (remaining_edges > 0 && idx < n) {\n            int component_size = rnd.next(1, min(n - idx, remaining_edges + 1));\n            if (component_size == 1) {\n                idx += 1;\n                continue;\n            }\n            for (int i = idx; i < idx + component_size - 1; ++i) {\n                edges.push_back({nodes[i], nodes[i+1]});\n                degree[nodes[i]]++;\n                degree[nodes[i+1]]++;\n                edge_set.insert({min(nodes[i], nodes[i+1]), max(nodes[i], nodes[i+1])});\n                remaining_edges--;\n                if (remaining_edges == 0) break;\n            }\n            idx += component_size;\n        }\n    } else { // Random\n        shuffle(nodes.begin(), nodes.end());\n        // Build a chain first\n        int i = 0;\n        while (i < n -1 && m > 0) {\n            int u = nodes[i];\n            int v = nodes[i+1];\n            if (degree[u] < 2 && degree[v] < 2) {\n                edges.push_back({u, v});\n                degree[u]++;\n                degree[v]++;\n                edge_set.insert({min(u,v), max(u,v)});\n                m--;\n            }\n            i++;\n        }\n        // Try to add more random edges\n        vector<int> available_nodes;\n        for (int j = 0; j < n; ++j)\n            if (degree[nodes[j]] < 2)\n                available_nodes.push_back(nodes[j]);\n        while (m > 0) {\n            if ((int)available_nodes.size() < 2)\n                break;\n            int u_idx = rnd.next(0, (int)available_nodes.size() - 1);\n            int v_idx = rnd.next(0, (int)available_nodes.size() - 1);\n            if (u_idx == v_idx) continue;\n            int u = available_nodes[u_idx];\n            int v = available_nodes[v_idx];\n            if (edge_set.count({min(u,v), max(u,v)})) continue;\n            edges.push_back({u,v});\n            degree[u]++;\n            degree[v]++;\n            edge_set.insert({min(u,v), max(u,v)});\n            if (degree[u] == 2)\n                swap(available_nodes[u_idx], available_nodes.back()), available_nodes.pop_back();\n            if (degree[v] == 2 && u != v)\n                swap(available_nodes[v_idx], available_nodes.back()), available_nodes.pop_back();\n            m--;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    Edge(int _u, int _v) {\n        u = min(_u, _v);\n        v = max(_u, _v);\n    }\n    bool operator<(const Edge &other) const {\n        if (u != other.u)\n            return u < other.u;\n        return v < other.v;\n    }\n};\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensuref(1 <= m && m <= n, \"m should be in range [1, n]\");\n    ensuref(n <= 100000 && m <= 100000, \"n and m should be at most 1e5\");\n\n    vector<pair<int,int>> edges;\n    vector<int> degree(n + 1, 0);\n    set<pair<int,int>> edge_set;\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i + 1;\n\n    if (type == \"chain\") {\n        int num_edges = min(m, n - 1);\n        for (int i = 0; i < num_edges; ++i) {\n            edges.push_back({nodes[i], nodes[i+1]});\n            degree[nodes[i]]++;\n            degree[nodes[i+1]]++;\n            edge_set.insert({min(nodes[i], nodes[i+1]), max(nodes[i], nodes[i+1])});\n        }\n        // If m < n - 1, we have isolated nodes\n    } else if (type == \"cycle\") {\n        if (n < 3) {\n            // Cannot form a cycle with less than 3 nodes\n            m = 0;\n        } else {\n            int num_edges = min(m, n);\n            for (int i = 0; i < num_edges - 1; ++i) {\n                edges.push_back({nodes[i], nodes[i+1]});\n                degree[nodes[i]]++;\n                degree[nodes[i+1]]++;\n                edge_set.insert({min(nodes[i], nodes[i+1]), max(nodes[i], nodes[i+1])});\n            }\n            if (num_edges == n) {\n                // Close the cycle\n                edges.push_back({nodes[n-1], nodes[0]});\n                degree[nodes[n-1]]++;\n                degree[nodes[0]]++;\n                edge_set.insert({min(nodes[n-1], nodes[0]), max(nodes[n-1], nodes[0])});\n            }\n        }\n    } else if (type == \"components\") {\n        shuffle(nodes.begin(), nodes.end());\n        int remaining_edges = m;\n        int idx = 0;\n        while (remaining_edges > 0 && idx < n) {\n            int component_size = rnd.next(1, min(n - idx, remaining_edges + 1));\n            if (component_size == 1) {\n                idx += 1;\n                continue;\n            }\n            for (int i = idx; i < idx + component_size - 1; ++i) {\n                edges.push_back({nodes[i], nodes[i+1]});\n                degree[nodes[i]]++;\n                degree[nodes[i+1]]++;\n                edge_set.insert({min(nodes[i], nodes[i+1]), max(nodes[i], nodes[i+1])});\n                remaining_edges--;\n                if (remaining_edges == 0) break;\n            }\n            idx += component_size;\n        }\n    } else { // Random\n        shuffle(nodes.begin(), nodes.end());\n        // Build a chain first\n        int i = 0;\n        while (i < n -1 && m > 0) {\n            int u = nodes[i];\n            int v = nodes[i+1];\n            if (degree[u] < 2 && degree[v] < 2) {\n                edges.push_back({u, v});\n                degree[u]++;\n                degree[v]++;\n                edge_set.insert({min(u,v), max(u,v)});\n                m--;\n            }\n            i++;\n        }\n        // Try to add more random edges\n        vector<int> available_nodes;\n        for (int j = 0; j < n; ++j)\n            if (degree[nodes[j]] < 2)\n                available_nodes.push_back(nodes[j]);\n        while (m > 0) {\n            if ((int)available_nodes.size() < 2)\n                break;\n            int u_idx = rnd.next(0, (int)available_nodes.size() - 1);\n            int v_idx = rnd.next(0, (int)available_nodes.size() - 1);\n            if (u_idx == v_idx) continue;\n            int u = available_nodes[u_idx];\n            int v = available_nodes[v_idx];\n            if (edge_set.count({min(u,v), max(u,v)})) continue;\n            edges.push_back({u,v});\n            degree[u]++;\n            degree[v]++;\n            edge_set.insert({min(u,v), max(u,v)});\n            if (degree[u] == 2)\n                swap(available_nodes[u_idx], available_nodes.back()), available_nodes.pop_back();\n            if (degree[v] == 2 && u != v)\n                swap(available_nodes[v_idx], available_nodes.back()), available_nodes.pop_back();\n            m--;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small size chains\n./gen -n 3 -m 2 -type chain\n./gen -n 5 -m 4 -type chain\n\n# Small size cycles\n./gen -n 4 -m 4 -type cycle\n./gen -n 6 -m 5 -type cycle\n\n# Components with disconnected paths\n./gen -n 10 -m 5 -type components\n./gen -n 15 -m 7 -type components\n\n# Random graphs with degrees <= 2\n./gen -n 10 -m 9 -type random\n./gen -n 50 -m 49 -type random\n\n# Maximum size chain\n./gen -n 1000 -m 999 -type chain\n./gen -n 100000 -m 99999 -type chain\n\n# Maximum size cycle\n./gen -n 1000 -m 1000 -type cycle\n./gen -n 100000 -m 100000 -type cycle\n\n# Random graphs with maximum edges\n./gen -n 1000 -m 1000 -type random\n./gen -n 100000 -m 100000 -type random\n\n# Graphs with minimal edges\n./gen -n 1000 -m 1 -type random\n./gen -n 100000 -m 1 -type random\n\n# Edge cases where it's impossible to construct new graph\n./gen -n 2 -m 1 -type chain\n./gen -n 3 -m 2 -type chain\n\n# Medium size graphs\n./gen -n 50000 -m 49999 -type chain\n./gen -n 50000 -m 50000 -type cycle\n./gen -n 50000 -m 25000 -type components\n./gen -n 50000 -m 40000 -type random\n\n# Random graphs with various sizes\n./gen -n 70000 -m 60000 -type random\n./gen -n 80000 -m 70000 -type random\n./gen -n 90000 -m 80000 -type random\n\n# Components with random sizes\n./gen -n 100000 -m 50000 -type components\n./gen -n 100000 -m 75000 -type components\n\n# Chains with minimal edges\n./gen -n 100000 -m 1 -type chain\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:51.275068",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "329/D",
      "title": "D. The Evil Temple and the Moving Rocks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line will consists of two integers n and x, denoting the size of the room and the number of sounds required to open the door. There will be exactly three test cases for this problem:  n = 5, x = 5;  n = 3, x = 2;  n = 100, x = 105. All of these testcases are in pretest.",
      "output_spec": "OutputOutput n lines. Each line consists of n characters — the j-th character of the i-th line represents the content of the tile at the i-th row and the j-th column, and should be one of these:  '^', '<', '>', or 'v': a rock as described in the problem statement.  '.': an empty tile. Then, output two integers r and c (1 ≤ r, c ≤ n) on the next line — this means that the rock you activate first is located at the r-th row from above and c-th column from the left. There must be a rock in this cell.If there are multiple solutions, you may output any of them.",
      "sample_tests": "ExamplesInputCopy5 5OutputCopy>...vv.<....^..>......^.<1 1InputCopy3 2OutputCopy>vv^<.^.<1 3",
      "description": "D. The Evil Temple and the Moving Rocks\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line will consists of two integers n and x, denoting the size of the room and the number of sounds required to open the door. There will be exactly three test cases for this problem:  n = 5, x = 5;  n = 3, x = 2;  n = 100, x = 105. All of these testcases are in pretest.\n\nOutputOutput n lines. Each line consists of n characters — the j-th character of the i-th line represents the content of the tile at the i-th row and the j-th column, and should be one of these:  '^', '<', '>', or 'v': a rock as described in the problem statement.  '.': an empty tile. Then, output two integers r and c (1 ≤ r, c ≤ n) on the next line — this means that the rock you activate first is located at the r-th row from above and c-th column from the left. There must be a rock in this cell.If there are multiple solutions, you may output any of them.\n\nInputCopy5 5OutputCopy>...vv.<....^..>......^.<1 1InputCopy3 2OutputCopy>vv^<.^.<1 3\n\nInputCopy5 5\n\nOutputCopy>...vv.<....^..>......^.<1 1\n\nInputCopy3 2\n\nOutputCopy>vv^<.^.<1 3\n\nNoteHere's a simulation of the first example, accompanied with the number of sounds produced so far.  0 sound   1 sound   2 sounds   3 sounds   4 sounds   still 4 sounds In the picture above, the activated rock switches between the '^' rock and the '<' rock. However, no sound is produced since the '^' rock didn't move even a single tile. So, still 4 sound.  5 sounds At this point, 5 sound are already produced, so this solution is already correct. However, for the sake of example, we will continue simulating what happens.  6 sounds   7 sounds   still 7 sounds   8 sounds And the movement stops. In total, it produces 8 sounds. Notice that the last move produced sound.Here's a simulation of the second example:  0 sound   1 sound   2 sounds Now, the activated stone will switch continuously from one to another without producing a sound until it reaches the 107 limit, after which the movement will cease.  In total, it produced exactly 2 sounds, so the solution is correct.",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 329\\s*D"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 329\\s*D"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\"); // n in [1, 100]\n    inf.readSpace();\n    int x = inf.readInt(1, 100000, \"x\"); // x in [1, 100000]\n    inf.readEoln();\n\n    ensuref(\n        (n == 3 && x == 2) || (n == 5 && x == 5) || (n == 100 && x == 100000),\n        \"n and x must be one of the specified pairs: (3,2), (5,5), or (100,100000)\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\"); // n in [1, 100]\n    inf.readSpace();\n    int x = inf.readInt(1, 100000, \"x\"); // x in [1, 100000]\n    inf.readEoln();\n\n    ensuref(\n        (n == 3 && x == 2) || (n == 5 && x == 5) || (n == 100 && x == 100000),\n        \"n and x must be one of the specified pairs: (3,2), (5,5), or (100,100000)\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\"); // n in [1, 100]\n    inf.readSpace();\n    int x = inf.readInt(1, 100000, \"x\"); // x in [1, 100000]\n    inf.readEoln();\n\n    ensuref(\n        (n == 3 && x == 2) || (n == 5 && x == 5) || (n == 100 && x == 100000),\n        \"n and x must be one of the specified pairs: (3,2), (5,5), or (100,100000)\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the checker\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt();\n    int x = inf.readInt();\n\n    // Read contestant's output\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string line = ouf.readLine();\n        if (line.length() != n)\n            quitf(_wa, \"Line %d length is %d, expected %d\", i+1, line.length(), n);\n\n        for (int j = 0; j < n; ++j) {\n            char c = line[j];\n            if (c != '.' && c != '^' && c != 'v' && c != '<' && c != '>')\n                quitf(_wa, \"Invalid character '%c' at position (%d, %d)\", c, i+1, j+1);\n        }\n        grid[i] = line;\n    }\n\n    int nRocksUsed = 0;\n    for (int i = 0; i < n; ++i) {\n        for (char c : grid[i]) {\n            if (c != '.')\n                nRocksUsed++;\n        }\n    }\n\n    if (nRocksUsed == 0)\n        quitf(_wa, \"No rocks placed on the grid\");\n\n    int r = ouf.readInt(1, n, \"r\");\n    int c = ouf.readInt(1, n, \"c\");\n\n    char start_rock = grid[r-1][c-1];\n    if (start_rock != '^' && start_rock != 'v' && start_rock != '<' && start_rock != '>')\n        quitf(_wa, \"Cell at (%d, %d) does not contain a rock\", r, c);\n\n    // Mapping directions\n    map<char, pair<int, int>> dir_map = {\n        {'^', {-1, 0}},\n        {'v', {1, 0}},\n        {'<', {0, -1}},\n        {'>', {0, 1}}\n    };\n\n    // Simulate the movements\n    const int MAX_ACTIVATIONS = int(1e7);\n    int activation_count = 1; // Initial activation\n    int sounds = 0;\n    queue<pair<int, int>> q;\n    q.push({r-1, c-1});\n\n    while (!q.empty()) {\n        // Check if the activation limit is reached\n        if (activation_count > MAX_ACTIVATIONS) {\n            break;\n        }\n\n        auto [cur_r, cur_c] = q.front();\n        q.pop();\n\n        char rock_char = grid[cur_r][cur_c];\n        int dx = dir_map[rock_char].first;\n        int dy = dir_map[rock_char].second;\n\n        int nr = cur_r;\n        int nc = cur_c;\n        bool moved = false;\n\n        while (true) {\n            int next_r = nr + dx;\n            int next_c = nc + dy;\n\n            // Check bounds (walls)\n            if (next_r < 0 || next_r >= n || next_c < 0 || next_c >= n) {\n                if (moved)\n                    sounds++;\n                // Movement ends\n                break;\n            }\n\n            char next_cell = grid[next_r][next_c];\n\n            if (next_cell == '.') {\n                // Move to next cell\n                nr = next_r;\n                nc = next_c;\n                moved = true;\n            } else {\n                // Hit another rock\n                if (moved)\n                    sounds++;\n                // Activate the rock\n                activation_count++;\n                if (activation_count > MAX_ACTIVATIONS)\n                    goto movements_end;\n                q.push({next_r, next_c});\n                // Movement ends\n                break;\n            }\n        }\n    }\n\nmovements_end:\n\n    if (sounds >= x) {\n        quitf(_ok, \"Produced %d sounds which is at least x = %d\", sounds, x);\n    } else {\n        quitf(_wa, \"Only produced %d sounds, but x = %d\", sounds, x);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n\n    // Ensure (n, x) is one of the three valid pairs:\n    if (!(\n        (n == 3 && x == 2) ||\n        (n == 5 && x == 5) ||\n        (n == 100 && x == 100000)\n    )) {\n        cerr << \"Error: (n, x) must be precisely one of (3,2), (5,5), or (100,100000).\\n\";\n        return 1; // Return non-zero to indicate error\n    }\n\n    // Output the validated input.\n    cout << n << \" \" << x << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n\n    // Ensure (n, x) is one of the three valid pairs:\n    if (!(\n        (n == 3 && x == 2) ||\n        (n == 5 && x == 5) ||\n        (n == 100 && x == 100000)\n    )) {\n        cerr << \"Error: (n, x) must be precisely one of (3,2), (5,5), or (100,100000).\\n\";\n        return 1; // Return non-zero to indicate error\n    }\n\n    // Output the validated input.\n    cout << n << \" \" << x << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1) Produce \"3 2\"\n./gen -n 3 -x 2\n\n# 2) Produce \"5 5\"\n./gen -n 5 -x 5\n\n# 3) Produce \"100 100000\"\n./gen -n 100 -x 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:53.547339",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "329/E",
      "title": "E. Evil",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (3 ≤ n ≤ 105). Then n lines follow, each consisting of two integers xi and yi (0 ≤ xi, yi ≤ 109), denoting the coordinates of a city. All given points will be distinct.",
      "output_spec": "OutputA single line denoting the longest possible length of a Hamiltonian cycle of the given cities. You should not output the cycle, only its length.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy41 11 22 12 2OutputCopy6",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (3 ≤ n ≤ 105). Then n lines follow, each consisting of two integers xi and yi (0 ≤ xi, yi ≤ 109), denoting the coordinates of a city. All given points will be distinct.\n\nOutputA single line denoting the longest possible length of a Hamiltonian cycle of the given cities. You should not output the cycle, only its length.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy41 11 22 12 2OutputCopy6\n\nInputCopy41 11 22 12 2\n\nOutputCopy6\n\nNoteIn the example, one of the possible Hamiltonian cycles with length 6 is (1, 1) (1, 2) (2, 1) (2, 2). There does not exist any other Hamiltonian cycle with a length greater than 6.The Manhattan distance between two cities (xi, yi) and (xj, yj) is |xi - xj| + |yi - yj|.",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 329\\s*E"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 329\\s*E"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int> > points;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(0, 1000000000, \"yi\");\n        inf.readEoln();\n        ensuref(points.insert(make_pair(x, y)).second, \"Point (%d, %d) is not unique\", x, y);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int> > points;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(0, 1000000000, \"yi\");\n        inf.readEoln();\n        ensuref(points.insert(make_pair(x, y)).second, \"Point (%d, %d) is not unique\", x, y);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int> > points;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(0, 1000000000, \"yi\");\n        inf.readEoln();\n        ensuref(points.insert(make_pair(x, y)).second, \"Point (%d, %d) is not unique\", x, y);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<pair<int,int>> points;\n\n    if (type == \"random\") {\n        set<pair<int,int>> point_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            int y = rnd.next(0, int(1e9));\n            pair<int,int> p = make_pair(x, y);\n            if (point_set.insert(p).second) {\n                points.push_back(p);\n                ++i;\n            }\n        }\n    }\n    else if (type == \"line_x\") {\n        int x = rnd.next(0, int(1e9));\n        set<int> y_set;\n        for (int i = 0; i < n; ) {\n            int y = rnd.next(0, int(1e9));\n            if (y_set.insert(y).second) {\n                points.push_back(make_pair(x, y));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"line_y\") {\n        int y = rnd.next(0, int(1e9));\n        set<int> x_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (x_set.insert(x).second) {\n                points.push_back(make_pair(x, y));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"diagonal\") {\n        set<int> x_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (x_set.insert(x).second) {\n                points.push_back(make_pair(x, x));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"antidiagonal\") {\n        set<int> x_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (x_set.insert(x).second) {\n                points.push_back(make_pair(x, int(1e9) - x));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"cluster\") {\n        int base_x = rnd.next(0, int(1e9 - 1000));\n        int base_y = rnd.next(0, int(1e9 - 1000));\n        int delta = 1000; // small area\n        set<pair<int,int>> point_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(base_x, base_x + delta);\n            int y = rnd.next(base_y, base_y + delta);\n            pair<int,int> p = make_pair(x, y);\n            if (point_set.insert(p).second) {\n                points.push_back(p);\n                ++i;\n            }\n        }\n    }\n    else if (type == \"extremes\") {\n        int min_x = 0;\n        int max_x = int(1e9);\n        int min_y = 0;\n        int max_y = int(1e9);\n        for (int i = 0; i < n; i+=4) {\n            if (i < n) points.push_back(make_pair(min_x, min_y));\n            if (i+1 < n) points.push_back(make_pair(min_x, max_y));\n            if (i+2 < n) points.push_back(make_pair(max_x, min_y));\n            if (i+3 < n) points.push_back(make_pair(max_x, max_y));\n        }\n    }\n    else if (type == \"grid\") {\n        int side = sqrt(n);\n        if (1LL * side * side < n) side++;\n        set<pair<int,int>> point_set;\n        int delta = int(1e9) / side;\n        for (int i = 0; i < side && points.size() < n; ++i) {\n            for (int j = 0; j < side && points.size() < n; ++j) {\n                int x = rnd.next(i * delta, (i+1) * delta -1);\n                int y = rnd.next(j * delta, (j+1) * delta -1);\n                pair<int,int> p = make_pair(x, y);\n                if (point_set.insert(p).second) {\n                    points.push_back(p);\n                }\n            }\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<pair<int,int>> points;\n\n    if (type == \"random\") {\n        set<pair<int,int>> point_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            int y = rnd.next(0, int(1e9));\n            pair<int,int> p = make_pair(x, y);\n            if (point_set.insert(p).second) {\n                points.push_back(p);\n                ++i;\n            }\n        }\n    }\n    else if (type == \"line_x\") {\n        int x = rnd.next(0, int(1e9));\n        set<int> y_set;\n        for (int i = 0; i < n; ) {\n            int y = rnd.next(0, int(1e9));\n            if (y_set.insert(y).second) {\n                points.push_back(make_pair(x, y));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"line_y\") {\n        int y = rnd.next(0, int(1e9));\n        set<int> x_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (x_set.insert(x).second) {\n                points.push_back(make_pair(x, y));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"diagonal\") {\n        set<int> x_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (x_set.insert(x).second) {\n                points.push_back(make_pair(x, x));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"antidiagonal\") {\n        set<int> x_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, int(1e9));\n            if (x_set.insert(x).second) {\n                points.push_back(make_pair(x, int(1e9) - x));\n                ++i;\n            }\n        }\n    }\n    else if (type == \"cluster\") {\n        int base_x = rnd.next(0, int(1e9 - 1000));\n        int base_y = rnd.next(0, int(1e9 - 1000));\n        int delta = 1000; // small area\n        set<pair<int,int>> point_set;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(base_x, base_x + delta);\n            int y = rnd.next(base_y, base_y + delta);\n            pair<int,int> p = make_pair(x, y);\n            if (point_set.insert(p).second) {\n                points.push_back(p);\n                ++i;\n            }\n        }\n    }\n    else if (type == \"extremes\") {\n        int min_x = 0;\n        int max_x = int(1e9);\n        int min_y = 0;\n        int max_y = int(1e9);\n        for (int i = 0; i < n; i+=4) {\n            if (i < n) points.push_back(make_pair(min_x, min_y));\n            if (i+1 < n) points.push_back(make_pair(min_x, max_y));\n            if (i+2 < n) points.push_back(make_pair(max_x, min_y));\n            if (i+3 < n) points.push_back(make_pair(max_x, max_y));\n        }\n    }\n    else if (type == \"grid\") {\n        int side = sqrt(n);\n        if (1LL * side * side < n) side++;\n        set<pair<int,int>> point_set;\n        int delta = int(1e9) / side;\n        for (int i = 0; i < side && points.size() < n; ++i) {\n            for (int j = 0; j < side && points.size() < n; ++j) {\n                int x = rnd.next(i * delta, (i+1) * delta -1);\n                int y = rnd.next(j * delta, (j+1) * delta -1);\n                pair<int,int> p = make_pair(x, y);\n                if (point_set.insert(p).second) {\n                    points.push_back(p);\n                }\n            }\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type line_x\n./gen -n 3 -type line_y\n./gen -n 3 -type diagonal\n./gen -n 3 -type antidiagonal\n./gen -n 3 -type cluster\n./gen -n 3 -type extremes\n./gen -n 3 -type grid\n\n./gen -n 10 -type random\n./gen -n 10 -type line_x\n./gen -n 10 -type line_y\n./gen -n 10 -type diagonal\n./gen -n 10 -type antidiagonal\n./gen -n 10 -type cluster\n./gen -n 10 -type extremes\n./gen -n 10 -type grid\n\n./gen -n 100 -type random\n./gen -n 100 -type line_x\n./gen -n 100 -type line_y\n./gen -n 100 -type diagonal\n./gen -n 100 -type antidiagonal\n./gen -n 100 -type cluster\n./gen -n 100 -type extremes\n./gen -n 100 -type grid\n\n./gen -n 1000 -type random\n./gen -n 1000 -type line_x\n./gen -n 1000 -type line_y\n./gen -n 1000 -type diagonal\n./gen -n 1000 -type antidiagonal\n./gen -n 1000 -type cluster\n./gen -n 1000 -type extremes\n./gen -n 1000 -type grid\n\n./gen -n 100000 -type random\n./gen -n 100000 -type line_x\n./gen -n 100000 -type line_y\n./gen -n 100000 -type diagonal\n./gen -n 100000 -type antidiagonal\n./gen -n 100000 -type cluster\n./gen -n 100000 -type extremes\n./gen -n 100000 -type grid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:55.674322",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "33/A",
      "title": "A. What is for dinner?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (1 ≤ m ≤ n ≤ 1000, 0 ≤ k ≤ 106) — total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow n lines, each containing two integers: r (1 ≤ r ≤ m) — index of the row, where belongs the corresponding tooth, and c (0 ≤ c ≤ 106) — its residual viability.It's guaranteed that each tooth row has positive amount of teeth.",
      "output_spec": "OutputIn the first line output the maximum amount of crucians that Valerie can consume for dinner.",
      "sample_tests": "ExamplesInputCopy4 3 182 31 23 62 3OutputCopy11InputCopy2 2 131 132 12OutputCopy13",
      "description": "A. What is for dinner?\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (1 ≤ m ≤ n ≤ 1000, 0 ≤ k ≤ 106) — total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow n lines, each containing two integers: r (1 ≤ r ≤ m) — index of the row, where belongs the corresponding tooth, and c (0 ≤ c ≤ 106) — its residual viability.It's guaranteed that each tooth row has positive amount of teeth.\n\nOutputIn the first line output the maximum amount of crucians that Valerie can consume for dinner.\n\nInputCopy4 3 182 31 23 62 3OutputCopy11InputCopy2 2 131 132 12OutputCopy13\n\nInputCopy4 3 182 31 23 62 3\n\nOutputCopy11\n\nInputCopy2 2 131 132 12\n\nOutputCopy13",
      "solutions": [
        {
          "title": "Codeforces Beta Round #33 (Codeforces format) - Codeforces",
          "content": "Good morning, day, evening, night to you.Welcome to the wonderful randomized contest, which is prepared for you by team Saratov SU 3 (Davtyan Edvard, Kholkin Pavel, Kudryashov Igor).Thanks to Julia Satushina, Artem Rakhov and Dmitry Matov for their help in preparing this round. Special thanks to VK company.Good luck and high rating!With best regards, Saratov SU 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/729",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 366
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/731",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/732",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 1000;\n    const int MAX_K = 1000000;\n    const int MAX_C = 1000000;\n    \n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, MAX_K, \"k\");\n    inf.readEoln();\n\n    vector<int> countsInRow(m + 1, 0); // Rows are 1-indexed\n\n    for (int i = 0; i < n; ++i) {\n        int r_i = inf.readInt(1, m, \"r_i\");\n        inf.readSpace();\n        int c_i = inf.readInt(0, MAX_C, \"c_i\");\n        inf.readEoln();\n\n        countsInRow[r_i]++;\n    }\n\n    for (int idx = 1; idx <= m; ++idx) {\n        ensuref(countsInRow[idx] > 0, \"Each tooth row must have positive amount of teeth, but tooth row %d has 0 teeth\", idx);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 1000;\n    const int MAX_K = 1000000;\n    const int MAX_C = 1000000;\n    \n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, MAX_K, \"k\");\n    inf.readEoln();\n\n    vector<int> countsInRow(m + 1, 0); // Rows are 1-indexed\n\n    for (int i = 0; i < n; ++i) {\n        int r_i = inf.readInt(1, m, \"r_i\");\n        inf.readSpace();\n        int c_i = inf.readInt(0, MAX_C, \"c_i\");\n        inf.readEoln();\n\n        countsInRow[r_i]++;\n    }\n\n    for (int idx = 1; idx <= m; ++idx) {\n        ensuref(countsInRow[idx] > 0, \"Each tooth row must have positive amount of teeth, but tooth row %d has 0 teeth\", idx);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 1000;\n    const int MAX_K = 1000000;\n    const int MAX_C = 1000000;\n    \n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, MAX_K, \"k\");\n    inf.readEoln();\n\n    vector<int> countsInRow(m + 1, 0); // Rows are 1-indexed\n\n    for (int i = 0; i < n; ++i) {\n        int r_i = inf.readInt(1, m, \"r_i\");\n        inf.readSpace();\n        int c_i = inf.readInt(0, MAX_C, \"c_i\");\n        inf.readEoln();\n\n        countsInRow[r_i]++;\n    }\n\n    for (int idx = 1; idx <= m; ++idx) {\n        ensuref(countsInRow[idx] > 0, \"Each tooth row must have positive amount of teeth, but tooth row %d has 0 teeth\", idx);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> toothRows(n);\n    vector<int> viability(n);\n\n    if (m > n) {\n        // Adjust m to be at most n\n        m = n;\n    }\n\n    if (type == \"random\") {\n        // Assign one tooth to each row to ensure every row has at least one tooth\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        // Assign remaining teeth to random rows\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        // Shuffle tooth rows\n        shuffle(toothRows.begin(), toothRows.end());\n        // Generate random viabilities within [0, 1e6]\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n\n    } else if (type == \"min_viability\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        // Set minimum viability (0 or 1)\n        for (int i = 0; i < n; ++i)\n            viability[i] = 0;\n\n    } else if (type == \"max_viability\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        // Set maximum viability\n        for (int i = 0; i < n; ++i)\n            viability[i] = 1000000;\n\n    } else if (type == \"zero_k\") {\n        k = 0; // Ensure k is zero\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n\n    } else if (type == \"one_row\") {\n        m = 1; // Only one row\n        for (int i = 0; i < n; ++i)\n            toothRows[i] = 1;\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n\n    } else if (type == \"max_rows\") {\n        m = n; // Each tooth is in its own row\n        for (int i = 0; i < n; ++i) {\n            toothRows[i] = i + 1;\n            viability[i] = rnd.next(0, 1000000);\n        }\n\n    } else if (type == \"skewed\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        int specialIndex = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            viability[i] = (i == specialIndex) ? 0 : 1000000;\n        }\n\n    } else if (type == \"edge_viability\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        for (int i = 0; i < n; ++i)\n            viability[i] = 0;\n\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d\\n\", toothRows[i], viability[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> toothRows(n);\n    vector<int> viability(n);\n\n    if (m > n) {\n        // Adjust m to be at most n\n        m = n;\n    }\n\n    if (type == \"random\") {\n        // Assign one tooth to each row to ensure every row has at least one tooth\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        // Assign remaining teeth to random rows\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        // Shuffle tooth rows\n        shuffle(toothRows.begin(), toothRows.end());\n        // Generate random viabilities within [0, 1e6]\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n\n    } else if (type == \"min_viability\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        // Set minimum viability (0 or 1)\n        for (int i = 0; i < n; ++i)\n            viability[i] = 0;\n\n    } else if (type == \"max_viability\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        // Set maximum viability\n        for (int i = 0; i < n; ++i)\n            viability[i] = 1000000;\n\n    } else if (type == \"zero_k\") {\n        k = 0; // Ensure k is zero\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n\n    } else if (type == \"one_row\") {\n        m = 1; // Only one row\n        for (int i = 0; i < n; ++i)\n            toothRows[i] = 1;\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n\n    } else if (type == \"max_rows\") {\n        m = n; // Each tooth is in its own row\n        for (int i = 0; i < n; ++i) {\n            toothRows[i] = i + 1;\n            viability[i] = rnd.next(0, 1000000);\n        }\n\n    } else if (type == \"skewed\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        int specialIndex = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            viability[i] = (i == specialIndex) ? 0 : 1000000;\n        }\n\n    } else if (type == \"edge_viability\") {\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        for (int i = 0; i < n; ++i)\n            viability[i] = 0;\n\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < m; ++i)\n            toothRows[i] = i + 1;\n        for (int i = m; i < n; ++i)\n            toothRows[i] = rnd.next(1, m);\n        shuffle(toothRows.begin(), toothRows.end());\n        for (int i = 0; i < n; ++i)\n            viability[i] = rnd.next(0, 1000000);\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d\\n\", toothRows[i], viability[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 0 -type zero_k\n./gen -n 1 -m 1 -k 1 -type min_viability\n./gen -n 1 -m 1 -k 1 -type max_viability\n./gen -n 2 -m 1 -k 1 -type one_row\n./gen -n 2 -m 2 -k 2 -type max_rows\n./gen -n 10 -m 5 -k 0 -type zero_k\n./gen -n 10 -m 5 -k 10 -type min_viability\n./gen -n 10 -m 5 -k 100 -type max_viability\n./gen -n 50 -m 10 -k 500 -type random\n./gen -n 100 -m 50 -k 500 -type random\n./gen -n 100 -m 100 -k 1000 -type max_rows\n./gen -n 100 -m 1 -k 1000 -type one_row\n./gen -n 500 -m 250 -k 10000 -type skewed\n./gen -n 500 -m 250 -k 0 -type edge_viability\n./gen -n 500 -m 250 -k 100000 -type random\n./gen -n 1000 -m 500 -k 1000000 -type max_viability\n./gen -n 1000 -m 500 -k 1000000 -type min_viability\n./gen -n 1000 -m 1000 -k 500000 -type max_rows\n./gen -n 1000 -m 1 -k 500000 -type one_row\n./gen -n 1000 -m 100 -k 500 -type skewed\n./gen -n 1000 -m 100 -k 500 -type edge_viability\n./gen -n 1000 -m 100 -k 0 -type zero_k\n./gen -n 1000 -m 100 -k 500000 -type random\n./gen -n 1000 -m 999 -k 999999 -type random\n./gen -n 1000 -m 1 -k 1000000 -type max_viability\n./gen -n 1000 -m 1 -k 0 -type zero_k\n./gen -n 1000 -m 1 -k 1000000 -type min_viability\n./gen -n 1000 -m 500 -k 1000000 -type random\n./gen -n 1000 -m 1000 -k 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:08:57.967093",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "33/B",
      "title": "B. String Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two initial non-empty strings s and t, consisting of lower case Latin letters. The length of each string doesn't exceed 105. The following line contains integer n (0 ≤ n ≤ 500) — amount of possible changings. Then follow n lines, each containing characters Ai and Bi (lower case Latin letters) and integer Wi (0 ≤ Wi ≤ 100), saying that it's allowed to change character Ai into character Bi in any of the strings and spend sum of money Wi.",
      "output_spec": "OutputIf the answer exists, output the answer to the problem, and the resulting string. Otherwise output -1 in the only line. If the answer is not unique, output any.",
      "sample_tests": "ExamplesInputCopyuayduxxd3a x 8x y 13d c 3OutputCopy21uxydInputCopyab3a b 2a b 3b a 5OutputCopy2bInputCopyabcab6a b 4a b 7b a 8c b 11c a 3a c 0OutputCopy-1",
      "description": "B. String Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two initial non-empty strings s and t, consisting of lower case Latin letters. The length of each string doesn't exceed 105. The following line contains integer n (0 ≤ n ≤ 500) — amount of possible changings. Then follow n lines, each containing characters Ai and Bi (lower case Latin letters) and integer Wi (0 ≤ Wi ≤ 100), saying that it's allowed to change character Ai into character Bi in any of the strings and spend sum of money Wi.\n\nOutputIf the answer exists, output the answer to the problem, and the resulting string. Otherwise output -1 in the only line. If the answer is not unique, output any.\n\nInputCopyuayduxxd3a x 8x y 13d c 3OutputCopy21uxydInputCopyab3a b 2a b 3b a 5OutputCopy2bInputCopyabcab6a b 4a b 7b a 8c b 11c a 3a c 0OutputCopy-1\n\nInputCopyuayduxxd3a x 8x y 13d c 3\n\nOutputCopy21uxyd\n\nInputCopyab3a b 2a b 3b a 5\n\nOutputCopy2b\n\nInputCopyabcab6a b 4a b 7b a 8c b 11c a 3a c 0\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #33 (Codeforces format) - Codeforces",
          "content": "Good morning, day, evening, night to you.Welcome to the wonderful randomized contest, which is prepared for you by team Saratov SU 3 (Davtyan Edvard, Kholkin Pavel, Kudryashov Igor).Thanks to Julia Satushina, Artem Rakhov and Dmitry Matov for their help in preparing this round. Special thanks to VK company.Good luck and high rating!With best regards, Saratov SU 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/729",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 366
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/731",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/732",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,100000}\", \"s\");\n\n    // Read t\n    string t = inf.readLine(\"[a-z]{1,100000}\", \"t\");\n\n    // Read n\n    int n = inf.readInt(0, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        // Read Ai\n        string Ai = inf.readToken(\"[a-z]\", \"Ai\");\n        inf.readSpace();\n\n        // Read Bi\n        string Bi = inf.readToken(\"[a-z]\", \"Bi\");\n        inf.readSpace();\n\n        // Read Wi\n        int Wi = inf.readInt(0, 100, \"Wi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,100000}\", \"s\");\n\n    // Read t\n    string t = inf.readLine(\"[a-z]{1,100000}\", \"t\");\n\n    // Read n\n    int n = inf.readInt(0, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        // Read Ai\n        string Ai = inf.readToken(\"[a-z]\", \"Ai\");\n        inf.readSpace();\n\n        // Read Bi\n        string Bi = inf.readToken(\"[a-z]\", \"Bi\");\n        inf.readSpace();\n\n        // Read Wi\n        int Wi = inf.readInt(0, 100, \"Wi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,100000}\", \"s\");\n\n    // Read t\n    string t = inf.readLine(\"[a-z]{1,100000}\", \"t\");\n\n    // Read n\n    int n = inf.readInt(0, 500, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        // Read Ai\n        string Ai = inf.readToken(\"[a-z]\", \"Ai\");\n        inf.readSpace();\n\n        // Read Bi\n        string Bi = inf.readToken(\"[a-z]\", \"Bi\");\n        inf.readSpace();\n\n        // Read Wi\n        int Wi = inf.readInt(0, 100, \"Wi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    string s = inf.readToken();\n    string t = inf.readToken();\n\n    int n = inf.readInt(0, 500);\n\n    vector<vector<int>> cost(26, vector<int>(26, INT_MAX));\n\n    for (int i = 0; i < 26; ++i)\n        cost[i][i] = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string a_str = inf.readWord();\n        string b_str = inf.readWord();\n        char a = a_str[0];\n        char b = b_str[0];\n        int w = inf.readInt(0, 100);\n        int u = a - 'a';\n        int v = b - 'a';\n        if (cost[u][v] > w)\n            cost[u][v] = w;\n    }\n\n    // Compute minimal cost to transform any character to any other character\n    for (int k = 0; k < 26; ++k)\n        for (int i = 0; i < 26; ++i)\n            for (int j = 0; j < 26; ++j)\n                if (cost[i][k] < INT_MAX && cost[k][j] < INT_MAX)\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\n    // Now handle the case where s and t have different lengths\n    if (s.size() != t.size()) {\n        // Read participant output\n        int pans = ouf.readInt();\n        if (pans != -1)\n            quitf(_wa, \"Strings have different lengths, participant should output -1\");\n        else\n            quitf(_ok, \"-1\");\n    } else {\n        int len = s.size();\n\n        // Now compute minimal possible total cost, and minimal possible resulting string\n        int minimal_total_cost = 0;\n        bool possible = true;\n\n        for (int i = 0; i < len; ++i) {\n            int s_i = s[i] - 'a';\n            int t_i = t[i] - 'a';\n            int minimal_cost_i = INT_MAX;\n            for (int c = 0; c < 26; ++c) {\n                int cost_s = cost[s_i][c];\n                int cost_t = cost[t_i][c];\n                if (cost_s == INT_MAX || cost_t == INT_MAX)\n                    continue;\n                int total_cost = cost_s + cost_t;\n                if (total_cost < minimal_cost_i) {\n                    minimal_cost_i = total_cost;\n                }\n            }\n            if (minimal_cost_i == INT_MAX) {\n                possible = false;\n                break;\n            }\n            minimal_total_cost += minimal_cost_i;\n        }\n\n        if (!possible) {\n            // Read participant output\n            int pans = ouf.readInt();\n            if (pans != -1)\n                quitf(_wa, \"No solution exists, participant should output -1\");\n            else\n                quitf(_ok, \"-1\");\n        } else {\n            int pans = ouf.readInt();\n            if (pans != minimal_total_cost)\n                quitf(_wa, \"Expected minimal total cost %d, participant output %d\", minimal_total_cost, pans);\n\n            string pstring = ouf.readToken();\n            if ((int)pstring.size() != len)\n                quitf(_wa, \"Resulting string length is %d, expected %d\", (int)pstring.size(), len);\n\n            int participant_total_cost = 0;\n\n            for (int i = 0; i < len; ++i) {\n                int s_i = s[i] - 'a';\n                int t_i = t[i] - 'a';\n                int p_i = pstring[i] - 'a';\n\n                if (p_i < 0 || p_i >= 26)\n                    quitf(_wa, \"Invalid character '%c' in position %d\", pstring[i], i + 1);\n\n                int cost_s = cost[s_i][p_i];\n                int cost_t = cost[t_i][p_i];\n\n                if (cost_s == INT_MAX || cost_t == INT_MAX)\n                    quitf(_wa, \"Cannot transform s[%d]='%c' and t[%d]='%c' to '%c'\", i+1, s[i], i+1, t[i], pstring[i]);\n\n                participant_total_cost += cost_s + cost_t;\n            }\n\n            if (participant_total_cost != pans)\n                quitf(_wa, \"Computed total cost %d does not match participant output %d\", participant_total_cost, pans);\n\n            quitf(_ok, \"Correct answer with total cost %d\", minimal_total_cost);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// This generator creates test data for the string transformation problem.\n//\n// Usage example:\n//   ./gen -ls 10 -lt 10 -n 5 -type random\n// Above command will produce one test case with:\n//   - String s of length 10\n//   - String t of length 10\n//   - 5 transformations\n//   - Generation mode (type) = \"random\"\n//\n// Remember you should run this generator multiple times with different parameters\n// to produce many test files for your problem.\n\nstatic const int ALPH = 26;   // The number of lowercase letters (a..z)\nstatic const char BASE = 'a'; // 'a' is 97 in ASCII\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    // ls = length of string s\n    // lt = length of string t\n    // n  = number of transformations\n    // type = string that controls how we generate s, t, and transformations\n    int ls = opt<int>(\"ls\", 5);\n    int lt = opt<int>(\"lt\", 5);\n    int n  = opt<int>(\"n\", 3);\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Make sure 1 <= ls, lt <= 100000\n    // and 0 <= n <= 500\n    // but do not forcibly exit; just clamp or rely on the user to pass valid values\n    ls = max(1, min(ls, 100000));\n    lt = max(1, min(lt, 100000));\n    n  = max(0, min(n, 500));\n    \n    // Generate the strings s and t\n    // We'll create different behaviors depending on \"type\".\n    // But the generator must always output exactly one test case.\n\n    // s, t initially empty\n    string s, t;\n\n    auto randomString = [&](int length) {\n        // Generate a random lowercase string of given length\n        // using testlib's rnd for randomness\n        string ret;\n        ret.reserve(length);\n        for (int i = 0; i < length; i++) {\n            char c = char(BASE + rnd.next(ALPH)); \n            ret.push_back(c);\n        }\n        return ret;\n    };\n\n    if (type == \"simple_equal\") {\n        // s and t are the same random string\n        s = randomString(ls);\n        // Force lt = ls to ensure they are the same length\n        // so we do not violate the problem statement's possibility\n        t = s; \n    }\n    else if (type == \"diff_length\") {\n        // s and t have different lengths, so presumably -1 is immediate\n        // We'll just do that forcibly here. If user passes ls=lt by mistake,\n        // we forcibly tweak lt to get a difference.\n        if (ls == lt) {\n            // Make t length different by +/- 1\n            if (ls > 1) {\n                lt = ls - 1;\n            } else {\n                lt = ls + 1;\n            }\n        }\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else if (type == \"zero\") {\n        // n=0 => no transformations => if s != t => -1\n        // We'll keep them random\n        s = randomString(ls);\n        t = randomString(lt);\n        // Force n=0 to match this scenario\n        n = 0;\n    }\n    else if (type == \"random\") {\n        // purely random s, t, possibly with s==t length or not\n        // We'll just produce them as is\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else if (type == \"zero_cost\") {\n        // s, t random but same length, plus transformations with some zero cost\n        // Force same length for more interesting scenario\n        lt = ls;\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else if (type == \"all_letters\") {\n        // s, t random, same length\n        // We want some coverage of transformations from almost all pairs if possible\n        lt = ls;\n        s = randomString(ls);\n        t = randomString(lt);\n        // n can be up to 500. We'll do a systematic approach for transformations below.\n    }\n    else if (type == \"some_cycle\") {\n        // s, t random, same length.\n        // We'll add transformations that create cycles (e.g. a->b, b->a).\n        lt = ls;\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else {\n        // default fallback \"random\"\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n\n    // Output s and t\n    // Next line is integer n\n    // Then n lines of transformations: Ai Bi Wi\n    //\n    // We'll build them according to the \"type\".\n\n    // Let's collect transformations in a vector\n    // For each transformation, pick Ai, Bi, Wi\n    // Ai, Bi in ['a'..'z'], Wi in [0..100]\n\n    vector<tuple<char, char, int>> trans;\n\n    if (type == \"zero\") {\n        // n=0 => produce no transformations\n    }\n    else if (type == \"all_letters\") {\n        // We want to produce as many distinct letter pairs as we can\n        // But limited by n <= 500\n        // We'll produce pairs (a->b) for some subset or random set\n        // Possibly we produce min(ALPH*ALPH, n) transformations\n        // We won't produce duplicates, picking pairs systematically or randomly\n        // We'll do it systematically up to n\n        int limit = min(ALPH*ALPH, n);\n        int count = 0;\n        for (int i = 0; i < ALPH && count < limit; i++) {\n            for (int j = 0; j < ALPH && count < limit; j++) {\n                char A = char(BASE + i);\n                char B = char(BASE + j);\n                int W = rnd.next(101); \n                trans.push_back({A, B, W});\n                count++;\n            }\n        }\n    }\n    else if (type == \"some_cycle\") {\n        // We'll produce up to n transformations, ensuring a few cycles\n        // E.g. a->b, b->c, c->a might form a cycle\n        // Then fill the rest randomly\n        // We'll pick random letters for cycle\n        // (If n < 3, we just do random transformations.)\n        int cycleSize = min(n, 3);\n        vector<char> cyc;\n        for (int i = 0; i < cycleSize; i++) {\n            char c = char(BASE + rnd.next(ALPH));\n            cyc.push_back(c);\n        }\n        // tie them up in a cycle\n        for (int i = 0; i+1 < (int)cyc.size(); i++) {\n            int W = rnd.next(101);\n            trans.push_back({cyc[i], cyc[i+1], W});\n        }\n        if (cycleSize == 3) {\n            int W = rnd.next(101);\n            trans.push_back({cyc[2], cyc[0], W});\n        }\n        // fill the rest (n - cycleSize or n - cycleSize - 1) transformations randomly\n        while ((int)trans.size() < n) {\n            char A = char(BASE + rnd.next(ALPH));\n            char B = char(BASE + rnd.next(ALPH));\n            int W = rnd.next(101);\n            trans.push_back({A, B, W});\n        }\n        // If we had leftover because cycle took fewer than n lines:\n        // that is handled above by random fill\n    }\n    else if (type == \"zero_cost\") {\n        // We'll produce random transformations, but ensure some have cost 0\n        // We'll produce n transformations in total\n        // Let half of them have cost 0 if possible\n        for (int i = 0; i < n; i++) {\n            char A = char(BASE + rnd.next(ALPH));\n            char B = char(BASE + rnd.next(ALPH));\n            int W = 0;\n            if (i >= n/2) {\n                // random cost\n                W = rnd.next(101);\n            }\n            trans.push_back({A, B, W});\n        }\n    }\n    else {\n        // fallback => produce n random transformations\n        for (int i = 0; i < n; i++) {\n            char A = char(BASE + rnd.next(ALPH));\n            char B = char(BASE + rnd.next(ALPH));\n            int W = rnd.next(101);\n            trans.push_back({A, B, W});\n        }\n    }\n\n    // Now we output them:\n    // First line: s and t\n    // Then a line with n\n    // Then n lines: Ai Bi Wi\n\n    cout << s << \"\\n\";\n    cout << t << \"\\n\";\n    cout << n << \"\\n\";\n    for (int i = 0; i < (int)trans.size(); i++){\n        auto [A, B, W] = trans[i];\n        cout << A << \" \" << B << \" \" << W << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// This generator creates test data for the string transformation problem.\n//\n// Usage example:\n//   ./gen -ls 10 -lt 10 -n 5 -type random\n// Above command will produce one test case with:\n//   - String s of length 10\n//   - String t of length 10\n//   - 5 transformations\n//   - Generation mode (type) = \"random\"\n//\n// Remember you should run this generator multiple times with different parameters\n// to produce many test files for your problem.\n\nstatic const int ALPH = 26;   // The number of lowercase letters (a..z)\nstatic const char BASE = 'a'; // 'a' is 97 in ASCII\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    // ls = length of string s\n    // lt = length of string t\n    // n  = number of transformations\n    // type = string that controls how we generate s, t, and transformations\n    int ls = opt<int>(\"ls\", 5);\n    int lt = opt<int>(\"lt\", 5);\n    int n  = opt<int>(\"n\", 3);\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Make sure 1 <= ls, lt <= 100000\n    // and 0 <= n <= 500\n    // but do not forcibly exit; just clamp or rely on the user to pass valid values\n    ls = max(1, min(ls, 100000));\n    lt = max(1, min(lt, 100000));\n    n  = max(0, min(n, 500));\n    \n    // Generate the strings s and t\n    // We'll create different behaviors depending on \"type\".\n    // But the generator must always output exactly one test case.\n\n    // s, t initially empty\n    string s, t;\n\n    auto randomString = [&](int length) {\n        // Generate a random lowercase string of given length\n        // using testlib's rnd for randomness\n        string ret;\n        ret.reserve(length);\n        for (int i = 0; i < length; i++) {\n            char c = char(BASE + rnd.next(ALPH)); \n            ret.push_back(c);\n        }\n        return ret;\n    };\n\n    if (type == \"simple_equal\") {\n        // s and t are the same random string\n        s = randomString(ls);\n        // Force lt = ls to ensure they are the same length\n        // so we do not violate the problem statement's possibility\n        t = s; \n    }\n    else if (type == \"diff_length\") {\n        // s and t have different lengths, so presumably -1 is immediate\n        // We'll just do that forcibly here. If user passes ls=lt by mistake,\n        // we forcibly tweak lt to get a difference.\n        if (ls == lt) {\n            // Make t length different by +/- 1\n            if (ls > 1) {\n                lt = ls - 1;\n            } else {\n                lt = ls + 1;\n            }\n        }\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else if (type == \"zero\") {\n        // n=0 => no transformations => if s != t => -1\n        // We'll keep them random\n        s = randomString(ls);\n        t = randomString(lt);\n        // Force n=0 to match this scenario\n        n = 0;\n    }\n    else if (type == \"random\") {\n        // purely random s, t, possibly with s==t length or not\n        // We'll just produce them as is\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else if (type == \"zero_cost\") {\n        // s, t random but same length, plus transformations with some zero cost\n        // Force same length for more interesting scenario\n        lt = ls;\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else if (type == \"all_letters\") {\n        // s, t random, same length\n        // We want some coverage of transformations from almost all pairs if possible\n        lt = ls;\n        s = randomString(ls);\n        t = randomString(lt);\n        // n can be up to 500. We'll do a systematic approach for transformations below.\n    }\n    else if (type == \"some_cycle\") {\n        // s, t random, same length.\n        // We'll add transformations that create cycles (e.g. a->b, b->a).\n        lt = ls;\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n    else {\n        // default fallback \"random\"\n        s = randomString(ls);\n        t = randomString(lt);\n    }\n\n    // Output s and t\n    // Next line is integer n\n    // Then n lines of transformations: Ai Bi Wi\n    //\n    // We'll build them according to the \"type\".\n\n    // Let's collect transformations in a vector\n    // For each transformation, pick Ai, Bi, Wi\n    // Ai, Bi in ['a'..'z'], Wi in [0..100]\n\n    vector<tuple<char, char, int>> trans;\n\n    if (type == \"zero\") {\n        // n=0 => produce no transformations\n    }\n    else if (type == \"all_letters\") {\n        // We want to produce as many distinct letter pairs as we can\n        // But limited by n <= 500\n        // We'll produce pairs (a->b) for some subset or random set\n        // Possibly we produce min(ALPH*ALPH, n) transformations\n        // We won't produce duplicates, picking pairs systematically or randomly\n        // We'll do it systematically up to n\n        int limit = min(ALPH*ALPH, n);\n        int count = 0;\n        for (int i = 0; i < ALPH && count < limit; i++) {\n            for (int j = 0; j < ALPH && count < limit; j++) {\n                char A = char(BASE + i);\n                char B = char(BASE + j);\n                int W = rnd.next(101); \n                trans.push_back({A, B, W});\n                count++;\n            }\n        }\n    }\n    else if (type == \"some_cycle\") {\n        // We'll produce up to n transformations, ensuring a few cycles\n        // E.g. a->b, b->c, c->a might form a cycle\n        // Then fill the rest randomly\n        // We'll pick random letters for cycle\n        // (If n < 3, we just do random transformations.)\n        int cycleSize = min(n, 3);\n        vector<char> cyc;\n        for (int i = 0; i < cycleSize; i++) {\n            char c = char(BASE + rnd.next(ALPH));\n            cyc.push_back(c);\n        }\n        // tie them up in a cycle\n        for (int i = 0; i+1 < (int)cyc.size(); i++) {\n            int W = rnd.next(101);\n            trans.push_back({cyc[i], cyc[i+1], W});\n        }\n        if (cycleSize == 3) {\n            int W = rnd.next(101);\n            trans.push_back({cyc[2], cyc[0], W});\n        }\n        // fill the rest (n - cycleSize or n - cycleSize - 1) transformations randomly\n        while ((int)trans.size() < n) {\n            char A = char(BASE + rnd.next(ALPH));\n            char B = char(BASE + rnd.next(ALPH));\n            int W = rnd.next(101);\n            trans.push_back({A, B, W});\n        }\n        // If we had leftover because cycle took fewer than n lines:\n        // that is handled above by random fill\n    }\n    else if (type == \"zero_cost\") {\n        // We'll produce random transformations, but ensure some have cost 0\n        // We'll produce n transformations in total\n        // Let half of them have cost 0 if possible\n        for (int i = 0; i < n; i++) {\n            char A = char(BASE + rnd.next(ALPH));\n            char B = char(BASE + rnd.next(ALPH));\n            int W = 0;\n            if (i >= n/2) {\n                // random cost\n                W = rnd.next(101);\n            }\n            trans.push_back({A, B, W});\n        }\n    }\n    else {\n        // fallback => produce n random transformations\n        for (int i = 0; i < n; i++) {\n            char A = char(BASE + rnd.next(ALPH));\n            char B = char(BASE + rnd.next(ALPH));\n            int W = rnd.next(101);\n            trans.push_back({A, B, W});\n        }\n    }\n\n    // Now we output them:\n    // First line: s and t\n    // Then a line with n\n    // Then n lines: Ai Bi Wi\n\n    cout << s << \"\\n\";\n    cout << t << \"\\n\";\n    cout << n << \"\\n\";\n    for (int i = 0; i < (int)trans.size(); i++){\n        auto [A, B, W] = trans[i];\n        cout << A << \" \" << B << \" \" << W << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to produce multiple test cases using the above generator.\n# Each command prints a single test case to stdout. You can run them all\n# in order to gather 20+ different test inputs. No output redirection is used here.\n\n# 1) Very small, zero transformations => either cost=0 or -1\n./gen -ls 1 -lt 1 -n 0 -type zero\n\n# 2) Minimal same-length random strings with a few transformations\n./gen -ls 1 -lt 1 -n 3 -type random\n\n# 3) Different length => guaranteed -1\n./gen -ls 2 -lt 3 -n 5 -type diff_length\n\n# 4) Same random strings with n=5\n./gen -ls 5 -lt 5 -n 5 -type random\n\n# 5) \"simple_equal\": s and t identical => cost depends only on transformations\n./gen -ls 5 -lt 5 -n 5 -type simple_equal\n\n# 6) Another \"simple_equal\" with bigger size\n./gen -ls 10 -lt 10 -n 3 -type simple_equal\n\n# 7) Zero transformations but bigger strings\n./gen -ls 10 -lt 10 -n 0 -type zero\n\n# 8) \"zero_cost\": half zero cost transformations\n./gen -ls 10 -lt 10 -n 6 -type zero_cost\n\n# 9) A random test with lengths 10 and 12 => mismatch\n./gen -ls 10 -lt 12 -n 6 -type random\n\n# 10) Edge: no transformations with large strings => likely -1\n./gen -ls 100 -lt 100 -n 0 -type zero\n\n# 11) Some cycle test on small strings\n./gen -ls 5 -lt 5 -n 5 -type some_cycle\n\n# 12) Some cycle test on bigger strings\n./gen -ls 20 -lt 20 -n 10 -type some_cycle\n\n# 13) \"all_letters\" with a moderate n\n./gen -ls 10 -lt 10 -n 26 -type all_letters\n\n# 14) \"all_letters\" with up to 500 transformations\n./gen -ls 15 -lt 15 -n 500 -type all_letters\n\n# 15) Large equal strings with random transformations\n./gen -ls 1000 -lt 1000 -n 10 -type simple_equal\n\n# 16) Large random strings with random transformations\n./gen -ls 1000 -lt 1000 -n 30 -type random\n\n# 17) Large random with mismatch\n./gen -ls 999 -lt 1000 -n 50 -type random\n\n# 18) Zero-cost transformations, large\n./gen -ls 2000 -lt 2000 -n 100 -type zero_cost\n\n# 19) Some cycle test with large strings\n./gen -ls 3000 -lt 3000 -n 200 -type some_cycle\n\n# 20) Another \"all_letters\" test near n=500\n./gen -ls 200 -lt 200 -n 500 -type all_letters\n\n# 21) Very large random near the upper limit for length, with small n\n./gen -ls 100000 -lt 100000 -n 5 -type random\n\n# 22) Big mismatch: guaranteed -1\n./gen -ls 99999 -lt 100000 -n 5 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:00.042185",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "33/C",
      "title": "C. Wonderful Randomized Sum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — amount of elements in the sequence. The second line contains n integers ai ( - 104 ≤ ai ≤ 104) — the sequence itself.",
      "output_spec": "OutputThe first and the only line of the output should contain the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3-1 -2 -3OutputCopy6InputCopy5-4 2 0 5 0OutputCopy11InputCopy5-1 10 -5 10 -2OutputCopy18",
      "description": "C. Wonderful Randomized Sum\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — amount of elements in the sequence. The second line contains n integers ai ( - 104 ≤ ai ≤ 104) — the sequence itself.\n\nOutputThe first and the only line of the output should contain the answer to the problem.\n\nInputCopy3-1 -2 -3OutputCopy6InputCopy5-4 2 0 5 0OutputCopy11InputCopy5-1 10 -5 10 -2OutputCopy18\n\nInputCopy3-1 -2 -3\n\nOutputCopy6\n\nInputCopy5-4 2 0 5 0\n\nOutputCopy11\n\nInputCopy5-1 10 -5 10 -2\n\nOutputCopy18",
      "solutions": [
        {
          "title": "Codeforces Beta Round #33 (Codeforces format) - Codeforces",
          "content": "Good morning, day, evening, night to you.Welcome to the wonderful randomized contest, which is prepared for you by team Saratov SU 3 (Davtyan Edvard, Kholkin Pavel, Kudryashov Igor).Thanks to Julia Satushina, Artem Rakhov and Dmitry Matov for their help in preparing this round. Special thanks to VK company.Good luck and high rating!With best regards, Saratov SU 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/729",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 366
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/731",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/732",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"mixed\");\n\n    vector<int> a(n);\n\n    if (type == \"all_positive\") {\n        // Generate n positive numbers in [1, 10000]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"all_negative\") {\n        // Generate n negative numbers in [-10000, -1]\n        for (int i = 0; i < n; ++i) {\n            a[i] = -rnd.next(1, 10000);\n        }\n    } else if (type == \"mixed\") {\n        // Generate n numbers in [-10000, 10000]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    } else if (type == \"zeros\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"max_positive\") {\n        // All numbers are 10000\n        fill(a.begin(), a.end(), 10000);\n    } else if (type == \"max_negative\") {\n        // All numbers are -10000\n        fill(a.begin(), a.end(), -10000);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Positive number\n                a[i] = rnd.next(1, 10000);\n            } else {\n                // Negative number\n                a[i] = -rnd.next(1, 10000);\n            }\n        }\n    } else if (type == \"spikes\") {\n        // Number of spikes can be specified, default to 1\n        int num_spikes = opt<int>(\"spikes\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10,10);\n        }\n        // Add spikes\n        for (int i = 0; i < num_spikes; ++i) {\n            int pos = rnd.next(0, n-1);\n            a[pos] = rnd.next(-10000, 10000);\n        }\n    } else {\n        // Default to mixed\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"mixed\");\n\n    vector<int> a(n);\n\n    if (type == \"all_positive\") {\n        // Generate n positive numbers in [1, 10000]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"all_negative\") {\n        // Generate n negative numbers in [-10000, -1]\n        for (int i = 0; i < n; ++i) {\n            a[i] = -rnd.next(1, 10000);\n        }\n    } else if (type == \"mixed\") {\n        // Generate n numbers in [-10000, 10000]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    } else if (type == \"zeros\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"max_positive\") {\n        // All numbers are 10000\n        fill(a.begin(), a.end(), 10000);\n    } else if (type == \"max_negative\") {\n        // All numbers are -10000\n        fill(a.begin(), a.end(), -10000);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Positive number\n                a[i] = rnd.next(1, 10000);\n            } else {\n                // Negative number\n                a[i] = -rnd.next(1, 10000);\n            }\n        }\n    } else if (type == \"spikes\") {\n        // Number of spikes can be specified, default to 1\n        int num_spikes = opt<int>(\"spikes\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10,10);\n        }\n        // Add spikes\n        for (int i = 0; i < num_spikes; ++i) {\n            int pos = rnd.next(0, n-1);\n            a[pos] = rnd.next(-10000, 10000);\n        }\n    } else {\n        // Default to mixed\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type all_positive\n./gen -n 1 -type all_negative\n./gen -n 1 -type mixed\n\n./gen -n 5 -type zeros\n./gen -n 5 -type all_positive\n./gen -n 5 -type all_negative\n./gen -n 5 -type alternating\n./gen -n 5 -type mixed\n\n./gen -n 10 -type zeros\n./gen -n 10 -type alternating\n./gen -n 10 -type spikes -spikes 2\n./gen -n 10 -type mixed\n\n./gen -n 100 -type all_positive\n./gen -n 100 -type all_negative\n./gen -n 100 -type mixed\n./gen -n 100 -type alternating\n./gen -n 100 -type spikes -spikes 5\n\n./gen -n 1000 -type mixed\n./gen -n 1000 -type max_positive\n./gen -n 1000 -type max_negative\n./gen -n 1000 -type spikes -spikes 10\n\n./gen -n 10000 -type mixed\n./gen -n 10000 -type max_positive\n./gen -n 10000 -type max_negative\n./gen -n 10000 -type spikes -spikes 20\n\n./gen -n 100000 -type mixed\n./gen -n 100000 -type all_positive\n./gen -n 100000 -type all_negative\n./gen -n 100000 -type spikes -spikes 50\n./gen -n 100000 -type alternating\n\n./gen -n 100000 -type zeros\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:02.243801",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "33/D",
      "title": "D. Рыцари",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных записано три целых числа n, m, k (1 ≤ n, m ≤ 1000, 0 ≤ k ≤ 100000). В следующих n строках записано по два целых числа Kxi, Kyi ( - 109 ≤ Kxi, Kyi ≤ 109) — координаты опорной точки номер i. Опорные точки могут совпадать.Каждая из следующих m строк описывает забор номер i тремя целыми числами ri, Cxi, Cyi (1 ≤ ri ≤ 109,  - 109 ≤ Cxi, Cyi ≤ 109) — радиусом и центром окружности, на которой находится соответствующий забор. Далее заданы k пар целых чисел ai, bi (1 ≤ ai, bi ≤ n), каждая в отдельной строке — запросы на которые вам придётся отвечать. ai и bi могут совпадать.",
      "output_spec": "Выходные данныеВыведите ровно k строк, в каждой из которых записано одно число — ответ на соответствующий запрос.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 1 10 03 32 0 01 2Выходные данныеСкопировать1Входные данныеСкопировать2 3 10 04 41 0 02 0 03 0 01 2Выходные данныеСкопировать3",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано три целых числа n, m, k (1 ≤ n, m ≤ 1000, 0 ≤ k ≤ 100000). В следующих n строках записано по два целых числа Kxi, Kyi ( - 109 ≤ Kxi, Kyi ≤ 109) — координаты опорной точки номер i. Опорные точки могут совпадать.Каждая из следующих m строк описывает забор номер i тремя целыми числами ri, Cxi, Cyi (1 ≤ ri ≤ 109,  - 109 ≤ Cxi, Cyi ≤ 109) — радиусом и центром окружности, на которой находится соответствующий забор. Далее заданы k пар целых чисел ai, bi (1 ≤ ai, bi ≤ n), каждая в отдельной строке — запросы на которые вам придётся отвечать. ai и bi могут совпадать.\n\nВходные данные\n\nВыходные данныеВыведите ровно k строк, в каждой из которых записано одно число — ответ на соответствующий запрос.\n\nВыходные данные\n\nВходные данныеСкопировать2 1 10 03 32 0 01 2Выходные данныеСкопировать1Входные данныеСкопировать2 3 10 04 41 0 02 0 03 0 01 2Выходные данныеСкопировать3\n\nВходные данныеСкопировать2 1 10 03 32 0 01 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3 10 04 41 0 02 0 03 0 01 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #33 (Codeforces format) - Codeforces",
          "content": "Доброго Вам утра, дня, вечера, ночи.Приветствуем Вас на прекрасном рандомизированном контесте, который подготовила для Вас команда Саратов СУ 3 (Давтян Эдвард, Холкин Павел, Кудряшов Игорь). Сегодня вам предстоит поближе познакомиться с Валерами и Валериями и помочь им во всем, чего бы они не попросили. Надеемся на то, что соревнование Вам понравиться, ведь мы очень старались. Благодарим за помощь в подготовке контеста Артема Рахова, Юлию Сатушину и Валерия Дмитрия Матова. Кроме того отдельное спасибо компании ВКонтакте.История нашей команды началась в этом году в летней школе \"Дубки\" и едва там не закончилась. Нас спасли Петрозаводские сборы, на которые мы и уехали из \"Дубков\". Как вы могли заметить по предыдущему предложению, у нас в команде два капитана: один капитан и один Кэп (всего два). Но несмотря на это, мы очень дружная и серьезная команда и у нас очень хорошо развит командный дух. Тем временем до начала соревнования остается совсем немного.Всем участникам мы желаем успехов и высокого рейтинга!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/729",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1019
        },
        {
          "title": "Codeforces Beta Round #33. Разбор A - Codeforces",
          "content": "Разбор задачи \"A. Что у нас на ужин?\"Решение задачи достаточно тривиальное. Необходимо было завести массив , в котором для каждого ряда зубов хранилось бы значение остаточной жизнеспособности самого больного зуба в этом ряду (самым больным зубом в ряду назовем тот, у которого минимальная остаточная жизнеспособность). Таким образом мы определим для каждого ряда зубов максимальное число карасиков, которых Валерия сможет съесть, используя этот ряд (больше съесть Валерия не сможет, так как в этом случае жизнеспособность самого больного зуба станет отрицательной). Зная эти величины, нужно просто просуммировать их и в качестве ответа выдать минимум из суммы и общего числа карасиков, имеющихся в наличии у Валерии .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/731",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 717
        },
        {
          "title": "Codeforces Beta Round #33. Разбор A - Codeforces",
          "content": "Разбор задачи \"A. Что у нас на ужин?\"Решение задачи достаточно тривиальное. Необходимо было завести массив , в котором для каждого ряда зубов хранилось бы значение остаточной жизнеспособности самого больного зуба в этом ряду (самым больным зубом в ряду назовем тот, у которого минимальная остаточная жизнеспособность). Таким образом мы определим для каждого ряда зубов максимальное число карасиков, которых Валерия сможет съесть, используя этот ряд (больше съесть Валерия не сможет, так как в этом случае жизнеспособность самого больного зуба станет отрицательной). Зная эти величины, нужно просто просуммировать их и в качестве ответа выдать минимум из суммы и общего числа карасиков, имеющихся в наличии у Валерии .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/732",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 717
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #33 (Codeforces format) - Codeforces - Code 1",
          "code": "3 2 1\najjkeczpyzfplikjfj\njwvxmmyvcbadixxi\nsinbirqrkwodoouanvjklcgqh\n1 1 1\n18:08-18:17\n20:37-21:20\n22:20-22:21\n22:48-22:51\najjkeczpyzfplikjfj 1 00:02 178\njwvxmmyvcbadixxi 1 00:02 188",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/729",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #33 (Codeforces format) - Codeforces - Code 2",
          "code": "2 10 5\n-5 2\n5 -2\n10 0 0\n11 0 0\n12 0 0\n13 0 0\n1 5 -2\n2 5 -2\n3 5 -2\n4 5 -2\n4 -4 0\n1 -5 2\n1 2\n2 1\n1 2\n2 1\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/729",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nuint64_t square(int64_t x) {\n    uint64_t y = x >= 0 ? x : -x;\n    return y * y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    // Read n control points\n    vector<pair<int64_t, int64_t>> control_points(n);\n    for (int i = 0; i < n; ++i) {\n        int64_t x = inf.readLong(-1000000000LL, 1000000000LL, \"Kx_i\");\n        inf.readSpace();\n        int64_t y = inf.readLong(-1000000000LL, 1000000000LL, \"Ky_i\");\n        inf.readEoln();\n        control_points[i] = {x, y};\n    }\n\n    // Read m fences\n    vector<tuple<int64_t, int64_t, int64_t>> fences(m); // r_i, Cx_i, Cy_i\n    for (int i = 0; i < m; ++i) {\n        int64_t r = inf.readLong(1LL, 1000000000LL, \"r_i\");\n        inf.readSpace();\n        int64_t cx = inf.readLong(-1000000000LL, 1000000000LL, \"Cx_i\");\n        inf.readSpace();\n        int64_t cy = inf.readLong(-1000000000LL, 1000000000LL, \"Cy_i\");\n        inf.readEoln();\n        fences[i] = {r, cx, cy};\n    }\n\n    // Read k pairs\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    // Now perform the checks\n    // 1. Check that no two fences have common points (no overlapping or touching)\n    // For each pair of fences (i, j) where i < j\n    for (int i = 0; i < m; ++i) {\n        int64_t r1, cx1, cy1;\n        tie(r1, cx1, cy1) = fences[i];\n        for (int j = i + 1; j < m; ++j) {\n            int64_t r2, cx2, cy2;\n            tie(r2, cx2, cy2) = fences[j];\n            int64_t dx = cx1 - cx2;\n            int64_t dy = cy1 - cy2;\n            uint64_t d2 = square(dx) + square(dy);\n            int64_t sr = r1 + r2;\n            uint64_t sr2 = (uint64_t)sr * (uint64_t)sr;\n            ensuref(d2 > sr2, \"Fences %d and %d have common points\", i+1, j+1);\n        }\n    }\n\n    // 2. Check that no control point is on a fence\n    for (int i = 0; i < n; ++i) {\n        int64_t kx = control_points[i].first;\n        int64_t ky = control_points[i].second;\n        for (int j = 0; j < m; ++j) {\n            int64_t r, cx, cy;\n            tie(r, cx, cy) = fences[j];\n            int64_t dx = kx - cx;\n            int64_t dy = ky - cy;\n            uint64_t d2 = square(dx) + square(dy);\n            uint64_t r2 = (uint64_t)r * (uint64_t)r;\n            ensuref(d2 != r2, \"Control point %d lies on fence %d\", i+1, j+1);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nuint64_t square(int64_t x) {\n    uint64_t y = x >= 0 ? x : -x;\n    return y * y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    // Read n control points\n    vector<pair<int64_t, int64_t>> control_points(n);\n    for (int i = 0; i < n; ++i) {\n        int64_t x = inf.readLong(-1000000000LL, 1000000000LL, \"Kx_i\");\n        inf.readSpace();\n        int64_t y = inf.readLong(-1000000000LL, 1000000000LL, \"Ky_i\");\n        inf.readEoln();\n        control_points[i] = {x, y};\n    }\n\n    // Read m fences\n    vector<tuple<int64_t, int64_t, int64_t>> fences(m); // r_i, Cx_i, Cy_i\n    for (int i = 0; i < m; ++i) {\n        int64_t r = inf.readLong(1LL, 1000000000LL, \"r_i\");\n        inf.readSpace();\n        int64_t cx = inf.readLong(-1000000000LL, 1000000000LL, \"Cx_i\");\n        inf.readSpace();\n        int64_t cy = inf.readLong(-1000000000LL, 1000000000LL, \"Cy_i\");\n        inf.readEoln();\n        fences[i] = {r, cx, cy};\n    }\n\n    // Read k pairs\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    // Now perform the checks\n    // 1. Check that no two fences have common points (no overlapping or touching)\n    // For each pair of fences (i, j) where i < j\n    for (int i = 0; i < m; ++i) {\n        int64_t r1, cx1, cy1;\n        tie(r1, cx1, cy1) = fences[i];\n        for (int j = i + 1; j < m; ++j) {\n            int64_t r2, cx2, cy2;\n            tie(r2, cx2, cy2) = fences[j];\n            int64_t dx = cx1 - cx2;\n            int64_t dy = cy1 - cy2;\n            uint64_t d2 = square(dx) + square(dy);\n            int64_t sr = r1 + r2;\n            uint64_t sr2 = (uint64_t)sr * (uint64_t)sr;\n            ensuref(d2 > sr2, \"Fences %d and %d have common points\", i+1, j+1);\n        }\n    }\n\n    // 2. Check that no control point is on a fence\n    for (int i = 0; i < n; ++i) {\n        int64_t kx = control_points[i].first;\n        int64_t ky = control_points[i].second;\n        for (int j = 0; j < m; ++j) {\n            int64_t r, cx, cy;\n            tie(r, cx, cy) = fences[j];\n            int64_t dx = kx - cx;\n            int64_t dy = ky - cy;\n            uint64_t d2 = square(dx) + square(dy);\n            uint64_t r2 = (uint64_t)r * (uint64_t)r;\n            ensuref(d2 != r2, \"Control point %d lies on fence %d\", i+1, j+1);\n        }\n    }\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nuint64_t square(int64_t x) {\n    uint64_t y = x >= 0 ? x : -x;\n    return y * y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    // Read n control points\n    vector<pair<int64_t, int64_t>> control_points(n);\n    for (int i = 0; i < n; ++i) {\n        int64_t x = inf.readLong(-1000000000LL, 1000000000LL, \"Kx_i\");\n        inf.readSpace();\n        int64_t y = inf.readLong(-1000000000LL, 1000000000LL, \"Ky_i\");\n        inf.readEoln();\n        control_points[i] = {x, y};\n    }\n\n    // Read m fences\n    vector<tuple<int64_t, int64_t, int64_t>> fences(m); // r_i, Cx_i, Cy_i\n    for (int i = 0; i < m; ++i) {\n        int64_t r = inf.readLong(1LL, 1000000000LL, \"r_i\");\n        inf.readSpace();\n        int64_t cx = inf.readLong(-1000000000LL, 1000000000LL, \"Cx_i\");\n        inf.readSpace();\n        int64_t cy = inf.readLong(-1000000000LL, 1000000000LL, \"Cy_i\");\n        inf.readEoln();\n        fences[i] = {r, cx, cy};\n    }\n\n    // Read k pairs\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    // Now perform the checks\n    // 1. Check that no two fences have common points (no overlapping or touching)\n    // For each pair of fences (i, j) where i < j\n    for (int i = 0; i < m; ++i) {\n        int64_t r1, cx1, cy1;\n        tie(r1, cx1, cy1) = fences[i];\n        for (int j = i + 1; j < m; ++j) {\n            int64_t r2, cx2, cy2;\n            tie(r2, cx2, cy2) = fences[j];\n            int64_t dx = cx1 - cx2;\n            int64_t dy = cy1 - cy2;\n            uint64_t d2 = square(dx) + square(dy);\n            int64_t sr = r1 + r2;\n            uint64_t sr2 = (uint64_t)sr * (uint64_t)sr;\n            ensuref(d2 > sr2, \"Fences %d and %d have common points\", i+1, j+1);\n        }\n    }\n\n    // 2. Check that no control point is on a fence\n    for (int i = 0; i < n; ++i) {\n        int64_t kx = control_points[i].first;\n        int64_t ky = control_points[i].second;\n        for (int j = 0; j < m; ++j) {\n            int64_t r, cx, cy;\n            tie(r, cx, cy) = fences[j];\n            int64_t dx = kx - cx;\n            int64_t dy = ky - cy;\n            uint64_t d2 = square(dx) + square(dy);\n            uint64_t r2 = (uint64_t)r * (uint64_t)r;\n            ensuref(d2 != r2, \"Control point %d lies on fence %d\", i+1, j+1);\n        }\n    }\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", 0); // default 0\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<ll, ll>> control_points(n);\n    vector<ll> Cx(m), Cy(m), ri(m); // Centers and radii of fences\n\n    if (type == \"random\") {\n        // Generate control points randomly\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1000000000LL, 1000000000LL);\n            ll y = rnd.next(-1000000000LL, 1000000000LL);\n            control_points[i] = make_pair(x, y);\n        }\n\n        // Generate m fences\n        // Use grid method to place centers far apart\n\n        int G = int(sqrt(m)) + 1;\n        ll S = 300000LL;\n        ll max_r = 100000LL;\n        ll min_r = 10000LL;\n\n        vector<pair<ll, ll> > positions;\n\n        ll start_x = -1000000000LL + max_r + 1000000LL;\n        ll start_y = -1000000000LL + max_r + 1000000LL;\n\n        for (int i = 0; i < G; ++i) {\n            for (int j = 0; j < G; ++j) {\n                positions.push_back(make_pair(start_x + i * S, start_y + j * S));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int i = 0; i < m; ++i) {\n            Cx[i] = positions[i].first;\n            Cy[i] = positions[i].second;\n            ri[i] = rnd.next(min_r, max_r);\n        }\n\n    } else if (type == \"nested\") {\n        // Generate nested fences\n        // Use same center, decreasing radii\n\n        // Center at (0,0)\n        ll center_x = rnd.next(-1000000000LL + 1000000LL, 1000000000LL - 1000000LL);\n        ll center_y = rnd.next(-1000000000LL + 1000000LL, 1000000000LL - 1000000LL);\n\n        ll max_r = 1000000000LL - max(abs(center_x), abs(center_y)) - 1000000LL;\n        ll min_r = 1LL;\n\n        for (int i = 0; i < m; ++i) {\n            ri[i] = max_r - (max_r - min_r) * i / m;\n            Cx[i] = center_x;\n            Cy[i] = center_y;\n        }\n\n        // Generate control points randomly, avoid being on fences\n\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1000000000LL, 1000000000LL);\n            ll y = rnd.next(-1000000000LL, 1000000000LL);\n            control_points[i] = make_pair(x, y);\n        }\n\n    } else if (type == \"max_coord\") {\n        // Generate control points and fences at coordinate limits\n\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            ll y = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            control_points[i] = make_pair(x, y);\n        }\n\n        // Generate fences at coordinate limits\n\n        for (int i = 0; i < m; ++i) {\n            ll x = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            ll y = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            ll r = 1LL; // Minimum radius\n            Cx[i] = x;\n            Cy[i] = y;\n            ri[i] = r;\n        }\n\n    } else if (type == \"coincide_control_points\") {\n        // Generate control points that coincide\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                control_points[i] = make_pair(0LL, 0LL);\n            } else {\n                ll x = rnd.next(-1000000000LL, 1000000000LL);\n                ll y = rnd.next(-1000000000LL, 1000000000LL);\n                control_points[i] = make_pair(x, y);\n            }\n        }\n\n        // Generate fences as in random type\n\n        int G = int(sqrt(m)) + 1;\n        ll S = 300000LL;\n        ll max_r = 100000LL;\n        ll min_r = 10000LL;\n\n        vector<pair<ll, ll> > positions;\n\n        ll start_x = -1000000000LL + max_r + 1000000LL;\n        ll start_y = -1000000000LL + max_r + 1000000LL;\n\n        for (int i = 0; i < G; ++i) {\n            for (int j = 0; j < G; ++j) {\n                positions.push_back(make_pair(start_x + i * S, start_y + j * S));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int i = 0; i < m; ++i) {\n            Cx[i] = positions[i].first;\n            Cy[i] = positions[i].second;\n            ri[i] = rnd.next(min_r, max_r);\n        }\n\n    } else {\n        // Default to random type\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1000000000LL, 1000000000LL);\n            ll y = rnd.next(-1000000000LL, 1000000000LL);\n            control_points[i] = make_pair(x, y);\n        }\n\n        // Generate fences as in random type\n\n        int G = int(sqrt(m)) + 1;\n        ll S = 300000LL;\n        ll max_r = 100000LL;\n        ll min_r = 10000LL;\n\n        vector<pair<ll, ll> > positions;\n\n        ll start_x = -1000000000LL + max_r + 1000000LL;\n        ll start_y = -1000000000LL + max_r + 1000000LL;\n\n        for (int i = 0; i < G; ++i) {\n            for (int j = 0; j < G; ++j) {\n                positions.push_back(make_pair(start_x + i * S, start_y + j * S));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int i = 0; i < m; ++i) {\n            Cx[i] = positions[i].first;\n            Cy[i] = positions[i].second;\n            ri[i] = rnd.next(min_r, max_r);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output n control points\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", control_points[i].first, control_points[i].second);\n    }\n\n    // Output m fences\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld %lld %lld\\n\", ri[i], Cx[i], Cy[i]);\n    }\n\n    // Generate k queries\n    for (int i = 0; i < k; ++i) {\n        int ai = rnd.next(1, n);\n        int bi = rnd.next(1, n);\n        printf(\"%d %d\\n\", ai, bi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", 0); // default 0\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<ll, ll>> control_points(n);\n    vector<ll> Cx(m), Cy(m), ri(m); // Centers and radii of fences\n\n    if (type == \"random\") {\n        // Generate control points randomly\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1000000000LL, 1000000000LL);\n            ll y = rnd.next(-1000000000LL, 1000000000LL);\n            control_points[i] = make_pair(x, y);\n        }\n\n        // Generate m fences\n        // Use grid method to place centers far apart\n\n        int G = int(sqrt(m)) + 1;\n        ll S = 300000LL;\n        ll max_r = 100000LL;\n        ll min_r = 10000LL;\n\n        vector<pair<ll, ll> > positions;\n\n        ll start_x = -1000000000LL + max_r + 1000000LL;\n        ll start_y = -1000000000LL + max_r + 1000000LL;\n\n        for (int i = 0; i < G; ++i) {\n            for (int j = 0; j < G; ++j) {\n                positions.push_back(make_pair(start_x + i * S, start_y + j * S));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int i = 0; i < m; ++i) {\n            Cx[i] = positions[i].first;\n            Cy[i] = positions[i].second;\n            ri[i] = rnd.next(min_r, max_r);\n        }\n\n    } else if (type == \"nested\") {\n        // Generate nested fences\n        // Use same center, decreasing radii\n\n        // Center at (0,0)\n        ll center_x = rnd.next(-1000000000LL + 1000000LL, 1000000000LL - 1000000LL);\n        ll center_y = rnd.next(-1000000000LL + 1000000LL, 1000000000LL - 1000000LL);\n\n        ll max_r = 1000000000LL - max(abs(center_x), abs(center_y)) - 1000000LL;\n        ll min_r = 1LL;\n\n        for (int i = 0; i < m; ++i) {\n            ri[i] = max_r - (max_r - min_r) * i / m;\n            Cx[i] = center_x;\n            Cy[i] = center_y;\n        }\n\n        // Generate control points randomly, avoid being on fences\n\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1000000000LL, 1000000000LL);\n            ll y = rnd.next(-1000000000LL, 1000000000LL);\n            control_points[i] = make_pair(x, y);\n        }\n\n    } else if (type == \"max_coord\") {\n        // Generate control points and fences at coordinate limits\n\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            ll y = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            control_points[i] = make_pair(x, y);\n        }\n\n        // Generate fences at coordinate limits\n\n        for (int i = 0; i < m; ++i) {\n            ll x = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            ll y = rnd.next(2) ? 1000000000LL : -1000000000LL;\n            ll r = 1LL; // Minimum radius\n            Cx[i] = x;\n            Cy[i] = y;\n            ri[i] = r;\n        }\n\n    } else if (type == \"coincide_control_points\") {\n        // Generate control points that coincide\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                control_points[i] = make_pair(0LL, 0LL);\n            } else {\n                ll x = rnd.next(-1000000000LL, 1000000000LL);\n                ll y = rnd.next(-1000000000LL, 1000000000LL);\n                control_points[i] = make_pair(x, y);\n            }\n        }\n\n        // Generate fences as in random type\n\n        int G = int(sqrt(m)) + 1;\n        ll S = 300000LL;\n        ll max_r = 100000LL;\n        ll min_r = 10000LL;\n\n        vector<pair<ll, ll> > positions;\n\n        ll start_x = -1000000000LL + max_r + 1000000LL;\n        ll start_y = -1000000000LL + max_r + 1000000LL;\n\n        for (int i = 0; i < G; ++i) {\n            for (int j = 0; j < G; ++j) {\n                positions.push_back(make_pair(start_x + i * S, start_y + j * S));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int i = 0; i < m; ++i) {\n            Cx[i] = positions[i].first;\n            Cy[i] = positions[i].second;\n            ri[i] = rnd.next(min_r, max_r);\n        }\n\n    } else {\n        // Default to random type\n        for (int i = 0; i < n; ++i) {\n            ll x = rnd.next(-1000000000LL, 1000000000LL);\n            ll y = rnd.next(-1000000000LL, 1000000000LL);\n            control_points[i] = make_pair(x, y);\n        }\n\n        // Generate fences as in random type\n\n        int G = int(sqrt(m)) + 1;\n        ll S = 300000LL;\n        ll max_r = 100000LL;\n        ll min_r = 10000LL;\n\n        vector<pair<ll, ll> > positions;\n\n        ll start_x = -1000000000LL + max_r + 1000000LL;\n        ll start_y = -1000000000LL + max_r + 1000000LL;\n\n        for (int i = 0; i < G; ++i) {\n            for (int j = 0; j < G; ++j) {\n                positions.push_back(make_pair(start_x + i * S, start_y + j * S));\n            }\n        }\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int i = 0; i < m; ++i) {\n            Cx[i] = positions[i].first;\n            Cy[i] = positions[i].second;\n            ri[i] = rnd.next(min_r, max_r);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output n control points\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", control_points[i].first, control_points[i].second);\n    }\n\n    // Output m fences\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld %lld %lld\\n\", ri[i], Cx[i], Cy[i]);\n    }\n\n    // Generate k queries\n    for (int i = 0; i < k; ++i) {\n        int ai = rnd.next(1, n);\n        int bi = rnd.next(1, n);\n        printf(\"%d %d\\n\", ai, bi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -k 0 -type random\n./gen -n 2 -m 1 -k 1 -type random\n./gen -n 5 -m 0 -k 10 -type random\n\n./gen -n 1000 -m 0 -k 0 -type random\n\n./gen -n 1000 -m 1000 -k 100000 -type random\n./gen -n 1000 -m 1000 -k 100000 -type nested\n./gen -n 1000 -m 1000 -k 100000 -type coincide_control_points\n./gen -n 1000 -m 1000 -k 100000 -type max_coord\n\n./gen -n 2 -m 1000 -k 100000 -type nested\n\n./gen -n 1000 -m 10 -k 100000 -type random\n./gen -n 10 -m 1000 -k 100000 -type random\n\n./gen -n 1000 -m 1000 -k 0 -type random\n\n./gen -n 1000 -m 500 -k 100000 -type nested\n./gen -n 1000 -m 500 -k 100000 -type random\n\n./gen -n 1000 -m 1000 -k 0 -type coincide_control_points\n\n./gen -n 1 -m 1000 -k 100000 -type random\n./gen -n 1 -m 1000 -k 100000 -type nested\n\n./gen -n 1000 -m 0 -k 100000 -type random\n./gen -n 1000 -m 0 -k 100000 -type coincide_control_points\n./gen -n 1000 -m 0 -k 100000 -type max_coord\n\n./gen -n 500 -m 0 -k 100000 -type random\n./gen -n 500 -m 0 -k 100000 -type nested\n\n./gen -n 500 -m 500 -k 50000 -type random\n./gen -n 500 -m 500 -k 50000 -type nested\n\n./gen -n 1000 -m 1000 -k 100000 -type random\n./gen -n 1000 -m 1000 -k 100000 -type nested\n./gen -n 1000 -m 1000 -k 100000 -type coincide_control_points\n./gen -n 1000 -m 1000 -k 100000 -type max_coord\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:04.585067",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "33/E",
      "title": "E. Helper",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers m, n, k (1 ≤ m, n ≤ 100, 1 ≤ k ≤ 30) — amount of subjects on the list, amount of Valera's potential employers and the duration of the exam period in days.The following m lines contain the names of subjects listi (listi is a non-empty string of at most 32 characters, consisting of lower case Latin letters). It's guaranteed that no two subjects are the same.The (m + 2)-th line contains m integers ti (1 ≤ ti ≤ 1000) — time in minutes that Valera spends to solve problems of the i-th subject. Then follow four lines, containing time segments for sleep, breakfast, lunch and dinner correspondingly.Each line is in format H1:M1-H2:M2, where 00 ≤  H1, H2  ≤ 23, 00 ≤  M1, M2  ≤ 59. Time H1:M1 stands for the first minute of some Valera's action, and time H2:M2 stands for the last minute of this action. No two time segments cross. It's guaranteed that Valera goes to bed before midnight, gets up earlier than he has breakfast, finishes his breakfast before lunch, finishes his lunch before dinner, and finishes his dinner before midnight. All these actions last less than a day, but not less than one minute. Time of the beginning and time of the ending of each action are within one and the same day. But it's possible that Valera has no time for solving problems.Then follow n lines, each containing the description of students. For each student the following is known: his exam subject si (si is a non-empty string of at most 32 characters, consisting of lower case Latin letters), index of the exam day di (1 ≤ di ≤ k), the exam time timei, and sum of money ci (0 ≤ ci ≤ 106, ci — integer) that he's ready to pay for Valera's help. Exam time timei is in the format HH:MM, where 00 ≤  HH  ≤ 23, 00 ≤  MM  ≤ 59. Valera will get money, if he finishes to solve the problem strictly before the corresponding student's exam begins.",
      "output_spec": "OutputIn the first line output the maximum profit that Valera can get. The second line should contain number p — amount of problems that Valera is to solve. In the following p lines output the order of solving problems in chronological order in the following format: index of a student, to whom Valera is to help; index of the time, when Valera should start the problem; time, when Valera should start the problem (the first minute of his work); index of the day, when Valera should finish the problem; time, when Valera should finish the problem (the last minute of his work). To understand the output format better, study the sample tests.",
      "sample_tests": "ExamplesInputCopy3 3 4calculusalgebrahistory58 23 1500:00-08:1508:20-08:3509:30-10:2519:00-19:45calculus 1 09:36 100english 4 21:15 5000history 1 19:50 50OutputCopy15021 1 08:16 1 09:293 1 10:26 1 10:40InputCopy2 2 1matancodeforces1 200:00-08:0009:00-09:0012:00-12:0018:00-18:00codeforces 1 08:04 2matan 1 08:02 1OutputCopy322 1 08:01 1 08:011 1 08:02 1 08:03InputCopy2 2 1matancodeforces2 200:00-08:0009:00-09:0012:00-12:0018:00-18:00codeforces 1 08:04 2matan 1 08:03 1OutputCopy211 1 08:01 1 08:02",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers m, n, k (1 ≤ m, n ≤ 100, 1 ≤ k ≤ 30) — amount of subjects on the list, amount of Valera's potential employers and the duration of the exam period in days.The following m lines contain the names of subjects listi (listi is a non-empty string of at most 32 characters, consisting of lower case Latin letters). It's guaranteed that no two subjects are the same.The (m + 2)-th line contains m integers ti (1 ≤ ti ≤ 1000) — time in minutes that Valera spends to solve problems of the i-th subject. Then follow four lines, containing time segments for sleep, breakfast, lunch and dinner correspondingly.Each line is in format H1:M1-H2:M2, where 00 ≤  H1, H2  ≤ 23, 00 ≤  M1, M2  ≤ 59. Time H1:M1 stands for the first minute of some Valera's action, and time H2:M2 stands for the last minute of this action. No two time segments cross. It's guaranteed that Valera goes to bed before midnight, gets up earlier than he has breakfast, finishes his breakfast before lunch, finishes his lunch before dinner, and finishes his dinner before midnight. All these actions last less than a day, but not less than one minute. Time of the beginning and time of the ending of each action are within one and the same day. But it's possible that Valera has no time for solving problems.Then follow n lines, each containing the description of students. For each student the following is known: his exam subject si (si is a non-empty string of at most 32 characters, consisting of lower case Latin letters), index of the exam day di (1 ≤ di ≤ k), the exam time timei, and sum of money ci (0 ≤ ci ≤ 106, ci — integer) that he's ready to pay for Valera's help. Exam time timei is in the format HH:MM, where 00 ≤  HH  ≤ 23, 00 ≤  MM  ≤ 59. Valera will get money, if he finishes to solve the problem strictly before the corresponding student's exam begins.\n\nOutputIn the first line output the maximum profit that Valera can get. The second line should contain number p — amount of problems that Valera is to solve. In the following p lines output the order of solving problems in chronological order in the following format: index of a student, to whom Valera is to help; index of the time, when Valera should start the problem; time, when Valera should start the problem (the first minute of his work); index of the day, when Valera should finish the problem; time, when Valera should finish the problem (the last minute of his work). To understand the output format better, study the sample tests.\n\nInputCopy3 3 4calculusalgebrahistory58 23 1500:00-08:1508:20-08:3509:30-10:2519:00-19:45calculus 1 09:36 100english 4 21:15 5000history 1 19:50 50OutputCopy15021 1 08:16 1 09:293 1 10:26 1 10:40InputCopy2 2 1matancodeforces1 200:00-08:0009:00-09:0012:00-12:0018:00-18:00codeforces 1 08:04 2matan 1 08:02 1OutputCopy322 1 08:01 1 08:011 1 08:02 1 08:03InputCopy2 2 1matancodeforces2 200:00-08:0009:00-09:0012:00-12:0018:00-18:00codeforces 1 08:04 2matan 1 08:03 1OutputCopy211 1 08:01 1 08:02\n\nInputCopy3 3 4calculusalgebrahistory58 23 1500:00-08:1508:20-08:3509:30-10:2519:00-19:45calculus 1 09:36 100english 4 21:15 5000history 1 19:50 50\n\nOutputCopy15021 1 08:16 1 09:293 1 10:26 1 10:40\n\nInputCopy2 2 1matancodeforces1 200:00-08:0009:00-09:0012:00-12:0018:00-18:00codeforces 1 08:04 2matan 1 08:02 1\n\nOutputCopy322 1 08:01 1 08:011 1 08:02 1 08:03\n\nInputCopy2 2 1matancodeforces2 200:00-08:0009:00-09:0012:00-12:0018:00-18:00codeforces 1 08:04 2matan 1 08:03 1\n\nOutputCopy211 1 08:01 1 08:02",
      "solutions": [
        {
          "title": "Codeforces Beta Round #33 (Codeforces format) - Codeforces",
          "content": "Good morning, day, evening, night to you.Welcome to the wonderful randomized contest, which is prepared for you by team Saratov SU 3 (Davtyan Edvard, Kholkin Pavel, Kudryashov Igor).Thanks to Julia Satushina, Artem Rakhov and Dmitry Matov for their help in preparing this round. Special thanks to VK company.Good luck and high rating!With best regards, Saratov SU 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/729",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 366
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/731",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        },
        {
          "title": "Codeforces Beta Round #33. Analysis of problem A - Codeforces",
          "content": "Analysis of problem \"A. What is for dinner?\"The solution of the problem is rather trivial. It was needed to make an array, where for each row of teeth the value of residual viability of the sickest thooth in this row would have kept (sickest tooth in the row is called the one with the lowest residual viability).Thus we define for each row of teeth the maximum number of crucians, which Valery able to eat, using this row (Valeria can not eat more crucians, because the residual viability of the sickest tooth will become negative).Knowing these values, you just need to sum them and to give the minimum of the sum and total amount of crucians in Valerie's portion for dinner as answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/732",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 687
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Segment {\n    int start;\n    int end;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30, \"k\");\n    inf.readEoln();\n\n    set<string> subjects;\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine(\"[a-z]{1,32}\", \"listi\");\n        ensuref(!s.empty(), \"Subject name must not be empty\");\n        ensuref(subjects.find(s) == subjects.end(), \"Subjects must be unique\");\n        subjects.insert(s);\n    }\n\n    vector<int> ti = inf.readInts(m, 1, 1000, \"ti\");\n    inf.readEoln();\n\n    vector<Segment> segments;\n    for (int i = 0; i < 4; ++i) {\n        string ts = inf.readLine(\"[0-9]{2}:[0-9]{2}-[0-9]{2}:[0-9]{2}\", \"time segment\");\n\n        int H1 = stoi(ts.substr(0,2));\n        int M1 = stoi(ts.substr(3,2));\n        int H2 = stoi(ts.substr(6,2));\n        int M2 = stoi(ts.substr(9,2));\n\n        ensuref(0 <= H1 && H1 <= 23, \"Hours must be between 00 and 23\");\n        ensuref(0 <= M1 && M1 <= 59, \"Minutes must be between 00 and 59\");\n        ensuref(0 <= H2 && H2 <= 23, \"Hours must be between 00 and 23\");\n        ensuref(0 <= M2 && M2 <= 59, \"Minutes must be between 00 and 59\");\n\n        int start = H1 * 60 + M1;\n        int end = H2 * 60 + M2;\n\n        ensuref(start <= end, \"Time segments must be within one day\");\n\n        int duration = end - start + 1;\n        ensuref(duration >= 1, \"Each time segment must last at least one minute\");\n        ensuref(duration < 1440, \"Each time segment must last less than a day\");\n\n        segments.push_back({start, end});\n    }\n\n    ensuref(segments[0].start < 1440, \"Sleep time must start before midnight\");\n    ensuref(segments[3].end < 1440, \"Dinner must end before midnight\");\n    ensuref(segments[0].end < segments[1].start, \"Sleep must end before breakfast starts\");\n    ensuref(segments[1].end < segments[2].start, \"Breakfast must end before lunch starts\");\n    ensuref(segments[2].end < segments[3].start, \"Lunch must end before dinner starts\");\n\n    for (int i = 0; i < 4; ++i) {\n        for (int j = i + 1; j < 4; ++j) {\n            ensuref(segments[i].end < segments[j].start || segments[j].end < segments[i].start, \"Time segments must not overlap\");\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        string si = inf.readToken(\"[a-z]{1,32}\", \"si\");\n        inf.readSpace();\n        int di = inf.readInt(1, k, \"di\");\n        inf.readSpace();\n        string timei = inf.readToken(\"[0-9]{2}:[0-9]{2}\", \"timei\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(timei.length() == 5, \"Invalid time format\");\n        ensuref(timei[2] == ':', \"Invalid time format\");\n        int HH = stoi(timei.substr(0, 2));\n        int MM = stoi(timei.substr(3, 2));\n        ensuref(0 <= HH && HH <= 23, \"Hour must be between 00 and 23\");\n        ensuref(0 <= MM && MM <= 59, \"Minute must be between 00 and 59\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Segment {\n    int start;\n    int end;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30, \"k\");\n    inf.readEoln();\n\n    set<string> subjects;\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine(\"[a-z]{1,32}\", \"listi\");\n        ensuref(!s.empty(), \"Subject name must not be empty\");\n        ensuref(subjects.find(s) == subjects.end(), \"Subjects must be unique\");\n        subjects.insert(s);\n    }\n\n    vector<int> ti = inf.readInts(m, 1, 1000, \"ti\");\n    inf.readEoln();\n\n    vector<Segment> segments;\n    for (int i = 0; i < 4; ++i) {\n        string ts = inf.readLine(\"[0-9]{2}:[0-9]{2}-[0-9]{2}:[0-9]{2}\", \"time segment\");\n\n        int H1 = stoi(ts.substr(0,2));\n        int M1 = stoi(ts.substr(3,2));\n        int H2 = stoi(ts.substr(6,2));\n        int M2 = stoi(ts.substr(9,2));\n\n        ensuref(0 <= H1 && H1 <= 23, \"Hours must be between 00 and 23\");\n        ensuref(0 <= M1 && M1 <= 59, \"Minutes must be between 00 and 59\");\n        ensuref(0 <= H2 && H2 <= 23, \"Hours must be between 00 and 23\");\n        ensuref(0 <= M2 && M2 <= 59, \"Minutes must be between 00 and 59\");\n\n        int start = H1 * 60 + M1;\n        int end = H2 * 60 + M2;\n\n        ensuref(start <= end, \"Time segments must be within one day\");\n\n        int duration = end - start + 1;\n        ensuref(duration >= 1, \"Each time segment must last at least one minute\");\n        ensuref(duration < 1440, \"Each time segment must last less than a day\");\n\n        segments.push_back({start, end});\n    }\n\n    ensuref(segments[0].start < 1440, \"Sleep time must start before midnight\");\n    ensuref(segments[3].end < 1440, \"Dinner must end before midnight\");\n    ensuref(segments[0].end < segments[1].start, \"Sleep must end before breakfast starts\");\n    ensuref(segments[1].end < segments[2].start, \"Breakfast must end before lunch starts\");\n    ensuref(segments[2].end < segments[3].start, \"Lunch must end before dinner starts\");\n\n    for (int i = 0; i < 4; ++i) {\n        for (int j = i + 1; j < 4; ++j) {\n            ensuref(segments[i].end < segments[j].start || segments[j].end < segments[i].start, \"Time segments must not overlap\");\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        string si = inf.readToken(\"[a-z]{1,32}\", \"si\");\n        inf.readSpace();\n        int di = inf.readInt(1, k, \"di\");\n        inf.readSpace();\n        string timei = inf.readToken(\"[0-9]{2}:[0-9]{2}\", \"timei\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(timei.length() == 5, \"Invalid time format\");\n        ensuref(timei[2] == ':', \"Invalid time format\");\n        int HH = stoi(timei.substr(0, 2));\n        int MM = stoi(timei.substr(3, 2));\n        ensuref(0 <= HH && HH <= 23, \"Hour must be between 00 and 23\");\n        ensuref(0 <= MM && MM <= 59, \"Minute must be between 00 and 59\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Segment {\n    int start;\n    int end;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30, \"k\");\n    inf.readEoln();\n\n    set<string> subjects;\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine(\"[a-z]{1,32}\", \"listi\");\n        ensuref(!s.empty(), \"Subject name must not be empty\");\n        ensuref(subjects.find(s) == subjects.end(), \"Subjects must be unique\");\n        subjects.insert(s);\n    }\n\n    vector<int> ti = inf.readInts(m, 1, 1000, \"ti\");\n    inf.readEoln();\n\n    vector<Segment> segments;\n    for (int i = 0; i < 4; ++i) {\n        string ts = inf.readLine(\"[0-9]{2}:[0-9]{2}-[0-9]{2}:[0-9]{2}\", \"time segment\");\n\n        int H1 = stoi(ts.substr(0,2));\n        int M1 = stoi(ts.substr(3,2));\n        int H2 = stoi(ts.substr(6,2));\n        int M2 = stoi(ts.substr(9,2));\n\n        ensuref(0 <= H1 && H1 <= 23, \"Hours must be between 00 and 23\");\n        ensuref(0 <= M1 && M1 <= 59, \"Minutes must be between 00 and 59\");\n        ensuref(0 <= H2 && H2 <= 23, \"Hours must be between 00 and 23\");\n        ensuref(0 <= M2 && M2 <= 59, \"Minutes must be between 00 and 59\");\n\n        int start = H1 * 60 + M1;\n        int end = H2 * 60 + M2;\n\n        ensuref(start <= end, \"Time segments must be within one day\");\n\n        int duration = end - start + 1;\n        ensuref(duration >= 1, \"Each time segment must last at least one minute\");\n        ensuref(duration < 1440, \"Each time segment must last less than a day\");\n\n        segments.push_back({start, end});\n    }\n\n    ensuref(segments[0].start < 1440, \"Sleep time must start before midnight\");\n    ensuref(segments[3].end < 1440, \"Dinner must end before midnight\");\n    ensuref(segments[0].end < segments[1].start, \"Sleep must end before breakfast starts\");\n    ensuref(segments[1].end < segments[2].start, \"Breakfast must end before lunch starts\");\n    ensuref(segments[2].end < segments[3].start, \"Lunch must end before dinner starts\");\n\n    for (int i = 0; i < 4; ++i) {\n        for (int j = i + 1; j < 4; ++j) {\n            ensuref(segments[i].end < segments[j].start || segments[j].end < segments[i].start, \"Time segments must not overlap\");\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        string si = inf.readToken(\"[a-z]{1,32}\", \"si\");\n        inf.readSpace();\n        int di = inf.readInt(1, k, \"di\");\n        inf.readSpace();\n        string timei = inf.readToken(\"[0-9]{2}:[0-9]{2}\", \"timei\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(timei.length() == 5, \"Invalid time format\");\n        ensuref(timei[2] == ':', \"Invalid time format\");\n        int HH = stoi(timei.substr(0, 2));\n        int MM = stoi(timei.substr(3, 2));\n        ensuref(0 <= HH && HH <= 23, \"Hour must be between 00 and 23\");\n        ensuref(0 <= MM && MM <= 59, \"Minute must be between 00 and 59\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  We have a scheduling/optimization problem with potentially multiple correct solutions \n  (different orders of solving problems can yield the same optimal profit). \n  Therefore, we provide a custom checker using testlib.\n\n  Outline of checks:\n   1. Parse the entire input from inf.\n   2. Define a function readAns(...) that:\n      - Reads the claimed total profit and number of tasks from the stream.\n      - Reads each scheduled task (student index, start day, start time, end day, end time).\n      - Simulates whether the schedule is valid:\n         * Tasks appear in non-decreasing order of (day, time).\n         * Each student subject is in the known subject-list.\n         * Ensure the exact subject solving time matches the difference between \n           the start and end times, discounting the 4 daily breaks (sleep/breakfast/lunch/dinner).\n         * Ensure finishing time is strictly before that student's exam day/time.\n      - Sums the cost. Checks it matches the participant's claimed total profit.\n      - Returns that sum to the main checker.\n   3. Compare participant's sum (pans) with jury's sum (jans):\n      - if pans < jans => _wa\n      - if pans == jans => _ok\n      - if pans > jans => _fail\n*/\n\nstatic const int MINUTES_PER_DAY = 24*60;\n\n// Data structures to hold input\nstruct SubjectInfo {\n    string name;\n    int solveTime; // minutes needed to solve\n};\n\nstruct TimeInterval {\n    int start; // inclusive, minute of the day\n    int end;   // inclusive, minute of the day\n};\n\nstruct StudentInfo {\n    string subject;\n    int examDay;\n    int examMinute; // from 0..1439 for that day\n    long long cost;\n};\n\nint m, n, k;\nvector<SubjectInfo> subjects;\nunordered_map<string,int> subjectIndex; // map from subject name -> index in subjects\nvector<StudentInfo> students;\n\n// For each day, we will store the \"break intervals\" that Valera CANNOT work in that day.\n// We have 4 intervals each day: sleep, breakfast, lunch, dinner.\nvector<TimeInterval> dailyBreaks; // size=4, stored in increasing order for a single day\n\n// Parse \"HH:MM\" into integer minute of day, from 0..1439\nint parseHHMM(const string &s) {\n    // s in format \"HH:MM\"\n    int HH = stoi(s.substr(0,2));\n    int MM = stoi(s.substr(3,2));\n    return HH*60 + MM;\n}\n\n// Parse line \"HH1:MM1-HH2:MM2\" into a TimeInterval\nTimeInterval parseInterval(const string &s) {\n    // format: \"HH1:MM1-HH2:MM2\"\n    // We'll parse each side.\n    // The problem states the interval is from H1:M1 to H2:M2 inclusive in sense of daily action.\n    // We'll keep it in [start, end], inclusive, in minutes from 0..1439.\n    int dashPos = s.find('-');\n    string left = s.substr(0, dashPos);\n    string right = s.substr(dashPos+1);\n    TimeInterval ret;\n    ret.start = parseHHMM(left);\n    ret.end   = parseHHMM(right);\n    return ret;\n}\n\n// We'll store for each day a set of intervals in which Valera CANNOT work. \n// We will compute workable time in a given [t1, t2] by subtracting these breaks day by day.\n\n// Return how many workable minutes are in [startAbs, endAbs], inclusive of endpoints,\n// given the daily breaks. startAbs and endAbs are absolute minutes from day=0. \n// For instance, day d starts at d*1440.\nlong long calcWorkTime(long long startAbs, long long endAbs) {\n    if (endAbs < startAbs) return 0; \n    long long total = 0;\n    // We'll iterate day by day\n    // each day index = floor(current / 1440)\n    // within that day, we consider [ dayBase, dayBase+1439 ], \n    // intersect with [startAbs, endAbs], then subtract the break intervals.\n    for(long long cur = startAbs; cur <= endAbs; ) {\n        long long dayIndex = cur / MINUTES_PER_DAY;\n        if(dayIndex >= k) {\n            // Problem states exam period is k days, presumably after day k there's no meaning,\n            // but let's allow reading. We'll do no day constraints here except that \n            // it won't help to schedule beyond day k. Usually we expect endDay <= k. \n            // We'll still handle it to avoid negative indexes.\n        }\n        long long dayBase = dayIndex * (long long)MINUTES_PER_DAY;\n        long long dayEndAbs = dayBase + MINUTES_PER_DAY - 1; // last minute of that day\n\n        // The chunk we are analyzing is from 'cur' up to min(endAbs, dayEndAbs)\n        long long chunkEnd = min((long long)endAbs, dayEndAbs);\n        // now we'll subtract break intervals for this day\n        long long chunkLen = 0;\n        // we have an intersection [cur, chunkEnd]. We'll remove daily breaks from that intersection.\n        if(cur <= chunkEnd) {\n            // length of intersection initially\n            chunkLen = (chunkEnd - cur + 1);\n            // subtract breaks\n            // dailyBreaks are for a single day. We shift them by dayBase to get absolute coords.\n            for(const auto &br : dailyBreaks) {\n                long long bStart = dayBase + br.start;\n                long long bEnd   = dayBase + br.end;\n                if(bEnd < cur || bStart > chunkEnd) {\n                    // no overlap\n                    continue;\n                }\n                // overlap with [cur, chunkEnd] is [max(cur, bStart), min(chunkEnd, bEnd)]\n                long long ovStart = max((long long)cur, bStart);\n                long long ovEnd   = min((long long)chunkEnd, bEnd);\n                if(ovStart <= ovEnd) {\n                    long long ovLen = (ovEnd - ovStart + 1);\n                    chunkLen -= ovLen;\n                }\n            }\n        }\n        total += max(0LL, chunkLen);\n        // move cur to next day or beyond\n        cur = chunkEnd + 1;\n    }\n    return total;\n}\n\n// Convert day+HH:MM to absolute minute. day is 1-based in input, we store 0-based internally\nlong long toAbsoluteMinute(int d, int minuteOfDay){\n    // if day=1 => dayIndex=0\n    return (long long)(d-1)*MINUTES_PER_DAY + minuteOfDay;\n}\n\n// We'll parse the official solution or the participant's solution using this function.\nlong long readAnswer(InStream &stream) {\n    // read claimed total profit\n    long long claimedProfit = stream.readLong(0, (long long)1e15, \"claimedProfit\"); \n    // read number of tasks\n    int p = stream.readInt(0, n, \"p\"); \n    // We'll keep track of schedule feasibility\n    long long totalProfit = 0;\n\n    // We'll keep track of the finishing time of the last task to ensure chronological order\n    long long lastFinish = -1; \n\n    // We'll track which students are used (though the problem doesn't forbid using one student multiple times,\n    // but semantically it wouldn't help if each student only needs one problem. The problem statement \n    // doesn't explicitly forbid \"helping\" the same student multiple times, but let's not over-judge that. \n    // We'll just check feasibility. \n    \n    for(int i=0; i<p; i++){\n        // read each line:\n        // studentIndex, startDay, startHH:MM, endDay, endHH:MM\n        int stIndex = stream.readInt(1, n, \"studentIndex\");\n        int startDay = stream.readInt(1, k, \"startDay\");\n        string startTimeStr = stream.readToken(\"^[0-2][0-9]:[0-5][0-9]$\", \"startTime\");\n        int endDay   = stream.readInt(1, k, \"endDay\");\n        string endTimeStr   = stream.readToken(\"^[0-2][0-9]:[0-5][0-9]$\", \"endTime\");\n\n        // parse times\n        int startMinOfDay = parseHHMM(startTimeStr);\n        int endMinOfDay   = parseHHMM(endTimeStr);\n\n        long long startAbs = toAbsoluteMinute(startDay, startMinOfDay);\n        long long endAbs   = toAbsoluteMinute(endDay, endMinOfDay);\n\n        // check chronological order (the next task must start at or after we finished the previous)\n        if(startAbs < lastFinish) {\n            stream.quitf(_wa, \n                \"Tasks are not in non-decreasing chronological order. Task %d starts before previous finished.\", i+1);\n        }\n\n        if(endAbs < startAbs) {\n            stream.quitf(_wa,\n                \"Task %d ends before it starts.\", i+1);\n        }\n\n        // retrieve student info\n        const auto &stud = students[stIndex-1]; // stIndex is 1-based\n        // check subject is in list\n        if(subjectIndex.find(stud.subject) == subjectIndex.end()) {\n            // student subject is not in Valera's known list => can't solve\n            stream.quitf(_wa,\n                \"Task %d references student %d with unknown subject '%s'.\",\n                i+1, stIndex, stud.subject.c_str());\n        }\n        int subjID = subjectIndex[stud.subject];\n        int neededTime = subjects[subjID].solveTime;\n\n        // compute how many workable minutes we have in [startAbs, endAbs].\n        // The end is \"last minute of his work\" => so inclusive. \n        long long workable = calcWorkTime(startAbs, endAbs);\n        if(workable != neededTime) {\n            stream.quitf(_wa, \n                \"Task %d scheduled from day %d %s to day %d %s for student %d has workable time = %lld, but needs %d.\",\n                i+1, startDay, startTimeStr.c_str(), endDay, endTimeStr.c_str(), stIndex, workable, neededTime);\n        }\n\n        // check finishing strictly before exam\n        // finishing minute is endAbs. We need endAbs < examAbs\n        long long examAbs = toAbsoluteMinute(stud.examDay, stud.examMinute);\n        if(endAbs >= examAbs) {\n            stream.quitf(_wa,\n                \"Task %d for student %d finishes at or after the exam time. endAbs=%lld, examAbs=%lld\",\n                i+1, stIndex, endAbs, examAbs);\n        }\n\n        // accumulate profit\n        totalProfit += stud.cost;\n        // update lastFinish\n        lastFinish = endAbs;\n    }\n\n    // Now compare totalProfit with claimedProfit\n    if(totalProfit != claimedProfit) {\n        stream.quitf(_wa, \n            \"Claimed profit = %lld, but actual profit = %lld.\",\n            claimedProfit, totalProfit);\n    }\n\n    // Return the actual (correct) profit from this solution\n    return totalProfit;\n}\n\nint main(int argc, char *argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read the entire input from inf\n    m = inf.readInt(1,100,\"m\");\n    n = inf.readInt(1,100,\"n\");\n    k = inf.readInt(1,30,\"k\");\n\n    subjects.resize(m);\n    for(int i=0; i<m; i++){\n        subjects[i].name = inf.readToken(\"[a-z]{1,32}\", \"subjectName\");\n    }\n\n    // map subject -> index\n    for(int i=0; i<m; i++){\n        subjectIndex[subjects[i].name] = i;\n    }\n\n    // read times needed\n    for(int i=0; i<m; i++){\n        subjects[i].solveTime = inf.readInt(1, 1000, \"solveTime\");\n    }\n\n    // read the 4 daily break intervals: sleep, breakfast, lunch, dinner\n    dailyBreaks.clear();\n    dailyBreaks.resize(4);\n    for(int i=0; i<4; i++){\n        string br = inf.readToken(\"^[0-2][0-9]:[0-5][0-9]-[0-2][0-9]:[0-5][0-9]$\", \"breakInterval\");\n        dailyBreaks[i] = parseInterval(br);\n    }\n\n    // read students\n    students.resize(n);\n    for(int i=0; i<n; i++){\n        // subject day examTime cost\n        string sSubj = inf.readToken(\"[a-z]{1,32}\", \"studentSubject\");\n        int dDay = inf.readInt(1, k, \"examDay\");\n        string eTimeStr = inf.readToken(\"^[0-2][0-9]:[0-5][0-9]$\", \"examTime\");\n        long long cCost = inf.readLong(0, (long long)1e6, \"cost\");\n        students[i].subject = sSubj;\n        students[i].examDay = dDay;\n        students[i].examMinute = parseHHMM(eTimeStr);\n        students[i].cost = cCost;\n    }\n\n    // 2) read official answer\n    long long jans = readAnswer(ans); // jury's (official) solution profit\n\n    // 3) read participant's answer\n    long long pans = readAnswer(ouf); // participant's solution profit\n\n    // 4) compare\n    if(pans < jans) {\n        quitf(_wa, \"Participant's profit=%lld is less than jury's profit=%lld\", pans, jans);\n    } else if(pans == jans){\n        quitf(_ok, \"Correct. Profit=%lld\", pans);\n    } else {\n        // participant found something better than jury => suspicious => _fail\n        quitf(_fail, \n            \"Participant's profit=%lld is greater than jury's profit=%lld\", pans, jans);\n    }\n    return 0; // just in case\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a unique random subject name\nstring randomSubjectName(set<string>& existingNames) {\n    // Generate a random subject name (non-empty string of at most 32 lowercase letters)\n    int len = rnd.next(1, 32);\n    string s;\n    do {\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = rnd.next('a', 'z');\n        }\n    } while (existingNames.count(s)); // Ensure uniqueness\n    existingNames.insert(s);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\"); // number of subjects\n    int n = opt<int>(\"n\"); // number of students\n    int k = opt<int>(\"k\", 30); // duration in days, default 30\n    string type = opt<string>(\"type\", \"normal\");\n\n    // Some global settings\n    m = min(max(m, 1), 100);\n    n = min(max(n, 1), 100);\n    k = min(max(k,1),30);\n\n    vector<string> subjectList(m);\n    set<string> existingSubjects;\n\n    // Generate subjects\n    for (int i = 0; i < m; ++i) {\n        subjectList[i] = randomSubjectName(existingSubjects);\n    }\n\n    // Generate ti (time to solve problems of each subject)\n    vector<int> ti(m);\n    // Depending on type, we can set ti differently.\n\n    if (type == \"max_ti\") {\n        // Use maximum ti\n        for (int i = 0; i < m; ++i) {\n            ti[i] = 1000;\n        }\n    } else if (type == \"min_ti\") {\n        for (int i = 0; i < m; ++i) {\n            ti[i] = 1;\n        }\n    } else {\n        // Random ti\n        for (int i = 0; i < m; ++i) {\n            ti[i] = rnd.next(1,1000);\n        }\n    }\n\n    // Generate time segments for sleep, breakfast, lunch, dinner\n    // Each line is in format H1:M1-H2:M2, where 00 ≤  H1, H2 ≤ 23, 00 ≤  M1, M2 ≤ 59.\n    // No two time segments cross. Sleep before midnight, get up before breakfast, etc.\n\n    vector<pair<int, int>> rest_times(4); // sleep, breakfast, lunch, dinner\n\n    if (type == \"no_time\") {\n        // Valera has no time to work\n        rest_times[0] = make_pair(0, 1439); // Sleep from 00:00 to 23:59\n        rest_times[1] = make_pair(0, 0);\n        rest_times[2] = make_pair(0, 0);\n        rest_times[3] = make_pair(0, 0);\n    } else {\n        // Sleep from 00:00 to 06:59\n        rest_times[0] = make_pair(0*60, 7*60 -1);\n\n        // Breakfast from 07:00 to 07:29\n        rest_times[1] = make_pair(7*60, 7*60 + 29);\n\n        // Lunch from 12:00 to 12:59\n        rest_times[2] = make_pair(12*60, 12*60 + 59);\n\n        // Dinner from 19:00 to 19:59\n        rest_times[3] = make_pair(19*60, 19*60 + 59);\n    }\n\n    // Now generate n students\n    vector<string> studentSubject(n);\n    vector<int> di(n);           // exam day (1 ≤ di ≤ k)\n    vector<int> examTime(n);     // exam time in minutes (0 to 1439)\n    vector<int> ci(n);           // money (0 ≤ ci ≤ 1e6)\n\n    if (type == \"conflicting_subjects\") {\n        // All students have subjects Valera does not know\n        for (int i = 0; i < n; ++i) {\n            // Generate a subject name not in Valera's list\n            string s;\n            do {\n                s = randomSubjectName(existingSubjects);\n            } while (find(subjectList.begin(), subjectList.end(), s) != subjectList.end());\n            studentSubject[i] = s;\n            di[i] = rnd.next(1,k);\n            examTime[i] = rnd.next(0,1439);\n            ci[i] = rnd.next(0,1000000);\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            // Decide whether to give a subject Valera knows or not\n            bool knownSubject = (type == \"known_subjects\") ? true : rnd.next(0,1); // 50% chance\n            if (knownSubject) {\n                // Choose a subject from Valera's list\n                studentSubject[i] = subjectList[rnd.next(0,m-1)];\n            } else {\n                // Generate a subject not in Valera's list\n                string s;\n                do {\n                    s = randomSubjectName(existingSubjects);\n                } while (find(subjectList.begin(), subjectList.end(), s) != subjectList.end());\n                studentSubject[i] = s;\n            }\n            di[i] = rnd.next(1,k);\n            examTime[i] = rnd.next(0,1439);\n            ci[i] = rnd.next(0,1000000);\n        }\n    }\n\n    // Now, output the data\n\n    printf(\"%d %d %d\\n\", m, n, k);\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%s\\n\", subjectList[i].c_str());\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", ti[i], (i == m-1 ? '\\n' : ' '));\n    }\n\n    // Output time segments for sleep, breakfast, lunch, dinner\n\n    for (int i = 0; i < 4; ++i) {\n        // Format H1:M1-H2:M2\n        int H1 = rest_times[i].first / 60;\n        int M1 = rest_times[i].first % 60;\n        int H2 = rest_times[i].second / 60;\n        int M2 = rest_times[i].second % 60;\n        printf(\"%02d:%02d-%02d:%02d\\n\", H1, M1, H2, M2);\n    }\n\n    // Now output the students\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s %d %02d:%02d %d\\n\", studentSubject[i].c_str(), di[i],\n               examTime[i]/60, examTime[i]%60, ci[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a unique random subject name\nstring randomSubjectName(set<string>& existingNames) {\n    // Generate a random subject name (non-empty string of at most 32 lowercase letters)\n    int len = rnd.next(1, 32);\n    string s;\n    do {\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = rnd.next('a', 'z');\n        }\n    } while (existingNames.count(s)); // Ensure uniqueness\n    existingNames.insert(s);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\"); // number of subjects\n    int n = opt<int>(\"n\"); // number of students\n    int k = opt<int>(\"k\", 30); // duration in days, default 30\n    string type = opt<string>(\"type\", \"normal\");\n\n    // Some global settings\n    m = min(max(m, 1), 100);\n    n = min(max(n, 1), 100);\n    k = min(max(k,1),30);\n\n    vector<string> subjectList(m);\n    set<string> existingSubjects;\n\n    // Generate subjects\n    for (int i = 0; i < m; ++i) {\n        subjectList[i] = randomSubjectName(existingSubjects);\n    }\n\n    // Generate ti (time to solve problems of each subject)\n    vector<int> ti(m);\n    // Depending on type, we can set ti differently.\n\n    if (type == \"max_ti\") {\n        // Use maximum ti\n        for (int i = 0; i < m; ++i) {\n            ti[i] = 1000;\n        }\n    } else if (type == \"min_ti\") {\n        for (int i = 0; i < m; ++i) {\n            ti[i] = 1;\n        }\n    } else {\n        // Random ti\n        for (int i = 0; i < m; ++i) {\n            ti[i] = rnd.next(1,1000);\n        }\n    }\n\n    // Generate time segments for sleep, breakfast, lunch, dinner\n    // Each line is in format H1:M1-H2:M2, where 00 ≤  H1, H2 ≤ 23, 00 ≤  M1, M2 ≤ 59.\n    // No two time segments cross. Sleep before midnight, get up before breakfast, etc.\n\n    vector<pair<int, int>> rest_times(4); // sleep, breakfast, lunch, dinner\n\n    if (type == \"no_time\") {\n        // Valera has no time to work\n        rest_times[0] = make_pair(0, 1439); // Sleep from 00:00 to 23:59\n        rest_times[1] = make_pair(0, 0);\n        rest_times[2] = make_pair(0, 0);\n        rest_times[3] = make_pair(0, 0);\n    } else {\n        // Sleep from 00:00 to 06:59\n        rest_times[0] = make_pair(0*60, 7*60 -1);\n\n        // Breakfast from 07:00 to 07:29\n        rest_times[1] = make_pair(7*60, 7*60 + 29);\n\n        // Lunch from 12:00 to 12:59\n        rest_times[2] = make_pair(12*60, 12*60 + 59);\n\n        // Dinner from 19:00 to 19:59\n        rest_times[3] = make_pair(19*60, 19*60 + 59);\n    }\n\n    // Now generate n students\n    vector<string> studentSubject(n);\n    vector<int> di(n);           // exam day (1 ≤ di ≤ k)\n    vector<int> examTime(n);     // exam time in minutes (0 to 1439)\n    vector<int> ci(n);           // money (0 ≤ ci ≤ 1e6)\n\n    if (type == \"conflicting_subjects\") {\n        // All students have subjects Valera does not know\n        for (int i = 0; i < n; ++i) {\n            // Generate a subject name not in Valera's list\n            string s;\n            do {\n                s = randomSubjectName(existingSubjects);\n            } while (find(subjectList.begin(), subjectList.end(), s) != subjectList.end());\n            studentSubject[i] = s;\n            di[i] = rnd.next(1,k);\n            examTime[i] = rnd.next(0,1439);\n            ci[i] = rnd.next(0,1000000);\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            // Decide whether to give a subject Valera knows or not\n            bool knownSubject = (type == \"known_subjects\") ? true : rnd.next(0,1); // 50% chance\n            if (knownSubject) {\n                // Choose a subject from Valera's list\n                studentSubject[i] = subjectList[rnd.next(0,m-1)];\n            } else {\n                // Generate a subject not in Valera's list\n                string s;\n                do {\n                    s = randomSubjectName(existingSubjects);\n                } while (find(subjectList.begin(), subjectList.end(), s) != subjectList.end());\n                studentSubject[i] = s;\n            }\n            di[i] = rnd.next(1,k);\n            examTime[i] = rnd.next(0,1439);\n            ci[i] = rnd.next(0,1000000);\n        }\n    }\n\n    // Now, output the data\n\n    printf(\"%d %d %d\\n\", m, n, k);\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%s\\n\", subjectList[i].c_str());\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", ti[i], (i == m-1 ? '\\n' : ' '));\n    }\n\n    // Output time segments for sleep, breakfast, lunch, dinner\n\n    for (int i = 0; i < 4; ++i) {\n        // Format H1:M1-H2:M2\n        int H1 = rest_times[i].first / 60;\n        int M1 = rest_times[i].first % 60;\n        int H2 = rest_times[i].second / 60;\n        int M2 = rest_times[i].second % 60;\n        printf(\"%02d:%02d-%02d:%02d\\n\", H1, M1, H2, M2);\n    }\n\n    // Now output the students\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s %d %02d:%02d %d\\n\", studentSubject[i].c_str(), di[i],\n               examTime[i]/60, examTime[i]%60, ci[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -k 10 -type normal\n./gen -n 20 -m 10 -k 15 -type normal\n./gen -n 50 -m 20 -k 20 -type normal\n./gen -n 100 -m 50 -k 30 -type normal\n\n./gen -n 100 -m 100 -k 30 -type max_ti\n./gen -n 100 -m 100 -k 30 -type min_ti\n\n./gen -n 1 -m 1 -k 1 -type conflicting_subjects\n./gen -n 10 -m 5 -k 5 -type conflicting_subjects\n./gen -n 100 -m 50 -k 10 -type conflicting_subjects\n\n./gen -n 100 -m 100 -k 30 -type known_subjects\n\n./gen -n 10 -m 5 -k 7 -type no_time\n./gen -n 50 -m 20 -k 15 -type no_time\n\n./gen -n 100 -m 100 -k 30 -type normal\n\n./gen -n 100 -m 1 -k 1 -type normal\n\n./gen -n 1 -m 100 -k 1 -type normal\n\n./gen -n 100 -m 100 -k 1 -type normal\n\n./gen -n 50 -m 50 -k 15 -type max_ti\n./gen -n 50 -m 50 -k 15 -type min_ti\n./gen -n 50 -m 50 -k 15 -type normal\n\n./gen -n 2 -m 2 -k 2 -type normal\n./gen -n 3 -m 3 -k 3 -type normal\n./gen -n 4 -m 4 -k 4 -type normal\n./gen -n 5 -m 5 -k 5 -type normal\n\n./gen -n 100 -m 100 -k 30 -type max_ti\n./gen -n 100 -m 100 -k 30 -type min_ti\n./gen -n 100 -m 100 -k 30 -type conflicting_subjects\n./gen -n 100 -m 100 -k 30 -type known_subjects\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:06.849571",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "330/A",
      "title": "A. Cakeminator",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers r and c (2 ≤ r, c ≤ 10), denoting the number of rows and the number of columns of the cake. The next r lines each contains c characters — the j-th character of the i-th line denotes the content of the cell at row i and column j, and is either one of these:   '.' character denotes a cake cell with no evil strawberry;  'S' character denotes a cake cell with an evil strawberry.",
      "output_spec": "OutputOutput the maximum number of cake cells that the cakeminator can eat.",
      "sample_tests": "ExamplesInputCopy3 4S.........S.OutputCopy8",
      "description": "A. Cakeminator\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers r and c (2 ≤ r, c ≤ 10), denoting the number of rows and the number of columns of the cake. The next r lines each contains c characters — the j-th character of the i-th line denotes the content of the cell at row i and column j, and is either one of these:   '.' character denotes a cake cell with no evil strawberry;  'S' character denotes a cake cell with an evil strawberry.\n\nOutputOutput the maximum number of cake cells that the cakeminator can eat.\n\nInputCopy3 4S.........S.OutputCopy8\n\nInputCopy3 4S.........S.\n\nOutputCopy8\n\nNoteFor the first example, one possible way to eat the maximum number of cake cells is as follows (perform 3 eats).",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 330\\s*A"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(2, 10, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(2, 10, \"c\");\n    inf.readEoln();\n\n    for (int i = 0; i < r; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == c, \"Line %d length is %d, expected %d\", i + 1, int(s.size()), c);\n        for (int j = 0; j < c; ++j) {\n            char ch = s[j];\n            ensuref(ch == '.' || ch == 'S', \"Invalid character '%c' at row %d, column %d\", ch, i + 1, j + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(2, 10, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(2, 10, \"c\");\n    inf.readEoln();\n\n    for (int i = 0; i < r; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == c, \"Line %d length is %d, expected %d\", i + 1, int(s.size()), c);\n        for (int j = 0; j < c; ++j) {\n            char ch = s[j];\n            ensuref(ch == '.' || ch == 'S', \"Invalid character '%c' at row %d, column %d\", ch, i + 1, j + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(2, 10, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(2, 10, \"c\");\n    inf.readEoln();\n\n    for (int i = 0; i < r; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == c, \"Line %d length is %d, expected %d\", i + 1, int(s.size()), c);\n        for (int j = 0; j < c; ++j) {\n            char ch = s[j];\n            ensuref(ch == '.' || ch == 'S', \"Invalid character '%c' at row %d, column %d\", ch, i + 1, j + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(r, string(c, '.'));\n\n    if (type == \"empty\") {\n        // Grid is already filled with '.'\n    } else if (type == \"full\") {\n        // Fill grid with 'S'\n        for(int i = 0; i < r; ++i)\n            grid[i] = string(c, 'S');\n    } else if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // default density 0.5\n        for(int i = 0; i < r; ++i)\n            for(int j = 0; j < c; ++j)\n                grid[i][j] = (rnd.next() < density) ? 'S' : '.';\n    } else if (type == \"row_full_s\") {\n        // Each row contains at least one 'S'\n        for(int i = 0; i < r; ++i) {\n            int num_s = rnd.next(1, c);\n            set<int> s_positions;\n            while ((int) s_positions.size() < num_s) {\n                s_positions.insert(rnd.next(0, c - 1));\n            }\n            for(int j : s_positions)\n                grid[i][j] = 'S';\n        }\n    } else if (type == \"column_full_s\") {\n        // Each column contains at least one 'S'\n        for(int j = 0; j < c; ++j) {\n            int num_s = rnd.next(1, r);\n            set<int> s_positions;\n            while ((int) s_positions.size() < num_s) {\n                s_positions.insert(rnd.next(0, r - 1));\n            }\n            for(int i : s_positions)\n                grid[i][j] = 'S';\n        }\n    } else if (type == \"checkerboard\") {\n        // Place 'S's in a checkerboard pattern\n        for(int i = 0; i < r; ++i)\n            for(int j = 0; j < c; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? 'S' : '.';\n    } else if (type == \"border_s\") {\n        // Place 'S's along the border\n        for(int j = 0; j < c; ++j) {\n            grid[0][j] = 'S';\n            grid[r-1][j] = 'S';\n        }\n        for(int i = 0; i < r; ++i) {\n            grid[i][0] = 'S';\n            grid[i][c-1] = 'S';\n        }\n    } else if (type == \"overlapping\") {\n        // Create a pattern that may cause overlapping counts\n        for (int i = 0; i < r; ++i)\n            grid[i] = string(c, '.');\n        if (r > 2 && c > 2) {\n            int mid_r = r / 2;\n            int mid_c = c / 2;\n            for (int i = 0; i < r; ++i)\n                grid[i][mid_c] = 'S';\n            for (int j = 0; j < c; ++j)\n                grid[mid_r][j] = 'S';\n        } else {\n            for (int i = 0; i < min(r, c); ++i)\n                grid[i][i] = 'S';\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", r, c);\n    for(int i = 0; i < r; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(r, string(c, '.'));\n\n    if (type == \"empty\") {\n        // Grid is already filled with '.'\n    } else if (type == \"full\") {\n        // Fill grid with 'S'\n        for(int i = 0; i < r; ++i)\n            grid[i] = string(c, 'S');\n    } else if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // default density 0.5\n        for(int i = 0; i < r; ++i)\n            for(int j = 0; j < c; ++j)\n                grid[i][j] = (rnd.next() < density) ? 'S' : '.';\n    } else if (type == \"row_full_s\") {\n        // Each row contains at least one 'S'\n        for(int i = 0; i < r; ++i) {\n            int num_s = rnd.next(1, c);\n            set<int> s_positions;\n            while ((int) s_positions.size() < num_s) {\n                s_positions.insert(rnd.next(0, c - 1));\n            }\n            for(int j : s_positions)\n                grid[i][j] = 'S';\n        }\n    } else if (type == \"column_full_s\") {\n        // Each column contains at least one 'S'\n        for(int j = 0; j < c; ++j) {\n            int num_s = rnd.next(1, r);\n            set<int> s_positions;\n            while ((int) s_positions.size() < num_s) {\n                s_positions.insert(rnd.next(0, r - 1));\n            }\n            for(int i : s_positions)\n                grid[i][j] = 'S';\n        }\n    } else if (type == \"checkerboard\") {\n        // Place 'S's in a checkerboard pattern\n        for(int i = 0; i < r; ++i)\n            for(int j = 0; j < c; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? 'S' : '.';\n    } else if (type == \"border_s\") {\n        // Place 'S's along the border\n        for(int j = 0; j < c; ++j) {\n            grid[0][j] = 'S';\n            grid[r-1][j] = 'S';\n        }\n        for(int i = 0; i < r; ++i) {\n            grid[i][0] = 'S';\n            grid[i][c-1] = 'S';\n        }\n    } else if (type == \"overlapping\") {\n        // Create a pattern that may cause overlapping counts\n        for (int i = 0; i < r; ++i)\n            grid[i] = string(c, '.');\n        if (r > 2 && c > 2) {\n            int mid_r = r / 2;\n            int mid_c = c / 2;\n            for (int i = 0; i < r; ++i)\n                grid[i][mid_c] = 'S';\n            for (int j = 0; j < c; ++j)\n                grid[mid_r][j] = 'S';\n        } else {\n            for (int i = 0; i < min(r, c); ++i)\n                grid[i][i] = 'S';\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", r, c);\n    for(int i = 0; i < r; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -r 2 -c 2 -type empty\n./gen -r 2 -c 2 -type full\n./gen -r 2 -c 2 -type random\n./gen -r 2 -c 2 -type checkerboard\n./gen -r 2 -c 2 -type overlapping\n\n./gen -r 10 -c 10 -type empty\n./gen -r 10 -c 10 -type full\n./gen -r 10 -c 10 -type random -density 0.2\n./gen -r 10 -c 10 -type random -density 0.8\n./gen -r 10 -c 10 -type checkerboard\n./gen -r 10 -c 10 -type border_s\n./gen -r 10 -c 10 -type overlapping\n./gen -r 10 -c 10 -type row_full_s\n./gen -r 10 -c 10 -type column_full_s\n\n./gen -r 5 -c 5 -type empty\n./gen -r 5 -c 5 -type full\n./gen -r 5 -c 5 -type random -density 0.5\n./gen -r 5 -c 5 -type checkerboard\n./gen -r 5 -c 5 -type border_s\n./gen -r 5 -c 5 -type overlapping\n./gen -r 5 -c 5 -type row_full_s\n./gen -r 5 -c 5 -type column_full_s\n\n./gen -r 3 -c 3 -type empty\n./gen -r 3 -c 3 -type full\n./gen -r 3 -c 3 -type random\n./gen -r 3 -c 3 -type checkerboard\n./gen -r 3 -c 3 -type overlapping\n\n./gen -r 7 -c 8 -type random -density 0.3\n./gen -r 4 -c 7 -type random -density 0.7\n./gen -r 9 -c 9 -type checkerboard\n./gen -r 9 -c 8 -type random\n./gen -r 8 -c 9 -type random\n\n./gen -r 2 -c 10 -type empty\n./gen -r 10 -c 2 -type full\n./gen -r 9 -c 9 -type empty\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:08.903244",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "330/B",
      "title": "B. Road Construction",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line consists of two integers n and m .Then m lines follow, each consisting of two integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which means that it is not possible to construct a road connecting cities ai and bi. Consider the cities are numbered from 1 to n.It is guaranteed that every pair of cities will appear at most once in the input.",
      "output_spec": "OutputYou should print an integer s: the minimum number of roads that should be constructed, in the first line. Then s lines should follow, each consisting of two integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which means that a road should be constructed between cities ai and bi.If there are several solutions, you may print any of them.",
      "sample_tests": "ExamplesInputCopy4 11 3OutputCopy31 24 22 3",
      "description": "B. Road Construction\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line consists of two integers n and m .Then m lines follow, each consisting of two integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which means that it is not possible to construct a road connecting cities ai and bi. Consider the cities are numbered from 1 to n.It is guaranteed that every pair of cities will appear at most once in the input.\n\nOutputYou should print an integer s: the minimum number of roads that should be constructed, in the first line. Then s lines should follow, each consisting of two integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which means that a road should be constructed between cities ai and bi.If there are several solutions, you may print any of them.\n\nInputCopy4 11 3OutputCopy31 24 22 3\n\nInputCopy4 11 3\n\nOutputCopy31 24 22 3\n\nNoteThis is one possible solution of the example:   These are examples of wrong solutions:   The above solution is wrong because it doesn't use the minimum number of edges (4 vs 3). In addition, it also tries to construct a road between cities 1 and 3, while the input specifies that it is not allowed to construct a road between the pair.   The above solution is wrong because you need to traverse at least 3 roads to go from city 1 to city 3, whereas in your country it must be possible to go from any city to another by traversing at most 2 roads.   Finally, the above solution is wrong because it must be possible to go from any city to another, whereas it is not possible in this country to go from city 1 to 3, 2 to 3, and 4 to 3.",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 330\\s*B"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> forbidden_edges;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai and bi must be different, but ai=%d and bi=%d\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(forbidden_edges.count(edge) == 0, \"Edge between %d and %d appears more than once\", u, v);\n        forbidden_edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> forbidden_edges;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai and bi must be different, but ai=%d and bi=%d\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(forbidden_edges.count(edge) == 0, \"Edge between %d and %d appears more than once\", u, v);\n        forbidden_edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> forbidden_edges;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai and bi must be different, but ai=%d and bi=%d\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(forbidden_edges.count(edge) == 0, \"Edge between %d and %d appears more than once\", u, v);\n        forbidden_edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read n, m from the input \"inf\"\n    int n = inf.readInt(2, 100000, \"n\");\n    int m = inf.readInt(0, (long long)n*(n-1)/2, \"m\");\n\n    // Read the forbidden edges\n    set<pair<int, int>> forbidden;\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"fa\");\n        int b = inf.readInt(1, n, \"fb\");\n        if (a > b) swap(a, b);\n        forbidden.insert({a, b});\n    }\n\n    // We are NOT reading any jury solution from \"ans\" \n    // to avoid blocking/timeouts when \"ans\" is empty.\n\n    // Read number of roads from the contestant's output \"ouf\"\n    int s = ouf.readInt(0, (long long)n*(n-1)/2, \"s\");\n\n    // We'll keep adjacency for distance checks\n    vector<unordered_set<int>> adj(n + 1);\n    // For detecting duplicates\n    set<pair<int,int>> usedEdges;\n\n    // Read each of the s edges\n    for (int i = 0; i < s; i++) {\n        int a = ouf.readInt(1, n, \"a\");\n        int b = ouf.readInt(1, n, \"b\");\n        if (a == b) {\n            ouf.quitf(_wa, \"Self-loop detected on city %d\", a);\n        }\n        if (a > b) swap(a, b);\n\n        if (forbidden.count({a, b})) {\n            ouf.quitf(_wa, \"Forbidden edge between %d and %d\", a, b);\n        }\n        if (!usedEdges.insert({a, b}).second) {\n            ouf.quitf(_wa, \"Duplicate edge between %d and %d\", a, b);\n        }\n        adj[a].insert(b);\n        adj[b].insert(a);\n    }\n\n    // Make sure there's nothing but whitespace in the output after reading s roads\n    ouf.skipBlanks();\n    if (!ouf.eof()) {\n        ouf.quitf(_wa, \"Extra data in output after reading %d roads (possible stray '.')\", s);\n    }\n\n    // Check distance ≤ 2 for every pair of distinct cities\n    // For n=4 (the given test), a simple double-loop is fine.\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            // If directly connected, distance = 1\n            if (adj[u].count(v)) continue;\n            // Otherwise, check for a common neighbor\n            bool ok = false;\n            // Minor optimization: iterate the smaller adjacency list\n            if (adj[u].size() < adj[v].size()) {\n                for (int mid : adj[u]) {\n                    if (adj[v].count(mid)) {\n                        ok = true;\n                        break;\n                    }\n                }\n            } else {\n                for (int mid : adj[v]) {\n                    if (adj[u].count(mid)) {\n                        ok = true;\n                        break;\n                    }\n                }\n            }\n            if (!ok) {\n                ouf.quitf(_wa,\n                    \"Cities %d and %d are at distance > 2 in the participant's solution\",\n                    u, v\n                );\n            }\n        }\n    }\n\n    // If no error has been reported, the solution is correct\n    // (no minimality check since there's no jury solution).\n    quitf(_ok, \"Valid solution with %d roads; no jury solution provided.\", s);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    m = min(m, 100000); // Ensure m ≤ 1e5\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0);\n    k = min(k, n-1);\n\n    set<pair<int,int>> forbidden;\n\n    if (type == \"random\") {\n        // Generate m random forbidden pairs\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    } else if (type == \"central_forbidden\") {\n        int central = 1;\n        k = min(k, n-1);\n        m = max(m, k);\n        m = min(m, 100000);\n        for (int i = 2; i <= n && (int)forbidden.size() < k; ++i) {\n            forbidden.insert({min(central,i), max(central,i)});\n        }\n        // Now fill up the rest of m forbidden pairs randomly\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    } else if (type == \"no_forbidden\") {\n        m = 0; // Ensure m is zero\n    } else if (type == \"max_forbidden\") {\n        m = min(m, 100000);\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    } else {\n        // Default to random\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)forbidden.size());\n\n    // Output m forbidden pairs\n    for (auto p : forbidden) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    m = min(m, 100000); // Ensure m ≤ 1e5\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0);\n    k = min(k, n-1);\n\n    set<pair<int,int>> forbidden;\n\n    if (type == \"random\") {\n        // Generate m random forbidden pairs\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    } else if (type == \"central_forbidden\") {\n        int central = 1;\n        k = min(k, n-1);\n        m = max(m, k);\n        m = min(m, 100000);\n        for (int i = 2; i <= n && (int)forbidden.size() < k; ++i) {\n            forbidden.insert({min(central,i), max(central,i)});\n        }\n        // Now fill up the rest of m forbidden pairs randomly\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    } else if (type == \"no_forbidden\") {\n        m = 0; // Ensure m is zero\n    } else if (type == \"max_forbidden\") {\n        m = min(m, 100000);\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    } else {\n        // Default to random\n        while ((int)forbidden.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a != b) {\n                if (a > b) swap(a,b);\n                forbidden.insert({a,b});\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)forbidden.size());\n\n    // Output m forbidden pairs\n    for (auto p : forbidden) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type no_forbidden\n\n./gen -n 2 -m 0 -type no_forbidden\n\n./gen -n 2 -m 1 -type random\n\n./gen -n 2 -m 1 -type central_forbidden -k 1\n\n./gen -n 5 -m 5 -type random\n\n./gen -n 5 -m 10 -type random\n\n./gen -n 5 -m 10 -type max_forbidden\n\n./gen -n 100 -m 0 -type no_forbidden\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 100 -m 50 -type central_forbidden -k 30\n\n./gen -n 1000 -m 500 -type random\n\n./gen -n 1000 -m 500 -type central_forbidden -k 100\n\n./gen -n 1000 -m 1000 -type central_forbidden -k 0\n\n./gen -n 1000 -m 1000 -type central_forbidden -k 1000\n\n./gen -n 9999 -m 10000 -type random\n\n./gen -n 99999 -m 100000 -type random\n\n./gen -n 100000 -m 0 -type no_forbidden\n\n./gen -n 100000 -m 1 -type random\n\n./gen -n 100000 -m 50000 -type random\n\n./gen -n 100000 -m 99999 -type random\n\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type central_forbidden -k 50000\n\n./gen -n 100000 -m 100000 -type central_forbidden -k 99999\n\n./gen -n 99999 -m 100000 -type random\n\n./gen -n 100000 -m 99999 -type random\n\n./gen -n 100000 -m 50000 -type central_forbidden -k 25000\n\n./gen -n 99999 -m 50000 -type random\n\n./gen -n 100000 -m 0 -type no_forbidden\n\n./gen -n 100000 -m 100000 -type max_forbidden\n\n./gen -n 1000 -m 0 -type no_forbidden\n\n./gen -n 1000 -m 0 -type random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:11.220845",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "330/C",
      "title": "C. Purification",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line will contain a single integer n (1 ≤ n ≤ 100). Then, n lines follows, each contains n characters. The j-th character in the i-th row represents the cell located at row i and column j. It will be the character 'E' if it is a particularly more evil cell, and '.' otherwise.",
      "output_spec": "OutputIf there exists no way to purify all the cells, output -1. Otherwise, if your solution casts x \"Purification\" spells (where x is the minimum possible number of spells), output x lines. Each line should consist of two integers denoting the row and column numbers of the cell on which you should cast the \"Purification\" spell.",
      "sample_tests": "ExamplesInputCopy3.E.E.E.E.OutputCopy1 12 23 3InputCopy3EEEE..E.EOutputCopy-1InputCopy5EE.EEE.EE.E...E.EE.EEE.EEOutputCopy3 31 32 24 45 3",
      "description": "C. Purification\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line will contain a single integer n (1 ≤ n ≤ 100). Then, n lines follows, each contains n characters. The j-th character in the i-th row represents the cell located at row i and column j. It will be the character 'E' if it is a particularly more evil cell, and '.' otherwise.\n\nOutputIf there exists no way to purify all the cells, output -1. Otherwise, if your solution casts x \"Purification\" spells (where x is the minimum possible number of spells), output x lines. Each line should consist of two integers denoting the row and column numbers of the cell on which you should cast the \"Purification\" spell.\n\nInputCopy3.E.E.E.E.OutputCopy1 12 23 3InputCopy3EEEE..E.EOutputCopy-1InputCopy5EE.EEE.EE.E...E.EE.EEE.EEOutputCopy3 31 32 24 45 3\n\nInputCopy3.E.E.E.E.\n\nOutputCopy1 12 23 3\n\nInputCopy3EEEE..E.E\n\nOutputCopy-1\n\nInputCopy5EE.EEE.EE.E...E.EE.EEE.EE\n\nOutputCopy3 31 32 24 45 3\n\nNoteThe first example is illustrated as follows. Purple tiles are evil tiles that have not yet been purified. Red tile is the tile on which \"Purification\" is cast. Yellow tiles are the tiles being purified as a result of the current \"Purification\" spell. Green tiles are tiles that have been purified previously.   In the second example, it is impossible to purify the cell located at row 1 and column 1.For the third example:",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 330\\s*C"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[E.]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"s_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[E.]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"s_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[E.]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"s_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf (input file)\n    int n = inf.readInt(1, 100, \"n\");\n    vector<string> grid(n);\n\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readToken();\n        if ((int)grid[i].length() != n) {\n            quitf(_fail, \"Invalid grid row length at line %d\", i + 2);\n        }\n        for (char c : grid[i]) {\n            if (c != 'E' && c != '.') {\n                quitf(_fail, \"Invalid character '%c' in grid at line %d\", c, i + 2);\n            }\n        }\n    }\n\n    // Read contestant's output from ouf\n    if (ouf.seekEof()) {\n        quitf(_wa, \"Contestant's output is empty\");\n    }\n\n    string firstLine = ouf.readLine();\n    trim(firstLine);\n    if (firstLine == \"-1\") {\n        // Contestant outputs -1\n        string juryFirstToken = ans.readToken();\n        if (juryFirstToken != \"-1\") {\n            quitf(_wa, \"Contestant claims impossible, but a solution exists\");\n        } else {\n            if (!ouf.seekEof())\n                quitf(_wa, \"Contestant outputs extra stuff after -1\");\n            quitf(_ok, \"Correctly outputted -1\");\n        }\n    } else {\n        // Contestant outputs positions\n        vector<pair<int, int>> positions;\n\n        // Read first line (already read)\n        istringstream iss(firstLine);\n        int x, y;\n        if (!(iss >> x >> y)) {\n            quitf(_wa, \"Cannot read two integers from the first line\");\n        }\n        if (iss >> x) {\n            quitf(_wa, \"Extra data in the first line\");\n        }\n        positions.push_back({x - 1, y - 1}); // 0-based index\n\n        // Read rest of the lines\n        while (!ouf.seekEof()) {\n            string line = ouf.readLine();\n            trim(line);\n            if (line.empty()) continue;\n            istringstream iss(line);\n            if (!(iss >> x >> y)) {\n                quitf(_wa, \"Cannot read two integers from a line\");\n            }\n            if (iss >> x) {\n                quitf(_wa, \"Extra data in a line\");\n            }\n            positions.push_back({x - 1, y - 1}); // 0-based index\n        }\n\n        // Now, simulate the purification process\n        vector<vector<bool>> purified(n, vector<bool>(n, false));\n\n        for (size_t idx = 0; idx < positions.size(); ++idx) {\n            int x = positions[idx].first;\n            int y = positions[idx].second;\n\n            // Check that positions are valid\n            if (x < 0 || x >= n || y < 0 || y >= n) {\n                quitf(_wa, \"Invalid cell position (%d, %d)\", x + 1, y + 1);\n            }\n\n            // Check that we can cast spell on this cell\n            if (grid[x][y] == 'E') {\n                quitf(_wa, \"Cannot cast spell on cell (%d, %d)\", x + 1, y + 1);\n            }\n\n            // Purify row x and column y\n            for (int i = 0; i < n; ++i) {\n                purified[x][i] = true;\n                purified[i][y] = true;\n            }\n        }\n\n        // Check if all cells are purified\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!purified[i][j]) {\n                    quitf(_wa, \"Cell (%d, %d) is not purified\", i + 1, j + 1);\n                }\n            }\n        }\n\n        quitf(_ok, \"All cells are purified with %d spells\", positions.size());\n    }\n\n    // Should not reach here\n    quitf(_fail, \"Checker error\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"random_possible\") {\n        for (int i = 0; i < n; ++i) {\n            bool hasDot = false;\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next(2))\n                    grid[i][j] = 'E';\n                else {\n                    grid[i][j] = '.';\n                    hasDot = true;\n                }\n            }\n            if (!hasDot) {\n                // Randomly choose a cell in this row to set to '.'\n                int col = rnd.next(n);\n                grid[i][col] = '.';\n            }\n        }\n    } else if (type == \"random_impossible\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = (rnd.next(2) ? 'E' : '.');\n\n        // Choose a random row to set entirely to 'E's\n        int row = rnd.next(n);\n        for (int j = 0; j < n; ++j)\n            grid[row][j] = 'E';\n        // For each column in that row, set other cells to 'E's\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < n; ++i)\n                if (i != row)\n                    grid[i][j] = 'E';\n    } else if (type == \"full_E\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, 'E');\n    } else if (type == \"row_full_E\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = (rnd.next(2) ? 'E' : '.');\n\n        int row = rnd.next(n);\n        for (int j = 0; j < n; ++j)\n            grid[row][j] = 'E';\n    } else if (type == \"column_full_E\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = (rnd.next(2) ? 'E' : '.');\n\n        int col = rnd.next(n);\n        for (int i = 0; i < n; ++i)\n            grid[i][col] = 'E';\n    } else if (type == \"max_E_possible\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'E');\n            int col = rnd.next(n);\n            grid[i][col] = '.';\n        }\n    } else {\n        // Default is random_possible\n        for (int i = 0; i < n; ++i) {\n            bool hasDot = false;\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next(2))\n                    grid[i][j] = 'E';\n                else {\n                    grid[i][j] = '.';\n                    hasDot = true;\n                }\n            }\n            if (!hasDot) {\n                int col = rnd.next(n);\n                grid[i][col] = '.';\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output grid\n    for (const auto& row : grid) {\n        printf(\"%s\\n\", row.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"random_possible\") {\n        for (int i = 0; i < n; ++i) {\n            bool hasDot = false;\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next(2))\n                    grid[i][j] = 'E';\n                else {\n                    grid[i][j] = '.';\n                    hasDot = true;\n                }\n            }\n            if (!hasDot) {\n                // Randomly choose a cell in this row to set to '.'\n                int col = rnd.next(n);\n                grid[i][col] = '.';\n            }\n        }\n    } else if (type == \"random_impossible\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = (rnd.next(2) ? 'E' : '.');\n\n        // Choose a random row to set entirely to 'E's\n        int row = rnd.next(n);\n        for (int j = 0; j < n; ++j)\n            grid[row][j] = 'E';\n        // For each column in that row, set other cells to 'E's\n        for (int j = 0; j < n; ++j)\n            for (int i = 0; i < n; ++i)\n                if (i != row)\n                    grid[i][j] = 'E';\n    } else if (type == \"full_E\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(n, 'E');\n    } else if (type == \"row_full_E\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = (rnd.next(2) ? 'E' : '.');\n\n        int row = rnd.next(n);\n        for (int j = 0; j < n; ++j)\n            grid[row][j] = 'E';\n    } else if (type == \"column_full_E\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = (rnd.next(2) ? 'E' : '.');\n\n        int col = rnd.next(n);\n        for (int i = 0; i < n; ++i)\n            grid[i][col] = 'E';\n    } else if (type == \"max_E_possible\") {\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'E');\n            int col = rnd.next(n);\n            grid[i][col] = '.';\n        }\n    } else {\n        // Default is random_possible\n        for (int i = 0; i < n; ++i) {\n            bool hasDot = false;\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next(2))\n                    grid[i][j] = 'E';\n                else {\n                    grid[i][j] = '.';\n                    hasDot = true;\n                }\n            }\n            if (!hasDot) {\n                int col = rnd.next(n);\n                grid[i][col] = '.';\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output grid\n    for (const auto& row : grid) {\n        printf(\"%s\\n\", row.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random_possible\n./gen -n 1 -type full_E\n./gen -n 1 -type max_E_possible\n\n./gen -n 2 -type random_possible\n./gen -n 2 -type random_impossible\n./gen -n 2 -type row_full_E\n./gen -n 2 -type column_full_E\n\n./gen -n 3 -type random_possible\n./gen -n 3 -type random_impossible\n./gen -n 3 -type max_E_possible\n\n./gen -n 5 -type random_possible\n./gen -n 5 -type random_impossible\n./gen -n 5 -type row_full_E\n./gen -n 5 -type column_full_E\n\n./gen -n 10 -type random_possible\n./gen -n 10 -type random_impossible\n./gen -n 10 -type max_E_possible\n\n./gen -n 20 -type random_possible\n./gen -n 20 -type random_impossible\n./gen -n 20 -type full_E\n\n./gen -n 50 -type random_possible\n./gen -n 50 -type random_impossible\n./gen -n 50 -type row_full_E\n./gen -n 50 -type column_full_E\n\n./gen -n 100 -type random_possible\n./gen -n 100 -type random_impossible\n./gen -n 100 -type max_E_possible\n./gen -n 100 -type full_E\n\n./gen -n 100 -type row_full_E\n./gen -n 100 -type column_full_E\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:13.414925",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "330/D",
      "title": "D. Biridian Forest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line consists of two integers: r and c (1 ≤ r, c ≤ 1000), denoting the number of rows and the number of columns in Biridian Forest. The next r rows will each depict a row of the map, where each character represents the content of a single cell:   'T': A cell occupied by a tree.  'S': An empty cell, and your starting position. There will be exactly one occurence of this in the map.  'E': An empty cell, and where the exit is located. There will be exactly one occurence of this in the map.  A digit (0-9): A cell represented by a digit X means that the cell is empty and is occupied by X breeders (in particular, if X is zero, it means that the cell is not occupied by any breeder). It is guaranteed that it will be possible for you to go from your starting position to the exit cell through a sequence of moves.",
      "output_spec": "OutputA single line denoted the minimum possible number of mikemon battles that you have to participate in if you pick a strategy that minimize this number.",
      "sample_tests": "ExamplesInputCopy5 7000E0T3T0TT0T0010T0T02T0T0T00T0S000OutputCopy3InputCopy1 4SE23OutputCopy2",
      "description": "D. Biridian Forest\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line consists of two integers: r and c (1 ≤ r, c ≤ 1000), denoting the number of rows and the number of columns in Biridian Forest. The next r rows will each depict a row of the map, where each character represents the content of a single cell:   'T': A cell occupied by a tree.  'S': An empty cell, and your starting position. There will be exactly one occurence of this in the map.  'E': An empty cell, and where the exit is located. There will be exactly one occurence of this in the map.  A digit (0-9): A cell represented by a digit X means that the cell is empty and is occupied by X breeders (in particular, if X is zero, it means that the cell is not occupied by any breeder). It is guaranteed that it will be possible for you to go from your starting position to the exit cell through a sequence of moves.\n\nOutputA single line denoted the minimum possible number of mikemon battles that you have to participate in if you pick a strategy that minimize this number.\n\nInputCopy5 7000E0T3T0TT0T0010T0T02T0T0T00T0S000OutputCopy3InputCopy1 4SE23OutputCopy2\n\nInputCopy5 7000E0T3T0TT0T0010T0T02T0T0T00T0S000\n\nOutputCopy3\n\nInputCopy1 4SE23\n\nOutputCopy2\n\nNoteThe following picture illustrates the first example. The blue line denotes a possible sequence of moves that you should post in your blog:  The three breeders on the left side of the map will be able to battle you — the lone breeder can simply stay in his place until you come while the other two breeders can move to where the lone breeder is and stay there until you come. The three breeders on the right does not have a way to battle you, so they will stay in their place.For the second example, you should post this sequence in your Blog:  Here's what happens. First, you move one cell to the right.  Then, the two breeders directly to the right of the exit will simultaneously move to the left. The other three breeder cannot battle you so they will do nothing.  You end up in the same cell with 2 breeders, so 2 mikemon battles are conducted. After those battles, all of your opponents leave the forest.  Finally, you make another move by leaving the forest.",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 330\\s*D"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n    \n    vector<string> grid(r);\n    int numS = 0, numE = 0;\n    int s_x = -1, s_y = -1, e_x = -1, e_y = -1;\n    string allowedChars = \"TSE0123456789\";\n    \n    for (int i = 0; i < r; ++i) {\n        string pattern = \"[\" + allowedChars + \"]{\" + to_string(c) + \"}\";\n        grid[i] = inf.readLine(pattern, \"grid line\");\n        \n        for (int j = 0; j < c; ++j) {\n            char ch = grid[i][j];\n            if (ch == 'S') {\n                numS++;\n                s_x = i;\n                s_y = j;\n            } else if (ch == 'E') {\n                numE++;\n                e_x = i;\n                e_y = j;\n            }\n            // 'T' and digits '0'-'9' are valid, no need to check further here\n        }\n    }\n    \n    ensuref(numS == 1, \"There must be exactly one 'S' in the grid, found %d\", numS);\n    ensuref(numE == 1, \"There must be exactly one 'E' in the grid, found %d\", numE);\n    \n    // Check if 'E' is reachable from 'S'\n    vector<vector<bool>> visited(r, vector<bool>(c, false));\n    queue<pair<int, int>> q;\n    q.push({s_x, s_y});\n    visited[s_x][s_y] = true;\n    \n    int dx[4] = {-1, 1, 0, 0}; // Directions: up, down, left, right\n    int dy[4] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        \n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            \n            if (nx >= 0 && nx < r && ny >= 0 && ny < c) {\n                if (!visited[nx][ny] && grid[nx][ny] != 'T') {\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    \n    ensuref(visited[e_x][e_y], \"It is not possible to reach 'E' from 'S' through empty cells\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n    \n    vector<string> grid(r);\n    int numS = 0, numE = 0;\n    int s_x = -1, s_y = -1, e_x = -1, e_y = -1;\n    string allowedChars = \"TSE0123456789\";\n    \n    for (int i = 0; i < r; ++i) {\n        string pattern = \"[\" + allowedChars + \"]{\" + to_string(c) + \"}\";\n        grid[i] = inf.readLine(pattern, \"grid line\");\n        \n        for (int j = 0; j < c; ++j) {\n            char ch = grid[i][j];\n            if (ch == 'S') {\n                numS++;\n                s_x = i;\n                s_y = j;\n            } else if (ch == 'E') {\n                numE++;\n                e_x = i;\n                e_y = j;\n            }\n            // 'T' and digits '0'-'9' are valid, no need to check further here\n        }\n    }\n    \n    ensuref(numS == 1, \"There must be exactly one 'S' in the grid, found %d\", numS);\n    ensuref(numE == 1, \"There must be exactly one 'E' in the grid, found %d\", numE);\n    \n    // Check if 'E' is reachable from 'S'\n    vector<vector<bool>> visited(r, vector<bool>(c, false));\n    queue<pair<int, int>> q;\n    q.push({s_x, s_y});\n    visited[s_x][s_y] = true;\n    \n    int dx[4] = {-1, 1, 0, 0}; // Directions: up, down, left, right\n    int dy[4] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        \n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            \n            if (nx >= 0 && nx < r && ny >= 0 && ny < c) {\n                if (!visited[nx][ny] && grid[nx][ny] != 'T') {\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    \n    ensuref(visited[e_x][e_y], \"It is not possible to reach 'E' from 'S' through empty cells\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n    \n    vector<string> grid(r);\n    int numS = 0, numE = 0;\n    int s_x = -1, s_y = -1, e_x = -1, e_y = -1;\n    string allowedChars = \"TSE0123456789\";\n    \n    for (int i = 0; i < r; ++i) {\n        string pattern = \"[\" + allowedChars + \"]{\" + to_string(c) + \"}\";\n        grid[i] = inf.readLine(pattern, \"grid line\");\n        \n        for (int j = 0; j < c; ++j) {\n            char ch = grid[i][j];\n            if (ch == 'S') {\n                numS++;\n                s_x = i;\n                s_y = j;\n            } else if (ch == 'E') {\n                numE++;\n                e_x = i;\n                e_y = j;\n            }\n            // 'T' and digits '0'-'9' are valid, no need to check further here\n        }\n    }\n    \n    ensuref(numS == 1, \"There must be exactly one 'S' in the grid, found %d\", numS);\n    ensuref(numE == 1, \"There must be exactly one 'E' in the grid, found %d\", numE);\n    \n    // Check if 'E' is reachable from 'S'\n    vector<vector<bool>> visited(r, vector<bool>(c, false));\n    queue<pair<int, int>> q;\n    q.push({s_x, s_y});\n    visited[s_x][s_y] = true;\n    \n    int dx[4] = {-1, 1, 0, 0}; // Directions: up, down, left, right\n    int dy[4] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        \n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            \n            if (nx >= 0 && nx < r && ny >= 0 && ny < c) {\n                if (!visited[nx][ny] && grid[nx][ny] != 'T') {\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    \n    ensuref(visited[e_x][e_y], \"It is not possible to reach 'E' from 'S' through empty cells\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int x, int y, vector<string>& grid, vector<vector<bool>>& visited) {\n    int r = grid.size(), c = grid[0].size();\n    visited[x][y] = true;\n    vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    shuffle(dirs.begin(), dirs.end());\n    for(auto [dx, dy]: dirs) {\n        int nx = x + dx, ny = y + dy;\n        if (nx < 0 || nx >= r || ny < 0 || ny >= c)\n            continue;\n        if (!visited[nx][ny]) {\n            if (grid[nx][ny] != 'T') {\n                dfs(nx, ny, grid, visited);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Initialize grid\n    vector<string> grid(r, string(c, '0'));\n    \n    if (type == \"simple\") {\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        // No trees, minimal breeders\n    } else if (type == \"random\") {\n        // Random grid with trees and breeders, ensure 'S' can reach 'E'\n        for (int i = 0; i < r; ++i)\n            grid[i] = string(c, 'T');\n        // Choose positions for 'S' and 'E'\n        int sx = rnd.next(0, r-1);\n        int sy = rnd.next(0, c-1);\n        int ex = rnd.next(0, r-1);\n        int ey = rnd.next(0, c-1);\n        while (sx == ex && sy == ey) {\n            ex = rnd.next(0, r-1);\n            ey = rnd.next(0, c-1);\n        }\n        grid[sx][sy] = 'S';\n        grid[ex][ey] = 'E';\n        // Randomized BFS to create a path\n        queue<pair<int,int>> q;\n        q.push({sx, sy});\n        grid[sx][sy] = '0';\n        vector<vector<bool>> visited(r, vector<bool>(c, false));\n        visited[sx][sy] = true;\n        while (!q.empty()) {\n            int x = q.front().first, y = q.front().second;\n            q.pop();\n            vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n            shuffle(dirs.begin(), dirs.end());\n            for(auto [dx, dy]: dirs) {\n                int nx = x + dx, ny = y + dy;\n                if (nx < 0 || nx >= r || ny < 0 || ny >= c)\n                    continue;\n                if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    grid[nx][ny] = '0';\n                    q.push({nx, ny});\n                    if (nx == ex && ny == ey) {\n                        grid[nx][ny] = 'E';\n                    }\n                }\n            }\n        }\n        // For cells that are '0', randomly place breeders\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j) {\n                if (grid[i][j] == '0') {\n                    if (rnd.next(100) < 20) { // 20% chance to place breeders\n                        int breeders = rnd.next(1, 9);\n                        grid[i][j] = '0' + breeders;\n                    }\n                }\n            }\n        grid[sx][sy] = 'S';\n        grid[ex][ey] = 'E';\n    } else if (type == \"forced_battles\") {\n        // Create a path from 'S' to 'E' with unavoidable battles\n        int x = 0, y = 0;\n        grid[x][y] = 'S';\n        grid[r-1][c-1] = 'E';\n        // Fill grid with 'T's\n        for (int i = 0; i < r; ++i)\n            grid[i] = string(c, 'T');\n        // Carve path\n        x = 0, y = 0;\n        vector<pair<int,int>> path;\n        while (x != r-1 || y != c-1) {\n            grid[x][y] = '0';\n            path.push_back({x,y});\n            if (x < r-1 && (y == c-1 || rnd.next(2)))\n                x++;\n            else\n                y++;\n        }\n        grid[r-1][c-1] = 'E';\n        path.push_back({r-1,c-1});\n        // Place breeders along the path (except 'S' and 'E')\n        for (int i = 1; i+1 < path.size(); i++) {\n            int px = path[i].first;\n            int py = path[i].second;\n            int breeders = rnd.next(1, 9);\n            grid[px][py] = '0' + breeders;\n        }\n    } else if (type == \"no_battles\") {\n        // Empty grid, place breeders away from path\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        // Generate a path from (0,0) to (r-1,c-1)\n        vector<vector<bool>> isPath(r, vector<bool>(c, false));\n        for (int i = 0; i < r; i++) isPath[i][0] = true;\n        for (int j = 0; j < c; j++) isPath[r-1][j] = true;\n        // Place breeders in cells not in the path\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j) {\n                if (grid[i][j]=='S' || grid[i][j]=='E') continue;\n                if (!isPath[i][j]) {\n                    if (rnd.next(100) < 50) { // 50% chance to place breeders\n                        int breeders = rnd.next(1, 9);\n                        grid[i][j] = '0' + breeders;\n                    }\n                }\n            }\n    } else if (type == \"max_size\") {\n        // Max size grid, empty\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        // No trees or breeders\n    } else if (type == \"many_breeders\") {\n        // Fill the grid with breeders\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; ++j < c; ++j) {\n                if (grid[i][j] == 'S' || grid[i][j] == 'E') continue;\n                grid[i][j] = '9';\n            }\n    } else {\n        // Default case, simple grid\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n    }\n    \n    // Output the grid\n    cout << r << \" \" << c << \"\\n\";\n    for (int i = 0; i < r; ++i) {\n        cout << grid[i] << \"\\n\";\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int x, int y, vector<string>& grid, vector<vector<bool>>& visited) {\n    int r = grid.size(), c = grid[0].size();\n    visited[x][y] = true;\n    vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    shuffle(dirs.begin(), dirs.end());\n    for(auto [dx, dy]: dirs) {\n        int nx = x + dx, ny = y + dy;\n        if (nx < 0 || nx >= r || ny < 0 || ny >= c)\n            continue;\n        if (!visited[nx][ny]) {\n            if (grid[nx][ny] != 'T') {\n                dfs(nx, ny, grid, visited);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Initialize grid\n    vector<string> grid(r, string(c, '0'));\n    \n    if (type == \"simple\") {\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        // No trees, minimal breeders\n    } else if (type == \"random\") {\n        // Random grid with trees and breeders, ensure 'S' can reach 'E'\n        for (int i = 0; i < r; ++i)\n            grid[i] = string(c, 'T');\n        // Choose positions for 'S' and 'E'\n        int sx = rnd.next(0, r-1);\n        int sy = rnd.next(0, c-1);\n        int ex = rnd.next(0, r-1);\n        int ey = rnd.next(0, c-1);\n        while (sx == ex && sy == ey) {\n            ex = rnd.next(0, r-1);\n            ey = rnd.next(0, c-1);\n        }\n        grid[sx][sy] = 'S';\n        grid[ex][ey] = 'E';\n        // Randomized BFS to create a path\n        queue<pair<int,int>> q;\n        q.push({sx, sy});\n        grid[sx][sy] = '0';\n        vector<vector<bool>> visited(r, vector<bool>(c, false));\n        visited[sx][sy] = true;\n        while (!q.empty()) {\n            int x = q.front().first, y = q.front().second;\n            q.pop();\n            vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n            shuffle(dirs.begin(), dirs.end());\n            for(auto [dx, dy]: dirs) {\n                int nx = x + dx, ny = y + dy;\n                if (nx < 0 || nx >= r || ny < 0 || ny >= c)\n                    continue;\n                if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    grid[nx][ny] = '0';\n                    q.push({nx, ny});\n                    if (nx == ex && ny == ey) {\n                        grid[nx][ny] = 'E';\n                    }\n                }\n            }\n        }\n        // For cells that are '0', randomly place breeders\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j) {\n                if (grid[i][j] == '0') {\n                    if (rnd.next(100) < 20) { // 20% chance to place breeders\n                        int breeders = rnd.next(1, 9);\n                        grid[i][j] = '0' + breeders;\n                    }\n                }\n            }\n        grid[sx][sy] = 'S';\n        grid[ex][ey] = 'E';\n    } else if (type == \"forced_battles\") {\n        // Create a path from 'S' to 'E' with unavoidable battles\n        int x = 0, y = 0;\n        grid[x][y] = 'S';\n        grid[r-1][c-1] = 'E';\n        // Fill grid with 'T's\n        for (int i = 0; i < r; ++i)\n            grid[i] = string(c, 'T');\n        // Carve path\n        x = 0, y = 0;\n        vector<pair<int,int>> path;\n        while (x != r-1 || y != c-1) {\n            grid[x][y] = '0';\n            path.push_back({x,y});\n            if (x < r-1 && (y == c-1 || rnd.next(2)))\n                x++;\n            else\n                y++;\n        }\n        grid[r-1][c-1] = 'E';\n        path.push_back({r-1,c-1});\n        // Place breeders along the path (except 'S' and 'E')\n        for (int i = 1; i+1 < path.size(); i++) {\n            int px = path[i].first;\n            int py = path[i].second;\n            int breeders = rnd.next(1, 9);\n            grid[px][py] = '0' + breeders;\n        }\n    } else if (type == \"no_battles\") {\n        // Empty grid, place breeders away from path\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        // Generate a path from (0,0) to (r-1,c-1)\n        vector<vector<bool>> isPath(r, vector<bool>(c, false));\n        for (int i = 0; i < r; i++) isPath[i][0] = true;\n        for (int j = 0; j < c; j++) isPath[r-1][j] = true;\n        // Place breeders in cells not in the path\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j) {\n                if (grid[i][j]=='S' || grid[i][j]=='E') continue;\n                if (!isPath[i][j]) {\n                    if (rnd.next(100) < 50) { // 50% chance to place breeders\n                        int breeders = rnd.next(1, 9);\n                        grid[i][j] = '0' + breeders;\n                    }\n                }\n            }\n    } else if (type == \"max_size\") {\n        // Max size grid, empty\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        // No trees or breeders\n    } else if (type == \"many_breeders\") {\n        // Fill the grid with breeders\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; ++j < c; ++j) {\n                if (grid[i][j] == 'S' || grid[i][j] == 'E') continue;\n                grid[i][j] = '9';\n            }\n    } else {\n        // Default case, simple grid\n        grid[0][0] = 'S';\n        grid[r-1][c-1] = 'E';\n    }\n    \n    // Output the grid\n    cout << r << \" \" << c << \"\\n\";\n    for (int i = 0; i < r; ++i) {\n        cout << grid[i] << \"\\n\";\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -r 1 -c 2 -type simple\n./gen -r 2 -c 2 -type simple\n./gen -r 1 -c 1 -type simple\n\n./gen -r 3 -c 3 -type random\n./gen -r 3 -c 3 -type forced_battles\n./gen -r 3 -c 2 -type no_battles\n\n./gen -r 10 -c 10 -type random\n./gen -r 10 -c 10 -type forced_battles\n./gen -r 10 -c 10 -type no_battles\n\n./gen -r 50 -c 50 -type random\n./gen -r 50 -c 50 -type forced_battles\n./gen -r 50 -c 50 -type no_battles\n\n./gen -r 100 -c 100 -type random\n./gen -r 100 -c 100 -type forced_battles\n./gen -r 100 -c 100 -type no_battles\n./gen -r 100 -c 100 -type many_breeders\n\n./gen -r 500 -c 500 -type random\n./gen -r 500 -c 500 -type forced_battles\n./gen -r 500 -c 500 -type no_battles\n./gen -r 500 -c 500 -type many_breeders\n\n./gen -r 1000 -c 1000 -type random\n./gen -r 1000 -c 1000 -type forced_battles\n./gen -r 1000 -c 1000 -type no_battles\n./gen -r 1000 -c 1000 -type max_size\n./gen -r 1000 -c 1000 -type many_breeders\n\n./gen -r 1 -c 1000 -type no_battles\n./gen -r 1000 -c 1 -type no_battles\n./gen -r 1 -c 1000 -type forced_battles\n./gen -r 1000 -c 1 -type forced_battles\n\n./gen -r 2 -c 3 -type random\n./gen -r 2 -c 3 -type forced_battles\n./gen -r 2 -c 3 -type simple\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:15.604859",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "330/E",
      "title": "E. Graph Reconstruction",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line consists of two space-separated integers: n and m (1 ≤ m ≤ n ≤ 105), denoting the number of nodes and edges, respectively. Then m lines follow. Each of the m lines consists of two space-separated integers u and v (1 ≤ u, v ≤ n; u ≠ v), denoting an edge between nodes u and v.",
      "output_spec": "OutputIf it is not possible to construct a new graph with the mentioned properties, output a single line consisting of -1. Otherwise, output exactly m lines. Each line should contain a description of edge in the same way as used in the input format.",
      "sample_tests": "ExamplesInputCopy8 71 22 34 55 66 88 77 4OutputCopy1 44 61 62 77 58 52 8InputCopy3 21 22 3OutputCopy-1InputCopy5 41 22 33 44 1OutputCopy1 33 55 22 4",
      "description": "E. Graph Reconstruction\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line consists of two space-separated integers: n and m (1 ≤ m ≤ n ≤ 105), denoting the number of nodes and edges, respectively. Then m lines follow. Each of the m lines consists of two space-separated integers u and v (1 ≤ u, v ≤ n; u ≠ v), denoting an edge between nodes u and v.\n\nOutputIf it is not possible to construct a new graph with the mentioned properties, output a single line consisting of -1. Otherwise, output exactly m lines. Each line should contain a description of edge in the same way as used in the input format.\n\nInputCopy8 71 22 34 55 66 88 77 4OutputCopy1 44 61 62 77 58 52 8InputCopy3 21 22 3OutputCopy-1InputCopy5 41 22 33 44 1OutputCopy1 33 55 22 4\n\nInputCopy8 71 22 34 55 66 88 77 4\n\nOutputCopy1 44 61 62 77 58 52 8\n\nInputCopy3 21 22 3\n\nOutputCopy-1\n\nInputCopy5 41 22 33 44 1\n\nOutputCopy1 33 55 22 4\n\nNoteThe old graph of the first example:A possible new graph for the first example:In the second example, we cannot create any new graph.The old graph of the third example:A possible new graph for the third example:",
      "solutions": [
        {
          "title": "Codeforces Round #192 - Codeforces",
          "content": "UPD: EditorialHello!After the barrage of non-standard contests (memSQL, ABBYY, Yandex), we present you a standard and fun (and strange) Codeforces round! This contest is prepared by Indonesian coders: fushar, jonathanirvings, and me (dolphinigle)! fushar wrote D2-E/D1-C, jonathanirvings wrote D2-B, and I wrote the rest. For me, this is my fourth contest, after Codeforces Beta Round 87 (Div. 1 Only), Croc Champ 2012 - Final, and last week’s MemSQL start[c]up Round 1 (only 1 problem there though). We would also like to thank Gerald for helping with the contest preparation, Delinur for translation, and MikeMirzayanov for the system!I think this contest is stranger than usual -- The statements are strange, there are pictures everywhere, etc. There is a single problem with very lengthy statement (I am unable to shorten it further without losing clarity, I'm sorry), but I think it's very clear. The other problems have relatively short statements.fushar drops a message for you:We think that the solutions to all problems are satisfying to discover. We want to add a special note: you might find that the solutions will not be too “usual” :).Happy solving!UPD: The contest is finished! Editorial will be posted tomorrow by fushar. Hope you enjoyed the contest!...Div1-D 329D - The Evil Temple and the Moving Rocks was a little too strange I guess.UPD: Congratulations to the winners!D1: espr1t RAVEman Psyho Petr Shik D2: RNS_MHB Parsa.pordel s0en1it RaJin darrenhp You guys are certainly good at ad hoc problems! :)UPD: Komaki, followed by Marcin_smu finally solved the last problem 329E - Evil after the contest. During the contest, they submitted some solutions with the right idea but got caught by pretest. You guys are awesome! UPD: Scores:D2: standard (500 1000 1500 2000 2500)D1: 500 1000 1500 1500 2500UPD: Important: This contest is held in an unusual time (2 hours earlier than usual): http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=7&year=2013&hour=17&min=30&sec=0&p1=166",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8402",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2009
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces",
          "content": "So! We hope you enjoyed the round. Internally, we called this round Trollforces, because as you knew, most solutions should be unexpected :)Some fun fact: there are ~ 30 pictures in this round, totaling ~ 144 KB.Here is the editorial, written with mixed point of views of all writers (hence \"I\" may refer to any of us). 330A - Cakeminator by dolphinigleLong solution: Once an evil strawberry, always an evil strawberry (since they can’t be eaten). Thus, if a row cannot be eaten before any eat is performed, it can never be eaten. Same with column. Thus, you can know which columns and which rows you can eat. Just try to eat them all and calculate how many cells you actually eat. Short solution: A row or a column cannot be eaten if it has at least one strawberry. A cell cannot be eaten if both its row and its column cannot be eaten -- otherwise you can eat the row/column and eat it! If there are r' rows that cannot be eaten, and c' columns that cannot be eaten, then there are r' * c' cells that cannot be eaten -- a cell such that both its row and columns cannot be eaten.Since all other cells can be eaten, answer is R * C — r' * c'. 330B - Road Construction by jonathanirvings Since m < n/2, there exists at least one node that is not incident to any edge. The constraints can be satisfied if and only if the graph is a star graph: http://en.wikipedia.org/wiki/Star_(graph_theory). We can just create a star graph centered with the node and connect it to all other nodes. 330C - Purification / 329A - Purification by dolphinigle Obviously the minimum possible answer is n (why?). But is it always possible to purify all the cells with n spells? If there exist a row consisting of entirely \"E\" cells and a column consisting of entirely \"E\" cells, then the answer is -1. This is since the cell with that row and that column cannot be purifed. Otherwise, without loss of generality let's suppose there is no row consisting entirely of \"E\". Then, for each row, find any \".\" cell. Purify it. The case with no column consisting entirely of \"E\" is similar. 330D - Biridian Forest / 329B - Biridian Forest by dolphinigleThe only non ad hoc problem in the round! ...sort of. Despite the very long problem statement, the solution is really simple. We should take any shortest path from S to E (yes, any!). We will see why this is optimal at the end. If a breeder can reach E faster than or equal to us, then he will battle us. This is since he can simply walk to E and waits for us there. Otherwise, they can never battle us by contradiction. Assume they battled us, but they cannot reach cell E from their location faster or equal to us. If the battle us in cell X, then cell X is part of the shortest path from S to E that you are travelling. Since he is able to battle us there, he must be able to arrive at cell X <= us. But then, that means he can walk from X to E and reach E before or equal to us! Contradiction. This is optimal, since any breeder that we battle in this solution must also be battled in any other solution (the other breeders should immediately go to E and wait). You can use Breadth-First Search once from exit cell to obtain the shortest paths from each breeder to it. ThoughtsI tried to make this clearer by separating the paragraphs by topic. Did it work well?Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon -- similar to how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:). 330E - Graph Reconstruction / 329C - Graph Reconstruction by fusharFirst, I would like to apologize the missing node 3 in the picture of the first example. It was a mistake :(Intended, deterministic solution: If n <= 7, brute force all possible subsets of the edges (at most 2^(7 * (7 — 1) / 2)), and check if they satisfy the constraint. Otherwise, a solution always exists. Here is how to construct one. Partition the nodes into connected components. Note that each component will be either a cycle or a chain. List the nodes of each component in order of the cycle/chain. For example, for the first example, the partition would be { <1, 2, 3>, <4, 5, 6, 8, 7> }. For each component, we do not care whether it is a cycle or a chain. For each component, reorder the nodes such that all nodes in the odd positions are in the front. For example, component ABCDEFGHI is reordered into ACEGIBDFH. (Each letter represent a node.) Pick any component with the largest number of nodes. If the number of nodes in it is even, swap the first two nodes. For example, ABCDEFGH -> ACEGBDFH -> CAEGBDFH. For each other component, insert the nodes alternately between the largest component. For example, if the other components are acebd and 1324, insert them as follows: CAEGBDFH -> C a A c E e G b B d DFH -> C 1 a 3 A 2 c 4 EeGbBdDFH. Connect adjacent nodes so that the number of edges is m, connecting the last with the first nodes if necessary. The deterministic solution is very tricky. Therefore, I made the pretest quite strong. Some tricky cases: 4-cycle and 1-chain (covered in the example) 3-cycle and 3-cycle 4-cycle and 3-cycle (very tricky! many submissions failed on this case) Actually, we can do brute force when n <= 6, but this requires a special handling: when the largest component has 4 nodes, we should swap the first node with the third node (not the second). This is to handle the 4-cycle-and-3-cycle case.Troll solution, nondeterministic:Do the following many times: x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n if the edge (x[i], x[(i+1)%n]) is in input:\n // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n // we obtain a solution!\n for i = 1 to m:\n print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n print -1So, the question is, for large n what is the probability that a permutation is not \"bad\"? This can be computed (or at least approximated) similar to computing derangement probability -- I obtained a result above 0.1, which means in 100 iterations it should succeed if there was a solution. ...There is a solution if n > 7, so it should work. 329D - The Evil Temple and the Moving Rocks by dolphiniglePost your solution in the comment! Here's mine for the last case! (approximately 120,000 sounds). You can get the number of sounds your solution produces when submitting it to the server. 1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1I wonder if there’s a solution with ~150,000 sounds or more... the (theoretical) upper bound is 100^3 / something, so it may be feasible...? 329E - Evil by dolphinigleThe solution to this problem is actually quite simple: 4122927This problem asks us to prove something very long (the proof below is of 80+ lines).Assume that the number of cities is at least 4. The case where it's less than 4 is trivial.First, we will assume that no two cities will have same X or Y coordinates. To get this assumption, we can juxtapose every city very slightly that it will not change the answer.The keys are : A) \"Manhattan Distance\", B) the tour starts and ends at the same city. Suppose we know a tour. The total distance traveled will be |X1 — X2| + |Y1 — Y2| + |X3 — X2| + |Y3 — Y2| ...Let's separate the X and Y coordinates for simplicity. Note that each city will contribute twice to this value, for example X2 was in |X1 — X2| and |X3 — X2| in the example above. Manhattan distance implies that each of these values will either be multiplied by +1 or -1, depending on the other coordinate being compared in the absolute term. Furthermore, the number of values that are multiplied by +1 must equal the number of values that are multiplied by -1 (since in each absolute term, one is multiplied by +1 and the other by -1). This directly implies an upper bound on the maximum length of the tour.If we list all the X coordinates of the cities, and we put each of them twice in this list, and sort them, the maximum will be gained if we multiply the last half by +1 and the first half by -1, and finally summing them up. Note that all of these reasoning applies to the Y coordinate, and summing both maximum of X and Y, we receive an upper bound on the length of the tour.If we can find a tour with this length, our job is done. In some case, it's possible. Let's investigate!First, if we have the medians of the X and the Ys as in the list above, we can separated the field like below : A | B\n |\n---------\n |\n C | DThe lines corresponds to the median for both X and Y.At most one city will lie on each of the median lines (recall our assumption that X and Ys are distinct).Let's call each A B C and D as boxes. Below, we will refer box A as simply A (applies to B, C, and D too)To obtain the value above, from a city in B we must go to a city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs of cities become apparrent, A and D are paired as well as B and C.First, if either A+D is empty or B+C is empty, then we can obtain the upper bound above. We simply alternates between the two remaining pair. So let's assume that A+D is not empty and B+C is not empty.First, let's investigate the relationship between B and C (A and B will also exhibits this relationship).Theorem 1:|B — C| <= 1.Why:First, if there are no cities in the medians or there is a single city in the center of the median :A median divides the region into two areas with the same number of cities, so we have: a) A+B = C+D\nb) A+C = B+Dsubstituting A from a to b yields : (C+D-B)+C = B+D\n2C = 2B\nB = CAnd the theorem follows.Next, suppose there are two cities in the median, one for each median line :Let's suppose the median is one above and one on the right. All other cases will be similar. By definition of median... a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)Substituing a into b yields (C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1which also implies A = DApplying the same technique to other cases will give: C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1And the theorem follows.Note also that the one with the extra 1 city will be the one that is not adjacent to any median city (adjacent being the city lies in the boundary of the box)OK, so in the following observations, we will assume the upper bound (that is, the sorted list of both X and Ys have their first half multiplied by -1 while the rest by +1), and trying to find a solution that's as close as possible to this upper bound.The following will be another case analysis.Theorem 2:If there are two cities in the medians (that is, one in each median line), then the upper bound can be achieved.Why:We use pair of boxes to denote either A and D or B and C. From the second part of the proof for theorem 1, there will be a pair of boxes that contain different number of cities. Let's pick this pair, and start at the one with the most boxes. We keep alternating with its pair until we end up back in our starting box. Then, we simply move to either of the median city. From there we move to the other pair of box, the farthest one of the two. Alternate between the two, go to the other median city, and return to the starting city. It's easy to see that this will be optimal and have the upper bound as its value.Now, let's see if there are no cities in the medians. First of all, this implies that the number of cities is even. Second, this implies that our upper bound which has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work (since this implies we have to continuously alternate between the two pairs of boxes, however, we can't switch between the pair of boxes). So, at least a modification would be required. The smallest possible modification is obtained by swapping the medians, that is, it becomes : -1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So, there are two cities that changes since the number of cities is even. Furthermore, these two cities will be the closest to the median line (let's assume these coordinates are X, that is, they're the closest to the vertical median line) and lies at two different boxes. Then, we proceed as follows. We start at one of these two cities. Alternate and end at the other side. If the other city is at that box, we make it so that we end at that city, and in this case, we can move to a city in the other box pair while respecting the list of X coordinates (we can do so since this city is the closest to the median line). Otherwise, the city will be in the other pair of boxes. We simply move there and it can be shown that we still respect the list of X coordinates. Alternate and at the end, go back to the starting city. All of these can be shown to still respect the list above.This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved.Now, if there is a single city in the center of both medians, then the upper bound cannot be achieved. To see this, the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city. However, since both pair of boxes contains a city, we will need to move at least twice between them. Since there's only one center city, this is not possible.Observe that this case implies an odd number of cities. Hence, we can't simply swap the median since it swaps the x coordinates of the same median city. Instead, we do this :-1 -1 ... -1 -1 1 1 -1 1 ... 1 1or-1 -1 ... -1 1 -1 -1 1 1 ... 1 1That is, we swap to either one of the neighboring city. With the same reasoning as above, we can show that we respect this list of X coordinates.To achieve O(N) expected performance, note that the only operations we need are : grouping elements into boxes and median finding. Both can be done in expected O(N) time (expected since although there is a worst-case O(N) selection algorithm, it's ugly).Thoughts:Actually I intended to reword this into a three-paragraph weird story, but that seems a little too evil >:), so it was left out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8417",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 330\\s*E"
          },
          "content_length": 14622
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #192 - Codeforces - Code 1",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 2",
          "code": ">>>>>>.vvvvvv\n.............\n^^^^^..<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 3",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 4",
          "code": ">>>>.>.V\n^.<.<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 5",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 6",
          "code": ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>v\n^<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 7",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 8",
          "code": ">>>>>>>>>>>>>>v\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<\n^.<.<.<.<<<<<<<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 9",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 10",
          "code": "4 4\nETTT\n0T9T\n0TTT\n000S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 11",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 12",
          "code": "4\n.EEE\n.EE.\nEEEE\nE...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 13",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 14",
          "code": "1 1\n4 4\n2 4\n4 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 15",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 - Codeforces - Code 16",
          "code": "Visual Studio Debug Mode:\nExpression: map/set iterator not incrementable.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8402",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 1",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 2",
          "code": "x = [1, 2, 3, ..., n]\nrandom_shuffle(x)\nfor i = 1 to m:\n    if the edge (x[i], x[(i+1)%n]) is in input:\n        // fail this iteration, repeat the entire procedure\n\nif didn’t fail:\n    // we obtain a solution!\n    for i = 1 to m:\n        print x[i], x[(i+1)%n]\n\nIf didn’t obtain solution:\n    print -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 3",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 4",
          "code": "1 copy of\nv<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nv>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v>v^\n\n24 copies of\nv.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.v.\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n\n24 copies of\nv^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^\n.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\n\n1 copy of\n>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^>^\n....................................................................................................\n\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 5",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 6",
          "code": "A  | B\n    |\n---------\n    |\n C  | D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 7",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 8",
          "code": "a) A+B = C+D\nb) A+C = B+D",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 9",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 10",
          "code": "(C+D-B)+C = B+D\n2C = 2B\nB = C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 11",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 12",
          "code": "a) (A + B + 1) = (C + D)\nb) (A + C) = (B + D + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 13",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 14",
          "code": "(C + D - B - 1 + C) = (B + D + 1)\n2C = 2B + 2\nC = B + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 15",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #192 Editorial - Codeforces - Code 16",
          "code": "C = B and A = D+1\nC = B-1 and A = D\nC = B and A = D-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8417",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> deg(n + 1, 0); // Nodes are numbered from 1 to n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No self-loops allowed (edge from node %d to itself)\", u);\n\n        deg[u]++;\n        deg[v]++;\n        ensuref(deg[u] <= 2, \"Degree of node %d exceeds 2\", u);\n        ensuref(deg[v] <= 2, \"Degree of node %d exceeds 2\", v);\n\n        int x = min(u, v);\n        int y = max(u, v);\n        ensuref(edges.find({x, y}) == edges.end(), \"Multiple edges between nodes %d and %d\", x, y);\n        edges.insert({x, y});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> deg(n + 1, 0); // Nodes are numbered from 1 to n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No self-loops allowed (edge from node %d to itself)\", u);\n\n        deg[u]++;\n        deg[v]++;\n        ensuref(deg[u] <= 2, \"Degree of node %d exceeds 2\", u);\n        ensuref(deg[v] <= 2, \"Degree of node %d exceeds 2\", v);\n\n        int x = min(u, v);\n        int y = max(u, v);\n        ensuref(edges.find({x, y}) == edges.end(), \"Multiple edges between nodes %d and %d\", x, y);\n        edges.insert({x, y});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> deg(n + 1, 0); // Nodes are numbered from 1 to n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No self-loops allowed (edge from node %d to itself)\", u);\n\n        deg[u]++;\n        deg[v]++;\n        ensuref(deg[u] <= 2, \"Degree of node %d exceeds 2\", u);\n        ensuref(deg[v] <= 2, \"Degree of node %d exceeds 2\", v);\n\n        int x = min(u, v);\n        int y = max(u, v);\n        ensuref(edges.find({x, y}) == edges.end(), \"Multiple edges between nodes %d and %d\", x, y);\n        edges.insert({x, y});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nset<pair<int, int>> oldEdges;\n\nvoid readOldGraph() {\n    n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loop edge (%d, %d) in input\", u, v);\n        pair<int,int> e = {min(u,v), max(u,v)};\n        ensuref(oldEdges.count(e)==0, \"Duplicate edge (%d, %d) in input\", u, v);\n        oldEdges.insert(e);\n    }\n}\n\nbool readGraph(InStream &stream, vector<pair<int, int>> &edges, vector<int> &deg) {\n    edges.clear();\n    deg.assign(n+1, 0);\n    if (stream.seekEof()){\n        stream.quitf(_pe, \"Output is empty\");\n    }\n    string s = stream.readLine();\n    if (s == \"-1\") {\n        if (!stream.seekEof()){\n            stream.quitf(_pe, \"Output must contain exactly '-1' or m edges\");\n        }\n        return false; // Indicates that output is \"-1\"\n    } else {\n        // Process the first line\n        istringstream ss(s);\n        int u, v;\n        if (!(ss >> u >> v)){\n            stream.quitf(_pe, \"Couldn't parse two integers in output\");\n        }\n        ensuref(1 <= u && u <= n, \"u=%d is not in range [1, n]\", u);\n        ensuref(1 <= v && v <= n, \"v=%d is not in range [1, n]\", v);\n        ensuref(u != v, \"Self-loop edge (%d, %d) in output\", u, v);\n        pair<int,int> e = {min(u,v), max(u,v)};\n        ensuref(oldEdges.count(e)==0, \"Edge (%d, %d) exists in the old graph\", u, v);\n        set<pair<int,int>> edgeSet;\n        edgeSet.insert(e);\n        deg[u]++;\n        deg[v]++;\n        ensuref(deg[u] <= 2 && deg[v] <=2, \"Node degree exceeds 2 in output\");\n        edges.push_back(e);\n        // Read remaining m-1 lines\n        for (int i = 0; i < m - 1; ++i){\n            if (stream.seekEof()){\n                stream.quitf(_pe, \"Output terminated early, expected %d edges\", m);\n            }\n            u = stream.readInt(1, n, \"u\");\n            stream.readSpace();\n            v = stream.readInt(1, n, \"v\");\n            stream.readEoln();\n            ensuref(u != v, \"Self-loop edge (%d, %d) in output\", u, v);\n            e = {min(u,v), max(u,v)};\n            ensuref(edgeSet.count(e)==0, \"Duplicate edge (%d, %d)\", u, v);\n            ensuref(oldEdges.count(e)==0, \"Edge (%d, %d) exists in the old graph\", u, v);\n            edgeSet.insert(e);\n            deg[u]++;\n            deg[v]++;\n            ensuref(deg[u] <= 2 && deg[v] <=2, \"Node degree exceeds 2 in output\");\n            edges.push_back(e);\n        }\n        if (!stream.seekEof()){\n            stream.quitf(_pe, \"Output has extra data after reading %d edges\", m);\n        }\n        return true; // Indicates that output is m edges\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    readOldGraph();\n\n    vector<pair<int,int>> jEdges;\n    vector<int> jDeg;\n    bool jHasEdges = readGraph(ans, jEdges, jDeg);\n\n    vector<pair<int,int>> pEdges;\n    vector<int> pDeg;\n    bool pHasEdges = readGraph(ouf, pEdges, pDeg);\n\n    if (!jHasEdges) {\n        // Jury's output is \"-1\"\n        if (!pHasEdges) {\n            // Participant's output is \"-1\"\n            quitf(_ok, \"Correctly reported impossible\");\n        } else {\n            // Participant's output has been validated; report _fail\n            quitf(_fail, \"Participant found valid solution while jury says impossible\");\n        }\n    } else {\n        // Jury has a valid solution\n        if (!pHasEdges) {\n            // Participant reports impossible\n            quitf(_wa, \"Participant reports impossible while a solution exists\");\n        } else {\n            // Both have valid solutions; participant's output has been validated\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (m < 0 || m > n) {\n        println(\"-1\");\n        return 0;\n    }\n\n    vector<pair<int,int>> edges;\n    vector<set<int>> adj(n+1);\n    vector<int> deg(n+1,0);\n\n    if (type == \"path\") {\n        if (m > n - 1) {\n            // Cannot create a path with more than n - 1 edges\n            println(\"-1\");\n            return 0;\n        }\n        if (n < 1 || m < 0) {\n            println(\"-1\");\n            return 0;\n        }\n        // Generate a path with m edges (m + 1 nodes)\n        vector<int> nodes(n);\n        for(int i = 1; i <= n; ++i)\n            nodes[i-1] = i;\n        shuffle(nodes.begin(), nodes.end());\n        for(int i = 0; i < m; ++i) {\n            int u = nodes[i];\n            int v = nodes[i+1];\n            edges.emplace_back(u,v);\n            deg[u]++;\n            deg[v]++;\n            adj[u].insert(v);\n            adj[v].insert(u);\n        }\n    } else if (type == \"cycle\") {\n        if (n < 3 || m < 3) {\n            // Cannot create a cycle with less than 3 nodes or edges\n            println(\"-1\");\n            return 0;\n        }\n        if (m > n) {\n            // Cannot have more edges than nodes\n            println(\"-1\");\n            return 0;\n        }\n        // Generate a cycle with m nodes and m edges\n        vector<int> nodes(n);\n        for(int i = 1; i <= n; ++i)\n            nodes[i-1] = i;\n        shuffle(nodes.begin(), nodes.end());\n        for(int i = 0; i < m; ++i) {\n            int u = nodes[i % n];\n            int v = nodes[(i + 1) % n];\n            edges.emplace_back(u,v);\n            deg[u]++;\n            deg[v]++;\n            adj[u].insert(v);\n            adj[v].insert(u);\n            if (deg[u] > 2 || deg[v] > 2) {\n                println(\"-1\");\n                return 0;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random edges ensuring degree ≤ 2\n        int maxEdges = n * 2;\n        if (m > maxEdges / 2) {\n            // Cannot have more than n edges (since degree ≤2)\n            println(\"-1\");\n            return 0;\n        }\n        vector<int> nodes(n);\n        for(int i = 1; i <= n; ++i)\n            nodes[i-1] = i;\n        int attempts = 0;\n        while(edges.size() < m && attempts < n * 10) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(adj[u].count(v)) continue;\n            if(deg[u] >= 2 || deg[v] >= 2) continue;\n            edges.emplace_back(u,v);\n            deg[u]++;\n            deg[v]++;\n            adj[u].insert(v);\n            adj[v].insert(u);\n            attempts = 0;\n        }\n        if(edges.size() < m) {\n            println(\"-1\");\n            return 0;\n        }\n    } else if (type == \"impossible\") {\n        if(n != 3 || m != 2) {\n            // For simplicity, output the impossible sample graph\n            println(\"-1\");\n            return 0;\n        }\n        edges.emplace_back(1,2);\n        deg[1]++;\n        deg[2]++;\n        adj[1].insert(2);\n        adj[2].insert(1);\n        edges.emplace_back(2,3);\n        deg[2]++;\n        deg[3]++;\n        adj[2].insert(3);\n        adj[3].insert(2);\n    } else {\n        println(\"-1\");\n        return 0;\n    }\n\n    // Output the graph\n    println(n, edges.size());\n    for(auto& e : edges) {\n        println(e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (m < 0 || m > n) {\n        println(\"-1\");\n        return 0;\n    }\n\n    vector<pair<int,int>> edges;\n    vector<set<int>> adj(n+1);\n    vector<int> deg(n+1,0);\n\n    if (type == \"path\") {\n        if (m > n - 1) {\n            // Cannot create a path with more than n - 1 edges\n            println(\"-1\");\n            return 0;\n        }\n        if (n < 1 || m < 0) {\n            println(\"-1\");\n            return 0;\n        }\n        // Generate a path with m edges (m + 1 nodes)\n        vector<int> nodes(n);\n        for(int i = 1; i <= n; ++i)\n            nodes[i-1] = i;\n        shuffle(nodes.begin(), nodes.end());\n        for(int i = 0; i < m; ++i) {\n            int u = nodes[i];\n            int v = nodes[i+1];\n            edges.emplace_back(u,v);\n            deg[u]++;\n            deg[v]++;\n            adj[u].insert(v);\n            adj[v].insert(u);\n        }\n    } else if (type == \"cycle\") {\n        if (n < 3 || m < 3) {\n            // Cannot create a cycle with less than 3 nodes or edges\n            println(\"-1\");\n            return 0;\n        }\n        if (m > n) {\n            // Cannot have more edges than nodes\n            println(\"-1\");\n            return 0;\n        }\n        // Generate a cycle with m nodes and m edges\n        vector<int> nodes(n);\n        for(int i = 1; i <= n; ++i)\n            nodes[i-1] = i;\n        shuffle(nodes.begin(), nodes.end());\n        for(int i = 0; i < m; ++i) {\n            int u = nodes[i % n];\n            int v = nodes[(i + 1) % n];\n            edges.emplace_back(u,v);\n            deg[u]++;\n            deg[v]++;\n            adj[u].insert(v);\n            adj[v].insert(u);\n            if (deg[u] > 2 || deg[v] > 2) {\n                println(\"-1\");\n                return 0;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random edges ensuring degree ≤ 2\n        int maxEdges = n * 2;\n        if (m > maxEdges / 2) {\n            // Cannot have more than n edges (since degree ≤2)\n            println(\"-1\");\n            return 0;\n        }\n        vector<int> nodes(n);\n        for(int i = 1; i <= n; ++i)\n            nodes[i-1] = i;\n        int attempts = 0;\n        while(edges.size() < m && attempts < n * 10) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(adj[u].count(v)) continue;\n            if(deg[u] >= 2 || deg[v] >= 2) continue;\n            edges.emplace_back(u,v);\n            deg[u]++;\n            deg[v]++;\n            adj[u].insert(v);\n            adj[v].insert(u);\n            attempts = 0;\n        }\n        if(edges.size() < m) {\n            println(\"-1\");\n            return 0;\n        }\n    } else if (type == \"impossible\") {\n        if(n != 3 || m != 2) {\n            // For simplicity, output the impossible sample graph\n            println(\"-1\");\n            return 0;\n        }\n        edges.emplace_back(1,2);\n        deg[1]++;\n        deg[2]++;\n        adj[1].insert(2);\n        adj[2].insert(1);\n        edges.emplace_back(2,3);\n        deg[2]++;\n        deg[3]++;\n        adj[2].insert(3);\n        adj[3].insert(2);\n    } else {\n        println(\"-1\");\n        return 0;\n    }\n\n    // Output the graph\n    println(n, edges.size());\n    for(auto& e : edges) {\n        println(e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 2 -type impossible\n./gen -n 3 -m 2 -type path\n./gen -n 3 -m 3 -type cycle\n\n./gen -n 5 -m 4 -type cycle\n./gen -n 5 -m 4 -type path\n./gen -n 5 -m 4 -type random\n\n./gen -n 10 -m 9 -type path\n./gen -n 10 -m 10 -type cycle\n./gen -n 10 -m 15 -type random\n\n./gen -n 50 -m 49 -type path\n./gen -n 50 -m 50 -type cycle\n./gen -n 50 -m 75 -type random\n\n./gen -n 100 -m 99 -type path\n./gen -n 100 -m 100 -type cycle\n./gen -n 100 -m 150 -type random\n\n./gen -n 1000 -m 999 -type path\n./gen -n 1000 -m 1000 -type cycle\n./gen -n 1000 -m 1500 -type random\n\n./gen -n 10000 -m 9999 -type path\n./gen -n 10000 -m 10000 -type cycle\n./gen -n 10000 -m 15000 -type random\n\n./gen -n 100000 -m 99999 -type path\n./gen -n 100000 -m 100000 -type cycle\n./gen -n 100000 -m 150000 -type random\n\n./gen -n 2 -m 1 -type path\n./gen -n 2 -m 1 -type random\n\n./gen -n 4 -m 3 -type impossible\n\n./gen -n 1 -m 0 -type path\n./gen -n 1 -m 0 -type random\n\n./gen -n 10000 -m 0 -type path\n./gen -n 10000 -m 0 -type random\n\n./gen -n 5 -m 2 -type path\n./gen -n 5 -m 3 -type cycle\n./gen -n 5 -m 4 -type random\n\n./gen -n 20000 -m 30000 -type random\n./gen -n 50000 -m 75000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:17.622114",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "332/A",
      "title": "A. Выпьем?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (4 ≤ n ≤ 2000) — количество участников игры. Вторая строка описывает саму игру: i-ый символ этой строки равен 'a', если участник, ходивший i-ым, показал на следующего человека локтем, и 'b' — если кивком головы. Игра продолжалась не менее 1 и не более 2000 ходов.",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество стаканов сока, которое выпил бы Вася, если бы действовал оптимально.",
      "sample_tests": "ПримерыВходные данныеСкопировать4abbbaВыходные данныеСкопировать1Входные данныеСкопировать4abbabВыходные данныеСкопировать0",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (4 ≤ n ≤ 2000) — количество участников игры. Вторая строка описывает саму игру: i-ый символ этой строки равен 'a', если участник, ходивший i-ым, показал на следующего человека локтем, и 'b' — если кивком головы. Игра продолжалась не менее 1 и не более 2000 ходов.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество стаканов сока, которое выпил бы Вася, если бы действовал оптимально.\n\nВыходные данные\n\nВходные данныеСкопировать4abbbaВыходные данныеСкопировать1Входные данныеСкопировать4abbabВыходные данныеСкопировать0\n\nВходные данныеСкопировать4abbba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4abbab\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ обоих примерах Васе доставались два хода — 1 и 5. В первом примере Вася мог выпить стакан сока во время пятого хода, если бы показал на следующего человека кивком головы. В этом случае последовательность ходов имела бы вид «abbbb». Во втором примере Вася в любом случае не выпил бы ни одного стакана сока, поскольку движения, сделанные во время 3 и 4 ходов, отличаются.",
      "solutions": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "Всем привет!Через несколько дней (24 июля, 19:30 MSK) состоится Codeforces Round #193 (Div. 2), который был подготовлен мной. Те, кто уже вышел в первый дивизион, традиционно могут поучаствовать в раунде вне конкурса.Хотелось бы поблагодарить Виталия Гриднева (gridnevvvit), Павла Кунявского (PavelKunyavskiy) и Дмитрия Иванова (DmitriyIvanov) за тестирование задач, координатора раундов Геральда Агапова (Gerald) за полезные советы и Марию Белову (Delinur) за перевод условий на английский язык.Всем удачи и высокого рейтинга!UPD1. В раунде будет использоваться динамическая разбалловка (см. здесь). Задачи будут расположены в порядке возрастания предполагаемой сложности.UPD2. Опубликован разбор задач.UPD3. Рейтинг участников обновлен. Поздравляем победителей, решивших 4 задачи:WilliamacmWindseekerTifueraseen",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8424",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 813
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "332A - Выпьем?Поскольку n ≥ 4, один ход Васи никак не влияет на то, выпьет ли он стакан сока во время другого своего хода. Следовательно, задача заключается просто в том, чтобы найти в заданной строке количество позиций, номера которых (в 0-индексации) кратны n и перед которыми стоит хотя бы три одинаковых символа.Асимптотика решения — O(|s|)Код332B - Максимальная абсурдностьПредварительно построим массив частичных сумм, который позволит отвечать на запрос суммы на отрезке за O(1). Будем перебирать по убыванию число a из ответа — левую границу того из наших отрезков, который лежит левее. Теперь нужно среди отрезков длины k, начинающихся с элемента не левее a + k, выбрать отрезок с максимальной суммой. Поскольку a перебирается по убыванию, то такой отрезок можно поддерживать при переходе от a к a - 1. Асимптотика решения — O(n).Код332C - Месть студентовОтсортируем приказы в первую очередь по возрастанию bi, а при равенстве bi — по убыванию ai. Можно считать, что в оптимальном решении все приказы, выполненные заведующей, следуют (в отсортированном списке) после тех приказов, которые она не выполнила (это может быть неверно в случае наличия одинаковых приказов, однако на параметры ответа это все равно не влияет). Переберем i — номер первого приказа в отсортированном списке, который выполнит заведующая. Слева от этого приказа нужно выбрать p - k приказов, которые заведующая не выполнит. Поскольку требуется, что сумма bi у этих приказов была наибольшей, можно выбрать последние p - k приказов, стоящие перед i-ым приказом. Справа от i-ого приказа требуется выбрать k - 1 приказ, который заведующая выполнит. Требуется, чтобы эти приказы имели максимальную сумму ai. Если i перебирать по убыванию, то эту максимальную сумму можно поддерживать, просто храня k - 1 максимальных ai из уже проанализированных в какой-нибудь стандартной структуре данных, работающей за логарифмическое время (типа multiset’а в C++),Асимптотика решения — O(n log n).Код332D - Похищение чертежейВ задаче задан неориентированный взвешенный граф без кратных ребер и петель, удовлетворяющий следующему свойству: для любого k-элементного множества S его вершин существует единственная вершина, смежная со всеми вершинами этого множества (*) (эта вершина была названа в условии соседней с S). Для любого k-элементного множества можно вычислить специальную характеристику, равную сумме весов ребер, ведущих из вершин этого множества в соседнюю с ним вершину. Требуется найти среднее арифметическое характеристик всех k-элементных множеств вершин.Решить эту задачу позволяет следующий факт (доказательство которого приведено ниже): при k ≥ 3 условию задачи удовлетворяет только полный граф из k + 1 вершины. Для полных графов ответ на задачу равен удвоенной сумме длин всех ребер, деленной на n. Точно так же вычисляется и ответ для k = 1. Осталось рассмотреть случай k = 2. Переберем вершину i, которая будет являться соседней с нашим двухэлементным множеством. Выпишем в порядке возрастания все такие номера вершин j, что ci, j ≠  - 1. Любые две вершины из построенного списка образуют множество, для которого вершина i является соседней, а других таких множеств не существует. Перебирая все пары вершин из этого списка, мы можем прибавить характеристики всех этих множеств к ответу. Поскольку в задаче гарантируется, что граф удовлетворяет свойству (*), то каждая пара вершин будет проанализирована ровно один раз. Отметим, что аналогичный подход используется и в валидаторе к данной задаче.Асимптотическая сложность решения составляет, таким образом, O(n2)КодДоказательство.Пусть в графе любые k вершин имеют ровно одну общую смежную вершину (*)Лемма 1. У любых двух вершин ровно k - 1 общая смежная вершина.Рассмотрим две произвольные различные вершины s, t. Пусть v1, v2, ..., vl — все различные общие смежные вершины этих двух вершин. Если l ≥ k, то мы получим, что вершины из множества {v1, ..., vk} имеют две общие смежные вершины s, t, что противоречит (*). Пусть теперь l ≤ k - 2. Рассмотрим множество вершин S = {s, t, v1, ..., vl}, состоящее из l + 2 ≤ k элементов. Если l + 2 < k, дополним это множество до k-элементного произвольными вершинами, не входящими в S. Полученное множество назовем T. Согласно (*), существует единственная вершина u, не входящая в T, которая смежна со всеми вершинами из T. В частности, эта вершина смежна с вершинами s и t. Однако по построению во множестве T должны были находиться все вершины, смежные c s и t, в том числе и вершина u. Получили противоречие. Значит, l = k - 1.Лемма 2. В нашем графе найдется полный подграф из k + 1 вершины.Рассмотрим множество S = {v1, ..., vk, vk + 1}, в котором v1, ... vk — произвольные попарно различные вершины нашего графа, vk + 1 — их общая смежная вершина. Приведем конструктивный способ построения полного подграфа на основе этого множества. Осуществим k - 1 итерацию, на i-ой итерации будем рассматривать вершину vi. Если эта вершина смежна со всеми вершинами vi + 1, ..., vk, то перейдем к следующей итерации. Иначе рассмотрим множество T = {v1, ..., vi - 1, vi + 1, ...vk + 1}. У вершин из T существует ровно одна общая смежная вершина u (не совпадающая, очевидно, с vi, поскольку vi смежна не со всеми вершинами из T). Заменим вершину vi на u и перейдем к следующей итерации. После окончания последней итерации множество S, очевидно, будет являться множеством вершин полного подграфа.Покажем, что при k ≥ 3 наш граф — это полный граф из k + 1 вершины. Согласно лемме 2, в этом в графе найдется полный подграф с множеством вершин S = {v1, ..., vk + 1}. Допустим, что в нашем графе найдется вершина u, не принадлежащая S. Так как S — множество вершин полного подграфа, а любые две вершины согласно (1) имеют ровно k - 1 общую вершину, то все общие смежные вершины v1 и v2 (как и любых двух различных вершин из S) лежат в S. Если любые k вершин имеют общую смежную вершину, то и любые i (2 ≤ i ≤ k - 1) вершин имеют общую смежную вершину (возможно, не единственную). В частности, поскольку k ≥ 3, общую смежную вершину имеют вершины v1, v2, u, и эта вершина принадлежит S (как общая смежная вершина v1 и v2). Если допустить, что у u есть две смежных вершины x, y из S, то получим противоречие (1) (поскольку у этих двух смежных вершин будет k общих смежных вершин). Следовательно, в S существует единственная вершина x, смежная с u. Возьмем вершину y из S, отличную от x. У вершин (u, x, y) есть общая смежная вершина, и она принадлежит S. Но это значит, что u имеет две смежных вершины из S. Противоречие.332E - Двоичный ключПереберем cnt — количество единичных бит в ключе. Заметим, что cnt достаточно перебирать до min(|s|, k), поскольку ключи, содержащие более чем |s| единичных бит, не могут являться минимальными лексикографически. Научимся решать задачу для фиксированного cnt. Заметим, что любой полный проход по ключу соответствует выписыванию cnt из k просмотренных символов контейнера, т.е. контейнер разбивается на блоки длины k, а сообщение — на блоки длины cnt (последние блоки могут иметь меньшую длину). Пронумеруем символы каждого блока сообщения от 0 до cnt–1. Назовем (q, j)-суффиксом сообщения суффикс его q-ого блока, начинающийся с позиции j в этом блоке. Решим задачу динамическим программированием: di, j – верно ли, что существует ключ, первые i символов которого – нули и при использовании которого будет выписана строка, получаемая конкатенацией всех (q, j)-суффиксов сообщения. Переходы в этой динамике основаны на постановке в i-ую позицию ключа либо нуля, либо единицы (каждый раз нужно выбирать минимальный допустимый символ). Для восстановления самого ключа требуется сохранять для каждой подзадачи и сами выбранные символы, либо анализировать сами значения динамики.Асимптотическая сложность решения — O(k·|s|2 + |p|).Код",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8447",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 332\\s*A"
          },
          "content_length": 7731
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "5 2\n3 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "C_m^k * k * sum / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 2000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine(\"[ab]{1,2000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 2000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine(\"[ab]{1,2000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 2000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine(\"[ab]{1,2000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n < 4 || n > 2000) {\n        cerr << \"Error: n must be between 4 and 2000 inclusive.\" << endl;\n        return 1;\n    }\n\n    if (m == -1) {\n        if (type == \"maximum_turns\") {\n            m = 2000;\n        } else if (type == \"minimum_turns\") {\n            m = 1;\n        } else {\n            cerr << \"Error: m is required for the chosen type.\" << endl;\n            return 1;\n        }\n    } else if (m < 1 || m > 2000) {\n        cerr << \"Error: m must be between 1 and 2000 inclusive.\" << endl;\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        // Random actions\n        for (int i = 0; i < m; ++i) {\n            s += (rnd.next(2) == 0 ? 'a' : 'b');\n        }\n    } else if (type == \"all_a\") {\n        // All 'a's\n        s = string(m, 'a');\n    } else if (type == \"all_b\") {\n        // All 'b's\n        s = string(m, 'b');\n    } else if (type == \"alternate_ab\") {\n        // 'a' and 'b' alternately\n        for (int i = 0; i < m; ++i) {\n            s += (i % 2 == 0 ? 'a' : 'b');\n        }\n    } else if (type == \"vasya_maximize\") {\n        // Maximize the number of times Vasya can drink juice\n        for (int i = 0; i < m; ++i) {\n            int bi = (i) % n;\n            if (bi == 0) {\n                s += 'a'; // Vasya's move (can be optimized)\n            } else {\n                s += 'a'; // Other players' move\n            }\n        }\n    } else if (type == \"vasya_never_drink\") {\n        // Ensure Vasya can never drink juice\n        for (int i = 0; i < m; ++i) {\n            int bi = (i) % n;\n            if (bi == 0) {\n                s += 'a'; // Vasya's move\n            } else {\n                s += ((i + bi) % 2 == 0 ? 'a' : 'b'); // Alternate moves for others\n            }\n        }\n    } else if (type == \"minimum_turns\") {\n        s = string(m, 'a');\n    } else if (type == \"maximum_turns\") {\n        for (int i = 0; i < m; ++i) {\n            s += (rnd.next(2) == 0 ? 'a' : 'b');\n        }\n    } else {\n        cerr << \"Error: Unknown type '\" << type << \"'.\" << endl;\n        return 1;\n    }\n\n    cout << n << endl;\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n < 4 || n > 2000) {\n        cerr << \"Error: n must be between 4 and 2000 inclusive.\" << endl;\n        return 1;\n    }\n\n    if (m == -1) {\n        if (type == \"maximum_turns\") {\n            m = 2000;\n        } else if (type == \"minimum_turns\") {\n            m = 1;\n        } else {\n            cerr << \"Error: m is required for the chosen type.\" << endl;\n            return 1;\n        }\n    } else if (m < 1 || m > 2000) {\n        cerr << \"Error: m must be between 1 and 2000 inclusive.\" << endl;\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        // Random actions\n        for (int i = 0; i < m; ++i) {\n            s += (rnd.next(2) == 0 ? 'a' : 'b');\n        }\n    } else if (type == \"all_a\") {\n        // All 'a's\n        s = string(m, 'a');\n    } else if (type == \"all_b\") {\n        // All 'b's\n        s = string(m, 'b');\n    } else if (type == \"alternate_ab\") {\n        // 'a' and 'b' alternately\n        for (int i = 0; i < m; ++i) {\n            s += (i % 2 == 0 ? 'a' : 'b');\n        }\n    } else if (type == \"vasya_maximize\") {\n        // Maximize the number of times Vasya can drink juice\n        for (int i = 0; i < m; ++i) {\n            int bi = (i) % n;\n            if (bi == 0) {\n                s += 'a'; // Vasya's move (can be optimized)\n            } else {\n                s += 'a'; // Other players' move\n            }\n        }\n    } else if (type == \"vasya_never_drink\") {\n        // Ensure Vasya can never drink juice\n        for (int i = 0; i < m; ++i) {\n            int bi = (i) % n;\n            if (bi == 0) {\n                s += 'a'; // Vasya's move\n            } else {\n                s += ((i + bi) % 2 == 0 ? 'a' : 'b'); // Alternate moves for others\n            }\n        }\n    } else if (type == \"minimum_turns\") {\n        s = string(m, 'a');\n    } else if (type == \"maximum_turns\") {\n        for (int i = 0; i < m; ++i) {\n            s += (rnd.next(2) == 0 ? 'a' : 'b');\n        }\n    } else {\n        cerr << \"Error: Unknown type '\" << type << \"'.\" << endl;\n        return 1;\n    }\n\n    cout << n << endl;\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -m 1 -type random\n./gen -n 4 -m 1 -type all_a\n./gen -n 4 -m 1 -type all_b\n./gen -n 4 -m 1 -type alternate_ab\n./gen -n 4 -m 4 -type vasya_maximize\n./gen -n 4 -m 4 -type vasya_never_drink\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type vasya_maximize\n./gen -n 100 -m 100 -type vasya_never_drink\n./gen -n 2000 -m 2000 -type random\n./gen -n 2000 -m 2000 -type all_a\n./gen -n 2000 -m 2000 -type all_b\n./gen -n 2000 -m 2000 -type vasya_maximize\n./gen -n 2000 -m 2000 -type vasya_never_drink\n./gen -n 2000 -m 2000 -type alternate_ab\n./gen -n 4 -type minimum_turns\n./gen -n 2000 -type maximum_turns\n./gen -n 500 -m 1000 -type random\n./gen -n 500 -m 1000 -type vasya_maximize\n./gen -n 500 -m 1000 -type vasya_never_drink\n./gen -n 4 -m 3 -type random\n./gen -n 4 -m 3 -type all_a\n./gen -n 2000 -m 3 -type random\n./gen -n 17 -m 50 -type random\n./gen -n 17 -m 50 -type vasya_maximize\n./gen -n 17 -m 50 -type vasya_never_drink\n./gen -n 1000 -m 500 -type random\n./gen -n 1000 -m 2000 -type random\n./gen -n 1500 -m 1999 -type random\n./gen -n 4 -m 2000 -type random\n./gen -n 2000 -m 1 -type all_b\n./gen -n 500 -m 1000 -type alternate_ab\n./gen -n 1999 -m 2000 -type vasya_maximize\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:19.554499",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "332/B",
      "title": "B. Максимальная абсурдность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и k (2 ≤ n ≤ 2·105, 0 < 2k ≤ n) — количество законов, принятых парламентом, и длина одного отрезка в списке законов соответственно. В следующей строке записано n целых чисел x1, x2, ..., xn — абсурдность каждого из законов (1 ≤ xi ≤ 109).",
      "output_spec": "Выходные данныеВыведите два целых числа a, b — начальные номера законов в отрезках, которые следует выбрать дяде Вове (это значит, что президент подпишет законы с номерами из отрезков [a; a + k - 1] и [b; b + k - 1]). Если существует несколько решений, выведите то, в котором число a минимально. Если вариантов подписания по-прежнему несколько, выведите тот, в котором число b минимально.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 23 6 1 1 6Выходные данныеСкопировать1 4Входные данныеСкопировать6 21 1 1 1 1 1Выходные данныеСкопировать1 3",
      "description": "B. Максимальная абсурдность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и k (2 ≤ n ≤ 2·105, 0 < 2k ≤ n) — количество законов, принятых парламентом, и длина одного отрезка в списке законов соответственно. В следующей строке записано n целых чисел x1, x2, ..., xn — абсурдность каждого из законов (1 ≤ xi ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите два целых числа a, b — начальные номера законов в отрезках, которые следует выбрать дяде Вове (это значит, что президент подпишет законы с номерами из отрезков [a; a + k - 1] и [b; b + k - 1]). Если существует несколько решений, выведите то, в котором число a минимально. Если вариантов подписания по-прежнему несколько, выведите тот, в котором число b минимально.\n\nВыходные данные\n\nВходные данныеСкопировать5 23 6 1 1 6Выходные данныеСкопировать1 4Входные данныеСкопировать6 21 1 1 1 1 1Выходные данныеСкопировать1 3\n\nВходные данныеСкопировать5 23 6 1 1 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 21 1 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере дядя Вова подпишет законы с номерами из отрезков [1;2] и [4;5]. Суммарная абсурдность подписанных законов составит 3 + 6 + 1 + 6 = 16.Во втором примере дядя Вова подпишет законы с номерами из отрезков [1;2] и [3;4]. Суммарная абсурдность подписанных законов составит 1 + 1 + 1 + 1 = 4.",
      "solutions": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "Всем привет!Через несколько дней (24 июля, 19:30 MSK) состоится Codeforces Round #193 (Div. 2), который был подготовлен мной. Те, кто уже вышел в первый дивизион, традиционно могут поучаствовать в раунде вне конкурса.Хотелось бы поблагодарить Виталия Гриднева (gridnevvvit), Павла Кунявского (PavelKunyavskiy) и Дмитрия Иванова (DmitriyIvanov) за тестирование задач, координатора раундов Геральда Агапова (Gerald) за полезные советы и Марию Белову (Delinur) за перевод условий на английский язык.Всем удачи и высокого рейтинга!UPD1. В раунде будет использоваться динамическая разбалловка (см. здесь). Задачи будут расположены в порядке возрастания предполагаемой сложности.UPD2. Опубликован разбор задач.UPD3. Рейтинг участников обновлен. Поздравляем победителей, решивших 4 задачи:WilliamacmWindseekerTifueraseen",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8424",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 813
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "332A - Выпьем?Поскольку n ≥ 4, один ход Васи никак не влияет на то, выпьет ли он стакан сока во время другого своего хода. Следовательно, задача заключается просто в том, чтобы найти в заданной строке количество позиций, номера которых (в 0-индексации) кратны n и перед которыми стоит хотя бы три одинаковых символа.Асимптотика решения — O(|s|)Код332B - Максимальная абсурдностьПредварительно построим массив частичных сумм, который позволит отвечать на запрос суммы на отрезке за O(1). Будем перебирать по убыванию число a из ответа — левую границу того из наших отрезков, который лежит левее. Теперь нужно среди отрезков длины k, начинающихся с элемента не левее a + k, выбрать отрезок с максимальной суммой. Поскольку a перебирается по убыванию, то такой отрезок можно поддерживать при переходе от a к a - 1. Асимптотика решения — O(n).Код332C - Месть студентовОтсортируем приказы в первую очередь по возрастанию bi, а при равенстве bi — по убыванию ai. Можно считать, что в оптимальном решении все приказы, выполненные заведующей, следуют (в отсортированном списке) после тех приказов, которые она не выполнила (это может быть неверно в случае наличия одинаковых приказов, однако на параметры ответа это все равно не влияет). Переберем i — номер первого приказа в отсортированном списке, который выполнит заведующая. Слева от этого приказа нужно выбрать p - k приказов, которые заведующая не выполнит. Поскольку требуется, что сумма bi у этих приказов была наибольшей, можно выбрать последние p - k приказов, стоящие перед i-ым приказом. Справа от i-ого приказа требуется выбрать k - 1 приказ, который заведующая выполнит. Требуется, чтобы эти приказы имели максимальную сумму ai. Если i перебирать по убыванию, то эту максимальную сумму можно поддерживать, просто храня k - 1 максимальных ai из уже проанализированных в какой-нибудь стандартной структуре данных, работающей за логарифмическое время (типа multiset’а в C++),Асимптотика решения — O(n log n).Код332D - Похищение чертежейВ задаче задан неориентированный взвешенный граф без кратных ребер и петель, удовлетворяющий следующему свойству: для любого k-элементного множества S его вершин существует единственная вершина, смежная со всеми вершинами этого множества (*) (эта вершина была названа в условии соседней с S). Для любого k-элементного множества можно вычислить специальную характеристику, равную сумме весов ребер, ведущих из вершин этого множества в соседнюю с ним вершину. Требуется найти среднее арифметическое характеристик всех k-элементных множеств вершин.Решить эту задачу позволяет следующий факт (доказательство которого приведено ниже): при k ≥ 3 условию задачи удовлетворяет только полный граф из k + 1 вершины. Для полных графов ответ на задачу равен удвоенной сумме длин всех ребер, деленной на n. Точно так же вычисляется и ответ для k = 1. Осталось рассмотреть случай k = 2. Переберем вершину i, которая будет являться соседней с нашим двухэлементным множеством. Выпишем в порядке возрастания все такие номера вершин j, что ci, j ≠  - 1. Любые две вершины из построенного списка образуют множество, для которого вершина i является соседней, а других таких множеств не существует. Перебирая все пары вершин из этого списка, мы можем прибавить характеристики всех этих множеств к ответу. Поскольку в задаче гарантируется, что граф удовлетворяет свойству (*), то каждая пара вершин будет проанализирована ровно один раз. Отметим, что аналогичный подход используется и в валидаторе к данной задаче.Асимптотическая сложность решения составляет, таким образом, O(n2)КодДоказательство.Пусть в графе любые k вершин имеют ровно одну общую смежную вершину (*)Лемма 1. У любых двух вершин ровно k - 1 общая смежная вершина.Рассмотрим две произвольные различные вершины s, t. Пусть v1, v2, ..., vl — все различные общие смежные вершины этих двух вершин. Если l ≥ k, то мы получим, что вершины из множества {v1, ..., vk} имеют две общие смежные вершины s, t, что противоречит (*). Пусть теперь l ≤ k - 2. Рассмотрим множество вершин S = {s, t, v1, ..., vl}, состоящее из l + 2 ≤ k элементов. Если l + 2 < k, дополним это множество до k-элементного произвольными вершинами, не входящими в S. Полученное множество назовем T. Согласно (*), существует единственная вершина u, не входящая в T, которая смежна со всеми вершинами из T. В частности, эта вершина смежна с вершинами s и t. Однако по построению во множестве T должны были находиться все вершины, смежные c s и t, в том числе и вершина u. Получили противоречие. Значит, l = k - 1.Лемма 2. В нашем графе найдется полный подграф из k + 1 вершины.Рассмотрим множество S = {v1, ..., vk, vk + 1}, в котором v1, ... vk — произвольные попарно различные вершины нашего графа, vk + 1 — их общая смежная вершина. Приведем конструктивный способ построения полного подграфа на основе этого множества. Осуществим k - 1 итерацию, на i-ой итерации будем рассматривать вершину vi. Если эта вершина смежна со всеми вершинами vi + 1, ..., vk, то перейдем к следующей итерации. Иначе рассмотрим множество T = {v1, ..., vi - 1, vi + 1, ...vk + 1}. У вершин из T существует ровно одна общая смежная вершина u (не совпадающая, очевидно, с vi, поскольку vi смежна не со всеми вершинами из T). Заменим вершину vi на u и перейдем к следующей итерации. После окончания последней итерации множество S, очевидно, будет являться множеством вершин полного подграфа.Покажем, что при k ≥ 3 наш граф — это полный граф из k + 1 вершины. Согласно лемме 2, в этом в графе найдется полный подграф с множеством вершин S = {v1, ..., vk + 1}. Допустим, что в нашем графе найдется вершина u, не принадлежащая S. Так как S — множество вершин полного подграфа, а любые две вершины согласно (1) имеют ровно k - 1 общую вершину, то все общие смежные вершины v1 и v2 (как и любых двух различных вершин из S) лежат в S. Если любые k вершин имеют общую смежную вершину, то и любые i (2 ≤ i ≤ k - 1) вершин имеют общую смежную вершину (возможно, не единственную). В частности, поскольку k ≥ 3, общую смежную вершину имеют вершины v1, v2, u, и эта вершина принадлежит S (как общая смежная вершина v1 и v2). Если допустить, что у u есть две смежных вершины x, y из S, то получим противоречие (1) (поскольку у этих двух смежных вершин будет k общих смежных вершин). Следовательно, в S существует единственная вершина x, смежная с u. Возьмем вершину y из S, отличную от x. У вершин (u, x, y) есть общая смежная вершина, и она принадлежит S. Но это значит, что u имеет две смежных вершины из S. Противоречие.332E - Двоичный ключПереберем cnt — количество единичных бит в ключе. Заметим, что cnt достаточно перебирать до min(|s|, k), поскольку ключи, содержащие более чем |s| единичных бит, не могут являться минимальными лексикографически. Научимся решать задачу для фиксированного cnt. Заметим, что любой полный проход по ключу соответствует выписыванию cnt из k просмотренных символов контейнера, т.е. контейнер разбивается на блоки длины k, а сообщение — на блоки длины cnt (последние блоки могут иметь меньшую длину). Пронумеруем символы каждого блока сообщения от 0 до cnt–1. Назовем (q, j)-суффиксом сообщения суффикс его q-ого блока, начинающийся с позиции j в этом блоке. Решим задачу динамическим программированием: di, j – верно ли, что существует ключ, первые i символов которого – нули и при использовании которого будет выписана строка, получаемая конкатенацией всех (q, j)-суффиксов сообщения. Переходы в этой динамике основаны на постановке в i-ую позицию ключа либо нуля, либо единицы (каждый раз нужно выбирать минимальный допустимый символ). Для восстановления самого ключа требуется сохранять для каждой подзадачи и сами выбранные символы, либо анализировать сами значения динамики.Асимптотическая сложность решения — O(k·|s|2 + |p|).Код",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8447",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 332\\s*B"
          },
          "content_length": 7731
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "5 2\n3 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "C_m^k * k * sum / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n / 2, \"k\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 1, 1000000000, \"x_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n / 2, \"k\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 1, 1000000000, \"x_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n / 2, \"k\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 1, 1000000000, \"x_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(2 <= n && n <= 200000);     // 2 ≤ n ≤ 2·10^5\n    ensure(0 < 2 * k && 2 * k <= n);   // 0 < 2k ≤ n\n\n    vector<int> xi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"max_absurdity\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1000000000;\n        }\n    } else if (type == \"min_absurdity\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1;\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = val;\n            val = min(1000000000, val + rnd.next(0, 1000000000));\n        }\n    } else if (type == \"decreasing\") {\n        int val = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = val;\n            val = max(1, val - rnd.next(0, 1000000000));\n        }\n    } else if (type == \"multiple_optimal\") {\n        // Create multiple segments with the same total absurdity\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1;\n        }\n        int num_segments = (n - 2 * k + 1);\n        for (int i = 0; i < num_segments; ++i) {\n            for (int j = 0; j < k; ++j) {\n                xi[i + j] = 1000000000;\n                xi[n - k - i + j] = 1000000000;\n            }\n        }\n    } else if (type == \"overlapping_max\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1;\n        }\n        // Set overlapping segments to have high absurdity\n        int start = n / 2 - k;\n        for (int i = start; i < start + 2 * k; ++i) {\n            xi[i] = 1000000000;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", xi[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(2 <= n && n <= 200000);     // 2 ≤ n ≤ 2·10^5\n    ensure(0 < 2 * k && 2 * k <= n);   // 0 < 2k ≤ n\n\n    vector<int> xi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"max_absurdity\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1000000000;\n        }\n    } else if (type == \"min_absurdity\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1;\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = val;\n            val = min(1000000000, val + rnd.next(0, 1000000000));\n        }\n    } else if (type == \"decreasing\") {\n        int val = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = val;\n            val = max(1, val - rnd.next(0, 1000000000));\n        }\n    } else if (type == \"multiple_optimal\") {\n        // Create multiple segments with the same total absurdity\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1;\n        }\n        int num_segments = (n - 2 * k + 1);\n        for (int i = 0; i < num_segments; ++i) {\n            for (int j = 0; j < k; ++j) {\n                xi[i + j] = 1000000000;\n                xi[n - k - i + j] = 1000000000;\n            }\n        }\n    } else if (type == \"overlapping_max\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 1;\n        }\n        // Set overlapping segments to have high absurdity\n        int start = n / 2 - k;\n        for (int i = start; i < start + 2 * k; ++i) {\n            xi[i] = 1000000000;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", xi[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -k 2 -type random\n./gen -n 10 -k 2 -type max_absurdity\n./gen -n 10 -k 2 -type min_absurdity\n./gen -n 10 -k 2 -type all_same\n./gen -n 10 -k 2 -type increasing\n./gen -n 10 -k 2 -type decreasing\n./gen -n 10 -k 2 -type multiple_optimal\n\n./gen -n 100 -k 5 -type random\n./gen -n 100 -k 5 -type max_absurdity\n./gen -n 100 -k 5 -type min_absurdity\n./gen -n 100 -k 5 -type all_same\n./gen -n 100 -k 5 -type increasing\n./gen -n 100 -k 5 -type decreasing\n\n./gen -n 50000 -k 25000 -type random\n./gen -n 50000 -k 25000 -type min_absurdity\n./gen -n 50000 -k 25000 -type max_absurdity\n./gen -n 50000 -k 25000 -type multiple_optimal\n\n./gen -n 200000 -k 100000 -type random\n./gen -n 200000 -k 100000 -type min_absurdity\n./gen -n 200000 -k 100000 -type max_absurdity\n./gen -n 200000 -k 100000 -type all_same\n./gen -n 200000 -k 100000 -type multiple_optimal\n\n./gen -n 200000 -k 1 -type random\n./gen -n 200000 -k 1 -type overlapping_max\n./gen -n 200000 -k 1 -type multiple_optimal\n./gen -n 200000 -k 1 -type increasing\n./gen -n 200000 -k 1 -type decreasing\n\n./gen -n 200000 -k 2 -type random\n./gen -n 200000 -k 2 -type overlapping_max\n./gen -n 200000 -k 2 -type multiple_optimal\n\n./gen -n 200000 -k 99999 -type random\n./gen -n 200000 -k 99999 -type max_absurdity\n./gen -n 200000 -k 99999 -type all_same\n./gen -n 200000 -k 99999 -type overlapping_max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:22.027503",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "332/C",
      "title": "C. Месть студентов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n (1 ≤ n ≤ 105), p (1 ≤ p ≤ n), k (1 ≤ k ≤ p) — количество приказов, которые будут рассмотрены ректоратом, количество приказов, которые будут приняты ректоратом, и количество приказов, которые будут выполнены заведующей, соответственно. Каждая из следующих n строк содержит два целых числа ai и bi (1 ≤ ai, bi ≤ 109), описывающих соответствующий приказ.",
      "output_spec": "Выходные данныеВыведите в произвольном порядке p различных целых чисел — номера приказов, которые необходимо принять, чтобы осуществить замысел студентов. Приказы нумеруются от 1 до n согласно порядку их следования во входных данных. Если оптимальных решений несколько, можно вывести любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 3 25 65 81 34 34 11Выходные данныеСкопировать3 1 2 Входные данныеСкопировать5 3 310 1818 1710 2020 1820 18Выходные данныеСкопировать2 4 5",
      "description": "C. Месть студентов\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n (1 ≤ n ≤ 105), p (1 ≤ p ≤ n), k (1 ≤ k ≤ p) — количество приказов, которые будут рассмотрены ректоратом, количество приказов, которые будут приняты ректоратом, и количество приказов, которые будут выполнены заведующей, соответственно. Каждая из следующих n строк содержит два целых числа ai и bi (1 ≤ ai, bi ≤ 109), описывающих соответствующий приказ.\n\nВходные данные\n\nВыходные данныеВыведите в произвольном порядке p различных целых чисел — номера приказов, которые необходимо принять, чтобы осуществить замысел студентов. Приказы нумеруются от 1 до n согласно порядку их следования во входных данных. Если оптимальных решений несколько, можно вывести любое.\n\nВыходные данные\n\nВходные данныеСкопировать5 3 25 65 81 34 34 11Выходные данныеСкопировать3 1 2 Входные данныеСкопировать5 3 310 1818 1710 2020 1820 18Выходные данныеСкопировать2 4 5\n\nВходные данныеСкопировать5 3 25 65 81 34 34 11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 1 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 3 310 1818 1710 2020 1820 18\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 4 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере одно из оптимальных решений — это принятие приказов 1, 2, 3. В этом случае заведующая выполнит приказы с номерами 1 и 2. У нее на голове прибавится 10 седых волос, а недовольство ректората ее действиями будет равно 3. Отметим, что такого же результата можно достичь, приняв вместо приказа 3 приказ 4.Во втором примере заведующая сможет выполнить все приказы, поэтому студентам лучше всего принимать приказы с максимальной суммой ai. На голове у заведующей прибавится 58 седых волос, а недовольство ректората будет равно 0.",
      "solutions": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "Всем привет!Через несколько дней (24 июля, 19:30 MSK) состоится Codeforces Round #193 (Div. 2), который был подготовлен мной. Те, кто уже вышел в первый дивизион, традиционно могут поучаствовать в раунде вне конкурса.Хотелось бы поблагодарить Виталия Гриднева (gridnevvvit), Павла Кунявского (PavelKunyavskiy) и Дмитрия Иванова (DmitriyIvanov) за тестирование задач, координатора раундов Геральда Агапова (Gerald) за полезные советы и Марию Белову (Delinur) за перевод условий на английский язык.Всем удачи и высокого рейтинга!UPD1. В раунде будет использоваться динамическая разбалловка (см. здесь). Задачи будут расположены в порядке возрастания предполагаемой сложности.UPD2. Опубликован разбор задач.UPD3. Рейтинг участников обновлен. Поздравляем победителей, решивших 4 задачи:WilliamacmWindseekerTifueraseen",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8424",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 813
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "332A - Выпьем?Поскольку n ≥ 4, один ход Васи никак не влияет на то, выпьет ли он стакан сока во время другого своего хода. Следовательно, задача заключается просто в том, чтобы найти в заданной строке количество позиций, номера которых (в 0-индексации) кратны n и перед которыми стоит хотя бы три одинаковых символа.Асимптотика решения — O(|s|)Код332B - Максимальная абсурдностьПредварительно построим массив частичных сумм, который позволит отвечать на запрос суммы на отрезке за O(1). Будем перебирать по убыванию число a из ответа — левую границу того из наших отрезков, который лежит левее. Теперь нужно среди отрезков длины k, начинающихся с элемента не левее a + k, выбрать отрезок с максимальной суммой. Поскольку a перебирается по убыванию, то такой отрезок можно поддерживать при переходе от a к a - 1. Асимптотика решения — O(n).Код332C - Месть студентовОтсортируем приказы в первую очередь по возрастанию bi, а при равенстве bi — по убыванию ai. Можно считать, что в оптимальном решении все приказы, выполненные заведующей, следуют (в отсортированном списке) после тех приказов, которые она не выполнила (это может быть неверно в случае наличия одинаковых приказов, однако на параметры ответа это все равно не влияет). Переберем i — номер первого приказа в отсортированном списке, который выполнит заведующая. Слева от этого приказа нужно выбрать p - k приказов, которые заведующая не выполнит. Поскольку требуется, что сумма bi у этих приказов была наибольшей, можно выбрать последние p - k приказов, стоящие перед i-ым приказом. Справа от i-ого приказа требуется выбрать k - 1 приказ, который заведующая выполнит. Требуется, чтобы эти приказы имели максимальную сумму ai. Если i перебирать по убыванию, то эту максимальную сумму можно поддерживать, просто храня k - 1 максимальных ai из уже проанализированных в какой-нибудь стандартной структуре данных, работающей за логарифмическое время (типа multiset’а в C++),Асимптотика решения — O(n log n).Код332D - Похищение чертежейВ задаче задан неориентированный взвешенный граф без кратных ребер и петель, удовлетворяющий следующему свойству: для любого k-элементного множества S его вершин существует единственная вершина, смежная со всеми вершинами этого множества (*) (эта вершина была названа в условии соседней с S). Для любого k-элементного множества можно вычислить специальную характеристику, равную сумме весов ребер, ведущих из вершин этого множества в соседнюю с ним вершину. Требуется найти среднее арифметическое характеристик всех k-элементных множеств вершин.Решить эту задачу позволяет следующий факт (доказательство которого приведено ниже): при k ≥ 3 условию задачи удовлетворяет только полный граф из k + 1 вершины. Для полных графов ответ на задачу равен удвоенной сумме длин всех ребер, деленной на n. Точно так же вычисляется и ответ для k = 1. Осталось рассмотреть случай k = 2. Переберем вершину i, которая будет являться соседней с нашим двухэлементным множеством. Выпишем в порядке возрастания все такие номера вершин j, что ci, j ≠  - 1. Любые две вершины из построенного списка образуют множество, для которого вершина i является соседней, а других таких множеств не существует. Перебирая все пары вершин из этого списка, мы можем прибавить характеристики всех этих множеств к ответу. Поскольку в задаче гарантируется, что граф удовлетворяет свойству (*), то каждая пара вершин будет проанализирована ровно один раз. Отметим, что аналогичный подход используется и в валидаторе к данной задаче.Асимптотическая сложность решения составляет, таким образом, O(n2)КодДоказательство.Пусть в графе любые k вершин имеют ровно одну общую смежную вершину (*)Лемма 1. У любых двух вершин ровно k - 1 общая смежная вершина.Рассмотрим две произвольные различные вершины s, t. Пусть v1, v2, ..., vl — все различные общие смежные вершины этих двух вершин. Если l ≥ k, то мы получим, что вершины из множества {v1, ..., vk} имеют две общие смежные вершины s, t, что противоречит (*). Пусть теперь l ≤ k - 2. Рассмотрим множество вершин S = {s, t, v1, ..., vl}, состоящее из l + 2 ≤ k элементов. Если l + 2 < k, дополним это множество до k-элементного произвольными вершинами, не входящими в S. Полученное множество назовем T. Согласно (*), существует единственная вершина u, не входящая в T, которая смежна со всеми вершинами из T. В частности, эта вершина смежна с вершинами s и t. Однако по построению во множестве T должны были находиться все вершины, смежные c s и t, в том числе и вершина u. Получили противоречие. Значит, l = k - 1.Лемма 2. В нашем графе найдется полный подграф из k + 1 вершины.Рассмотрим множество S = {v1, ..., vk, vk + 1}, в котором v1, ... vk — произвольные попарно различные вершины нашего графа, vk + 1 — их общая смежная вершина. Приведем конструктивный способ построения полного подграфа на основе этого множества. Осуществим k - 1 итерацию, на i-ой итерации будем рассматривать вершину vi. Если эта вершина смежна со всеми вершинами vi + 1, ..., vk, то перейдем к следующей итерации. Иначе рассмотрим множество T = {v1, ..., vi - 1, vi + 1, ...vk + 1}. У вершин из T существует ровно одна общая смежная вершина u (не совпадающая, очевидно, с vi, поскольку vi смежна не со всеми вершинами из T). Заменим вершину vi на u и перейдем к следующей итерации. После окончания последней итерации множество S, очевидно, будет являться множеством вершин полного подграфа.Покажем, что при k ≥ 3 наш граф — это полный граф из k + 1 вершины. Согласно лемме 2, в этом в графе найдется полный подграф с множеством вершин S = {v1, ..., vk + 1}. Допустим, что в нашем графе найдется вершина u, не принадлежащая S. Так как S — множество вершин полного подграфа, а любые две вершины согласно (1) имеют ровно k - 1 общую вершину, то все общие смежные вершины v1 и v2 (как и любых двух различных вершин из S) лежат в S. Если любые k вершин имеют общую смежную вершину, то и любые i (2 ≤ i ≤ k - 1) вершин имеют общую смежную вершину (возможно, не единственную). В частности, поскольку k ≥ 3, общую смежную вершину имеют вершины v1, v2, u, и эта вершина принадлежит S (как общая смежная вершина v1 и v2). Если допустить, что у u есть две смежных вершины x, y из S, то получим противоречие (1) (поскольку у этих двух смежных вершин будет k общих смежных вершин). Следовательно, в S существует единственная вершина x, смежная с u. Возьмем вершину y из S, отличную от x. У вершин (u, x, y) есть общая смежная вершина, и она принадлежит S. Но это значит, что u имеет две смежных вершины из S. Противоречие.332E - Двоичный ключПереберем cnt — количество единичных бит в ключе. Заметим, что cnt достаточно перебирать до min(|s|, k), поскольку ключи, содержащие более чем |s| единичных бит, не могут являться минимальными лексикографически. Научимся решать задачу для фиксированного cnt. Заметим, что любой полный проход по ключу соответствует выписыванию cnt из k просмотренных символов контейнера, т.е. контейнер разбивается на блоки длины k, а сообщение — на блоки длины cnt (последние блоки могут иметь меньшую длину). Пронумеруем символы каждого блока сообщения от 0 до cnt–1. Назовем (q, j)-суффиксом сообщения суффикс его q-ого блока, начинающийся с позиции j в этом блоке. Решим задачу динамическим программированием: di, j – верно ли, что существует ключ, первые i символов которого – нули и при использовании которого будет выписана строка, получаемая конкатенацией всех (q, j)-суффиксов сообщения. Переходы в этой динамике основаны на постановке в i-ую позицию ключа либо нуля, либо единицы (каждый раз нужно выбирать минимальный допустимый символ). Для восстановления самого ключа требуется сохранять для каждой подзадачи и сами выбранные символы, либо анализировать сами значения динамики.Асимптотическая сложность решения — O(k·|s|2 + |p|).Код",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8447",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 332\\s*C"
          },
          "content_length": 7731
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "5 2\n3 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "C_m^k * k * sum / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int k = inf.readInt(1, p, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"ai[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int k = inf.readInt(1, p, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"ai[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int k = inf.readInt(1, p, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"ai[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000000000, \"bi[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, p, k;\nvector<long long> ai;\nvector<long long> bi;\n\nbool cmp_chairperson(const pair<long long, pair<long long, int>> &a, const pair<long long, pair<long long, int>> &b) {\n    if (a.first != b.first) return a.first > b.first; // higher bi first\n    else return a.second.first < b.second.first;      // lower ai\n}\n\n// This function reads an answer from the stream, validates it, and calculates\n// the total grey hairs and displeasure sums according to the problem's logic.\nvoid readAns(InStream& stream, long long &greyHairSum, long long &displeasureSum) {\n    // Read p integers\n    vector<int> orders;\n    set<int> used;\n    for (int i = 0; i < p; i++) {\n        int idx = stream.readInt(1, n, format(\"order index #%d\", i + 1).c_str());\n        if (used.count(idx))\n            stream.quitf(_wa, \"order index %d is duplicated\", idx);\n        used.insert(idx);\n        orders.push_back(idx - 1); // zero-based indexing\n    }\n    // Simulate the chairperson's selection\n    vector<pair<long long, pair<long long, int>>> selectedOrders; // (bi, (ai, index))\n\n    for (int idx : orders) {\n        selectedOrders.push_back( make_pair(bi[idx], make_pair(ai[idx], idx)) );\n    }\n\n    // Sort according to the chairperson's preferences\n    sort(selectedOrders.begin(), selectedOrders.end(), cmp_chairperson);\n\n    greyHairSum = 0;\n    displeasureSum = 0;\n\n    // First k orders are obeyed\n    for (int i = 0; i < k; i++) {\n        greyHairSum += selectedOrders[i].second.first; // ai\n    }\n    // Remaining p - k orders are disobeyed\n    for (int i = k; i < p; i++) {\n        displeasureSum += selectedOrders[i].first; // bi\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    n = inf.readInt();\n    p = inf.readInt();\n    k = inf.readInt();\n\n    if (p < k || k < 1 || p > n) {\n        quitf(_fail, \"Invalid input values: p = %d, k = %d, n = %d\", p, k, n);\n    }\n\n    ai.resize(n);\n    bi.resize(n);\n    for (int i = 0; i < n; i++) {\n        ai[i] = inf.readLong();\n        bi[i] = inf.readLong();\n    }\n\n    // Read jury's answer\n    long long jGreyHairSum = 0, jDispleasureSum = 0;\n    readAns(ans, jGreyHairSum, jDispleasureSum);\n\n    // Read participant's answer\n    long long pGreyHairSum = 0, pDispleasureSum = 0;\n    readAns(ouf, pGreyHairSum, pDispleasureSum);\n\n    if (pGreyHairSum < jGreyHairSum) {\n        quitf(_wa, \"Participant's total grey hairs %lld is less than jury's %lld\", pGreyHairSum, jGreyHairSum);\n    }\n    else if (pGreyHairSum == jGreyHairSum) {\n        if (pDispleasureSum < jDispleasureSum) {\n            quitf(_wa, \"Participant's total displeasure %lld is less than jury's %lld with same grey hairs\", pDispleasureSum, jDispleasureSum);\n        }\n        else {\n            quitf(_ok, \"Total grey hairs = %lld, displeasure = %lld\", pGreyHairSum, pDispleasureSum);\n        }\n    }\n    else { // pGreyHairSum > jGreyHairSum\n        quitf(_fail, \"Participant's total grey hairs %lld is greater than jury's %lld\", pGreyHairSum, jGreyHairSum);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= n && n <= 100000);\n    assert(1 <= p && p <= n);\n    assert(1 <= k && k <= p);\n\n    // Output n, p, k\n    printf(\"%d %d %d\\n\", n, p, k);\n\n    vector<pair<int, int>> orders(n);\n\n    if (type == \"random\") {\n        // Random a_i and b_i\n        for(int i = 0; i < n; i++) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            orders[i] = {a, b};\n        }\n    } else if (type == \"maximal_a_minimal_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1000000000;\n            int b = 1;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"minimal_a_maximal_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1;\n            int b = 1000000000;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"all_equal_values\") {\n        int a = rnd.next(1, 1000000000);\n        int b = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; i++) {\n            orders[i] = {a, b};\n        }\n    } else if (type == \"increasing_a_decreasing_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = i * (1000000000LL / n) + 1;\n            int b = 1000000000 - i * (1000000000LL / n);\n            orders[i] = {a, b};\n        }\n    } else if (type == \"decreasing_a_increasing_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1000000000 - i * (1000000000LL / n);\n            int b = i * (1000000000LL / n) + 1;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"small_values\") {\n        for(int i = 0; i < n; i++) {\n            int a = rnd.next(1, 10);\n            int b = rnd.next(1, 10);\n            orders[i] = {a, b};\n        }\n    } else if (type == \"maximal_values\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1000000000;\n            int b = 1000000000;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"minimal_values\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1;\n            int b = 1;\n            orders[i] = {a, b};\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; i++) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            orders[i] = {a, b};\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", orders[i].first, orders[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= n && n <= 100000);\n    assert(1 <= p && p <= n);\n    assert(1 <= k && k <= p);\n\n    // Output n, p, k\n    printf(\"%d %d %d\\n\", n, p, k);\n\n    vector<pair<int, int>> orders(n);\n\n    if (type == \"random\") {\n        // Random a_i and b_i\n        for(int i = 0; i < n; i++) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            orders[i] = {a, b};\n        }\n    } else if (type == \"maximal_a_minimal_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1000000000;\n            int b = 1;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"minimal_a_maximal_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1;\n            int b = 1000000000;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"all_equal_values\") {\n        int a = rnd.next(1, 1000000000);\n        int b = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; i++) {\n            orders[i] = {a, b};\n        }\n    } else if (type == \"increasing_a_decreasing_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = i * (1000000000LL / n) + 1;\n            int b = 1000000000 - i * (1000000000LL / n);\n            orders[i] = {a, b};\n        }\n    } else if (type == \"decreasing_a_increasing_b\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1000000000 - i * (1000000000LL / n);\n            int b = i * (1000000000LL / n) + 1;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"small_values\") {\n        for(int i = 0; i < n; i++) {\n            int a = rnd.next(1, 10);\n            int b = rnd.next(1, 10);\n            orders[i] = {a, b};\n        }\n    } else if (type == \"maximal_values\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1000000000;\n            int b = 1000000000;\n            orders[i] = {a, b};\n        }\n    } else if (type == \"minimal_values\") {\n        for(int i = 0; i < n; i++) {\n            int a = 1;\n            int b = 1;\n            orders[i] = {a, b};\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; i++) {\n            int a = rnd.next(1, 1000000000);\n            int b = rnd.next(1, 1000000000);\n            orders[i] = {a, b};\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", orders[i].first, orders[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -p 1 -k 1 -type random\n./gen -n 5 -p 3 -k 2 -type random\n./gen -n 10 -p 5 -k 3 -type all_equal_values\n./gen -n 20 -p 10 -k 5 -type minimal_values\n./gen -n 50 -p 25 -k 25 -type maximal_values\n\n# Edge cases with n = 1\n./gen -n 1 -p 1 -k 1 -type minimal_a_maximal_b\n./gen -n 1 -p 1 -k 1 -type maximal_a_minimal_b\n\n# Edge cases with large n and small p\n./gen -n 100000 -p 1 -k 1 -type random\n\n# Edge cases with p = n\n./gen -n 100000 -p 100000 -k 1 -type random\n\n# Max n, random types\n./gen -n 100000 -p 50000 -k 25000 -type random\n./gen -n 100000 -p 50000 -k 50000 -type random\n\n# Max n, p = k = n\n./gen -n 100000 -p 100000 -k 100000 -type random\n./gen -n 100000 -p 100000 -k 100000 -type maximal_values\n\n# Various k values\n./gen -n 1000 -p 500 -k 1 -type increasing_a_decreasing_b\n./gen -n 1000 -p 500 -k 500 -type decreasing_a_increasing_b\n./gen -n 1000 -p 500 -k 250 -type random\n\n# Tests with possible tie-breaks\n./gen -n 1000 -p 500 -k 250 -type all_equal_values\n./gen -n 1000 -p 500 -k 250 -type minimal_a_maximal_b\n./gen -n 1000 -p 500 -k 250 -type maximal_a_minimal_b\n\n# Small values\n./gen -n 100 -p 50 -k 25 -type small_values\n\n# Large values\n./gen -n 1000 -p 500 -k 250 -type maximal_values\n\n# Testing p = n\n./gen -n 1000 -p 1000 -k 500 -type random\n\n# Edge cases where k = p\n./gen -n 1000 -p 500 -k 500 -type random\n./gen -n 1000 -p 500 -k 500 -type increasing_a_decreasing_b\n\n# Edge cases where k = 1\n./gen -n 1000 -p 500 -k 1 -type random\n\n# Maximal displeasement test\n./gen -n 1000 -p 500 -k 250 -type minimal_a_maximal_b\n\n# Maximal gray hair growth test\n./gen -n 1000 -p 500 -k 250 -type maximal_a_minimal_b\n\n# All a_i = b_i\n./gen -n 1000 -p 500 -k 250 -type all_equal_values\n\n# Max n, minimal values\n./gen -n 100000 -p 50000 -k 25000 -type minimal_values\n\n# Max n, maximal values\n./gen -n 100000 -p 50000 -k 25000 -type maximal_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:23.875169",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "332/D",
      "title": "D. Похищение чертежей",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n и k (2 ≤ n ≤ 2000, 1 ≤ k ≤ n - 1) — количество шахт и количество разведывательных групп соответственно. В следующих n - 1 строках описывается план полигона: i-ая из этих строк содержит n - i целых чисел ci, i + 1, ci, i + 2, ..., ci, n — количество дроидов, патрулирующих соответствующие переходы (-1 ≤ ci, j ≤ 109; если ci, j =  -1, то перехода между шахтами i и j нет). Все переходы являются двунаправленными, то есть можно считать, что ci, j = cj, i. Переходов, соединяющих шахту саму с собой, не существует. Гарантируется, что план полигона удовлетворяет условию задачи.",
      "output_spec": "Выходные данныеВыведите среднюю опасность разведывательной операции, округленную вниз до целого числа. Обратите внимание, что при указанных ограничениях ответ на задачу всегда помещается в стандартный целочисленный 64-битный тип данных.Пожалуйста, не используйте спецификатор %lld для вывода 64-битных чисел на С++. Рекомендуется использовать поток cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 1-1 -1 -1 8 -1-1 5 -1 -1-1 -1 3-1 -1-1Выходные данныеСкопировать5Входные данныеСкопировать3 210 011Выходные данныеСкопировать14",
      "description": "D. Похищение чертежей\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n и k (2 ≤ n ≤ 2000, 1 ≤ k ≤ n - 1) — количество шахт и количество разведывательных групп соответственно. В следующих n - 1 строках описывается план полигона: i-ая из этих строк содержит n - i целых чисел ci, i + 1, ci, i + 2, ..., ci, n — количество дроидов, патрулирующих соответствующие переходы (-1 ≤ ci, j ≤ 109; если ci, j =  -1, то перехода между шахтами i и j нет). Все переходы являются двунаправленными, то есть можно считать, что ci, j = cj, i. Переходов, соединяющих шахту саму с собой, не существует. Гарантируется, что план полигона удовлетворяет условию задачи.\n\nВходные данные\n\nВыходные данныеВыведите среднюю опасность разведывательной операции, округленную вниз до целого числа. Обратите внимание, что при указанных ограничениях ответ на задачу всегда помещается в стандартный целочисленный 64-битный тип данных.Пожалуйста, не используйте спецификатор %lld для вывода 64-битных чисел на С++. Рекомендуется использовать поток cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать6 1-1 -1 -1 8 -1-1 5 -1 -1-1 -1 3-1 -1-1Выходные данныеСкопировать5Входные данныеСкопировать3 210 011Выходные данныеСкопировать14\n\nВходные данныеСкопировать6 1-1 -1 -1 8 -1-1 5 -1 -1-1 -1 3-1 -1-1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 210 011\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать14\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере существует 6 одноэлементных множеств шахт. Для множеств {1}, {5} опасность операции составит 8, для множеств {3}, {6} — 3, для множеств {2}, {4} — 5. Среднее арифметическое равно .Во втором примере существует 3 двухэлементных множества шахт: {1, 3} (опасность равна 21), {1, 2} (опасность равна 11), {2, 3} (опасность равна 10). Средняя опасность операции равна .",
      "solutions": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "Всем привет!Через несколько дней (24 июля, 19:30 MSK) состоится Codeforces Round #193 (Div. 2), который был подготовлен мной. Те, кто уже вышел в первый дивизион, традиционно могут поучаствовать в раунде вне конкурса.Хотелось бы поблагодарить Виталия Гриднева (gridnevvvit), Павла Кунявского (PavelKunyavskiy) и Дмитрия Иванова (DmitriyIvanov) за тестирование задач, координатора раундов Геральда Агапова (Gerald) за полезные советы и Марию Белову (Delinur) за перевод условий на английский язык.Всем удачи и высокого рейтинга!UPD1. В раунде будет использоваться динамическая разбалловка (см. здесь). Задачи будут расположены в порядке возрастания предполагаемой сложности.UPD2. Опубликован разбор задач.UPD3. Рейтинг участников обновлен. Поздравляем победителей, решивших 4 задачи:WilliamacmWindseekerTifueraseen",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8424",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 813
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "332A - Выпьем?Поскольку n ≥ 4, один ход Васи никак не влияет на то, выпьет ли он стакан сока во время другого своего хода. Следовательно, задача заключается просто в том, чтобы найти в заданной строке количество позиций, номера которых (в 0-индексации) кратны n и перед которыми стоит хотя бы три одинаковых символа.Асимптотика решения — O(|s|)Код332B - Максимальная абсурдностьПредварительно построим массив частичных сумм, который позволит отвечать на запрос суммы на отрезке за O(1). Будем перебирать по убыванию число a из ответа — левую границу того из наших отрезков, который лежит левее. Теперь нужно среди отрезков длины k, начинающихся с элемента не левее a + k, выбрать отрезок с максимальной суммой. Поскольку a перебирается по убыванию, то такой отрезок можно поддерживать при переходе от a к a - 1. Асимптотика решения — O(n).Код332C - Месть студентовОтсортируем приказы в первую очередь по возрастанию bi, а при равенстве bi — по убыванию ai. Можно считать, что в оптимальном решении все приказы, выполненные заведующей, следуют (в отсортированном списке) после тех приказов, которые она не выполнила (это может быть неверно в случае наличия одинаковых приказов, однако на параметры ответа это все равно не влияет). Переберем i — номер первого приказа в отсортированном списке, который выполнит заведующая. Слева от этого приказа нужно выбрать p - k приказов, которые заведующая не выполнит. Поскольку требуется, что сумма bi у этих приказов была наибольшей, можно выбрать последние p - k приказов, стоящие перед i-ым приказом. Справа от i-ого приказа требуется выбрать k - 1 приказ, который заведующая выполнит. Требуется, чтобы эти приказы имели максимальную сумму ai. Если i перебирать по убыванию, то эту максимальную сумму можно поддерживать, просто храня k - 1 максимальных ai из уже проанализированных в какой-нибудь стандартной структуре данных, работающей за логарифмическое время (типа multiset’а в C++),Асимптотика решения — O(n log n).Код332D - Похищение чертежейВ задаче задан неориентированный взвешенный граф без кратных ребер и петель, удовлетворяющий следующему свойству: для любого k-элементного множества S его вершин существует единственная вершина, смежная со всеми вершинами этого множества (*) (эта вершина была названа в условии соседней с S). Для любого k-элементного множества можно вычислить специальную характеристику, равную сумме весов ребер, ведущих из вершин этого множества в соседнюю с ним вершину. Требуется найти среднее арифметическое характеристик всех k-элементных множеств вершин.Решить эту задачу позволяет следующий факт (доказательство которого приведено ниже): при k ≥ 3 условию задачи удовлетворяет только полный граф из k + 1 вершины. Для полных графов ответ на задачу равен удвоенной сумме длин всех ребер, деленной на n. Точно так же вычисляется и ответ для k = 1. Осталось рассмотреть случай k = 2. Переберем вершину i, которая будет являться соседней с нашим двухэлементным множеством. Выпишем в порядке возрастания все такие номера вершин j, что ci, j ≠  - 1. Любые две вершины из построенного списка образуют множество, для которого вершина i является соседней, а других таких множеств не существует. Перебирая все пары вершин из этого списка, мы можем прибавить характеристики всех этих множеств к ответу. Поскольку в задаче гарантируется, что граф удовлетворяет свойству (*), то каждая пара вершин будет проанализирована ровно один раз. Отметим, что аналогичный подход используется и в валидаторе к данной задаче.Асимптотическая сложность решения составляет, таким образом, O(n2)КодДоказательство.Пусть в графе любые k вершин имеют ровно одну общую смежную вершину (*)Лемма 1. У любых двух вершин ровно k - 1 общая смежная вершина.Рассмотрим две произвольные различные вершины s, t. Пусть v1, v2, ..., vl — все различные общие смежные вершины этих двух вершин. Если l ≥ k, то мы получим, что вершины из множества {v1, ..., vk} имеют две общие смежные вершины s, t, что противоречит (*). Пусть теперь l ≤ k - 2. Рассмотрим множество вершин S = {s, t, v1, ..., vl}, состоящее из l + 2 ≤ k элементов. Если l + 2 < k, дополним это множество до k-элементного произвольными вершинами, не входящими в S. Полученное множество назовем T. Согласно (*), существует единственная вершина u, не входящая в T, которая смежна со всеми вершинами из T. В частности, эта вершина смежна с вершинами s и t. Однако по построению во множестве T должны были находиться все вершины, смежные c s и t, в том числе и вершина u. Получили противоречие. Значит, l = k - 1.Лемма 2. В нашем графе найдется полный подграф из k + 1 вершины.Рассмотрим множество S = {v1, ..., vk, vk + 1}, в котором v1, ... vk — произвольные попарно различные вершины нашего графа, vk + 1 — их общая смежная вершина. Приведем конструктивный способ построения полного подграфа на основе этого множества. Осуществим k - 1 итерацию, на i-ой итерации будем рассматривать вершину vi. Если эта вершина смежна со всеми вершинами vi + 1, ..., vk, то перейдем к следующей итерации. Иначе рассмотрим множество T = {v1, ..., vi - 1, vi + 1, ...vk + 1}. У вершин из T существует ровно одна общая смежная вершина u (не совпадающая, очевидно, с vi, поскольку vi смежна не со всеми вершинами из T). Заменим вершину vi на u и перейдем к следующей итерации. После окончания последней итерации множество S, очевидно, будет являться множеством вершин полного подграфа.Покажем, что при k ≥ 3 наш граф — это полный граф из k + 1 вершины. Согласно лемме 2, в этом в графе найдется полный подграф с множеством вершин S = {v1, ..., vk + 1}. Допустим, что в нашем графе найдется вершина u, не принадлежащая S. Так как S — множество вершин полного подграфа, а любые две вершины согласно (1) имеют ровно k - 1 общую вершину, то все общие смежные вершины v1 и v2 (как и любых двух различных вершин из S) лежат в S. Если любые k вершин имеют общую смежную вершину, то и любые i (2 ≤ i ≤ k - 1) вершин имеют общую смежную вершину (возможно, не единственную). В частности, поскольку k ≥ 3, общую смежную вершину имеют вершины v1, v2, u, и эта вершина принадлежит S (как общая смежная вершина v1 и v2). Если допустить, что у u есть две смежных вершины x, y из S, то получим противоречие (1) (поскольку у этих двух смежных вершин будет k общих смежных вершин). Следовательно, в S существует единственная вершина x, смежная с u. Возьмем вершину y из S, отличную от x. У вершин (u, x, y) есть общая смежная вершина, и она принадлежит S. Но это значит, что u имеет две смежных вершины из S. Противоречие.332E - Двоичный ключПереберем cnt — количество единичных бит в ключе. Заметим, что cnt достаточно перебирать до min(|s|, k), поскольку ключи, содержащие более чем |s| единичных бит, не могут являться минимальными лексикографически. Научимся решать задачу для фиксированного cnt. Заметим, что любой полный проход по ключу соответствует выписыванию cnt из k просмотренных символов контейнера, т.е. контейнер разбивается на блоки длины k, а сообщение — на блоки длины cnt (последние блоки могут иметь меньшую длину). Пронумеруем символы каждого блока сообщения от 0 до cnt–1. Назовем (q, j)-суффиксом сообщения суффикс его q-ого блока, начинающийся с позиции j в этом блоке. Решим задачу динамическим программированием: di, j – верно ли, что существует ключ, первые i символов которого – нули и при использовании которого будет выписана строка, получаемая конкатенацией всех (q, j)-суффиксов сообщения. Переходы в этой динамике основаны на постановке в i-ую позицию ключа либо нуля, либо единицы (каждый раз нужно выбирать минимальный допустимый символ). Для восстановления самого ключа требуется сохранять для каждой подзадачи и сами выбранные символы, либо анализировать сами значения динамики.Асимптотическая сложность решения — O(k·|s|2 + |p|).Код",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8447",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 332\\s*D"
          },
          "content_length": 7731
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "5 2\n3 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "C_m^k * k * sum / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    vector<vector<int> > c(n + 1, vector<int>(n + 1, -1)); // 1-based indexing\n\n    // Read the next n - 1 lines\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            if (j != i + 1)\n                inf.readSpace();\n            int cij = inf.readInt(-1, 1000000000, \"c_{\" + to_string(i) + \",\" + to_string(j) + \"}\");\n            c[i][j] = cij;\n        }\n        inf.readEoln();\n    }\n\n    // Ensure no self-loops\n    for (int i = 1; i <= n; ++i) {\n        c[i][i] = -1;\n    }\n\n    // Ensure symmetry: c[i][j] == c[j][i]\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            c[j][i] = c[i][j];\n        }\n    }\n\n    // Check symmetry\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            ensuref(c[i][j] == c[j][i], \"Edge weights are not symmetric between %d and %d\", i, j);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    vector<vector<int> > c(n + 1, vector<int>(n + 1, -1)); // 1-based indexing\n\n    // Read the next n - 1 lines\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            if (j != i + 1)\n                inf.readSpace();\n            int cij = inf.readInt(-1, 1000000000, \"c_{\" + to_string(i) + \",\" + to_string(j) + \"}\");\n            c[i][j] = cij;\n        }\n        inf.readEoln();\n    }\n\n    // Ensure no self-loops\n    for (int i = 1; i <= n; ++i) {\n        c[i][i] = -1;\n    }\n\n    // Ensure symmetry: c[i][j] == c[j][i]\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            c[j][i] = c[i][j];\n        }\n    }\n\n    // Check symmetry\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            ensuref(c[i][j] == c[j][i], \"Edge weights are not symmetric between %d and %d\", i, j);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    vector<vector<int> > c(n + 1, vector<int>(n + 1, -1)); // 1-based indexing\n\n    // Read the next n - 1 lines\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            if (j != i + 1)\n                inf.readSpace();\n            int cij = inf.readInt(-1, 1000000000, \"c_{\" + to_string(i) + \",\" + to_string(j) + \"}\");\n            c[i][j] = cij;\n        }\n        inf.readEoln();\n    }\n\n    // Ensure no self-loops\n    for (int i = 1; i <= n; ++i) {\n        c[i][i] = -1;\n    }\n\n    // Ensure symmetry: c[i][j] == c[j][i]\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            c[j][i] = c[i][j];\n        }\n    }\n\n    // Check symmetry\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            ensuref(c[i][j] == c[j][i], \"Edge weights are not symmetric between %d and %d\", i, j);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"star\");\n\n    if (n < 2 || k < 1 || k >= n) {\n        cerr << \"Invalid parameters: ensure that n >= 2 and 1 <= k <= n - 1\" << endl;\n        return 1;\n    }\n\n    vector<vector<int>> c(n + 1, vector<int>(n + 1, -1)); // 1-based indexing\n\n    if (type == \"star\") {\n        // Build star graph\n        int maxc = opt<int>(\"maxc\", 1000000000);\n        for (int i = 2; i <= n; ++i) {\n            int cost = rnd.next(1, maxc);\n            c[1][i] = cost;\n            c[i][1] = cost;\n        }\n    } else if (type == \"complete\") {\n        // Build complete graph\n        int maxc = opt<int>(\"maxc\", 1000000000);\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                int cost = rnd.next(1, maxc);\n                c[i][j] = cost;\n                c[j][i] = cost;\n            }\n        }\n    } else if (type == \"random\") {\n        // Build random graph\n        int maxc = opt<int>(\"maxc\", 1000000000);\n        int density = opt<int>(\"density\", 50); // density percentage from 0 to 100\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                if (rnd.next(100) < density) {\n                    int cost = rnd.next(1, maxc);\n                    c[i][j] = cost;\n                    c[j][i] = cost;\n                } else {\n                    c[i][j] = c[j][i] = -1; // No edge\n                }\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the adjacency matrix according to the input format\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            if (j != i + 1)\n                printf(\" \");\n            printf(\"%d\", c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"star\");\n\n    if (n < 2 || k < 1 || k >= n) {\n        cerr << \"Invalid parameters: ensure that n >= 2 and 1 <= k <= n - 1\" << endl;\n        return 1;\n    }\n\n    vector<vector<int>> c(n + 1, vector<int>(n + 1, -1)); // 1-based indexing\n\n    if (type == \"star\") {\n        // Build star graph\n        int maxc = opt<int>(\"maxc\", 1000000000);\n        for (int i = 2; i <= n; ++i) {\n            int cost = rnd.next(1, maxc);\n            c[1][i] = cost;\n            c[i][1] = cost;\n        }\n    } else if (type == \"complete\") {\n        // Build complete graph\n        int maxc = opt<int>(\"maxc\", 1000000000);\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                int cost = rnd.next(1, maxc);\n                c[i][j] = cost;\n                c[j][i] = cost;\n            }\n        }\n    } else if (type == \"random\") {\n        // Build random graph\n        int maxc = opt<int>(\"maxc\", 1000000000);\n        int density = opt<int>(\"density\", 50); // density percentage from 0 to 100\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                if (rnd.next(100) < density) {\n                    int cost = rnd.next(1, maxc);\n                    c[i][j] = cost;\n                    c[j][i] = cost;\n                } else {\n                    c[i][j] = c[j][i] = -1; // No edge\n                }\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the adjacency matrix according to the input format\n    for (int i = 1; i <= n - 1; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            if (j != i + 1)\n                printf(\" \");\n            printf(\"%d\", c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 1 -type star\n./gen -n 3 -k 1 -type star\n./gen -n 4 -k 2 -type star\n./gen -n 5 -k 2 -type star\n./gen -n 10 -k 1 -type star\n./gen -n 20 -k 5 -type star\n./gen -n 50 -k 10 -type star\n./gen -n 100 -k 50 -type star\n./gen -n 200 -k 100 -type star\n./gen -n 500 -k 250 -type star\n./gen -n 1000 -k 500 -type star\n./gen -n 2000 -k 1000 -type star -maxc 1000000000\n\n./gen -n 2 -k 1 -type complete\n./gen -n 3 -k 2 -type complete\n./gen -n 5 -k 2 -type complete\n./gen -n 10 -k 5 -type complete\n./gen -n 20 -k 10 -type complete -maxc 1000000000\n./gen -n 50 -k 25 -type complete -maxc 1000000000\n\n./gen -n 10 -k 1 -type random -density 20\n./gen -n 10 -k 2 -type random -density 50\n./gen -n 10 -k 3 -type random -density 80\n./gen -n 100 -k 5 -type random -density 10\n./gen -n 100 -k 10 -type random -density 30\n./gen -n 100 -k 20 -type random -density 70\n\n./gen -n 2000 -k 1999 -type star -maxc 1\n./gen -n 2000 -k 1999 -type star -maxc 1000000000\n./gen -n 2000 -k 1 -type star\n./gen -n 2000 -k 1 -type complete\n./gen -n 2000 -k 1999 -type complete -maxc 1000000000\n./gen -n 2000 -k 1000 -type random -density 50\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:26.021307",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "332/E",
      "title": "E. Binary Key",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first two lines of the input are non-empty strings p and s (1 ≤ |p| ≤ 106, 1 ≤ |s| ≤ 200), describing the container and the message, correspondingly. The strings can contain any characters with the ASCII codes from 32 to 126, inclusive.The third line contains a single integer k (1 ≤ k ≤ 2000) — the key's length.",
      "output_spec": "OutputPrint the required key (string of length k, consisting only of characters 0 and 1). If the key doesn't exist, print the single character 0.",
      "sample_tests": "ExamplesInputCopyabacabaaba6OutputCopy100001InputCopyabacabaaba3OutputCopy0",
      "description": "E. Binary Key\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first two lines of the input are non-empty strings p and s (1 ≤ |p| ≤ 106, 1 ≤ |s| ≤ 200), describing the container and the message, correspondingly. The strings can contain any characters with the ASCII codes from 32 to 126, inclusive.The third line contains a single integer k (1 ≤ k ≤ 2000) — the key's length.\n\nOutputPrint the required key (string of length k, consisting only of characters 0 and 1). If the key doesn't exist, print the single character 0.\n\nInputCopyabacabaaba6OutputCopy100001InputCopyabacabaaba3OutputCopy0\n\nInputCopyabacabaaba6\n\nOutputCopy100001\n\nInputCopyabacabaaba3\n\nOutputCopy0\n\nNoteString x = x1x2... xp is lexicographically smaller than string y = y1y2... yq, if either p < q and x1 = y1, x2 = y2, ... , xp = yp, or there exists such integer r (0 ≤ r < min(p, q)) that x1 = y1, x2 = y2, ... , xr = yr and xr + 1 < yr + 1. Symbols are compared according to their ASCII codes.",
      "solutions": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces",
          "content": "Hello everyone!In several days (July 24, 19:30 MSK) will take place Codeforces Round #193 (Div. 2), which I have prepared. Those who has already reached the first division traditionally can participate in the round out of the competition.I would like to thank Vitaliy Gridnev (gridnevvvit), Pavel Kunyavskiy (PavelKunyavskiy) and Dmitriy Ivanov (DmitriyIvanov) for testing of problemset, coordinator of Codeforces rounds Gerald Agapov (Gerald) for useful hints and Maria Belova (Delinur) for translation of statements into English.Good luck and high rating to all!UPD1. The score distribution in this round will be dynamic (see here). In our opinion problems are sorted according to their difficulty.UPD2. Analysis of problems is publisched.UPD3. Rating is updated. Congrutalations to the winners who solved 4 problems:WilliamacmWindseekerTifueraseen",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8424",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 850
        },
        {
          "title": "Codeforces Round #193 (Div. 2) — Tutorial - Codeforces",
          "content": "Any suggestions, remarks and information about mistakes are welcomed. If you can improve the quality of this tutorial, please write me a private message :)332A - Down the Hatch!Since n ≥ 4, one Vasya’s turn does not affect his other turns. Consequently, you should find just the number of positions (0-indexed) in the given string, which indexes are multiples of n and before which there are at least three same symbols.Asymptotics of the solution — O(|s|)Code332B - Maximum AbsurdityLet’s build the array of partial sums, which will permit to find the sum in any segment of the array in O(1). Let's iterate through the number a (the left edge of the leftmost segment) in descending order. Now we need to find among segments of length k, starting from position which index is greater than or equal to a + k, a segment with the maximum sum. Since we search a in descending order, we can maintain this segment during the transition from a to a - 1.Asymptotics of the solution — O(n).Code332C - Students' RevengeLet’s sort orders ascending bi, and by equality of bi — descending ai. One can assume that in an optimal solution all the orders obeyed by the chairperson go in the sorted list after orders that she hasn’t obeyed (it may be wrong if there are several same orders, but it doesn’t affect parameters of an answer). Let’s iterate through i — the position of the first order in the sorted list, which the chairperson will obey. To the left of this order we should choose p - k orders which the chairperson won’t obey. As we should choose orders with the maximum sum of bi, we can just choose p - k orders that immediately precede the i-th order. To the right of the i-th order we should choose k - 1 orders which the chairperson will obey. These orders should have the maximum sum of ai. If we iterate i by descending, we can keep these k - 1 orders in some data structure that can perform basic operations with sets in logarithmic time (for example, multiset in C++).Asymptotics of the solution — O(nlogn)Code332D - Theft of BlueprintsIn the problem is given the weighted undirected graph without loops and multiple edges satisfying the following property: for every set S containing k vertices there is exactly one vertex adjacent to all vertices from this set (*) (this vertex is called “adjacent with S”). For any k-element set of vertices we can calculate the special characteristic: the sum of the weights of edges that connect vertices from S with vertex, adjacent with S. It is required to find the mathematical average of the characteristics of all k-element sets of vertices.One can solve this problem using the following fact (the proof is now available only in the Russian version of this post): if k ≥ 3, only complete graph containing k + 1 vertices satisfies the problem statement. For complete graphs answer is equal to doubled sum of weights of all edges, divided by n. The same way one can calculate answer if k = 1. Now let’s consider the case k = 2. Let’s iterate through the vertex i which is adjacent with our two-element set. Let’s write in ascending order all such numbers j that ci, j ≠  - 1. Any two different vertices of this list form the set for which vertex i is adjacent, and there are no other such sets of vertices. Looking over all pairs of vertices in this list, we can add characteristics of all these sets to the answer. Since it’s guaranteed that the graph satisfies the property (*), each pair of vertices will be analyzed only once. A similar approach is used in the validator for this problem.Asymptotics of the solution — O(n2).Code332E - Binary KeyLet’s iterate through the number of ones in the key (cnt). One can note that cnt can’t be large than min(|s|, k), as the keys containing more than |s| ones can’t be lexicographically minimal.Let’s consider the solution of this problem with the fixed cnt. Any complete pass on the key corresponds to the extracting cnt of k scanned symbols of the container, i. e. container is divided into blocks of length k, and the message is divided into blocks of length cnt (last blocks may be shorter). We’ll number the characters in each block of the message from 0 to cnt - 1. We’ll call (q, j)-suffix suffix of q-th block of the message that starts from a position j in this block. Let’s solve the problem with dynamic programming: di, j is true if there exists a key, the first i characters of which are zeros and which corresponds to the extracting from container the string that is the result of concatenation of all (q, j)-suffixes of the message. The transitions are based on the filling of i-th position of the key with zero or one (we need to choose the minimum acceptable character). To restore the key you can keep chosen characters for each subtask.Asymptotics of the solution — O(k·|s|2 + |p|).Code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8447",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 332\\s*E"
          },
          "content_length": 4796
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 1",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 2",
          "code": "00:16:47  Skipped [pretests] → 4148842\n01:00:50  Accepted [final tests] → 4152076",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) - Codeforces - Code 3",
          "code": "5 2\n3 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8424",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #193 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "k = 2, n = 8\nIndices:  1 2 3 4 5 6 7 8\nElements: 1 2 3 4 9 5 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8447",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read p\n    string p = inf.readLine();\n    ensuref(1 <= p.size() && p.size() <= 1000000, \"Length of p must be between 1 and 1e6 inclusive, but it's %zu\", p.size());\n    for (char c : p) {\n        int ascii_code = static_cast<unsigned char>(c);\n        ensuref(32 <= ascii_code && ascii_code <= 126, \"Character in p has ASCII code %d, which is out of range 32..126\", ascii_code);\n    }\n\n    // Read s\n    string s = inf.readLine();\n    ensuref(1 <= s.size() && s.size() <= 200, \"Length of s must be between 1 and 200 inclusive, but it's %zu\", s.size());\n    for (char c : s) {\n        int ascii_code = static_cast<unsigned char>(c);\n        ensuref(32 <= ascii_code && ascii_code <= 126, \"Character in s has ASCII code %d, which is out of range 32..126\", ascii_code);\n    }\n\n    // Read k\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read p\n    string p = inf.readLine();\n    ensuref(1 <= p.size() && p.size() <= 1000000, \"Length of p must be between 1 and 1e6 inclusive, but it's %zu\", p.size());\n    for (char c : p) {\n        int ascii_code = static_cast<unsigned char>(c);\n        ensuref(32 <= ascii_code && ascii_code <= 126, \"Character in p has ASCII code %d, which is out of range 32..126\", ascii_code);\n    }\n\n    // Read s\n    string s = inf.readLine();\n    ensuref(1 <= s.size() && s.size() <= 200, \"Length of s must be between 1 and 200 inclusive, but it's %zu\", s.size());\n    for (char c : s) {\n        int ascii_code = static_cast<unsigned char>(c);\n        ensuref(32 <= ascii_code && ascii_code <= 126, \"Character in s has ASCII code %d, which is out of range 32..126\", ascii_code);\n    }\n\n    // Read k\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read p\n    string p = inf.readLine();\n    ensuref(1 <= p.size() && p.size() <= 1000000, \"Length of p must be between 1 and 1e6 inclusive, but it's %zu\", p.size());\n    for (char c : p) {\n        int ascii_code = static_cast<unsigned char>(c);\n        ensuref(32 <= ascii_code && ascii_code <= 126, \"Character in p has ASCII code %d, which is out of range 32..126\", ascii_code);\n    }\n\n    // Read s\n    string s = inf.readLine();\n    ensuref(1 <= s.size() && s.size() <= 200, \"Length of s must be between 1 and 200 inclusive, but it's %zu\", s.size());\n    for (char c : s) {\n        int ascii_code = static_cast<unsigned char>(c);\n        ensuref(32 <= ascii_code && ascii_code <= 126, \"Character in s has ASCII code %d, which is out of range 32..126\", ascii_code);\n    }\n\n    // Read k\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10000);        // Length of p\n    int s_len = opt<int>(\"slen\", 100);   // Length of s\n    int k = opt<int>(\"k\", 1000);         // Length of q\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n, s_len, k are within the problem constraints\n    n = min(max(n, 1), 1000000);         // 1 ≤ n ≤ 1e6\n    s_len = min(max(s_len, 1), 200);     // 1 ≤ s_len ≤ 200\n    k = min(max(k, 1), 2000);            // 1 ≤ k ≤ 2000\n\n    string p, s;\n\n    if (type == \"random\") {\n        // Generate random p of length n\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 126);\n        }\n        // Generate random s of length s_len\n        for (int i = 0; i < s_len; i++) {\n            s += (char)rnd.next(32, 126);\n        }\n    } else if (type == \"same\") {\n        n = s_len; // Set p and s to have the same length\n        // Generate random p of length n\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 126);\n        }\n        s = p; // Set s equal to p\n    } else if (type == \"cannot_extract\") {\n        // Generate p of length n without a certain character\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 125); // Exclude character with ASCII code 126\n        }\n        // Generate s with a character not present in p\n        for (int i = 0; i < s_len; i++) {\n            s += (char)126; // Character with ASCII code 126\n        }\n    } else if (type == \"minimal_q\") {\n        // Generate p and s where 's' is a sequence of 'a's\n        p = string(n, 'a');\n        s = string(s_len, 'a');\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 126);\n        }\n        for (int i = 0; i < s_len; i++) {\n            s += (char)rnd.next(32, 126);\n        }\n    }\n\n    // Output p, s, and k according to the problem's input format\n    cout << p << endl;\n    cout << s << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10000);        // Length of p\n    int s_len = opt<int>(\"slen\", 100);   // Length of s\n    int k = opt<int>(\"k\", 1000);         // Length of q\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n, s_len, k are within the problem constraints\n    n = min(max(n, 1), 1000000);         // 1 ≤ n ≤ 1e6\n    s_len = min(max(s_len, 1), 200);     // 1 ≤ s_len ≤ 200\n    k = min(max(k, 1), 2000);            // 1 ≤ k ≤ 2000\n\n    string p, s;\n\n    if (type == \"random\") {\n        // Generate random p of length n\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 126);\n        }\n        // Generate random s of length s_len\n        for (int i = 0; i < s_len; i++) {\n            s += (char)rnd.next(32, 126);\n        }\n    } else if (type == \"same\") {\n        n = s_len; // Set p and s to have the same length\n        // Generate random p of length n\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 126);\n        }\n        s = p; // Set s equal to p\n    } else if (type == \"cannot_extract\") {\n        // Generate p of length n without a certain character\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 125); // Exclude character with ASCII code 126\n        }\n        // Generate s with a character not present in p\n        for (int i = 0; i < s_len; i++) {\n            s += (char)126; // Character with ASCII code 126\n        }\n    } else if (type == \"minimal_q\") {\n        // Generate p and s where 's' is a sequence of 'a's\n        p = string(n, 'a');\n        s = string(s_len, 'a');\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; i++) {\n            p += (char)rnd.next(32, 126);\n        }\n        for (int i = 0; i < s_len; i++) {\n            s += (char)rnd.next(32, 126);\n        }\n    }\n\n    // Output p, s, and k according to the problem's input format\n    cout << p << endl;\n    cout << s << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varied lengths\n./gen -n 1000 -slen 100 -k 50 -type random\n./gen -n 50000 -slen 150 -k 500 -type random\n./gen -n 100000 -slen 200 -k 1000 -type random\n./gen -n 1000000 -slen 100 -k 2000 -type random\n\n# Test cases where p and s are the same\n./gen -n 100 -slen 100 -k 1000 -type same\n./gen -n 200 -slen 200 -k 1 -type same\n./gen -n 200 -slen 200 -k 2000 -type same\n\n# Test cases where s cannot be extracted from p\n./gen -n 1000 -slen 50 -k 10 -type cannot_extract\n./gen -n 50000 -slen 100 -k 1000 -type cannot_extract\n./gen -n 100000 -slen 150 -k 2000 -type cannot_extract\n\n# Test cases to check minimal lexicographical key\n./gen -n 1000 -slen 10 -k 20 -type minimal_q\n./gen -n 100000 -slen 100 -k 500 -type minimal_q\n\n# Edge cases with minimal k\n./gen -n 1000 -slen 50 -k 1 -type random\n./gen -n 5000 -slen 100 -k 1 -type same\n\n# Edge cases with maximal k\n./gen -n 1000 -slen 50 -k 2000 -type random\n./gen -n 5000 -slen 200 -k 2000 -type same\n\n# Test cases with maximal p length\n./gen -n 1000000 -slen 100 -k 1000 -type random\n./gen -n 1000000 -slen 200 -k 2000 -type minimal_q\n\n# Test cases with maximal s length\n./gen -n 5000 -slen 200 -k 1000 -type random\n./gen -n 100000 -slen 200 -k 2000 -type minimal_q\n\n# Smallest possible p and s\n./gen -n 1 -slen 1 -k 1 -type random\n./gen -n 1 -slen 1 -k 2000 -type random\n\n# Additional random test cases\n./gen -n 6000 -slen 100 -k 500 -type random\n./gen -n 70000 -slen 150 -k 1200 -type random\n./gen -n 800000 -slen 200 -k 1500 -type random\n\n# Testing cases where s_len exceeds n (should not happen due to constraints)\n# Adjusted to ensure 1 ≤ s_len ≤ min(n, 200)\n./gen -n 1000 -slen 150 -k 1000 -type random\n\n# Test cases with minimal s_len\n./gen -n 1000 -slen 1 -k 500 -type random\n./gen -n 1000 -slen 1 -k 2000 -type same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:27.905930",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "333/A",
      "title": "A. Secrets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains a single integer n (1 ≤ n ≤ 1017).Please, do not use the %lld specifier to read or write 64 bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputIn a single line print an integer: the maximum number of coins the unlucky buyer could have paid with.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy4OutputCopy2",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains a single integer n (1 ≤ n ≤ 1017).Please, do not use the %lld specifier to read or write 64 bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputIn a single line print an integer: the maximum number of coins the unlucky buyer could have paid with.\n\nInputCopy1OutputCopy1InputCopy4OutputCopy2\n\nOutputCopy1\n\nOutputCopy2\n\nNoteIn the first test case, if a buyer has exactly one coin of at least 3 marks, then, to give Gerald one mark, he will have to give this coin. In this sample, the customer can not have a coin of one mark, as in this case, he will be able to give the money to Gerald without any change.In the second test case, if the buyer had exactly three coins of 3 marks, then, to give Gerald 4 marks, he will have to give two of these coins. The buyer cannot give three coins as he wants to minimize the number of coins that he gives.",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 333\\s*A"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    string rest = inf.readLine();\n    ensuref(rest.find_first_not_of(\" \\t\") == string::npos, \"Extra characters after n\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    string rest = inf.readLine();\n    ensuref(rest.find_first_not_of(\" \\t\") == string::npos, \"Extra characters after n\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    string rest = inf.readLine();\n    ensuref(rest.find_first_not_of(\" \\t\") == string::npos, \"Extra characters after n\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll min_n = opt<ll>(\"min_n\", 1);\n    ll max_n = opt<ll>(\"max_n\", 1e17);\n\n    ll n = 0;\n\n    if (type == \"small\") {\n        n = rnd.next(min_n, min(max_n, 100LL));\n    } else if (type == \"large\") {\n        n = rnd.next(max(min_n, (ll)1e17 - 1000), max_n);\n    } else if (type == \"power_of_3\") {\n        ll k = rnd.next(0, 38); // 3^38 is less than 1e17\n        n = 1;\n        for (int i = 0; i < k; ++i)\n            n *= 3;\n        if (n < min_n || n > max_n)\n            n = min_n; // adjust if out of bounds\n    } else if (type == \"close_to_power_of_3\") {\n        ll k = rnd.next(0, 38);\n        ll p = 1;\n        for (int i = 0; i < k; ++i)\n            p *= 3;\n        if (rnd.next(0,1)) {\n            n = p - rnd.next(1, 10);\n        } else {\n            n = p + rnd.next(1, 10);\n        }\n        n = max(n, min_n);\n        n = min(n, max_n);\n    } else if (type == \"sum_of_powers_of_3\") {\n        // Generate n as sum of random powers of 3\n        int num_terms = rnd.next(1, 20); // up to 20 terms\n        set<int> exps;\n        while (exps.size() < num_terms) {\n            exps.insert(rnd.next(0, 38));\n        }\n        n = 0;\n        for (int e : exps) {\n            ll term = 1;\n            for (int i = 0; i < e; ++i)\n                term *= 3;\n            n += term;\n        }\n        n = max(n, min_n);\n        n = min(n, max_n);\n    } else if (type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else {\n        // default to random\n        n = rnd.next(min_n, max_n);\n    }\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll min_n = opt<ll>(\"min_n\", 1);\n    ll max_n = opt<ll>(\"max_n\", 1e17);\n\n    ll n = 0;\n\n    if (type == \"small\") {\n        n = rnd.next(min_n, min(max_n, 100LL));\n    } else if (type == \"large\") {\n        n = rnd.next(max(min_n, (ll)1e17 - 1000), max_n);\n    } else if (type == \"power_of_3\") {\n        ll k = rnd.next(0, 38); // 3^38 is less than 1e17\n        n = 1;\n        for (int i = 0; i < k; ++i)\n            n *= 3;\n        if (n < min_n || n > max_n)\n            n = min_n; // adjust if out of bounds\n    } else if (type == \"close_to_power_of_3\") {\n        ll k = rnd.next(0, 38);\n        ll p = 1;\n        for (int i = 0; i < k; ++i)\n            p *= 3;\n        if (rnd.next(0,1)) {\n            n = p - rnd.next(1, 10);\n        } else {\n            n = p + rnd.next(1, 10);\n        }\n        n = max(n, min_n);\n        n = min(n, max_n);\n    } else if (type == \"sum_of_powers_of_3\") {\n        // Generate n as sum of random powers of 3\n        int num_terms = rnd.next(1, 20); // up to 20 terms\n        set<int> exps;\n        while (exps.size() < num_terms) {\n            exps.insert(rnd.next(0, 38));\n        }\n        n = 0;\n        for (int e : exps) {\n            ll term = 1;\n            for (int i = 0; i < e; ++i)\n                term *= 3;\n            n += term;\n        }\n        n = max(n, min_n);\n        n = min(n, max_n);\n    } else if (type == \"random\") {\n        n = rnd.next(min_n, max_n);\n    } else {\n        // default to random\n        n = rnd.next(min_n, max_n);\n    }\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -type small -min_n 1 -max_n 10\n./gen -type small -min_n 1 -max_n 100\n./gen -type small -min_n 1 -max_n 1000\n\n# Large n\n./gen -type large -min_n 99999999999999999 -max_n 100000000000000000\n./gen -type large -min_n 100000000000000000 -max_n 100000000000000000\n\n# Power of 3 n\n./gen -type power_of_3\n./gen -type power_of_3\n./gen -type power_of_3\n\n# Close to power of 3\n./gen -type close_to_power_of_3\n./gen -type close_to_power_of_3\n./gen -type close_to_power_of_3\n\n# Sum of powers of 3\n./gen -type sum_of_powers_of_3\n./gen -type sum_of_powers_of_3\n./gen -type sum_of_powers_of_3\n\n# Random n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Specific small n\n./gen -type random -min_n 1 -max_n 1\n./gen -type random -min_n 2 -max_n 2\n./gen -type random -min_n 3 -max_n 3\n./gen -type random -min_n 4 -max_n 4\n./gen -type random -min_n 5 -max_n 5\n./gen -type random -min_n 6 -max_n 6\n./gen -type random -min_n 7 -max_n 7\n./gen -type random -min_n 8 -max_n 8\n./gen -type random -min_n 9 -max_n 9\n./gen -type random -min_n 10 -max_n 10\n\n# Maximum n\n./gen -type random -min_n 100000000000000000 -max_n 100000000000000000\n\n# Larger n\n./gen -type random -min_n 10000000000000000 -max_n 100000000000000000\n\n# Random n with inexact sums\n./gen -type random -min_n 1000 -max_n 2000\n\n# Random n with specific value\n./gen -type random -min_n 1234567891011 -max_n 1234567891011\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:29.979354",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "333/B",
      "title": "B. Chips",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 1000, 0 ≤ m ≤ 105) — the size of the field and the number of banned cells. Next m lines each contain two space-separated integers. Specifically, the i-th of these lines contains numbers xi and yi (1 ≤ xi, yi ≤ n) — the coordinates of the i-th banned cell. All given cells are distinct.Consider the field rows numbered from top to bottom from 1 to n, and the columns — from left to right from 1 to n.",
      "output_spec": "OutputPrint a single integer — the maximum points Gerald can earn in this game.",
      "sample_tests": "ExamplesInputCopy3 12 2OutputCopy0InputCopy3 0OutputCopy1InputCopy4 33 13 23 3OutputCopy1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 1000, 0 ≤ m ≤ 105) — the size of the field and the number of banned cells. Next m lines each contain two space-separated integers. Specifically, the i-th of these lines contains numbers xi and yi (1 ≤ xi, yi ≤ n) — the coordinates of the i-th banned cell. All given cells are distinct.Consider the field rows numbered from top to bottom from 1 to n, and the columns — from left to right from 1 to n.\n\nOutputPrint a single integer — the maximum points Gerald can earn in this game.\n\nInputCopy3 12 2OutputCopy0InputCopy3 0OutputCopy1InputCopy4 33 13 23 3OutputCopy1\n\nInputCopy3 12 2\n\nOutputCopy0\n\nInputCopy3 0\n\nOutputCopy1\n\nInputCopy4 33 13 23 3\n\nOutputCopy1\n\nNoteIn the first test the answer equals zero as we can't put chips into the corner cells.In the second sample we can place one chip into either cell (1, 2), or cell (3, 2), or cell (2, 1), or cell (2, 3). We cannot place two chips.In the third sample we can only place one chip into either cell (2, 1), or cell (2, 4).",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 333\\s*B"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > cells;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> cell = make_pair(xi, yi);\n        ensuref(cells.count(cell) == 0, \"The given cells must be distinct, but cell (%d, %d) appears more than once\", xi, yi);\n        cells.insert(cell);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > cells;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> cell = make_pair(xi, yi);\n        ensuref(cells.count(cell) == 0, \"The given cells must be distinct, but cell (%d, %d) appears more than once\", xi, yi);\n        cells.insert(cell);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > cells;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> cell = make_pair(xi, yi);\n        ensuref(cells.count(cell) == 0, \"The given cells must be distinct, but cell (%d, %d) appears more than once\", xi, yi);\n        cells.insert(cell);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints check\n    ensure(2 <= n && n <= 1000);\n    ensure(0 <= m && m <= 100000);\n\n    set<pii> banned_cells;\n\n    if (type == \"min\") {\n        // n=2, m=0\n        n = 2;\n        m = 0;\n    } else if (type == \"max_size\") {\n        // n=1000\n        n = 1000;\n        // m can vary\n    } else if (type == \"max_banned\") {\n        // m=1e5 or n x n\n        m = min(100000, n*n);\n    } else if (type == \"full_ban\") {\n        // Ban as many cells as possible\n        m = min(n * n, 100000);\n        int total_cells = n * n;\n        // Add all cells up to m\n        for(int x=1; x<=n && (int)banned_cells.size() < m; x++) {\n            for(int y=1; y<=n && (int)banned_cells.size() < m; y++) {\n                banned_cells.insert({x, y});\n            }\n        }\n        m = banned_cells.size();\n    } else if (type == \"no_valid_start\") {\n        // Ban all non-corner border cells\n        for(int i=2; i<=n-1; i++) {\n            banned_cells.insert({1, i}); // Top edge\n            banned_cells.insert({n, i}); // Bottom edge\n            banned_cells.insert({i, 1}); // Left edge\n            banned_cells.insert({i, n}); // Right edge\n        }\n        m = banned_cells.size();\n    } else if (type == \"random\") {\n        // Random m banned cells\n        m = min(m, n*n);\n        // Generate random m banned cells\n    } else {\n        // default to random\n    }\n\n    // If banned_cells is not filled, fill it with random cells up to m\n    if ((int)banned_cells.size() < m) {\n        while((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x,y});\n        }\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output m cells\n    // Output the m banned cells in random order\n\n    vector<pii> banned(banned_cells.begin(), banned_cells.end());\n    shuffle(banned.begin(), banned.end());\n\n    for(int i=0; i < m; i++) {\n        printf(\"%d %d\\n\", banned[i].first, banned[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints check\n    ensure(2 <= n && n <= 1000);\n    ensure(0 <= m && m <= 100000);\n\n    set<pii> banned_cells;\n\n    if (type == \"min\") {\n        // n=2, m=0\n        n = 2;\n        m = 0;\n    } else if (type == \"max_size\") {\n        // n=1000\n        n = 1000;\n        // m can vary\n    } else if (type == \"max_banned\") {\n        // m=1e5 or n x n\n        m = min(100000, n*n);\n    } else if (type == \"full_ban\") {\n        // Ban as many cells as possible\n        m = min(n * n, 100000);\n        int total_cells = n * n;\n        // Add all cells up to m\n        for(int x=1; x<=n && (int)banned_cells.size() < m; x++) {\n            for(int y=1; y<=n && (int)banned_cells.size() < m; y++) {\n                banned_cells.insert({x, y});\n            }\n        }\n        m = banned_cells.size();\n    } else if (type == \"no_valid_start\") {\n        // Ban all non-corner border cells\n        for(int i=2; i<=n-1; i++) {\n            banned_cells.insert({1, i}); // Top edge\n            banned_cells.insert({n, i}); // Bottom edge\n            banned_cells.insert({i, 1}); // Left edge\n            banned_cells.insert({i, n}); // Right edge\n        }\n        m = banned_cells.size();\n    } else if (type == \"random\") {\n        // Random m banned cells\n        m = min(m, n*n);\n        // Generate random m banned cells\n    } else {\n        // default to random\n    }\n\n    // If banned_cells is not filled, fill it with random cells up to m\n    if ((int)banned_cells.size() < m) {\n        while((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x,y});\n        }\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output m cells\n    // Output the m banned cells in random order\n\n    vector<pii> banned(banned_cells.begin(), banned_cells.end());\n    shuffle(banned.begin(), banned.end());\n\n    for(int i=0; i < m; i++) {\n        printf(\"%d %d\\n\", banned[i].first, banned[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size grid, no banned cells\n./gen -n 2 -m 0 -type min\n\n# Small grid, small m, random banned cells\n./gen -n 5 -m 5 -type random\n\n# Small grid, maximum banned cells\n./gen -n 10 -m 100 -type max_banned\n\n# Maximum grid size, no banned cells\n./gen -n 1000 -m 0 -type max_size\n\n# Maximum grid size, maximum banned cells\n./gen -n 1000 -m 100000 -type max_banned\n\n# Random grid, m = 0\n./gen -n 500 -m 0 -type random\n\n# Random grid, medium m\n./gen -n 500 -m 10000 -type random\n\n# Random grid, m = n^2 / 2 (if possible)\n./gen -n 1000 -m 100000 -type random\n\n# Grid with no valid starting positions\n./gen -n 1000 -m 0 -type no_valid_start\n\n# Grid where all cells are banned\n./gen -n 316 -m 100000 -type full_ban\n\n# Small grid with all cells banned\n./gen -n 10 -m 100 -type full_ban\n\n# Random grid testing swapping possibility\n./gen -n 100 -m 0 -type random\n\n# Grid where path is blocked by banned cells\n./gen -n 100 -m 1000 -type random\n\n# Maximum size grid with full banned\n./gen -n 1000 -m 100000 -type full_ban\n\n# Random grids with varying sizes and m\n./gen -n 2 -m 1 -type random\n./gen -n 3 -m 2 -type random\n./gen -n 5 -m 10 -type random\n./gen -n 15 -m 100 -type random\n./gen -n 100 -m 5000 -type random\n./gen -n 200 -m 20000 -type random\n./gen -n 250 -m 60000 -type random\n./gen -n 300 -m 90000 -type random\n./gen -n 500 -m 100000 -type random\n./gen -n 600 -m 100000 -type max_banned\n\n# Edge cases: grids of size 2 with random banned cells\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 3 -type random\n\n# Edge cases: grids where starting positions are severely limited\n./gen -n 10 -m 36 -type no_valid_start\n\n# Edge case: grid with a single valid starting position\n./gen -n 10 -m 99 -type random\n\n# Edge case: grid where movement paths are blocked\n./gen -n 20 -m 200 -type random\n\n# Random grids with maximum possible banned cells\n./gen -n 500 -m 100000 -type max_banned\n./gen -n 700 -m 100000 -type max_banned\n./gen -n 800 -m 100000 -type max_banned\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:31.912620",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "333/C",
      "title": "C. Счастливые билеты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест6 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке находятся два целых числа k и m (0 ≤ k ≤ 104, 1 ≤ m ≤ 3·105).",
      "output_spec": "Выходные данныеВыведите m строк. В каждой строке должно быть ровно 8 цифр — номер очередного k-счастливого билета. Номера могут начинаться с 0, все номера должны быть различны. Если существует больше, чем m различных k-счастливых билетов, то выведите любые m из них. Гарантируется, что хотя бы m различных k-счастливых билетов существуют. Билеты можно выводить в любом порядке.",
      "sample_tests": "ПримерыВходные данныеСкопировать0 3Выходные данныеСкопировать000000000000000100000002Входные данныеСкопировать7 4Выходные данныеСкопировать00000007000000160000001700000018",
      "description": "C. Счастливые билеты\n\nограничение по времени на тест6 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке находятся два целых числа k и m (0 ≤ k ≤ 104, 1 ≤ m ≤ 3·105).\n\nВходные данные\n\nВыходные данныеВыведите m строк. В каждой строке должно быть ровно 8 цифр — номер очередного k-счастливого билета. Номера могут начинаться с 0, все номера должны быть различны. Если существует больше, чем m различных k-счастливых билетов, то выведите любые m из них. Гарантируется, что хотя бы m различных k-счастливых билетов существуют. Билеты можно выводить в любом порядке.\n\nВыходные данные\n\nВходные данныеСкопировать0 3Выходные данныеСкопировать000000000000000100000002Входные данныеСкопировать7 4Выходные данныеСкопировать00000007000000160000001700000018\n\nВходные данныеСкопировать0 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать000000000000000100000002\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать00000007000000160000001700000018\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Доброго всем времени суток!Приглашаю Вас поучаствовать в 194 раунде, автором которого я являюсь. Это мой четвёртый раунд, хотя предыдущие три были очень давно: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (прошу прощения у div-2 участников, что упоминаю только div-1 раунды, просто ссылка даже на один раунд уже чересчур громоздка).В этот раз, как в раунде Codeforces Beta Round 79 (Div. 1 Only), вы вновь поможете мальчику Геральду разобраться с его проблемами. На этот раз его проблемы настолько серьёзны, что он стал координатором контестов на Codeforces и помог мне сделать этот раунд, чтобы спихнуть их на вас.Хочу поблагодарить Gerald за то, что он очень хорошо выполняет работу координатора. Работая с ним, ощущаешь, что всё действительно под контролем. Кроме того, спасибо Марии Беловой за перевод условий на английский. Также спасибо Seyaua и Aksenov239 за тестирование задач.Этот раунд состоится в необычное время — 12:30 по Московскому времени.Разбалловка стандартная, 500 — 1000 — 1500 — 2000 — 2500.Всем спасибо за участие, добро пожаловать в разбор.Мои поздравления победителям: Дивизион 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteОтдельно хочу отметить сразу двух украинских участников, которым единственным покорились все пять задач!Дивизион 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Следуя многочисленным просьбам к авторам раундов, расскажу немного о себе. Меня зовут Валера Самойлов и мне 24 года. Gerald не смог сходу вспомнить более старшего автора Codeforces раунда =) Я закончил мат-мех СПбГУ пару лет назад (тем, кому это о чём-то скажет, ПОМИ-группа + кафедра алгебры, диплом по теории графов). Сейчас я работаю в области химической укладки графов и вместе с женой воспитываю годовалую дочку. Кроме того, последние 8 лет я учу детей математике (а в последний год ещё и программированию) в ЮМШ (Юношеской Математической Школе, это в Питере), которую я и закончил в своё время. Всё это объясняет, почему я так долго не делал раундов, хотя задач у меня придумано предостаточно. Тем не менее, летом, пока жена с дочкой на отдыхе, а учить некого, я улучил на это время и надеюсь, что вам не покажется, что я провёл его зря.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2379
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces",
          "content": "334A - Пакетики с конфетамиВ этой задаче требуется разделить все натуральные числа от 1 до n2 на n групп по n чисел в каждой так, чтобы суммы чисел во всех группах были одинаковыми.Давайте разобьем все эти числа на пары . Это можно сделать благодаря тому, что n четное, а значит, и n2 тоже. Сумма каждой из этих пар равна n2 + 1. Теперь осталось только определить по пар в каждую из групп.334B - Восьмиточечные наборыВ этой задаче требуется сделать лишь то, что сказано — определить, удовлетворяет ли данный набор из восьми точек описанному условию.Есть множество способов это сделать. Например, следующий: Проверить, что среди координат этих точек есть ровно три различных x и ровно три различных y. Найти количество различных x (так же, как и y) можно, положив их в set и узнав его размер. Если оно не равно 3, вывести <>. Итак, у нас есть x1, x2 и x3, а так же y1, y2 и y3. Осталось проверить, что для любой пары (xi, yj) (кроме (x2, y2)) данная точка присутствует среди восьми перечисленных. Можно просто перебрать все эти пары и для каждой пары, перебрав все восемь точек, выяснить, есть ли эта пара. Однако я думаю, что читать решение в данном случае — неблагодарная затея. Лучше просто посмотреть реализацию.334C - Секреты / 333A - СекретыНа самом деле, в задаче разыскивается самая длинная такая последовательность натуральных чисел a1, a2, ..., ak, такая, что каждое число в ней является степенью тройки, сумма всех чисел больше, чем n, и если выкинуть любое из чисел, то сумма станет меньше n. Если точнее, требуется лишь узнать длину этой последовательности.Рассмотрим минимальное ai = A. Поскольку все эти числя являются степенями 3, то все остальные ai делятся на A и, следовательно, сумма всех этих чисел S тоже делится на A. Если n также делится на A, то, так как S > n, то S превосходит n как минимум на A. Следовательно, если выкинуть из последовательности число A, то остаток будет не меньше, чем n, а это противоречит второму условию. Таким образом, мы выяснили, что n не делится ни на одно из чисел этого последовательности, даже на самое маленькое. Тогда найдем минимальное k такое, что — это легко сделать простым перебором. А дальше просто набрать минимальную сумму, превосходящую n монетами номинала 3k. Таким образом, ответом будет число .334D - Фишки / 333B - ФишкиВ этой задаче требовалось найти максимальное количество фишек, которые Геральд может поставить на поле.Сначала сделаем два замечания. На каждую линию (вертикаль или горизонталь) можно поставить только одну фишку, с одного конца или с другого. Если на линии есть хотя бы одна запрещенная клетка, то на нее нельзя поставить ни одной фишки. Соблюдая последнее замечание, мы избегнем попадания фишек на запрещенные клетки. Осталось избежать <<столкновения>> фишек.Рассмотрим следующие четыре линии: вертикали i и n + 1 - i и горизонтали с теми же номерами (i может быть любым, если только i ≠ n + 1 - i). Заметим, что фишки, поставленные на эти линии, могут столкнуться друг с другом, но не могут столкнуться с фишками на других линиях. Таким образом, для этих четырех линий можно решать задачу независимо от других линий. Осталось заметить, что мы можем поставить фишки на каждую из этих линий (на которой не стоит запрещенная клетка), так, чтобы они не столкнулись так, как это показано на картинке.Итого, можно просто перебрать эти четверки линий и для каждой из них выяснить, сколько фишек можно на них поставить. И не забыть рассмотреть случай двух средних линий в случае нечётного n.334E - Счастливые билеты / 333C - Счастливые билетыВ это задаче надо предъявить нужное количество счастливых билетов.Давайте рассмотрим, сколько разных чисел можно получить таким образом из четырёхзначных номеров. Их легко перебрать, благо их всего 104. Оказывается, что в среднем получается почти 60 чисел на каждый четырёхзначный номер. Пусть из номера n можно получить число x. Ясно, что k - x ≥ 0 либо x - k ≥ 0. Если, например, k - x ≥ 0, мы можем записать восьмизначный номер, в первых четырех цифрах которого будет записано k - x, а в последних четырех — n. Понятно, что такой билет будет k-счастливым. Всего это дает нам почти 600 000 билетов, этого вполне достаточно.333D - Характеристики прямоугольниковПо сути, в этой задаче надо найти, каким наибольшим может быть значение минимума из четырех клеток на пересечении двух столбцов и двух строк.Иными словами, надо найти максимальное значение величины min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) при всех i1, i2, j1, j2 таких, что 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Давайте применим бинарный поиск по ответу. Для этого надо научиться находить, есть ли в таблице из 0 и 1 два столбца и две строки, на всех четырех пересечениях которых стоят единицы, то есть, такие i1, i2, j1, j2, что ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Давайте рассмотрим все такие пары натуральных чисел (i1, i2), что существует натуральное число j такое, что ai1, j = ai2, j = 1. Наличие двух одинаковых таких пар как раз и означало бы наличие вышеописанных четырех чисел. Однако, всего может быть таких пар. Следовательно, мы можем завести массив, где будем отмечать, какие пары уже встретились и перебирать все пары в любом порядке, пока не встретится повторяющаяся пара или пока все пары не будут перебраны. Итого, получаем решение за время .333E - Летний заработокВ этой задаче требуется нарисовать три непересекающихся круга максимального радиуса с центрами в заданных точках. Иными словами, нам надо найти треугольник у которого минимальная из сторон будет максимальна.К сожалению, мы не ожидали решения с битовой оптимизацией, которое оказалось для участников проще нашего.Вспомним факт из школьного курса геометрии, говорящий, что напротив большего угла лежит большая сторона. Кроме того, вспомним, что сумма углов в треугольнике равна . Из этого следует, во-первых, что как минимум один угол в треугольнике не меньше . Во-вторых, что этот угол не может быть самым маленьким в треугольнике. И следовательно, что напротив этого угла лежит не самая маленькая сторона. Следовательно, если в , то min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).Следовательно, мы можем поступить следующим образом. Переберем вершину B и найдем треугольник с максимальной минимальной стороной среди таких, у которых . Для этого отсортируем все остальные вершины по углу относительно B, и для каждой вершины A найдем самую удалённую от B вершину C среди отрезка тех вершин, для которых . Для этого нам понадобится использовать дерево отрезков для максимума и два указателя или бинарный поиск, чтобы хранить левую и правую границу возможных вершин C при переборе вершины A. Итого, получаем решение за время .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 333\\s*C"
          },
          "content_length": 6606
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 3",
          "code": "2 4\n4 0 4 5\n4 0 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 4",
          "code": "2 4\n4 0 4 5\n4 0 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 5",
          "code": "518 -> 507\n386 -> 366\n22 -> 11\n254 -> 125\n75 -> 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 6",
          "code": "518 -> 507\n386 -> 366\n22 -> 11\n254 -> 125\n75 -> 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 7",
          "code": "val = min(a[i][k], a[j][k]);\nif (val < ans)\n          continue;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 8",
          "code": "val = min(a[i][k], a[j][k]);\nif (val < ans)\n          continue;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 9",
          "code": "else mx:=max(mx,x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 10",
          "code": "var i,n:longint;\n\nbegin\n  readln(n);\n  for i:=1 to sqr(n)div 2 do\n   writeln(i,' ',sqr(n)-i+1);\n\nend.",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 11",
          "code": "var i,n:longint;\n\nbegin\n  readln(n);\n  for i:=1 to sqr(n)div 2 do\n   writeln(i,' ',sqr(n)-i+1);\n\nend.",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 12",
          "code": "Test: #2, время: 0 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n4\nВывод\n1 16\n2 15\n3 14\n4 13\n5 12\n6 11\n7 10\n8 9\nОтвет\n1 16 2 15\n3 14 4 13\n5 12 6 11\n7 10 8 9\nПротокол тестирования\nok",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 13",
          "code": "Test: #2, время: 0 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n4\nВывод\n1 16\n2 15\n3 14\n4 13\n5 12\n6 11\n7 10\n8 9\nОтвет\n1 16 2 15\n3 14 4 13\n5 12 6 11\n7 10 8 9\nПротокол тестирования\nok",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int k = inf.readInt(0, 10000, \"k\");\n    int m = inf.readInt(1, 300000, \"m\");\n\n    vector<string> tickets;\n    for (int i = 0; i < m; ++i) {\n        if (ouf.eof())\n            quitf(_wa, \"expected %d tickets, but only %d lines found\", m, i);\n\n        string ticket = ouf.readLine();\n\n        if (ticket.size() != 8)\n            quitf(_wa, \"ticket %d has length %zu, expected 8\", i + 1, ticket.size());\n\n        for (size_t j = 0; j < 8; ++j) {\n            if (!isdigit(ticket[j]))\n                quitf(_wa, \"ticket %d contains non-digit character '%c'\", i + 1, ticket[j]);\n        }\n        tickets.push_back(ticket);\n    }\n\n    if (!ouf.seekEof())\n        quitf(_wa, \"extra output found after %d tickets\", m);\n\n    set<string> ticketSet(tickets.begin(), tickets.end());\n    if ((int)ticketSet.size() != m)\n        quitf(_wa, \"tickets are not distinct, expected %d distinct tickets, found %d\", m, (int)ticketSet.size());\n\n    quitf(_ok, \"All tickets are correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint randomKSmall() {\n    return rnd.next(0, 10);\n}\n\nint randomKLarge() {\n    return rnd.next(9000, 10000);\n}\n\nint randomMSmall() {\n    return rnd.next(1, 100);\n}\n\nint randomMLarge() {\n    return rnd.next(250000, 300000);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"custom\");\n\n    if (k == -1 || m == -1) {\n        if (type == \"min\") {\n            k = 0;\n            m = 1;\n        } else if (type == \"max\") {\n            k = 10000;\n            m = 300000;\n        } else if (type==\"small_k_small_m\") {\n            k = randomKSmall();\n            m = randomMSmall();\n        } else if (type==\"large_k_small_m\") {\n            k = randomKLarge();\n            m = randomMSmall();\n        } else if (type==\"small_k_large_m\") {\n            k = randomKSmall();\n            m = randomMLarge();\n        } else if (type==\"large_k_large_m\") {\n            k = randomKLarge();\n            m = randomMLarge();\n        } else {\n            // random\n            k = rnd.next(0, 10000);\n            m = rnd.next(1, 300000);\n        }\n    }\n\n    // Ensure constraints\n    ensure(0 <= k && k <= 10000);\n    ensure(1 <= m && m <= 300000);\n\n    printf(\"%d %d\\n\", k, m);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint randomKSmall() {\n    return rnd.next(0, 10);\n}\n\nint randomKLarge() {\n    return rnd.next(9000, 10000);\n}\n\nint randomMSmall() {\n    return rnd.next(1, 100);\n}\n\nint randomMLarge() {\n    return rnd.next(250000, 300000);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"custom\");\n\n    if (k == -1 || m == -1) {\n        if (type == \"min\") {\n            k = 0;\n            m = 1;\n        } else if (type == \"max\") {\n            k = 10000;\n            m = 300000;\n        } else if (type==\"small_k_small_m\") {\n            k = randomKSmall();\n            m = randomMSmall();\n        } else if (type==\"large_k_small_m\") {\n            k = randomKLarge();\n            m = randomMSmall();\n        } else if (type==\"small_k_large_m\") {\n            k = randomKSmall();\n            m = randomMLarge();\n        } else if (type==\"large_k_large_m\") {\n            k = randomKLarge();\n            m = randomMLarge();\n        } else {\n            // random\n            k = rnd.next(0, 10000);\n            m = rnd.next(1, 300000);\n        }\n    }\n\n    // Ensure constraints\n    ensure(0 <= k && k <= 10000);\n    ensure(1 <= m && m <= 300000);\n\n    printf(\"%d %d\\n\", k, m);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal k and m\n./gen -type min\n\n# Maximum k and m\n./gen -type max\n\n# k = 0, m = maximum\n./gen -k 0 -m 300000\n\n# k = maximum, m = minimum\n./gen -k 10000 -m 1\n\n# Small k and small m\n./gen -type small_k_small_m\n\n# Large k and small m\n./gen -type large_k_small_m\n\n# Small k and large m\n./gen -type small_k_large_m\n\n# Large k and large m\n./gen -type large_k_large_m\n\n# Random values\n./gen -type random\n\n# Edge cases\n./gen -k 0 -m 1\n./gen -k 10000 -m 300000\n\n# Examples from sample inputs\n./gen -k 0 -m 3\n./gen -k 7 -m 4\n\n# Random k = 0 with varying m\n./gen -k 0 -m 10000\n./gen -k 0 -m 200000\n\n# Random k = 10000 with varying m\n./gen -k 10000 -m 10000\n./gen -k 10000 -m 200000\n\n# Mid-range values\n./gen -k 5000 -m 150000\n./gen -k 2500 -m 75000\n./gen -k 7500 -m 225000\n\n# Custom random values\n./gen -k 1234 -m 56789\n./gen -k 9876 -m 54321\n\n# m = maximum\n./gen -k 1234 -m 300000\n./gen -k 9876 -m 300000\n\n# m = 1\n./gen -k 5000 -m 1\n\n# Additional custom test cases\n./gen -k 8888 -m 88888\n./gen -k 9999 -m 1\n./gen -k 1 -m 299999\n./gen -k 9999 -m 100\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:33.952287",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "333/D",
      "title": "D. Характеристики прямоугольников",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке даны через пробел два целых числа n и m (2 ≤ n, m ≤ 1000). В следующих n строках описана таблица. В i-той из этих строк перечислены через пробел целые числа ai, 1, ai, 2, ..., ai, m (0 ≤ ai, j ≤ 109) — m чисел стоящих в i-той строке таблицы.",
      "output_spec": "Выходные данныеВыведите единственное целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 21 23 4Выходные данныеСкопировать1Входные данныеСкопировать3 31 0 00 1 11 0 0Выходные данныеСкопировать0",
      "description": "D. Характеристики прямоугольников\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке даны через пробел два целых числа n и m (2 ≤ n, m ≤ 1000). В следующих n строках описана таблица. В i-той из этих строк перечислены через пробел целые числа ai, 1, ai, 2, ..., ai, m (0 ≤ ai, j ≤ 109) — m чисел стоящих в i-той строке таблицы.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать2 21 23 4Выходные данныеСкопировать1Входные данныеСкопировать3 31 0 00 1 11 0 0Выходные данныеСкопировать0\n\nВходные данныеСкопировать2 21 23 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 0 00 1 11 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере Геральд ничего не может поделать со своим недовольством — в таблице всего две строки и два столбца.Во втором тестовом примере, как бы Геральд не обрезал таблицу, все равно хотя бы в одном из углов будет 0.",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Доброго всем времени суток!Приглашаю Вас поучаствовать в 194 раунде, автором которого я являюсь. Это мой четвёртый раунд, хотя предыдущие три были очень давно: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (прошу прощения у div-2 участников, что упоминаю только div-1 раунды, просто ссылка даже на один раунд уже чересчур громоздка).В этот раз, как в раунде Codeforces Beta Round 79 (Div. 1 Only), вы вновь поможете мальчику Геральду разобраться с его проблемами. На этот раз его проблемы настолько серьёзны, что он стал координатором контестов на Codeforces и помог мне сделать этот раунд, чтобы спихнуть их на вас.Хочу поблагодарить Gerald за то, что он очень хорошо выполняет работу координатора. Работая с ним, ощущаешь, что всё действительно под контролем. Кроме того, спасибо Марии Беловой за перевод условий на английский. Также спасибо Seyaua и Aksenov239 за тестирование задач.Этот раунд состоится в необычное время — 12:30 по Московскому времени.Разбалловка стандартная, 500 — 1000 — 1500 — 2000 — 2500.Всем спасибо за участие, добро пожаловать в разбор.Мои поздравления победителям: Дивизион 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteОтдельно хочу отметить сразу двух украинских участников, которым единственным покорились все пять задач!Дивизион 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Следуя многочисленным просьбам к авторам раундов, расскажу немного о себе. Меня зовут Валера Самойлов и мне 24 года. Gerald не смог сходу вспомнить более старшего автора Codeforces раунда =) Я закончил мат-мех СПбГУ пару лет назад (тем, кому это о чём-то скажет, ПОМИ-группа + кафедра алгебры, диплом по теории графов). Сейчас я работаю в области химической укладки графов и вместе с женой воспитываю годовалую дочку. Кроме того, последние 8 лет я учу детей математике (а в последний год ещё и программированию) в ЮМШ (Юношеской Математической Школе, это в Питере), которую я и закончил в своё время. Всё это объясняет, почему я так долго не делал раундов, хотя задач у меня придумано предостаточно. Тем не менее, летом, пока жена с дочкой на отдыхе, а учить некого, я улучил на это время и надеюсь, что вам не покажется, что я провёл его зря.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2379
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces",
          "content": "334A - Пакетики с конфетамиВ этой задаче требуется разделить все натуральные числа от 1 до n2 на n групп по n чисел в каждой так, чтобы суммы чисел во всех группах были одинаковыми.Давайте разобьем все эти числа на пары . Это можно сделать благодаря тому, что n четное, а значит, и n2 тоже. Сумма каждой из этих пар равна n2 + 1. Теперь осталось только определить по пар в каждую из групп.334B - Восьмиточечные наборыВ этой задаче требуется сделать лишь то, что сказано — определить, удовлетворяет ли данный набор из восьми точек описанному условию.Есть множество способов это сделать. Например, следующий: Проверить, что среди координат этих точек есть ровно три различных x и ровно три различных y. Найти количество различных x (так же, как и y) можно, положив их в set и узнав его размер. Если оно не равно 3, вывести <>. Итак, у нас есть x1, x2 и x3, а так же y1, y2 и y3. Осталось проверить, что для любой пары (xi, yj) (кроме (x2, y2)) данная точка присутствует среди восьми перечисленных. Можно просто перебрать все эти пары и для каждой пары, перебрав все восемь точек, выяснить, есть ли эта пара. Однако я думаю, что читать решение в данном случае — неблагодарная затея. Лучше просто посмотреть реализацию.334C - Секреты / 333A - СекретыНа самом деле, в задаче разыскивается самая длинная такая последовательность натуральных чисел a1, a2, ..., ak, такая, что каждое число в ней является степенью тройки, сумма всех чисел больше, чем n, и если выкинуть любое из чисел, то сумма станет меньше n. Если точнее, требуется лишь узнать длину этой последовательности.Рассмотрим минимальное ai = A. Поскольку все эти числя являются степенями 3, то все остальные ai делятся на A и, следовательно, сумма всех этих чисел S тоже делится на A. Если n также делится на A, то, так как S > n, то S превосходит n как минимум на A. Следовательно, если выкинуть из последовательности число A, то остаток будет не меньше, чем n, а это противоречит второму условию. Таким образом, мы выяснили, что n не делится ни на одно из чисел этого последовательности, даже на самое маленькое. Тогда найдем минимальное k такое, что — это легко сделать простым перебором. А дальше просто набрать минимальную сумму, превосходящую n монетами номинала 3k. Таким образом, ответом будет число .334D - Фишки / 333B - ФишкиВ этой задаче требовалось найти максимальное количество фишек, которые Геральд может поставить на поле.Сначала сделаем два замечания. На каждую линию (вертикаль или горизонталь) можно поставить только одну фишку, с одного конца или с другого. Если на линии есть хотя бы одна запрещенная клетка, то на нее нельзя поставить ни одной фишки. Соблюдая последнее замечание, мы избегнем попадания фишек на запрещенные клетки. Осталось избежать <<столкновения>> фишек.Рассмотрим следующие четыре линии: вертикали i и n + 1 - i и горизонтали с теми же номерами (i может быть любым, если только i ≠ n + 1 - i). Заметим, что фишки, поставленные на эти линии, могут столкнуться друг с другом, но не могут столкнуться с фишками на других линиях. Таким образом, для этих четырех линий можно решать задачу независимо от других линий. Осталось заметить, что мы можем поставить фишки на каждую из этих линий (на которой не стоит запрещенная клетка), так, чтобы они не столкнулись так, как это показано на картинке.Итого, можно просто перебрать эти четверки линий и для каждой из них выяснить, сколько фишек можно на них поставить. И не забыть рассмотреть случай двух средних линий в случае нечётного n.334E - Счастливые билеты / 333C - Счастливые билетыВ это задаче надо предъявить нужное количество счастливых билетов.Давайте рассмотрим, сколько разных чисел можно получить таким образом из четырёхзначных номеров. Их легко перебрать, благо их всего 104. Оказывается, что в среднем получается почти 60 чисел на каждый четырёхзначный номер. Пусть из номера n можно получить число x. Ясно, что k - x ≥ 0 либо x - k ≥ 0. Если, например, k - x ≥ 0, мы можем записать восьмизначный номер, в первых четырех цифрах которого будет записано k - x, а в последних четырех — n. Понятно, что такой билет будет k-счастливым. Всего это дает нам почти 600 000 билетов, этого вполне достаточно.333D - Характеристики прямоугольниковПо сути, в этой задаче надо найти, каким наибольшим может быть значение минимума из четырех клеток на пересечении двух столбцов и двух строк.Иными словами, надо найти максимальное значение величины min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) при всех i1, i2, j1, j2 таких, что 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Давайте применим бинарный поиск по ответу. Для этого надо научиться находить, есть ли в таблице из 0 и 1 два столбца и две строки, на всех четырех пересечениях которых стоят единицы, то есть, такие i1, i2, j1, j2, что ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Давайте рассмотрим все такие пары натуральных чисел (i1, i2), что существует натуральное число j такое, что ai1, j = ai2, j = 1. Наличие двух одинаковых таких пар как раз и означало бы наличие вышеописанных четырех чисел. Однако, всего может быть таких пар. Следовательно, мы можем завести массив, где будем отмечать, какие пары уже встретились и перебирать все пары в любом порядке, пока не встретится повторяющаяся пара или пока все пары не будут перебраны. Итого, получаем решение за время .333E - Летний заработокВ этой задаче требуется нарисовать три непересекающихся круга максимального радиуса с центрами в заданных точках. Иными словами, нам надо найти треугольник у которого минимальная из сторон будет максимальна.К сожалению, мы не ожидали решения с битовой оптимизацией, которое оказалось для участников проще нашего.Вспомним факт из школьного курса геометрии, говорящий, что напротив большего угла лежит большая сторона. Кроме того, вспомним, что сумма углов в треугольнике равна . Из этого следует, во-первых, что как минимум один угол в треугольнике не меньше . Во-вторых, что этот угол не может быть самым маленьким в треугольнике. И следовательно, что напротив этого угла лежит не самая маленькая сторона. Следовательно, если в , то min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).Следовательно, мы можем поступить следующим образом. Переберем вершину B и найдем треугольник с максимальной минимальной стороной среди таких, у которых . Для этого отсортируем все остальные вершины по углу относительно B, и для каждой вершины A найдем самую удалённую от B вершину C среди отрезка тех вершин, для которых . Для этого нам понадобится использовать дерево отрезков для максимума и два указателя или бинарный поиск, чтобы хранить левую и правую границу возможных вершин C при переборе вершины A. Итого, получаем решение за время .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 333\\s*D"
          },
          "content_length": 6606
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 3",
          "code": "2 4\n4 0 4 5\n4 0 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 4",
          "code": "2 4\n4 0 4 5\n4 0 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 5",
          "code": "518 -> 507\n386 -> 366\n22 -> 11\n254 -> 125\n75 -> 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 6",
          "code": "518 -> 507\n386 -> 366\n22 -> 11\n254 -> 125\n75 -> 31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 7",
          "code": "val = min(a[i][k], a[j][k]);\nif (val < ans)\n          continue;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 8",
          "code": "val = min(a[i][k], a[j][k]);\nif (val < ans)\n          continue;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 9",
          "code": "else mx:=max(mx,x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 10",
          "code": "var i,n:longint;\n\nbegin\n  readln(n);\n  for i:=1 to sqr(n)div 2 do\n   writeln(i,' ',sqr(n)-i+1);\n\nend.",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 11",
          "code": "var i,n:longint;\n\nbegin\n  readln(n);\n  for i:=1 to sqr(n)div 2 do\n   writeln(i,' ',sqr(n)-i+1);\n\nend.",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 12",
          "code": "Test: #2, время: 0 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n4\nВывод\n1 16\n2 15\n3 14\n4 13\n5 12\n6 11\n7 10\n8 9\nОтвет\n1 16 2 15\n3 14 4 13\n5 12 6 11\n7 10 8 9\nПротокол тестирования\nok",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 13",
          "code": "Test: #2, время: 0 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n4\nВывод\n1 16\n2 15\n3 14\n4 13\n5 12\n6 11\n7 10\n8 9\nОтвет\n1 16 2 15\n3 14 4 13\n5 12 6 11\n7 10 8 9\nПротокол тестирования\nok",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Разбор задач - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"t\", \"random\");\n\n    vector<vector<int> > a(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random values in [0, 1e9]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9));\n            }\n        }\n    } else if (type == \"max_corner\") {\n        // Fill all elements with random values in [0, 1e9 - 1]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9 - 1));\n            }\n        }\n        // Set corners to 1e9\n        a[0][0] = int(1e9);\n        a[0][m-1] = int(1e9);\n        a[n-1][0] = int(1e9);\n        a[n-1][m-1] = int(1e9);\n    } else if (type == \"min_corner\") {\n        // Fill all elements with random values in [1, 1e9]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(1, int(1e9));\n            }\n        }\n        // Set corners to 0\n        a[0][0] = 0;\n        a[0][m-1] = 0;\n        a[n-1][0] = 0;\n        a[n-1][m-1] = 0;\n    } else if (type == \"uniform\") {\n        int val = opt<int>(\"val\", 0);\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = val;\n            }\n        }\n    } else if (type == \"border_max\") {\n        // Fill with random values in [0, 1e9 - 1]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9 - 1));\n            }\n        }\n        // Set borders to 1e9\n        for(int i = 0; i < n; ++i){\n            a[i][0] = int(1e9);\n            a[i][m-1] = int(1e9);\n        }\n        for(int j = 0; j < m; ++j){\n            a[0][j] = int(1e9);\n            a[n-1][j] = int(1e9);\n        }\n    } else if (type == \"inner_max\") {\n        // Fill with zeros\n        for(int i = 0; i < n; ++i){\n            fill(a[i].begin(), a[i].end(), 0);\n        }\n        // Define inner rectangle with higher values\n        int del_rows = n >= 4 ? n / 4 : 0;\n        int del_cols = m >= 4 ? m / 4 : 0;\n        int r1 = del_rows;\n        int r2 = n - del_rows - 1;\n        int c1 = del_cols;\n        int c2 = m - del_cols - 1;\n        for(int i = r1; i <= r2; ++i){\n            for(int j = c1; j <= c2; ++j){\n                a[i][j] = int(1e9);\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9));\n            }\n        }\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n    // Output the table\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < m; ++j){\n            printf(\"%d\", a[i][j]);\n            if(j + 1 != m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"t\", \"random\");\n\n    vector<vector<int> > a(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random values in [0, 1e9]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9));\n            }\n        }\n    } else if (type == \"max_corner\") {\n        // Fill all elements with random values in [0, 1e9 - 1]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9 - 1));\n            }\n        }\n        // Set corners to 1e9\n        a[0][0] = int(1e9);\n        a[0][m-1] = int(1e9);\n        a[n-1][0] = int(1e9);\n        a[n-1][m-1] = int(1e9);\n    } else if (type == \"min_corner\") {\n        // Fill all elements with random values in [1, 1e9]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(1, int(1e9));\n            }\n        }\n        // Set corners to 0\n        a[0][0] = 0;\n        a[0][m-1] = 0;\n        a[n-1][0] = 0;\n        a[n-1][m-1] = 0;\n    } else if (type == \"uniform\") {\n        int val = opt<int>(\"val\", 0);\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = val;\n            }\n        }\n    } else if (type == \"border_max\") {\n        // Fill with random values in [0, 1e9 - 1]\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9 - 1));\n            }\n        }\n        // Set borders to 1e9\n        for(int i = 0; i < n; ++i){\n            a[i][0] = int(1e9);\n            a[i][m-1] = int(1e9);\n        }\n        for(int j = 0; j < m; ++j){\n            a[0][j] = int(1e9);\n            a[n-1][j] = int(1e9);\n        }\n    } else if (type == \"inner_max\") {\n        // Fill with zeros\n        for(int i = 0; i < n; ++i){\n            fill(a[i].begin(), a[i].end(), 0);\n        }\n        // Define inner rectangle with higher values\n        int del_rows = n >= 4 ? n / 4 : 0;\n        int del_cols = m >= 4 ? m / 4 : 0;\n        int r1 = del_rows;\n        int r2 = n - del_rows - 1;\n        int c1 = del_cols;\n        int c2 = m - del_cols - 1;\n        for(int i = r1; i <= r2; ++i){\n            for(int j = c1; j <= c2; ++j){\n                a[i][j] = int(1e9);\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                a[i][j] = rnd.next(0, int(1e9));\n            }\n        }\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n    // Output the table\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < m; ++j){\n            printf(\"%d\", a[i][j]);\n            if(j + 1 != m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -t random\n./gen -n 2 -m 2 -t max_corner\n./gen -n 2 -m 2 -t min_corner\n./gen -n 2 -m 2 -t uniform -val 0\n\n./gen -n 10 -m 10 -t random\n./gen -n 10 -m 10 -t max_corner\n./gen -n 10 -m 10 -t min_corner\n./gen -n 10 -m 10 -t uniform -val 100\n./gen -n 10 -m 10 -t border_max\n./gen -n 10 -m 10 -t inner_max\n\n./gen -n 100 -m 100 -t random\n./gen -n 100 -m 100 -t max_corner\n./gen -n 100 -m 100 -t min_corner\n./gen -n 100 -m 100 -t uniform -val 1000000000\n./gen -n 100 -m 100 -t border_max\n./gen -n 100 -m 100 -t inner_max\n\n./gen -n 500 -m 500 -t random\n./gen -n 500 -m 500 -t max_corner\n./gen -n 500 -m 500 -t min_corner\n./gen -n 500 -m 500 -t border_max\n./gen -n 500 -m 500 -t inner_max\n\n./gen -n 1000 -m 1000 -t random\n./gen -n 1000 -m 1000 -t max_corner\n./gen -n 1000 -m 1000 -t min_corner\n./gen -n 1000 -m 1000 -t border_max\n./gen -n 1000 -m 1000 -t inner_max\n\n./gen -n 2 -m 1000 -t random\n./gen -n 1000 -m 2 -t random\n./gen -n 2 -m 1000 -t max_corner\n./gen -n 1000 -m 2 -t max_corner\n\n./gen -n 2 -m 1000 -t inner_max\n./gen -n 1000 -m 2 -t inner_max\n\n./gen -n 999 -m 1000 -t random\n./gen -n 1000 -m 999 -t random\n\n./gen -n 1000 -m 1000 -t uniform -val 0\n./gen -n 1000 -m 1000 -t uniform -val 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:35.942717",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "333/E",
      "title": "E. Summer Earnings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test9 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the number of centers (3 ≤ n ≤ 3000). The following n lines each contain two integers xi, yi ( - 104 ≤ xi, yi ≤ 104) — the coordinates of potential circle centers, provided by the Company.All given points are distinct.",
      "output_spec": "OutputPrint a single real number — maximum possible radius of circles. The answer will be accepted if its relative or absolute error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy30 11 01 1OutputCopy0.50000000000000000000InputCopy72 -3-2 -33 0-3 -11 -22 -2-1 0OutputCopy1.58113883008418980000",
      "description": "E. Summer Earnings\n\ntime limit per test9 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n — the number of centers (3 ≤ n ≤ 3000). The following n lines each contain two integers xi, yi ( - 104 ≤ xi, yi ≤ 104) — the coordinates of potential circle centers, provided by the Company.All given points are distinct.\n\nOutputPrint a single real number — maximum possible radius of circles. The answer will be accepted if its relative or absolute error doesn't exceed 10 - 6.\n\nInputCopy30 11 01 1OutputCopy0.50000000000000000000InputCopy72 -3-2 -33 0-3 -11 -22 -2-1 0OutputCopy1.58113883008418980000\n\nInputCopy30 11 01 1\n\nOutputCopy0.50000000000000000000\n\nInputCopy72 -3-2 -33 0-3 -11 -22 -2-1 0\n\nOutputCopy1.58113883008418980000",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 333\\s*E"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int> > points;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) occurs more than once\", x, y);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int> > points;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) occurs more than once\", x, y);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int> > points;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) occurs more than once\", x, y);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -10000;\nconst int MAX_COORD = 10000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        /* Generate n random distinct points within the coordinate bounds */\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            int y = rnd.next(MIN_COORD, MAX_COORD);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"cluster\") {\n        /* Generate points clustered around a point */\n        int cx = rnd.next(MIN_COORD + 1000, MAX_COORD - 1000);\n        int cy = rnd.next(MIN_COORD + 1000, MAX_COORD - 1000);\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(cx - 500, cx + 500);\n            int y = rnd.next(cy - 500, cy + 500);\n            if (x < MIN_COORD || x > MAX_COORD || y < MIN_COORD || y > MAX_COORD) continue;\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"line\") {\n        /* Generate points along a line */\n        int x0 = rnd.next(MIN_COORD + n, MAX_COORD - n);\n        int y = rnd.next(MIN_COORD, MAX_COORD);\n        for (int i = 0; i < n; ++i) {\n            int x = x0 + i - n / 2;\n            points.push_back({x, y});\n        }\n    } else if (type == \"grid\") {\n        /* Generate points in a grid pattern */\n        int s = (int)sqrt(n);\n        if (s * s < n) ++s;\n        int x_start = rnd.next(MIN_COORD + s, MAX_COORD - s);\n        int y_start = rnd.next(MIN_COORD + s, MAX_COORD - s);\n        for (int i = 0; i < s && (int)points.size() < n; ++i) {\n            for (int j = 0; j < s && (int)points.size() < n; ++j) {\n                int x = x_start + i - s / 2;\n                int y = y_start + j - s / 2;\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"circle\") {\n        /* Generate points along a circle */\n        int cx = rnd.next(MIN_COORD + 5000, MAX_COORD - 5000);\n        int cy = rnd.next(MIN_COORD + 5000, MAX_COORD - 5000);\n        int r = rnd.next(1000, 5000);\n        double angle_step = 2 * M_PI / n;\n        set<pair<int, int>> point_set;\n        for (int i = 0; (int)point_set.size() < n && i < 2 * n; ++i) {\n            double angle = angle_step * i;\n            int x = cx + int(r * cos(angle) + 0.5);\n            int y = cy + int(r * sin(angle) + 0.5);\n            if (x < MIN_COORD || x > MAX_COORD || y < MIN_COORD || y > MAX_COORD) continue;\n            point_set.insert({x, y});\n        }\n        if ((int)point_set.size() < n) {\n            // If not enough unique points, fill with random points\n            while ((int)point_set.size() < n) {\n                int x = rnd.next(MIN_COORD, MAX_COORD);\n                int y = rnd.next(MIN_COORD, MAX_COORD);\n                point_set.insert({x, y});\n            }\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"maxmin\") {\n        /* Generate points at extreme coordinates */\n        int coords[] = {MIN_COORD, MAX_COORD};\n        for (int x : coords) {\n            for (int y : coords) {\n                points.push_back({x, y});\n            }\n        }\n        if (n > 4) {\n            int per_edge = (n - 4) / 4 + 1;\n            for (int i = 0; i < per_edge; ++i) {\n                int x = MIN_COORD + i * (MAX_COORD - MIN_COORD) / per_edge;\n                points.push_back({x, MIN_COORD});\n                points.push_back({x, MAX_COORD});\n                points.push_back({MIN_COORD, x});\n                points.push_back({MAX_COORD, x});\n            }\n        }\n        // Trim to n points\n        if ((int)points.size() > n) points.resize(n);\n    } else if (type == \"regular_polygon\") {\n        /* Generate points forming a regular polygon */\n        int cx = rnd.next(-5000, 5000);\n        int cy = rnd.next(-5000, 5000);\n        int r = 9000;  // Adjust radius to fit within coordinate bounds\n        double angle_step = 2 * M_PI / n;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = angle_step * i;\n            int x = cx + int(r * cos(angle) + 0.5);\n            int y = cy + int(r * sin(angle) + 0.5);\n            if (x < MIN_COORD || x > MAX_COORD || y < MIN_COORD || y > MAX_COORD) continue;\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n        // If we didn't get enough unique points, fill with random points\n        while ((int)points.size() < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            int y = rnd.next(MIN_COORD, MAX_COORD);\n            points.push_back({x, y});\n        }\n    } else {\n        /* Handle unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Shuffle the points */\n    shuffle(points.begin(), points.end());\n\n    /* Ensure we have exactly n points */\n    if ((int)points.size() > n) points.resize(n);\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the points */\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -10000;\nconst int MAX_COORD = 10000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        /* Generate n random distinct points within the coordinate bounds */\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            int y = rnd.next(MIN_COORD, MAX_COORD);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"cluster\") {\n        /* Generate points clustered around a point */\n        int cx = rnd.next(MIN_COORD + 1000, MAX_COORD - 1000);\n        int cy = rnd.next(MIN_COORD + 1000, MAX_COORD - 1000);\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(cx - 500, cx + 500);\n            int y = rnd.next(cy - 500, cy + 500);\n            if (x < MIN_COORD || x > MAX_COORD || y < MIN_COORD || y > MAX_COORD) continue;\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"line\") {\n        /* Generate points along a line */\n        int x0 = rnd.next(MIN_COORD + n, MAX_COORD - n);\n        int y = rnd.next(MIN_COORD, MAX_COORD);\n        for (int i = 0; i < n; ++i) {\n            int x = x0 + i - n / 2;\n            points.push_back({x, y});\n        }\n    } else if (type == \"grid\") {\n        /* Generate points in a grid pattern */\n        int s = (int)sqrt(n);\n        if (s * s < n) ++s;\n        int x_start = rnd.next(MIN_COORD + s, MAX_COORD - s);\n        int y_start = rnd.next(MIN_COORD + s, MAX_COORD - s);\n        for (int i = 0; i < s && (int)points.size() < n; ++i) {\n            for (int j = 0; j < s && (int)points.size() < n; ++j) {\n                int x = x_start + i - s / 2;\n                int y = y_start + j - s / 2;\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"circle\") {\n        /* Generate points along a circle */\n        int cx = rnd.next(MIN_COORD + 5000, MAX_COORD - 5000);\n        int cy = rnd.next(MIN_COORD + 5000, MAX_COORD - 5000);\n        int r = rnd.next(1000, 5000);\n        double angle_step = 2 * M_PI / n;\n        set<pair<int, int>> point_set;\n        for (int i = 0; (int)point_set.size() < n && i < 2 * n; ++i) {\n            double angle = angle_step * i;\n            int x = cx + int(r * cos(angle) + 0.5);\n            int y = cy + int(r * sin(angle) + 0.5);\n            if (x < MIN_COORD || x > MAX_COORD || y < MIN_COORD || y > MAX_COORD) continue;\n            point_set.insert({x, y});\n        }\n        if ((int)point_set.size() < n) {\n            // If not enough unique points, fill with random points\n            while ((int)point_set.size() < n) {\n                int x = rnd.next(MIN_COORD, MAX_COORD);\n                int y = rnd.next(MIN_COORD, MAX_COORD);\n                point_set.insert({x, y});\n            }\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"maxmin\") {\n        /* Generate points at extreme coordinates */\n        int coords[] = {MIN_COORD, MAX_COORD};\n        for (int x : coords) {\n            for (int y : coords) {\n                points.push_back({x, y});\n            }\n        }\n        if (n > 4) {\n            int per_edge = (n - 4) / 4 + 1;\n            for (int i = 0; i < per_edge; ++i) {\n                int x = MIN_COORD + i * (MAX_COORD - MIN_COORD) / per_edge;\n                points.push_back({x, MIN_COORD});\n                points.push_back({x, MAX_COORD});\n                points.push_back({MIN_COORD, x});\n                points.push_back({MAX_COORD, x});\n            }\n        }\n        // Trim to n points\n        if ((int)points.size() > n) points.resize(n);\n    } else if (type == \"regular_polygon\") {\n        /* Generate points forming a regular polygon */\n        int cx = rnd.next(-5000, 5000);\n        int cy = rnd.next(-5000, 5000);\n        int r = 9000;  // Adjust radius to fit within coordinate bounds\n        double angle_step = 2 * M_PI / n;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = angle_step * i;\n            int x = cx + int(r * cos(angle) + 0.5);\n            int y = cy + int(r * sin(angle) + 0.5);\n            if (x < MIN_COORD || x > MAX_COORD || y < MIN_COORD || y > MAX_COORD) continue;\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n        // If we didn't get enough unique points, fill with random points\n        while ((int)points.size() < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            int y = rnd.next(MIN_COORD, MAX_COORD);\n            points.push_back({x, y});\n        }\n    } else {\n        /* Handle unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Shuffle the points */\n    shuffle(points.begin(), points.end());\n\n    /* Ensure we have exactly n points */\n    if ((int)points.size() > n) points.resize(n);\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the points */\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type cluster\n./gen -n 3 -type line\n./gen -n 3 -type grid\n./gen -n 3 -type circle\n./gen -n 3 -type maxmin\n./gen -n 3 -type regular_polygon\n\n./gen -n 10 -type random\n./gen -n 10 -type cluster\n./gen -n 10 -type line\n./gen -n 10 -type grid\n./gen -n 10 -type circle\n./gen -n 10 -type maxmin\n./gen -n 10 -type regular_polygon\n\n./gen -n 100 -type random\n./gen -n 100 -type cluster\n./gen -n 100 -type line\n./gen -n 100 -type grid\n./gen -n 100 -type circle\n./gen -n 100 -type maxmin\n./gen -n 100 -type regular_polygon\n\n./gen -n 1000 -type random\n./gen -n 1000 -type cluster\n./gen -n 1000 -type line\n./gen -n 1000 -type grid\n./gen -n 1000 -type circle\n./gen -n 1000 -type maxmin\n./gen -n 1000 -type regular_polygon\n\n./gen -n 3000 -type random\n./gen -n 3000 -type cluster\n./gen -n 3000 -type line\n./gen -n 3000 -type grid\n./gen -n 3000 -type circle\n./gen -n 3000 -type maxmin\n./gen -n 3000 -type regular_polygon\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:38.205377",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "334/A",
      "title": "A. Candy Bags",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains a single integer n (n is even, 2 ≤ n ≤ 100) — the number of Gerald's brothers.",
      "output_spec": "OutputLet's assume that Gerald indexes his brothers with numbers from 1 to n. You need to print n lines, on the i-th line print n integers — the numbers of candies in the bags for the i-th brother. Naturally, all these numbers should be distinct and be within limits from 1 to n2. You can print the numbers in the lines in any order. It is guaranteed that the solution exists at the given limits.",
      "sample_tests": "ExamplesInputCopy2OutputCopy1 42 3",
      "description": "A. Candy Bags\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains a single integer n (n is even, 2 ≤ n ≤ 100) — the number of Gerald's brothers.\n\nOutputLet's assume that Gerald indexes his brothers with numbers from 1 to n. You need to print n lines, on the i-th line print n integers — the numbers of candies in the bags for the i-th brother. Naturally, all these numbers should be distinct and be within limits from 1 to n2. You can print the numbers in the lines in any order. It is guaranteed that the solution exists at the given limits.\n\nInputCopy2OutputCopy1 42 3\n\nOutputCopy1 42 3\n\nNoteThe sample shows Gerald's actions if he has two brothers. In this case, his bags contain 1, 2, 3 and 4 candies. He can give the bags with 1 and 4 candies to one brother and the bags with 2 and 3 to the other brother.",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 334\\s*A"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from input file\n    int n = inf.readInt();\n\n    // Stores whether a number from 1 to n^2 is used\n    vector<bool> used(n * n + 1, false); // index from 1 to n^2\n\n    int total_sum = -1;\n    for (int i = 0; i < n; ++i) {\n        // For each brother, read n integers\n        vector<int> candies;\n        for (int j = 0; j < n; ++j) {\n            int x = ouf.readInt(1, n * n, format(\"Brother %d bag %d\", i + 1, j + 1).c_str());\n\n            // Check if x is already used\n            if (used[x]) {\n                quitf(_wa, \"Number %d is used more than once\", x);\n            }\n            used[x] = true;\n            candies.push_back(x);\n        }\n\n        // Calculate sum of candies for this brother\n        int sum = 0;\n        for (int c : candies) sum += c;\n\n        // For the first brother, set total_sum\n        if (i == 0) {\n            total_sum = sum;\n        } else {\n            if (sum != total_sum) {\n                quitf(_wa, \"Not all brothers have the same total candies\");\n            }\n        }\n    }\n\n    // Check that all numbers from 1 to n^2 are used exactly once\n    for (int i = 1; i <= n * n; ++i) {\n        if (!used[i]) {\n            quitf(_wa, \"Number %d was not used\", i);\n        }\n    }\n\n    quitf(_ok, \"All brothers have %d total candies\", total_sum);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nmin = opt<int>(\"nmin\", 2);\n    int nmax = opt<int>(\"nmax\", 100);\n\n    ensure(nmin >= 2 && nmax <= 100 && nmin <= nmax);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n;\n\n    if (type == \"min\") {\n        n = nmin;\n        if (n % 2 != 0)\n            n += 1;\n    } else if (type == \"max\") {\n        n = nmax;\n        if (n % 2 != 0)\n            n -= 1;\n    } else if (type == \"smallestEven\") {\n        n = 2;\n    } else if (type == \"largestEven\") {\n        n = 100;\n    } else if (type == \"random\") {\n        n = rnd.next(nmin/2, nmax/2)*2;\n    } else {\n        n = rnd.next(nmin, nmax);\n        if (n % 2 != 0)\n            n -= 1;\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nmin = opt<int>(\"nmin\", 2);\n    int nmax = opt<int>(\"nmax\", 100);\n\n    ensure(nmin >= 2 && nmax <= 100 && nmin <= nmax);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n;\n\n    if (type == \"min\") {\n        n = nmin;\n        if (n % 2 != 0)\n            n += 1;\n    } else if (type == \"max\") {\n        n = nmax;\n        if (n % 2 != 0)\n            n -= 1;\n    } else if (type == \"smallestEven\") {\n        n = 2;\n    } else if (type == \"largestEven\") {\n        n = 100;\n    } else if (type == \"random\") {\n        n = rnd.next(nmin/2, nmax/2)*2;\n    } else {\n        n = rnd.next(nmin, nmax);\n        if (n % 2 != 0)\n            n -= 1;\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type smallestEven\n./gen -type largestEven\n./gen -nmin 2 -nmax 10 -type random\n./gen -nmin 2 -nmax 20 -type random\n./gen -nmin 50 -nmax 100 -type random\n./gen -nmin 2 -nmax 100 -type random\n./gen -nmin 98 -nmax 100 -type random\n\n./gen -nmin 10 -nmax 10 -type min\n./gen -nmin 20 -nmax 20 -type min\n./gen -nmin 50 -nmax 50 -type min\n./gen -nmin 80 -nmax 80 -type min\n./gen -nmin 100 -nmax 100 -type min\n\nfor i in {1..10}; do ./gen -nmin 2 -nmax 100 -type random; done\n\n./gen -nmin 2 -nmax 4 -type random\n./gen -nmin 96 -nmax 100 -type random\n./gen -nmin 2 -nmax 100 -type random\n./gen -type random\n./gen -nmin 4 -nmax 50 -type random\n\n./gen -nmin 60 -nmax 80 -type random\n./gen -nmin 2 -nmax 100 -type random\n./gen -nmin 30 -nmax 70 -type random\n./gen -nmin 2 -nmax 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:39.869273",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "334/B",
      "title": "B. Eight Point Sets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of eight lines, the i-th line contains two space-separated integers xi and yi (0 ≤ xi, yi ≤ 106). You do not have any other conditions for these points.",
      "output_spec": "OutputIn a single line print word \"respectable\", if the given set of points corresponds to Gerald's decency rules, and \"ugly\" otherwise.",
      "sample_tests": "ExamplesInputCopy0 00 10 21 01 22 02 12 2OutputCopyrespectableInputCopy0 01 02 03 04 05 06 07 0OutputCopyuglyInputCopy1 11 21 32 12 22 33 13 2OutputCopyugly",
      "description": "B. Eight Point Sets\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input consists of eight lines, the i-th line contains two space-separated integers xi and yi (0 ≤ xi, yi ≤ 106). You do not have any other conditions for these points.\n\nOutputIn a single line print word \"respectable\", if the given set of points corresponds to Gerald's decency rules, and \"ugly\" otherwise.\n\nInputCopy0 00 10 21 01 22 02 12 2OutputCopyrespectableInputCopy0 01 02 03 04 05 06 07 0OutputCopyuglyInputCopy1 11 21 32 12 22 33 13 2OutputCopyugly\n\nInputCopy0 00 10 21 01 22 02 12 2\n\nOutputCopyrespectable\n\nInputCopy0 01 02 03 04 05 06 07 0\n\nOutputCopyugly\n\nInputCopy1 11 21 32 12 22 33 13 2\n\nOutputCopyugly",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 334\\s*B"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 8; i++) {\n        int xi = inf.readInt(0, 1000000);\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 8; i++) {\n        int xi = inf.readInt(0, 1000000);\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 8; i++) {\n        int xi = inf.readInt(0, 1000000);\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"respectable\");\n    int MAX_COORD = opt<int>(\"max_coord\", 1000000);\n\n    // Ensure MAX_COORD is at least 2 to avoid errors\n    MAX_COORD = max(2, MAX_COORD);\n\n    vector<pair<int, int>> points;\n\n    int x1, x2, x3, y1, y2, y3;\n\n    if (type == \"respectable\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"include_center\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points including (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                points.emplace_back(xi, yi);\n            }\n        }\n    }\n    else if (type == \"missing_point\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n        // Remove one random point\n        int index = rnd.next(0, (int)points.size() - 1);\n        points.erase(points.begin() + index);\n    }\n    else if (type == \"duplicate_point\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n        // Duplicate a random point\n        int index = rnd.next(0, (int)points.size() - 1);\n        points.push_back(points[index]);\n    }\n    else if (type == \"duplicate_coordinate\") {\n        // Generate x1 == x2 < x3 or y1 == y2 < y3\n        if (rnd.next(0, 1) == 0) {\n            // Duplicate x coordinate\n            x1 = rnd.next(0, MAX_COORD - 1);\n            x2 = x1; // x1 == x2\n            x3 = rnd.next(x2 + 1, MAX_COORD);\n        } else {\n            // Duplicate y coordinate\n            x1 = rnd.next(0, MAX_COORD - 2);\n            x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n            x3 = rnd.next(x2 + 1, MAX_COORD);\n        }\n\n        y1 = rnd.next(0, MAX_COORD - 1);\n        y2 = y1; // y1 == y2\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"incorrect_order_x\") {\n        // Generate x1 >= x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(0, x1); // x2 <= x1\n        x3 = rnd.next(x1 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"incorrect_order_y\") {\n        // Generate y1 >= y2 < y3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(0, y1); // y2 <= y1\n        y3 = rnd.next(y1 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Generate random eight points\n        for (int i = 0; i < 8; ++i) {\n            int xi = rnd.next(0, MAX_COORD);\n            int yi = rnd.next(0, MAX_COORD);\n            points.emplace_back(xi, yi);\n        }\n    }\n    else {\n        // Default to 'respectable' if unrecognized type\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n\n    // Shuffle the points\n    shuffle(points.begin(), points.end());\n\n    // Output the points\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"respectable\");\n    int MAX_COORD = opt<int>(\"max_coord\", 1000000);\n\n    // Ensure MAX_COORD is at least 2 to avoid errors\n    MAX_COORD = max(2, MAX_COORD);\n\n    vector<pair<int, int>> points;\n\n    int x1, x2, x3, y1, y2, y3;\n\n    if (type == \"respectable\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"include_center\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points including (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                points.emplace_back(xi, yi);\n            }\n        }\n    }\n    else if (type == \"missing_point\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n        // Remove one random point\n        int index = rnd.next(0, (int)points.size() - 1);\n        points.erase(points.begin() + index);\n    }\n    else if (type == \"duplicate_point\") {\n        // Generate x1 < x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n        // Duplicate a random point\n        int index = rnd.next(0, (int)points.size() - 1);\n        points.push_back(points[index]);\n    }\n    else if (type == \"duplicate_coordinate\") {\n        // Generate x1 == x2 < x3 or y1 == y2 < y3\n        if (rnd.next(0, 1) == 0) {\n            // Duplicate x coordinate\n            x1 = rnd.next(0, MAX_COORD - 1);\n            x2 = x1; // x1 == x2\n            x3 = rnd.next(x2 + 1, MAX_COORD);\n        } else {\n            // Duplicate y coordinate\n            x1 = rnd.next(0, MAX_COORD - 2);\n            x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n            x3 = rnd.next(x2 + 1, MAX_COORD);\n        }\n\n        y1 = rnd.next(0, MAX_COORD - 1);\n        y2 = y1; // y1 == y2\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"incorrect_order_x\") {\n        // Generate x1 >= x2 < x3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(0, x1); // x2 <= x1\n        x3 = rnd.next(x1 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"incorrect_order_y\") {\n        // Generate y1 >= y2 < y3\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(0, y1); // y2 <= y1\n        y3 = rnd.next(y1 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Generate random eight points\n        for (int i = 0; i < 8; ++i) {\n            int xi = rnd.next(0, MAX_COORD);\n            int yi = rnd.next(0, MAX_COORD);\n            points.emplace_back(xi, yi);\n        }\n    }\n    else {\n        // Default to 'respectable' if unrecognized type\n        x1 = rnd.next(0, MAX_COORD - 2);\n        x2 = rnd.next(x1 + 1, MAX_COORD - 1);\n        x3 = rnd.next(x2 + 1, MAX_COORD);\n\n        y1 = rnd.next(0, MAX_COORD - 2);\n        y2 = rnd.next(y1 + 1, MAX_COORD - 1);\n        y3 = rnd.next(y2 + 1, MAX_COORD);\n\n        // Generate all points except (x2, y2)\n        for (int xi : {x1, x2, x3}) {\n            for (int yi : {y1, y2, y3}) {\n                if (!(xi == x2 && yi == y2)) {\n                    points.emplace_back(xi, yi);\n                }\n            }\n        }\n    }\n\n    // Shuffle the points\n    shuffle(points.begin(), points.end());\n\n    // Output the points\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type respectable -max_coord 10\n./gen -type respectable -max_coord 100\n./gen -type respectable -max_coord 1000\n./gen -type respectable -max_coord 1000000\n\n./gen -type include_center -max_coord 10\n./gen -type include_center -max_coord 1000000\n\n./gen -type missing_point -max_coord 10\n./gen -type missing_point -max_coord 1000000\n\n./gen -type duplicate_point -max_coord 10\n./gen -type duplicate_point -max_coord 1000000\n\n./gen -type duplicate_coordinate -max_coord 10\n./gen -type duplicate_coordinate -max_coord 1000000\n\n./gen -type incorrect_order_x -max_coord 10\n./gen -type incorrect_order_x -max_coord 1000000\n\n./gen -type incorrect_order_y -max_coord 10\n./gen -type incorrect_order_y -max_coord 1000000\n\n./gen -type random -max_coord 10\n./gen -type random -max_coord 1000000\n\n# Additional test cases for comprehensive coverage\n./gen -type respectable -max_coord 500000\n./gen -type duplicate_point -max_coord 500000\n./gen -type incorrect_order_x -max_coord 500000\n./gen -type random -max_coord 500000\n\n# More repetitions to ensure variability\n./gen -type respectable -max_coord 1000000\n./gen -type respectable -max_coord 1000000\n./gen -type respectable -max_coord 1000000\n\n./gen -type random -max_coord 1000000\n./gen -type random -max_coord 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:41.784056",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "334/C",
      "title": "C. Secrets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains a single integer n (1 ≤ n ≤ 1017).Please, do not use the %lld specifier to read or write 64 bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputIn a single line print an integer: the maximum number of coins the unlucky buyer could have paid with.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy4OutputCopy2",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains a single integer n (1 ≤ n ≤ 1017).Please, do not use the %lld specifier to read or write 64 bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputIn a single line print an integer: the maximum number of coins the unlucky buyer could have paid with.\n\nInputCopy1OutputCopy1InputCopy4OutputCopy2\n\nOutputCopy1\n\nOutputCopy2\n\nNoteIn the first test case, if a buyer has exactly one coin of at least 3 marks, then, to give Gerald one mark, he will have to give this coin. In this sample, the customer can not have a coin of one mark, as in this case, he will be able to give the money to Gerald without any change.In the second test case, if the buyer had exactly three coins of 3 marks, then, to give Gerald 4 marks, he will have to give two of these coins. The buyer cannot give three coins as he wants to minimize the number of coins that he gives.",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 334\\s*C"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long power3(int k) {\n    long long res = 1;\n    for (int i = 0; i < k; i++) {\n        res = res * 3;\n        if (res > 100000000000000000LL) // limit n to <= 1e17\n            return 100000000000000000LL;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n = 0;\n    if (type == \"small\") {\n        n = rnd.next(1LL, 1000LL);\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, 100000000000000000LL);\n    } else if (type == \"power3\") {\n        int k = opt<int>(\"k\", 5);\n        n = power3(k);\n    } else if (type == \"less_power3\") {\n        int k = opt<int>(\"k\", 5);\n        n = power3(k) - 1;\n    } else if (type == \"more_power3\") {\n        int k = opt<int>(\"k\", 5);\n        n = power3(k) + 1;\n    } else if (type == \"ternary_twos\") {\n        int k = opt<int>(\"k\", 10);\n        n = 0;\n        for (int i = 0; i < k; i++) {\n            n = n * 3 + 2;\n            if (n > 100000000000000000LL)\n                break;\n        }\n    } else if (type == \"max\") {\n        n = 100000000000000000LL;\n    } else {\n        // default random\n        n = rnd.next(1LL, 100000000000000000LL);\n    }\n\n    if (n < 1) n = 1;\n    if (n > 100000000000000000LL) n = 100000000000000000LL;\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long power3(int k) {\n    long long res = 1;\n    for (int i = 0; i < k; i++) {\n        res = res * 3;\n        if (res > 100000000000000000LL) // limit n to <= 1e17\n            return 100000000000000000LL;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n = 0;\n    if (type == \"small\") {\n        n = rnd.next(1LL, 1000LL);\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, 100000000000000000LL);\n    } else if (type == \"power3\") {\n        int k = opt<int>(\"k\", 5);\n        n = power3(k);\n    } else if (type == \"less_power3\") {\n        int k = opt<int>(\"k\", 5);\n        n = power3(k) - 1;\n    } else if (type == \"more_power3\") {\n        int k = opt<int>(\"k\", 5);\n        n = power3(k) + 1;\n    } else if (type == \"ternary_twos\") {\n        int k = opt<int>(\"k\", 10);\n        n = 0;\n        for (int i = 0; i < k; i++) {\n            n = n * 3 + 2;\n            if (n > 100000000000000000LL)\n                break;\n        }\n    } else if (type == \"max\") {\n        n = 100000000000000000LL;\n    } else {\n        // default random\n        n = rnd.next(1LL, 100000000000000000LL);\n    }\n\n    if (n < 1) n = 1;\n    if (n > 100000000000000000LL) n = 100000000000000000LL;\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -type small\n\n# Random n values\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Powers of 3\n./gen -type power3 -k 0\n./gen -type power3 -k 1\n./gen -type power3 -k 2\n./gen -type power3 -k 5\n./gen -type power3 -k 10\n./gen -type power3 -k 20\n./gen -type power3 -k 30\n./gen -type power3 -k 34\n\n# One less than powers of 3\n./gen -type less_power3 -k 1\n./gen -type less_power3 -k 2\n./gen -type less_power3 -k 5\n./gen -type less_power3 -k 10\n./gen -type less_power3 -k 20\n./gen -type less_power3 -k 30\n./gen -type less_power3 -k 34\n\n# One more than powers of 3\n./gen -type more_power3 -k 0\n./gen -type more_power3 -k 1\n./gen -type more_power3 -k 2\n./gen -type more_power3 -k 5\n./gen -type more_power3 -k 10\n./gen -type more_power3 -k 20\n./gen -type more_power3 -k 30\n./gen -type more_power3 -k 34\n\n# Ternary twos\n./gen -type ternary_twos -k 1\n./gen -type ternary_twos -k 2\n./gen -type ternary_twos -k 5\n./gen -type ternary_twos -k 10\n./gen -type ternary_twos -k 20\n./gen -type ternary_twos -k 30\n./gen -type ternary_twos -k 34\n\n# Max n value\n./gen -type max\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:43.828958",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "334/D",
      "title": "D. Chips",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 1000, 0 ≤ m ≤ 105) — the size of the field and the number of banned cells. Next m lines each contain two space-separated integers. Specifically, the i-th of these lines contains numbers xi and yi (1 ≤ xi, yi ≤ n) — the coordinates of the i-th banned cell. All given cells are distinct.Consider the field rows numbered from top to bottom from 1 to n, and the columns — from left to right from 1 to n.",
      "output_spec": "OutputPrint a single integer — the maximum points Gerald can earn in this game.",
      "sample_tests": "ExamplesInputCopy3 12 2OutputCopy0InputCopy3 0OutputCopy1InputCopy4 33 13 23 3OutputCopy1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 1000, 0 ≤ m ≤ 105) — the size of the field and the number of banned cells. Next m lines each contain two space-separated integers. Specifically, the i-th of these lines contains numbers xi and yi (1 ≤ xi, yi ≤ n) — the coordinates of the i-th banned cell. All given cells are distinct.Consider the field rows numbered from top to bottom from 1 to n, and the columns — from left to right from 1 to n.\n\nOutputPrint a single integer — the maximum points Gerald can earn in this game.\n\nInputCopy3 12 2OutputCopy0InputCopy3 0OutputCopy1InputCopy4 33 13 23 3OutputCopy1\n\nInputCopy3 12 2\n\nOutputCopy0\n\nInputCopy3 0\n\nOutputCopy1\n\nInputCopy4 33 13 23 3\n\nOutputCopy1\n\nNoteIn the first test the answer equals zero as we can't put chips into the corner cells.In the second sample we can place one chip into either cell (1, 2), or cell (3, 2), or cell (2, 1), or cell (2, 3). We cannot place two chips.In the third sample we can only place one chip into either cell (2, 1), or cell (2, 4).",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 334\\s*D"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> bannedCells;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        pair<int, int> cell = make_pair(xi, yi);\n        ensuref(bannedCells.count(cell) == 0, \"Cell (%d, %d) appears multiple times\", xi, yi);\n        bannedCells.insert(cell);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> bannedCells;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        pair<int, int> cell = make_pair(xi, yi);\n        ensuref(bannedCells.count(cell) == 0, \"Cell (%d, %d) appears multiple times\", xi, yi);\n        bannedCells.insert(cell);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> bannedCells;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        pair<int, int> cell = make_pair(xi, yi);\n        ensuref(bannedCells.count(cell) == 0, \"Cell (%d, %d) appears multiple times\", xi, yi);\n        bannedCells.insert(cell);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m does not exceed constraints\n    m = min(m, n * n);\n    m = min(m, 100000);\n\n    set<pair<int, int>> banned_cells;\n\n    if (type == \"random\") {\n        // Generate m unique banned cells randomly\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    } else if (type == \"no_banned\") {\n        // No banned cells\n        m = 0;\n    } else if (type == \"banned_border\") {\n        // Ban all border (but not corner) cells\n        for (int i = 2; i <= n - 1; ++i) {\n            // First row\n            banned_cells.insert({1, i});\n            // Last row\n            banned_cells.insert({n, i});\n            // First column\n            banned_cells.insert({i, 1});\n            // Last column\n            banned_cells.insert({i, n});\n        }\n        m = banned_cells.size();\n    } else if (type == \"full_grid_banned\") {\n        // Ban all cells except corners\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                if (!((i == 1 || i == n) && (j == 1 || j == n)))\n                    banned_cells.insert({i, j});\n        m = banned_cells.size();\n    } else if (type == \"max_edges\") {\n        // Ban all cells\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                banned_cells.insert({i, j});\n        m = min((int)banned_cells.size(), m);\n    } else if (type == \"minimal_n\") {\n        // n = 2, m can be specified\n        n = 2;\n        m = min(m, n * n);\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    } else if (type == \"maximal_n\") {\n        // n = 1000, m can be specified\n        n = 1000;\n        m = min(m, n * n);\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    } else if (type == \"special_case_1\") {\n        // Ban a cross in the middle of the grid\n        int mid = n / 2 + (n % 2);\n        for (int i = 1; i <= n; ++i) {\n            banned_cells.insert({mid, i});\n            banned_cells.insert({i, mid});\n        }\n        m = min((int)banned_cells.size(), m);\n    } else {\n        // Default to random\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output m lines of banned cells\n    for (const auto& cell : banned_cells) {\n        printf(\"%d %d\\n\", cell.first, cell.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m does not exceed constraints\n    m = min(m, n * n);\n    m = min(m, 100000);\n\n    set<pair<int, int>> banned_cells;\n\n    if (type == \"random\") {\n        // Generate m unique banned cells randomly\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    } else if (type == \"no_banned\") {\n        // No banned cells\n        m = 0;\n    } else if (type == \"banned_border\") {\n        // Ban all border (but not corner) cells\n        for (int i = 2; i <= n - 1; ++i) {\n            // First row\n            banned_cells.insert({1, i});\n            // Last row\n            banned_cells.insert({n, i});\n            // First column\n            banned_cells.insert({i, 1});\n            // Last column\n            banned_cells.insert({i, n});\n        }\n        m = banned_cells.size();\n    } else if (type == \"full_grid_banned\") {\n        // Ban all cells except corners\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                if (!((i == 1 || i == n) && (j == 1 || j == n)))\n                    banned_cells.insert({i, j});\n        m = banned_cells.size();\n    } else if (type == \"max_edges\") {\n        // Ban all cells\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                banned_cells.insert({i, j});\n        m = min((int)banned_cells.size(), m);\n    } else if (type == \"minimal_n\") {\n        // n = 2, m can be specified\n        n = 2;\n        m = min(m, n * n);\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    } else if (type == \"maximal_n\") {\n        // n = 1000, m can be specified\n        n = 1000;\n        m = min(m, n * n);\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    } else if (type == \"special_case_1\") {\n        // Ban a cross in the middle of the grid\n        int mid = n / 2 + (n % 2);\n        for (int i = 1; i <= n; ++i) {\n            banned_cells.insert({mid, i});\n            banned_cells.insert({i, mid});\n        }\n        m = min((int)banned_cells.size(), m);\n    } else {\n        // Default to random\n        while ((int)banned_cells.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            banned_cells.insert({x, y});\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output m lines of banned cells\n    for (const auto& cell : banned_cells) {\n        printf(\"%d %d\\n\", cell.first, cell.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 0 -type no_banned\n./gen -n 2 -m 0 -type random\n./gen -n 2 -m 4 -type random\n./gen -n 2 -m 4 -type full_grid_banned\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 20 -type random\n./gen -n 10 -m 50 -type random\n\n./gen -n 50 -m 100 -type random\n./gen -n 50 -m 100 -type special_case_1\n./gen -n 50 -m 196 -type banned_border\n\n./gen -n 100 -m 0 -type no_banned\n./gen -n 100 -m 1000 -type random\n./gen -n 100 -m 1000 -type special_case_1\n./gen -n 100 -m 396 -type banned_border\n\n./gen -n 500 -m 100000 -type random\n./gen -n 500 -m 50000 -type random\n\n./gen -n 1000 -m 100000 -type random\n./gen -n 1000 -m 100000 -type special_case_1\n./gen -n 1000 -m 3996 -type banned_border\n\n./gen -n 2 -m 4 -type max_edges\n./gen -n 2 -m 4 -type minimal_n\n\n./gen -n 1000 -m 100000 -type maximal_n\n\n./gen -n 3 -m 8 -type special_case_1\n\n./gen -n 1000 -m 1 -type random\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 999 -m 100000 -type maximal_n\n./gen -n 1000 -m 100000 -type full_grid_banned\n\n./gen -n 500 -m 50000 -type minimal_n\n\n./gen -n 1000 -m 100000 -type no_banned\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:45.770466",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "334/E",
      "title": "E. Lucky Tickets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two integers k and m (0 ≤ k ≤ 104, 1 ≤ m ≤ 3·105).",
      "output_spec": "OutputPrint m lines. Each line must contain exactly 8 digits — the k-winning ticket. The tickets may begin with 0, all tickets must be distinct. If there are more than m distinct k-lucky tickets, print any m of them. It is guaranteed that at least m distinct k-lucky tickets exist. The tickets can be printed in any order.",
      "sample_tests": "ExamplesInputCopy0 3OutputCopy000000000000000100000002InputCopy7 4OutputCopy00000007000000160000001700000018",
      "description": "E. Lucky Tickets\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two integers k and m (0 ≤ k ≤ 104, 1 ≤ m ≤ 3·105).\n\nOutputPrint m lines. Each line must contain exactly 8 digits — the k-winning ticket. The tickets may begin with 0, all tickets must be distinct. If there are more than m distinct k-lucky tickets, print any m of them. It is guaranteed that at least m distinct k-lucky tickets exist. The tickets can be printed in any order.\n\nInputCopy0 3OutputCopy000000000000000100000002InputCopy7 4OutputCopy00000007000000160000001700000018\n\nInputCopy0 3\n\nOutputCopy000000000000000100000002\n\nInputCopy7 4\n\nOutputCopy00000007000000160000001700000018",
      "solutions": [
        {
          "title": "Codeforces Round 194 - Codeforces",
          "content": "Good day for all!I invite you to participiate in the round 194. I'm author of it. It is my fourth round, but three previous ones were a long time ago: Codeforces Beta Round 79 (Div. 1 Only), Codeforces Beta Round 94 (Div. 1 Only), Codeforces Round 110 (Div. 1) (I apologize to the div-2 participants that I have mention only div-1 round, but even one link looks bulky). This time you will help to boy Gerald cope with his problems as in the Codeforces Beta Round 79 (Div. 1 Only). This time his problems are so serious that he became coordinator of contests on the Codeforces, to be able to throw his problems to you.I want to thank Gerald for he is great as coordinator. When you are work with him you are fill the everythink is under control. Moreover I want to thank Maria Belova for translation problems statements to the English.This round will be held in unusual time — 12:30 Moscow Time.Score distribution is standart: 500 — 1000 — 1500 — 2000 — 2500.Thanks everyone for participation, welcom to editoral.Congratulations to winners: Division 1: 1. KADR 2. RAVEman 3. PavelKunyavskiy 4. Dmitry_Egorov 5. RAD 6. sy2006 7. mmaxio 8. riadwaw 9. niyaznigmatul 10. RomaWhiteSeparate note two Ukrainian participiants, who only solve all five problems!Division 2: 1. IMOiguanas 2. savsmail 3. suyash666 4. AntiForest 5. kang205 6. jschnei 7. littlepanda 8. langdamao 9. 9mmlitswe 10. Renkai Following numerous requests to authors of rounds, I will talk something about me. My name is Valera Samoylov and I'm 24. I have graduated from SPb SU two years ago. Now I working on chemical layout of graphs and bringing up my little daughter together with my wife. Moreover last 8 years I'm teach schoolchilds math (and, last year, programming) in mathematical school in Saint-Petersburg. It all explains why I have not made rounds last time, although I have abound invented problems. Nonetheless I have found some time to make the round while my wife and daughter are on the vacation and schoolchilds on the vacation too. I hope you are will find that I not waste this time.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2066
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces",
          "content": "334A - Candy BagsIn this problem one must divide all natural numbers from 1 to n2 to groups size of n with the same sums.Lets divide all this numbers to pairs . We can to do it since n is even and therefore n2 is even too. Then we can just make n groups consists of of these pairs.334B - Eight Point SetsIn this problem you must to do only what's written — you must to define does this set of points sutisfies to decribed conditions.There are many ways to define it. For instance: Check if there are exactly 3 discinct x's and y's. One can put all x's to set and then get it size to find amount of distinct x's (as well as y's). Then print ``ugly'' if this amount isn't equals to 3. Finally we have x1, x2 и x3 as well as y1, y2 и y3. Now lets check if for every pair (xi, yj) (except (x2, y2)) such point exist in given set of points. But I think that to read editoral of this problem is not good idea. It is better to just look at the implementation.334C - Secrets / 333A - SecretsActually we are looking for longest sequence of natural number a1, a2, ..., ak, so that every number in it sequence is the power of three, sum of all numbers is more then n and if we remove any number sum will be less then n. To be precise we are looking for length of this sequence.Consider minimal number ai = A in the sequence. All this numbers are divides to A since them all are powers of 3. And then, sum S of all this number is divides to A too. Suppose that n is divide to A too. Then, since S > n, then S - A ≥ n. And then if we remove A from sequence, sum of other number not less then n — contradist with second condition.Well, we now that n is not divide to none element in sequence. Now lets find minimal k so that , and answer is .334D - Chips / 333B - ChipsAt first lets make two remarks: On every (vertical of horizontal) line we can put only one chip. If there is at least one forbidden cell on the line then we can't put chip on this line. Follow last remark we will avoid hits chip on forbidden cells. Lets avoid ``collisions'' of chips.Lets consider these four line: vertical lines number i and n + 1 - i and horizontal lines with the same numbers. Chips on these lines can collides together, but con't collides to another chip. Therefore we can solve the problem for these four line independently. And finally lets observe that we can put the chip on each of these lines without cillisions as well as on the picture.So, we can iterate all possible fours and put chip on every possible line. And don't fogot about case of two middle line in case of n is odd.334E - Lucky Tickets / 333C - Lucky TicketsIn this problem we can find the right amount of lucky tickets.Lets consider amount of different numbers we can get from one four-digit ticket number. It is easy to iterate all this tickets, since it amount only 104. It happened that we can get almost 60 numbers from ticket on the average.Suppose we can get number x from ticket n. It is clearly that either x - k ≥ 0 or k - x ≥ 0. If k - x ≥ 0 we can write eight-digit ticket number who will have k - x in the first four digits and n in the last four digits. It is clearly that such ticket is k-lucky. This method allows us to get almost 600 000 lucky tickets and it is enough.333D - Characteristics of RectanglesIn this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table.In another words, we are looking for maximum value of min(ai1, j1, ai1, j2, ai2, j1, ai2, j2) for all i1, i2, j1, j2 such that 1 ≤ i1, i2 ≤ n, 1 ≤ j1, j2 ≤ m, i1 ≠ i2, j1 ≠ j2. Lets us binary search of the answer. For us it we must can define is there two rows and two colums with ones on all four its intersections; in other words, integers i1, i2, j1, j2 so that ai1, j1 = ai1, j2 = ai2, j1 = ai2, j2 = 1. Lets consider all pair of natural numbers (i1, i2) so that there exist nutural number j so that ai1, j = ai2, j = 1. Existence of two equals such pairs is equals to existence of above four numbers. But it is can be only such pairs. Therefore we can make the array where we will mark pair who were meets. Lets iterate all pairs in any order until we meet repeated pair or pairs are ends. So we have solution of time .333E - Summer EarningsIn this problem it is need to draw three circle equals together with maximum possible radius with centers in given points. In another words it is need to find triangle wich minimum side is maximal.Unfortunately solution with bit optimize is not expected for us.Lets call to memory two simple geometric facts. Firstly, sum of alnges of trianle is equals to . Secondly, minimal angle is opposit to minimal side of triangle.Since, at leats one side of angles of triangle not less then and this anlge is not least one. And side opposite to it is not least side. Therefore, if in then min(|AB|, |BC|, |CA|) = min(|AB|, |BC|).And then lets do the follows. Lets iterate apex B and for each B lets find triangle with maximal minimum of sides when B is the apex of triangle and . For it lets sort all other points by the angle relative to B, and for each point A lets find point C most distant to B among such points that . We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points C during iterating A.Finally, we have solution of time .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8418",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 334\\s*E"
          },
          "content_length": 5332
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 194 - Codeforces - Code 1",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 - Codeforces - Code 2",
          "code": "Case 0: Buyer has only 1 coins. Here he will be able to give exact sum. So, invalid.\nCase 1: Buyer has 1 and 3 coins. In this case, he will be able to give 4 (1,3). Invalid.\nCase 2: Buyer has only 3 coins. In this case ans is 2.\nCase 3: Buyer has coins with value more than 3. In this case ans is 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 1",
          "code": "O(n^2 log max(a))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 2",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 3",
          "code": "int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 4",
          "code": "rep(i, 1000000000) a = std::max(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 194 — Editoral - Codeforces - Code 5",
          "code": "rep(i, 1000000000) a = fastmax(1000, -1000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8418",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <set>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input parameters k and m, but since we won't use k, we can skip reading it\n    inf.readInt(0, 10000, \"k\");\n    int m = inf.readInt(1, 300000, \"m\");\n    set<string> tickets;\n    for (int i = 1; i <= m; ++i) {\n        string ticket = ouf.readLine();\n        if (ticket.size() != 8)\n            quitf(_wa, \"Line %d: ticket length is %d, expected 8\", i, ticket.size());\n        for (char c : ticket) {\n            if (!isdigit(c))\n                quitf(_wa, \"Line %d: ticket contains non-digit character '%c'\", i, c);\n        }\n        if (tickets.count(ticket))\n            quitf(_wa, \"Line %d: duplicate ticket %s\", i, ticket.c_str());\n        tickets.insert(ticket);\n    }\n    if (!ouf.eof())\n        quitf(_wa, \"Output contains extra data after reading %d tickets\", m);\n    quitf(_ok, \"All tickets are valid and distinct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = rnd.next(0, 10000);\n    int m = rnd.next(1, 300000);\n\n    string type = opt<string>(\"type\", \"random\");\n    k = opt<int>(\"k\", k);\n    m = opt<int>(\"m\", m);\n\n    if (type == \"min_k_min_m\") {\n        k = 0;\n        m = 1;\n    } else if (type == \"min_k_max_m\") {\n        k = 0;\n        m = 300000;\n    } else if (type == \"max_k_min_m\") {\n        k = 10000;\n        m = 1;\n    } else if (type == \"max_k_max_m\") {\n        k = 10000;\n        m = 300000;\n    } else if (type == \"small_m\") {\n        m = rnd.next(1, 10);\n    } else if (type == \"large_m\") {\n        m = rnd.next(299990, 300000);\n    } else if (type == \"small_k\") {\n        k = rnd.next(0, 10);\n    } else if (type == \"large_k\") {\n        k = rnd.next(9990, 10000);\n    } else if (type == \"max_m_random_k\") {\n        m = 300000;\n        k = rnd.next(0, 10000);\n    } else if (type == \"max_k_random_m\") {\n        k = 10000;\n        m = rnd.next(1, 300000);\n    } else if (type == \"random\") {\n        // k and m already assigned randomly\n    } else {\n        // Use provided k and m if specified\n        // Otherwise, keep the random values\n    }\n\n    printf(\"%d %d\\n\", k, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = rnd.next(0, 10000);\n    int m = rnd.next(1, 300000);\n\n    string type = opt<string>(\"type\", \"random\");\n    k = opt<int>(\"k\", k);\n    m = opt<int>(\"m\", m);\n\n    if (type == \"min_k_min_m\") {\n        k = 0;\n        m = 1;\n    } else if (type == \"min_k_max_m\") {\n        k = 0;\n        m = 300000;\n    } else if (type == \"max_k_min_m\") {\n        k = 10000;\n        m = 1;\n    } else if (type == \"max_k_max_m\") {\n        k = 10000;\n        m = 300000;\n    } else if (type == \"small_m\") {\n        m = rnd.next(1, 10);\n    } else if (type == \"large_m\") {\n        m = rnd.next(299990, 300000);\n    } else if (type == \"small_k\") {\n        k = rnd.next(0, 10);\n    } else if (type == \"large_k\") {\n        k = rnd.next(9990, 10000);\n    } else if (type == \"max_m_random_k\") {\n        m = 300000;\n        k = rnd.next(0, 10000);\n    } else if (type == \"max_k_random_m\") {\n        k = 10000;\n        m = rnd.next(1, 300000);\n    } else if (type == \"random\") {\n        // k and m already assigned randomly\n    } else {\n        // Use provided k and m if specified\n        // Otherwise, keep the random values\n    }\n\n    printf(\"%d %d\\n\", k, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_k_min_m\n./gen -type min_k_max_m\n./gen -type max_k_min_m\n./gen -type max_k_max_m\n\n./gen -type small_m\n./gen -type large_m\n./gen -type small_k\n./gen -type large_k\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max_m_random_k\n./gen -type max_k_random_m\n\n# Specific k and m\n./gen -k 0 -m 300000\n./gen -k 1 -m 299999\n./gen -k 10 -m 1\n./gen -k 9999 -m 300000\n./gen -k 10000 -m 1\n\n# Testing boundary conditions\n./gen -k 0 -m 1\n./gen -k 10000 -m 300000\n./gen -k 5000 -m 150000\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Testing small m\n./gen -type small_m\n./gen -type small_m\n./gen -type small_m\n\n# Testing large m\n./gen -type large_m\n./gen -type large_m\n./gen -type large_m\n\n# Testing small k\n./gen -type small_k\n./gen -type small_k\n./gen -type small_k\n\n# Testing large k\n./gen -type large_k\n./gen -type large_k\n./gen -type large_k\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:48.110093",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "335/A",
      "title": "A. Banana",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains string s (1 ≤ |s| ≤ 1000), consisting of lowercase English characters only. The second line contains an integer n (1 ≤ n ≤ 1000).",
      "output_spec": "OutputOn the first line, print the minimum number of sheets Piegirl has to buy. On the second line, print a string consisting of n lower case English characters. This string should describe a sheet of stickers that Piegirl can buy in order to minimize the number of sheets. If Piegirl cannot possibly form the string s, print instead a single line with the number -1.",
      "sample_tests": "ExamplesInputCopybanana4OutputCopy2baanInputCopybanana3OutputCopy3nabInputCopybanana2OutputCopy-1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains string s (1 ≤ |s| ≤ 1000), consisting of lowercase English characters only. The second line contains an integer n (1 ≤ n ≤ 1000).\n\nOutputOn the first line, print the minimum number of sheets Piegirl has to buy. On the second line, print a string consisting of n lower case English characters. This string should describe a sheet of stickers that Piegirl can buy in order to minimize the number of sheets. If Piegirl cannot possibly form the string s, print instead a single line with the number -1.\n\nInputCopybanana4OutputCopy2baanInputCopybanana3OutputCopy3nabInputCopybanana2OutputCopy-1\n\nInputCopybanana4\n\nOutputCopy2baan\n\nInputCopybanana3\n\nOutputCopy3nab\n\nInputCopybanana2\n\nOutputCopy-1\n\nNoteIn the second example, Piegirl can order 3 sheets of stickers with the characters \"nab\". She can take characters \"nab\" from the first sheet, \"na\" from the second, and \"a\" from the third, and arrange them to from \"banana\".",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL start[c]up will take place on August, 3rd, 10:00am PDT. There will be two contests running simultaneously, one for people who participate onsite, and one for everybody else who advanced to the round two. Both rounds share the problemset and are rated based on the combined scoreboard.Onsite participants will have special prizes for first three places. All onsite participants as well as the top 100 in the online contest will receive a start[c]up t-shirt.People who have not advanced to the round two can participate in the round unofficially. Unofficial participation will be rated.The contest will be 3 hours long, and will feature 6 problems. The score distribution is 500-1000-1000-2000-2500-3000.The problem set has been developed by MemSQL engineers pieguy, nika, exod40, SkidanovAlex and dolphinigle.Good luck and happy coding!UPDATE: Editorial is up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8506",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces",
          "content": "This is the Editorial for MemSQL start[c]up Round 2 and MemSQL start[c]up Round 2 - online version. Congratulations RAD for online round winner and Petr for onsite and overall score winner!This editorial is written jointly by the contest's coordinators (i.e., MemSQL engineers).335A - Banana -- AlexSkidanovReference solution: Jimanbanashi's 4222182Instead of calculating the smallest possible number of sheets given a fixed n, let us instead try to compute the smallest possible value of n given a fixed number of sheets. Let k denote the number of sheets. If a particular letter appears p times in s, then it must appear at least ceil(p / k) times in the sheet. Thus we can compute the smallest possible value of n by summing ceil(p / k) over all letters. Now the original problem can be solved using binary search on k (or brute force, since the constraints were small enough).335B - Palindrome -- AlexSkidanovThere’s a well known O(n2) solution that allows one to find a longest subsequence of a string which is a palindrome: for every pair of positions l and r, such that l ≤ r, find the length d of the longest palindrome subsequence between those positions. d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).There are two ways to solve this problem faster than O(n2) with the constraints given in the problem: Use dynamic programming. For every position l and length k find the leftmost position r, such that there’s a palindrome of length k in the substring of s starting at l and ending at r. For position l and length k r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),where next(pos, s) is the next occurrence of character s after position pos. Next can be precomputed for all the positions and all the characters in advance. See DamianS's 4221965. If length is less than 2600, use the well-known O(n2) dynamic programming approach. Otherwise by pigeonhole principle there’s at least one character that appears in the string at least 100 times -- find it and print it 100 times. See SteamTurbine's 4224770. 335C - More Reclamation -- AlexSkidanovThe most straightforward way to solve this problem is to use Grundy numbers. Define a segment as a maximal range of rows in which no cells have been reclaimed. Since segments have no bearing on other segments, they can be assigned Grundy numbers. There are 4 types of segments: The entire river. A section of river containing one of the ends. A section of river blocked at both ends in the same column A section of river blocked at both ends in different columns Each time a cell is reclaimed, it splits a segment into 2 segments (one of which may have size 0). We can compute the Grundy value for all possible segments in O(r2). Then after sorting the reclaimed cells by row number, we can find all segments and compute the Grundy number for the full state.See Dmitry_Egorov's 4221888.Alternatively, we can compute the result directly. Suppose the game is over. We can determine who won the game just by looking at the top row and the bottom row. Let us define “parity” as the modulo 2 remainder of (r + n + c0 + c1), where c0 is the column of the reclaimed cell with the lowest row, and c1 is the column of the reclaimed cell with the highest row. Claim: when the game is over, the parity is even. This can be seen by observing that the number of empty rows is equal to the number of times the column changes. In other words, if c0==c1, there are an even number of empty rows, otherwise an odd number of empty rows. Now, given r, c0, and c1, we can determine n, and therefore the winner.Let us consider the case where there are no reclaimed cells. If r is even, then the second city can win with a mirroring strategy. When the first city reclaims cell (a,b), the second city follows with (r+1-a,b). Similarly, if r is odd then the first city wins by a mirroring strategy, playing first in ((r+1)/2, 0), and subsequently following the strategy for even r.Now suppose there are reclaimed cells. Let us define r0 as the number of empty rows in the segment starting from one end, and r1 as the number of empty rows starting from the other end.Case 1: if r0==r1 and the parity is even, the state is losing. All available moves will either decrease r0, decrease r1, or make the parity odd. The other player can respond to the first two types of moves with a mirroring strategy, and the third by making the parity even again (there will always be such a move that doesn’t affect r0 or r1, based on the fact that the argument above).Case 2: if abs(r0-r1)>=2 then the state is winning. Suppose, without loss of generality, that r0-r1>=2. Then either of the cells (r1+1, 1) and (r1+1, 2) may be reclaimed, and one of them must lead to Case 1 (since they both result in r0==r1, and one will have even parity and the other odd).Case 3: if abs(r0-r1)<2 and the parity is odd, the state is winning. If r0==r1, then we can change the parity without affecting r0 or r1, leaving our opponent in Case 1. Otherwise, there is a unique move that leaves our opponent in Case 1.(note that cases 2 and 3 together imply that all states with odd parity are winning)Case 4: if abs(r0-r1)==1 and the parity is even, there is at most one move that doesn’t leave our opponent in Case 2 or Case 3. Suppose r0==r1+1. We must change either r0 or r1, since all other moves will change the parity to odd. Thus our only option is to decrease r0, since decreasing r1 would leave our opponent in Case 2. We could decrease r0 by 1, but doing so would change the parity. Thus we must decrease r0 by 2, and there is at most one move that does so and keeps the parity even. It follows that if floor(r0/2)+floor(r1/2) is even, then this is a losing position, otherwise a winning position.See jill-jenn's extremely short 4225125.335D - Rectangles and Square -- AlexSkidanovEven though constraints were allowing O(k^2) solutions, in this editorial we will describe an O(n log(n)) solution. This problem has a rather long solution, involving several very different ideas: On the first step, for every rectangle we want to determine, if we were to consider this rectangle as the top left corner of a square, how long could the top and left edge of the square be (see the picture).If there’s no rectangle that is adjacent to the current rectangle on the right, which has the same y1 coordinate, then the top edge length is just the width of the current rectangle. Otherwise it is the width of the current rectangle plus the max top edge computed for the rectangle adjacent on the right. Left edge length is computed likewise.When top and left edge lengths are computed, we want to compute the max bottom and right edge length if this rectangle was the bottom right corner of the square.On the second step, we want to find all possible square frames. Look at this picture to better understand what we mean by square frame:To find a frame, let’s sort all the points first by x - y, and then by x (or y -- both will yield the same result). This way all the points are sorted by the diagonal they belong to, and then by the position on that diagonal. Then we will maintain a stack of pairs (position, edge length), where edge length is min(top edge length, left edge length). Position could be either x or y (within a given diagonal relative differences in xs and ys are the same). Min edge length tells us what is the largest square that could start at that position.When we process a new point on a diagonal, first pop from the stack all the pairs such that their position + edge length is less than our position. If stack after that is empty, then the current point cannot be a bottom right corner of any square. If stack is not empty, then there could be some frames with the current point being bottom right corner.Here we need to make a very important observation. If a square frame is contained within some other square frame, we don’t need to consider the outer square frame, since if the outer square frame is then proves to be an actual square, then the inner frame also has to be an actual square, and it is enough to only check an inner frame.With this observation made, we can only check if the last point on the stack forms a frame with the current point, there’s no need to check any other point on the stack. Since we already know that last element on the stack reaches to the right and to the bottom further than our current position (otherwise we would have popped it from the stack), to see if we form a frame with that point it is enough to check if we can reach that far to the top and to the left. To do so, check, if position of the current point minus min(bottom edge length, right edge length) for the current point is smaller or equal than the position of the point that is at the top of the stack. If it is, we have a square frame.When we have a frame, we move to the third step, where we check if the frame is filled in. To do that we just want to check if area within that square that is filled in by rectangles is equal to the area of the square. For every corner of every rectangle we will compute the area covered by rectangles which are fully located to the left and top from that point. To do that we can sort all the corners by x, and then by y, and process them one by one. We will maintain an interval tree where value at every position y represents area covered by rectangles processed so far that are fully above y. Then when we process a corner, we first update the interval tree if the corner is a bottom right corner, and then query the interval tree to see the area covered by rectangles to the up and left from the current corner.Then, when we have these number precomputed, for every square frame x1, y1, x2, y2 we can just get the area for (x2, y2), add area for (x1, y1) and subtract for (x2, y1) and for (x1, y2). See the author (AlexSkidanov)'s 4234601A possible O(k2) solution is similar, but makes checking whether or not the frame is filled much and a bunch of other checks easier. See my 4234474.335E - Counting Skyscrapers -- pieguyThe skyscrapers in this problem depict a data structure called Skip List. Skip list is similar to AVL and red black trees in a sense that it allows O(log N) insertions, deletions and searches (including searching for lower and upper bounds), as well as moving to the next element in sorted order in constant time. Skiplist is different from any tree structures because it has a practical thread safe implementation without locks (so-called lock-free). Lock free skiplists are used as a main data structure to store data in MemSQL, and the algorithm that Bob uses to traverse the skyscrapers is an O(log N) approach, that allows one to estimate the size of the skiplist. Thus, if Bob ended up with an estimation of n, the actual skiplist size is expected to be n (so if the first line of the input file is Bob, one just needs to print the number from the second line to the output). Formal proof is rather simple, and is left to the reader. Curiously, the converse does not hold. If the skiplist size is n, the expected return value of the estimation algorithm could be bigger than n. For an n that is significantly bigger than 2h the estimate converges to n - 1 + 2h, but this problem included cases with smaller n as well.Let us build up the solution one level at a time. When H is 0, the expected sum is N. Now for each additional level, we can add the expected cost of the zip lines on that level, and subtract the expected cost of the zip lines immediately below them. In the end we’ll have the total expected cost.For some floor number H, let’s consider some left and right tower, and determine the probability that a zip line exists between them. Let L be the distance between the two towers. A potential zip line of length L and height H exists if the towers at both ends are tall enough (probability 1 / 2H for each one), and the L - 1 towers between them are all shorter (probability 1 - 1 / 2H for each). Thus the probability that such a zip line exists is 1 / 22 * H × (1 - 1 / 2H)L - 1.Now, assuming that such a zip line exists, what’s the expected number of zip lines immediately below it? This is simply one more than the number of towers of height H - 1. Each of the L - 1 towers has probability 1 / (2H - 1) of having height H-1 (given that it has height at most H-1) -- use conditional probability () to calculate this. Thus the expected number of zip lines immediately below a zip line of length L and height H is 1 + (L - 1) / (2H - 1).For each length L, there are N - L possible zip lines with this length on each level. We multiply probability by cost for all possible zip lines to attain the expected value.The final answer is thereforeIt turns out the inner loop can be computed using matrix multiplication, for a running time of O(H log N). -- although the constraints is low enough that using matrix multiplication is an overkill -- O(H * N) will do.See the author (pieguy)'s 4234465. ...apparently this solution is much shorter than the \"easier\" problem's :)Congratulations Petr and tourist for the only persons solving this problem in-contest both on-site and off-site!335F - Buy One, Get One Free -- pieguyThis problem is equivalent to maximizing the total value of items that we can get for free.First, process the items into <#value, #number_of_items_with_that_value> tuples, which means we have #number_of_items_with_that_value items of value #value. Then, sort the tuples in descending order of #value.Iterate over those tuples and let #pieguy be an empty multi set()For each tuple <#val, #num>, we can calculate #max_free, the maximum number of items (not value) that we can get for free up to this point easily.So, we want to populate #pieguy so that it contains exactly #max_free “things”. #pieguy is special, in that we can compute the maximum price that we can get for free for n items by summing up the n most expensive items in #pieguy. How could #pieguy do that?For now, you may assume that each element of #pieguy contains the value of a single item that can be gotten for free. Thus, summing n items = value of n items that can be gotten for free. This is not correct, of course, since not all n arbitrary items can be simultaneously gotten for free in tandem, but we’ll come back to it later.We’re now at <#val, #num>, and we have #pieguy from previous iteration. #pieguy contains the previous #max_free elements. Assume that #num <= number of items more expensive than this value, for otherwise the remainder are ‘dead’ and useless for our current purpose. In particular, for the first tuple we process, we assume that #num is 0, since all of them cannot be gotten for free.Suppose we want to obtain exactly #max_free items. How many of the #num must we use?Let’s arrange the current members of #pieguy in descending order. For example, if #pieguy has 5 members: A B C D ELet’s arrange #num #val under #pieguy so that the rightmost one is located on position #max_free. For example, if #num is 6 and #max_free is 8 and #val is V.... A B C D E\n V V V V V VThese 6 Vs will be competing for a spot in #pieguy.Now...1) what happens if C < V? This means, instead of making C free, we can make V free instead! (if you’re wondering why this is possible, remember that #pieguy definition I gave you was not entirely honest yet). So, we replace C, D and E with all Vs, and we get our new #pieguy! A B V V V V V V (this should be sorted again, but C++’s multiset does that automagically).2) otherwise, C > V. So, V cannot contend for the 3-th place in #pieguy, it has to contend for a place larger than or equal to the 4-th.Now the fun begins! If you want to contend for the 4-th place, any solution MUST HAVE AT LEAST 2 V s (remember that the 4-th place is used in a solution consisting of at least 4 free items). In general, if you want to contend for the #max_free — i -th place, you MUST HAVE AT LEAST #num — i Vs. #proof? is easy, exercise (i’m honest!)Okay, so back to contending for the 4-th place. If D is still > V, we proceed. Otherwise, we know that D < V. This means, E and any element after E is also < V! Thus, we can replace all elements after or equal to E with V! The problem would be the final element of #pieguy.When the final element of #pieguy is included in the sum, it is only included in the sum of all n elements of #pieguy. You do this when you want to calculate the maximum sum of values of free items you can get when getting exactly #max_free items. Any such solution must include all #num elements with value #val. We have included #num-2 Vs in #pieguy. Thus, the final element of #pieguy must somehow contains 2 Vs! So, elements of #pieguy actually can do this. Instead of containing a single elmeent, each element of #pieguy is more of an “operation” that adds several value and removes several value. In our case, we want to add 2 Vs and remove something. The something? The smallest element that we can remove (the ones that we haven't removed)! C! (if you're wondering why not D or E, it's because (again) #pieguy is special -- it only forms a solution if the most expensive t are summed, not if some are skipped. -- we cannot skip C if we want to use D).So, Insert 2V — C into #pieguy, and the rest, insert V into #pieguy. 2V — C is < V, so summing all elements of #pieguy correctly found out the max value when we receive #max_free free items!Right! Cool! ...except that 2V — C can be negative. Why would we want to insert negative stuffs into #pieguy? We don’t! Actually, we check if 2V — C is negative. If it is, we continue instead, and check 3V — C — D and so on, under the same reason.That’s it folks! I skipped some details of why this works (for example, that the number of V selected is always sufficient to guarantee solution in #pieguy), but they're easier to see once you get this large idea. The result is then #pieguy.last_elementSee pieguy's beautiful 4234458.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8538",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 335\\s*A"
          },
          "content_length": 17873
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 1",
          "code": "*--st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 2",
          "code": "*----st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 3",
          "code": "*--st.lower_bound(*--st.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 4",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 5",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 1",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 2",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 3",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 4",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 5",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 6",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 7",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 8",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 9",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 10",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 11",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 12",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 13",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 14",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 15",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 16",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 17",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 18",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 19",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 20",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 21",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 22",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 23",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 24",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 25",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 26",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 27",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 28",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 29",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 30",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 31",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 32",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n\n    // Read n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n\n    // Read n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n\n    // Read n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    string s = inf.readToken();\n    int n = inf.readInt();\n    \n    int k_jury = ans.readInt();\n    string t_jury;\n    if (k_jury != -1) {\n        t_jury = ans.readToken();\n        if ((int)t_jury.length() != n)\n            ans.quitf(_fail, \"Jury's sheet description t must be of length n\");\n        for (char c : t_jury) {\n            if (c < 'a' || c > 'z')\n                ans.quitf(_fail, \"Jury's sheet description t must consist of lowercase English letters only\");\n        }\n        // Optional: Check if jury's solution can form s\n        vector<int> count_s(26, 0), count_t(26, 0);\n        for (char c : s)\n            count_s[c - 'a']++;\n        for (char c : t_jury)\n            count_t[c - 'a']++;\n        for (int i = 0; i < 26; i++) {\n            if (count_s[i] > count_t[i] * k_jury)\n                ans.quitf(_fail, \"Jury's solution cannot form s from k sheets of t\");\n        }\n    }\n    \n    int k_contestant = ouf.readInt();\n    if (k_contestant == -1) {\n        if (k_jury == -1)\n            quitf(_ok, \"Correctly outputs -1\");\n        else\n            quitf(_wa, \"Participant outputs -1 but solution exists with k=%d\", k_jury);\n    } else {\n        string t_contestant = ouf.readToken();\n        if ((int)t_contestant.length() != n)\n            ouf.quitf(_wa, \"The sheet description t must be of length n\");\n        for (char c : t_contestant) {\n            if (c < 'a' || c > 'z')\n                ouf.quitf(_wa, \"The sheet description t must consist of lowercase English letters only\");\n        }\n        \n        if (k_jury == -1)\n            quitf(_fail, \"Participant found solution with k=%d but jury says impossible\", k_contestant);\n        else if (k_contestant > k_jury)\n            quitf(_wa, \"Participant's k=%d is greater than minimal k=%d\", k_contestant, k_jury);\n        else if (k_contestant < k_jury)\n            quitf(_fail, \"Participant found better solution with k=%d, jury has k=%d\", k_contestant, k_jury);\n        else {\n            // Check if s can be formed from k_contestant copies of t_contestant\n            vector<int> count_s(26, 0), count_t(26, 0);\n            for (char c : s)\n                count_s[c - 'a']++;\n            for (char c : t_contestant)\n                count_t[c - 'a']++;\n            bool possible = true;\n            for (int i = 0; i < 26; i++) {\n                if (count_s[i] > count_t[i] * k_contestant) {\n                    possible = false;\n                    break;\n                }\n            }\n            if (possible)\n                quitf(_ok, \"Correct answer\");\n            else\n                quitf(_wa, \"Cannot form s from k sheets of t\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len_s = opt<int>(\"len_s\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure len_s and n are within the problem constraints\n    len_s = max(1, min(len_s, 1000));\n    n = max(1, min(n, 1000));\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string s of length len_s\n        s.resize(len_s);\n        for (int i = 0; i < len_s; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"single_char\") {\n        // Generate a string s of length len_s with a single repeated character\n        char c = 'a' + rnd.next(26);\n        s = string(len_s, c);\n    } else if (type == \"impossible\") {\n        if (n >= 1 && len_s >= n + 1) {\n            // Create an impossible case where one character appears more than n times\n            char c = 'a' + rnd.next(26);\n            s = string(n + 1, c);\n            // Add other random characters if len_s > n + 1\n            for (int i = n + 1; i < len_s; ++i) {\n                char d;\n                do {\n                    d = 'a' + rnd.next(26);\n                } while (d == c);\n                s += d;\n            }\n            // Shuffle the string s\n            shuffle(s.begin(), s.end());\n        } else {\n            // If len_s is too small or n is too large, generate a random impossible case\n            s.resize(len_s);\n            for (int i = 0; i < len_s; ++i) {\n                s[i] = 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"max_sheets\") {\n        // Generate s with unique characters to maximize the number of sheets needed\n        s.resize(len_s);\n        set<char> used_chars;\n        for (int i = 0; i < len_s; ++i) {\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (used_chars.count(c) && used_chars.size() < 26);\n            used_chars.insert(c);\n            s[i] = c;\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate edge case strings\n        s.resize(len_s);\n        for (int i = 0; i < len_s; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else {\n        // Default to random string generation\n        s.resize(len_s);\n        for (int i = 0; i < len_s; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    }\n\n    // Ensure s is within the problem constraints\n    if (s.size() < 1 || s.size() > 1000) {\n        s.resize(max(1, min((int)s.size(), 1000)));\n    }\n\n    // Output s and n\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len_s = opt<int>(\"len_s\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure len_s and n are within the problem constraints\n    len_s = max(1, min(len_s, 1000));\n    n = max(1, min(n, 1000));\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string s of length len_s\n        s.resize(len_s);\n        for (int i = 0; i < len_s; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"single_char\") {\n        // Generate a string s of length len_s with a single repeated character\n        char c = 'a' + rnd.next(26);\n        s = string(len_s, c);\n    } else if (type == \"impossible\") {\n        if (n >= 1 && len_s >= n + 1) {\n            // Create an impossible case where one character appears more than n times\n            char c = 'a' + rnd.next(26);\n            s = string(n + 1, c);\n            // Add other random characters if len_s > n + 1\n            for (int i = n + 1; i < len_s; ++i) {\n                char d;\n                do {\n                    d = 'a' + rnd.next(26);\n                } while (d == c);\n                s += d;\n            }\n            // Shuffle the string s\n            shuffle(s.begin(), s.end());\n        } else {\n            // If len_s is too small or n is too large, generate a random impossible case\n            s.resize(len_s);\n            for (int i = 0; i < len_s; ++i) {\n                s[i] = 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"max_sheets\") {\n        // Generate s with unique characters to maximize the number of sheets needed\n        s.resize(len_s);\n        set<char> used_chars;\n        for (int i = 0; i < len_s; ++i) {\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (used_chars.count(c) && used_chars.size() < 26);\n            used_chars.insert(c);\n            s[i] = c;\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate edge case strings\n        s.resize(len_s);\n        for (int i = 0; i < len_s; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else {\n        // Default to random string generation\n        s.resize(len_s);\n        for (int i = 0; i < len_s; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    }\n\n    // Ensure s is within the problem constraints\n    if (s.size() < 1 || s.size() > 1000) {\n        s.resize(max(1, min((int)s.size(), 1000)));\n    }\n\n    // Output s and n\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len_s 5 -n 5 -type random\n./gen -len_s 500 -n 500 -type random\n./gen -len_s 1000 -n 1000 -type random\n./gen -len_s 10 -n 2 -type single_char\n./gen -len_s 1000 -n 1000 -type single_char\n./gen -len_s 10 -n 2 -type impossible\n./gen -len_s 5 -n 100 -type impossible\n./gen -len_s 11 -n 10 -type impossible\n./gen -len_s 100 -n 1 -type max_sheets\n./gen -len_s 500 -n 10 -type max_sheets\n./gen -len_s 1000 -n 100 -type max_sheets\n./gen -len_s 1000 -n 1 -type edge_cases\n./gen -len_s 1 -n 1000 -type edge_cases\n./gen -len_s 1000 -n 1000 -type edge_cases\n./gen -len_s 500 -n 1 -type random\n./gen -len_s 500 -n 1000 -type random\n./gen -len_s 500 -n 500 -type single_char\n./gen -len_s 501 -n 500 -type impossible\n./gen -len_s 26 -n 1 -type max_sheets\n./gen -len_s 26 -n 26 -type max_sheets\n./gen -len_s 999 -n 999 -type random\n./gen -len_s 1 -n 1 -type single_char\n./gen -len_s 2 -n 1 -type impossible\n./gen -len_s 1000 -n 1 -type single_char\n./gen -len_s 1 -n 1000 -type single_char\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:50.316979",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "335/B",
      "title": "B. Palindrome",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input contains one string s of length n (1 ≤ n ≤ 5·104) containing only lowercase English letters.",
      "output_spec": "OutputIf s contains a palindrome of length exactly 100 as a subsequence, print any palindrome of length 100 which is a subsequence of s. If s doesn't contain any palindromes of length exactly 100, print a palindrome that is a subsequence of s and is as long as possible.If there exists multiple answers, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopybbbabcbbbOutputCopybbbcbbbInputCopyrquwmzexectvnbanemsmdufrgOutputCopyrumenanemur",
      "description": "B. Palindrome\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of the input contains one string s of length n (1 ≤ n ≤ 5·104) containing only lowercase English letters.\n\nOutputIf s contains a palindrome of length exactly 100 as a subsequence, print any palindrome of length 100 which is a subsequence of s. If s doesn't contain any palindromes of length exactly 100, print a palindrome that is a subsequence of s and is as long as possible.If there exists multiple answers, you are allowed to print any of them.\n\nInputCopybbbabcbbbOutputCopybbbcbbbInputCopyrquwmzexectvnbanemsmdufrgOutputCopyrumenanemur\n\nInputCopybbbabcbbb\n\nOutputCopybbbcbbb\n\nInputCopyrquwmzexectvnbanemsmdufrg\n\nOutputCopyrumenanemur\n\nNoteA subsequence of a string is a string that can be derived from it by deleting some characters without changing the order of the remaining characters. A palindrome is a string that reads the same forward or backward.",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL start[c]up will take place on August, 3rd, 10:00am PDT. There will be two contests running simultaneously, one for people who participate onsite, and one for everybody else who advanced to the round two. Both rounds share the problemset and are rated based on the combined scoreboard.Onsite participants will have special prizes for first three places. All onsite participants as well as the top 100 in the online contest will receive a start[c]up t-shirt.People who have not advanced to the round two can participate in the round unofficially. Unofficial participation will be rated.The contest will be 3 hours long, and will feature 6 problems. The score distribution is 500-1000-1000-2000-2500-3000.The problem set has been developed by MemSQL engineers pieguy, nika, exod40, SkidanovAlex and dolphinigle.Good luck and happy coding!UPDATE: Editorial is up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8506",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces",
          "content": "This is the Editorial for MemSQL start[c]up Round 2 and MemSQL start[c]up Round 2 - online version. Congratulations RAD for online round winner and Petr for onsite and overall score winner!This editorial is written jointly by the contest's coordinators (i.e., MemSQL engineers).335A - Banana -- AlexSkidanovReference solution: Jimanbanashi's 4222182Instead of calculating the smallest possible number of sheets given a fixed n, let us instead try to compute the smallest possible value of n given a fixed number of sheets. Let k denote the number of sheets. If a particular letter appears p times in s, then it must appear at least ceil(p / k) times in the sheet. Thus we can compute the smallest possible value of n by summing ceil(p / k) over all letters. Now the original problem can be solved using binary search on k (or brute force, since the constraints were small enough).335B - Palindrome -- AlexSkidanovThere’s a well known O(n2) solution that allows one to find a longest subsequence of a string which is a palindrome: for every pair of positions l and r, such that l ≤ r, find the length d of the longest palindrome subsequence between those positions. d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).There are two ways to solve this problem faster than O(n2) with the constraints given in the problem: Use dynamic programming. For every position l and length k find the leftmost position r, such that there’s a palindrome of length k in the substring of s starting at l and ending at r. For position l and length k r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),where next(pos, s) is the next occurrence of character s after position pos. Next can be precomputed for all the positions and all the characters in advance. See DamianS's 4221965. If length is less than 2600, use the well-known O(n2) dynamic programming approach. Otherwise by pigeonhole principle there’s at least one character that appears in the string at least 100 times -- find it and print it 100 times. See SteamTurbine's 4224770. 335C - More Reclamation -- AlexSkidanovThe most straightforward way to solve this problem is to use Grundy numbers. Define a segment as a maximal range of rows in which no cells have been reclaimed. Since segments have no bearing on other segments, they can be assigned Grundy numbers. There are 4 types of segments: The entire river. A section of river containing one of the ends. A section of river blocked at both ends in the same column A section of river blocked at both ends in different columns Each time a cell is reclaimed, it splits a segment into 2 segments (one of which may have size 0). We can compute the Grundy value for all possible segments in O(r2). Then after sorting the reclaimed cells by row number, we can find all segments and compute the Grundy number for the full state.See Dmitry_Egorov's 4221888.Alternatively, we can compute the result directly. Suppose the game is over. We can determine who won the game just by looking at the top row and the bottom row. Let us define “parity” as the modulo 2 remainder of (r + n + c0 + c1), where c0 is the column of the reclaimed cell with the lowest row, and c1 is the column of the reclaimed cell with the highest row. Claim: when the game is over, the parity is even. This can be seen by observing that the number of empty rows is equal to the number of times the column changes. In other words, if c0==c1, there are an even number of empty rows, otherwise an odd number of empty rows. Now, given r, c0, and c1, we can determine n, and therefore the winner.Let us consider the case where there are no reclaimed cells. If r is even, then the second city can win with a mirroring strategy. When the first city reclaims cell (a,b), the second city follows with (r+1-a,b). Similarly, if r is odd then the first city wins by a mirroring strategy, playing first in ((r+1)/2, 0), and subsequently following the strategy for even r.Now suppose there are reclaimed cells. Let us define r0 as the number of empty rows in the segment starting from one end, and r1 as the number of empty rows starting from the other end.Case 1: if r0==r1 and the parity is even, the state is losing. All available moves will either decrease r0, decrease r1, or make the parity odd. The other player can respond to the first two types of moves with a mirroring strategy, and the third by making the parity even again (there will always be such a move that doesn’t affect r0 or r1, based on the fact that the argument above).Case 2: if abs(r0-r1)>=2 then the state is winning. Suppose, without loss of generality, that r0-r1>=2. Then either of the cells (r1+1, 1) and (r1+1, 2) may be reclaimed, and one of them must lead to Case 1 (since they both result in r0==r1, and one will have even parity and the other odd).Case 3: if abs(r0-r1)<2 and the parity is odd, the state is winning. If r0==r1, then we can change the parity without affecting r0 or r1, leaving our opponent in Case 1. Otherwise, there is a unique move that leaves our opponent in Case 1.(note that cases 2 and 3 together imply that all states with odd parity are winning)Case 4: if abs(r0-r1)==1 and the parity is even, there is at most one move that doesn’t leave our opponent in Case 2 or Case 3. Suppose r0==r1+1. We must change either r0 or r1, since all other moves will change the parity to odd. Thus our only option is to decrease r0, since decreasing r1 would leave our opponent in Case 2. We could decrease r0 by 1, but doing so would change the parity. Thus we must decrease r0 by 2, and there is at most one move that does so and keeps the parity even. It follows that if floor(r0/2)+floor(r1/2) is even, then this is a losing position, otherwise a winning position.See jill-jenn's extremely short 4225125.335D - Rectangles and Square -- AlexSkidanovEven though constraints were allowing O(k^2) solutions, in this editorial we will describe an O(n log(n)) solution. This problem has a rather long solution, involving several very different ideas: On the first step, for every rectangle we want to determine, if we were to consider this rectangle as the top left corner of a square, how long could the top and left edge of the square be (see the picture).If there’s no rectangle that is adjacent to the current rectangle on the right, which has the same y1 coordinate, then the top edge length is just the width of the current rectangle. Otherwise it is the width of the current rectangle plus the max top edge computed for the rectangle adjacent on the right. Left edge length is computed likewise.When top and left edge lengths are computed, we want to compute the max bottom and right edge length if this rectangle was the bottom right corner of the square.On the second step, we want to find all possible square frames. Look at this picture to better understand what we mean by square frame:To find a frame, let’s sort all the points first by x - y, and then by x (or y -- both will yield the same result). This way all the points are sorted by the diagonal they belong to, and then by the position on that diagonal. Then we will maintain a stack of pairs (position, edge length), where edge length is min(top edge length, left edge length). Position could be either x or y (within a given diagonal relative differences in xs and ys are the same). Min edge length tells us what is the largest square that could start at that position.When we process a new point on a diagonal, first pop from the stack all the pairs such that their position + edge length is less than our position. If stack after that is empty, then the current point cannot be a bottom right corner of any square. If stack is not empty, then there could be some frames with the current point being bottom right corner.Here we need to make a very important observation. If a square frame is contained within some other square frame, we don’t need to consider the outer square frame, since if the outer square frame is then proves to be an actual square, then the inner frame also has to be an actual square, and it is enough to only check an inner frame.With this observation made, we can only check if the last point on the stack forms a frame with the current point, there’s no need to check any other point on the stack. Since we already know that last element on the stack reaches to the right and to the bottom further than our current position (otherwise we would have popped it from the stack), to see if we form a frame with that point it is enough to check if we can reach that far to the top and to the left. To do so, check, if position of the current point minus min(bottom edge length, right edge length) for the current point is smaller or equal than the position of the point that is at the top of the stack. If it is, we have a square frame.When we have a frame, we move to the third step, where we check if the frame is filled in. To do that we just want to check if area within that square that is filled in by rectangles is equal to the area of the square. For every corner of every rectangle we will compute the area covered by rectangles which are fully located to the left and top from that point. To do that we can sort all the corners by x, and then by y, and process them one by one. We will maintain an interval tree where value at every position y represents area covered by rectangles processed so far that are fully above y. Then when we process a corner, we first update the interval tree if the corner is a bottom right corner, and then query the interval tree to see the area covered by rectangles to the up and left from the current corner.Then, when we have these number precomputed, for every square frame x1, y1, x2, y2 we can just get the area for (x2, y2), add area for (x1, y1) and subtract for (x2, y1) and for (x1, y2). See the author (AlexSkidanov)'s 4234601A possible O(k2) solution is similar, but makes checking whether or not the frame is filled much and a bunch of other checks easier. See my 4234474.335E - Counting Skyscrapers -- pieguyThe skyscrapers in this problem depict a data structure called Skip List. Skip list is similar to AVL and red black trees in a sense that it allows O(log N) insertions, deletions and searches (including searching for lower and upper bounds), as well as moving to the next element in sorted order in constant time. Skiplist is different from any tree structures because it has a practical thread safe implementation without locks (so-called lock-free). Lock free skiplists are used as a main data structure to store data in MemSQL, and the algorithm that Bob uses to traverse the skyscrapers is an O(log N) approach, that allows one to estimate the size of the skiplist. Thus, if Bob ended up with an estimation of n, the actual skiplist size is expected to be n (so if the first line of the input file is Bob, one just needs to print the number from the second line to the output). Formal proof is rather simple, and is left to the reader. Curiously, the converse does not hold. If the skiplist size is n, the expected return value of the estimation algorithm could be bigger than n. For an n that is significantly bigger than 2h the estimate converges to n - 1 + 2h, but this problem included cases with smaller n as well.Let us build up the solution one level at a time. When H is 0, the expected sum is N. Now for each additional level, we can add the expected cost of the zip lines on that level, and subtract the expected cost of the zip lines immediately below them. In the end we’ll have the total expected cost.For some floor number H, let’s consider some left and right tower, and determine the probability that a zip line exists between them. Let L be the distance between the two towers. A potential zip line of length L and height H exists if the towers at both ends are tall enough (probability 1 / 2H for each one), and the L - 1 towers between them are all shorter (probability 1 - 1 / 2H for each). Thus the probability that such a zip line exists is 1 / 22 * H × (1 - 1 / 2H)L - 1.Now, assuming that such a zip line exists, what’s the expected number of zip lines immediately below it? This is simply one more than the number of towers of height H - 1. Each of the L - 1 towers has probability 1 / (2H - 1) of having height H-1 (given that it has height at most H-1) -- use conditional probability () to calculate this. Thus the expected number of zip lines immediately below a zip line of length L and height H is 1 + (L - 1) / (2H - 1).For each length L, there are N - L possible zip lines with this length on each level. We multiply probability by cost for all possible zip lines to attain the expected value.The final answer is thereforeIt turns out the inner loop can be computed using matrix multiplication, for a running time of O(H log N). -- although the constraints is low enough that using matrix multiplication is an overkill -- O(H * N) will do.See the author (pieguy)'s 4234465. ...apparently this solution is much shorter than the \"easier\" problem's :)Congratulations Petr and tourist for the only persons solving this problem in-contest both on-site and off-site!335F - Buy One, Get One Free -- pieguyThis problem is equivalent to maximizing the total value of items that we can get for free.First, process the items into <#value, #number_of_items_with_that_value> tuples, which means we have #number_of_items_with_that_value items of value #value. Then, sort the tuples in descending order of #value.Iterate over those tuples and let #pieguy be an empty multi set()For each tuple <#val, #num>, we can calculate #max_free, the maximum number of items (not value) that we can get for free up to this point easily.So, we want to populate #pieguy so that it contains exactly #max_free “things”. #pieguy is special, in that we can compute the maximum price that we can get for free for n items by summing up the n most expensive items in #pieguy. How could #pieguy do that?For now, you may assume that each element of #pieguy contains the value of a single item that can be gotten for free. Thus, summing n items = value of n items that can be gotten for free. This is not correct, of course, since not all n arbitrary items can be simultaneously gotten for free in tandem, but we’ll come back to it later.We’re now at <#val, #num>, and we have #pieguy from previous iteration. #pieguy contains the previous #max_free elements. Assume that #num <= number of items more expensive than this value, for otherwise the remainder are ‘dead’ and useless for our current purpose. In particular, for the first tuple we process, we assume that #num is 0, since all of them cannot be gotten for free.Suppose we want to obtain exactly #max_free items. How many of the #num must we use?Let’s arrange the current members of #pieguy in descending order. For example, if #pieguy has 5 members: A B C D ELet’s arrange #num #val under #pieguy so that the rightmost one is located on position #max_free. For example, if #num is 6 and #max_free is 8 and #val is V.... A B C D E\n V V V V V VThese 6 Vs will be competing for a spot in #pieguy.Now...1) what happens if C < V? This means, instead of making C free, we can make V free instead! (if you’re wondering why this is possible, remember that #pieguy definition I gave you was not entirely honest yet). So, we replace C, D and E with all Vs, and we get our new #pieguy! A B V V V V V V (this should be sorted again, but C++’s multiset does that automagically).2) otherwise, C > V. So, V cannot contend for the 3-th place in #pieguy, it has to contend for a place larger than or equal to the 4-th.Now the fun begins! If you want to contend for the 4-th place, any solution MUST HAVE AT LEAST 2 V s (remember that the 4-th place is used in a solution consisting of at least 4 free items). In general, if you want to contend for the #max_free — i -th place, you MUST HAVE AT LEAST #num — i Vs. #proof? is easy, exercise (i’m honest!)Okay, so back to contending for the 4-th place. If D is still > V, we proceed. Otherwise, we know that D < V. This means, E and any element after E is also < V! Thus, we can replace all elements after or equal to E with V! The problem would be the final element of #pieguy.When the final element of #pieguy is included in the sum, it is only included in the sum of all n elements of #pieguy. You do this when you want to calculate the maximum sum of values of free items you can get when getting exactly #max_free items. Any such solution must include all #num elements with value #val. We have included #num-2 Vs in #pieguy. Thus, the final element of #pieguy must somehow contains 2 Vs! So, elements of #pieguy actually can do this. Instead of containing a single elmeent, each element of #pieguy is more of an “operation” that adds several value and removes several value. In our case, we want to add 2 Vs and remove something. The something? The smallest element that we can remove (the ones that we haven't removed)! C! (if you're wondering why not D or E, it's because (again) #pieguy is special -- it only forms a solution if the most expensive t are summed, not if some are skipped. -- we cannot skip C if we want to use D).So, Insert 2V — C into #pieguy, and the rest, insert V into #pieguy. 2V — C is < V, so summing all elements of #pieguy correctly found out the max value when we receive #max_free free items!Right! Cool! ...except that 2V — C can be negative. Why would we want to insert negative stuffs into #pieguy? We don’t! Actually, we check if 2V — C is negative. If it is, we continue instead, and check 3V — C — D and so on, under the same reason.That’s it folks! I skipped some details of why this works (for example, that the number of V selected is always sufficient to guarantee solution in #pieguy), but they're easier to see once you get this large idea. The result is then #pieguy.last_elementSee pieguy's beautiful 4234458.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8538",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 335\\s*B"
          },
          "content_length": 17873
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 1",
          "code": "*--st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 2",
          "code": "*----st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 3",
          "code": "*--st.lower_bound(*--st.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 4",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 5",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 1",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 2",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 3",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 4",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 5",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 6",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 7",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 8",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 9",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 10",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 11",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 12",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 13",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 14",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 15",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 16",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 17",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 18",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 19",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 20",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 21",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 22",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 23",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 24",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 25",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 26",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 27",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 28",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 29",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 30",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 31",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 32",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,50000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,50000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,50000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Checks if 'sub' is a subsequence of 's'.\nbool isSubsequence(const string &s, const string &sub) {\n    int idx = 0;\n    for (char c : s) {\n        if (idx < (int)sub.size() && c == sub[idx]) {\n            idx++;\n            if (idx == (int)sub.size()) break;\n        }\n    }\n    return (idx == (int)sub.size());\n}\n\n// Checks if 'p' is a palindrome.\nbool isPalindrome(const string &p) {\n    int left = 0, right = (int)p.size() - 1;\n    while (left < right) {\n        if (p[left] != p[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n\n// Reads exactly one line (the supposed palindrome subsequence) from the given stream.\n// Returns that line and also checks if it is indeed a valid solution (a palindrome) \n// with respect to the given input `s`. If invalid and stream == ouf, we produce WA;\n// if invalid and stream == ans, we produce FAIL.\nint readAndCheckSolution(InStream &stream, const string &s) {\n    // Read the entire output line as the candidate palindrome\n    string candidate = stream.readLine();\n\n    // Quick length check: cannot exceed length of s if it is a subsequence\n    if ((int)candidate.size() > (int)s.size()) {\n        stream.quitf(_wa, \"the output is longer than the input, cannot be a subsequence\");\n    }\n\n    // Check palindrome property\n    if (!isPalindrome(candidate)) {\n        stream.quitf(_wa, \"the output string is not a palindrome\");\n    }\n\n    // Check subsequence property\n    if (!isSubsequence(s, candidate)) {\n        stream.quitf(_wa, \"the output string is not a subsequence of the input\");\n    }\n\n    return (int)candidate.size();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input string s\n    string s = inf.readLine();\n\n    // Read and check jury's solution\n    int jlen = readAndCheckSolution(ans, s);\n\n    // Read and check participant's solution\n    int plen = readAndCheckSolution(ouf, s);\n\n    // Now apply the problem logic:\n    // If the jury's solution length jlen == 100, that means\n    // there is a palindrome subsequence of length 100 in s.\n    // The participant must also output a palindrome of length 100.\n    // Otherwise, jlen < 100; that means s has no palindrome subsequence of length 100,\n    // and jlen is presumably the maximum possible palindrome subsequence length.\n    \n    if (jlen == 100) {\n        // Then the participant MUST provide a palindrome subsequence of length 100 as well\n        if (plen < 100) {\n            quitf(_wa, \"there is a length-100 palindrome in input, but participant printed a shorter one\");\n        } else if (plen > 100) {\n            // If the participant claims more than 100, that contradicts the condition\n            // that if there's a subsequence palindrome of >=100, you must print exactly 100.\n            // Following the style of sample checkers, we do:\n            quitf(_fail, \"participant's palindrome length is %d, but jury's is 100\", plen);\n        } else {\n            // plen == 100 => correct\n            quitf(_ok, \"correct length 100 palindrome\");\n        }\n    } else {\n        // jlen < 100 => no palindrome subsequence of length 100 in s.\n        // jlen is the maximum possible palindrome subsequence length.\n        if (plen >= 100) {\n            // The participant found a length >= 100 palindrome, which means they outperformed\n            // the jury's solution -> potential mistake in the jury or participant\n            quitf(_fail, \"participant found palindrome length %d >= 100, but jury found < 100\", plen);\n        }\n        if (plen < jlen) {\n            quitf(_wa, \"participant's palindrome has length %d but maximum possible is %d\", plen, jlen);\n        } else if (plen == jlen) {\n            quitf(_ok, \"correct palindrome of length %d\", plen);\n        } else {\n            // plen > jlen\n            quitf(_fail, \"participant's palindrome length is %d > jury's %d\", plen, jlen);\n        }\n    }\n    return 0; // not reached\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s;\n    \n    if (type == \"random\") {\n        /* Generate random string of length n */\n        for (int i = 0; i < n; ++i) {\n            s += (char)rnd.next('a', 'z');\n        }\n    } else if (type == \"all_same\") {\n        /* Generate string of length n with the same character */\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"palindrome_length_100\") {\n        /* Generate a string that contains a palindrome of length exactly 100 as a subsequence */\n        if (n < 100) n = 100;\n        s = \"\";\n        string pal;\n        for (int i = 0; i < 50; ++i) {\n            char c = rnd.next('a', 'z');\n            pal += c;\n        }\n        string pal_rev = pal;\n        reverse(pal_rev.begin(), pal_rev.end());\n        string palindrome = pal + pal_rev; // Length 100 palindrome\n        s += palindrome;\n        // Add random characters to reach length n\n        while ((int)s.length() < n) {\n            s += (char)rnd.next('a', 'z');\n        }\n        // Shuffle the string to hide the palindrome\n        shuffle(s.begin(), s.end());\n    } else if (type == \"no_palindrome_length_100\") {\n        /* Generate a string where the longest palindromic subsequence is less than 100 */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + (i % 10)); // Use only 10 different characters\n        }\n    } else if (type == \"max_palindrome\") {\n        /* Generate a palindrome of length n */\n        string half;\n        for (int i = 0; i < n / 2; ++i) {\n            half += (char)rnd.next('a', 'z');\n        }\n        s = half;\n        if (n % 2 == 1)\n            s += (char)rnd.next('a', 'z'); // Middle character\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (type == \"min_palindrome\") {\n        /* Generate a string where the longest palindromic subsequence is small */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)(('a' + i) % 'z'); // Try to avoid repeating characters\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"cyclic\") {\n        /* Generate a string where s[i] = 'a' + (i % 26) */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + (i % 26));\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i) {\n            s += (char)rnd.next('a', 'z');\n        }\n    }\n    \n    /* Output s */\n    printf(\"%s\\n\", s.c_str());\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s;\n    \n    if (type == \"random\") {\n        /* Generate random string of length n */\n        for (int i = 0; i < n; ++i) {\n            s += (char)rnd.next('a', 'z');\n        }\n    } else if (type == \"all_same\") {\n        /* Generate string of length n with the same character */\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"palindrome_length_100\") {\n        /* Generate a string that contains a palindrome of length exactly 100 as a subsequence */\n        if (n < 100) n = 100;\n        s = \"\";\n        string pal;\n        for (int i = 0; i < 50; ++i) {\n            char c = rnd.next('a', 'z');\n            pal += c;\n        }\n        string pal_rev = pal;\n        reverse(pal_rev.begin(), pal_rev.end());\n        string palindrome = pal + pal_rev; // Length 100 palindrome\n        s += palindrome;\n        // Add random characters to reach length n\n        while ((int)s.length() < n) {\n            s += (char)rnd.next('a', 'z');\n        }\n        // Shuffle the string to hide the palindrome\n        shuffle(s.begin(), s.end());\n    } else if (type == \"no_palindrome_length_100\") {\n        /* Generate a string where the longest palindromic subsequence is less than 100 */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + (i % 10)); // Use only 10 different characters\n        }\n    } else if (type == \"max_palindrome\") {\n        /* Generate a palindrome of length n */\n        string half;\n        for (int i = 0; i < n / 2; ++i) {\n            half += (char)rnd.next('a', 'z');\n        }\n        s = half;\n        if (n % 2 == 1)\n            s += (char)rnd.next('a', 'z'); // Middle character\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (type == \"min_palindrome\") {\n        /* Generate a string where the longest palindromic subsequence is small */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)(('a' + i) % 'z'); // Try to avoid repeating characters\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"cyclic\") {\n        /* Generate a string where s[i] = 'a' + (i % 26) */\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + (i % 26));\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i) {\n            s += (char)rnd.next('a', 'z');\n        }\n    }\n    \n    /* Output s */\n    printf(\"%s\\n\", s.c_str());\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type random\n\n./gen -n 100 -type palindrome_length_100\n./gen -n 500 -type palindrome_length_100\n./gen -n 1000 -type palindrome_length_100\n./gen -n 5000 -type palindrome_length_100\n./gen -n 50000 -type palindrome_length_100\n\n./gen -n 100 -type no_palindrome_length_100\n./gen -n 5000 -type no_palindrome_length_100\n./gen -n 50000 -type no_palindrome_length_100\n\n./gen -n 100 -type all_same\n./gen -n 50000 -type all_same\n\n./gen -n 100 -type max_palindrome\n./gen -n 50000 -type max_palindrome\n\n./gen -n 100 -type min_palindrome\n./gen -n 50000 -type min_palindrome\n\n./gen -n 50 -type cyclic\n./gen -n 100 -type cyclic\n./gen -n 5000 -type cyclic\n./gen -n 50000 -type cyclic\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:52.224850",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "335/C",
      "title": "C. More Reclamation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line consists of two integers r and n (1 ≤ r ≤ 100, 0 ≤ n ≤ r). Then n lines follow, describing the cells that were already reclaimed. Each line consists of two integers: ri and ci (1 ≤ ri ≤ r, 1 ≤ ci ≤ 2), which represent the cell located at row ri and column ci. All of the lines describing the cells will be distinct, and the reclaimed cells will not violate the constraints above.",
      "output_spec": "OutputOutput \"WIN\" if the city whose turn it is to choose a cell can guarantee that they will be the last to choose a cell. Otherwise print \"LOSE\".",
      "sample_tests": "ExamplesInputCopy3 11 1OutputCopyWINInputCopy12 24 18 1OutputCopyWINInputCopy1 11 2OutputCopyLOSE",
      "description": "C. More Reclamation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line consists of two integers r and n (1 ≤ r ≤ 100, 0 ≤ n ≤ r). Then n lines follow, describing the cells that were already reclaimed. Each line consists of two integers: ri and ci (1 ≤ ri ≤ r, 1 ≤ ci ≤ 2), which represent the cell located at row ri and column ci. All of the lines describing the cells will be distinct, and the reclaimed cells will not violate the constraints above.\n\nOutputOutput \"WIN\" if the city whose turn it is to choose a cell can guarantee that they will be the last to choose a cell. Otherwise print \"LOSE\".\n\nInputCopy3 11 1OutputCopyWINInputCopy12 24 18 1OutputCopyWINInputCopy1 11 2OutputCopyLOSE\n\nInputCopy3 11 1\n\nOutputCopyWIN\n\nInputCopy12 24 18 1\n\nOutputCopyWIN\n\nInputCopy1 11 2\n\nOutputCopyLOSE\n\nNoteIn the first example, there are 3 possible cells for the first city to reclaim: (2, 1), (3, 1), or (3, 2). The first two possibilities both lose, as they leave exactly one cell for the other city.  However, reclaiming the cell at (3, 2) leaves no more cells that can be reclaimed, and therefore the first city wins.  In the third example, there are no cells that can be reclaimed.",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL start[c]up will take place on August, 3rd, 10:00am PDT. There will be two contests running simultaneously, one for people who participate onsite, and one for everybody else who advanced to the round two. Both rounds share the problemset and are rated based on the combined scoreboard.Onsite participants will have special prizes for first three places. All onsite participants as well as the top 100 in the online contest will receive a start[c]up t-shirt.People who have not advanced to the round two can participate in the round unofficially. Unofficial participation will be rated.The contest will be 3 hours long, and will feature 6 problems. The score distribution is 500-1000-1000-2000-2500-3000.The problem set has been developed by MemSQL engineers pieguy, nika, exod40, SkidanovAlex and dolphinigle.Good luck and happy coding!UPDATE: Editorial is up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8506",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces",
          "content": "This is the Editorial for MemSQL start[c]up Round 2 and MemSQL start[c]up Round 2 - online version. Congratulations RAD for online round winner and Petr for onsite and overall score winner!This editorial is written jointly by the contest's coordinators (i.e., MemSQL engineers).335A - Banana -- AlexSkidanovReference solution: Jimanbanashi's 4222182Instead of calculating the smallest possible number of sheets given a fixed n, let us instead try to compute the smallest possible value of n given a fixed number of sheets. Let k denote the number of sheets. If a particular letter appears p times in s, then it must appear at least ceil(p / k) times in the sheet. Thus we can compute the smallest possible value of n by summing ceil(p / k) over all letters. Now the original problem can be solved using binary search on k (or brute force, since the constraints were small enough).335B - Palindrome -- AlexSkidanovThere’s a well known O(n2) solution that allows one to find a longest subsequence of a string which is a palindrome: for every pair of positions l and r, such that l ≤ r, find the length d of the longest palindrome subsequence between those positions. d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).There are two ways to solve this problem faster than O(n2) with the constraints given in the problem: Use dynamic programming. For every position l and length k find the leftmost position r, such that there’s a palindrome of length k in the substring of s starting at l and ending at r. For position l and length k r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),where next(pos, s) is the next occurrence of character s after position pos. Next can be precomputed for all the positions and all the characters in advance. See DamianS's 4221965. If length is less than 2600, use the well-known O(n2) dynamic programming approach. Otherwise by pigeonhole principle there’s at least one character that appears in the string at least 100 times -- find it and print it 100 times. See SteamTurbine's 4224770. 335C - More Reclamation -- AlexSkidanovThe most straightforward way to solve this problem is to use Grundy numbers. Define a segment as a maximal range of rows in which no cells have been reclaimed. Since segments have no bearing on other segments, they can be assigned Grundy numbers. There are 4 types of segments: The entire river. A section of river containing one of the ends. A section of river blocked at both ends in the same column A section of river blocked at both ends in different columns Each time a cell is reclaimed, it splits a segment into 2 segments (one of which may have size 0). We can compute the Grundy value for all possible segments in O(r2). Then after sorting the reclaimed cells by row number, we can find all segments and compute the Grundy number for the full state.See Dmitry_Egorov's 4221888.Alternatively, we can compute the result directly. Suppose the game is over. We can determine who won the game just by looking at the top row and the bottom row. Let us define “parity” as the modulo 2 remainder of (r + n + c0 + c1), where c0 is the column of the reclaimed cell with the lowest row, and c1 is the column of the reclaimed cell with the highest row. Claim: when the game is over, the parity is even. This can be seen by observing that the number of empty rows is equal to the number of times the column changes. In other words, if c0==c1, there are an even number of empty rows, otherwise an odd number of empty rows. Now, given r, c0, and c1, we can determine n, and therefore the winner.Let us consider the case where there are no reclaimed cells. If r is even, then the second city can win with a mirroring strategy. When the first city reclaims cell (a,b), the second city follows with (r+1-a,b). Similarly, if r is odd then the first city wins by a mirroring strategy, playing first in ((r+1)/2, 0), and subsequently following the strategy for even r.Now suppose there are reclaimed cells. Let us define r0 as the number of empty rows in the segment starting from one end, and r1 as the number of empty rows starting from the other end.Case 1: if r0==r1 and the parity is even, the state is losing. All available moves will either decrease r0, decrease r1, or make the parity odd. The other player can respond to the first two types of moves with a mirroring strategy, and the third by making the parity even again (there will always be such a move that doesn’t affect r0 or r1, based on the fact that the argument above).Case 2: if abs(r0-r1)>=2 then the state is winning. Suppose, without loss of generality, that r0-r1>=2. Then either of the cells (r1+1, 1) and (r1+1, 2) may be reclaimed, and one of them must lead to Case 1 (since they both result in r0==r1, and one will have even parity and the other odd).Case 3: if abs(r0-r1)<2 and the parity is odd, the state is winning. If r0==r1, then we can change the parity without affecting r0 or r1, leaving our opponent in Case 1. Otherwise, there is a unique move that leaves our opponent in Case 1.(note that cases 2 and 3 together imply that all states with odd parity are winning)Case 4: if abs(r0-r1)==1 and the parity is even, there is at most one move that doesn’t leave our opponent in Case 2 or Case 3. Suppose r0==r1+1. We must change either r0 or r1, since all other moves will change the parity to odd. Thus our only option is to decrease r0, since decreasing r1 would leave our opponent in Case 2. We could decrease r0 by 1, but doing so would change the parity. Thus we must decrease r0 by 2, and there is at most one move that does so and keeps the parity even. It follows that if floor(r0/2)+floor(r1/2) is even, then this is a losing position, otherwise a winning position.See jill-jenn's extremely short 4225125.335D - Rectangles and Square -- AlexSkidanovEven though constraints were allowing O(k^2) solutions, in this editorial we will describe an O(n log(n)) solution. This problem has a rather long solution, involving several very different ideas: On the first step, for every rectangle we want to determine, if we were to consider this rectangle as the top left corner of a square, how long could the top and left edge of the square be (see the picture).If there’s no rectangle that is adjacent to the current rectangle on the right, which has the same y1 coordinate, then the top edge length is just the width of the current rectangle. Otherwise it is the width of the current rectangle plus the max top edge computed for the rectangle adjacent on the right. Left edge length is computed likewise.When top and left edge lengths are computed, we want to compute the max bottom and right edge length if this rectangle was the bottom right corner of the square.On the second step, we want to find all possible square frames. Look at this picture to better understand what we mean by square frame:To find a frame, let’s sort all the points first by x - y, and then by x (or y -- both will yield the same result). This way all the points are sorted by the diagonal they belong to, and then by the position on that diagonal. Then we will maintain a stack of pairs (position, edge length), where edge length is min(top edge length, left edge length). Position could be either x or y (within a given diagonal relative differences in xs and ys are the same). Min edge length tells us what is the largest square that could start at that position.When we process a new point on a diagonal, first pop from the stack all the pairs such that their position + edge length is less than our position. If stack after that is empty, then the current point cannot be a bottom right corner of any square. If stack is not empty, then there could be some frames with the current point being bottom right corner.Here we need to make a very important observation. If a square frame is contained within some other square frame, we don’t need to consider the outer square frame, since if the outer square frame is then proves to be an actual square, then the inner frame also has to be an actual square, and it is enough to only check an inner frame.With this observation made, we can only check if the last point on the stack forms a frame with the current point, there’s no need to check any other point on the stack. Since we already know that last element on the stack reaches to the right and to the bottom further than our current position (otherwise we would have popped it from the stack), to see if we form a frame with that point it is enough to check if we can reach that far to the top and to the left. To do so, check, if position of the current point minus min(bottom edge length, right edge length) for the current point is smaller or equal than the position of the point that is at the top of the stack. If it is, we have a square frame.When we have a frame, we move to the third step, where we check if the frame is filled in. To do that we just want to check if area within that square that is filled in by rectangles is equal to the area of the square. For every corner of every rectangle we will compute the area covered by rectangles which are fully located to the left and top from that point. To do that we can sort all the corners by x, and then by y, and process them one by one. We will maintain an interval tree where value at every position y represents area covered by rectangles processed so far that are fully above y. Then when we process a corner, we first update the interval tree if the corner is a bottom right corner, and then query the interval tree to see the area covered by rectangles to the up and left from the current corner.Then, when we have these number precomputed, for every square frame x1, y1, x2, y2 we can just get the area for (x2, y2), add area for (x1, y1) and subtract for (x2, y1) and for (x1, y2). See the author (AlexSkidanov)'s 4234601A possible O(k2) solution is similar, but makes checking whether or not the frame is filled much and a bunch of other checks easier. See my 4234474.335E - Counting Skyscrapers -- pieguyThe skyscrapers in this problem depict a data structure called Skip List. Skip list is similar to AVL and red black trees in a sense that it allows O(log N) insertions, deletions and searches (including searching for lower and upper bounds), as well as moving to the next element in sorted order in constant time. Skiplist is different from any tree structures because it has a practical thread safe implementation without locks (so-called lock-free). Lock free skiplists are used as a main data structure to store data in MemSQL, and the algorithm that Bob uses to traverse the skyscrapers is an O(log N) approach, that allows one to estimate the size of the skiplist. Thus, if Bob ended up with an estimation of n, the actual skiplist size is expected to be n (so if the first line of the input file is Bob, one just needs to print the number from the second line to the output). Formal proof is rather simple, and is left to the reader. Curiously, the converse does not hold. If the skiplist size is n, the expected return value of the estimation algorithm could be bigger than n. For an n that is significantly bigger than 2h the estimate converges to n - 1 + 2h, but this problem included cases with smaller n as well.Let us build up the solution one level at a time. When H is 0, the expected sum is N. Now for each additional level, we can add the expected cost of the zip lines on that level, and subtract the expected cost of the zip lines immediately below them. In the end we’ll have the total expected cost.For some floor number H, let’s consider some left and right tower, and determine the probability that a zip line exists between them. Let L be the distance between the two towers. A potential zip line of length L and height H exists if the towers at both ends are tall enough (probability 1 / 2H for each one), and the L - 1 towers between them are all shorter (probability 1 - 1 / 2H for each). Thus the probability that such a zip line exists is 1 / 22 * H × (1 - 1 / 2H)L - 1.Now, assuming that such a zip line exists, what’s the expected number of zip lines immediately below it? This is simply one more than the number of towers of height H - 1. Each of the L - 1 towers has probability 1 / (2H - 1) of having height H-1 (given that it has height at most H-1) -- use conditional probability () to calculate this. Thus the expected number of zip lines immediately below a zip line of length L and height H is 1 + (L - 1) / (2H - 1).For each length L, there are N - L possible zip lines with this length on each level. We multiply probability by cost for all possible zip lines to attain the expected value.The final answer is thereforeIt turns out the inner loop can be computed using matrix multiplication, for a running time of O(H log N). -- although the constraints is low enough that using matrix multiplication is an overkill -- O(H * N) will do.See the author (pieguy)'s 4234465. ...apparently this solution is much shorter than the \"easier\" problem's :)Congratulations Petr and tourist for the only persons solving this problem in-contest both on-site and off-site!335F - Buy One, Get One Free -- pieguyThis problem is equivalent to maximizing the total value of items that we can get for free.First, process the items into <#value, #number_of_items_with_that_value> tuples, which means we have #number_of_items_with_that_value items of value #value. Then, sort the tuples in descending order of #value.Iterate over those tuples and let #pieguy be an empty multi set()For each tuple <#val, #num>, we can calculate #max_free, the maximum number of items (not value) that we can get for free up to this point easily.So, we want to populate #pieguy so that it contains exactly #max_free “things”. #pieguy is special, in that we can compute the maximum price that we can get for free for n items by summing up the n most expensive items in #pieguy. How could #pieguy do that?For now, you may assume that each element of #pieguy contains the value of a single item that can be gotten for free. Thus, summing n items = value of n items that can be gotten for free. This is not correct, of course, since not all n arbitrary items can be simultaneously gotten for free in tandem, but we’ll come back to it later.We’re now at <#val, #num>, and we have #pieguy from previous iteration. #pieguy contains the previous #max_free elements. Assume that #num <= number of items more expensive than this value, for otherwise the remainder are ‘dead’ and useless for our current purpose. In particular, for the first tuple we process, we assume that #num is 0, since all of them cannot be gotten for free.Suppose we want to obtain exactly #max_free items. How many of the #num must we use?Let’s arrange the current members of #pieguy in descending order. For example, if #pieguy has 5 members: A B C D ELet’s arrange #num #val under #pieguy so that the rightmost one is located on position #max_free. For example, if #num is 6 and #max_free is 8 and #val is V.... A B C D E\n V V V V V VThese 6 Vs will be competing for a spot in #pieguy.Now...1) what happens if C < V? This means, instead of making C free, we can make V free instead! (if you’re wondering why this is possible, remember that #pieguy definition I gave you was not entirely honest yet). So, we replace C, D and E with all Vs, and we get our new #pieguy! A B V V V V V V (this should be sorted again, but C++’s multiset does that automagically).2) otherwise, C > V. So, V cannot contend for the 3-th place in #pieguy, it has to contend for a place larger than or equal to the 4-th.Now the fun begins! If you want to contend for the 4-th place, any solution MUST HAVE AT LEAST 2 V s (remember that the 4-th place is used in a solution consisting of at least 4 free items). In general, if you want to contend for the #max_free — i -th place, you MUST HAVE AT LEAST #num — i Vs. #proof? is easy, exercise (i’m honest!)Okay, so back to contending for the 4-th place. If D is still > V, we proceed. Otherwise, we know that D < V. This means, E and any element after E is also < V! Thus, we can replace all elements after or equal to E with V! The problem would be the final element of #pieguy.When the final element of #pieguy is included in the sum, it is only included in the sum of all n elements of #pieguy. You do this when you want to calculate the maximum sum of values of free items you can get when getting exactly #max_free items. Any such solution must include all #num elements with value #val. We have included #num-2 Vs in #pieguy. Thus, the final element of #pieguy must somehow contains 2 Vs! So, elements of #pieguy actually can do this. Instead of containing a single elmeent, each element of #pieguy is more of an “operation” that adds several value and removes several value. In our case, we want to add 2 Vs and remove something. The something? The smallest element that we can remove (the ones that we haven't removed)! C! (if you're wondering why not D or E, it's because (again) #pieguy is special -- it only forms a solution if the most expensive t are summed, not if some are skipped. -- we cannot skip C if we want to use D).So, Insert 2V — C into #pieguy, and the rest, insert V into #pieguy. 2V — C is < V, so summing all elements of #pieguy correctly found out the max value when we receive #max_free free items!Right! Cool! ...except that 2V — C can be negative. Why would we want to insert negative stuffs into #pieguy? We don’t! Actually, we check if 2V — C is negative. If it is, we continue instead, and check 3V — C — D and so on, under the same reason.That’s it folks! I skipped some details of why this works (for example, that the number of V selected is always sufficient to guarantee solution in #pieguy), but they're easier to see once you get this large idea. The result is then #pieguy.last_elementSee pieguy's beautiful 4234458.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8538",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 335\\s*C"
          },
          "content_length": 17873
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 1",
          "code": "*--st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 2",
          "code": "*----st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 3",
          "code": "*--st.lower_bound(*--st.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 4",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 5",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 1",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 2",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 3",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 4",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 5",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 6",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 7",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 8",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 9",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 10",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 11",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 12",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 13",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 14",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 15",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 16",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 17",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 18",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 19",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 20",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 21",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 22",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 23",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 24",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 25",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 26",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 27",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 28",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 29",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 30",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 31",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 32",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int n = inf.readInt(0, r, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> reclaimed;\n\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, r, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 2, \"ci\");\n        inf.readEoln();\n\n        auto cell = make_pair(ri, ci);\n        ensuref(reclaimed.count(cell) == 0, \"Cell (%d, %d) is reclaimed multiple times\", ri, ci);\n        reclaimed.insert(cell);\n    }\n\n    // Check that no reclaimed cells violate the constraints\n    for (const auto &cell : reclaimed) {\n        int ri = cell.first;\n        int ci = cell.second;\n        int ci_opp = 3 - ci; // opposite column\n\n        for (int delta_r = -1; delta_r <= 1; ++delta_r) {\n            int ri_adj = ri + delta_r;\n            if (ri_adj < 1 || ri_adj > r) continue; // Skip out of bounds\n            auto prohibited_cell = make_pair(ri_adj, ci_opp);\n            if (reclaimed.count(prohibited_cell)) {\n                ensuref(false, \"Cell (%d, %d) conflicts with cell (%d, %d)\", \n                        ri, ci, ri_adj, ci_opp);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int n = inf.readInt(0, r, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> reclaimed;\n\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, r, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 2, \"ci\");\n        inf.readEoln();\n\n        auto cell = make_pair(ri, ci);\n        ensuref(reclaimed.count(cell) == 0, \"Cell (%d, %d) is reclaimed multiple times\", ri, ci);\n        reclaimed.insert(cell);\n    }\n\n    // Check that no reclaimed cells violate the constraints\n    for (const auto &cell : reclaimed) {\n        int ri = cell.first;\n        int ci = cell.second;\n        int ci_opp = 3 - ci; // opposite column\n\n        for (int delta_r = -1; delta_r <= 1; ++delta_r) {\n            int ri_adj = ri + delta_r;\n            if (ri_adj < 1 || ri_adj > r) continue; // Skip out of bounds\n            auto prohibited_cell = make_pair(ri_adj, ci_opp);\n            if (reclaimed.count(prohibited_cell)) {\n                ensuref(false, \"Cell (%d, %d) conflicts with cell (%d, %d)\", \n                        ri, ci, ri_adj, ci_opp);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int n = inf.readInt(0, r, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> reclaimed;\n\n    for (int i = 0; i < n; ++i) {\n        int ri = inf.readInt(1, r, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 2, \"ci\");\n        inf.readEoln();\n\n        auto cell = make_pair(ri, ci);\n        ensuref(reclaimed.count(cell) == 0, \"Cell (%d, %d) is reclaimed multiple times\", ri, ci);\n        reclaimed.insert(cell);\n    }\n\n    // Check that no reclaimed cells violate the constraints\n    for (const auto &cell : reclaimed) {\n        int ri = cell.first;\n        int ci = cell.second;\n        int ci_opp = 3 - ci; // opposite column\n\n        for (int delta_r = -1; delta_r <= 1; ++delta_r) {\n            int ri_adj = ri + delta_r;\n            if (ri_adj < 1 || ri_adj > r) continue; // Skip out of bounds\n            auto prohibited_cell = make_pair(ri_adj, ci_opp);\n            if (reclaimed.count(prohibited_cell)) {\n                ensuref(false, \"Cell (%d, %d) conflicts with cell (%d, %d)\", \n                        ri, ci, ri_adj, ci_opp);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(r + 2, vector<int>(3, 0));\n\n    if (type == \"random\") {\n        int reclaimed = 0;\n        while (reclaimed < n) {\n            vector<pair<int,int>> candidates;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        // Cell (i,c) can be reclaimed\n                        candidates.emplace_back(i, c);\n                    }\n                }\n            }\n            if (candidates.empty()) {\n                break; // no more cells can be reclaimed\n            }\n            auto cell = rnd.any(candidates);\n            grid[cell.first][cell.second] = 1;\n            reclaimed++;\n        }\n    } else if (type == \"max\") {\n        // Reclaim cells to maximize the number of reclaimed cells\n        for (int i = 1; i <= r; i += 3) {\n            grid[i][1] = 1;\n        }\n        // Then try to reclaim more cells\n        bool changed = true;\n        while (changed) {\n            changed = false;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        grid[i][c] = 1;\n                        changed = true;\n                    }\n                }\n            }\n        }\n    } else if (type == \"min\") {\n        // No reclaimed cells\n        // Do nothing\n    } else if (type == \"single_column\") {\n        // Reclaim cells only in one column\n        int reclaimed = 0;\n        for (int i = 1; i <= r && reclaimed < n; ++i) {\n            int c = rnd.next(1,2);\n            if (grid[i][c] == 0) {\n                grid[i][c] = 1;\n                reclaimed++;\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Reclaim cells in alternating columns\n        int reclaimed = 0;\n        for (int i = 1; i <= r && reclaimed < n; ++i) {\n            int c = (i % 2) + 1;\n            if (grid[i][c] == 0) {\n                grid[i][c] = 1;\n                reclaimed++;\n            }\n        }\n    } else if (type == \"one_move_left\") {\n        // Create a game state where only one move is left\n        while (true) {\n            vector<pair<int,int>> candidates;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        // Cell (i,c) can be reclaimed\n                        candidates.emplace_back(i, c);\n                    }\n                }\n            }\n            if (candidates.size() <= 1) {\n                break;\n            }\n            for (auto cell : candidates) {\n                grid[cell.first][cell.second] = 1;\n            }\n        }\n    } else if (type == \"no_moves\") {\n        // Create a game state where there are no moves left\n        while (true) {\n            vector<pair<int,int>> candidates;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        // Cell (i,c) can be reclaimed\n                        candidates.emplace_back(i, c);\n                    }\n                }\n            }\n            if (candidates.empty()) {\n                break;\n            }\n            for (auto cell : candidates) {\n                grid[cell.first][cell.second] = 1;\n            }\n        }\n    }\n\n    // Now collect the list of reclaimed cells\n\n    vector<pair<int,int>> reclaimed_cells;\n    for (int i = 1; i <= r; ++i) {\n        for (int c = 1; c <=2; ++c) {\n            if (grid[i][c] == 1) {\n                reclaimed_cells.emplace_back(i, c);\n            }\n        }\n    }\n    n = reclaimed_cells.size();\n\n    // Output r and n\n    printf(\"%d %d\\n\", r, n);\n    // Output reclaimed cells\n    for (auto cell : reclaimed_cells) {\n        printf(\"%d %d\\n\", cell.first, cell.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int r = opt<int>(\"r\");\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(r + 2, vector<int>(3, 0));\n\n    if (type == \"random\") {\n        int reclaimed = 0;\n        while (reclaimed < n) {\n            vector<pair<int,int>> candidates;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        // Cell (i,c) can be reclaimed\n                        candidates.emplace_back(i, c);\n                    }\n                }\n            }\n            if (candidates.empty()) {\n                break; // no more cells can be reclaimed\n            }\n            auto cell = rnd.any(candidates);\n            grid[cell.first][cell.second] = 1;\n            reclaimed++;\n        }\n    } else if (type == \"max\") {\n        // Reclaim cells to maximize the number of reclaimed cells\n        for (int i = 1; i <= r; i += 3) {\n            grid[i][1] = 1;\n        }\n        // Then try to reclaim more cells\n        bool changed = true;\n        while (changed) {\n            changed = false;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        grid[i][c] = 1;\n                        changed = true;\n                    }\n                }\n            }\n        }\n    } else if (type == \"min\") {\n        // No reclaimed cells\n        // Do nothing\n    } else if (type == \"single_column\") {\n        // Reclaim cells only in one column\n        int reclaimed = 0;\n        for (int i = 1; i <= r && reclaimed < n; ++i) {\n            int c = rnd.next(1,2);\n            if (grid[i][c] == 0) {\n                grid[i][c] = 1;\n                reclaimed++;\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Reclaim cells in alternating columns\n        int reclaimed = 0;\n        for (int i = 1; i <= r && reclaimed < n; ++i) {\n            int c = (i % 2) + 1;\n            if (grid[i][c] == 0) {\n                grid[i][c] = 1;\n                reclaimed++;\n            }\n        }\n    } else if (type == \"one_move_left\") {\n        // Create a game state where only one move is left\n        while (true) {\n            vector<pair<int,int>> candidates;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        // Cell (i,c) can be reclaimed\n                        candidates.emplace_back(i, c);\n                    }\n                }\n            }\n            if (candidates.size() <= 1) {\n                break;\n            }\n            for (auto cell : candidates) {\n                grid[cell.first][cell.second] = 1;\n            }\n        }\n    } else if (type == \"no_moves\") {\n        // Create a game state where there are no moves left\n        while (true) {\n            vector<pair<int,int>> candidates;\n            for (int i = 1; i <= r; ++i) {\n                for (int c = 1; c <=2; ++c) {\n                    if (grid[i][c] == 0) {\n                        int rp1 = i + 1;\n                        int rm1 = i - 1;\n                        int cc = 3 - c;\n                        if (rm1 >=1 && grid[rm1][cc] == 1) continue;\n                        if (grid[i][cc] == 1) continue;\n                        if (rp1 <= r && grid[rp1][cc] == 1) continue;\n                        // Cell (i,c) can be reclaimed\n                        candidates.emplace_back(i, c);\n                    }\n                }\n            }\n            if (candidates.empty()) {\n                break;\n            }\n            for (auto cell : candidates) {\n                grid[cell.first][cell.second] = 1;\n            }\n        }\n    }\n\n    // Now collect the list of reclaimed cells\n\n    vector<pair<int,int>> reclaimed_cells;\n    for (int i = 1; i <= r; ++i) {\n        for (int c = 1; c <=2; ++c) {\n            if (grid[i][c] == 1) {\n                reclaimed_cells.emplace_back(i, c);\n            }\n        }\n    }\n    n = reclaimed_cells.size();\n\n    // Output r and n\n    printf(\"%d %d\\n\", r, n);\n    // Output reclaimed cells\n    for (auto cell : reclaimed_cells) {\n        printf(\"%d %d\\n\", cell.first, cell.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -r 1 -type min\n./gen -r 1 -type random -n 1\n./gen -r 1 -type no_moves\n\n./gen -r 2 -type random -n 1\n./gen -r 2 -type max\n./gen -r 2 -type one_move_left\n\n./gen -r 3 -type random -n 2\n./gen -r 3 -type single_column -n 2\n./gen -r 3 -type alternating\n\n./gen -r 10 -type random -n 5\n./gen -r 10 -type max\n./gen -r 10 -type one_move_left\n\n./gen -r 50 -type random -n 25\n./gen -r 50 -type max\n./gen -r 50 -type min\n\n./gen -r 100 -type random -n 50\n./gen -r 100 -type max\n./gen -r 100 -type one_move_left\n\n./gen -r 100 -type random -n 100\n./gen -r 100 -type min\n./gen -r 100 -type no_moves\n\n./gen -r 100 -type single_column -n 50\n./gen -r 100 -type alternating\n\n./gen -r 100 -type random -n 0\n./gen -r 100 -type random\n\n./gen -r 100 -type random -n 200\n\n./gen -r 100 -type random -n 101\n\n./gen -r 50 -type random -n 75\n\n./gen -r 1 -type no_moves\n./gen -r 1 -type one_move_left\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:54.505441",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "335/D",
      "title": "D. Прямоугольники и Квадрат",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105) — количество прямоугольников. Каждая из следующих n строк содержит описание прямоугольника, где i-ая строка описывает прямоугольник с номером i. Описание прямоугольника состоит из четырех целых чисел: x1, y1, x2, y2 — координат левого нижнего и правого верхнего углов прямоугольника (0 ≤ x1 < x2 ≤ 3000, 0 ≤ y1 < y2 ≤ 3000).Никакие два прямоугольника не пересекаются (не существует точки, принадлежащей внутренней области более чем одного прямоугольника).",
      "output_spec": "Выходные данныеЕсли такое подмножество существует, выведите «YES» (без кавычек) в первой строке, а затем на этой же строке число k — количество прямоугольников в подмножестве. На второй строке выведите k чисел — номера прямоугольников в подмножестве в любом порядке. Если существует более одного такого подмножества, выведите любое. Если такого подмножества не существует, выведите «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать90 0 1 91 0 9 11 8 9 98 1 9 82 2 3 63 2 7 32 6 7 75 3 7 63 3 5 6Выходные данныеСкопироватьYES 55 6 7 8 9Входные данныеСкопировать40 0 1 91 0 9 11 8 9 98 1 9 8Выходные данныеСкопироватьNO",
      "description": "D. Прямоугольники и Квадрат\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105) — количество прямоугольников. Каждая из следующих n строк содержит описание прямоугольника, где i-ая строка описывает прямоугольник с номером i. Описание прямоугольника состоит из четырех целых чисел: x1, y1, x2, y2 — координат левого нижнего и правого верхнего углов прямоугольника (0 ≤ x1 < x2 ≤ 3000, 0 ≤ y1 < y2 ≤ 3000).Никакие два прямоугольника не пересекаются (не существует точки, принадлежащей внутренней области более чем одного прямоугольника).\n\nВходные данные\n\nВыходные данныеЕсли такое подмножество существует, выведите «YES» (без кавычек) в первой строке, а затем на этой же строке число k — количество прямоугольников в подмножестве. На второй строке выведите k чисел — номера прямоугольников в подмножестве в любом порядке. Если существует более одного такого подмножества, выведите любое. Если такого подмножества не существует, выведите «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать90 0 1 91 0 9 11 8 9 98 1 9 82 2 3 63 2 7 32 6 7 75 3 7 63 3 5 6Выходные данныеСкопироватьYES 55 6 7 8 9Входные данныеСкопировать40 0 1 91 0 9 11 8 9 98 1 9 8Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать90 0 1 91 0 9 11 8 9 98 1 9 82 2 3 63 2 7 32 6 7 75 3 7 63 3 5 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES 55 6 7 8 9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать40 0 1 91 0 9 11 8 9 98 1 9 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый тест представлен на картинке:  Обратите внимание, что прямоугольники 6, 8, и 9 тоже образуют квадрат, и будут приняты как ответ.Второй тест представлен на картинке:",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces",
          "content": "Всем привет!Второй раунд соревнования MemSQL start[c]up состоится 3-его Августа в 21:00 MSK. Одновременно будет два контеста: для тех, кто участвует онсайт, и для тех, кто участвует онлайн. Набор задач в двух контестах будет одинаковый, и за них будет начислен рейтинг на основе общего монитора.Участники, участвующие в онсайт раунде, получат специальные призы за первые три места. Все участники онсайт раунда и топ 100 участников из онлайн раунда получат специальные футболки start[c]up.Участники, не прошедшие во второй раунд, могут участвовать неофициально. При этом раунд будет рейтинговым для таких участников.На соревновании будет предложено шесть задач, длительность соревнования -- три часа. Распределение баллов 500-1000-1000-2000-2500-3000.Задачи приготовлены разработчиками MemSQL pieguy, nika, exod40, SkidanovAlex и dolphinigle.Удачи и отличного кодинга!UPDATE: Опубликован разбор задач (на английском)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8506",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 915
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces",
          "content": "This is the Editorial for MemSQL start[c]up Round 2 and MemSQL start[c]up Round 2 - online version. Congratulations RAD for online round winner and Petr for onsite and overall score winner!This editorial is written jointly by the contest's coordinators (i.e., MemSQL engineers).335A - Banana -- AlexSkidanovReference solution: Jimanbanashi's 4222182Instead of calculating the smallest possible number of sheets given a fixed n, let us instead try to compute the smallest possible value of n given a fixed number of sheets. Let k denote the number of sheets. If a particular letter appears p times in s, then it must appear at least ceil(p / k) times in the sheet. Thus we can compute the smallest possible value of n by summing ceil(p / k) over all letters. Now the original problem can be solved using binary search on k (or brute force, since the constraints were small enough).335B - Palindrome -- AlexSkidanovThere’s a well known O(n2) solution that allows one to find a longest subsequence of a string which is a palindrome: for every pair of positions l and r, such that l ≤ r, find the length d of the longest palindrome subsequence between those positions. d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).There are two ways to solve this problem faster than O(n2) with the constraints given in the problem: Use dynamic programming. For every position l and length k find the leftmost position r, such that there’s a palindrome of length k in the substring of s starting at l and ending at r. For position l and length k r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),where next(pos, s) is the next occurrence of character s after position pos. Next can be precomputed for all the positions and all the characters in advance. See DamianS's 4221965. If length is less than 2600, use the well-known O(n2) dynamic programming approach. Otherwise by pigeonhole principle there’s at least one character that appears in the string at least 100 times -- find it and print it 100 times. See SteamTurbine's 4224770. 335C - More Reclamation -- AlexSkidanovThe most straightforward way to solve this problem is to use Grundy numbers. Define a segment as a maximal range of rows in which no cells have been reclaimed. Since segments have no bearing on other segments, they can be assigned Grundy numbers. There are 4 types of segments: The entire river. A section of river containing one of the ends. A section of river blocked at both ends in the same column A section of river blocked at both ends in different columns Each time a cell is reclaimed, it splits a segment into 2 segments (one of which may have size 0). We can compute the Grundy value for all possible segments in O(r2). Then after sorting the reclaimed cells by row number, we can find all segments and compute the Grundy number for the full state.See Dmitry_Egorov's 4221888.Alternatively, we can compute the result directly. Suppose the game is over. We can determine who won the game just by looking at the top row and the bottom row. Let us define “parity” as the modulo 2 remainder of (r + n + c0 + c1), where c0 is the column of the reclaimed cell with the lowest row, and c1 is the column of the reclaimed cell with the highest row. Claim: when the game is over, the parity is even. This can be seen by observing that the number of empty rows is equal to the number of times the column changes. In other words, if c0==c1, there are an even number of empty rows, otherwise an odd number of empty rows. Now, given r, c0, and c1, we can determine n, and therefore the winner.Let us consider the case where there are no reclaimed cells. If r is even, then the second city can win with a mirroring strategy. When the first city reclaims cell (a,b), the second city follows with (r+1-a,b). Similarly, if r is odd then the first city wins by a mirroring strategy, playing first in ((r+1)/2, 0), and subsequently following the strategy for even r.Now suppose there are reclaimed cells. Let us define r0 as the number of empty rows in the segment starting from one end, and r1 as the number of empty rows starting from the other end.Case 1: if r0==r1 and the parity is even, the state is losing. All available moves will either decrease r0, decrease r1, or make the parity odd. The other player can respond to the first two types of moves with a mirroring strategy, and the third by making the parity even again (there will always be such a move that doesn’t affect r0 or r1, based on the fact that the argument above).Case 2: if abs(r0-r1)>=2 then the state is winning. Suppose, without loss of generality, that r0-r1>=2. Then either of the cells (r1+1, 1) and (r1+1, 2) may be reclaimed, and one of them must lead to Case 1 (since they both result in r0==r1, and one will have even parity and the other odd).Case 3: if abs(r0-r1)<2 and the parity is odd, the state is winning. If r0==r1, then we can change the parity without affecting r0 or r1, leaving our opponent in Case 1. Otherwise, there is a unique move that leaves our opponent in Case 1.(note that cases 2 and 3 together imply that all states with odd parity are winning)Case 4: if abs(r0-r1)==1 and the parity is even, there is at most one move that doesn’t leave our opponent in Case 2 or Case 3. Suppose r0==r1+1. We must change either r0 or r1, since all other moves will change the parity to odd. Thus our only option is to decrease r0, since decreasing r1 would leave our opponent in Case 2. We could decrease r0 by 1, but doing so would change the parity. Thus we must decrease r0 by 2, and there is at most one move that does so and keeps the parity even. It follows that if floor(r0/2)+floor(r1/2) is even, then this is a losing position, otherwise a winning position.See jill-jenn's extremely short 4225125.335D - Rectangles and Square -- AlexSkidanovEven though constraints were allowing O(k^2) solutions, in this editorial we will describe an O(n log(n)) solution. This problem has a rather long solution, involving several very different ideas: On the first step, for every rectangle we want to determine, if we were to consider this rectangle as the top left corner of a square, how long could the top and left edge of the square be (see the picture).If there’s no rectangle that is adjacent to the current rectangle on the right, which has the same y1 coordinate, then the top edge length is just the width of the current rectangle. Otherwise it is the width of the current rectangle plus the max top edge computed for the rectangle adjacent on the right. Left edge length is computed likewise.When top and left edge lengths are computed, we want to compute the max bottom and right edge length if this rectangle was the bottom right corner of the square.On the second step, we want to find all possible square frames. Look at this picture to better understand what we mean by square frame:To find a frame, let’s sort all the points first by x - y, and then by x (or y -- both will yield the same result). This way all the points are sorted by the diagonal they belong to, and then by the position on that diagonal. Then we will maintain a stack of pairs (position, edge length), where edge length is min(top edge length, left edge length). Position could be either x or y (within a given diagonal relative differences in xs and ys are the same). Min edge length tells us what is the largest square that could start at that position.When we process a new point on a diagonal, first pop from the stack all the pairs such that their position + edge length is less than our position. If stack after that is empty, then the current point cannot be a bottom right corner of any square. If stack is not empty, then there could be some frames with the current point being bottom right corner.Here we need to make a very important observation. If a square frame is contained within some other square frame, we don’t need to consider the outer square frame, since if the outer square frame is then proves to be an actual square, then the inner frame also has to be an actual square, and it is enough to only check an inner frame.With this observation made, we can only check if the last point on the stack forms a frame with the current point, there’s no need to check any other point on the stack. Since we already know that last element on the stack reaches to the right and to the bottom further than our current position (otherwise we would have popped it from the stack), to see if we form a frame with that point it is enough to check if we can reach that far to the top and to the left. To do so, check, if position of the current point minus min(bottom edge length, right edge length) for the current point is smaller or equal than the position of the point that is at the top of the stack. If it is, we have a square frame.When we have a frame, we move to the third step, where we check if the frame is filled in. To do that we just want to check if area within that square that is filled in by rectangles is equal to the area of the square. For every corner of every rectangle we will compute the area covered by rectangles which are fully located to the left and top from that point. To do that we can sort all the corners by x, and then by y, and process them one by one. We will maintain an interval tree where value at every position y represents area covered by rectangles processed so far that are fully above y. Then when we process a corner, we first update the interval tree if the corner is a bottom right corner, and then query the interval tree to see the area covered by rectangles to the up and left from the current corner.Then, when we have these number precomputed, for every square frame x1, y1, x2, y2 we can just get the area for (x2, y2), add area for (x1, y1) and subtract for (x2, y1) and for (x1, y2). See the author (AlexSkidanov)'s 4234601A possible O(k2) solution is similar, but makes checking whether or not the frame is filled much and a bunch of other checks easier. See my 4234474.335E - Counting Skyscrapers -- pieguyThe skyscrapers in this problem depict a data structure called Skip List. Skip list is similar to AVL and red black trees in a sense that it allows O(log N) insertions, deletions and searches (including searching for lower and upper bounds), as well as moving to the next element in sorted order in constant time. Skiplist is different from any tree structures because it has a practical thread safe implementation without locks (so-called lock-free). Lock free skiplists are used as a main data structure to store data in MemSQL, and the algorithm that Bob uses to traverse the skyscrapers is an O(log N) approach, that allows one to estimate the size of the skiplist. Thus, if Bob ended up with an estimation of n, the actual skiplist size is expected to be n (so if the first line of the input file is Bob, one just needs to print the number from the second line to the output). Formal proof is rather simple, and is left to the reader. Curiously, the converse does not hold. If the skiplist size is n, the expected return value of the estimation algorithm could be bigger than n. For an n that is significantly bigger than 2h the estimate converges to n - 1 + 2h, but this problem included cases with smaller n as well.Let us build up the solution one level at a time. When H is 0, the expected sum is N. Now for each additional level, we can add the expected cost of the zip lines on that level, and subtract the expected cost of the zip lines immediately below them. In the end we’ll have the total expected cost.For some floor number H, let’s consider some left and right tower, and determine the probability that a zip line exists between them. Let L be the distance between the two towers. A potential zip line of length L and height H exists if the towers at both ends are tall enough (probability 1 / 2H for each one), and the L - 1 towers between them are all shorter (probability 1 - 1 / 2H for each). Thus the probability that such a zip line exists is 1 / 22 * H × (1 - 1 / 2H)L - 1.Now, assuming that such a zip line exists, what’s the expected number of zip lines immediately below it? This is simply one more than the number of towers of height H - 1. Each of the L - 1 towers has probability 1 / (2H - 1) of having height H-1 (given that it has height at most H-1) -- use conditional probability () to calculate this. Thus the expected number of zip lines immediately below a zip line of length L and height H is 1 + (L - 1) / (2H - 1).For each length L, there are N - L possible zip lines with this length on each level. We multiply probability by cost for all possible zip lines to attain the expected value.The final answer is thereforeIt turns out the inner loop can be computed using matrix multiplication, for a running time of O(H log N). -- although the constraints is low enough that using matrix multiplication is an overkill -- O(H * N) will do.See the author (pieguy)'s 4234465. ...apparently this solution is much shorter than the \"easier\" problem's :)Congratulations Petr and tourist for the only persons solving this problem in-contest both on-site and off-site!335F - Buy One, Get One Free -- pieguyThis problem is equivalent to maximizing the total value of items that we can get for free.First, process the items into <#value, #number_of_items_with_that_value> tuples, which means we have #number_of_items_with_that_value items of value #value. Then, sort the tuples in descending order of #value.Iterate over those tuples and let #pieguy be an empty multi set()For each tuple <#val, #num>, we can calculate #max_free, the maximum number of items (not value) that we can get for free up to this point easily.So, we want to populate #pieguy so that it contains exactly #max_free “things”. #pieguy is special, in that we can compute the maximum price that we can get for free for n items by summing up the n most expensive items in #pieguy. How could #pieguy do that?For now, you may assume that each element of #pieguy contains the value of a single item that can be gotten for free. Thus, summing n items = value of n items that can be gotten for free. This is not correct, of course, since not all n arbitrary items can be simultaneously gotten for free in tandem, but we’ll come back to it later.We’re now at <#val, #num>, and we have #pieguy from previous iteration. #pieguy contains the previous #max_free elements. Assume that #num <= number of items more expensive than this value, for otherwise the remainder are ‘dead’ and useless for our current purpose. In particular, for the first tuple we process, we assume that #num is 0, since all of them cannot be gotten for free.Suppose we want to obtain exactly #max_free items. How many of the #num must we use?Let’s arrange the current members of #pieguy in descending order. For example, if #pieguy has 5 members: A B C D ELet’s arrange #num #val under #pieguy so that the rightmost one is located on position #max_free. For example, if #num is 6 and #max_free is 8 and #val is V.... A B C D E\n V V V V V VThese 6 Vs will be competing for a spot in #pieguy.Now...1) what happens if C < V? This means, instead of making C free, we can make V free instead! (if you’re wondering why this is possible, remember that #pieguy definition I gave you was not entirely honest yet). So, we replace C, D and E with all Vs, and we get our new #pieguy! A B V V V V V V (this should be sorted again, but C++’s multiset does that automagically).2) otherwise, C > V. So, V cannot contend for the 3-th place in #pieguy, it has to contend for a place larger than or equal to the 4-th.Now the fun begins! If you want to contend for the 4-th place, any solution MUST HAVE AT LEAST 2 V s (remember that the 4-th place is used in a solution consisting of at least 4 free items). In general, if you want to contend for the #max_free — i -th place, you MUST HAVE AT LEAST #num — i Vs. #proof? is easy, exercise (i’m honest!)Okay, so back to contending for the 4-th place. If D is still > V, we proceed. Otherwise, we know that D < V. This means, E and any element after E is also < V! Thus, we can replace all elements after or equal to E with V! The problem would be the final element of #pieguy.When the final element of #pieguy is included in the sum, it is only included in the sum of all n elements of #pieguy. You do this when you want to calculate the maximum sum of values of free items you can get when getting exactly #max_free items. Any such solution must include all #num elements with value #val. We have included #num-2 Vs in #pieguy. Thus, the final element of #pieguy must somehow contains 2 Vs! So, elements of #pieguy actually can do this. Instead of containing a single elmeent, each element of #pieguy is more of an “operation” that adds several value and removes several value. In our case, we want to add 2 Vs and remove something. The something? The smallest element that we can remove (the ones that we haven't removed)! C! (if you're wondering why not D or E, it's because (again) #pieguy is special -- it only forms a solution if the most expensive t are summed, not if some are skipped. -- we cannot skip C if we want to use D).So, Insert 2V — C into #pieguy, and the rest, insert V into #pieguy. 2V — C is < V, so summing all elements of #pieguy correctly found out the max value when we receive #max_free free items!Right! Cool! ...except that 2V — C can be negative. Why would we want to insert negative stuffs into #pieguy? We don’t! Actually, we check if 2V — C is negative. If it is, we continue instead, and check 3V — C — D and so on, under the same reason.That’s it folks! I skipped some details of why this works (for example, that the number of V selected is always sufficient to guarantee solution in #pieguy), but they're easier to see once you get this large idea. The result is then #pieguy.last_elementSee pieguy's beautiful 4234458.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8538",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 335\\s*D"
          },
          "content_length": 17873
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 1",
          "code": "if(best.length() >= rest)                 return best;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 2",
          "code": "baaabaaaaaaaaaaaaa...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 3",
          "code": "*--st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 4",
          "code": "*----st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 5",
          "code": "*--st.lower_bound(*--st.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 6",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 7",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 1",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 2",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 3",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 4",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 5",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 6",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 7",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 8",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 9",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 10",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 11",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 12",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 13",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 14",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 15",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 16",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 17",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 18",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 19",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 20",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 21",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 22",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 23",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 24",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 25",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 26",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 27",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 28",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 29",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 30",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 31",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 32",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Event {\n    int x;\n    int type; // 0 = END, 1 = START\n    int y1, y2;\n    bool operator<(const Event &other) const {\n        if (x != other.x) return x < other.x;\n        return type < other.type; // END events before START events at same x\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<Event> events;\n    for (int i = 0; i < n; i++) {\n        int x1 = inf.readInt(0, 3000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(0, 3000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(0, 3000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(0, 3000, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"Rectangle #%d: x1 (%d) must be less than x2 (%d)\", i+1, x1, x2);\n        ensuref(y1 < y2, \"Rectangle #%d: y1 (%d) must be less than y2 (%d)\", i+1, y1, y2);\n\n        // Collect events only if rectangle has an interior\n        if (x2 - x1 > 1 && y2 - y1 > 1) {\n            int x_start = x1 + 1;\n            int x_end = x2 - 1;\n            int y_start = y1 + 1;\n            int y_end = y2 - 1;\n            events.push_back({x_start, 1, y_start, y_end}); // START event\n            events.push_back({x_end, 0, y_start, y_end}); // END event\n        }\n    }\n\n    sort(events.begin(), events.end());\n\n    set<pair<int, int>> active; // Intervals [y1, y2)\n    for (const auto &event : events) {\n        if (event.type == 0) {\n            // END event\n            active.erase({event.y1, event.y2});\n        } else {\n            // START event\n            // Check for overlap\n            auto it = active.lower_bound({event.y1, event.y2});\n            if (it != active.end()) {\n                if (it->first < event.y2) {\n                    ensuref(false, \"Rectangles' interiors overlap at y in [%d, %d)\", event.y1, event.y2);\n                }\n            }\n            if (it != active.begin()) {\n                auto prev_it = prev(it);\n                if (prev_it->second > event.y1) {\n                    ensuref(false, \"Rectangles' interiors overlap at y in [%d, %d)\", event.y1, event.y2);\n                }\n            }\n            active.insert({event.y1, event.y2});\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Event {\n    int x;\n    int type; // 0 = END, 1 = START\n    int y1, y2;\n    bool operator<(const Event &other) const {\n        if (x != other.x) return x < other.x;\n        return type < other.type; // END events before START events at same x\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<Event> events;\n    for (int i = 0; i < n; i++) {\n        int x1 = inf.readInt(0, 3000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(0, 3000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(0, 3000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(0, 3000, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"Rectangle #%d: x1 (%d) must be less than x2 (%d)\", i+1, x1, x2);\n        ensuref(y1 < y2, \"Rectangle #%d: y1 (%d) must be less than y2 (%d)\", i+1, y1, y2);\n\n        // Collect events only if rectangle has an interior\n        if (x2 - x1 > 1 && y2 - y1 > 1) {\n            int x_start = x1 + 1;\n            int x_end = x2 - 1;\n            int y_start = y1 + 1;\n            int y_end = y2 - 1;\n            events.push_back({x_start, 1, y_start, y_end}); // START event\n            events.push_back({x_end, 0, y_start, y_end}); // END event\n        }\n    }\n\n    sort(events.begin(), events.end());\n\n    set<pair<int, int>> active; // Intervals [y1, y2)\n    for (const auto &event : events) {\n        if (event.type == 0) {\n            // END event\n            active.erase({event.y1, event.y2});\n        } else {\n            // START event\n            // Check for overlap\n            auto it = active.lower_bound({event.y1, event.y2});\n            if (it != active.end()) {\n                if (it->first < event.y2) {\n                    ensuref(false, \"Rectangles' interiors overlap at y in [%d, %d)\", event.y1, event.y2);\n                }\n            }\n            if (it != active.begin()) {\n                auto prev_it = prev(it);\n                if (prev_it->second > event.y1) {\n                    ensuref(false, \"Rectangles' interiors overlap at y in [%d, %d)\", event.y1, event.y2);\n                }\n            }\n            active.insert({event.y1, event.y2});\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Event {\n    int x;\n    int type; // 0 = END, 1 = START\n    int y1, y2;\n    bool operator<(const Event &other) const {\n        if (x != other.x) return x < other.x;\n        return type < other.type; // END events before START events at same x\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<Event> events;\n    for (int i = 0; i < n; i++) {\n        int x1 = inf.readInt(0, 3000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(0, 3000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(0, 3000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(0, 3000, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"Rectangle #%d: x1 (%d) must be less than x2 (%d)\", i+1, x1, x2);\n        ensuref(y1 < y2, \"Rectangle #%d: y1 (%d) must be less than y2 (%d)\", i+1, y1, y2);\n\n        // Collect events only if rectangle has an interior\n        if (x2 - x1 > 1 && y2 - y1 > 1) {\n            int x_start = x1 + 1;\n            int x_end = x2 - 1;\n            int y_start = y1 + 1;\n            int y_end = y2 - 1;\n            events.push_back({x_start, 1, y_start, y_end}); // START event\n            events.push_back({x_end, 0, y_start, y_end}); // END event\n        }\n    }\n\n    sort(events.begin(), events.end());\n\n    set<pair<int, int>> active; // Intervals [y1, y2)\n    for (const auto &event : events) {\n        if (event.type == 0) {\n            // END event\n            active.erase({event.y1, event.y2});\n        } else {\n            // START event\n            // Check for overlap\n            auto it = active.lower_bound({event.y1, event.y2});\n            if (it != active.end()) {\n                if (it->first < event.y2) {\n                    ensuref(false, \"Rectangles' interiors overlap at y in [%d, %d)\", event.y1, event.y2);\n                }\n            }\n            if (it != active.begin()) {\n                auto prev_it = prev(it);\n                if (prev_it->second > event.y1) {\n                    ensuref(false, \"Rectangles' interiors overlap at y in [%d, %d)\", event.y1, event.y2);\n                }\n            }\n            active.insert({event.y1, event.y2});\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    vector<Rectangle> rectangles(n);\n    for (int i = 0; i < n; ++i) {\n        rectangles[i].x1 = inf.readInt();\n        rectangles[i].y1 = inf.readInt();\n        rectangles[i].x2 = inf.readInt();\n        rectangles[i].y2 = inf.readInt();\n    }\n\n    string juryVerdict = ans.readToken();\n    if (juryVerdict != \"YES\" && juryVerdict != \"NO\")\n        ans.quitf(_fail, \"Jury's output should be 'YES' or 'NO', found '%s'\", juryVerdict.c_str());\n\n    string participantVerdict = ouf.readToken();\n    if (participantVerdict != \"YES\" && participantVerdict != \"NO\")\n        quitf(_wa, \"Your output should be 'YES' or 'NO', found '%s'\", participantVerdict.c_str());\n\n    if (juryVerdict == \"NO\") {\n        if (participantVerdict == \"NO\") {\n            quitf(_ok, \"Correctly reported NO\");\n        } else {\n            quitf(_wa, \"No solution exists, but participant claimed there is\");\n        }\n    } else {\n        if (participantVerdict == \"NO\") {\n            quitf(_wa, \"A solution exists, but participant reported NO\");\n        }\n        // Participant output is YES, proceed to validate the subset\n        int k = ouf.readInt(1, n, \"k\");\n        vector<int> labels = ouf.readInts(k, 1, n, \"rectangle labels\");\n        set<int> labels_set(labels.begin(), labels.end());\n        if ((int)labels_set.size() != k)\n            quitf(_wa, \"Duplicate rectangle labels found in the subset\");\n\n        int min_x1 = INT_MAX, min_y1 = INT_MAX;\n        int max_x2 = INT_MIN, max_y2 = INT_MIN;\n        vector<Rectangle> subset_rectangles;\n        for (int idx : labels) {\n            idx--; // zero-based index\n            Rectangle rect = rectangles[idx];\n            subset_rectangles.push_back(rect);\n            min_x1 = min(min_x1, rect.x1);\n            min_y1 = min(min_y1, rect.y1);\n            max_x2 = max(max_x2, rect.x2);\n            max_y2 = max(max_y2, rect.y2);\n        }\n\n        int s = max_x2 - min_x1;\n        if (s != max_y2 - min_y1)\n            quitf(_wa, \"The union of rectangles does not form a square\");\n\n        int grid_size = s;\n        vector<vector<bool>> grid(grid_size, vector<bool>(grid_size, false));\n\n        for (const Rectangle& rect : subset_rectangles) {\n            for (int y = rect.y1; y < rect.y2; ++y) {\n                for (int x = rect.x1; x < rect.x2; ++x) {\n                    int ty = y - min_y1;\n                    int tx = x - min_x1;\n                    if (ty < 0 || ty >= grid_size || tx < 0 || tx >= grid_size)\n                        quitf(_wa, \"Rectangle extends beyond the supposed square\");\n                    if (grid[ty][tx])\n                        quitf(_wa, \"Rectangles overlap at (%d, %d)\", x, y);\n                    grid[ty][tx] = true;\n                }\n            }\n        }\n\n        for (int y = 0; y < grid_size; ++y) {\n            for (int x = 0; x < grid_size; ++x) {\n                if (!grid[y][x])\n                    quitf(_wa, \"The union of rectangles does not cover the entire square\");\n            }\n        }\n        quitf(_ok, \"Correct solution\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Rectangle> rects;\n\n    if (type == \"single_square_rect\") {\n        // n must be 1\n        n = 1;\n        int max_coord = 3000;\n        int s = rnd.next(1, max_coord);\n        int x1 = rnd.next(0, max_coord - s);\n        int y1 = rnd.next(0, max_coord - s);\n        int x2 = x1 + s;\n        int y2 = y1 + s;\n        rects.push_back({x1, y1, x2, y2});\n    } else if (type == \"full_square\") {\n        // Generate multiple rectangles that together form a square\n        int s = 3000; // Size of the square\n        int k = n;\n        if (k > s) {\n            k = s;\n        }\n        int stripe_height = s / k;\n        // Ensure stripe_height >= 1\n        stripe_height = max(stripe_height, 1);\n        k = s / stripe_height; // Adjust k to fit into s\n        n = k;\n        int adjusted_s = stripe_height * k; // Adjusted square size\n\n        // Generate rectangles\n        for (int i = 0; i < k; ++i) {\n            int x1 = 0;\n            int x2 = adjusted_s;\n            int y1 = i * stripe_height;\n            int y2 = (i + 1) * stripe_height;\n            rects.push_back({x1, y1, x2, y2});\n        }\n    } else if (type == \"non_square\") {\n        // Generate rectangles that do not form a square (e.g., an L-shape)\n        int s = 1000;\n        rects.push_back({0, 0, s/2, s}); // Vertical rectangle\n        rects.push_back({s/2, 0, s, s/2}); // Horizontal rectangle\n        n = 2;\n        // Add random rectangles if needed\n        for (int i = 2; i < n; ++i) {\n            int x1 = rnd.next(0, 3000 - 1);\n            int y1 = rnd.next(0, 3000 - 1);\n            int x2 = rnd.next(x1 + 1, 3000);\n            int y2 = rnd.next(y1 + 1, 3000);\n            rects.push_back({x1, y1, x2, y2});\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate rectangles that touch only at corners\n        n = 4;\n        int s = 1000;\n        rects.push_back({0, 0, s, s}); // Bottom-left\n        rects.push_back({s, s, 2*s, 2*s}); // Top-right\n        rects.push_back({s, 0, 2*s, s}); // Bottom-right\n        rects.push_back({0, s, s, 2*s}); // Top-left\n    } else if (type == \"random\" || type == \"random_large\") {\n        // Generate random non-overlapping rectangles\n        int max_coord = 3000;\n        int grid_size = sqrt(n) + 1;\n        int cell_size = max(max_coord / grid_size, 1);\n\n        vector<pair<int, int>> cells;\n        for (int i = 0; i < grid_size; ++i) {\n            for (int j = 0; j < grid_size; ++j) {\n                cells.push_back({i, j});\n            }\n        }\n        shuffle(cells.begin(), cells.end());\n\n        for (int i = 0; i < n; ++i) {\n            if (i >= (int)cells.size()) {\n                int x1 = rnd.next(0, max_coord - 1);\n                int y1 = rnd.next(0, max_coord - 1);\n                int x2 = x1 + 1;\n                int y2 = y1 + 1;\n                rects.push_back({x1, y1, x2, y2});\n            } else {\n                int cx = cells[i].first;\n                int cy = cells[i].second;\n                int x1 = cx * cell_size;\n                int y1 = cy * cell_size;\n                int x2 = min(x1 + cell_size, max_coord);\n                int y2 = min(y1 + cell_size, max_coord);\n\n                int x_start = x1;\n                int x_end = x2 - 1;\n                int y_start = y1;\n                int y_end = y2 - 1;\n\n                if (x_start >= x_end) {\n                    x_end = x_start + 1;\n                }\n                if (y_start >= y_end) {\n                    y_end = y_start + 1;\n                }\n\n                int x_a = rnd.next(x_start, x_end);\n                int x_b = rnd.next(x_a + 1, x2);\n                int y_a = rnd.next(y_start, y_end);\n                int y_b = rnd.next(y_a + 1, y2);\n\n                rects.push_back({x_a, y_a, x_b, y_b});\n            }\n        }\n    } else {\n        // Default random rectangles (similar to random_large)\n        int max_coord = 3000;\n        int grid_size = sqrt(n) + 1;\n        int cell_size = max(max_coord / grid_size, 1);\n\n        vector<pair<int, int>> cells;\n        for (int i = 0; i < grid_size; ++i) {\n            for (int j = 0; j < grid_size; ++j) {\n                cells.push_back({i, j});\n            }\n        }\n        shuffle(cells.begin(), cells.end());\n\n        for (int i = 0; i < n; ++i) {\n            if (i >= (int)cells.size()) {\n                int x1 = rnd.next(0, max_coord - 1);\n                int y1 = rnd.next(0, max_coord - 1);\n                int x2 = x1 + 1;\n                int y2 = y1 + 1;\n                rects.push_back({x1, y1, x2, y2});\n            } else {\n                int cx = cells[i].first;\n                int cy = cells[i].second;\n                int x1 = cx * cell_size;\n                int y1 = cy * cell_size;\n                int x2 = min(x1 + cell_size, max_coord);\n                int y2 = min(y1 + cell_size, max_coord);\n\n                int x_start = x1;\n                int x_end = x2 - 1;\n                int y_start = y1;\n                int y_end = y2 - 1;\n\n                if (x_start >= x_end) {\n                    x_end = x_start + 1;\n                }\n                if (y_start >= y_end) {\n                    y_end = y_start + 1;\n                }\n\n                int x_a = rnd.next(x_start, x_end);\n                int x_b = rnd.next(x_a + 1, x2);\n                int y_a = rnd.next(y_start, y_end);\n                int y_b = rnd.next(y_a + 1, y2);\n\n                rects.push_back({x_a, y_a, x_b, y_b});\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto r : rects) {\n        printf(\"%d %d %d %d\\n\", r.x1, r.y1, r.x2, r.y2);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Rectangle> rects;\n\n    if (type == \"single_square_rect\") {\n        // n must be 1\n        n = 1;\n        int max_coord = 3000;\n        int s = rnd.next(1, max_coord);\n        int x1 = rnd.next(0, max_coord - s);\n        int y1 = rnd.next(0, max_coord - s);\n        int x2 = x1 + s;\n        int y2 = y1 + s;\n        rects.push_back({x1, y1, x2, y2});\n    } else if (type == \"full_square\") {\n        // Generate multiple rectangles that together form a square\n        int s = 3000; // Size of the square\n        int k = n;\n        if (k > s) {\n            k = s;\n        }\n        int stripe_height = s / k;\n        // Ensure stripe_height >= 1\n        stripe_height = max(stripe_height, 1);\n        k = s / stripe_height; // Adjust k to fit into s\n        n = k;\n        int adjusted_s = stripe_height * k; // Adjusted square size\n\n        // Generate rectangles\n        for (int i = 0; i < k; ++i) {\n            int x1 = 0;\n            int x2 = adjusted_s;\n            int y1 = i * stripe_height;\n            int y2 = (i + 1) * stripe_height;\n            rects.push_back({x1, y1, x2, y2});\n        }\n    } else if (type == \"non_square\") {\n        // Generate rectangles that do not form a square (e.g., an L-shape)\n        int s = 1000;\n        rects.push_back({0, 0, s/2, s}); // Vertical rectangle\n        rects.push_back({s/2, 0, s, s/2}); // Horizontal rectangle\n        n = 2;\n        // Add random rectangles if needed\n        for (int i = 2; i < n; ++i) {\n            int x1 = rnd.next(0, 3000 - 1);\n            int y1 = rnd.next(0, 3000 - 1);\n            int x2 = rnd.next(x1 + 1, 3000);\n            int y2 = rnd.next(y1 + 1, 3000);\n            rects.push_back({x1, y1, x2, y2});\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate rectangles that touch only at corners\n        n = 4;\n        int s = 1000;\n        rects.push_back({0, 0, s, s}); // Bottom-left\n        rects.push_back({s, s, 2*s, 2*s}); // Top-right\n        rects.push_back({s, 0, 2*s, s}); // Bottom-right\n        rects.push_back({0, s, s, 2*s}); // Top-left\n    } else if (type == \"random\" || type == \"random_large\") {\n        // Generate random non-overlapping rectangles\n        int max_coord = 3000;\n        int grid_size = sqrt(n) + 1;\n        int cell_size = max(max_coord / grid_size, 1);\n\n        vector<pair<int, int>> cells;\n        for (int i = 0; i < grid_size; ++i) {\n            for (int j = 0; j < grid_size; ++j) {\n                cells.push_back({i, j});\n            }\n        }\n        shuffle(cells.begin(), cells.end());\n\n        for (int i = 0; i < n; ++i) {\n            if (i >= (int)cells.size()) {\n                int x1 = rnd.next(0, max_coord - 1);\n                int y1 = rnd.next(0, max_coord - 1);\n                int x2 = x1 + 1;\n                int y2 = y1 + 1;\n                rects.push_back({x1, y1, x2, y2});\n            } else {\n                int cx = cells[i].first;\n                int cy = cells[i].second;\n                int x1 = cx * cell_size;\n                int y1 = cy * cell_size;\n                int x2 = min(x1 + cell_size, max_coord);\n                int y2 = min(y1 + cell_size, max_coord);\n\n                int x_start = x1;\n                int x_end = x2 - 1;\n                int y_start = y1;\n                int y_end = y2 - 1;\n\n                if (x_start >= x_end) {\n                    x_end = x_start + 1;\n                }\n                if (y_start >= y_end) {\n                    y_end = y_start + 1;\n                }\n\n                int x_a = rnd.next(x_start, x_end);\n                int x_b = rnd.next(x_a + 1, x2);\n                int y_a = rnd.next(y_start, y_end);\n                int y_b = rnd.next(y_a + 1, y2);\n\n                rects.push_back({x_a, y_a, x_b, y_b});\n            }\n        }\n    } else {\n        // Default random rectangles (similar to random_large)\n        int max_coord = 3000;\n        int grid_size = sqrt(n) + 1;\n        int cell_size = max(max_coord / grid_size, 1);\n\n        vector<pair<int, int>> cells;\n        for (int i = 0; i < grid_size; ++i) {\n            for (int j = 0; j < grid_size; ++j) {\n                cells.push_back({i, j});\n            }\n        }\n        shuffle(cells.begin(), cells.end());\n\n        for (int i = 0; i < n; ++i) {\n            if (i >= (int)cells.size()) {\n                int x1 = rnd.next(0, max_coord - 1);\n                int y1 = rnd.next(0, max_coord - 1);\n                int x2 = x1 + 1;\n                int y2 = y1 + 1;\n                rects.push_back({x1, y1, x2, y2});\n            } else {\n                int cx = cells[i].first;\n                int cy = cells[i].second;\n                int x1 = cx * cell_size;\n                int y1 = cy * cell_size;\n                int x2 = min(x1 + cell_size, max_coord);\n                int y2 = min(y1 + cell_size, max_coord);\n\n                int x_start = x1;\n                int x_end = x2 - 1;\n                int y_start = y1;\n                int y_end = y2 - 1;\n\n                if (x_start >= x_end) {\n                    x_end = x_start + 1;\n                }\n                if (y_start >= y_end) {\n                    y_end = y_start + 1;\n                }\n\n                int x_a = rnd.next(x_start, x_end);\n                int x_b = rnd.next(x_a + 1, x2);\n                int y_a = rnd.next(y_start, y_end);\n                int y_b = rnd.next(y_a + 1, y2);\n\n                rects.push_back({x_a, y_a, x_b, y_b});\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto r : rects) {\n        printf(\"%d %d %d %d\\n\", r.x1, r.y1, r.x2, r.y2);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Single rectangle forming a square\n./gen -n 1 -type single_square_rect\n\n# Full square partitioned into horizontal stripes\n./gen -n 2 -type full_square\n./gen -n 3 -type full_square\n./gen -n 4 -type full_square\n./gen -n 5 -type full_square\n./gen -n 10 -type full_square\n./gen -n 50 -type full_square\n./gen -n 100 -type full_square\n./gen -n 1000 -type full_square\n./gen -n 3000 -type full_square\n\n# Random large test cases\n./gen -n 1000 -type random_large\n./gen -n 10000 -type random_large\n./gen -n 50000 -type random_large\n./gen -n 100000 -type random_large\n\n# Edge cases with rectangles touching at corners\n./gen -n 4 -type edge_cases\n\n# Non-square test cases\n./gen -n 2 -type non_square\n./gen -n 5 -type non_square\n./gen -n 1000 -type non_square\n./gen -n 100000 -type non_square\n\n# Random test cases\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n# Additional test cases\n# Single rectangle that is not a square\n./gen -n 1 -type random\n\n# Maximum size rectangle\n./gen -n 1 -type random_large\n\n# Full square with maximum n\n./gen -n 3000 -type full_square\n./gen -n 100000 -type full_square\n\n# Edge cases with maximum coordinates\n./gen -n 4 -type edge_cases\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:56.773987",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "335/E",
      "title": "E. Counting Skyscrapers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will be a name, either string \"Alice\" or \"Bob\". The second line of input contains two integers n and h (2 ≤ n ≤ 30000, 0 ≤ h ≤ 30). If the name is \"Alice\", then n represents the value of Alice's counter when she reaches the rightmost skyscraper, otherwise n represents the value of Bob's counter when he reaches the rightmost skyscraper; h represents the highest floor number Bob is willing to use.",
      "output_spec": "OutputOutput a single real value giving the expected value of the Alice's counter if you were given Bob's counter, or Bob's counter if you were given Alice's counter. You answer will be considered correct if its absolute or relative error doesn't exceed 10 - 9.",
      "sample_tests": "ExamplesInputCopyAlice3 1OutputCopy3.500000000InputCopyBob2 30OutputCopy2InputCopyAlice2572 10OutputCopy3439.031415943",
      "description": "E. Counting Skyscrapers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input will be a name, either string \"Alice\" or \"Bob\". The second line of input contains two integers n and h (2 ≤ n ≤ 30000, 0 ≤ h ≤ 30). If the name is \"Alice\", then n represents the value of Alice's counter when she reaches the rightmost skyscraper, otherwise n represents the value of Bob's counter when he reaches the rightmost skyscraper; h represents the highest floor number Bob is willing to use.\n\nOutputOutput a single real value giving the expected value of the Alice's counter if you were given Bob's counter, or Bob's counter if you were given Alice's counter. You answer will be considered correct if its absolute or relative error doesn't exceed 10 - 9.\n\nInputCopyAlice3 1OutputCopy3.500000000InputCopyBob2 30OutputCopy2InputCopyAlice2572 10OutputCopy3439.031415943\n\nInputCopyAlice3 1\n\nOutputCopy3.500000000\n\nInputCopyBob2 30\n\nOutputCopy2\n\nInputCopyAlice2572 10\n\nOutputCopy3439.031415943\n\nNoteIn the first example, Bob's counter has a 62.5% chance of being 3, a 25% chance of being 4, and a 12.5% chance of being 5.",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL start[c]up will take place on August, 3rd, 10:00am PDT. There will be two contests running simultaneously, one for people who participate onsite, and one for everybody else who advanced to the round two. Both rounds share the problemset and are rated based on the combined scoreboard.Onsite participants will have special prizes for first three places. All onsite participants as well as the top 100 in the online contest will receive a start[c]up t-shirt.People who have not advanced to the round two can participate in the round unofficially. Unofficial participation will be rated.The contest will be 3 hours long, and will feature 6 problems. The score distribution is 500-1000-1000-2000-2500-3000.The problem set has been developed by MemSQL engineers pieguy, nika, exod40, SkidanovAlex and dolphinigle.Good luck and happy coding!UPDATE: Editorial is up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8506",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces",
          "content": "This is the Editorial for MemSQL start[c]up Round 2 and MemSQL start[c]up Round 2 - online version. Congratulations RAD for online round winner and Petr for onsite and overall score winner!This editorial is written jointly by the contest's coordinators (i.e., MemSQL engineers).335A - Banana -- AlexSkidanovReference solution: Jimanbanashi's 4222182Instead of calculating the smallest possible number of sheets given a fixed n, let us instead try to compute the smallest possible value of n given a fixed number of sheets. Let k denote the number of sheets. If a particular letter appears p times in s, then it must appear at least ceil(p / k) times in the sheet. Thus we can compute the smallest possible value of n by summing ceil(p / k) over all letters. Now the original problem can be solved using binary search on k (or brute force, since the constraints were small enough).335B - Palindrome -- AlexSkidanovThere’s a well known O(n2) solution that allows one to find a longest subsequence of a string which is a palindrome: for every pair of positions l and r, such that l ≤ r, find the length d of the longest palindrome subsequence between those positions. d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).There are two ways to solve this problem faster than O(n2) with the constraints given in the problem: Use dynamic programming. For every position l and length k find the leftmost position r, such that there’s a palindrome of length k in the substring of s starting at l and ending at r. For position l and length k r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),where next(pos, s) is the next occurrence of character s after position pos. Next can be precomputed for all the positions and all the characters in advance. See DamianS's 4221965. If length is less than 2600, use the well-known O(n2) dynamic programming approach. Otherwise by pigeonhole principle there’s at least one character that appears in the string at least 100 times -- find it and print it 100 times. See SteamTurbine's 4224770. 335C - More Reclamation -- AlexSkidanovThe most straightforward way to solve this problem is to use Grundy numbers. Define a segment as a maximal range of rows in which no cells have been reclaimed. Since segments have no bearing on other segments, they can be assigned Grundy numbers. There are 4 types of segments: The entire river. A section of river containing one of the ends. A section of river blocked at both ends in the same column A section of river blocked at both ends in different columns Each time a cell is reclaimed, it splits a segment into 2 segments (one of which may have size 0). We can compute the Grundy value for all possible segments in O(r2). Then after sorting the reclaimed cells by row number, we can find all segments and compute the Grundy number for the full state.See Dmitry_Egorov's 4221888.Alternatively, we can compute the result directly. Suppose the game is over. We can determine who won the game just by looking at the top row and the bottom row. Let us define “parity” as the modulo 2 remainder of (r + n + c0 + c1), where c0 is the column of the reclaimed cell with the lowest row, and c1 is the column of the reclaimed cell with the highest row. Claim: when the game is over, the parity is even. This can be seen by observing that the number of empty rows is equal to the number of times the column changes. In other words, if c0==c1, there are an even number of empty rows, otherwise an odd number of empty rows. Now, given r, c0, and c1, we can determine n, and therefore the winner.Let us consider the case where there are no reclaimed cells. If r is even, then the second city can win with a mirroring strategy. When the first city reclaims cell (a,b), the second city follows with (r+1-a,b). Similarly, if r is odd then the first city wins by a mirroring strategy, playing first in ((r+1)/2, 0), and subsequently following the strategy for even r.Now suppose there are reclaimed cells. Let us define r0 as the number of empty rows in the segment starting from one end, and r1 as the number of empty rows starting from the other end.Case 1: if r0==r1 and the parity is even, the state is losing. All available moves will either decrease r0, decrease r1, or make the parity odd. The other player can respond to the first two types of moves with a mirroring strategy, and the third by making the parity even again (there will always be such a move that doesn’t affect r0 or r1, based on the fact that the argument above).Case 2: if abs(r0-r1)>=2 then the state is winning. Suppose, without loss of generality, that r0-r1>=2. Then either of the cells (r1+1, 1) and (r1+1, 2) may be reclaimed, and one of them must lead to Case 1 (since they both result in r0==r1, and one will have even parity and the other odd).Case 3: if abs(r0-r1)<2 and the parity is odd, the state is winning. If r0==r1, then we can change the parity without affecting r0 or r1, leaving our opponent in Case 1. Otherwise, there is a unique move that leaves our opponent in Case 1.(note that cases 2 and 3 together imply that all states with odd parity are winning)Case 4: if abs(r0-r1)==1 and the parity is even, there is at most one move that doesn’t leave our opponent in Case 2 or Case 3. Suppose r0==r1+1. We must change either r0 or r1, since all other moves will change the parity to odd. Thus our only option is to decrease r0, since decreasing r1 would leave our opponent in Case 2. We could decrease r0 by 1, but doing so would change the parity. Thus we must decrease r0 by 2, and there is at most one move that does so and keeps the parity even. It follows that if floor(r0/2)+floor(r1/2) is even, then this is a losing position, otherwise a winning position.See jill-jenn's extremely short 4225125.335D - Rectangles and Square -- AlexSkidanovEven though constraints were allowing O(k^2) solutions, in this editorial we will describe an O(n log(n)) solution. This problem has a rather long solution, involving several very different ideas: On the first step, for every rectangle we want to determine, if we were to consider this rectangle as the top left corner of a square, how long could the top and left edge of the square be (see the picture).If there’s no rectangle that is adjacent to the current rectangle on the right, which has the same y1 coordinate, then the top edge length is just the width of the current rectangle. Otherwise it is the width of the current rectangle plus the max top edge computed for the rectangle adjacent on the right. Left edge length is computed likewise.When top and left edge lengths are computed, we want to compute the max bottom and right edge length if this rectangle was the bottom right corner of the square.On the second step, we want to find all possible square frames. Look at this picture to better understand what we mean by square frame:To find a frame, let’s sort all the points first by x - y, and then by x (or y -- both will yield the same result). This way all the points are sorted by the diagonal they belong to, and then by the position on that diagonal. Then we will maintain a stack of pairs (position, edge length), where edge length is min(top edge length, left edge length). Position could be either x or y (within a given diagonal relative differences in xs and ys are the same). Min edge length tells us what is the largest square that could start at that position.When we process a new point on a diagonal, first pop from the stack all the pairs such that their position + edge length is less than our position. If stack after that is empty, then the current point cannot be a bottom right corner of any square. If stack is not empty, then there could be some frames with the current point being bottom right corner.Here we need to make a very important observation. If a square frame is contained within some other square frame, we don’t need to consider the outer square frame, since if the outer square frame is then proves to be an actual square, then the inner frame also has to be an actual square, and it is enough to only check an inner frame.With this observation made, we can only check if the last point on the stack forms a frame with the current point, there’s no need to check any other point on the stack. Since we already know that last element on the stack reaches to the right and to the bottom further than our current position (otherwise we would have popped it from the stack), to see if we form a frame with that point it is enough to check if we can reach that far to the top and to the left. To do so, check, if position of the current point minus min(bottom edge length, right edge length) for the current point is smaller or equal than the position of the point that is at the top of the stack. If it is, we have a square frame.When we have a frame, we move to the third step, where we check if the frame is filled in. To do that we just want to check if area within that square that is filled in by rectangles is equal to the area of the square. For every corner of every rectangle we will compute the area covered by rectangles which are fully located to the left and top from that point. To do that we can sort all the corners by x, and then by y, and process them one by one. We will maintain an interval tree where value at every position y represents area covered by rectangles processed so far that are fully above y. Then when we process a corner, we first update the interval tree if the corner is a bottom right corner, and then query the interval tree to see the area covered by rectangles to the up and left from the current corner.Then, when we have these number precomputed, for every square frame x1, y1, x2, y2 we can just get the area for (x2, y2), add area for (x1, y1) and subtract for (x2, y1) and for (x1, y2). See the author (AlexSkidanov)'s 4234601A possible O(k2) solution is similar, but makes checking whether or not the frame is filled much and a bunch of other checks easier. See my 4234474.335E - Counting Skyscrapers -- pieguyThe skyscrapers in this problem depict a data structure called Skip List. Skip list is similar to AVL and red black trees in a sense that it allows O(log N) insertions, deletions and searches (including searching for lower and upper bounds), as well as moving to the next element in sorted order in constant time. Skiplist is different from any tree structures because it has a practical thread safe implementation without locks (so-called lock-free). Lock free skiplists are used as a main data structure to store data in MemSQL, and the algorithm that Bob uses to traverse the skyscrapers is an O(log N) approach, that allows one to estimate the size of the skiplist. Thus, if Bob ended up with an estimation of n, the actual skiplist size is expected to be n (so if the first line of the input file is Bob, one just needs to print the number from the second line to the output). Formal proof is rather simple, and is left to the reader. Curiously, the converse does not hold. If the skiplist size is n, the expected return value of the estimation algorithm could be bigger than n. For an n that is significantly bigger than 2h the estimate converges to n - 1 + 2h, but this problem included cases with smaller n as well.Let us build up the solution one level at a time. When H is 0, the expected sum is N. Now for each additional level, we can add the expected cost of the zip lines on that level, and subtract the expected cost of the zip lines immediately below them. In the end we’ll have the total expected cost.For some floor number H, let’s consider some left and right tower, and determine the probability that a zip line exists between them. Let L be the distance between the two towers. A potential zip line of length L and height H exists if the towers at both ends are tall enough (probability 1 / 2H for each one), and the L - 1 towers between them are all shorter (probability 1 - 1 / 2H for each). Thus the probability that such a zip line exists is 1 / 22 * H × (1 - 1 / 2H)L - 1.Now, assuming that such a zip line exists, what’s the expected number of zip lines immediately below it? This is simply one more than the number of towers of height H - 1. Each of the L - 1 towers has probability 1 / (2H - 1) of having height H-1 (given that it has height at most H-1) -- use conditional probability () to calculate this. Thus the expected number of zip lines immediately below a zip line of length L and height H is 1 + (L - 1) / (2H - 1).For each length L, there are N - L possible zip lines with this length on each level. We multiply probability by cost for all possible zip lines to attain the expected value.The final answer is thereforeIt turns out the inner loop can be computed using matrix multiplication, for a running time of O(H log N). -- although the constraints is low enough that using matrix multiplication is an overkill -- O(H * N) will do.See the author (pieguy)'s 4234465. ...apparently this solution is much shorter than the \"easier\" problem's :)Congratulations Petr and tourist for the only persons solving this problem in-contest both on-site and off-site!335F - Buy One, Get One Free -- pieguyThis problem is equivalent to maximizing the total value of items that we can get for free.First, process the items into <#value, #number_of_items_with_that_value> tuples, which means we have #number_of_items_with_that_value items of value #value. Then, sort the tuples in descending order of #value.Iterate over those tuples and let #pieguy be an empty multi set()For each tuple <#val, #num>, we can calculate #max_free, the maximum number of items (not value) that we can get for free up to this point easily.So, we want to populate #pieguy so that it contains exactly #max_free “things”. #pieguy is special, in that we can compute the maximum price that we can get for free for n items by summing up the n most expensive items in #pieguy. How could #pieguy do that?For now, you may assume that each element of #pieguy contains the value of a single item that can be gotten for free. Thus, summing n items = value of n items that can be gotten for free. This is not correct, of course, since not all n arbitrary items can be simultaneously gotten for free in tandem, but we’ll come back to it later.We’re now at <#val, #num>, and we have #pieguy from previous iteration. #pieguy contains the previous #max_free elements. Assume that #num <= number of items more expensive than this value, for otherwise the remainder are ‘dead’ and useless for our current purpose. In particular, for the first tuple we process, we assume that #num is 0, since all of them cannot be gotten for free.Suppose we want to obtain exactly #max_free items. How many of the #num must we use?Let’s arrange the current members of #pieguy in descending order. For example, if #pieguy has 5 members: A B C D ELet’s arrange #num #val under #pieguy so that the rightmost one is located on position #max_free. For example, if #num is 6 and #max_free is 8 and #val is V.... A B C D E\n V V V V V VThese 6 Vs will be competing for a spot in #pieguy.Now...1) what happens if C < V? This means, instead of making C free, we can make V free instead! (if you’re wondering why this is possible, remember that #pieguy definition I gave you was not entirely honest yet). So, we replace C, D and E with all Vs, and we get our new #pieguy! A B V V V V V V (this should be sorted again, but C++’s multiset does that automagically).2) otherwise, C > V. So, V cannot contend for the 3-th place in #pieguy, it has to contend for a place larger than or equal to the 4-th.Now the fun begins! If you want to contend for the 4-th place, any solution MUST HAVE AT LEAST 2 V s (remember that the 4-th place is used in a solution consisting of at least 4 free items). In general, if you want to contend for the #max_free — i -th place, you MUST HAVE AT LEAST #num — i Vs. #proof? is easy, exercise (i’m honest!)Okay, so back to contending for the 4-th place. If D is still > V, we proceed. Otherwise, we know that D < V. This means, E and any element after E is also < V! Thus, we can replace all elements after or equal to E with V! The problem would be the final element of #pieguy.When the final element of #pieguy is included in the sum, it is only included in the sum of all n elements of #pieguy. You do this when you want to calculate the maximum sum of values of free items you can get when getting exactly #max_free items. Any such solution must include all #num elements with value #val. We have included #num-2 Vs in #pieguy. Thus, the final element of #pieguy must somehow contains 2 Vs! So, elements of #pieguy actually can do this. Instead of containing a single elmeent, each element of #pieguy is more of an “operation” that adds several value and removes several value. In our case, we want to add 2 Vs and remove something. The something? The smallest element that we can remove (the ones that we haven't removed)! C! (if you're wondering why not D or E, it's because (again) #pieguy is special -- it only forms a solution if the most expensive t are summed, not if some are skipped. -- we cannot skip C if we want to use D).So, Insert 2V — C into #pieguy, and the rest, insert V into #pieguy. 2V — C is < V, so summing all elements of #pieguy correctly found out the max value when we receive #max_free free items!Right! Cool! ...except that 2V — C can be negative. Why would we want to insert negative stuffs into #pieguy? We don’t! Actually, we check if 2V — C is negative. If it is, we continue instead, and check 3V — C — D and so on, under the same reason.That’s it folks! I skipped some details of why this works (for example, that the number of V selected is always sufficient to guarantee solution in #pieguy), but they're easier to see once you get this large idea. The result is then #pieguy.last_elementSee pieguy's beautiful 4234458.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8538",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 335\\s*E"
          },
          "content_length": 17873
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 1",
          "code": "*--st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 2",
          "code": "*----st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 3",
          "code": "*--st.lower_bound(*--st.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 4",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 5",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 1",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 2",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 3",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 4",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 5",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 6",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 7",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 8",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 9",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 10",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 11",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 12",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 13",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 14",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 15",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 16",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 17",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 18",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 19",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 20",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 21",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 22",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 23",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 24",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 25",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 26",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 27",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 28",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 29",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 30",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 31",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 32",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the first line: either 'Alice' or 'Bob'\n    string name = inf.readLine();\n    ensuref(name == \"Alice\" || name == \"Bob\", \"Name must be 'Alice' or 'Bob', got '%s'\", name.c_str());\n\n    // Read the second line: n and h\n    int n = inf.readInt(2, 30000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 30, \"h\");\n    inf.readEoln();\n\n    // Ensure that there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the first line: either 'Alice' or 'Bob'\n    string name = inf.readLine();\n    ensuref(name == \"Alice\" || name == \"Bob\", \"Name must be 'Alice' or 'Bob', got '%s'\", name.c_str());\n\n    // Read the second line: n and h\n    int n = inf.readInt(2, 30000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 30, \"h\");\n    inf.readEoln();\n\n    // Ensure that there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the first line: either 'Alice' or 'Bob'\n    string name = inf.readLine();\n    ensuref(name == \"Alice\" || name == \"Bob\", \"Name must be 'Alice' or 'Bob', got '%s'\", name.c_str());\n\n    // Read the second line: n and h\n    int n = inf.readInt(2, 30000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 30, \"h\");\n    inf.readEoln();\n\n    // Ensure that there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string name = opt<string>(\"name\", \"\");\n    int n = opt<int>(\"n\", -1);\n    int h = opt<int>(\"h\", -1);\n\n    const int N_MIN = 2, N_MAX = 30000;\n    const int H_MIN = 0, H_MAX = 30;\n\n    if (name != \"Alice\" && name != \"Bob\") {\n        name = rnd.next(2) ? \"Alice\" : \"Bob\";\n    }\n\n    if (n == -1) {\n        n = rnd.next(N_MIN, N_MAX);\n    } else {\n        ensuref(N_MIN <= n && n <= N_MAX, \"n out of bounds\");\n    }\n\n    if (h == -1) {\n        h = rnd.next(H_MIN, H_MAX);\n    } else {\n        ensuref(H_MIN <= h && h <= H_MAX, \"h out of bounds\");\n    }\n\n    printf(\"%s\\n\", name.c_str());\n    printf(\"%d %d\\n\", n, h);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string name = opt<string>(\"name\", \"\");\n    int n = opt<int>(\"n\", -1);\n    int h = opt<int>(\"h\", -1);\n\n    const int N_MIN = 2, N_MAX = 30000;\n    const int H_MIN = 0, H_MAX = 30;\n\n    if (name != \"Alice\" && name != \"Bob\") {\n        name = rnd.next(2) ? \"Alice\" : \"Bob\";\n    }\n\n    if (n == -1) {\n        n = rnd.next(N_MIN, N_MAX);\n    } else {\n        ensuref(N_MIN <= n && n <= N_MAX, \"n out of bounds\");\n    }\n\n    if (h == -1) {\n        h = rnd.next(H_MIN, H_MAX);\n    } else {\n        ensuref(H_MIN <= h && h <= H_MAX, \"h out of bounds\");\n    }\n\n    printf(\"%s\\n\", name.c_str());\n    printf(\"%d %d\\n\", n, h);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n and h values\n./gen -name Alice -n 2 -h 0\n./gen -name Bob -n 2 -h 0\n\n# Maximum n and h values\n./gen -name Alice -n 30000 -h 30\n./gen -name Bob -n 30000 -h 30\n\n# h = 0\n./gen -name Alice -n 10000 -h 0\n./gen -name Bob -n 20000 -h 0\n\n# h = 30\n./gen -name Alice -n 15000 -h 30\n./gen -name Bob -n 25000 -h 30\n\n# Random h values\n./gen -name Alice -n 5000 -h 15\n./gen -name Bob -n 5000 -h 15\n\n# Edge n values\n./gen -name Alice -n 2 -h 15\n./gen -name Bob -n 30000 -h 15\n\n# Random n and h values\n./gen -name Alice -n 12345 -h 20\n./gen -name Bob -n 23456 -h 10\n\n# Without specifying n and h (randomly generated)\n./gen -name Alice\n./gen -name Bob\n\n# Randomly generated n, h, and name\nfor i in {1..5}; do ./gen -name Alice; done\nfor i in {1..5}; do ./gen -name Bob; done\n\n# Random test cases\nfor i in {1..10}; do ./gen; done\n\n# h = 0 to test floor zero only\n./gen -name Alice -n 1000 -h 0\n./gen -name Bob -n 1000 -h 0\n\n# h = 1 to test minimal heights\n./gen -name Alice -n 2000 -h 1\n./gen -name Bob -n 2000 -h 1\n\n# n = max, h = min\n./gen -name Alice -n 30000 -h 0\n./gen -name Bob -n 30000 -h 0\n\n# n = min, h = max\n./gen -name Alice -n 2 -h 30\n./gen -name Bob -n 2 -h 30\n\n# Random values for n and h within valid ranges\n./gen -name Alice -n 25000 -h 25\n./gen -name Bob -n 25000 -h 5\n\n./gen -name Alice -n 5000 -h 5\n./gen -name Bob -n 5000 -h 25\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:09:58.491698",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "335/F",
      "title": "F. Buy One, Get One Free",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will begin with an integer n (1 ≤ n ≤ 500000), the number of pies you wish to acquire. Following this is a line with n integers, each indicating the cost of a pie. All costs are positive integers not exceeding 109.",
      "output_spec": "OutputPrint the minimum cost to acquire all the pies.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy63 4 5 3 4 5OutputCopy14InputCopy55 5 5 5 5OutputCopy25InputCopy4309999 6000 2080 2080OutputCopy314159",
      "description": "F. Buy One, Get One Free\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput will begin with an integer n (1 ≤ n ≤ 500000), the number of pies you wish to acquire. Following this is a line with n integers, each indicating the cost of a pie. All costs are positive integers not exceeding 109.\n\nOutputPrint the minimum cost to acquire all the pies.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy63 4 5 3 4 5OutputCopy14InputCopy55 5 5 5 5OutputCopy25InputCopy4309999 6000 2080 2080OutputCopy314159\n\nInputCopy63 4 5 3 4 5\n\nOutputCopy14\n\nInputCopy55 5 5 5 5\n\nOutputCopy25\n\nInputCopy4309999 6000 2080 2080\n\nOutputCopy314159\n\nNoteIn the first test case you can pay for a pie with cost 5 and get a pie with cost 4 for free, then pay for a pie with cost 5 and get a pie with cost 3 for free, then pay for a pie with cost 4 and get a pie with cost 3 for free.In the second test case you have to pay full price for every pie.",
      "solutions": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL start[c]up will take place on August, 3rd, 10:00am PDT. There will be two contests running simultaneously, one for people who participate onsite, and one for everybody else who advanced to the round two. Both rounds share the problemset and are rated based on the combined scoreboard.Onsite participants will have special prizes for first three places. All onsite participants as well as the top 100 in the online contest will receive a start[c]up t-shirt.People who have not advanced to the round two can participate in the round unofficially. Unofficial participation will be rated.The contest will be 3 hours long, and will feature 6 problems. The score distribution is 500-1000-1000-2000-2500-3000.The problem set has been developed by MemSQL engineers pieguy, nika, exod40, SkidanovAlex and dolphinigle.Good luck and happy coding!UPDATE: Editorial is up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8506",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces",
          "content": "This is the Editorial for MemSQL start[c]up Round 2 and MemSQL start[c]up Round 2 - online version. Congratulations RAD for online round winner and Petr for onsite and overall score winner!This editorial is written jointly by the contest's coordinators (i.e., MemSQL engineers).335A - Banana -- AlexSkidanovReference solution: Jimanbanashi's 4222182Instead of calculating the smallest possible number of sheets given a fixed n, let us instead try to compute the smallest possible value of n given a fixed number of sheets. Let k denote the number of sheets. If a particular letter appears p times in s, then it must appear at least ceil(p / k) times in the sheet. Thus we can compute the smallest possible value of n by summing ceil(p / k) over all letters. Now the original problem can be solved using binary search on k (or brute force, since the constraints were small enough).335B - Palindrome -- AlexSkidanovThere’s a well known O(n2) solution that allows one to find a longest subsequence of a string which is a palindrome: for every pair of positions l and r, such that l ≤ r, find the length d of the longest palindrome subsequence between those positions. d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).There are two ways to solve this problem faster than O(n2) with the constraints given in the problem: Use dynamic programming. For every position l and length k find the leftmost position r, such that there’s a palindrome of length k in the substring of s starting at l and ending at r. For position l and length k r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),where next(pos, s) is the next occurrence of character s after position pos. Next can be precomputed for all the positions and all the characters in advance. See DamianS's 4221965. If length is less than 2600, use the well-known O(n2) dynamic programming approach. Otherwise by pigeonhole principle there’s at least one character that appears in the string at least 100 times -- find it and print it 100 times. See SteamTurbine's 4224770. 335C - More Reclamation -- AlexSkidanovThe most straightforward way to solve this problem is to use Grundy numbers. Define a segment as a maximal range of rows in which no cells have been reclaimed. Since segments have no bearing on other segments, they can be assigned Grundy numbers. There are 4 types of segments: The entire river. A section of river containing one of the ends. A section of river blocked at both ends in the same column A section of river blocked at both ends in different columns Each time a cell is reclaimed, it splits a segment into 2 segments (one of which may have size 0). We can compute the Grundy value for all possible segments in O(r2). Then after sorting the reclaimed cells by row number, we can find all segments and compute the Grundy number for the full state.See Dmitry_Egorov's 4221888.Alternatively, we can compute the result directly. Suppose the game is over. We can determine who won the game just by looking at the top row and the bottom row. Let us define “parity” as the modulo 2 remainder of (r + n + c0 + c1), where c0 is the column of the reclaimed cell with the lowest row, and c1 is the column of the reclaimed cell with the highest row. Claim: when the game is over, the parity is even. This can be seen by observing that the number of empty rows is equal to the number of times the column changes. In other words, if c0==c1, there are an even number of empty rows, otherwise an odd number of empty rows. Now, given r, c0, and c1, we can determine n, and therefore the winner.Let us consider the case where there are no reclaimed cells. If r is even, then the second city can win with a mirroring strategy. When the first city reclaims cell (a,b), the second city follows with (r+1-a,b). Similarly, if r is odd then the first city wins by a mirroring strategy, playing first in ((r+1)/2, 0), and subsequently following the strategy for even r.Now suppose there are reclaimed cells. Let us define r0 as the number of empty rows in the segment starting from one end, and r1 as the number of empty rows starting from the other end.Case 1: if r0==r1 and the parity is even, the state is losing. All available moves will either decrease r0, decrease r1, or make the parity odd. The other player can respond to the first two types of moves with a mirroring strategy, and the third by making the parity even again (there will always be such a move that doesn’t affect r0 or r1, based on the fact that the argument above).Case 2: if abs(r0-r1)>=2 then the state is winning. Suppose, without loss of generality, that r0-r1>=2. Then either of the cells (r1+1, 1) and (r1+1, 2) may be reclaimed, and one of them must lead to Case 1 (since they both result in r0==r1, and one will have even parity and the other odd).Case 3: if abs(r0-r1)<2 and the parity is odd, the state is winning. If r0==r1, then we can change the parity without affecting r0 or r1, leaving our opponent in Case 1. Otherwise, there is a unique move that leaves our opponent in Case 1.(note that cases 2 and 3 together imply that all states with odd parity are winning)Case 4: if abs(r0-r1)==1 and the parity is even, there is at most one move that doesn’t leave our opponent in Case 2 or Case 3. Suppose r0==r1+1. We must change either r0 or r1, since all other moves will change the parity to odd. Thus our only option is to decrease r0, since decreasing r1 would leave our opponent in Case 2. We could decrease r0 by 1, but doing so would change the parity. Thus we must decrease r0 by 2, and there is at most one move that does so and keeps the parity even. It follows that if floor(r0/2)+floor(r1/2) is even, then this is a losing position, otherwise a winning position.See jill-jenn's extremely short 4225125.335D - Rectangles and Square -- AlexSkidanovEven though constraints were allowing O(k^2) solutions, in this editorial we will describe an O(n log(n)) solution. This problem has a rather long solution, involving several very different ideas: On the first step, for every rectangle we want to determine, if we were to consider this rectangle as the top left corner of a square, how long could the top and left edge of the square be (see the picture).If there’s no rectangle that is adjacent to the current rectangle on the right, which has the same y1 coordinate, then the top edge length is just the width of the current rectangle. Otherwise it is the width of the current rectangle plus the max top edge computed for the rectangle adjacent on the right. Left edge length is computed likewise.When top and left edge lengths are computed, we want to compute the max bottom and right edge length if this rectangle was the bottom right corner of the square.On the second step, we want to find all possible square frames. Look at this picture to better understand what we mean by square frame:To find a frame, let’s sort all the points first by x - y, and then by x (or y -- both will yield the same result). This way all the points are sorted by the diagonal they belong to, and then by the position on that diagonal. Then we will maintain a stack of pairs (position, edge length), where edge length is min(top edge length, left edge length). Position could be either x or y (within a given diagonal relative differences in xs and ys are the same). Min edge length tells us what is the largest square that could start at that position.When we process a new point on a diagonal, first pop from the stack all the pairs such that their position + edge length is less than our position. If stack after that is empty, then the current point cannot be a bottom right corner of any square. If stack is not empty, then there could be some frames with the current point being bottom right corner.Here we need to make a very important observation. If a square frame is contained within some other square frame, we don’t need to consider the outer square frame, since if the outer square frame is then proves to be an actual square, then the inner frame also has to be an actual square, and it is enough to only check an inner frame.With this observation made, we can only check if the last point on the stack forms a frame with the current point, there’s no need to check any other point on the stack. Since we already know that last element on the stack reaches to the right and to the bottom further than our current position (otherwise we would have popped it from the stack), to see if we form a frame with that point it is enough to check if we can reach that far to the top and to the left. To do so, check, if position of the current point minus min(bottom edge length, right edge length) for the current point is smaller or equal than the position of the point that is at the top of the stack. If it is, we have a square frame.When we have a frame, we move to the third step, where we check if the frame is filled in. To do that we just want to check if area within that square that is filled in by rectangles is equal to the area of the square. For every corner of every rectangle we will compute the area covered by rectangles which are fully located to the left and top from that point. To do that we can sort all the corners by x, and then by y, and process them one by one. We will maintain an interval tree where value at every position y represents area covered by rectangles processed so far that are fully above y. Then when we process a corner, we first update the interval tree if the corner is a bottom right corner, and then query the interval tree to see the area covered by rectangles to the up and left from the current corner.Then, when we have these number precomputed, for every square frame x1, y1, x2, y2 we can just get the area for (x2, y2), add area for (x1, y1) and subtract for (x2, y1) and for (x1, y2). See the author (AlexSkidanov)'s 4234601A possible O(k2) solution is similar, but makes checking whether or not the frame is filled much and a bunch of other checks easier. See my 4234474.335E - Counting Skyscrapers -- pieguyThe skyscrapers in this problem depict a data structure called Skip List. Skip list is similar to AVL and red black trees in a sense that it allows O(log N) insertions, deletions and searches (including searching for lower and upper bounds), as well as moving to the next element in sorted order in constant time. Skiplist is different from any tree structures because it has a practical thread safe implementation without locks (so-called lock-free). Lock free skiplists are used as a main data structure to store data in MemSQL, and the algorithm that Bob uses to traverse the skyscrapers is an O(log N) approach, that allows one to estimate the size of the skiplist. Thus, if Bob ended up with an estimation of n, the actual skiplist size is expected to be n (so if the first line of the input file is Bob, one just needs to print the number from the second line to the output). Formal proof is rather simple, and is left to the reader. Curiously, the converse does not hold. If the skiplist size is n, the expected return value of the estimation algorithm could be bigger than n. For an n that is significantly bigger than 2h the estimate converges to n - 1 + 2h, but this problem included cases with smaller n as well.Let us build up the solution one level at a time. When H is 0, the expected sum is N. Now for each additional level, we can add the expected cost of the zip lines on that level, and subtract the expected cost of the zip lines immediately below them. In the end we’ll have the total expected cost.For some floor number H, let’s consider some left and right tower, and determine the probability that a zip line exists between them. Let L be the distance between the two towers. A potential zip line of length L and height H exists if the towers at both ends are tall enough (probability 1 / 2H for each one), and the L - 1 towers between them are all shorter (probability 1 - 1 / 2H for each). Thus the probability that such a zip line exists is 1 / 22 * H × (1 - 1 / 2H)L - 1.Now, assuming that such a zip line exists, what’s the expected number of zip lines immediately below it? This is simply one more than the number of towers of height H - 1. Each of the L - 1 towers has probability 1 / (2H - 1) of having height H-1 (given that it has height at most H-1) -- use conditional probability () to calculate this. Thus the expected number of zip lines immediately below a zip line of length L and height H is 1 + (L - 1) / (2H - 1).For each length L, there are N - L possible zip lines with this length on each level. We multiply probability by cost for all possible zip lines to attain the expected value.The final answer is thereforeIt turns out the inner loop can be computed using matrix multiplication, for a running time of O(H log N). -- although the constraints is low enough that using matrix multiplication is an overkill -- O(H * N) will do.See the author (pieguy)'s 4234465. ...apparently this solution is much shorter than the \"easier\" problem's :)Congratulations Petr and tourist for the only persons solving this problem in-contest both on-site and off-site!335F - Buy One, Get One Free -- pieguyThis problem is equivalent to maximizing the total value of items that we can get for free.First, process the items into <#value, #number_of_items_with_that_value> tuples, which means we have #number_of_items_with_that_value items of value #value. Then, sort the tuples in descending order of #value.Iterate over those tuples and let #pieguy be an empty multi set()For each tuple <#val, #num>, we can calculate #max_free, the maximum number of items (not value) that we can get for free up to this point easily.So, we want to populate #pieguy so that it contains exactly #max_free “things”. #pieguy is special, in that we can compute the maximum price that we can get for free for n items by summing up the n most expensive items in #pieguy. How could #pieguy do that?For now, you may assume that each element of #pieguy contains the value of a single item that can be gotten for free. Thus, summing n items = value of n items that can be gotten for free. This is not correct, of course, since not all n arbitrary items can be simultaneously gotten for free in tandem, but we’ll come back to it later.We’re now at <#val, #num>, and we have #pieguy from previous iteration. #pieguy contains the previous #max_free elements. Assume that #num <= number of items more expensive than this value, for otherwise the remainder are ‘dead’ and useless for our current purpose. In particular, for the first tuple we process, we assume that #num is 0, since all of them cannot be gotten for free.Suppose we want to obtain exactly #max_free items. How many of the #num must we use?Let’s arrange the current members of #pieguy in descending order. For example, if #pieguy has 5 members: A B C D ELet’s arrange #num #val under #pieguy so that the rightmost one is located on position #max_free. For example, if #num is 6 and #max_free is 8 and #val is V.... A B C D E\n V V V V V VThese 6 Vs will be competing for a spot in #pieguy.Now...1) what happens if C < V? This means, instead of making C free, we can make V free instead! (if you’re wondering why this is possible, remember that #pieguy definition I gave you was not entirely honest yet). So, we replace C, D and E with all Vs, and we get our new #pieguy! A B V V V V V V (this should be sorted again, but C++’s multiset does that automagically).2) otherwise, C > V. So, V cannot contend for the 3-th place in #pieguy, it has to contend for a place larger than or equal to the 4-th.Now the fun begins! If you want to contend for the 4-th place, any solution MUST HAVE AT LEAST 2 V s (remember that the 4-th place is used in a solution consisting of at least 4 free items). In general, if you want to contend for the #max_free — i -th place, you MUST HAVE AT LEAST #num — i Vs. #proof? is easy, exercise (i’m honest!)Okay, so back to contending for the 4-th place. If D is still > V, we proceed. Otherwise, we know that D < V. This means, E and any element after E is also < V! Thus, we can replace all elements after or equal to E with V! The problem would be the final element of #pieguy.When the final element of #pieguy is included in the sum, it is only included in the sum of all n elements of #pieguy. You do this when you want to calculate the maximum sum of values of free items you can get when getting exactly #max_free items. Any such solution must include all #num elements with value #val. We have included #num-2 Vs in #pieguy. Thus, the final element of #pieguy must somehow contains 2 Vs! So, elements of #pieguy actually can do this. Instead of containing a single elmeent, each element of #pieguy is more of an “operation” that adds several value and removes several value. In our case, we want to add 2 Vs and remove something. The something? The smallest element that we can remove (the ones that we haven't removed)! C! (if you're wondering why not D or E, it's because (again) #pieguy is special -- it only forms a solution if the most expensive t are summed, not if some are skipped. -- we cannot skip C if we want to use D).So, Insert 2V — C into #pieguy, and the rest, insert V into #pieguy. 2V — C is < V, so summing all elements of #pieguy correctly found out the max value when we receive #max_free free items!Right! Cool! ...except that 2V — C can be negative. Why would we want to insert negative stuffs into #pieguy? We don’t! Actually, we check if 2V — C is negative. If it is, we continue instead, and check 3V — C — D and so on, under the same reason.That’s it folks! I skipped some details of why this works (for example, that the number of V selected is always sufficient to guarantee solution in #pieguy), but they're easier to see once you get this large idea. The result is then #pieguy.last_elementSee pieguy's beautiful 4234458.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8538",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 335\\s*F"
          },
          "content_length": 17873
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 1",
          "code": "*--st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 2",
          "code": "*----st.end()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 3",
          "code": "*--st.lower_bound(*--st.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 4",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 - Codeforces - Code 5",
          "code": "set<int> st;\n...\nset<int>::iterator it=st.end();\nint mx=*(--it); // max\nint mx2=*(--it); // second largest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8506",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 1",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 2",
          "code": "d[l][r] = max(d[l][r-1], d[l + 1][r], s[l] == s[r] ? d[l + 1][r - 1] + 1 : 0).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 3",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 4",
          "code": "r[l][k] = min(r[l + 1][k], next(r[l + 1][k - 1], s[l])),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 5",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 6",
          "code": "A B C D E\n    V V V V V V",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 7",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 8",
          "code": "10 10 9 9 6 6 4 4 4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 9",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 10",
          "code": "0\n  9 18\n  9 18 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 11",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 12",
          "code": "0\n  9 9\n  9 9 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 13",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 14",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 15",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 16",
          "code": "9 9 0\n    6 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 17",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 18",
          "code": "9 9 0\n    6 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 19",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 20",
          "code": "9 9 3 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 21",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 22",
          "code": "9 9 4 0 0 0\n  4 4 4 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 23",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 24",
          "code": "9 9 4 0  0  0\n  4 4 4 4 -1 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 25",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 26",
          "code": "9 9 4 4 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 27",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 28",
          "code": "10 10 9 9 6 6 6 6 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 29",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 30",
          "code": "9 9 3 3\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 31",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        },
        {
          "title": "MemSQL start[c]up Round 2 -- Editorial - Codeforces - Code 32",
          "code": "9 9 3 4\n        4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8538",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    vector<int> prices = inf.readInts(n, 1, 1000000000, \"prices\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    vector<int> prices = inf.readInts(n, 1, 1000000000, \"prices\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    vector<int> prices = inf.readInts(n, 1, 1000000000, \"prices\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> costs(n);\n\n    if (type == \"random\")\n    {\n        for (int i = 0; i < n; ++i)\n            costs[i] = rnd.next(1, 1000000000);\n    }\n    else if (type == \"samecost\")\n    {\n        int cost = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            costs[i] = cost;\n    }\n    else if (type == \"increasing\")\n    {\n        costs[0] = rnd.next(1, max(1, 1000000000 - n));\n        for (int i = 1; i < n; ++i)\n            costs[i] = min(1000000000, costs[i-1] + rnd.next(1, 10));\n    }\n    else if (type == \"decreasing\")\n    {\n        costs[0] = rnd.next(n, 1000000000);\n        for (int i = 1; i < n; ++i)\n            costs[i] = max(1, costs[i-1] - rnd.next(1, min(10, costs[i-1] - 1)));\n    }\n    else if (type == \"maxcost\")\n    {\n        int cost = 1000000000;\n        for (int i = 0; i < n; ++i)\n            costs[i] = cost;\n    }\n    else if (type == \"mincost\")\n    {\n        int cost = 1;\n        for (int i = 0; i < n; ++i)\n            costs[i] = cost;\n    }\n    else if (type == \"duplicates\")\n    {\n        for (int i = 0; i < n; ++i)\n            costs[i] = rnd.next(1, 1000);\n    }\n    else if (type == \"alternating\")\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            if (i % 2 == 0)\n                costs[i] = rnd.next(500000001, 1000000000);\n            else\n                costs[i] = rnd.next(1, 500000000);\n        }\n    }\n    else\n    {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            costs[i] = rnd.next(1, 1000000000);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", costs[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> costs(n);\n\n    if (type == \"random\")\n    {\n        for (int i = 0; i < n; ++i)\n            costs[i] = rnd.next(1, 1000000000);\n    }\n    else if (type == \"samecost\")\n    {\n        int cost = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            costs[i] = cost;\n    }\n    else if (type == \"increasing\")\n    {\n        costs[0] = rnd.next(1, max(1, 1000000000 - n));\n        for (int i = 1; i < n; ++i)\n            costs[i] = min(1000000000, costs[i-1] + rnd.next(1, 10));\n    }\n    else if (type == \"decreasing\")\n    {\n        costs[0] = rnd.next(n, 1000000000);\n        for (int i = 1; i < n; ++i)\n            costs[i] = max(1, costs[i-1] - rnd.next(1, min(10, costs[i-1] - 1)));\n    }\n    else if (type == \"maxcost\")\n    {\n        int cost = 1000000000;\n        for (int i = 0; i < n; ++i)\n            costs[i] = cost;\n    }\n    else if (type == \"mincost\")\n    {\n        int cost = 1;\n        for (int i = 0; i < n; ++i)\n            costs[i] = cost;\n    }\n    else if (type == \"duplicates\")\n    {\n        for (int i = 0; i < n; ++i)\n            costs[i] = rnd.next(1, 1000);\n    }\n    else if (type == \"alternating\")\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            if (i % 2 == 0)\n                costs[i] = rnd.next(500000001, 1000000000);\n            else\n                costs[i] = rnd.next(1, 500000000);\n        }\n    }\n    else\n    {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            costs[i] = rnd.next(1, 1000000000);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", costs[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type mincost\n./gen -n 1 -type maxcost\n./gen -n 2 -type samecost\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 5 -type duplicates\n./gen -n 7 -type random\n\n./gen -n 10 -type random\n./gen -n 10 -type samecost\n./gen -n 10 -type duplicates\n./gen -n 11 -type random\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type duplicates\n./gen -n 101 -type random\n\n./gen -n 99999 -type random\n./gen -n 99999 -type duplicates\n\n./gen -n 1000 -type random\n./gen -n 1000 -type maxcost\n./gen -n 1000 -type mincost\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1001 -type duplicates\n\n./gen -n 499999 -type random\n\n./gen -n 500000 -type random\n./gen -n 500000 -type maxcost\n./gen -n 500000 -type mincost\n./gen -n 500000 -type increasing\n./gen -n 500000 -type decreasing\n./gen -n 500000 -type duplicates\n./gen -n 500000 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:00.231315",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "336/A",
      "title": "A. Vasily the Bear and Triangle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers x, y ( - 109 ≤ x, y ≤ 109, x ≠ 0, y ≠ 0).",
      "output_spec": "OutputPrint in the single line four integers x1, y1, x2, y2 — the coordinates of the required points.",
      "sample_tests": "ExamplesInputCopy10 5OutputCopy0 15 15 0InputCopy-10 5OutputCopy-15 0 0 15",
      "description": "A. Vasily the Bear and Triangle\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers x, y ( - 109 ≤ x, y ≤ 109, x ≠ 0, y ≠ 0).\n\nOutputPrint in the single line four integers x1, y1, x2, y2 — the coordinates of the required points.\n\nInputCopy10 5OutputCopy0 15 15 0InputCopy-10 5OutputCopy-15 0 0 15\n\nInputCopy10 5\n\nOutputCopy0 15 15 0\n\nInputCopy-10 5\n\nOutputCopy-15 0 0 15\n\nNoteFigure to the first sample",
      "solutions": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on August 9 at 19:30 MSK) you are lucky to participate in Codeforces Round #195 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Eugene Sobolev (Seyaua), Vitaly Aksenov (Aksenov239) and Sergey Sukhov (Serega) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for translation of tutorial, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.We wish everyone good luck and high rating!UPD: English tutorialUPD: Congratulations for winners: Triolossus_3 WHITE2302 PM2.5 Separately, I want to congratulate Egor Kulikov (Egor) — the only person who had passed the all problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8524",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 856
        },
        {
          "title": "Tutorial Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "336A - Vasily the Bear and Triangleval = |x| + |y|. Then first point is (val * sign(x), 0), second — (0, val * sign(y)). Swap points if needed according to statement. Let's see why this is the answer. Conditions x ≠ 0 and y ≠ 0 give us that one point is on X-axis, and the other on Y-axis. Let's see how it works for x > 0 and y > 0. Other cases can be proved in similar way. We need to show, that (x, y) belongs to our triangle(including it's borders). In fact (x, y) belongs to segment, connecting (x + y, 0) with (0, x + y). Line through (x + y, 0) and (0, x + y) is Y =  - X + x + y. Using coordinates (x, y) in this equation proves the statement.Author's solution336B - Vasily the Bear and FlyAlso you could iterate circles, adding distance for each of them and dividing by m2 in the end. Let's see how the i-th iteration works 1 ≤ i ≤ m. Distance to m + i-th circle is 2R. Distance to m + j-th circle, where |j - i| = 1, is . For other circles it's quite simple to calculate sum of distances. There are i - 2 circles which located to the left of current circle. So, sum of distances for these circles is . In the same manner we can calculate answer for cirlcles which are located to the right of the current circleAuthor's solution336C - Vasily the Bear and SequenceLet's check max beauty from 29 to 0. For every possible beauty i our aim is to find largest subset with such beauty. We will include in this subset all numbers, that have 1 at i-th bit. After that we do bitwise and as in statement, and if the resulting value is divisible by 2i, then there is the answer. Solution works in O(n).Author's solution336D - Vasily the Bear and Beautiful Stringsany — random binary string, s + g — concatenation of strings, MOD = 1000000007.String 1 + any always transforms into 0, string 1 — into 1. String 01 + any always transforms into 1, string 01 — into 0. String 001 + any transforms into 0, string 001 — into 1, and so on. Using these facts let's consider following solution.Cases like strings without ones or zeroes are easy. For every i (in zero-based numbering) let's assume that it is position of the first occurence of 1 in our string. Using already known facts we can understand what is the final result of transformations for such string. If the result equals to g, we add C(cnt[0] + cnt[1] - i - 1, cnt[1] - 1) to the answer. Calculation of binomial coefficients is following: fact[i] = i!%MOD, , C(n, k) = fact[n]inv(fact[n - i]fact[i]), where inv(a) — inverse element modulo MOD. inv(a) = aMOD - 2, because MOD is prime number.Author's solution336E - Vasily the Bear and Painting SquarePretty tough problem. Consider following DP dp[lvl][op][cur][type] — number of ways to take op triangles, if we have 2lvl + 1 squares. cur, type — auxiliary values. Answer will be dp[n][k][0][2]k!. type means type of transitions we make. cur — amount of used quarters (cur = 4 — 2 quarters, cur < 4 — cur quarters). It is important to distinguish cur = 2 from cur = 4, because amount of consecutive pairs of unused quarters is different.About transitions. type = 2. Iterate amount of pairs (considering cur) of consecutive quarters that we will take. It is important for them to have no common quarters. We can get two pairs only in case cur = 0. Let's also take some quarters that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][newcur][1] * cntwaystochoose. For better understanding of type = 2 check my solution (calc(n, k, cur, type) — isfordp[n][k][cur][type]). type = 1. Now we take triangles at the borders (number of squares is 2*lvl + 1). \"at the borders\" means marked X, see the picture.Iterate amount of pairs (considering cur) of consecutive triangles we take. It is important for pairs to have no common triangles. Let's also take some triangles that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][cur][0] * cntwaystochoose.type = 0. We take triangles at the borders (number of squares is 2*lvl). \"at the borders\" means marked X, see the picture.Take some triangles, not in pairs. Calculate number of ways to select corresponding triangles and add to current DP-state value dp[lvl - 1][op - choosen][cur][2] * cntwaystochoose. Starting values: dp[0][0][cur][1] = 1, dp[0][cnt][cur][1] = 0, cnt > 0.Author's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8574",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 336\\s*A"
          },
          "content_length": 4410
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 1",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 2",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 3",
          "code": "-30329013470001650000000000000000000000000000.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000000, 1000000000, \"y\");\n    inf.readEoln();\n\n    ensuref(x != 0, \"x must not be zero\");\n    ensuref(y != 0, \"y must not be zero\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000000, 1000000000, \"y\");\n    inf.readEoln();\n\n    ensuref(x != 0, \"x must not be zero\");\n    ensuref(y != 0, \"y must not be zero\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000000, 1000000000, \"y\");\n    inf.readEoln();\n\n    ensuref(x != 0, \"x must not be zero\");\n    ensuref(y != 0, \"y must not be zero\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int x = opt<int>(\"x\", 0);\n    int y = opt<int>(\"y\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    int maxabs = opt<int>(\"maxabs\", 1000000000);\n\n    if (x == 0 || y == 0) {\n        if (type == \"random\") {\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"x_positive\") {\n            x = rnd.next(1, maxabs);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"x_negative\") {\n            x = rnd.next(-maxabs, -1);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"y_positive\") {\n            y = rnd.next(1, maxabs);\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n        } else if (type == \"y_negative\") {\n            y = rnd.next(-maxabs, -1);\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n        } else if (type == \"both_positive\") {\n            x = rnd.next(1, maxabs);\n            y = rnd.next(1, maxabs);\n        } else if (type == \"both_negative\") {\n            x = rnd.next(-maxabs, -1);\n            y = rnd.next(-maxabs, -1);\n        } else if (type == \"opposite_xy\") {\n            x = rnd.next(1, maxabs);\n            y = -x;\n        } else if (type == \"equal_xy\") {\n            x = rnd.next(1, maxabs);\n            if (rnd.next(2) == 0) x = -x;\n            y = x;\n        } else if (type == \"small_values\") {\n            x = rnd.next(1, 10);\n            if (rnd.next(2)) x = -x;\n            y = rnd.next(1, 10);\n            if (rnd.next(2)) y = -y;\n        } else if (type == \"max_values\") {\n            x = rnd.next(1) ? maxabs : -maxabs;\n            y = rnd.next(1) ? maxabs : -maxabs;\n        } else if (type == \"near_zero\") {\n            x = rnd.next(1, 10);\n            if (rnd.next(2)) x = -x;\n            y = rnd.next(1, 10);\n            if (rnd.next(2)) y = -y;\n        } else if (type == \"x_large\") {\n            x = rnd.next(int(9e8), maxabs);\n            if (rnd.next(2)) x = -x;\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"y_large\") {\n            y = rnd.next(int(9e8), maxabs);\n            if (rnd.next(2)) y = -y;\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n        } else {\n            // default to random\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        }\n    }\n\n    // Output x and y\n    printf(\"%d %d\\n\", x, y);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int x = opt<int>(\"x\", 0);\n    int y = opt<int>(\"y\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    int maxabs = opt<int>(\"maxabs\", 1000000000);\n\n    if (x == 0 || y == 0) {\n        if (type == \"random\") {\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"x_positive\") {\n            x = rnd.next(1, maxabs);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"x_negative\") {\n            x = rnd.next(-maxabs, -1);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"y_positive\") {\n            y = rnd.next(1, maxabs);\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n        } else if (type == \"y_negative\") {\n            y = rnd.next(-maxabs, -1);\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n        } else if (type == \"both_positive\") {\n            x = rnd.next(1, maxabs);\n            y = rnd.next(1, maxabs);\n        } else if (type == \"both_negative\") {\n            x = rnd.next(-maxabs, -1);\n            y = rnd.next(-maxabs, -1);\n        } else if (type == \"opposite_xy\") {\n            x = rnd.next(1, maxabs);\n            y = -x;\n        } else if (type == \"equal_xy\") {\n            x = rnd.next(1, maxabs);\n            if (rnd.next(2) == 0) x = -x;\n            y = x;\n        } else if (type == \"small_values\") {\n            x = rnd.next(1, 10);\n            if (rnd.next(2)) x = -x;\n            y = rnd.next(1, 10);\n            if (rnd.next(2)) y = -y;\n        } else if (type == \"max_values\") {\n            x = rnd.next(1) ? maxabs : -maxabs;\n            y = rnd.next(1) ? maxabs : -maxabs;\n        } else if (type == \"near_zero\") {\n            x = rnd.next(1, 10);\n            if (rnd.next(2)) x = -x;\n            y = rnd.next(1, 10);\n            if (rnd.next(2)) y = -y;\n        } else if (type == \"x_large\") {\n            x = rnd.next(int(9e8), maxabs);\n            if (rnd.next(2)) x = -x;\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        } else if (type == \"y_large\") {\n            y = rnd.next(int(9e8), maxabs);\n            if (rnd.next(2)) y = -y;\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n        } else {\n            // default to random\n            do {\n                x = rnd.next(-maxabs, maxabs);\n            } while (x == 0);\n            do {\n                y = rnd.next(-maxabs, maxabs);\n            } while (y == 0);\n        }\n    }\n\n    // Output x and y\n    printf(\"%d %d\\n\", x, y);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -x 10 -y 5\n./gen -x -10 -y 5\n\n./gen -type both_positive\n./gen -type both_negative\n\n./gen -type x_positive\n./gen -type x_negative\n./gen -type y_positive\n./gen -type y_negative\n\n./gen -type opposite_xy\n./gen -type equal_xy\n\n./gen -type small_values\n./gen -type near_zero\n\n./gen -type max_values\n./gen -type x_large\n./gen -type y_large\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type random -maxabs 1000000\n\n./gen -type random -maxabs 10\n\n./gen -x 1 -y 1\n./gen -x -1 -y -1\n\n./gen -x 1000000000 -y 1000000000\n./gen -x -1000000000 -y -1000000000\n\n./gen -x 1000000000 -y -1000000000\n./gen -x -1000000000 -y 1000000000\n\n./gen -x 999999999 -y 999999999\n./gen -x -999999999 -y 999999999\n./gen -x 999999999 -y -999999999\n\n./gen -x 10 -y 10\n./gen -x -10 -y 10\n./gen -x 10 -y -10\n./gen -x -10 -y -10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:02.198263",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "336/B",
      "title": "B. Vasily the Bear and Fly",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers m, R (1 ≤ m ≤ 105, 1 ≤ R ≤ 10).",
      "output_spec": "OutputIn a single line print a single real number — the answer to the problem. The answer will be considered correct if its absolute or relative error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy2.0000000000InputCopy2 2OutputCopy5.4142135624",
      "description": "B. Vasily the Bear and Fly\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers m, R (1 ≤ m ≤ 105, 1 ≤ R ≤ 10).\n\nOutputIn a single line print a single real number — the answer to the problem. The answer will be considered correct if its absolute or relative error doesn't exceed 10 - 6.\n\nInputCopy1 1OutputCopy2.0000000000InputCopy2 2OutputCopy5.4142135624\n\nInputCopy1 1\n\nOutputCopy2.0000000000\n\nInputCopy2 2\n\nOutputCopy5.4142135624\n\nNoteFigure to the second sample",
      "solutions": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on August 9 at 19:30 MSK) you are lucky to participate in Codeforces Round #195 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Eugene Sobolev (Seyaua), Vitaly Aksenov (Aksenov239) and Sergey Sukhov (Serega) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for translation of tutorial, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.We wish everyone good luck and high rating!UPD: English tutorialUPD: Congratulations for winners: Triolossus_3 WHITE2302 PM2.5 Separately, I want to congratulate Egor Kulikov (Egor) — the only person who had passed the all problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8524",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 856
        },
        {
          "title": "Tutorial Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "336A - Vasily the Bear and Triangleval = |x| + |y|. Then first point is (val * sign(x), 0), second — (0, val * sign(y)). Swap points if needed according to statement. Let's see why this is the answer. Conditions x ≠ 0 and y ≠ 0 give us that one point is on X-axis, and the other on Y-axis. Let's see how it works for x > 0 and y > 0. Other cases can be proved in similar way. We need to show, that (x, y) belongs to our triangle(including it's borders). In fact (x, y) belongs to segment, connecting (x + y, 0) with (0, x + y). Line through (x + y, 0) and (0, x + y) is Y =  - X + x + y. Using coordinates (x, y) in this equation proves the statement.Author's solution336B - Vasily the Bear and FlyAlso you could iterate circles, adding distance for each of them and dividing by m2 in the end. Let's see how the i-th iteration works 1 ≤ i ≤ m. Distance to m + i-th circle is 2R. Distance to m + j-th circle, where |j - i| = 1, is . For other circles it's quite simple to calculate sum of distances. There are i - 2 circles which located to the left of current circle. So, sum of distances for these circles is . In the same manner we can calculate answer for cirlcles which are located to the right of the current circleAuthor's solution336C - Vasily the Bear and SequenceLet's check max beauty from 29 to 0. For every possible beauty i our aim is to find largest subset with such beauty. We will include in this subset all numbers, that have 1 at i-th bit. After that we do bitwise and as in statement, and if the resulting value is divisible by 2i, then there is the answer. Solution works in O(n).Author's solution336D - Vasily the Bear and Beautiful Stringsany — random binary string, s + g — concatenation of strings, MOD = 1000000007.String 1 + any always transforms into 0, string 1 — into 1. String 01 + any always transforms into 1, string 01 — into 0. String 001 + any transforms into 0, string 001 — into 1, and so on. Using these facts let's consider following solution.Cases like strings without ones or zeroes are easy. For every i (in zero-based numbering) let's assume that it is position of the first occurence of 1 in our string. Using already known facts we can understand what is the final result of transformations for such string. If the result equals to g, we add C(cnt[0] + cnt[1] - i - 1, cnt[1] - 1) to the answer. Calculation of binomial coefficients is following: fact[i] = i!%MOD, , C(n, k) = fact[n]inv(fact[n - i]fact[i]), where inv(a) — inverse element modulo MOD. inv(a) = aMOD - 2, because MOD is prime number.Author's solution336E - Vasily the Bear and Painting SquarePretty tough problem. Consider following DP dp[lvl][op][cur][type] — number of ways to take op triangles, if we have 2lvl + 1 squares. cur, type — auxiliary values. Answer will be dp[n][k][0][2]k!. type means type of transitions we make. cur — amount of used quarters (cur = 4 — 2 quarters, cur < 4 — cur quarters). It is important to distinguish cur = 2 from cur = 4, because amount of consecutive pairs of unused quarters is different.About transitions. type = 2. Iterate amount of pairs (considering cur) of consecutive quarters that we will take. It is important for them to have no common quarters. We can get two pairs only in case cur = 0. Let's also take some quarters that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][newcur][1] * cntwaystochoose. For better understanding of type = 2 check my solution (calc(n, k, cur, type) — isfordp[n][k][cur][type]). type = 1. Now we take triangles at the borders (number of squares is 2*lvl + 1). \"at the borders\" means marked X, see the picture.Iterate amount of pairs (considering cur) of consecutive triangles we take. It is important for pairs to have no common triangles. Let's also take some triangles that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][cur][0] * cntwaystochoose.type = 0. We take triangles at the borders (number of squares is 2*lvl). \"at the borders\" means marked X, see the picture.Take some triangles, not in pairs. Calculate number of ways to select corresponding triangles and add to current DP-state value dp[lvl - 1][op - choosen][cur][2] * cntwaystochoose. Starting values: dp[0][0][cur][1] = 1, dp[0][cnt][cur][1] = 0, cnt > 0.Author's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8574",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 336\\s*B"
          },
          "content_length": 4410
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 1",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 2",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 3",
          "code": "-30329013470001650000000000000000000000000000.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int R = inf.readInt(1, 10, \"R\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int R = inf.readInt(1, 10, \"R\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int R = inf.readInt(1, 10, \"R\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\", -1);\n    int R = opt<int>(\"R\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        m = 1;\n        R = 1;\n    } else if (type == \"max\") {\n        m = 100000;\n        R = 10;\n    } else if (type == \"custom\") {\n        // Ensure m and R are provided\n        ensure(m != -1 && R != -1);\n    } else { // random\n        if (m == -1) {\n            m = rnd.next(1, 100000);\n        } else {\n            ensure(1 <= m && m <= 100000);\n        }\n        if (R == -1) {\n            R = rnd.next(1, 10);\n        } else {\n            ensure(1 <= R && R <= 10);\n        }\n    }\n\n    // Output m and R\n    printf(\"%d %d\\n\", m, R);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\", -1);\n    int R = opt<int>(\"R\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        m = 1;\n        R = 1;\n    } else if (type == \"max\") {\n        m = 100000;\n        R = 10;\n    } else if (type == \"custom\") {\n        // Ensure m and R are provided\n        ensure(m != -1 && R != -1);\n    } else { // random\n        if (m == -1) {\n            m = rnd.next(1, 100000);\n        } else {\n            ensure(1 <= m && m <= 100000);\n        }\n        if (R == -1) {\n            R = rnd.next(1, 10);\n        } else {\n            ensure(1 <= R && R <= 10);\n        }\n    }\n\n    // Output m and R\n    printf(\"%d %d\\n\", m, R);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal values\n./gen -type min\n\n# Maximal values\n./gen -type max\n\n# Random values\n./gen -type random\n\n# Random values with specified m\n./gen -type random -m 50000\n./gen -type random -m 1\n./gen -type random -m 100000\n\n# Random values with specified R\n./gen -type random -R 5\n./gen -type random -R 1\n./gen -type random -R 10\n\n# Test cases with fixed m and varying R\n./gen -type custom -m 1 -R 1\n./gen -type custom -m 1 -R 5\n./gen -type custom -m 1 -R 10\n./gen -type custom -m 10 -R 1\n./gen -type custom -m 10 -R 5\n./gen -type custom -m 10 -R 10\n./gen -type custom -m 100 -R 1\n./gen -type custom -m 100 -R 5\n./gen -type custom -m 100 -R 10\n./gen -type custom -m 1000 -R 1\n./gen -type custom -m 1000 -R 5\n./gen -type custom -m 1000 -R 10\n\n# Test cases with fixed R and varying m\n./gen -type custom -R 1 -m 1\n./gen -type custom -R 1 -m 100\n./gen -type custom -R 1 -m 10000\n./gen -type custom -R 1 -m 100000\n./gen -type custom -R 10 -m 1\n./gen -type custom -R 10 -m 100\n./gen -type custom -R 10 -m 10000\n./gen -type custom -R 10 -m 100000\n\n# Specific custom test cases\n./gen -type custom -m 12345 -R 2\n./gen -type custom -m 67890 -R 3\n./gen -type custom -m 99999 -R 9\n./gen -type custom -m 100000 -R 10\n\n# Edge cases\n./gen -type custom -m 1 -R 10\n./gen -type custom -m 100000 -R 1\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:04.323329",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "336/C",
      "title": "C. Vasily the Bear and Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ a1 < a2 < ... < an ≤ 109).",
      "output_spec": "OutputIn the first line print a single integer k (k > 0), showing how many numbers to write out. In the second line print k integers b1, b2, ..., bk — the numbers to write out. You are allowed to print numbers b1, b2, ..., bk in any order, but all of them must be distinct. If there are multiple ways to write out the numbers, choose the one with the maximum number of numbers to write out. If there still are multiple ways, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy51 2 3 4 5OutputCopy24 5InputCopy31 2 4OutputCopy14",
      "description": "C. Vasily the Bear and Sequence\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ a1 < a2 < ... < an ≤ 109).\n\nOutputIn the first line print a single integer k (k > 0), showing how many numbers to write out. In the second line print k integers b1, b2, ..., bk — the numbers to write out. You are allowed to print numbers b1, b2, ..., bk in any order, but all of them must be distinct. If there are multiple ways to write out the numbers, choose the one with the maximum number of numbers to write out. If there still are multiple ways, you are allowed to print any of them.\n\nInputCopy51 2 3 4 5OutputCopy24 5InputCopy31 2 4OutputCopy14\n\nInputCopy51 2 3 4 5\n\nOutputCopy24 5\n\nInputCopy31 2 4\n\nOutputCopy14",
      "solutions": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on August 9 at 19:30 MSK) you are lucky to participate in Codeforces Round #195 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Eugene Sobolev (Seyaua), Vitaly Aksenov (Aksenov239) and Sergey Sukhov (Serega) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for translation of tutorial, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.We wish everyone good luck and high rating!UPD: English tutorialUPD: Congratulations for winners: Triolossus_3 WHITE2302 PM2.5 Separately, I want to congratulate Egor Kulikov (Egor) — the only person who had passed the all problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8524",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 856
        },
        {
          "title": "Tutorial Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "336A - Vasily the Bear and Triangleval = |x| + |y|. Then first point is (val * sign(x), 0), second — (0, val * sign(y)). Swap points if needed according to statement. Let's see why this is the answer. Conditions x ≠ 0 and y ≠ 0 give us that one point is on X-axis, and the other on Y-axis. Let's see how it works for x > 0 and y > 0. Other cases can be proved in similar way. We need to show, that (x, y) belongs to our triangle(including it's borders). In fact (x, y) belongs to segment, connecting (x + y, 0) with (0, x + y). Line through (x + y, 0) and (0, x + y) is Y =  - X + x + y. Using coordinates (x, y) in this equation proves the statement.Author's solution336B - Vasily the Bear and FlyAlso you could iterate circles, adding distance for each of them and dividing by m2 in the end. Let's see how the i-th iteration works 1 ≤ i ≤ m. Distance to m + i-th circle is 2R. Distance to m + j-th circle, where |j - i| = 1, is . For other circles it's quite simple to calculate sum of distances. There are i - 2 circles which located to the left of current circle. So, sum of distances for these circles is . In the same manner we can calculate answer for cirlcles which are located to the right of the current circleAuthor's solution336C - Vasily the Bear and SequenceLet's check max beauty from 29 to 0. For every possible beauty i our aim is to find largest subset with such beauty. We will include in this subset all numbers, that have 1 at i-th bit. After that we do bitwise and as in statement, and if the resulting value is divisible by 2i, then there is the answer. Solution works in O(n).Author's solution336D - Vasily the Bear and Beautiful Stringsany — random binary string, s + g — concatenation of strings, MOD = 1000000007.String 1 + any always transforms into 0, string 1 — into 1. String 01 + any always transforms into 1, string 01 — into 0. String 001 + any transforms into 0, string 001 — into 1, and so on. Using these facts let's consider following solution.Cases like strings without ones or zeroes are easy. For every i (in zero-based numbering) let's assume that it is position of the first occurence of 1 in our string. Using already known facts we can understand what is the final result of transformations for such string. If the result equals to g, we add C(cnt[0] + cnt[1] - i - 1, cnt[1] - 1) to the answer. Calculation of binomial coefficients is following: fact[i] = i!%MOD, , C(n, k) = fact[n]inv(fact[n - i]fact[i]), where inv(a) — inverse element modulo MOD. inv(a) = aMOD - 2, because MOD is prime number.Author's solution336E - Vasily the Bear and Painting SquarePretty tough problem. Consider following DP dp[lvl][op][cur][type] — number of ways to take op triangles, if we have 2lvl + 1 squares. cur, type — auxiliary values. Answer will be dp[n][k][0][2]k!. type means type of transitions we make. cur — amount of used quarters (cur = 4 — 2 quarters, cur < 4 — cur quarters). It is important to distinguish cur = 2 from cur = 4, because amount of consecutive pairs of unused quarters is different.About transitions. type = 2. Iterate amount of pairs (considering cur) of consecutive quarters that we will take. It is important for them to have no common quarters. We can get two pairs only in case cur = 0. Let's also take some quarters that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][newcur][1] * cntwaystochoose. For better understanding of type = 2 check my solution (calc(n, k, cur, type) — isfordp[n][k][cur][type]). type = 1. Now we take triangles at the borders (number of squares is 2*lvl + 1). \"at the borders\" means marked X, see the picture.Iterate amount of pairs (considering cur) of consecutive triangles we take. It is important for pairs to have no common triangles. Let's also take some triangles that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][cur][0] * cntwaystochoose.type = 0. We take triangles at the borders (number of squares is 2*lvl). \"at the borders\" means marked X, see the picture.Take some triangles, not in pairs. Calculate number of ways to select corresponding triangles and add to current DP-state value dp[lvl - 1][op - choosen][cur][2] * cntwaystochoose. Starting values: dp[0][0][cur][1] = 1, dp[0][cnt][cur][1] = 0, cnt > 0.Author's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8574",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 336\\s*C"
          },
          "content_length": 4410
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 1",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 2",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 3",
          "code": "-30329013470001650000000000000000000000000000.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"Numbers must be in strictly increasing order at position %d\", i + 1);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"Numbers must be in strictly increasing order at position %d\", i + 1);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"Numbers must be in strictly increasing order at position %d\", i + 1);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Answer {\n    int k;\n    vector<int> b;\n    int beauty;\n};\n\nAnswer readAns(InStream& stream, const set<int>& a_set, int n, const char* who) {\n    Answer answ;\n    answ.k = stream.readInt(1, n, format(\"%s's k\", who).c_str());\n    answ.b.resize(answ.k);\n    set<int> b_set;\n    long long s = -1;\n    for (int i = 0; i < answ.k; ++i) {\n        answ.b[i] = stream.readInt(1, 1000000000, format(\"%s's b[%d]\", who, i + 1).c_str());\n        if (a_set.find(answ.b[i]) == a_set.end()) {\n            stream.quitf(_wa, \"%s's number %d in position %d is not from the input sequence\", who, answ.b[i], i + 1);\n        }\n        if (b_set.find(answ.b[i]) != b_set.end()) {\n            stream.quitf(_wa, \"%s's number %d is repeated at position %d\", who, answ.b[i], i + 1);\n        }\n        b_set.insert(answ.b[i]);\n        if (s == -1) {\n            s = answ.b[i];\n        } else {\n            s &= answ.b[i];\n        }\n    }\n    if (s == 0) {\n        answ.beauty = -1;\n    } else {\n        int v = 0;\n        while ((s & 1) == 0) {\n            s >>= 1;\n            v++;\n        }\n        answ.beauty = v;\n    }\n    return answ;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    vector<int> a(n);\n    set<int> a_set;\n    a[0] = inf.readInt(1, 1000000000, \"a[1]\");\n    a_set.insert(a[0]);\n    for (int i = 1; i < n; ++i) {\n        a[i] = inf.readInt(a[i - 1] + 1, 1000000000, format(\"a[%d]\", i + 1).c_str());\n        a_set.insert(a[i]);\n    }\n\n    Answer juryAns = readAns(ans, a_set, n, \"Jury\");\n    Answer participantAns = readAns(ouf, a_set, n, \"Participant\");\n\n    if (participantAns.beauty < juryAns.beauty) {\n        quitf(_wa, \"Participant's beauty %d is less than Jury's beauty %d\", participantAns.beauty, juryAns.beauty);\n    } else if (participantAns.beauty > juryAns.beauty) {\n        quitf(_fail, \"Participant's beauty %d is greater than Jury's beauty %d\", participantAns.beauty, juryAns.beauty);\n    } else {\n        // Equal beauties\n        if (participantAns.k < juryAns.k) {\n            quitf(_wa, \"Participant's answer length %d is less than Jury's length %d with same beauty %d\", participantAns.k, juryAns.k, participantAns.beauty);\n        } else if (participantAns.k > juryAns.k) {\n            quitf(_fail, \"Participant's answer length %d is greater than Jury's length %d with same beauty %d\", participantAns.k, juryAns.k, participantAns.beauty);\n        } else {\n            // Participant's answer is correct\n            quitf(_ok, \"Correct answer with beauty %d and length %d\", participantAns.beauty, participantAns.k);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_VALUE = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Generate n unique random integers in [1, MAX_VALUE], sorted in increasing order\n        set<int> numbers;\n        while ((int)numbers.size() < n) {\n            int num = rnd.next(1, MAX_VALUE);\n            numbers.insert(num);\n        }\n        vector<int> a(numbers.begin(), numbers.end());\n        sort(a.begin(), a.end());\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"all_odd\") {\n        // Generate n odd numbers starting from 1\n        int max_n = (MAX_VALUE - 1) / 2;\n        n = min(n, max_n);\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = 2 * i + 1; // 1, 3, 5, ...\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"all_even\") {\n        // Generate n even numbers starting from 2\n        int max_n = MAX_VALUE / 2;\n        n = min(n, max_n);\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = 2 * (i + 1); // 2, 4, 6, ...\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"max_numbers\") {\n        // Generate n numbers close to MAX_VALUE\n        int start = MAX_VALUE - n + 1;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"bitwise_and_zero\") {\n        // Generate numbers whose bitwise AND is zero\n        vector<int> bits(30);\n        iota(bits.begin(), bits.end(), 0); // bits from 0 to 29\n        vector<int> a;\n        int offset = 0;\n        while ((int)a.size() < n) {\n            for (int bit : bits) {\n                int val = (1 << bit) + offset;\n                if (val > MAX_VALUE) break;\n                a.push_back(val);\n                if ((int)a.size() >= n) break;\n            }\n            offset++;\n        }\n        sort(a.begin(), a.end());\n        a.resize(n); // Ensure the vector size is n\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"max_beauty\") {\n        // Generate numbers to maximize beauty\n        int v = 12; // You can adjust v according to n\n        int base = 1 << v; // 2^v\n        vector<int> a;\n        for (int i = 1; i <= n; i++) {\n            int num = base * (2 * i - 1);\n            if (num > MAX_VALUE) break;\n            a.push_back(num);\n        }\n        n = a.size();\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else {\n        // Default: Generate random numbers\n        set<int> numbers;\n        while ((int)numbers.size() < n) {\n            int num = rnd.next(1, MAX_VALUE);\n            numbers.insert(num);\n        }\n        vector<int> a(numbers.begin(), numbers.end());\n        sort(a.begin(), a.end());\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_VALUE = 1000000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Generate n unique random integers in [1, MAX_VALUE], sorted in increasing order\n        set<int> numbers;\n        while ((int)numbers.size() < n) {\n            int num = rnd.next(1, MAX_VALUE);\n            numbers.insert(num);\n        }\n        vector<int> a(numbers.begin(), numbers.end());\n        sort(a.begin(), a.end());\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"all_odd\") {\n        // Generate n odd numbers starting from 1\n        int max_n = (MAX_VALUE - 1) / 2;\n        n = min(n, max_n);\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = 2 * i + 1; // 1, 3, 5, ...\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"all_even\") {\n        // Generate n even numbers starting from 2\n        int max_n = MAX_VALUE / 2;\n        n = min(n, max_n);\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = 2 * (i + 1); // 2, 4, 6, ...\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"max_numbers\") {\n        // Generate n numbers close to MAX_VALUE\n        int start = MAX_VALUE - n + 1;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"bitwise_and_zero\") {\n        // Generate numbers whose bitwise AND is zero\n        vector<int> bits(30);\n        iota(bits.begin(), bits.end(), 0); // bits from 0 to 29\n        vector<int> a;\n        int offset = 0;\n        while ((int)a.size() < n) {\n            for (int bit : bits) {\n                int val = (1 << bit) + offset;\n                if (val > MAX_VALUE) break;\n                a.push_back(val);\n                if ((int)a.size() >= n) break;\n            }\n            offset++;\n        }\n        sort(a.begin(), a.end());\n        a.resize(n); // Ensure the vector size is n\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else if (type == \"max_beauty\") {\n        // Generate numbers to maximize beauty\n        int v = 12; // You can adjust v according to n\n        int base = 1 << v; // 2^v\n        vector<int> a;\n        for (int i = 1; i <= n; i++) {\n            int num = base * (2 * i - 1);\n            if (num > MAX_VALUE) break;\n            a.push_back(num);\n        }\n        n = a.size();\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    } else {\n        // Default: Generate random numbers\n        set<int> numbers;\n        while ((int)numbers.size() < n) {\n            int num = rnd.next(1, MAX_VALUE);\n            numbers.insert(num);\n        }\n        vector<int> a(numbers.begin(), numbers.end());\n        sort(a.begin(), a.end());\n        for (int i = 0; i < n; i++) {\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random small test cases\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n# Random large test cases\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n# All odd numbers\n./gen -n 10 -type all_odd\n./gen -n 1000 -type all_odd\n./gen -n 50000 -type all_odd\n\n# All even numbers\n./gen -n 10 -type all_even\n./gen -n 1000 -type all_even\n./gen -n 50000 -type all_even\n\n# Max numbers (close to 1e9)\n./gen -n 10 -type max_numbers\n./gen -n 1000 -type max_numbers\n./gen -n 100000 -type max_numbers\n\n# Bitwise AND is zero\n./gen -n 10 -type bitwise_and_zero\n./gen -n 1000 -type bitwise_and_zero\n./gen -n 100000 -type bitwise_and_zero\n\n# Maximize beauty\n./gen -n 10 -type max_beauty\n./gen -n 1000 -type max_beauty\n./gen -n 50000 -type max_beauty\n\n# Edge cases for minimal n\n./gen -n 1 -type random\n./gen -n 1 -type all_odd\n./gen -n 1 -type all_even\n\n# Edge cases for maximal n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_odd\n./gen -n 100000 -type all_even\n\n# Additional test cases with varying types\n./gen -n 15 -type random\n./gen -n 100 -type random\n./gen -n 500 -type max_beauty\n./gen -n 1000 -type bitwise_and_zero\n./gen -n 20000 -type max_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:06.753427",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "336/D",
      "title": "D. Vasily the Bear and Beautiful Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1 1 0OutputCopy2InputCopy2 2 0OutputCopy4InputCopy1 1 1OutputCopy0",
      "description": "D. Vasily the Bear and Beautiful Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\nOutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy1 1 0OutputCopy2InputCopy2 2 0OutputCopy4InputCopy1 1 1OutputCopy0\n\nInputCopy1 1 0\n\nOutputCopy2\n\nInputCopy2 2 0\n\nOutputCopy4\n\nInputCopy1 1 1\n\nOutputCopy0\n\nNoteIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.",
      "solutions": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on August 9 at 19:30 MSK) you are lucky to participate in Codeforces Round #195 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Eugene Sobolev (Seyaua), Vitaly Aksenov (Aksenov239) and Sergey Sukhov (Serega) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for translation of tutorial, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.We wish everyone good luck and high rating!UPD: English tutorialUPD: Congratulations for winners: Triolossus_3 WHITE2302 PM2.5 Separately, I want to congratulate Egor Kulikov (Egor) — the only person who had passed the all problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8524",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 856
        },
        {
          "title": "Tutorial Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "336A - Vasily the Bear and Triangleval = |x| + |y|. Then first point is (val * sign(x), 0), second — (0, val * sign(y)). Swap points if needed according to statement. Let's see why this is the answer. Conditions x ≠ 0 and y ≠ 0 give us that one point is on X-axis, and the other on Y-axis. Let's see how it works for x > 0 and y > 0. Other cases can be proved in similar way. We need to show, that (x, y) belongs to our triangle(including it's borders). In fact (x, y) belongs to segment, connecting (x + y, 0) with (0, x + y). Line through (x + y, 0) and (0, x + y) is Y =  - X + x + y. Using coordinates (x, y) in this equation proves the statement.Author's solution336B - Vasily the Bear and FlyAlso you could iterate circles, adding distance for each of them and dividing by m2 in the end. Let's see how the i-th iteration works 1 ≤ i ≤ m. Distance to m + i-th circle is 2R. Distance to m + j-th circle, where |j - i| = 1, is . For other circles it's quite simple to calculate sum of distances. There are i - 2 circles which located to the left of current circle. So, sum of distances for these circles is . In the same manner we can calculate answer for cirlcles which are located to the right of the current circleAuthor's solution336C - Vasily the Bear and SequenceLet's check max beauty from 29 to 0. For every possible beauty i our aim is to find largest subset with such beauty. We will include in this subset all numbers, that have 1 at i-th bit. After that we do bitwise and as in statement, and if the resulting value is divisible by 2i, then there is the answer. Solution works in O(n).Author's solution336D - Vasily the Bear and Beautiful Stringsany — random binary string, s + g — concatenation of strings, MOD = 1000000007.String 1 + any always transforms into 0, string 1 — into 1. String 01 + any always transforms into 1, string 01 — into 0. String 001 + any transforms into 0, string 001 — into 1, and so on. Using these facts let's consider following solution.Cases like strings without ones or zeroes are easy. For every i (in zero-based numbering) let's assume that it is position of the first occurence of 1 in our string. Using already known facts we can understand what is the final result of transformations for such string. If the result equals to g, we add C(cnt[0] + cnt[1] - i - 1, cnt[1] - 1) to the answer. Calculation of binomial coefficients is following: fact[i] = i!%MOD, , C(n, k) = fact[n]inv(fact[n - i]fact[i]), where inv(a) — inverse element modulo MOD. inv(a) = aMOD - 2, because MOD is prime number.Author's solution336E - Vasily the Bear and Painting SquarePretty tough problem. Consider following DP dp[lvl][op][cur][type] — number of ways to take op triangles, if we have 2lvl + 1 squares. cur, type — auxiliary values. Answer will be dp[n][k][0][2]k!. type means type of transitions we make. cur — amount of used quarters (cur = 4 — 2 quarters, cur < 4 — cur quarters). It is important to distinguish cur = 2 from cur = 4, because amount of consecutive pairs of unused quarters is different.About transitions. type = 2. Iterate amount of pairs (considering cur) of consecutive quarters that we will take. It is important for them to have no common quarters. We can get two pairs only in case cur = 0. Let's also take some quarters that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][newcur][1] * cntwaystochoose. For better understanding of type = 2 check my solution (calc(n, k, cur, type) — isfordp[n][k][cur][type]). type = 1. Now we take triangles at the borders (number of squares is 2*lvl + 1). \"at the borders\" means marked X, see the picture.Iterate amount of pairs (considering cur) of consecutive triangles we take. It is important for pairs to have no common triangles. Let's also take some triangles that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][cur][0] * cntwaystochoose.type = 0. We take triangles at the borders (number of squares is 2*lvl). \"at the borders\" means marked X, see the picture.Take some triangles, not in pairs. Calculate number of ways to select corresponding triangles and add to current DP-state value dp[lvl - 1][op - choosen][cur][2] * cntwaystochoose. Starting values: dp[0][0][cur][1] = 1, dp[0][cnt][cur][1] = 0, cnt > 0.Author's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8574",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 336\\s*D"
          },
          "content_length": 4410
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 1",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 2",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 3",
          "code": "-30329013470001650000000000000000000000000000.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int g = inf.readInt(0, 1, \"g\");\n    inf.readEoln();\n    ensuref(n + m >=1, \"n + m must be >= 1, but n=%d, m=%d\", n, m);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int g = inf.readInt(0, 1, \"g\");\n    inf.readEoln();\n    ensuref(n + m >=1, \"n + m must be >= 1, but n=%d, m=%d\", n, m);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int g = inf.readInt(0, 1, \"g\");\n    inf.readEoln();\n    ensuref(n + m >=1, \"n + m must be >= 1, but n=%d, m=%d\", n, m);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int g = opt<int>(\"g\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"minimal\") {\n        // n + m ≥ 1, 0 ≤ n,m ≤ 1\n        if (n == -1) n = rnd.next(0,1);\n        if (m == -1) m = rnd.next(0,1);\n        if (n + m == 0) {\n            if (rnd.next(2) == 0)\n                n = 1;\n            else\n                m = 1;\n        }\n        if (g == -1) g = rnd.next(0,1);\n\n    } else if (type == \"maximal\") {\n        // n + m = 200,000\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = 200000 - n;\n        // Ensure n and m are within bounds\n        n = min(100000, n);\n        m = min(100000, m);\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"zeros_only\") {\n        // m = 0\n        m = 0;\n        if (n == -1) n = rnd.next(1, 100000); // n ≥ 1 since n + m ≥ 1\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"ones_only\") {\n        // n = 0\n        n = 0;\n        if (m == -1) m = rnd.next(1, 100000); // m ≥ 1 since n + m ≥ 1\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"balanced_small\") {\n        // Small n and m\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(1, 100);\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"balanced_large\") {\n        // Large n and m\n        if (n == -1) n = rnd.next(50000, 100000);\n        if (m == -1) m = rnd.next(50000, 100000);\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"random\") {\n        // Random n and m\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = rnd.next(0, 100000);\n        if (n + m == 0) {\n            if (rnd.next(2) == 0)\n                n = 1;\n            else\n                m = 1;\n        }\n        if (g == -1) g = rnd.next(0,1);\n    } else {\n        // Default to random\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = rnd.next(0, 100000);\n        if (n + m == 0) {\n            if (rnd.next(2) == 0)\n                n = 1;\n            else\n                m = 1;\n        }\n        if (g == -1) g = rnd.next(0,1);\n    }\n\n    // Ensure n and m are in correct bounds\n    n = max(0, min(n, 100000));\n    m = max(0, min(m, 100000));\n\n    // Ensure n + m ≥ 1\n    if (n + m == 0) {\n        n = 1;\n    }\n\n    // Ensure g is 0 or 1\n    if (g != 0 && g != 1) {\n        g = rnd.next(0,1);\n    }\n\n    printf(\"%d %d %d\\n\", n, m, g);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int g = opt<int>(\"g\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"minimal\") {\n        // n + m ≥ 1, 0 ≤ n,m ≤ 1\n        if (n == -1) n = rnd.next(0,1);\n        if (m == -1) m = rnd.next(0,1);\n        if (n + m == 0) {\n            if (rnd.next(2) == 0)\n                n = 1;\n            else\n                m = 1;\n        }\n        if (g == -1) g = rnd.next(0,1);\n\n    } else if (type == \"maximal\") {\n        // n + m = 200,000\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = 200000 - n;\n        // Ensure n and m are within bounds\n        n = min(100000, n);\n        m = min(100000, m);\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"zeros_only\") {\n        // m = 0\n        m = 0;\n        if (n == -1) n = rnd.next(1, 100000); // n ≥ 1 since n + m ≥ 1\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"ones_only\") {\n        // n = 0\n        n = 0;\n        if (m == -1) m = rnd.next(1, 100000); // m ≥ 1 since n + m ≥ 1\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"balanced_small\") {\n        // Small n and m\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(1, 100);\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"balanced_large\") {\n        // Large n and m\n        if (n == -1) n = rnd.next(50000, 100000);\n        if (m == -1) m = rnd.next(50000, 100000);\n        if (g == -1) g = rnd.next(0,1);\n    } else if (type == \"random\") {\n        // Random n and m\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = rnd.next(0, 100000);\n        if (n + m == 0) {\n            if (rnd.next(2) == 0)\n                n = 1;\n            else\n                m = 1;\n        }\n        if (g == -1) g = rnd.next(0,1);\n    } else {\n        // Default to random\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = rnd.next(0, 100000);\n        if (n + m == 0) {\n            if (rnd.next(2) == 0)\n                n = 1;\n            else\n                m = 1;\n        }\n        if (g == -1) g = rnd.next(0,1);\n    }\n\n    // Ensure n and m are in correct bounds\n    n = max(0, min(n, 100000));\n    m = max(0, min(m, 100000));\n\n    // Ensure n + m ≥ 1\n    if (n + m == 0) {\n        n = 1;\n    }\n\n    // Ensure g is 0 or 1\n    if (g != 0 && g != 1) {\n        g = rnd.next(0,1);\n    }\n\n    printf(\"%d %d %d\\n\", n, m, g);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal -g 0\n./gen -type minimal -g 1\n./gen -type zeros_only -g 0\n./gen -type zeros_only -g 1\n./gen -type ones_only -g 0\n./gen -type ones_only -g 1\n./gen -type balanced_small -g 0\n./gen -type balanced_small -g 1\n./gen -type balanced_large -g 0\n./gen -type balanced_large -g 1\n./gen -type maximal -g 0\n./gen -type maximal -g 1\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -n 0 -m 1 -g 0\n./gen -n 1 -m 0 -g 1\n./gen -n 1 -m 1 -g 0\n./gen -n 100000 -m 100000 -g 1\n./gen -n 100000 -m 0 -g 0\n./gen -n 0 -m 100000 -g 1\n./gen -n 99999 -m 1 -g 0\n./gen -n 1 -m 99999 -g 1\n./gen -n 50000 -m 50000 -g 0\n./gen -n 50000 -m 50000 -g 1\n./gen -n 100000 -m 100000 -g 0\n./gen -n 100000 -m 1 -g 1\n./gen -n 1 -m 100000 -g 0\n./gen -type random -g 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:08.919177",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "336/E",
      "title": "E. Vasily the Bear and Painting Square",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k, separated by a space (0 ≤ n, k ≤ 200).",
      "output_spec": "OutputPrint exactly one integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy0 0OutputCopy1InputCopy0 1OutputCopy8InputCopy0 2OutputCopy32InputCopy1 1OutputCopy32",
      "description": "E. Vasily the Bear and Painting Square\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k, separated by a space (0 ≤ n, k ≤ 200).\n\nOutputPrint exactly one integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy0 0OutputCopy1InputCopy0 1OutputCopy8InputCopy0 2OutputCopy32InputCopy1 1OutputCopy32\n\nInputCopy0 0\n\nOutputCopy1\n\nInputCopy0 1\n\nOutputCopy8\n\nInputCopy0 2\n\nOutputCopy32\n\nInputCopy1 1\n\nOutputCopy32",
      "solutions": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on August 9 at 19:30 MSK) you are lucky to participate in Codeforces Round #195 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Eugene Sobolev (Seyaua), Vitaly Aksenov (Aksenov239) and Sergey Sukhov (Serega) for testing of problems, Alexander Ignatyev (aiMR) for testing of problems and for translation of tutorial, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova (Delinur) for translation of statements.We wish everyone good luck and high rating!UPD: English tutorialUPD: Congratulations for winners: Triolossus_3 WHITE2302 PM2.5 Separately, I want to congratulate Egor Kulikov (Egor) — the only person who had passed the all problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8524",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 856
        },
        {
          "title": "Tutorial Codeforces Round #195 (Div. 2) - Codeforces",
          "content": "336A - Vasily the Bear and Triangleval = |x| + |y|. Then first point is (val * sign(x), 0), second — (0, val * sign(y)). Swap points if needed according to statement. Let's see why this is the answer. Conditions x ≠ 0 and y ≠ 0 give us that one point is on X-axis, and the other on Y-axis. Let's see how it works for x > 0 and y > 0. Other cases can be proved in similar way. We need to show, that (x, y) belongs to our triangle(including it's borders). In fact (x, y) belongs to segment, connecting (x + y, 0) with (0, x + y). Line through (x + y, 0) and (0, x + y) is Y =  - X + x + y. Using coordinates (x, y) in this equation proves the statement.Author's solution336B - Vasily the Bear and FlyAlso you could iterate circles, adding distance for each of them and dividing by m2 in the end. Let's see how the i-th iteration works 1 ≤ i ≤ m. Distance to m + i-th circle is 2R. Distance to m + j-th circle, where |j - i| = 1, is . For other circles it's quite simple to calculate sum of distances. There are i - 2 circles which located to the left of current circle. So, sum of distances for these circles is . In the same manner we can calculate answer for cirlcles which are located to the right of the current circleAuthor's solution336C - Vasily the Bear and SequenceLet's check max beauty from 29 to 0. For every possible beauty i our aim is to find largest subset with such beauty. We will include in this subset all numbers, that have 1 at i-th bit. After that we do bitwise and as in statement, and if the resulting value is divisible by 2i, then there is the answer. Solution works in O(n).Author's solution336D - Vasily the Bear and Beautiful Stringsany — random binary string, s + g — concatenation of strings, MOD = 1000000007.String 1 + any always transforms into 0, string 1 — into 1. String 01 + any always transforms into 1, string 01 — into 0. String 001 + any transforms into 0, string 001 — into 1, and so on. Using these facts let's consider following solution.Cases like strings without ones or zeroes are easy. For every i (in zero-based numbering) let's assume that it is position of the first occurence of 1 in our string. Using already known facts we can understand what is the final result of transformations for such string. If the result equals to g, we add C(cnt[0] + cnt[1] - i - 1, cnt[1] - 1) to the answer. Calculation of binomial coefficients is following: fact[i] = i!%MOD, , C(n, k) = fact[n]inv(fact[n - i]fact[i]), where inv(a) — inverse element modulo MOD. inv(a) = aMOD - 2, because MOD is prime number.Author's solution336E - Vasily the Bear and Painting SquarePretty tough problem. Consider following DP dp[lvl][op][cur][type] — number of ways to take op triangles, if we have 2lvl + 1 squares. cur, type — auxiliary values. Answer will be dp[n][k][0][2]k!. type means type of transitions we make. cur — amount of used quarters (cur = 4 — 2 quarters, cur < 4 — cur quarters). It is important to distinguish cur = 2 from cur = 4, because amount of consecutive pairs of unused quarters is different.About transitions. type = 2. Iterate amount of pairs (considering cur) of consecutive quarters that we will take. It is important for them to have no common quarters. We can get two pairs only in case cur = 0. Let's also take some quarters that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][newcur][1] * cntwaystochoose. For better understanding of type = 2 check my solution (calc(n, k, cur, type) — isfordp[n][k][cur][type]). type = 1. Now we take triangles at the borders (number of squares is 2*lvl + 1). \"at the borders\" means marked X, see the picture.Iterate amount of pairs (considering cur) of consecutive triangles we take. It is important for pairs to have no common triangles. Let's also take some triangles that are not in pairs. Calculate number of ways to select corresponding triangles and add to the current DP-state value dp[lvl][op - choosen][cur][0] * cntwaystochoose.type = 0. We take triangles at the borders (number of squares is 2*lvl). \"at the borders\" means marked X, see the picture.Take some triangles, not in pairs. Calculate number of ways to select corresponding triangles and add to current DP-state value dp[lvl - 1][op - choosen][cur][2] * cntwaystochoose. Starting values: dp[0][0][cur][1] = 1, dp[0][cnt][cur][1] = 0, cnt > 0.Author's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8574",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 336\\s*E"
          },
          "content_length": 4410
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 1",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 2",
          "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    printf(\"%Lf\\n\", 3.14L);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #195 (Div. 2) - Codeforces - Code 3",
          "code": "-30329013470001650000000000000000000000000000.000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8524",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // Default -1 indicates not set\n    int k = opt<int>(\"k\", -1); // Default -1\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n_min_k\") {\n        // Both n and k are zero\n        n = 0;\n        k = 0;\n    } else if (type == \"min_n_max_k\") {\n        // n is zero, k is maximum\n        n = 0;\n        k = 200;\n    } else if (type == \"max_n_min_k\") {\n        // n is maximum, k is zero\n        n = 200;\n        k = 0;\n    } else if (type == \"max_n_max_k\") {\n        // Both n and k are maximum\n        n = 200;\n        k = 200;\n    } else if (type == \"n_equals_k\") {\n        // n equals k\n        if (n == -1 || k == -1) {\n            n = rnd.next(0, 200);\n            k = n;\n        } else {\n            n = min(n, k);\n            k = n;\n        }\n    } else if (type == \"n_less_than_k\") {\n        // n is less than k\n        if (n == -1) n = rnd.next(0, 199);\n        if (k == -1) k = rnd.next(n + 1, 200);\n    } else if (type == \"k_less_than_n\") {\n        // k is less than n\n        if (k == -1) k = rnd.next(0, 199);\n        if (n == -1) n = rnd.next(k + 1, 200);\n    } else if (type == \"n_zero\") {\n        // n is zero, k is random\n        n = 0;\n        if (k == -1) k = rnd.next(0, 200);\n    } else if (type == \"k_zero\") {\n        // k is zero, n is random\n        k = 0;\n        if (n == -1) n = rnd.next(0, 200);\n    } else if (type == \"max_answer\") {\n        // Generate input that may produce a maximal answer\n        n = 200;\n        k = 200;\n    } else if (type == \"small_values\") {\n        // Small random values for n and k\n        n = rnd.next(0, 5);\n        k = rnd.next(0, 5);\n    } else if (type == \"mid_values\") {\n        // Medium random values for n and k\n        n = rnd.next(50, 150);\n        k = rnd.next(50, 150);\n    } else {\n        // Random values for n and k\n        if (n == -1) n = rnd.next(0, 200);\n        if (k == -1) k = rnd.next(0, 200);\n    }\n\n    // Ensure n and k are within [0, 200]\n    n = max(0, min(n, 200));\n    k = max(0, min(k, 200));\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // Default -1 indicates not set\n    int k = opt<int>(\"k\", -1); // Default -1\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n_min_k\") {\n        // Both n and k are zero\n        n = 0;\n        k = 0;\n    } else if (type == \"min_n_max_k\") {\n        // n is zero, k is maximum\n        n = 0;\n        k = 200;\n    } else if (type == \"max_n_min_k\") {\n        // n is maximum, k is zero\n        n = 200;\n        k = 0;\n    } else if (type == \"max_n_max_k\") {\n        // Both n and k are maximum\n        n = 200;\n        k = 200;\n    } else if (type == \"n_equals_k\") {\n        // n equals k\n        if (n == -1 || k == -1) {\n            n = rnd.next(0, 200);\n            k = n;\n        } else {\n            n = min(n, k);\n            k = n;\n        }\n    } else if (type == \"n_less_than_k\") {\n        // n is less than k\n        if (n == -1) n = rnd.next(0, 199);\n        if (k == -1) k = rnd.next(n + 1, 200);\n    } else if (type == \"k_less_than_n\") {\n        // k is less than n\n        if (k == -1) k = rnd.next(0, 199);\n        if (n == -1) n = rnd.next(k + 1, 200);\n    } else if (type == \"n_zero\") {\n        // n is zero, k is random\n        n = 0;\n        if (k == -1) k = rnd.next(0, 200);\n    } else if (type == \"k_zero\") {\n        // k is zero, n is random\n        k = 0;\n        if (n == -1) n = rnd.next(0, 200);\n    } else if (type == \"max_answer\") {\n        // Generate input that may produce a maximal answer\n        n = 200;\n        k = 200;\n    } else if (type == \"small_values\") {\n        // Small random values for n and k\n        n = rnd.next(0, 5);\n        k = rnd.next(0, 5);\n    } else if (type == \"mid_values\") {\n        // Medium random values for n and k\n        n = rnd.next(50, 150);\n        k = rnd.next(50, 150);\n    } else {\n        // Random values for n and k\n        if (n == -1) n = rnd.next(0, 200);\n        if (k == -1) k = rnd.next(0, 200);\n    }\n\n    // Ensure n and k are within [0, 200]\n    n = max(0, min(n, 200));\n    k = max(0, min(k, 200));\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n_min_k\n./gen -type min_n_max_k\n./gen -type max_n_min_k\n./gen -type max_n_max_k\n./gen -type n_equals_k\n./gen -type n_equals_k -n 100\n./gen -type n_less_than_k\n./gen -type n_less_than_k -n 0\n./gen -type n_less_than_k -n 199\n./gen -type k_less_than_n\n./gen -type k_less_than_n -k 0\n./gen -type k_less_than_n -k 199\n./gen -type n_zero\n./gen -type k_zero\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type small_values\n./gen -type small_values\n./gen -type mid_values\n./gen -type mid_values\n./gen -type max_answer\n./gen -n 0 -k 0\n./gen -n 0 -k 1\n./gen -n 1 -k 0\n./gen -n 0 -k 200\n./gen -n 200 -k 0\n./gen -n 200 -k 200\n./gen -n 100 -k 50\n./gen -n 50 -k 100\n./gen -type n_equals_k -n 200\n./gen -type n_equals_k -n 0\n./gen -type n_equals_k -n 1\n./gen -type n_less_than_k -n 199\n./gen -type k_less_than_n -k 199\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:11.326624",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "337/A",
      "title": "A. Пазлы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записаны целые числа n и m (2 ≤ n ≤ m ≤ 50). Во второй строке через пробел записано m целых чисел f1, f2, ..., fm (4 ≤ fi ≤ 1000) — количества фрагментов в пазлах, продающихся в магазине.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимальную возможную разницу между максимальным и минимальным количеством фрагментов среди пазлов, которые должна приобрести учительница.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 610 12 10 7 5 22Выходные данныеСкопировать5",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записаны целые числа n и m (2 ≤ n ≤ m ≤ 50). Во второй строке через пробел записано m целых чисел f1, f2, ..., fm (4 ≤ fi ≤ 1000) — количества фрагментов в пазлах, продающихся в магазине.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимальную возможную разницу между максимальным и минимальным количеством фрагментов среди пазлов, которые должна приобрести учительница.\n\nВыходные данные\n\nВходные данныеСкопировать4 610 12 10 7 5 22Выходные данныеСкопировать5\n\nВходные данныеСкопировать4 610 12 10 7 5 22\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПример 1. В классе всего 4 ученика. В магазине продается 6 пазлов. Если Манана Тариеловна купит первые четыре пазла, которые состоят из 10, 12, 10 и 7 фрагментов соответственно, тогда разница между самым большим и самым маленьким будет равна 5-ти. Меньшую разницу получить невозможно. Заметим, что учительница может купить пазлы 1, 3, 4 и 5 и также получить разницу 5.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 50, \"m\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(m, 4, 1000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 50, \"m\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(m, 4, 1000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 50, \"m\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(m, 4, 1000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // 2 ≤ n ≤ m ≤ 50\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(2 <= n && n <= m && m <= 50); // Ensure constraints\n\n    vector<int> fi(m);\n\n    if (type == \"all_equal\") {\n        int val = rnd.next(4, 1000);\n        for (int i = 0; i < m; i++)\n            fi[i] = val;\n    } else if (type == \"increasing\") {\n        fi[0] = rnd.next(4, 1000 - m +1);\n        int increment = max(1, (1000 - fi[0]) / m);\n        for (int i = 1; i < m; i++)\n            fi[i] = fi[i-1] + increment;\n        // Adjust values to be within 1000\n        for (int i = 0; i < m; i++)\n            if (fi[i] > 1000)\n                fi[i] = 1000;\n    } else if (type == \"decreasing\") {\n        fi[0] = rnd.next(4 + m -1, 1000);\n        int decrement = max(1, (fi[0] - 4) / m);\n        for (int i = 1; i < m; i++)\n            fi[i] = fi[i-1] - decrement;\n        // Adjust values to be within 4\n        for (int i = 0; i < m; i++)\n            if (fi[i] < 4)\n                fi[i] = 4;\n    } else if (type == \"random\") {\n        for (int i = 0; i < m; i++)\n            fi[i] = rnd.next(4, 1000);\n    } else if (type == \"large_range\") {\n        fi[0] = 4;\n        fi[1] = 1000;\n        for (int i = 2; i < m; i++)\n            fi[i] = rnd.next(4, 1000);\n    } else if (type == \"small_range\") {\n        int base = rnd.next(4, 1000 - 5);\n        for (int i = 0; i < m; i++)\n            fi[i] = rnd.next(base, base + 5);\n    } else if (type == \"one_big\") {\n        for (int i = 0; i < m-1; i++)\n            fi[i] = rnd.next(4, 500);\n        fi[m-1] = rnd.next(501, 1000);\n        shuffle(fi.begin(), fi.end());\n    } else if (type == \"one_small\") {\n        for (int i = 0; i < m-1; i++)\n            fi[i] = rnd.next(501, 1000);\n        fi[m-1] = rnd.next(4, 500);\n        shuffle(fi.begin(), fi.end());\n    } else if (type == \"duplicates\") {\n        int num_unique = rnd.next(1, min(10,m)); // up to 10 unique numbers\n        vector<int> unique_values(num_unique);\n        for (int i = 0; i < num_unique; i++)\n            unique_values[i] = rnd.next(4, 1000);\n        for (int i = 0; i < m; i++)\n            fi[i] = unique_values[rnd.next(0, num_unique -1)];\n    } else {\n        // default to random\n        for (int i = 0; i < m; i++)\n            fi[i] = rnd.next(4, 1000);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output fi's\n    for (int i = 0; i < m; i++) {\n        printf(\"%d\", fi[i]);\n        if (i < m -1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // 2 ≤ n ≤ m ≤ 50\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(2 <= n && n <= m && m <= 50); // Ensure constraints\n\n    vector<int> fi(m);\n\n    if (type == \"all_equal\") {\n        int val = rnd.next(4, 1000);\n        for (int i = 0; i < m; i++)\n            fi[i] = val;\n    } else if (type == \"increasing\") {\n        fi[0] = rnd.next(4, 1000 - m +1);\n        int increment = max(1, (1000 - fi[0]) / m);\n        for (int i = 1; i < m; i++)\n            fi[i] = fi[i-1] + increment;\n        // Adjust values to be within 1000\n        for (int i = 0; i < m; i++)\n            if (fi[i] > 1000)\n                fi[i] = 1000;\n    } else if (type == \"decreasing\") {\n        fi[0] = rnd.next(4 + m -1, 1000);\n        int decrement = max(1, (fi[0] - 4) / m);\n        for (int i = 1; i < m; i++)\n            fi[i] = fi[i-1] - decrement;\n        // Adjust values to be within 4\n        for (int i = 0; i < m; i++)\n            if (fi[i] < 4)\n                fi[i] = 4;\n    } else if (type == \"random\") {\n        for (int i = 0; i < m; i++)\n            fi[i] = rnd.next(4, 1000);\n    } else if (type == \"large_range\") {\n        fi[0] = 4;\n        fi[1] = 1000;\n        for (int i = 2; i < m; i++)\n            fi[i] = rnd.next(4, 1000);\n    } else if (type == \"small_range\") {\n        int base = rnd.next(4, 1000 - 5);\n        for (int i = 0; i < m; i++)\n            fi[i] = rnd.next(base, base + 5);\n    } else if (type == \"one_big\") {\n        for (int i = 0; i < m-1; i++)\n            fi[i] = rnd.next(4, 500);\n        fi[m-1] = rnd.next(501, 1000);\n        shuffle(fi.begin(), fi.end());\n    } else if (type == \"one_small\") {\n        for (int i = 0; i < m-1; i++)\n            fi[i] = rnd.next(501, 1000);\n        fi[m-1] = rnd.next(4, 500);\n        shuffle(fi.begin(), fi.end());\n    } else if (type == \"duplicates\") {\n        int num_unique = rnd.next(1, min(10,m)); // up to 10 unique numbers\n        vector<int> unique_values(num_unique);\n        for (int i = 0; i < num_unique; i++)\n            unique_values[i] = rnd.next(4, 1000);\n        for (int i = 0; i < m; i++)\n            fi[i] = unique_values[rnd.next(0, num_unique -1)];\n    } else {\n        // default to random\n        for (int i = 0; i < m; i++)\n            fi[i] = rnd.next(4, 1000);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output fi's\n    for (int i = 0; i < m; i++) {\n        printf(\"%d\", fi[i]);\n        if (i < m -1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type all_equal\n./gen -n 2 -m 2 -type increasing\n./gen -n 2 -m 2 -type decreasing\n./gen -n 2 -m 2 -type random\n\n./gen -n 2 -m 50 -type all_equal\n./gen -n 2 -m 50 -type increasing\n./gen -n 2 -m 50 -type decreasing\n./gen -n 2 -m 50 -type random\n\n./gen -n 25 -m 25 -type all_equal\n./gen -n 25 -m 25 -type increasing\n./gen -n 25 -m 25 -type decreasing\n./gen -n 25 -m 25 -type random\n\n./gen -n 25 -m 30 -type one_big\n./gen -n 25 -m 30 -type one_small\n./gen -n 25 -m 30 -type duplicates\n\n./gen -n 20 -m 50 -type large_range\n./gen -n 20 -m 50 -type small_range\n./gen -n 20 -m 50 -type duplicates\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type increasing\n./gen -n 50 -m 50 -type decreasing\n\n./gen -n 49 -m 50 -type random\n./gen -n 2 -m 50 -type random\n\n./gen -n 2 -m 3 -type random\n./gen -n 3 -m 4 -type random\n\n./gen -n 30 -m 40 -type increasing\n./gen -n 30 -m 40 -type decreasing\n./gen -n 30 -m 40 -type random\n\n./gen -n 50 -m 50 -type one_big\n./gen -n 50 -m 50 -type one_small\n\n./gen -n 50 -m 50 -type duplicates\n\n./gen -n 49 -m 50 -type small_range\n\n./gen -n 2 -m 2 -type all_equal\n\n./gen -n 2 -m 2 -type one_big\n\n./gen -n 2 -m 2 -type one_small\n\n./gen -n 2 -m 2 -type large_range\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:13.345094",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "337/B",
      "title": "B. Routine Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains four space-separated integers a, b, c, d (1 ≤ a, b, c, d ≤ 1000).",
      "output_spec": "OutputPrint the answer to the problem as \"p/q\", where p is a non-negative integer, q is a positive integer and numbers p and q don't have a common divisor larger than 1.",
      "sample_tests": "ExamplesInputCopy1 1 3 2OutputCopy1/3InputCopy4 3 2 2OutputCopy1/4",
      "description": "B. Routine Problem\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains four space-separated integers a, b, c, d (1 ≤ a, b, c, d ≤ 1000).\n\nOutputPrint the answer to the problem as \"p/q\", where p is a non-negative integer, q is a positive integer and numbers p and q don't have a common divisor larger than 1.\n\nInputCopy1 1 3 2OutputCopy1/3InputCopy4 3 2 2OutputCopy1/4\n\nInputCopy1 1 3 2\n\nOutputCopy1/3\n\nInputCopy4 3 2 2\n\nOutputCopy1/4\n\nNoteSample 1. Manao's monitor has a square screen. The movie has 3:2 horizontal to vertical length ratio. Obviously, the movie occupies most of the screen if the width of the picture coincides with the width of the screen. In this case, only 2/3 of the monitor will project the movie in the horizontal dimension: Sample 2. This time the monitor's width is 4/3 times larger than its height and the movie's frame is square. In this case, the picture must take up the whole monitor in the vertical dimension and only 3/4 in the horizontal dimension:",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000, \"d\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000, \"d\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000, \"d\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int maxValue = opt<int>(\"maxValue\", 1000); // Default maximum value is 1000\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n    int a, b, c, d;\n\n    if (type == \"random\") {\n        // Random values for a, b, c, d in [1, maxValue]\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        c = rnd.next(1, maxValue);\n        d = rnd.next(1, maxValue);\n    } else if (type == \"square_screen\") {\n        // Screen is square (a == b)\n        a = b = rnd.next(1, maxValue);\n        c = rnd.next(1, maxValue);\n        d = rnd.next(1, maxValue);\n    } else if (type == \"square_movie\") {\n        // Movie frame is square (c == d)\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        c = d = rnd.next(1, maxValue);\n    } else if (type == \"same_ratio\") {\n        // Screen and movie have the same aspect ratio (a:b == c:d)\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        int gcd_ab = __gcd(a, b);\n        int a0 = a / gcd_ab;\n        int b0 = b / gcd_ab;\n        int k = rnd.next(1, maxValue / max(a0, b0));\n        c = a0 * k;\n        d = b0 * k;\n    } else if (type == \"max_values\") {\n        // All values are maximal\n        a = b = c = d = maxValue;\n    } else if (type == \"min_values\") {\n        // All values are minimal\n        a = b = c = d = 1;\n    } else if (type == \"movie_wider\") {\n        // Movie is wider than the screen (c/d > a/b)\n        a = rnd.next(1, maxValue - 1);\n        b = rnd.next(1, maxValue - 1);\n        c = rnd.next(a + 1, maxValue);\n        d = rnd.next(1, b);\n    } else if (type == \"movie_taller\") {\n        // Movie is taller than the screen (c/d < a/b)\n        a = rnd.next(1, maxValue - 1);\n        b = rnd.next(1, maxValue - 1);\n        c = rnd.next(1, a);\n        d = rnd.next(b + 1, maxValue);\n    } else {\n        // Default to random if type is unrecognized\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        c = rnd.next(1, maxValue);\n        d = rnd.next(1, maxValue);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", a, b, c, d);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int maxValue = opt<int>(\"maxValue\", 1000); // Default maximum value is 1000\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n    int a, b, c, d;\n\n    if (type == \"random\") {\n        // Random values for a, b, c, d in [1, maxValue]\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        c = rnd.next(1, maxValue);\n        d = rnd.next(1, maxValue);\n    } else if (type == \"square_screen\") {\n        // Screen is square (a == b)\n        a = b = rnd.next(1, maxValue);\n        c = rnd.next(1, maxValue);\n        d = rnd.next(1, maxValue);\n    } else if (type == \"square_movie\") {\n        // Movie frame is square (c == d)\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        c = d = rnd.next(1, maxValue);\n    } else if (type == \"same_ratio\") {\n        // Screen and movie have the same aspect ratio (a:b == c:d)\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        int gcd_ab = __gcd(a, b);\n        int a0 = a / gcd_ab;\n        int b0 = b / gcd_ab;\n        int k = rnd.next(1, maxValue / max(a0, b0));\n        c = a0 * k;\n        d = b0 * k;\n    } else if (type == \"max_values\") {\n        // All values are maximal\n        a = b = c = d = maxValue;\n    } else if (type == \"min_values\") {\n        // All values are minimal\n        a = b = c = d = 1;\n    } else if (type == \"movie_wider\") {\n        // Movie is wider than the screen (c/d > a/b)\n        a = rnd.next(1, maxValue - 1);\n        b = rnd.next(1, maxValue - 1);\n        c = rnd.next(a + 1, maxValue);\n        d = rnd.next(1, b);\n    } else if (type == \"movie_taller\") {\n        // Movie is taller than the screen (c/d < a/b)\n        a = rnd.next(1, maxValue - 1);\n        b = rnd.next(1, maxValue - 1);\n        c = rnd.next(1, a);\n        d = rnd.next(b + 1, maxValue);\n    } else {\n        // Default to random if type is unrecognized\n        a = rnd.next(1, maxValue);\n        b = rnd.next(1, maxValue);\n        c = rnd.next(1, maxValue);\n        d = rnd.next(1, maxValue);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", a, b, c, d);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -maxValue 10\n./gen -type random -maxValue 100\n./gen -type random -maxValue 1000\n\n./gen -type min_values\n./gen -type max_values\n\n./gen -type same_ratio -maxValue 100\n./gen -type same_ratio -maxValue 1000\n./gen -type same_ratio -maxValue 500\n\n./gen -type square_screen -maxValue 10\n./gen -type square_screen -maxValue 100\n./gen -type square_screen -maxValue 500\n./gen -type square_screen -maxValue 1000\n\n./gen -type square_movie -maxValue 10\n./gen -type square_movie -maxValue 100\n./gen -type square_movie -maxValue 500\n./gen -type square_movie -maxValue 1000\n\n./gen -type movie_wider -maxValue 10\n./gen -type movie_wider -maxValue 100\n./gen -type movie_wider -maxValue 500\n./gen -type movie_wider -maxValue 1000\n\n./gen -type movie_taller -maxValue 10\n./gen -type movie_taller -maxValue 100\n./gen -type movie_taller -maxValue 500\n./gen -type movie_taller -maxValue 1000\n\n# Edge cases with minimal values\n./gen -type min_values -maxValue 1\n./gen -type random -maxValue 1\n./gen -type random -maxValue 2\n\n# Edge cases with maximal values\n./gen -type max_values -maxValue 1000\n./gen -type random -maxValue 1000\n\n# Additional test cases\n./gen -type same_ratio -maxValue 1\n./gen -type same_ratio -maxValue 2\n./gen -type same_ratio -maxValue 999\n./gen -type square_screen -maxValue 1\n./gen -type square_movie -maxValue 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:15.254275",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "337/C",
      "title": "C. Викторина",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записаны через пробел три целых числа n, m и k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).",
      "output_spec": "Выходные данныеВыведите единственное число — остаток от деления минимального возможного счета Манао в викторине на 1000000009 (109 + 9).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 3 2Выходные данныеСкопировать3Входные данныеСкопировать5 4 2Выходные данныеСкопировать6",
      "description": "C. Викторина\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записаны через пробел три целых числа n, m и k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите единственное число — остаток от деления минимального возможного счета Манао в викторине на 1000000009 (109 + 9).\n\nВыходные данные\n\nВходные данныеСкопировать5 3 2Выходные данныеСкопировать3Входные данныеСкопировать5 4 2Выходные данныеСкопировать6\n\nВходные данныеСкопировать5 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПример 1. Манао ответил на 3 вопроса из 5, и за каждые два последовательных правильных ответа его счет удваивался. Если бы Манао ответил на первый, третий и пятый вопросы, то он в сумме набрал бы 3 очка.Пример 2. Теперь Манао ответил уже на 4 вопроса. Минимальный счет достигается в случае, если его единственный неправильный ответ был на четвертый вопрос.Заметим, что вас просят минимизировать счет, а не остаток от деления счета на 1000000009. Например, если во время игры Манао мог набрать или 2000000000, или 2000000020 очков, ответом задачи будет 2000000000 mod 1000000009, даже хотя 2000000020 mod 1000000009 представляет собой меньшее число.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1); // Total number of questions\n    long long m = opt<long long>(\"m\", -1); // Number of correct answers\n    long long k = opt<long long>(\"k\", -1); // Counter limit for doubling score\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, k based on the specified type\n    if(type == \"minimal\") {\n        n = 2;\n        k = 2;\n        m = rnd.next(0LL, n);\n    } else if(type == \"maximal\") {\n        n = 1000000000LL; // Maximum n\n        k = n;\n        m = rnd.next(0LL, n);\n    } else if(type == \"k_min\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        k = 2;\n        m = (m == -1) ? rnd.next(0LL, n) : m;\n    } else if(type == \"k_max\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        k = n;\n        m = (m == -1) ? rnd.next(0LL, n) : m;\n    } else if(type == \"m_zero\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        m = 0;\n        k = (k == -1) ? rnd.next(2LL, n) : k;\n    } else if(type == \"m_n\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        m = n;\n        k = (k == -1) ? rnd.next(2LL, n) : k;\n    } else if(type == \"random\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        m = (m == -1) ? rnd.next(0LL, n) : m;\n        k = (k == -1) ? rnd.next(2LL, n) : k;\n    } else if(type == \"custom1\") {\n        n = 1000000000LL;\n        k = 1000000000LL;\n        m = 1LL;\n    } else if(type == \"custom2\") {\n        n = 1000000000LL;\n        k = 1000000LL;\n        long long maxMultiplier = n / k;\n        m = k * rnd.next(1LL, maxMultiplier);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure n, m, k satisfy the constraints\n    if (n < 2 || k < 2 || k > n || m < 0 || m > n) {\n        fprintf(stderr, \"Constraints not satisfied: n=%lld m=%lld k=%lld\\n\", n, m, k);\n        exit(1);\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld\\n\", n, m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1); // Total number of questions\n    long long m = opt<long long>(\"m\", -1); // Number of correct answers\n    long long k = opt<long long>(\"k\", -1); // Counter limit for doubling score\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, k based on the specified type\n    if(type == \"minimal\") {\n        n = 2;\n        k = 2;\n        m = rnd.next(0LL, n);\n    } else if(type == \"maximal\") {\n        n = 1000000000LL; // Maximum n\n        k = n;\n        m = rnd.next(0LL, n);\n    } else if(type == \"k_min\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        k = 2;\n        m = (m == -1) ? rnd.next(0LL, n) : m;\n    } else if(type == \"k_max\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        k = n;\n        m = (m == -1) ? rnd.next(0LL, n) : m;\n    } else if(type == \"m_zero\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        m = 0;\n        k = (k == -1) ? rnd.next(2LL, n) : k;\n    } else if(type == \"m_n\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        m = n;\n        k = (k == -1) ? rnd.next(2LL, n) : k;\n    } else if(type == \"random\") {\n        n = (n == -1) ? rnd.next(2LL, 1000000000LL) : n;\n        m = (m == -1) ? rnd.next(0LL, n) : m;\n        k = (k == -1) ? rnd.next(2LL, n) : k;\n    } else if(type == \"custom1\") {\n        n = 1000000000LL;\n        k = 1000000000LL;\n        m = 1LL;\n    } else if(type == \"custom2\") {\n        n = 1000000000LL;\n        k = 1000000LL;\n        long long maxMultiplier = n / k;\n        m = k * rnd.next(1LL, maxMultiplier);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure n, m, k satisfy the constraints\n    if (n < 2 || k < 2 || k > n || m < 0 || m > n) {\n        fprintf(stderr, \"Constraints not satisfied: n=%lld m=%lld k=%lld\\n\", n, m, k);\n        exit(1);\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld\\n\", n, m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n\n./gen -type maximal\n\n./gen -type k_min -n 5\n\n./gen -type k_max -n 5\n\n./gen -type m_zero -n 10 -k 2\n\n./gen -type m_n -n 10 -k 2\n\n./gen -type random\n\n./gen -n 100 -m 50 -k 25 -type random\n\n./gen -n 1000 -type random\n\n./gen -n 10000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 1000000 -type random\n\n./gen -n 10000000 -type random\n\n./gen -n 100000000 -type random\n\n./gen -n 1000000000 -type random\n\n./gen -n 1000000000 -m 0 -k 1000000000 -type m_zero\n\n./gen -n 1000000000 -m 1000000000 -k 1000000000 -type m_n\n\n./gen -n 1000000000 -k 2 -type k_min\n\n./gen -n 1000000000 -k 1000000000 -type k_max\n\n./gen -type custom1\n\n./gen -type custom2\n\n./gen -n 500000000 -type random\n\n./gen -n 750000000 -m 375000000 -k 500000000 -type random\n\n./gen -n 1000000000 -m 500000000 -k 1000000 -type random\n\n./gen -n 1000000000 -m 999999999 -k 999999999 -type random\n\n./gen -n 1000000000 -m 500000000 -k 500000000 -type random\n\n./gen -n 2 -type random\n\n./gen -n 10 -type random\n\n./gen -n 100 -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:17.498065",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "337/D",
      "title": "D. Книга Зла",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записано три целых числа n, m и d (1 ≤ m ≤ n ≤ 100000; 0 ≤ d ≤ n - 1). Во второй строке через пробел записано m различных целых чисел p1, p2, ..., pm (1 ≤ pi ≤ n). Далее следует n - 1 строка, каждая из которых описывает одну из тропинок, проложенных в рассматриваемой местности. Тропинка описывается парой разделенных пробелом чисел ai и bi, представляющих собой концы этой тропинки.",
      "output_spec": "Выходные данныеВыведите единственное число — количество населенных пунктов, в которых может находиться Книга Зла. Возможно, что информация, дошедшая до Манао, противоречива и не существует такого населенного пункта, где может находиться Книга. В таком случае выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 2 31 21 52 33 44 55 6Выходные данныеСкопировать3",
      "description": "D. Книга Зла\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записано три целых числа n, m и d (1 ≤ m ≤ n ≤ 100000; 0 ≤ d ≤ n - 1). Во второй строке через пробел записано m различных целых чисел p1, p2, ..., pm (1 ≤ pi ≤ n). Далее следует n - 1 строка, каждая из которых описывает одну из тропинок, проложенных в рассматриваемой местности. Тропинка описывается парой разделенных пробелом чисел ai и bi, представляющих собой концы этой тропинки.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — количество населенных пунктов, в которых может находиться Книга Зла. Возможно, что информация, дошедшая до Манао, противоречива и не существует такого населенного пункта, где может находиться Книга. В таком случае выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать6 2 31 21 52 33 44 55 6Выходные данныеСкопировать3\n\nВходные данныеСкопировать6 2 31 21 52 33 44 55 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПример 1. Радиус действия Книги Зла равен 3-ем, а ее воздействие было замечено в населенных пунктах 1 и 2. Таким образом, она может находиться в населенных пунктах под номерами 3, 4 и 5.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, n - 1, \"d\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 1, n, \"p_i\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == m, \"p_i's are not distinct\");\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a self-loop (%d, %d)\", i + 1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert(edge);\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that the graph is connected\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int nodes_visited = 1;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                nodes_visited++;\n                q.push(v);\n            }\n        }\n    }\n\n    ensuref(nodes_visited == n, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, n - 1, \"d\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 1, n, \"p_i\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == m, \"p_i's are not distinct\");\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a self-loop (%d, %d)\", i + 1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert(edge);\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that the graph is connected\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int nodes_visited = 1;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                nodes_visited++;\n                q.push(v);\n            }\n        }\n    }\n\n    ensuref(nodes_visited == n, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, n - 1, \"d\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 1, n, \"p_i\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == m, \"p_i's are not distinct\");\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a self-loop (%d, %d)\", i + 1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert(edge);\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that the graph is connected\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int nodes_visited = 1;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                nodes_visited++;\n                q.push(v);\n            }\n        }\n    }\n\n    ensuref(nodes_visited == n, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<pair<int,int>> edges;\n\nvoid generateChain(int n) {\n    edges.clear();\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({i-1, i});\n    }\n}\n\nvoid generateStar(int n) {\n    edges.clear();\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n}\n\nvoid generateRandomTree(int n) {\n    edges.clear();\n    for (int i = 2; i <= n; ++i) {\n        int parent = rnd.next(1, i-1);\n        edges.push_back({parent, i});\n    }\n}\n\nvoid generateBinaryTree(int n) {\n    edges.clear();\n    queue<int> q;\n    int currentNode = 1;\n    q.push(currentNode);\n    currentNode++;\n    while (currentNode <= n) {\n        int parent = q.front(); q.pop();\n        edges.push_back({parent, currentNode});\n        q.push(currentNode);\n        currentNode++;\n        if (currentNode <= n) {\n            edges.push_back({parent, currentNode});\n            q.push(currentNode);\n            currentNode++;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string treeType = opt<string>(\"tree\", \"random\");\n    string piType = opt<string>(\"pi\", \"random\");\n\n    // validate parameters\n    ensure(1 <= m && m <= n);\n    ensure(0 <= d && d <= n - 1);\n\n    // generate tree\n    if (treeType == \"chain\") {\n        generateChain(n);\n    } else if (treeType == \"star\") {\n        generateStar(n);\n    } else if (treeType == \"binary\") {\n        generateBinaryTree(n);\n    } else if (treeType == \"random\") {\n        generateRandomTree(n);\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", treeType.c_str());\n        exit(1);\n    }\n\n    // Build adjacency list\n    adj.clear();\n    adj.resize(n+1);\n    for (auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Generate p_i's\n    vector<int> pis;\n\n    // Collect nodes according to piType\n    if (piType == \"random\") {\n        // select m distinct nodes randomly\n        for (int i = 1; i <= n; ++i) {\n            pis.push_back(i);\n        }\n        shuffle(pis.begin(), pis.end());\n        pis.resize(m);\n    } else if (piType == \"leaves\") {\n        // collect leaves\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if (int(leaves.size()) < m) {\n            fprintf(stderr, \"Not enough leaves for piType 'leaves' and m=%d\\n\", m);\n            exit(1);\n        }\n        shuffle(leaves.begin(), leaves.end());\n        pis.assign(leaves.begin(), leaves.begin() + m);\n    } else if (piType == \"root\") {\n        // select root node\n        if (m != 1) {\n            fprintf(stderr, \"piType 'root' requires m=1\\n\");\n            exit(1);\n        }\n        pis.push_back(1);\n    } else if (piType == \"middle\") {\n        // nodes at mid-depth\n        // Perform BFS to find depths\n        vector<int> depth(n+1, -1);\n        queue<int> q;\n        q.push(1);\n        depth[1] = 0;\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int v : adj[u]) {\n                if (depth[v] == -1) {\n                    depth[v] = depth[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        // Find nodes with depth equal to max_depth / 2\n        int max_depth = *max_element(depth.begin(), depth.end());\n        int target_depth = max_depth / 2;\n        vector<int> middles;\n        for (int i = 1; i <= n; ++i) {\n            if (depth[i] == target_depth) {\n                middles.push_back(i);\n            }\n        }\n        if (int(middles.size()) < m) {\n            fprintf(stderr, \"Not enough middle nodes for piType 'middle' and m=%d\\n\", m);\n            exit(1);\n        }\n        shuffle(middles.begin(), middles.end());\n        pis.assign(middles.begin(), middles.begin() + m);\n    } else {\n        fprintf(stderr, \"Unknown pi type: %s\\n\", piType.c_str());\n        exit(1);\n    }\n\n    // Now output the test case\n    printf(\"%d %d %d\\n\", n, m, d);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", pis[i], i == m-1 ? '\\n' : ' ');\n    }\n    // Shuffle the edges before outputting\n    shuffle(edges.begin(), edges.end());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<pair<int,int>> edges;\n\nvoid generateChain(int n) {\n    edges.clear();\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({i-1, i});\n    }\n}\n\nvoid generateStar(int n) {\n    edges.clear();\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n}\n\nvoid generateRandomTree(int n) {\n    edges.clear();\n    for (int i = 2; i <= n; ++i) {\n        int parent = rnd.next(1, i-1);\n        edges.push_back({parent, i});\n    }\n}\n\nvoid generateBinaryTree(int n) {\n    edges.clear();\n    queue<int> q;\n    int currentNode = 1;\n    q.push(currentNode);\n    currentNode++;\n    while (currentNode <= n) {\n        int parent = q.front(); q.pop();\n        edges.push_back({parent, currentNode});\n        q.push(currentNode);\n        currentNode++;\n        if (currentNode <= n) {\n            edges.push_back({parent, currentNode});\n            q.push(currentNode);\n            currentNode++;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string treeType = opt<string>(\"tree\", \"random\");\n    string piType = opt<string>(\"pi\", \"random\");\n\n    // validate parameters\n    ensure(1 <= m && m <= n);\n    ensure(0 <= d && d <= n - 1);\n\n    // generate tree\n    if (treeType == \"chain\") {\n        generateChain(n);\n    } else if (treeType == \"star\") {\n        generateStar(n);\n    } else if (treeType == \"binary\") {\n        generateBinaryTree(n);\n    } else if (treeType == \"random\") {\n        generateRandomTree(n);\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", treeType.c_str());\n        exit(1);\n    }\n\n    // Build adjacency list\n    adj.clear();\n    adj.resize(n+1);\n    for (auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Generate p_i's\n    vector<int> pis;\n\n    // Collect nodes according to piType\n    if (piType == \"random\") {\n        // select m distinct nodes randomly\n        for (int i = 1; i <= n; ++i) {\n            pis.push_back(i);\n        }\n        shuffle(pis.begin(), pis.end());\n        pis.resize(m);\n    } else if (piType == \"leaves\") {\n        // collect leaves\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if (int(leaves.size()) < m) {\n            fprintf(stderr, \"Not enough leaves for piType 'leaves' and m=%d\\n\", m);\n            exit(1);\n        }\n        shuffle(leaves.begin(), leaves.end());\n        pis.assign(leaves.begin(), leaves.begin() + m);\n    } else if (piType == \"root\") {\n        // select root node\n        if (m != 1) {\n            fprintf(stderr, \"piType 'root' requires m=1\\n\");\n            exit(1);\n        }\n        pis.push_back(1);\n    } else if (piType == \"middle\") {\n        // nodes at mid-depth\n        // Perform BFS to find depths\n        vector<int> depth(n+1, -1);\n        queue<int> q;\n        q.push(1);\n        depth[1] = 0;\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int v : adj[u]) {\n                if (depth[v] == -1) {\n                    depth[v] = depth[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        // Find nodes with depth equal to max_depth / 2\n        int max_depth = *max_element(depth.begin(), depth.end());\n        int target_depth = max_depth / 2;\n        vector<int> middles;\n        for (int i = 1; i <= n; ++i) {\n            if (depth[i] == target_depth) {\n                middles.push_back(i);\n            }\n        }\n        if (int(middles.size()) < m) {\n            fprintf(stderr, \"Not enough middle nodes for piType 'middle' and m=%d\\n\", m);\n            exit(1);\n        }\n        shuffle(middles.begin(), middles.end());\n        pis.assign(middles.begin(), middles.begin() + m);\n    } else {\n        fprintf(stderr, \"Unknown pi type: %s\\n\", piType.c_str());\n        exit(1);\n    }\n\n    // Now output the test case\n    printf(\"%d %d %d\\n\", n, m, d);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", pis[i], i == m-1 ? '\\n' : ' ');\n    }\n    // Shuffle the edges before outputting\n    shuffle(edges.begin(), edges.end());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, chain tree, m=1, d=0, pi=root\n./gen -n 1 -m 1 -d 0 -tree chain -pi root\n\n# Small n, chain tree, m=1, d=0, pi=leaves\n./gen -n 2 -m 1 -d 0 -tree chain -pi leaves\n\n# Small n, star tree, m=2, d=1, pi=leaves\n./gen -n 5 -m 2 -d 1 -tree star -pi leaves\n\n# Small n, binary tree, m=2, d=2, pi=middle\n./gen -n 7 -m 2 -d 2 -tree binary -pi middle\n\n# Max n, chain tree, m=1, d=n-1, pi=leaves\n./gen -n 100000 -m 1 -d 99999 -tree chain -pi leaves\n\n# Max n, star tree, m=n, d=0, pi=random\n./gen -n 100000 -m 100000 -d 0 -tree star -pi random\n\n# Medium n, random tree, m=n/2, d=n/4, pi=random\n./gen -n 50000 -m 25000 -d 12500 -tree random -pi random\n\n# Max n, binary tree, m=1, d=0, pi=root\n./gen -n 100000 -m 1 -d 0 -tree binary -pi root\n\n# Small n, chain tree, m=n, d=0, pi=random\n./gen -n 10 -m 10 -d 0 -tree chain -pi random\n\n# Max n, random tree, m=1000, d=0, pi=leaves\n./gen -n 100000 -m 1000 -d 0 -tree random -pi leaves\n\n# Max n, star tree, m=1, d=100000, pi=root\n./gen -n 100000 -m 1 -d 99999 -tree star -pi root\n\n# Edge case d=0\n./gen -n 100000 -m 1 -d 0 -tree random -pi random\n\n# Edge case m=1\n./gen -n 100000 -m 1 -d 50000 -tree random -pi random\n\n# Edge case m=n\n./gen -n 100000 -m 100000 -d 1 -tree random -pi random\n\n# Edge case d=n-1\n./gen -n 100000 -m 1000 -d 99999 -tree random -pi random\n\n# Balanced tree, m=10, d=15\n./gen -n 20000 -m 10 -d 15 -tree binary -pi random\n\n# Chain tree, m=10, d=1\n./gen -n 20000 -m 10 -d 1 -tree chain -pi random\n\n# Star tree, m=10, d=1\n./gen -n 20000 -m 10 -d 1 -tree star -pi random\n\n# Random tree, m=1, d=0\n./gen -n 20000 -m 1 -d 0 -tree random -pi root\n\n# Chain tree, m=1, d=n-1\n./gen -n 20000 -m 1 -d 19999 -tree chain -pi root\n\n# Max n, piType 'leaves' with m less than leaves\n./gen -n 100000 -m 50000 -d 50000 -tree binary -pi leaves\n\n# Middle nodes as p_i\n./gen -n 100000 -m 1000 -d 500 -tree random -pi middle\n\n# Max n, m=1, d=0\n./gen -n 100000 -m 1 -d 0 -tree chain -pi root\n\n# Max n, m=1, d=0, star tree, pi=leaves\n./gen -n 100000 -m 1 -d 0 -tree star -pi leaves\n\n# Max n, m=1, d=0, binary tree, pi=middle\n./gen -n 100000 -m 1 -d 0 -tree binary -pi middle\n\n# Random tree, random d, random m\n./gen -n 98765 -m 54321 -d 12345 -tree random -pi random\n\n# Random tree, d=0, m random\n./gen -n 12345 -m 6789 -d 0 -tree random -pi random\n\n# Random tree, d=n-1, m=1\n./gen -n 12345 -m 1 -d 12344 -tree random -pi random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:19.243503",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "337/E",
      "title": "E. Divisor Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 8). The second line contains n distinct space-separated integers ai (2 ≤ ai ≤ 1012).",
      "output_spec": "OutputPrint a single integer — the minimum number of vertices in the divisor tree that contains each of the numbers ai.",
      "sample_tests": "ExamplesInputCopy26 10OutputCopy7InputCopy46 72 8 4OutputCopy12InputCopy17OutputCopy1",
      "description": "E. Divisor Tree\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 8). The second line contains n distinct space-separated integers ai (2 ≤ ai ≤ 1012).\n\nOutputPrint a single integer — the minimum number of vertices in the divisor tree that contains each of the numbers ai.\n\nInputCopy26 10OutputCopy7InputCopy46 72 8 4OutputCopy12InputCopy17OutputCopy1\n\nInputCopy26 10\n\nOutputCopy7\n\nInputCopy46 72 8 4\n\nOutputCopy12\n\nInputCopy17\n\nOutputCopy1\n\nNoteSample 1. The smallest divisor tree looks this way: Sample 2. In this case you can build the following divisor tree: Sample 3. Note that the tree can consist of a single vertex.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 8);\n    inf.readEoln();\n\n    vector<long long> a(n);\n    a[0] = inf.readLong(2, 1000000000000LL);\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        a[i] = inf.readLong(2, 1000000000000LL);\n    }\n    inf.readEoln();\n\n    set<long long> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 8);\n    inf.readEoln();\n\n    vector<long long> a(n);\n    a[0] = inf.readLong(2, 1000000000000LL);\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        a[i] = inf.readLong(2, 1000000000000LL);\n    }\n    inf.readEoln();\n\n    set<long long> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 8);\n    inf.readEoln();\n\n    vector<long long> a(n);\n    a[0] = inf.readLong(2, 1000000000000LL);\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        a[i] = inf.readLong(2, 1000000000000LL);\n    }\n    inf.readEoln();\n\n    set<long long> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_SMALL_PRIME = 100;\n\nvector<int> small_primes;\n\nvoid generate_small_primes() {\n    vector<bool> is_prime(MAX_SMALL_PRIME+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i=2; i<=MAX_SMALL_PRIME; ++i) {\n        if (is_prime[i]) {\n            small_primes.push_back(i);\n            for (int j=i*2; j<=MAX_SMALL_PRIME; j+=i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> ai(n);\n\n    if (type == \"small_primes\") {\n        // Generate n distinct small primes\n        generate_small_primes();\n        shuffle(small_primes.begin(), small_primes.end());\n        for (int i=0; i<n; ++i)\n            ai[i] = small_primes[i];\n    } else if (type == \"large_primes\") {\n        // Generate n distinct large primes near 1e12\n        set<long long> primes_set;\n        while ((int)primes_set.size() < n) {\n            long long candidate = rnd.next(500000000000LL, 1000000000000LL) | 1; // Ensure odd number\n            bool is_prime_candidate = true;\n            for (long long i = 3; i <= 1000000LL; i += 2) {\n                if (candidate % i == 0) {\n                    is_prime_candidate = false;\n                    break;\n                }\n            }\n            if (is_prime_candidate) {\n                primes_set.insert(candidate);\n            }\n        }\n        int idx = 0;\n        for (auto p : primes_set) {\n            ai[idx++] = p;\n        }\n    } else if (type == \"small_composites\") {\n        // Generate n distinct small composite numbers (between 4 and 200)\n        vector<int> composites;\n        for (int i=4; i<=200; ++i) {\n            bool is_prime = true;\n            for (int j=2; j*j<=i; ++j) {\n                if (i % j == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (!is_prime)\n                composites.push_back(i);\n        }\n        shuffle(composites.begin(), composites.end());\n        for (int i=0; i<n; ++i)\n            ai[i] = composites[i];\n    } else if (type == \"large_composites\") {\n        // Generate n distinct large composite numbers\n        set<long long> composite_set;\n        while ((int)composite_set.size() < n) {\n            long long candidate = rnd.next(500000000000LL, 1000000000000LL);\n            if (candidate % 2 == 0 || candidate % 3 == 0 || candidate % 5 == 0 || candidate % 7 == 0)\n                composite_set.insert(candidate);\n        }\n        int idx = 0;\n        for (auto c : composite_set) {\n            ai[idx++] = c;\n        }\n    } else if (type == \"powers_of_two\") {\n        // Generate n distinct powers of two\n        set<long long> powers;\n        while ((int)powers.size() < n) {\n            int exp = rnd.next(1, 39);\n            powers.insert(1LL << exp);\n        }\n        int idx = 0;\n        for (auto p : powers) {\n            ai[idx++] = p;\n        }\n    } else if (type == \"co_prime\") {\n        // Generate n co-prime numbers\n        generate_small_primes();\n        shuffle(small_primes.begin(), small_primes.end());\n        for (int i=0; i<n; ++i) {\n            ai[i] = small_primes[i];\n        }\n    } else if (type == \"common_factor\") {\n        // Generate n numbers that share a common small factor\n        long long common_factor = rnd.next(2LL, 100LL);\n        set<long long> nums_set;\n        while ((int)nums_set.size() < n) {\n            long long num = common_factor * rnd.next(2LL, 10000000LL);\n            nums_set.insert(num);\n        }\n        int idx = 0;\n        for (auto num : nums_set) {\n            ai[idx++] = num;\n        }\n    } else if (type == \"large_common_factor\") {\n        // Generate n numbers that share a common large factor\n        long long common_factor = rnd.next(100000LL, 10000000LL);\n        set<long long> nums_set;\n        while ((int)nums_set.size() < n) {\n            long long num = common_factor * rnd.next(2LL, 100000LL);\n            nums_set.insert(num);\n        }\n        int idx = 0;\n        for (auto num : nums_set) {\n            ai[idx++] = num;\n        }\n    } else { // type == \"random\"\n        // Generate random numbers between 2 and 1e12\n        set<long long> nums_set;\n        while ((int)nums_set.size() < n) {\n            long long num = rnd.next(2LL, 1000000000000LL);\n            nums_set.insert(num);\n        }\n        int idx = 0;\n        for (auto num : nums_set) {\n            ai[idx++] = num;\n        }\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i=0; i<n; ++i) {\n        printf(\"%lld%c\", ai[i], i+1 == n ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_SMALL_PRIME = 100;\n\nvector<int> small_primes;\n\nvoid generate_small_primes() {\n    vector<bool> is_prime(MAX_SMALL_PRIME+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i=2; i<=MAX_SMALL_PRIME; ++i) {\n        if (is_prime[i]) {\n            small_primes.push_back(i);\n            for (int j=i*2; j<=MAX_SMALL_PRIME; j+=i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> ai(n);\n\n    if (type == \"small_primes\") {\n        // Generate n distinct small primes\n        generate_small_primes();\n        shuffle(small_primes.begin(), small_primes.end());\n        for (int i=0; i<n; ++i)\n            ai[i] = small_primes[i];\n    } else if (type == \"large_primes\") {\n        // Generate n distinct large primes near 1e12\n        set<long long> primes_set;\n        while ((int)primes_set.size() < n) {\n            long long candidate = rnd.next(500000000000LL, 1000000000000LL) | 1; // Ensure odd number\n            bool is_prime_candidate = true;\n            for (long long i = 3; i <= 1000000LL; i += 2) {\n                if (candidate % i == 0) {\n                    is_prime_candidate = false;\n                    break;\n                }\n            }\n            if (is_prime_candidate) {\n                primes_set.insert(candidate);\n            }\n        }\n        int idx = 0;\n        for (auto p : primes_set) {\n            ai[idx++] = p;\n        }\n    } else if (type == \"small_composites\") {\n        // Generate n distinct small composite numbers (between 4 and 200)\n        vector<int> composites;\n        for (int i=4; i<=200; ++i) {\n            bool is_prime = true;\n            for (int j=2; j*j<=i; ++j) {\n                if (i % j == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (!is_prime)\n                composites.push_back(i);\n        }\n        shuffle(composites.begin(), composites.end());\n        for (int i=0; i<n; ++i)\n            ai[i] = composites[i];\n    } else if (type == \"large_composites\") {\n        // Generate n distinct large composite numbers\n        set<long long> composite_set;\n        while ((int)composite_set.size() < n) {\n            long long candidate = rnd.next(500000000000LL, 1000000000000LL);\n            if (candidate % 2 == 0 || candidate % 3 == 0 || candidate % 5 == 0 || candidate % 7 == 0)\n                composite_set.insert(candidate);\n        }\n        int idx = 0;\n        for (auto c : composite_set) {\n            ai[idx++] = c;\n        }\n    } else if (type == \"powers_of_two\") {\n        // Generate n distinct powers of two\n        set<long long> powers;\n        while ((int)powers.size() < n) {\n            int exp = rnd.next(1, 39);\n            powers.insert(1LL << exp);\n        }\n        int idx = 0;\n        for (auto p : powers) {\n            ai[idx++] = p;\n        }\n    } else if (type == \"co_prime\") {\n        // Generate n co-prime numbers\n        generate_small_primes();\n        shuffle(small_primes.begin(), small_primes.end());\n        for (int i=0; i<n; ++i) {\n            ai[i] = small_primes[i];\n        }\n    } else if (type == \"common_factor\") {\n        // Generate n numbers that share a common small factor\n        long long common_factor = rnd.next(2LL, 100LL);\n        set<long long> nums_set;\n        while ((int)nums_set.size() < n) {\n            long long num = common_factor * rnd.next(2LL, 10000000LL);\n            nums_set.insert(num);\n        }\n        int idx = 0;\n        for (auto num : nums_set) {\n            ai[idx++] = num;\n        }\n    } else if (type == \"large_common_factor\") {\n        // Generate n numbers that share a common large factor\n        long long common_factor = rnd.next(100000LL, 10000000LL);\n        set<long long> nums_set;\n        while ((int)nums_set.size() < n) {\n            long long num = common_factor * rnd.next(2LL, 100000LL);\n            nums_set.insert(num);\n        }\n        int idx = 0;\n        for (auto num : nums_set) {\n            ai[idx++] = num;\n        }\n    } else { // type == \"random\"\n        // Generate random numbers between 2 and 1e12\n        set<long long> nums_set;\n        while ((int)nums_set.size() < n) {\n            long long num = rnd.next(2LL, 1000000000000LL);\n            nums_set.insert(num);\n        }\n        int idx = 0;\n        for (auto num : nums_set) {\n            ai[idx++] = num;\n        }\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i=0; i<n; ++i) {\n        printf(\"%lld%c\", ai[i], i+1 == n ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type small_primes\n./gen -n 1 -type large_primes\n./gen -n 1 -type small_composites\n./gen -n 1 -type large_composites\n./gen -n 1 -type powers_of_two\n./gen -n 1 -type random\n\n./gen -n 2 -type co_prime\n./gen -n 2 -type common_factor\n./gen -n 2 -type random\n\n./gen -n 3 -type small_primes\n./gen -n 3 -type large_primes\n./gen -n 3 -type small_composites\n./gen -n 3 -type large_composites\n./gen -n 3 -type powers_of_two\n\n./gen -n 4 -type co_prime\n./gen -n 4 -type common_factor\n./gen -n 4 -type random\n\n./gen -n 5 -type large_common_factor\n./gen -n 5 -type small_primes\n./gen -n 5 -type random\n\n./gen -n 6 -type powers_of_two\n./gen -n 6 -type large_composites\n./gen -n 6 -type random\n\n./gen -n 7 -type co_prime\n./gen -n 7 -type common_factor\n./gen -n 7 -type random\n\n./gen -n 8 -type large_primes\n./gen -n 8 -type small_composites\n./gen -n 8 -type large_common_factor\n./gen -n 8 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:21.488567",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "338/A",
      "title": "A. Викторина",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записаны через пробел три целых числа n, m и k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).",
      "output_spec": "Выходные данныеВыведите единственное число — остаток от деления минимального возможного счета Манао в викторине на 1000000009 (109 + 9).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 3 2Выходные данныеСкопировать3Входные данныеСкопировать5 4 2Выходные данныеСкопировать6",
      "description": "A. Викторина\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записаны через пробел три целых числа n, m и k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите единственное число — остаток от деления минимального возможного счета Манао в викторине на 1000000009 (109 + 9).\n\nВыходные данные\n\nВходные данныеСкопировать5 3 2Выходные данныеСкопировать3Входные данныеСкопировать5 4 2Выходные данныеСкопировать6\n\nВходные данныеСкопировать5 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПример 1. Манао ответил на 3 вопроса из 5, и за каждые два последовательных правильных ответа его счет удваивался. Если бы Манао ответил на первый, третий и пятый вопросы, то он в сумме набрал бы 3 очка.Пример 2. Теперь Манао ответил уже на 4 вопроса. Минимальный счет достигается в случае, если его единственный неправильный ответ был на четвертый вопрос.Заметим, что вас просят минимизировать счет, а не остаток от деления счета на 1000000009. Например, если во время игры Манао мог набрать или 2000000000, или 2000000020 очков, ответом задачи будет 2000000000 mod 1000000009, даже хотя 2000000020 mod 1000000009 представляет собой меньшее число.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Всем привет!Через несколько часов (16 августа, 20:00MSK) начнется Codeforces Round #196.Главным образом вам снова придется помогать Манао, задачи которого на этот раз варьируют от просмотра фильмов и участия в викторинах до древостроения и борьбы с нечистью.Хочу поблагодарить за помощь в подготовке раунда координатора задач Gerald; Seyaua, который тестировал задачи; Delinur, которая переводила условия на английский язык; и Aksenov239, который вычитывал условия.Разбалловка в обоих дивизионах будет стандартная.Также добавлю, что я даже старше, чем Sammarize, поэтому перехватываю титул самого старого автора Codeforces-раунда до появления следующего претендента ;)Контест окончен, я очень надеюсь что он вам понравился. Результаты: Див1, Див2. Мои поздравления лучшей пятерке первого дивизиона: tourist ilyakor al13n aa2985759 rng_58 Также поздавляю победителя второго дивизиона Ruthles!Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 922
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces",
          "content": "337A - ПазлыВ первую очередь, упорядочим числа f[i] по возрастанию. Теперь допустим, что самый маленький пазл, который приобретет учительница, состоит из f[k] фрагментов. Понятно, что в таком случае для минимизации разницы она должна приобрести наименьшие n пазлов, равных или превосходящих f[k] по размеру, то есть пазлы размеров f[k], f[k+1], ..., f[k+n-1] (это не совсем правильно, если среди f[i] встречаются повторяющиеся числа и выполняется f[k]=f[k-1], но такие случаи можно не рассматривать). Разница между наибольшим и наименьшим количествами фрагментов в таком наборе равняется f[k+n-1]-f[k].Чтобы выбрать оптимальное f[k], переберем значение k от 1 до m-n и выберем наименьшую возможную разницу. Таким образом, весь алгоритм выглядит следующим образом: read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n best = min(best, f[k+n-1] - f[k])\nprint best337B - Бытовая задачаДопустим, что ширина и высота монитора равны W и H соответственно. Так как W:H = a:b, мы имеем H=W*b/a. Аналогично, ширина и высота картинки фильма w и h удовлетворяют соотношению h=w*d/c. Представим себе, что Манао растягивает (или, наоборот, сужает) картинку фильма до тех пор, пока она не упрется в стенки экрана по горизонтали или вертикали. Рассмотрим три случая: соотношение горизонтали и вертикали монитора меньше, больше и равно соответствующему соотношению картинки фильма.В первом случае (a/b < c/d) картинка заполнит всю горизонталь экрана, и процесс растяжения остановится. Таким образом, новая ширина картинки будет равняться W, то есть картинка увеличилась в W/w раз. Соответственно, её новая высота равна h*W/w = w*c/d * W/w = W*d/c. Нас интересует, какая часть вертикали экрана осталась незанятой, то есть (высота экрана - новая высота картинки) / (высота экрана) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc. Во втором случае (a/b > c/d) картинка первой заполнит вертикаль. В этом случае, её высота будет равна H, а ширина — w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d. Часть горизонтали, оставшася незанятой, равна (W - W*b/a * c/d)/W = (ad-bc)/ad.В третьем случае картинка заполнит экран полностью, поэтому ответом задачи будет 0.Для того, чтобы вывести ответ в виде несократимой дроби, нужно найти наибольший общий делитель его числителя и знаменателя. Сделать это можно с помощью алгоритма Евклида, или просто циклом перебрать все числа от 1 до q и выбрать наибольшее, делящее их обоих. Так как q не превосходит произведения двух чисел из входных данных, а значения этих чисел ограничены 1000-ей, в худшем случае придется рассмотреть лишь миллион чисел.337C - ВикторинаДопустим, что Манао в процессе игры удвоил свой счет (за счёт ответа на k последовательных вопросов) ровно X раз. Тогда меньше всего очков Манао наберет, если эти удвоения произойдут в самом начале игры — то есть он ответит подряд на первые X*k вопросов, а потом ни разу не сможет ответить на k последовательных вопросов. Правильность этого утверждения основывается на том, что в любом другом сценарии с X удвоениями можно сдвинуть все удвоения в начало и этим не увеличить счет. Таким образом, для X=1 Манао наберет как минимум k*2+m-k очков: ответит на k последовательных вопросов, затем счет удвоится, а затем Манао ответит ещё на m-k вопросов. Для X=2 минимальный возможный счет равен (k*2+k)*2+m-2*k, для X=3 — ((k*2+k)*2+k)*2+m-3*k. В общем случае мы получаем формулу (2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k.Из сделанного выше наблюдения становится понятно, что счет монотонно растет с увеличением X, поэтому нужно лишь найти наименьшее подходящее значение X. Оно должно удовлетворять неравенствам X*k <= n и X + (n - n mod k) / k * (k-1) + n mod k >= m. Поподробнее о втором неравенстве: на первые X*k вопросов Манао ответил, таким образом осталось ещё n-X*k. Теперь он может отвечать максимум на k-1 вопрос из каждых k. Если бы n-X*k делилось на k (что есть то же самое, что n делится на k), неравенство имело бы вид X*k + (n-X*k) / k * (k-1) >= m, но из-за остатка формула получается более сложной: X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m. Упрощая все что можно, получаем из неё формулу, приведенную выше. Таким образом, минимальный X равен max(0, m - (n - n mod k) / k * (k-1) - n mod k). Для вычисления счета, соответствующего найденному значению X, нужно использовать бинарное возведение в степень. Таким образом, итоговая сложность решения — O(log(n)).337D - Книга ЗлаОчевидно, что на языке теории графов перед нами стоит следующая задача — дано дерево из n вершин, m из которых помечены; найти количество вершин, расстояние от которых до каждой из помеченных вершин не превосходит d.Давайте подвесим дерево за какую-либо вершину r, то есть будем рассматривать его как корневое дерево с корнем в r. Перефразируем условие, налагаемое на искомые вершины: нам нужно посчитать количество таких вершин v, что максимальное расстояние от v до какой-либо помеченной вершины не больше d.Для любой внутренней вершины v, наиболее отдаленная от неё вершина находится или в поддереве v, или за его пределами — во втором случае путь от v до наиболее отдаленной помеченной вершины проходит через родителя вершины v. Используя данное наблюдение, можно быстро пересчитывать расстояния до наиболее отдаленных помеченных вершин при переходе от некоторой вершины к её ребенку.Для начала давайте посчитаем расстояние от каждой вершины v до самой далекой от неё помеченной вершины в поддереве v. Будем называть это расстояние distDown[v]. Посчитать значения distDown[] можно с помощью поиска в глубину: для листьев дерева это расстояние или равно 0 (когда сам лист является помеченной вершиной), или условно минус бесконечности (когда лист не является помеченной вершиной), а для каждой внутренней вершины v distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1, где childi — дети вершины v.Теперь будем считать расстояния от каждой вершины до наиболее отдаленной от неё помеченной вершины вне её поддерева. Будем называть это расстояние distUp[v]. Для вычисления значений distUp[] мы опять-таки используем поиск в глубину. Для корня дерева distUp[r] условно равно минус бесконечности, а для любой другой вершины v есть два случая — или наиболее отдаленная от неё помеченная вершина находится в поддереве родителя p вершины v, или ещё \"дальше\", то есть путь к ней проходит через родителя p. В первом случае расстояние от v до такой вершины равно max(distDown[sibling1], ..., distDown[siblingK])+2, где siblingi — это братья (другие дети родителя) вершины v. Во втором случае оно равно distUp[p]+1. Таким образом, distUp[v] равен максимуму из этих двух величин. Надо заметить, что для обеспечения линейной работы этого поиска в глубину в первом случае нужно найти максимальное max1 и второе максимальное max2 среди значений distDown[sibling1], ..., distDown[siblingK]. Затем, если distDown[v] < max1, тогда max(distDown[sibling1], ..., distDown[siblingK])=max1, в противном же случае, при distDown[v] = max1, мы имеем max(distDown[sibling1], ..., distDown[siblingK])=max2.Имея значения distDown[] и distUp[], ответ найти просто: это количество таких v, что distDown[v] <= d && distUp[v] <= d.Для иллюстрации этой идеи можете посмотреть 4302127.337E - Дерево делителейДля начала покажем, что единственные вершины в оптимальном дереве делителей, которые могут не содержать одного из значений a[i], это листья и корень. Допустим, у нас есть некоторая внутренняя вершина, не являющася корнем, в которой записано число X, не равное ни одному из a[i]. Тогда можно исключить эту вершину из дерева, а её сыновей \"прицепить\" к её родителю без нарушения какого-либо из свойств дерева.Таким образом, наше дерево состоит из корня, прицепленных к нему или друг к другу в некотором порядке вершин с числами a[i] и идущих из них листьев, содержащих числа из их разложений на простые множители. Исключениями из этого наблюдения является ситуация, когда в корне записано одно из чисел a[i], и ситуация когда среди a[i] встречаются простые числа. Также заметим, что в общем случае количество листьев в дереве будет равнятся сумме показателей степеней простых чисел в разложении на простые множители тех a[i], которые являются детьми корня.Так как N <= 8, можно попытаться перебрать все возможные деревья, удовлетворяющие сделанным наблюдениям. Упорядочим числа a[i] по убыванию и рекурсивно будем выбирать для каждого из них, к какой из уже имеющихся вершин добавить сына с соответствующим числом. Понятно, что чтобы добавить число X к некоторой вершине v, произведение X и чисел в сыновьях v должно делить число в самой вершине v. Для первого из чисел a[i] у нас есть выбор — сделать его корнем дерева, или сделать сыном корня (в котором будет записана условная бесконечность, делящаяся на любые числа). Для каждого следующего числа выбор заключается в том, сделать его сыном корня (если таковой присутствует как отдельная от вершина) или вершины, содержащей одно из предыдущих чисел. В сумме мы рассматриваем O(N!) вариантов.Для иллюстрации этой идеи можете посмотреть 4302171.338D - Таблица НОДНаблюдение 1. Если последовательность a встречается в таблице G, то она обязательно должна встречаться в строке i = LCM(a[1], ..., a[k]). Докажем это утверждение. Понятно, что теоретически она может встречаться только в строках, номера которых кратны i, так как номер строки должен делиться на каждое из чисел a[index]. Рассмотрим некоторую строку с номером i*x, где x>1. Строки i и i*x отличаются только в таких элементах j, что i*x и j делятся на степень p^q некоторого простого числа, на которое не делится i (соответственно G(i*x, j) делится на p^q). Но ни один из a[index] на такое p^q делиться не может, потому что тогда бы и i делилось на p^q. Соответственно, если искомая подстрока находится в i*x-ой строке, то она не может содержать индекса j. Раз она может содержать только те индексы, где элементы в строках i и i*x совпадают, достаточно проверять лишь i-ую строку. Отсюда ясно, что если i > n, ответ задачи \"NO\".Наблюдение 2. Искомый индекс j должен удовлетворять следующую систему линейных уравнений по модулю: j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}Иными словами, j + l должно делиться на a[l+1] для каждого l=0..k-1.Согласно Китайской теореме об остатках, у такой системы есть решение тогда и только тогда, когда для каждой пары индексов x, y (0 <= x, y <= k-1) мы имеем -x = -y (mod GCD(a[x+1], a[y+1])). Положим L = LCM(a[1], ..., a[k]). Если у системы есть решение, тогда оно единственно в интервале [0, L), а все остальные решения конгруэнтны ему по модулю L. Допустим, мы вычислили минимальное неотрицательное j, удовлетворяющее данной системе. Тогда, если последовательность a встречается в таблице G, она обязательно будет начинаться с j-ого элемента строки i. Понятно, что теоретически она может начинаться с любого индекса вида j+x*L, x>=0, но i = L, поэтому G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j). Поэтому достаточно проверить, совпадают ли k последовательных элементов, начинающихся с j-ой позиции i-ой строки, с последовательностью a. Также понятно, что если j > m-k+1, то ответ задачи \"NO\".Наконец, рассмотрим как можно найти решение системы линейных уравнений по модулю (и заодно проверить её решаемость, так как предложенная ранее проверка в лоб будет работать слишком долго). Для этого можно использовать следующий вспомогательный метод, которой для данных значений r1, m1, r2, m2 находит минимальное число X такое, что X = r1 (mod m1) и X = r2 (mod m2), или определяет что его не существует. Пусть X = m1*x + r1, тогда мы имеем m1*x + r1 = r2 (mod m2). Это можно представить в виде Диофантового уравнения m1*x + m2*y = r2-r1, решение которого является делом техники. Наименьший неотрицательный x, если таковой существует, даёт нам искомое X = m1*x + r1. Теперь этот метод можно использовать, чтобы найти минимальное решение X1, удовлетворяющее первые два уравнения. Теперь можно считать, что у нас уже k-1 уравнение, в котором вместо двух первых есть новое уравнение j = X1 (mod LCM(a[1], a[2])), и повторить эту же процедуру снова. Используя этот метод k-1 раз, мы получим итоговое решение для всей системы.Заметим также, что предложенное решение не требует имплементации длинной арифметики:— Процесс подсчета LCM(a[1], ..., a[k]) можно реализовать так, чтобы при каждом умножении проверять, не станет ли результат больше n, а в таком случае сразу выводить \"NO\";— К моменту решения системы уравнений, нам уже известно что L <= n <= 10^12, поэтому все промежуточные модули также будут в этих пределах;— Расширенный алгоритм Эвклида находит решения в тех же пределах, что и входные числа, поэтому также будет оперировать числами до 10^12.Итоговая сложность алгоритма — O(k logn).338E - Оптимизировать!Оформление задачи представляет собой небольшой эксперимент, хотя я и не буду претендовать на абсолютную новизну такой идеи. Условие нужно понять из псевдокода очень медленного решения. Заключается оно в следующем: даны массивы A[1..N] и B[1..L] и число H. Нужно посчитать, сколько (непрерывных) подмассивов S массива A длины L имеют свойство — можно так перемешать элементы массива B, что каждая из сумм S[i]+B[i] (1<=i<=L) будет не меньше H.Понятно, что задачу для каждого отдельного подмассива можно решать за время O(NlogN), если упорядочить массив B, а для каждого подмассива S упорядочить его в обратном направлении и проверить что требуемое условие выполняется. Более общая идея решения, которую можно имплементировать с такой же асимптотической сложностью — для каждого из чисел B[i], нам нужно сопоставить ему наименьшее из чисел S[j] такое, что B[i]+S[j]>=H. Заметим, что числа B[i] можно обрабатывать в любом порядке. Также заметим, что S и B можно поменять местами, то есть искать наименьшую пару для каждого S[i] в массиве B. И последнее — если S и B упорядочены заранее, то обработка сегмента производится за O(N).При рассмотрении каждого подмассива по отдельности лучшей асимптотики не достичь, поэтому попробуем решать задачу для нескольких подмассивов одновременно. Допустим, что массив B уже упорядочен по возрастанию. Возьмем некоторое число X < L и рассмотрим некоторый подмассив A[i..i+X-1]. Давайте обработаем все числа из этого подмассива — то есть для каждого из них найдём наименьшее B[j], которое в сумме с ним не меньше H, и уберём элемент B[j] из массива B. Эту обработку можно выполнить за время O(N), если изначально иметь упорядоченный массив элементов A и соответствующих индексов: из такого массива мы можем получить элементы сегмента A[i..i+X-1] в порядке возрастания, а мы уже знаем, что имея их в таком виде и имея упорядоченный массив B, задачу можно решить за линейное время.Теперь мы можем найти ответ для каждого подмассива S длины L, левый край которого находится в интервале [i-Y, i], за время O(YlogY), где Y=L-X. Для этого просто возьмём те Y элементов, которые входят в S и не входят в A[i..i+X-1], и обработаем их на остатке чисел из массива B. Если для каждого из этих элементов нашлась пара, то подмассив S имеет нужное свойство, в противном случае нет. Более того, хотя для каждого отдельного сегмента нам обязательно нужно O(YlogY) времени, здесь также можно воспользоваться тем, что сегменты пересекаются и получить амортизированную сложность O(Y) на сегмент. Заметим, что для обработки остатка сегмента за время O(Y) нам нужно лишь иметь его элементы в упорядоченном состоянии. Для самого левого сегмента, который мы будем обрабатывать, честно упорядочим его элементы, а для каждого следующего (который отличается от предыдущего ровно в двух элементах) нужно лишь O(Y) операций, чтобы обновить упорядоченный массив элементов. Таким образом, мы получаем сложность O(YlogY + Y^2) для обработки всех Y сегментов в сумме, что даёт O(Y) на один сегмент в среднем.Вернемся к общей картине. Чтобы рассмотреть все подмассивы длины L, нам нужно использовать вышеуказанный алгоритм для каждого из сегментов A[Y..Y+X-1], A[2Y+1..2Y+X], A[3Y+2..3Y+X-1], .... Таким образом, мы O(N/Y) раз запускаем алгоритм со сложностью O(N+Y^2). Получается, что нам надо выбрать Y, минимизирующий N*N/Y + N*Y, откуда мы имеем Y=~sqrt(N). Итоговая сложность алгоритма получается O(Nsqrt(N)). Тем не менее, отдельно надо рассмотреть случай L < sqrt(N), потому что Y = L - X < L. Здесь задачу можно решать за время O(NL) подобной прошлому подходу идеей: упорядочив самый левый подмассив длины L, для получения упорядоченной версии каждого следующего требуется лишь O(L) операций.Имплементацию этой идеи вы можете увидеть в 4302344.P.S. Условие \"задачи\", которую решает Манао, на самом деле содержит текст одной грузинской сказки. Вы можете скопировать (почти) его отсюда и попробовать понять смысл переведенного текста :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 338 和字母"
          },
          "content_length": 16676
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 1",
          "code": "f[k], f[k+1], ..., f[k+n-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 2",
          "code": "f[k]=f[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 3",
          "code": "f[k+n-1]-f[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 4",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 5",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 6",
          "code": "h*W/w = w*c/d * W/w = W*d/c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 7",
          "code": "(высота экрана - новая высота картинки) / (высота экрана) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 8",
          "code": "w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 9",
          "code": "(W - W*b/a * c/d)/W = (ad-bc)/ad",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 10",
          "code": "(k*2+k)*2+m-2*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 11",
          "code": "((k*2+k)*2+k)*2+m-3*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 12",
          "code": "(2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 13",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 14",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 15",
          "code": "X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 16",
          "code": "max(0, m - (n - n mod k) / k * (k-1) - n mod k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 17",
          "code": "distDown[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 18",
          "code": "distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 19",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])+2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 20",
          "code": "distUp[p]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 21",
          "code": "distDown[sibling1], ..., distDown[siblingK]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 22",
          "code": "distDown[v] < max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 23",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 24",
          "code": "distDown[v] = max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 25",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 26",
          "code": "distDown[v] <= d && distUp[v] <= d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 27",
          "code": "i = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 28",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 29",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 30",
          "code": "x, y (0 <= x, y <= k-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 31",
          "code": "-x = -y (mod GCD(a[x+1], a[y+1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 32",
          "code": "L = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 33",
          "code": "j+x*L, x>=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 34",
          "code": "G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 35",
          "code": "r1, m1, r2, m2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 36",
          "code": "X = r1 (mod m1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 37",
          "code": "X = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 38",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 39",
          "code": "m1*x + r1 = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 40",
          "code": "m1*x + m2*y = r2-r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 41",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 42",
          "code": "j = X1 (mod LCM(a[1], a[2]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 43",
          "code": "LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 44",
          "code": "L <= n <= 10^12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 45",
          "code": "S[i]+B[i] (1<=i<=L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 46",
          "code": "B[i]+S[j]>=H",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 47",
          "code": "A[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 48",
          "code": "A[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 49",
          "code": "A[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 50",
          "code": "O(YlogY + Y^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 51",
          "code": "A[Y..Y+X-1], A[2Y+1..2Y+X], A[3Y+2..3Y+X-1], ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 52",
          "code": "N*N/Y + N*Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 53",
          "code": "O(Nsqrt(N))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 54",
          "code": "L < sqrt(N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 55",
          "code": "Y = L - X < L",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 56",
          "code": "distDown[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 57",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 58",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 59",
          "code": "dp[up_lsb][down_mask1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 60",
          "code": "dp[up_rest][down_mask2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 61",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 62",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 63",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Разбор задач - Codeforces - Code 64",
          "code": "X+(n/k)*(k-1)>=m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", 0);\n    long long m = opt<long long>(\"m\", -1); // default -1 indicates not set\n    long long k = opt<long long>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long N_MAX = 1000000000LL;\n\n    if (type == \"min\") {\n        /* Minimal edge case */\n        n = 2;\n        k = 2;\n        m = 0;\n    } else if (type == \"max\") {\n        /* Maximal edge case */\n        n = N_MAX;\n        k = 2;\n        m = n;\n    } else if (type == \"m0\") {\n        /* m = 0 */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        m = 0;\n        k = rnd.next(2LL, n);\n    } else if (type == \"mn\") {\n        /* m = n */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        m = n;\n        k = rnd.next(2LL, n);\n    } else if (type == \"k2\") {\n        /* k = 2 */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = 2;\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else if (type == \"kn\") {\n        /* k = n */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = n;\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else if (type == \"k_near_n\") {\n        /* k near n */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        long long k_min = max(2LL, n - 10);\n        k = rnd.next(k_min, n);\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else if (type == \"large_n_small_m\") {\n        /* Large n, small m */\n        n = N_MAX;\n        m = rnd.next(0LL, n / 10);\n        k = rnd.next(2LL, n);\n    } else if (type == \"small_n_large_m\") {\n        /* Small n, large m */\n        n = rnd.next(2LL, 1000LL);\n        m = n;\n        k = rnd.next(2LL, n);\n    } else if (type == \"random\") {\n        /* Random test case */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = rnd.next(2LL, n);\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else {\n        /* Default random */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = rnd.next(2LL, n);\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    }\n\n    /* Ensure constraints are satisfied */\n    n = max(2LL, min(n, N_MAX));\n    k = max(2LL, min(k, n));\n    m = max(0LL, min(m, n));\n\n    printf(\"%lld %lld %lld\\n\", n, m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", 0);\n    long long m = opt<long long>(\"m\", -1); // default -1 indicates not set\n    long long k = opt<long long>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long N_MAX = 1000000000LL;\n\n    if (type == \"min\") {\n        /* Minimal edge case */\n        n = 2;\n        k = 2;\n        m = 0;\n    } else if (type == \"max\") {\n        /* Maximal edge case */\n        n = N_MAX;\n        k = 2;\n        m = n;\n    } else if (type == \"m0\") {\n        /* m = 0 */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        m = 0;\n        k = rnd.next(2LL, n);\n    } else if (type == \"mn\") {\n        /* m = n */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        m = n;\n        k = rnd.next(2LL, n);\n    } else if (type == \"k2\") {\n        /* k = 2 */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = 2;\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else if (type == \"kn\") {\n        /* k = n */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = n;\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else if (type == \"k_near_n\") {\n        /* k near n */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        long long k_min = max(2LL, n - 10);\n        k = rnd.next(k_min, n);\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else if (type == \"large_n_small_m\") {\n        /* Large n, small m */\n        n = N_MAX;\n        m = rnd.next(0LL, n / 10);\n        k = rnd.next(2LL, n);\n    } else if (type == \"small_n_large_m\") {\n        /* Small n, large m */\n        n = rnd.next(2LL, 1000LL);\n        m = n;\n        k = rnd.next(2LL, n);\n    } else if (type == \"random\") {\n        /* Random test case */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = rnd.next(2LL, n);\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    } else {\n        /* Default random */\n        n = n == 0 ? rnd.next(2LL, N_MAX) : n;\n        k = rnd.next(2LL, n);\n        m = m == -1 ? rnd.next(0LL, n) : m;\n    }\n\n    /* Ensure constraints are satisfied */\n    n = max(2LL, min(n, N_MAX));\n    k = max(2LL, min(k, n));\n    m = max(0LL, min(m, n));\n\n    printf(\"%lld %lld %lld\\n\", n, m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type m0 -n 100\n./gen -type m0 -n 1000000\n./gen -type m0 -n 999999999\n\n./gen -type mn -n 10000\n./gen -type mn -n 1000000000\n\n./gen -type k2 -n 1000000\n./gen -type k2 -n 1000000000 -m 999999999\n\n./gen -type kn -n 1000\n./gen -type kn -n 1000000000\n\n./gen -type k_near_n -n 1000\n./gen -type k_near_n -n 1000000000\n\n./gen -type large_n_small_m\n./gen -type small_n_large_m\n\n./gen -type random -n 2 -m 1\n./gen -type random -n 10 -m 5\n./gen -type random -n 100 -m 50\n./gen -type random -n 1000\n./gen -type random -n 10000\n./gen -type random -n 100000\n./gen -type random -n 1000000\n./gen -type random -n 1000000000\n./gen -type random -n 1000000000 -m 0\n./gen -type random -n 1000000000 -m 1000000000\n\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:23.176384",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "338/B",
      "title": "B. Book of Evil",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m and d (1 ≤ m ≤ n ≤ 100000; 0 ≤ d ≤ n - 1). The second line contains m distinct space-separated integers p1, p2, ..., pm (1 ≤ pi ≤ n). Then n - 1 lines follow, each line describes a path made in the area. A path is described by a pair of space-separated integers ai and bi representing the ends of this path.",
      "output_spec": "OutputPrint a single number — the number of settlements that may contain the Book of Evil. It is possible that Manao received some controversial information and there is no settlement that may contain the Book. In such case, print 0.",
      "sample_tests": "ExamplesInputCopy6 2 31 21 52 33 44 55 6OutputCopy3",
      "description": "B. Book of Evil\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m and d (1 ≤ m ≤ n ≤ 100000; 0 ≤ d ≤ n - 1). The second line contains m distinct space-separated integers p1, p2, ..., pm (1 ≤ pi ≤ n). Then n - 1 lines follow, each line describes a path made in the area. A path is described by a pair of space-separated integers ai and bi representing the ends of this path.\n\nOutputPrint a single number — the number of settlements that may contain the Book of Evil. It is possible that Manao received some controversial information and there is no settlement that may contain the Book. In such case, print 0.\n\nInputCopy6 2 31 21 52 33 44 55 6OutputCopy3\n\nInputCopy6 2 31 21 52 33 44 55 6\n\nOutputCopy3\n\nNoteSample 1. The damage range of the Book of Evil equals 3 and its effects have been noticed in settlements 1 and 2. Thus, it can be in settlements 3, 4 or 5.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces",
          "content": "337A - PuzzlesFirst, let's sort the numbers f[i] in ascending order. Now assume that the smallest jigsaw puzzle which the teacher purchases consists of f[k] pieces. Obviously, she should buy the smallest n puzzles which are of size f[k] or greater to minimize the difference. These are the puzzles f[k], f[k+1], ..., f[k+n-1] (this is not correct when f[i] are not distinct and f[k]=f[k-1], but such cases can be skipped). The difference between the greatest and the least size of the puzzles in such set is f[k+n-1]-f[k].To choose the optimal f[k], we can test every k between 1 and m-n and pick the one producing the least difference. The full algorithm is as follows: read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n best = min(best, f[k+n-1] - f[k])\nprint best337B - Routine ProblemSuppose that the width and height of the screen are W and H correspondingly. Since W:H = a:b, we have H=W*b/a. Similarly, the width and height of the film frame w and h are related as h=w*d/c. Imagine that Manao stretches/constricts the frame until it fits the screen horizontally or vertically, whichever happens first. There are three cases to consider: the horizontal to vertical ratio of the screen is less, equal or more than the corresponding ratio of the frame.In the first case (a/b < c/d) the stretching process ends when the frame reaches the same width as the screen. That is, the frame will enlarge in W/w times and its new width will be W. Thus, its new height is h*W/w = w*c/d * W/w = W*d/c. We are interested in the ratio of unoccupied portion of the screen to its full size, which is (screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc.In the second case (a/b > c/d) the process ends when the frame reaches the same height as the screen. Its height will become H and its width will become w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d. The unoccupied portion of the screen's horizontal is (W - W*b/a * c/d)/W = (ad-bc)/ad.In the third case, the frame fills the screen entirely and the answer will be 0.All that's left is to print the answer as an irreducible fraction. We need to find the greatest common divisor of its nominator and denominator for this. It can be done using Euclidean algorithm or just through trial division by every number from 1 to q. Since q is no more than a product of two numbers from the input and these numbers are constrained by 1000, we need to try at most million numbers in the worst case.337C - QuizAssume that Manao has doubled his score (i.e. gave k consecutive correct answers) exactly X times. Then the least possible score is obtained when this doublings happen in the beginning of the game, i.e., when he answers the first X*k questions and never manages to answer k consecutive questions after that. The correctness of this statement follows from the following: for any other scenario with X doublings, all of these doublings can be moved into the beginning and the total score will not increase. Hence, for X=1 Manao's minimum score is k*2+m-k: he answers k consecutive questions, the score doubles, then he answers m-k questions. For X=2 the minimum possible score is (k*2+k)*2+m-2*k, for X=3 — ((k*2+k)*2+k)*2+m-3*k. For the general case, a formula (2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k is derived.The abovementioned observation shows that the minimum score grows monotonically when X is increased, so all we need is to find the minimum feasible X. It should satisfy the inequalities X*k <= n and X + (n - n mod k) / k * (k-1) + n mod k >= m. More on the second inequality: Manao answered the first X*k questions, thus there are n-X*k left. Now he can answer at most k-1 question from each k questions. If k divides n-X*k (which is the same as k divides n), the inequality becomes X*k + (n-X*k) / k * (k-1) >= m, but the remainder complicates it a bit: X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m. This formula can be simplified to the one written earlier. So, the minimum X is equal to max(0, m - (n - n mod k) / k * (k-1) - n mod k). You'll need exponentiation by squaring to compute the score corresponding to this value of X. Thus, the overall complexity of this solution is O(log(n)).337D - Book of EvilObviously, in graph theory language our problem is: given a tree with n vertices, m of which are marked, find the number of vertices which are at most distance d apart from each of the marked vertices.Let us hang the tree by some vertex r, that is, assume that it is a rooted tree with root in vertex r. Let us also rephrase the condition imposed on sought vertices: we need to count such vertices v that the maximum distance from v to a marked vertex is at most d.For any inner vertex v, the marked vertex which is the farthest from it is either in the subtree of v or outside it — in the latter case the path from v to the farthest marked vertex traverses the parent of v. Using this observation, we can recompute the distances to the farthest marked vertices when transiting from a vertex to its child.First, we will compute the distance from every vertex v to the farthest marked vertex within the subtree of v. Let us call this distance distDown[v]. The values of distDown[] can be computed in a single depth-first search: for each leaf of the tree this distance is either 0 (when the leaf is marked) or nominal negative infinity (when the leaf is not marked), and for each inner vertex v distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1, where childi are the children of v.Now we will compute the distances from each vertex to the farthest marked vertex outside its subtree. Let's denote this distance with distUp[v]. We will use DFS again to compute values of distUp[]. For the root, distUp[r] is equal to nominal negative infinity, and for any other vertex v there are two cases: either the farthest marked vertex is located in the subtree of v-s parent p, or it is even \"farther\", i.e., the path to it traverses vertex p-s parent. In the first case, the distance from v to such vertex is equal to max(distDown[sibling1], ..., distDown[siblingK])+2, where siblingi are the brothers (other children of the parent) of vertex v. In the second case, it is equal to distUp[p]+1. Thus, distUp[v] is equal to the maximum of these two values. Note that you need to be clever to perform the computations in the first case in overall linear time. For this, you can find the maximum max1 and second maximum max2 of values distDown[sibling1], ..., distDown[siblingK]. After that, when distDown[v] < max1, we have max(distDown[sibling1], ..., distDown[siblingK])=max1, otherwise we have distDown[v] = max1 and max(distDown[sibling1], ..., distDown[siblingK])=max2.After computing distDown[] и distUp[], it is easy to derive the answers: it is the count of such vertices v that distDown[v] <= d && distUp[v] <= d.You can check 4302127 for an implementation of the described approach.337E - Divisor TreeLet us first show that in an optimal divisor tree only the root or a leaf can hold a value other than one of a[i]. Suppose that we have an inner vertex different from the root which holds a number X not equal to any of a[i]. Then we can exclude this vertex from the tree and tie its children to its parent without violating any of the tree's properties.Hence, our tree consists of the root, vertices with numbers a[i] tied to each other or to the root, and leaves, which are tied to vertices with numbers a[i] and contain these numbers' prime factorizations. The exception is the case when one of a[i] is written in root itself, and the case when some a[i]-s are prime themselves. Also note that in general case it's easy to count how many leaves the tree will have. This count is equal to the sum of exponents of primes in prime factorizations of those a[i]-s which are the children of the root.Since N <= 8, we can build all divisor trees which satisfy the observations we made. Let's sort numbers a[i] in descending order and recursively choose a parent for each of them from the vertices already present in the tree. Of course, tying a number X to some vertex v is only possible if the product of X and the numbers in children of v divides the number in v itself. For a[1], we have a choice — we can make it the root of the tree or a child of the root (in this case the root will hold a nominal infinity which is divisible by any number). For every next a[i], the choice is whether to tie it to the root or a vertex containing one of the previous numbers. Therefore, we only consider O(N!) trees in total.You can check 4302171 for an implementation of this idea.338D - GCD TableObservation 1. If the sequence a occurs in table G, then it should occur in row i = LCM(a[1], ..., a[k]). The proof follows. It is clear that theoretically it may only occur in rows with numbers which are multiple to i, since the row number should divide by each of a[index]. Consider some a row with number i*x, where x>1. The rows i and i*x differ only in such elements j that i*x and j both divide by some p^q (where p is prime) which does not divide i (hence, G(i*x, j) is divisible by p^q). But none of the a[index] may divide by such p^q, since then i would be also divisible by it. Therefore, if a occurs in row i*x, then it does not intersect with index j. Since it can only reside on indices where i and i*x coincide, checking only the i-th row is enough. It also clear that if i > n, the answer is NO.Observation 2. The sought index j should satisfy the following modular linear equations system: j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}In other words, j + l must divide by a[l+1] for each l=0..k-1.According to Chinese Remainder Theorem, such a system has a solution iff for each pair of indices x, y (0 <= x, y <= k-1) we have -x = -y (mod GCD(a[x+1], a[y+1])). Let's denote L = LCM(a[1], ..., a[k]). If the system has a solution, then it is singular on interval [0, L) and all the other solutions are congruent to it modulo L. Suppose that we have found the minimum non-negative j which satisfies the given system. Then, if a occurs in G, it will start from the j-th element of the i-th row. Theoretically, it may begin at any index of form j+x*L, x>=0, but since i = L, we have G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j). So it is sufficient to check whether the k consecutive elements which begin at index j in row i coincide with sequence a. It is also clear that when j > m-k+1, the answer is NO.Finally, let's consider how to solve a system of modular linear equations. We can use an auxiliary method which, given r1, m1, r2, m2, finds minimum X such that X = r1 (mod m1) and X = r2 (mod m2), or determines that such number does not exist. Let X = m1*x + r1, then we have m1*x + r1 = r2 (mod m2). This can be represented as a Diophantine equation m1*x + m2*y = r2-r1 and solved using Extended Euclidean Algorithm. The least non-negative x, if it exists, yields the sought X = m1*x + r1. Now this method can be used to find the minimum X1 which satisfies the first two equations. After that, we can say that we have a system with k-1 equation, where the first two old equations are replaced with a new j = X1 (mod LCM(a[1], a[2])), and repeat the same procedure again. After using this method k-1 times, we obtain the solution to the whole system.Also note that the proposed solution does not require long arithmetics: — The computation of LCM(a[1], ..., a[k]) can be implemented with a check before each multiplication: if the result will become larger than n, the answer is NO; — When it comes to solving the system of equations, we already know that L <= n <= 10^12, thus all the intermediate moduli will also obide to this constraint; — The Extended Euclidean Algorithm can find a solution in the same bounds as its inputs, so it will also use numbers up to 10^12.The overall complexity of the algorithm is O(k logn).338E - Optimize!Decyphering Manao's pseudocode, we unearth the following problem: you are given arrays a[1..n] and b[1..len] and a number h. Consider each subarray of a of length L. Let us call it s. Count how many of them have the property that the elements of b can be shuffled in such a way that each sum s[i]+b[i] (1<=i<=L) is at least h.First, let's solve a problem for one subarray. That is, we need to determine whether the elements of two arrays s and b can be matched in such a way that each sum is h or more. We can do the following: for each element of s, find the least element of b such that the two's sum is at least h, and erase the corresponding element from b. If we managed to pair each of the elements from s, then the arrays hold the property. Note that the elements of s can be processed in any order. If both s and b are sorted, then the idea described can be implemented in linear time.We can not achieve better complexity when considering each subarray separately, so we will try to solve the problem for several subarrays at the same time. Suppose that b is already sorted. We choose some X < len and consider a subarray a[i..i+X-1]. Let's process all the numbers from this subarray, i.e., for each of them find the least b[j] which pairs up with this number and erase it from b. The whole processing can be done in time O(n) if we have a sorted version of a and the corresponding indices computed beforehand.Now we can find the answer for every subarray s of length len which begins in segment [i-Y, i] using O(YlogY) operations, where Y=len-X. For this, we just take the Y elements which are in s but not in a[i..i+X-1] and process them against the numbers left in b. If each of them has been paired, then subarray s holds the required property, otherwise it does not. Moreover, since the subarrays we consider are overlapping, we can optimize even further and obtain amortized O(Y) complexity per subarray. To understand this, note that for processing a subarray in O(Y) time we only need to obtain its sorted version (to be more specific, the sorted version of the portion which does not overlap with a[i..i+X-1]). For the leftmost subarray we consider, we can sort its elements in usual way. For every next subarray (which differs from its predecessor in exactly two elements) we only need O(Y) operations to obtain its sorted version by updating the information from the previous subarray. Thus we have complexity O(YlogY + Y^2) of processing Y segments in total, which gives O(Y) per segment on average.Now let us take a look at the full picture. To process all subarrays of length len, we need to use the method given above for each of the segments a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], .... Therefore, we have O(N/Y) iterations of algorithm with comlexity O(N+Y^2). We need to find a value of Y that minimizes N*N/Y + N*Y, which is Y=~sqrt(N). The overall complexity is O(Nsqrt(N)). However, we need to consider the case len < sqrt(N) separately, since then Y = len - X < len. In this case, the problem can be solved in time O(N*len) with ideas similar to those described above.You can check the implementation of this idea in 4302344.P.S. The statement of the \"problem\" that Manao is solving actually contains a Georgian fairy tale. You can copy almost the same text from here and try to guess what he tale is about :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 338 和字母"
          },
          "content_length": 15337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 1",
          "code": "f[k], f[k+1], ..., f[k+n-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 2",
          "code": "f[k]=f[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 3",
          "code": "f[k+n-1]-f[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 4",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 5",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 6",
          "code": "h*W/w = w*c/d * W/w = W*d/c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 7",
          "code": "(screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 8",
          "code": "w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 9",
          "code": "(W - W*b/a * c/d)/W = (ad-bc)/ad",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 10",
          "code": "(k*2+k)*2+m-2*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 11",
          "code": "((k*2+k)*2+k)*2+m-3*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 12",
          "code": "(2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 13",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 14",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 15",
          "code": "X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 16",
          "code": "max(0, m - (n - n mod k) / k * (k-1) - n mod k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 17",
          "code": "distDown[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 18",
          "code": "distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 19",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])+2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 20",
          "code": "distUp[p]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 21",
          "code": "distDown[sibling1], ..., distDown[siblingK]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 22",
          "code": "distDown[v] < max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 23",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 24",
          "code": "distDown[v] = max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 25",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 26",
          "code": "distDown[v] <= d && distUp[v] <= d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 27",
          "code": "i = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 28",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 29",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 30",
          "code": "x, y (0 <= x, y <= k-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 31",
          "code": "-x = -y (mod GCD(a[x+1], a[y+1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 32",
          "code": "L = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 33",
          "code": "j+x*L, x>=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 34",
          "code": "G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 35",
          "code": "r1, m1, r2, m2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 36",
          "code": "X = r1 (mod m1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 37",
          "code": "X = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 38",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 39",
          "code": "m1*x + r1 = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 40",
          "code": "m1*x + m2*y = r2-r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 41",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 42",
          "code": "j = X1 (mod LCM(a[1], a[2]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 43",
          "code": "LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 44",
          "code": "L <= n <= 10^12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 45",
          "code": "s[i]+b[i] (1<=i<=L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 46",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 47",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 48",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 49",
          "code": "O(YlogY + Y^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 50",
          "code": "a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 51",
          "code": "N*N/Y + N*Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 52",
          "code": "O(Nsqrt(N))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 53",
          "code": "len < sqrt(N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 54",
          "code": "Y = len - X < len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 55",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 56",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 57",
          "code": "dp[up_lsb][down_mask1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 58",
          "code": "dp[up_rest][down_mask2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 59",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 60",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 61",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 62",
          "code": "X+(n/k)*(k-1)>=m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent;\n    int components;\n\npublic:\n    DSU(int n) {\n        parent.resize(n + 1); // nodes are from 1 to n\n        for (int i = 1; i <= n; i++) parent[i] = i;\n        components = n;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int x_root = find(x);\n        int y_root = find(y);\n        if (x_root != y_root) {\n            parent[y_root] = x_root;\n            components--;\n            return true;\n        }\n        return false; // already connected; would form a cycle\n    }\n\n    int getComponents() {\n        return components;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, n - 1, \"d\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 1, n, \"p_i\");\n    inf.readEoln();\n\n    // Check that p_i are distinct\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == m, \"p_i are not distinct\");\n\n    DSU dsu(n);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge can't connect a node to itself\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n        auto edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between the same nodes\");\n        edgeSet.insert(edge);\n\n        if (!dsu.unite(a, b)) {\n            ensuref(false, \"Graph contains a cycle\");\n        }\n    }\n    ensuref(dsu.getComponents() == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent;\n    int components;\n\npublic:\n    DSU(int n) {\n        parent.resize(n + 1); // nodes are from 1 to n\n        for (int i = 1; i <= n; i++) parent[i] = i;\n        components = n;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int x_root = find(x);\n        int y_root = find(y);\n        if (x_root != y_root) {\n            parent[y_root] = x_root;\n            components--;\n            return true;\n        }\n        return false; // already connected; would form a cycle\n    }\n\n    int getComponents() {\n        return components;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, n - 1, \"d\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 1, n, \"p_i\");\n    inf.readEoln();\n\n    // Check that p_i are distinct\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == m, \"p_i are not distinct\");\n\n    DSU dsu(n);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge can't connect a node to itself\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n        auto edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between the same nodes\");\n        edgeSet.insert(edge);\n\n        if (!dsu.unite(a, b)) {\n            ensuref(false, \"Graph contains a cycle\");\n        }\n    }\n    ensuref(dsu.getComponents() == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent;\n    int components;\n\npublic:\n    DSU(int n) {\n        parent.resize(n + 1); // nodes are from 1 to n\n        for (int i = 1; i <= n; i++) parent[i] = i;\n        components = n;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int x_root = find(x);\n        int y_root = find(y);\n        if (x_root != y_root) {\n            parent[y_root] = x_root;\n            components--;\n            return true;\n        }\n        return false; // already connected; would form a cycle\n    }\n\n    int getComponents() {\n        return components;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, n - 1, \"d\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 1, n, \"p_i\");\n    inf.readEoln();\n\n    // Check that p_i are distinct\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == m, \"p_i are not distinct\");\n\n    DSU dsu(n);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge can't connect a node to itself\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n        auto edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between the same nodes\");\n        edgeSet.insert(edge);\n\n        if (!dsu.unite(a, b)) {\n            ensuref(false, \"Graph contains a cycle\");\n        }\n    }\n    ensuref(dsu.getComponents() == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid add_edge(vector<pair<int, int>>& edges, vector<int>& deg, int u, int v) {\n    edges.emplace_back(u, v);\n    deg[u]++;\n    deg[v]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string pi_type = opt<string>(\"pi_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> deg(n + 1, 0);\n\n    // Generate the tree according to tree_type\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            add_edge(edges, deg, i, i + 1);\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            add_edge(edges, deg, 1, i);\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            add_edge(edges, deg, parent, i);\n        }\n    } else {\n        // You can add other tree types here if needed\n    }\n\n    // Generate the pi_set according to pi_type\n    set<int> pi_set;\n    if (pi_type == \"random\") {\n        while ((int)pi_set.size() < m) {\n            int x = rnd.next(1, n);\n            pi_set.insert(x);\n        }\n    } else if (pi_type == \"root\") {\n        pi_set.insert(1);\n        for (int i = 2; i <= n && (int)pi_set.size() < m; ++i) {\n            pi_set.insert(i);\n        }\n    } else if (pi_type == \"leaves\") {\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (deg[i] == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if ((int)leaves.size() >= m) {\n            shuffle(leaves.begin(), leaves.end());\n            for (int i = 0; i < m; ++i) {\n                pi_set.insert(leaves[i]);\n            }\n        } else {\n            for (int x : leaves)\n                pi_set.insert(x);\n            for (int i = 1; i <= n && (int)pi_set.size() < m; ++i)\n                pi_set.insert(i);\n        }\n    } else {\n        // You can add other pi_types here if needed\n    }\n\n    // Ensure pi_set has size m\n    while ((int)pi_set.size() < m) {\n        int x = rnd.next(1, n);\n        pi_set.insert(x);\n    }\n\n    // Output n, m, d\n    printf(\"%d %d %d\\n\", n, m, d);\n\n    // Output pi's\n    vector<int> pi_list(pi_set.begin(), pi_set.end());\n    shuffle(pi_list.begin(), pi_list.end());\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", pi_list[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid add_edge(vector<pair<int, int>>& edges, vector<int>& deg, int u, int v) {\n    edges.emplace_back(u, v);\n    deg[u]++;\n    deg[v]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string pi_type = opt<string>(\"pi_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> deg(n + 1, 0);\n\n    // Generate the tree according to tree_type\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            add_edge(edges, deg, i, i + 1);\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            add_edge(edges, deg, 1, i);\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            add_edge(edges, deg, parent, i);\n        }\n    } else {\n        // You can add other tree types here if needed\n    }\n\n    // Generate the pi_set according to pi_type\n    set<int> pi_set;\n    if (pi_type == \"random\") {\n        while ((int)pi_set.size() < m) {\n            int x = rnd.next(1, n);\n            pi_set.insert(x);\n        }\n    } else if (pi_type == \"root\") {\n        pi_set.insert(1);\n        for (int i = 2; i <= n && (int)pi_set.size() < m; ++i) {\n            pi_set.insert(i);\n        }\n    } else if (pi_type == \"leaves\") {\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (deg[i] == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if ((int)leaves.size() >= m) {\n            shuffle(leaves.begin(), leaves.end());\n            for (int i = 0; i < m; ++i) {\n                pi_set.insert(leaves[i]);\n            }\n        } else {\n            for (int x : leaves)\n                pi_set.insert(x);\n            for (int i = 1; i <= n && (int)pi_set.size() < m; ++i)\n                pi_set.insert(i);\n        }\n    } else {\n        // You can add other pi_types here if needed\n    }\n\n    // Ensure pi_set has size m\n    while ((int)pi_set.size() < m) {\n        int x = rnd.next(1, n);\n        pi_set.insert(x);\n    }\n\n    // Output n, m, d\n    printf(\"%d %d %d\\n\", n, m, d);\n\n    // Output pi's\n    vector<int> pi_list(pi_set.begin(), pi_set.end());\n    shuffle(pi_list.begin(), pi_list.end());\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", pi_list[i], i + 1 == m ? '\\n' : ' ');\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -m 1 -d 0 -tree_type chain -pi_type random\n./gen -n 2 -m 1 -d 1 -tree_type chain -pi_type root\n./gen -n 2 -m 2 -d 0 -tree_type star -pi_type leaves\n\n# Medium n, various types\n./gen -n 10 -m 5 -d 3 -tree_type chain -pi_type random\n./gen -n 10 -m 2 -d 5 -tree_type star -pi_type leaves\n./gen -n 10 -m 3 -d 2 -tree_type random -pi_type root\n\n# Edge cases for d\n./gen -n 100 -m 10 -d 0 -tree_type star -pi_type random\n./gen -n 100 -m 10 -d 99 -tree_type chain -pi_type leaves\n./gen -n 100 -m 10 -d 50 -tree_type random -pi_type random\n\n# Large n, small m\n./gen -n 100000 -m 1 -d 0 -tree_type random -pi_type root\n./gen -n 100000 -m 1 -d 99999 -tree_type chain -pi_type leaves\n\n# Large n, large m\n./gen -n 100000 -m 100000 -d 0 -tree_type star -pi_type leaves\n./gen -n 100000 -m 100000 -d 99999 -tree_type chain -pi_type random\n\n# Various tree_types\n./gen -n 100000 -m 50000 -d 50000 -tree_type chain -pi_type random\n./gen -n 100000 -m 50000 -d 1 -tree_type star -pi_type random\n./gen -n 100000 -m 50000 -d 10000 -tree_type random -pi_type random\n\n# Different pi_types\n./gen -n 50000 -m 10000 -d 1000 -tree_type random -pi_type root\n./gen -n 50000 -m 10000 -d 1000 -tree_type random -pi_type leaves\n./gen -n 50000 -m 10000 -d 1000 -tree_type random -pi_type random\n\n# Small m\n./gen -n 100000 -m 1 -d 0 -tree_type random -pi_type random\n./gen -n 100000 -m 1 -d 0 -tree_type chain -pi_type leaves\n\n# Maximum m\n./gen -n 100000 -m 100000 -d 0 -tree_type random -pi_type random\n\n# Mixed cases\n./gen -n 99999 -m 1 -d 0 -tree_type chain -pi_type random\n./gen -n 100000 -m 100 -d 1000 -tree_type random -pi_type random\n./gen -n 100000 -m 25000 -d 25000 -tree_type random -pi_type random\n\n# Edge cases for m\n./gen -n 100000 -m 2 -d 50000 -tree_type chain -pi_type random\n./gen -n 100000 -m 99999 -d 1 -tree_type star -pi_type random\n\n# Edge cases for n\n./gen -n 1 -m 1 -d 0 -tree_type star -pi_type root\n\n# Edge cases for d\n./gen -n 100000 -m 1000 -d 0 -tree_type random -pi_type root\n./gen -n 100000 -m 1000 -d 100000 -tree_type random -pi_type random\n\n# Additional test cases\n./gen -n 50000 -m 50000 -d 0 -tree_type star -pi_type leaves\n./gen -n 50000 -m 1 -d 49999 -tree_type chain -pi_type root\n./gen -n 50000 -m 25000 -d 25000 -tree_type chain -pi_type random\n./gen -n 50000 -m 25000 -d 25000 -tree_type random -pi_type random\n./gen -n 100000 -m 50000 -d 0 -tree_type star -pi_type root\n./gen -n 100000 -m 50000 -d 100000 -tree_type random -pi_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:24.979701",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "338/C",
      "title": "C. Divisor Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 8). The second line contains n distinct space-separated integers ai (2 ≤ ai ≤ 1012).",
      "output_spec": "OutputPrint a single integer — the minimum number of vertices in the divisor tree that contains each of the numbers ai.",
      "sample_tests": "ExamplesInputCopy26 10OutputCopy7InputCopy46 72 8 4OutputCopy12InputCopy17OutputCopy1",
      "description": "C. Divisor Tree\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 8). The second line contains n distinct space-separated integers ai (2 ≤ ai ≤ 1012).\n\nOutputPrint a single integer — the minimum number of vertices in the divisor tree that contains each of the numbers ai.\n\nInputCopy26 10OutputCopy7InputCopy46 72 8 4OutputCopy12InputCopy17OutputCopy1\n\nInputCopy26 10\n\nOutputCopy7\n\nInputCopy46 72 8 4\n\nOutputCopy12\n\nInputCopy17\n\nOutputCopy1\n\nNoteSample 1. The smallest divisor tree looks this way: Sample 2. In this case you can build the following divisor tree: Sample 3. Note that the tree can consist of a single vertex.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces",
          "content": "337A - PuzzlesFirst, let's sort the numbers f[i] in ascending order. Now assume that the smallest jigsaw puzzle which the teacher purchases consists of f[k] pieces. Obviously, she should buy the smallest n puzzles which are of size f[k] or greater to minimize the difference. These are the puzzles f[k], f[k+1], ..., f[k+n-1] (this is not correct when f[i] are not distinct and f[k]=f[k-1], but such cases can be skipped). The difference between the greatest and the least size of the puzzles in such set is f[k+n-1]-f[k].To choose the optimal f[k], we can test every k between 1 and m-n and pick the one producing the least difference. The full algorithm is as follows: read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n best = min(best, f[k+n-1] - f[k])\nprint best337B - Routine ProblemSuppose that the width and height of the screen are W and H correspondingly. Since W:H = a:b, we have H=W*b/a. Similarly, the width and height of the film frame w and h are related as h=w*d/c. Imagine that Manao stretches/constricts the frame until it fits the screen horizontally or vertically, whichever happens first. There are three cases to consider: the horizontal to vertical ratio of the screen is less, equal or more than the corresponding ratio of the frame.In the first case (a/b < c/d) the stretching process ends when the frame reaches the same width as the screen. That is, the frame will enlarge in W/w times and its new width will be W. Thus, its new height is h*W/w = w*c/d * W/w = W*d/c. We are interested in the ratio of unoccupied portion of the screen to its full size, which is (screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc.In the second case (a/b > c/d) the process ends when the frame reaches the same height as the screen. Its height will become H and its width will become w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d. The unoccupied portion of the screen's horizontal is (W - W*b/a * c/d)/W = (ad-bc)/ad.In the third case, the frame fills the screen entirely and the answer will be 0.All that's left is to print the answer as an irreducible fraction. We need to find the greatest common divisor of its nominator and denominator for this. It can be done using Euclidean algorithm or just through trial division by every number from 1 to q. Since q is no more than a product of two numbers from the input and these numbers are constrained by 1000, we need to try at most million numbers in the worst case.337C - QuizAssume that Manao has doubled his score (i.e. gave k consecutive correct answers) exactly X times. Then the least possible score is obtained when this doublings happen in the beginning of the game, i.e., when he answers the first X*k questions and never manages to answer k consecutive questions after that. The correctness of this statement follows from the following: for any other scenario with X doublings, all of these doublings can be moved into the beginning and the total score will not increase. Hence, for X=1 Manao's minimum score is k*2+m-k: he answers k consecutive questions, the score doubles, then he answers m-k questions. For X=2 the minimum possible score is (k*2+k)*2+m-2*k, for X=3 — ((k*2+k)*2+k)*2+m-3*k. For the general case, a formula (2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k is derived.The abovementioned observation shows that the minimum score grows monotonically when X is increased, so all we need is to find the minimum feasible X. It should satisfy the inequalities X*k <= n and X + (n - n mod k) / k * (k-1) + n mod k >= m. More on the second inequality: Manao answered the first X*k questions, thus there are n-X*k left. Now he can answer at most k-1 question from each k questions. If k divides n-X*k (which is the same as k divides n), the inequality becomes X*k + (n-X*k) / k * (k-1) >= m, but the remainder complicates it a bit: X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m. This formula can be simplified to the one written earlier. So, the minimum X is equal to max(0, m - (n - n mod k) / k * (k-1) - n mod k). You'll need exponentiation by squaring to compute the score corresponding to this value of X. Thus, the overall complexity of this solution is O(log(n)).337D - Book of EvilObviously, in graph theory language our problem is: given a tree with n vertices, m of which are marked, find the number of vertices which are at most distance d apart from each of the marked vertices.Let us hang the tree by some vertex r, that is, assume that it is a rooted tree with root in vertex r. Let us also rephrase the condition imposed on sought vertices: we need to count such vertices v that the maximum distance from v to a marked vertex is at most d.For any inner vertex v, the marked vertex which is the farthest from it is either in the subtree of v or outside it — in the latter case the path from v to the farthest marked vertex traverses the parent of v. Using this observation, we can recompute the distances to the farthest marked vertices when transiting from a vertex to its child.First, we will compute the distance from every vertex v to the farthest marked vertex within the subtree of v. Let us call this distance distDown[v]. The values of distDown[] can be computed in a single depth-first search: for each leaf of the tree this distance is either 0 (when the leaf is marked) or nominal negative infinity (when the leaf is not marked), and for each inner vertex v distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1, where childi are the children of v.Now we will compute the distances from each vertex to the farthest marked vertex outside its subtree. Let's denote this distance with distUp[v]. We will use DFS again to compute values of distUp[]. For the root, distUp[r] is equal to nominal negative infinity, and for any other vertex v there are two cases: either the farthest marked vertex is located in the subtree of v-s parent p, or it is even \"farther\", i.e., the path to it traverses vertex p-s parent. In the first case, the distance from v to such vertex is equal to max(distDown[sibling1], ..., distDown[siblingK])+2, where siblingi are the brothers (other children of the parent) of vertex v. In the second case, it is equal to distUp[p]+1. Thus, distUp[v] is equal to the maximum of these two values. Note that you need to be clever to perform the computations in the first case in overall linear time. For this, you can find the maximum max1 and second maximum max2 of values distDown[sibling1], ..., distDown[siblingK]. After that, when distDown[v] < max1, we have max(distDown[sibling1], ..., distDown[siblingK])=max1, otherwise we have distDown[v] = max1 and max(distDown[sibling1], ..., distDown[siblingK])=max2.After computing distDown[] и distUp[], it is easy to derive the answers: it is the count of such vertices v that distDown[v] <= d && distUp[v] <= d.You can check 4302127 for an implementation of the described approach.337E - Divisor TreeLet us first show that in an optimal divisor tree only the root or a leaf can hold a value other than one of a[i]. Suppose that we have an inner vertex different from the root which holds a number X not equal to any of a[i]. Then we can exclude this vertex from the tree and tie its children to its parent without violating any of the tree's properties.Hence, our tree consists of the root, vertices with numbers a[i] tied to each other or to the root, and leaves, which are tied to vertices with numbers a[i] and contain these numbers' prime factorizations. The exception is the case when one of a[i] is written in root itself, and the case when some a[i]-s are prime themselves. Also note that in general case it's easy to count how many leaves the tree will have. This count is equal to the sum of exponents of primes in prime factorizations of those a[i]-s which are the children of the root.Since N <= 8, we can build all divisor trees which satisfy the observations we made. Let's sort numbers a[i] in descending order and recursively choose a parent for each of them from the vertices already present in the tree. Of course, tying a number X to some vertex v is only possible if the product of X and the numbers in children of v divides the number in v itself. For a[1], we have a choice — we can make it the root of the tree or a child of the root (in this case the root will hold a nominal infinity which is divisible by any number). For every next a[i], the choice is whether to tie it to the root or a vertex containing one of the previous numbers. Therefore, we only consider O(N!) trees in total.You can check 4302171 for an implementation of this idea.338D - GCD TableObservation 1. If the sequence a occurs in table G, then it should occur in row i = LCM(a[1], ..., a[k]). The proof follows. It is clear that theoretically it may only occur in rows with numbers which are multiple to i, since the row number should divide by each of a[index]. Consider some a row with number i*x, where x>1. The rows i and i*x differ only in such elements j that i*x and j both divide by some p^q (where p is prime) which does not divide i (hence, G(i*x, j) is divisible by p^q). But none of the a[index] may divide by such p^q, since then i would be also divisible by it. Therefore, if a occurs in row i*x, then it does not intersect with index j. Since it can only reside on indices where i and i*x coincide, checking only the i-th row is enough. It also clear that if i > n, the answer is NO.Observation 2. The sought index j should satisfy the following modular linear equations system: j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}In other words, j + l must divide by a[l+1] for each l=0..k-1.According to Chinese Remainder Theorem, such a system has a solution iff for each pair of indices x, y (0 <= x, y <= k-1) we have -x = -y (mod GCD(a[x+1], a[y+1])). Let's denote L = LCM(a[1], ..., a[k]). If the system has a solution, then it is singular on interval [0, L) and all the other solutions are congruent to it modulo L. Suppose that we have found the minimum non-negative j which satisfies the given system. Then, if a occurs in G, it will start from the j-th element of the i-th row. Theoretically, it may begin at any index of form j+x*L, x>=0, but since i = L, we have G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j). So it is sufficient to check whether the k consecutive elements which begin at index j in row i coincide with sequence a. It is also clear that when j > m-k+1, the answer is NO.Finally, let's consider how to solve a system of modular linear equations. We can use an auxiliary method which, given r1, m1, r2, m2, finds minimum X such that X = r1 (mod m1) and X = r2 (mod m2), or determines that such number does not exist. Let X = m1*x + r1, then we have m1*x + r1 = r2 (mod m2). This can be represented as a Diophantine equation m1*x + m2*y = r2-r1 and solved using Extended Euclidean Algorithm. The least non-negative x, if it exists, yields the sought X = m1*x + r1. Now this method can be used to find the minimum X1 which satisfies the first two equations. After that, we can say that we have a system with k-1 equation, where the first two old equations are replaced with a new j = X1 (mod LCM(a[1], a[2])), and repeat the same procedure again. After using this method k-1 times, we obtain the solution to the whole system.Also note that the proposed solution does not require long arithmetics: — The computation of LCM(a[1], ..., a[k]) can be implemented with a check before each multiplication: if the result will become larger than n, the answer is NO; — When it comes to solving the system of equations, we already know that L <= n <= 10^12, thus all the intermediate moduli will also obide to this constraint; — The Extended Euclidean Algorithm can find a solution in the same bounds as its inputs, so it will also use numbers up to 10^12.The overall complexity of the algorithm is O(k logn).338E - Optimize!Decyphering Manao's pseudocode, we unearth the following problem: you are given arrays a[1..n] and b[1..len] and a number h. Consider each subarray of a of length L. Let us call it s. Count how many of them have the property that the elements of b can be shuffled in such a way that each sum s[i]+b[i] (1<=i<=L) is at least h.First, let's solve a problem for one subarray. That is, we need to determine whether the elements of two arrays s and b can be matched in such a way that each sum is h or more. We can do the following: for each element of s, find the least element of b such that the two's sum is at least h, and erase the corresponding element from b. If we managed to pair each of the elements from s, then the arrays hold the property. Note that the elements of s can be processed in any order. If both s and b are sorted, then the idea described can be implemented in linear time.We can not achieve better complexity when considering each subarray separately, so we will try to solve the problem for several subarrays at the same time. Suppose that b is already sorted. We choose some X < len and consider a subarray a[i..i+X-1]. Let's process all the numbers from this subarray, i.e., for each of them find the least b[j] which pairs up with this number and erase it from b. The whole processing can be done in time O(n) if we have a sorted version of a and the corresponding indices computed beforehand.Now we can find the answer for every subarray s of length len which begins in segment [i-Y, i] using O(YlogY) operations, where Y=len-X. For this, we just take the Y elements which are in s but not in a[i..i+X-1] and process them against the numbers left in b. If each of them has been paired, then subarray s holds the required property, otherwise it does not. Moreover, since the subarrays we consider are overlapping, we can optimize even further and obtain amortized O(Y) complexity per subarray. To understand this, note that for processing a subarray in O(Y) time we only need to obtain its sorted version (to be more specific, the sorted version of the portion which does not overlap with a[i..i+X-1]). For the leftmost subarray we consider, we can sort its elements in usual way. For every next subarray (which differs from its predecessor in exactly two elements) we only need O(Y) operations to obtain its sorted version by updating the information from the previous subarray. Thus we have complexity O(YlogY + Y^2) of processing Y segments in total, which gives O(Y) per segment on average.Now let us take a look at the full picture. To process all subarrays of length len, we need to use the method given above for each of the segments a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], .... Therefore, we have O(N/Y) iterations of algorithm with comlexity O(N+Y^2). We need to find a value of Y that minimizes N*N/Y + N*Y, which is Y=~sqrt(N). The overall complexity is O(Nsqrt(N)). However, we need to consider the case len < sqrt(N) separately, since then Y = len - X < len. In this case, the problem can be solved in time O(N*len) with ideas similar to those described above.You can check the implementation of this idea in 4302344.P.S. The statement of the \"problem\" that Manao is solving actually contains a Georgian fairy tale. You can copy almost the same text from here and try to guess what he tale is about :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 338 和字母"
          },
          "content_length": 15337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 1",
          "code": "f[k], f[k+1], ..., f[k+n-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 2",
          "code": "f[k]=f[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 3",
          "code": "f[k+n-1]-f[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 4",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 5",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 6",
          "code": "h*W/w = w*c/d * W/w = W*d/c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 7",
          "code": "(screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 8",
          "code": "w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 9",
          "code": "(W - W*b/a * c/d)/W = (ad-bc)/ad",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 10",
          "code": "(k*2+k)*2+m-2*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 11",
          "code": "((k*2+k)*2+k)*2+m-3*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 12",
          "code": "(2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 13",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 14",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 15",
          "code": "X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 16",
          "code": "max(0, m - (n - n mod k) / k * (k-1) - n mod k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 17",
          "code": "distDown[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 18",
          "code": "distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 19",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])+2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 20",
          "code": "distUp[p]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 21",
          "code": "distDown[sibling1], ..., distDown[siblingK]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 22",
          "code": "distDown[v] < max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 23",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 24",
          "code": "distDown[v] = max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 25",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 26",
          "code": "distDown[v] <= d && distUp[v] <= d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 27",
          "code": "i = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 28",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 29",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 30",
          "code": "x, y (0 <= x, y <= k-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 31",
          "code": "-x = -y (mod GCD(a[x+1], a[y+1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 32",
          "code": "L = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 33",
          "code": "j+x*L, x>=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 34",
          "code": "G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 35",
          "code": "r1, m1, r2, m2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 36",
          "code": "X = r1 (mod m1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 37",
          "code": "X = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 38",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 39",
          "code": "m1*x + r1 = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 40",
          "code": "m1*x + m2*y = r2-r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 41",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 42",
          "code": "j = X1 (mod LCM(a[1], a[2]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 43",
          "code": "LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 44",
          "code": "L <= n <= 10^12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 45",
          "code": "s[i]+b[i] (1<=i<=L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 46",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 47",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 48",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 49",
          "code": "O(YlogY + Y^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 50",
          "code": "a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 51",
          "code": "N*N/Y + N*Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 52",
          "code": "O(Nsqrt(N))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 53",
          "code": "len < sqrt(N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 54",
          "code": "Y = len - X < len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 55",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 56",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 57",
          "code": "dp[up_lsb][down_mask1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 58",
          "code": "dp[up_rest][down_mask2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 59",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 60",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 61",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 62",
          "code": "X+(n/k)*(k-1)>=m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 8, \"n\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 2LL, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    set<long long> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All a_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 8, \"n\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 2LL, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    set<long long> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All a_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 8, \"n\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 2LL, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    set<long long> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All a_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long random_in_range(long long from, long long to) {\n    return rnd.next(from, to);\n}\n\nlong long random_prime() {\n    // Generate a prime up to 1e6\n    static vector<long long> primes;\n    static bool initialized = false;\n    if (!initialized) {\n        const int MAX_PRIME = 1000000;\n        vector<bool> is_prime(MAX_PRIME + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i * i <= MAX_PRIME; ++i) {\n            if (is_prime[i]) {\n                for (int j = i * i; j <= MAX_PRIME; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for (int i = 2; i <= MAX_PRIME; ++i) {\n            if (is_prime[i])\n                primes.push_back(i);\n        }\n        initialized = true;\n    }\n    return primes[rnd.next(0, primes.size() - 1)];\n}\n\nlong long random_composite(long long min_value, long long max_value) {\n    while (true) {\n        long long num = rnd.next(min_value, max_value);\n        if (num <= 3)\n            continue;\n        // Check if num is composite\n        if (num % 2 == 0)\n            return num;\n        for (int i = 3; i * i <= num && i <= 1000; i += 2) {\n            if (num % i == 0)\n                return num;\n        }\n    }\n}\n\nlong long random_power_of_prime() {\n    long long p = random_prime();\n    int max_exponent = log(1e12) / log(p);\n    int e = rnd.next(1, max(1, max_exponent));\n    // Use pow, but ensure result is within range\n    long long result = p;\n    for (int i = 1; i < e; ++i) {\n        if (result > 1e12 / p)\n            break;\n        result *= p;\n    }\n    return result;\n}\n\nlong long random_coprime_with(vector<long long>& nums) {\n    while (true) {\n        long long num = rnd.next(2LL, 1'000'000'000'000LL);\n        bool coprime = true;\n        for (long long x : nums) {\n            if (__gcd(num, x) != 1) {\n                coprime = false;\n                break;\n            }\n        }\n        if (coprime)\n            return num;\n    }\n}\n\nlong long random_common_factor(long long factor) {\n    // Generate number which is multiple of factor\n    long long mult = rnd.next(1LL, min(1'000'000'000'000LL / factor, 1'000'000'000'000LL));\n    return factor * mult;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<long long> a_set;\n    vector<long long> a;\n\n    if (type == \"random\") {\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(2LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"small\") {\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(2LL, 100LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"large\") {\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(999'999'990'000LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"primes\") {\n        while ((int)a_set.size() < n) {\n            long long num = random_prime();\n            a_set.insert(num);\n        }\n    } else if (type == \"composite\") {\n        while ((int)a_set.size() < n) {\n            long long num = random_composite(2LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"powers\") {\n        while ((int)a_set.size() < n) {\n            long long num = random_power_of_prime();\n            if (num >= 2 && num <= 1'000'000'000'000LL)\n                a_set.insert(num);\n        }\n    } else if (type == \"coprime\") {\n        while ((int)a_set.size() < n) {\n            vector<long long> a_vec(a_set.begin(), a_set.end());\n            long long num = random_coprime_with(a_vec);\n            a_set.insert(num);\n        }\n    } else if (type == \"common_factor\") {\n        // Select a random common factor between 2 and 1e6\n        long long factor = rnd.next(2LL, 1'000'000LL);\n        while ((int)a_set.size() < n) {\n            long long num = random_common_factor(factor);\n            if (num >= 2 && num <= 1'000'000'000'000LL)\n                a_set.insert(num);\n        }\n    } else {\n        // default is random\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(2LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    }\n\n    a = vector<long long>(a_set.begin(), a_set.end());\n    shuffle(a.begin(), a.end());\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long random_in_range(long long from, long long to) {\n    return rnd.next(from, to);\n}\n\nlong long random_prime() {\n    // Generate a prime up to 1e6\n    static vector<long long> primes;\n    static bool initialized = false;\n    if (!initialized) {\n        const int MAX_PRIME = 1000000;\n        vector<bool> is_prime(MAX_PRIME + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i * i <= MAX_PRIME; ++i) {\n            if (is_prime[i]) {\n                for (int j = i * i; j <= MAX_PRIME; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for (int i = 2; i <= MAX_PRIME; ++i) {\n            if (is_prime[i])\n                primes.push_back(i);\n        }\n        initialized = true;\n    }\n    return primes[rnd.next(0, primes.size() - 1)];\n}\n\nlong long random_composite(long long min_value, long long max_value) {\n    while (true) {\n        long long num = rnd.next(min_value, max_value);\n        if (num <= 3)\n            continue;\n        // Check if num is composite\n        if (num % 2 == 0)\n            return num;\n        for (int i = 3; i * i <= num && i <= 1000; i += 2) {\n            if (num % i == 0)\n                return num;\n        }\n    }\n}\n\nlong long random_power_of_prime() {\n    long long p = random_prime();\n    int max_exponent = log(1e12) / log(p);\n    int e = rnd.next(1, max(1, max_exponent));\n    // Use pow, but ensure result is within range\n    long long result = p;\n    for (int i = 1; i < e; ++i) {\n        if (result > 1e12 / p)\n            break;\n        result *= p;\n    }\n    return result;\n}\n\nlong long random_coprime_with(vector<long long>& nums) {\n    while (true) {\n        long long num = rnd.next(2LL, 1'000'000'000'000LL);\n        bool coprime = true;\n        for (long long x : nums) {\n            if (__gcd(num, x) != 1) {\n                coprime = false;\n                break;\n            }\n        }\n        if (coprime)\n            return num;\n    }\n}\n\nlong long random_common_factor(long long factor) {\n    // Generate number which is multiple of factor\n    long long mult = rnd.next(1LL, min(1'000'000'000'000LL / factor, 1'000'000'000'000LL));\n    return factor * mult;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<long long> a_set;\n    vector<long long> a;\n\n    if (type == \"random\") {\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(2LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"small\") {\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(2LL, 100LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"large\") {\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(999'999'990'000LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"primes\") {\n        while ((int)a_set.size() < n) {\n            long long num = random_prime();\n            a_set.insert(num);\n        }\n    } else if (type == \"composite\") {\n        while ((int)a_set.size() < n) {\n            long long num = random_composite(2LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    } else if (type == \"powers\") {\n        while ((int)a_set.size() < n) {\n            long long num = random_power_of_prime();\n            if (num >= 2 && num <= 1'000'000'000'000LL)\n                a_set.insert(num);\n        }\n    } else if (type == \"coprime\") {\n        while ((int)a_set.size() < n) {\n            vector<long long> a_vec(a_set.begin(), a_set.end());\n            long long num = random_coprime_with(a_vec);\n            a_set.insert(num);\n        }\n    } else if (type == \"common_factor\") {\n        // Select a random common factor between 2 and 1e6\n        long long factor = rnd.next(2LL, 1'000'000LL);\n        while ((int)a_set.size() < n) {\n            long long num = random_common_factor(factor);\n            if (num >= 2 && num <= 1'000'000'000'000LL)\n                a_set.insert(num);\n        }\n    } else {\n        // default is random\n        while ((int)a_set.size() < n) {\n            long long num = rnd.next(2LL, 1'000'000'000'000LL);\n            a_set.insert(num);\n        }\n    }\n\n    a = vector<long long>(a_set.begin(), a_set.end());\n    shuffle(a.begin(), a.end());\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 6 -type random\n./gen -n 7 -type random\n./gen -n 8 -type random\n\n./gen -n 8 -type small\n./gen -n 8 -type large\n./gen -n 8 -type primes\n./gen -n 8 -type composite\n./gen -n 8 -type powers\n./gen -n 8 -type coprime\n./gen -n 8 -type common_factor\n\n./gen -n 4 -type small\n./gen -n 4 -type large\n./gen -n 4 -type primes\n./gen -n 4 -type composite\n./gen -n 4 -type powers\n./gen -n 4 -type coprime\n./gen -n 4 -type common_factor\n\n./gen -n 2 -type small\n./gen -n 2 -type large\n./gen -n 2 -type primes\n./gen -n 2 -type composite\n./gen -n 2 -type powers\n./gen -n 2 -type coprime\n./gen -n 2 -type common_factor\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:26.733913",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "338/D",
      "title": "D. GCD Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m and k (1 ≤ n, m ≤ 1012; 1 ≤ k ≤ 10000). The second line contains k space-separated integers a1, a2, ..., ak (1 ≤ ai ≤ 1012).",
      "output_spec": "OutputPrint a single word \"YES\", if the given sequence occurs in table G, otherwise print \"NO\".",
      "sample_tests": "ExamplesInputCopy100 100 55 2 1 2 1OutputCopyYESInputCopy100 8 55 2 1 2 1OutputCopyNOInputCopy100 100 71 2 3 4 5 6 7OutputCopyNO",
      "description": "D. GCD Table\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m and k (1 ≤ n, m ≤ 1012; 1 ≤ k ≤ 10000). The second line contains k space-separated integers a1, a2, ..., ak (1 ≤ ai ≤ 1012).\n\nOutputPrint a single word \"YES\", if the given sequence occurs in table G, otherwise print \"NO\".\n\nInputCopy100 100 55 2 1 2 1OutputCopyYESInputCopy100 8 55 2 1 2 1OutputCopyNOInputCopy100 100 71 2 3 4 5 6 7OutputCopyNO\n\nInputCopy100 100 55 2 1 2 1\n\nOutputCopyYES\n\nInputCopy100 8 55 2 1 2 1\n\nOutputCopyNO\n\nInputCopy100 100 71 2 3 4 5 6 7\n\nOutputCopyNO\n\nNoteSample 1. The tenth row of table G starts from sequence {1, 2, 1, 2, 5, 2, 1, 2, 1, 10}. As you can see, elements from fifth to ninth coincide with sequence a.Sample 2. This time the width of table G equals 8. Sequence a doesn't occur there.",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces",
          "content": "337A - PuzzlesFirst, let's sort the numbers f[i] in ascending order. Now assume that the smallest jigsaw puzzle which the teacher purchases consists of f[k] pieces. Obviously, she should buy the smallest n puzzles which are of size f[k] or greater to minimize the difference. These are the puzzles f[k], f[k+1], ..., f[k+n-1] (this is not correct when f[i] are not distinct and f[k]=f[k-1], but such cases can be skipped). The difference between the greatest and the least size of the puzzles in such set is f[k+n-1]-f[k].To choose the optimal f[k], we can test every k between 1 and m-n and pick the one producing the least difference. The full algorithm is as follows: read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n best = min(best, f[k+n-1] - f[k])\nprint best337B - Routine ProblemSuppose that the width and height of the screen are W and H correspondingly. Since W:H = a:b, we have H=W*b/a. Similarly, the width and height of the film frame w and h are related as h=w*d/c. Imagine that Manao stretches/constricts the frame until it fits the screen horizontally or vertically, whichever happens first. There are three cases to consider: the horizontal to vertical ratio of the screen is less, equal or more than the corresponding ratio of the frame.In the first case (a/b < c/d) the stretching process ends when the frame reaches the same width as the screen. That is, the frame will enlarge in W/w times and its new width will be W. Thus, its new height is h*W/w = w*c/d * W/w = W*d/c. We are interested in the ratio of unoccupied portion of the screen to its full size, which is (screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc.In the second case (a/b > c/d) the process ends when the frame reaches the same height as the screen. Its height will become H and its width will become w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d. The unoccupied portion of the screen's horizontal is (W - W*b/a * c/d)/W = (ad-bc)/ad.In the third case, the frame fills the screen entirely and the answer will be 0.All that's left is to print the answer as an irreducible fraction. We need to find the greatest common divisor of its nominator and denominator for this. It can be done using Euclidean algorithm or just through trial division by every number from 1 to q. Since q is no more than a product of two numbers from the input and these numbers are constrained by 1000, we need to try at most million numbers in the worst case.337C - QuizAssume that Manao has doubled his score (i.e. gave k consecutive correct answers) exactly X times. Then the least possible score is obtained when this doublings happen in the beginning of the game, i.e., when he answers the first X*k questions and never manages to answer k consecutive questions after that. The correctness of this statement follows from the following: for any other scenario with X doublings, all of these doublings can be moved into the beginning and the total score will not increase. Hence, for X=1 Manao's minimum score is k*2+m-k: he answers k consecutive questions, the score doubles, then he answers m-k questions. For X=2 the minimum possible score is (k*2+k)*2+m-2*k, for X=3 — ((k*2+k)*2+k)*2+m-3*k. For the general case, a formula (2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k is derived.The abovementioned observation shows that the minimum score grows monotonically when X is increased, so all we need is to find the minimum feasible X. It should satisfy the inequalities X*k <= n and X + (n - n mod k) / k * (k-1) + n mod k >= m. More on the second inequality: Manao answered the first X*k questions, thus there are n-X*k left. Now he can answer at most k-1 question from each k questions. If k divides n-X*k (which is the same as k divides n), the inequality becomes X*k + (n-X*k) / k * (k-1) >= m, but the remainder complicates it a bit: X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m. This formula can be simplified to the one written earlier. So, the minimum X is equal to max(0, m - (n - n mod k) / k * (k-1) - n mod k). You'll need exponentiation by squaring to compute the score corresponding to this value of X. Thus, the overall complexity of this solution is O(log(n)).337D - Book of EvilObviously, in graph theory language our problem is: given a tree with n vertices, m of which are marked, find the number of vertices which are at most distance d apart from each of the marked vertices.Let us hang the tree by some vertex r, that is, assume that it is a rooted tree with root in vertex r. Let us also rephrase the condition imposed on sought vertices: we need to count such vertices v that the maximum distance from v to a marked vertex is at most d.For any inner vertex v, the marked vertex which is the farthest from it is either in the subtree of v or outside it — in the latter case the path from v to the farthest marked vertex traverses the parent of v. Using this observation, we can recompute the distances to the farthest marked vertices when transiting from a vertex to its child.First, we will compute the distance from every vertex v to the farthest marked vertex within the subtree of v. Let us call this distance distDown[v]. The values of distDown[] can be computed in a single depth-first search: for each leaf of the tree this distance is either 0 (when the leaf is marked) or nominal negative infinity (when the leaf is not marked), and for each inner vertex v distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1, where childi are the children of v.Now we will compute the distances from each vertex to the farthest marked vertex outside its subtree. Let's denote this distance with distUp[v]. We will use DFS again to compute values of distUp[]. For the root, distUp[r] is equal to nominal negative infinity, and for any other vertex v there are two cases: either the farthest marked vertex is located in the subtree of v-s parent p, or it is even \"farther\", i.e., the path to it traverses vertex p-s parent. In the first case, the distance from v to such vertex is equal to max(distDown[sibling1], ..., distDown[siblingK])+2, where siblingi are the brothers (other children of the parent) of vertex v. In the second case, it is equal to distUp[p]+1. Thus, distUp[v] is equal to the maximum of these two values. Note that you need to be clever to perform the computations in the first case in overall linear time. For this, you can find the maximum max1 and second maximum max2 of values distDown[sibling1], ..., distDown[siblingK]. After that, when distDown[v] < max1, we have max(distDown[sibling1], ..., distDown[siblingK])=max1, otherwise we have distDown[v] = max1 and max(distDown[sibling1], ..., distDown[siblingK])=max2.After computing distDown[] и distUp[], it is easy to derive the answers: it is the count of such vertices v that distDown[v] <= d && distUp[v] <= d.You can check 4302127 for an implementation of the described approach.337E - Divisor TreeLet us first show that in an optimal divisor tree only the root or a leaf can hold a value other than one of a[i]. Suppose that we have an inner vertex different from the root which holds a number X not equal to any of a[i]. Then we can exclude this vertex from the tree and tie its children to its parent without violating any of the tree's properties.Hence, our tree consists of the root, vertices with numbers a[i] tied to each other or to the root, and leaves, which are tied to vertices with numbers a[i] and contain these numbers' prime factorizations. The exception is the case when one of a[i] is written in root itself, and the case when some a[i]-s are prime themselves. Also note that in general case it's easy to count how many leaves the tree will have. This count is equal to the sum of exponents of primes in prime factorizations of those a[i]-s which are the children of the root.Since N <= 8, we can build all divisor trees which satisfy the observations we made. Let's sort numbers a[i] in descending order and recursively choose a parent for each of them from the vertices already present in the tree. Of course, tying a number X to some vertex v is only possible if the product of X and the numbers in children of v divides the number in v itself. For a[1], we have a choice — we can make it the root of the tree or a child of the root (in this case the root will hold a nominal infinity which is divisible by any number). For every next a[i], the choice is whether to tie it to the root or a vertex containing one of the previous numbers. Therefore, we only consider O(N!) trees in total.You can check 4302171 for an implementation of this idea.338D - GCD TableObservation 1. If the sequence a occurs in table G, then it should occur in row i = LCM(a[1], ..., a[k]). The proof follows. It is clear that theoretically it may only occur in rows with numbers which are multiple to i, since the row number should divide by each of a[index]. Consider some a row with number i*x, where x>1. The rows i and i*x differ only in such elements j that i*x and j both divide by some p^q (where p is prime) which does not divide i (hence, G(i*x, j) is divisible by p^q). But none of the a[index] may divide by such p^q, since then i would be also divisible by it. Therefore, if a occurs in row i*x, then it does not intersect with index j. Since it can only reside on indices where i and i*x coincide, checking only the i-th row is enough. It also clear that if i > n, the answer is NO.Observation 2. The sought index j should satisfy the following modular linear equations system: j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}In other words, j + l must divide by a[l+1] for each l=0..k-1.According to Chinese Remainder Theorem, such a system has a solution iff for each pair of indices x, y (0 <= x, y <= k-1) we have -x = -y (mod GCD(a[x+1], a[y+1])). Let's denote L = LCM(a[1], ..., a[k]). If the system has a solution, then it is singular on interval [0, L) and all the other solutions are congruent to it modulo L. Suppose that we have found the minimum non-negative j which satisfies the given system. Then, if a occurs in G, it will start from the j-th element of the i-th row. Theoretically, it may begin at any index of form j+x*L, x>=0, but since i = L, we have G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j). So it is sufficient to check whether the k consecutive elements which begin at index j in row i coincide with sequence a. It is also clear that when j > m-k+1, the answer is NO.Finally, let's consider how to solve a system of modular linear equations. We can use an auxiliary method which, given r1, m1, r2, m2, finds minimum X such that X = r1 (mod m1) and X = r2 (mod m2), or determines that such number does not exist. Let X = m1*x + r1, then we have m1*x + r1 = r2 (mod m2). This can be represented as a Diophantine equation m1*x + m2*y = r2-r1 and solved using Extended Euclidean Algorithm. The least non-negative x, if it exists, yields the sought X = m1*x + r1. Now this method can be used to find the minimum X1 which satisfies the first two equations. After that, we can say that we have a system with k-1 equation, where the first two old equations are replaced with a new j = X1 (mod LCM(a[1], a[2])), and repeat the same procedure again. After using this method k-1 times, we obtain the solution to the whole system.Also note that the proposed solution does not require long arithmetics: — The computation of LCM(a[1], ..., a[k]) can be implemented with a check before each multiplication: if the result will become larger than n, the answer is NO; — When it comes to solving the system of equations, we already know that L <= n <= 10^12, thus all the intermediate moduli will also obide to this constraint; — The Extended Euclidean Algorithm can find a solution in the same bounds as its inputs, so it will also use numbers up to 10^12.The overall complexity of the algorithm is O(k logn).338E - Optimize!Decyphering Manao's pseudocode, we unearth the following problem: you are given arrays a[1..n] and b[1..len] and a number h. Consider each subarray of a of length L. Let us call it s. Count how many of them have the property that the elements of b can be shuffled in such a way that each sum s[i]+b[i] (1<=i<=L) is at least h.First, let's solve a problem for one subarray. That is, we need to determine whether the elements of two arrays s and b can be matched in such a way that each sum is h or more. We can do the following: for each element of s, find the least element of b such that the two's sum is at least h, and erase the corresponding element from b. If we managed to pair each of the elements from s, then the arrays hold the property. Note that the elements of s can be processed in any order. If both s and b are sorted, then the idea described can be implemented in linear time.We can not achieve better complexity when considering each subarray separately, so we will try to solve the problem for several subarrays at the same time. Suppose that b is already sorted. We choose some X < len and consider a subarray a[i..i+X-1]. Let's process all the numbers from this subarray, i.e., for each of them find the least b[j] which pairs up with this number and erase it from b. The whole processing can be done in time O(n) if we have a sorted version of a and the corresponding indices computed beforehand.Now we can find the answer for every subarray s of length len which begins in segment [i-Y, i] using O(YlogY) operations, where Y=len-X. For this, we just take the Y elements which are in s but not in a[i..i+X-1] and process them against the numbers left in b. If each of them has been paired, then subarray s holds the required property, otherwise it does not. Moreover, since the subarrays we consider are overlapping, we can optimize even further and obtain amortized O(Y) complexity per subarray. To understand this, note that for processing a subarray in O(Y) time we only need to obtain its sorted version (to be more specific, the sorted version of the portion which does not overlap with a[i..i+X-1]). For the leftmost subarray we consider, we can sort its elements in usual way. For every next subarray (which differs from its predecessor in exactly two elements) we only need O(Y) operations to obtain its sorted version by updating the information from the previous subarray. Thus we have complexity O(YlogY + Y^2) of processing Y segments in total, which gives O(Y) per segment on average.Now let us take a look at the full picture. To process all subarrays of length len, we need to use the method given above for each of the segments a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], .... Therefore, we have O(N/Y) iterations of algorithm with comlexity O(N+Y^2). We need to find a value of Y that minimizes N*N/Y + N*Y, which is Y=~sqrt(N). The overall complexity is O(Nsqrt(N)). However, we need to consider the case len < sqrt(N) separately, since then Y = len - X < len. In this case, the problem can be solved in time O(N*len) with ideas similar to those described above.You can check the implementation of this idea in 4302344.P.S. The statement of the \"problem\" that Manao is solving actually contains a Georgian fairy tale. You can copy almost the same text from here and try to guess what he tale is about :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 338\\s*D"
          },
          "content_length": 15337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 1",
          "code": "f[k], f[k+1], ..., f[k+n-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 2",
          "code": "f[k]=f[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 3",
          "code": "f[k+n-1]-f[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 4",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 5",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 6",
          "code": "h*W/w = w*c/d * W/w = W*d/c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 7",
          "code": "(screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 8",
          "code": "w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 9",
          "code": "(W - W*b/a * c/d)/W = (ad-bc)/ad",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 10",
          "code": "(k*2+k)*2+m-2*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 11",
          "code": "((k*2+k)*2+k)*2+m-3*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 12",
          "code": "(2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 13",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 14",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 15",
          "code": "X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 16",
          "code": "max(0, m - (n - n mod k) / k * (k-1) - n mod k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 17",
          "code": "distDown[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 18",
          "code": "distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 19",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])+2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 20",
          "code": "distUp[p]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 21",
          "code": "distDown[sibling1], ..., distDown[siblingK]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 22",
          "code": "distDown[v] < max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 23",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 24",
          "code": "distDown[v] = max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 25",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 26",
          "code": "distDown[v] <= d && distUp[v] <= d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 27",
          "code": "i = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 28",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 29",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 30",
          "code": "x, y (0 <= x, y <= k-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 31",
          "code": "-x = -y (mod GCD(a[x+1], a[y+1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 32",
          "code": "L = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 33",
          "code": "j+x*L, x>=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 34",
          "code": "G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 35",
          "code": "r1, m1, r2, m2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 36",
          "code": "X = r1 (mod m1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 37",
          "code": "X = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 38",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 39",
          "code": "m1*x + r1 = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 40",
          "code": "m1*x + m2*y = r2-r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 41",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 42",
          "code": "j = X1 (mod LCM(a[1], a[2]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 43",
          "code": "LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 44",
          "code": "L <= n <= 10^12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 45",
          "code": "s[i]+b[i] (1<=i<=L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 46",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 47",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 48",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 49",
          "code": "O(YlogY + Y^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 50",
          "code": "a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 51",
          "code": "N*N/Y + N*Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 52",
          "code": "O(Nsqrt(N))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 53",
          "code": "len < sqrt(N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 54",
          "code": "Y = len - X < len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 55",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 56",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 57",
          "code": "dp[up_lsb][down_mask1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 58",
          "code": "dp[up_rest][down_mask2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 59",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 60",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 61",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 62",
          "code": "X+(n/k)*(k-1)>=m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1, 1000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(k, 1, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1, 1000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(k, 1, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1, 1000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(k, 1, 1000000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator outputs a single test case for the following problem:\n\n    We have a table G of size n × m such that G(i, j) = GCD(i, j).\n    We are given a sequence a1, a2, ..., ak.\n    We need to determine if this sequence a occurs consecutively in some row of G.\n\n    Input format:\n      1) A line with three space-separated integers n, m, and k.\n      2) A line with k space-separated integers a1, a2, ..., ak.\n\n    Constraints:\n      1 <= n, m <= 10^12\n      1 <= k <= 10000\n      1 <= a_i <= 10^12\n\n  USAGE:\n    Compile and run this generator with various parameters, e.g.:\n      ./gen -n 100 -m 200 -k 5 -type random\n    It will output exactly one test with the specified n, m, k, and an array\n    of length k (depending on the \"type\" parameter).\n\n  NOTE:\n    1. Do NOT set or pass any random seed. testlib does it automatically.\n    2. For large n, m (up to 10^12), we will still generate the output for a[] (which is feasible).\n    3. For certain \"type\"s we ignore user-provided n, m, k and produce a predefined test (e.g. \"sample1\").\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read arguments (with defaults).\n    long long n = opt<long long>(\"n\", 100LL);\n    long long m = opt<long long>(\"m\", 100LL);\n    int k       = opt<int>(\"k\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Container for the sequence\n    vector<long long> seq(k, 1LL);\n\n    // Handle special \"sample\" types from the problem statement\n    // These ignore user-provided n, m, k and produce exact data.\n    if (type == \"sample1\") {\n        // First example\n        // Input:\n        //  100 100 5\n        //  5 2 1 2 1\n        n = 100; m = 100; k = 5;\n        seq = {5, 2, 1, 2, 1};\n    }\n    else if (type == \"sample2\") {\n        // Second example\n        // Input:\n        //  100 8 5\n        //  5 2 1 2 1\n        n = 100; m = 8; k = 5;\n        seq = {5, 2, 1, 2, 1};\n    }\n    else if (type == \"sample3\") {\n        // Third example\n        // Input:\n        //  100 100 7\n        //  1 2 3 4 5 6 7\n        n = 100; m = 100; k = 7;\n        seq = {1, 2, 3, 4, 5, 6, 7};\n    }\n    // Otherwise, we generate data based on \"type\" and user-provided n, m, k.\n    else if (type == \"all-ones\") {\n        // All elements = 1\n        // Note: This often forms a \"YES\" case if m >= k and n >= 1.\n        for (int i = 0; i < k; i++) {\n            seq[i] = 1LL;\n        }\n    }\n    else if (type == \"inc\") {\n        // Increasing sequence from 1 to k, but clipped at min(n,m) if needed\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            // Each element does not exceed limit\n            seq[i] = min<long long>(limit, (long long)(i + 1));\n        }\n    }\n    else if (type == \"dec\") {\n        // Decreasing sequence from min(n,m) down\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            // Each element is: limit - i, but not less than 1\n            long long val = limit - i;\n            if (val < 1) val = 1; // clamp to 1\n            seq[i] = val;\n        }\n    }\n    else if (type == \"max\") {\n        // Entire sequence uses min(n,m)\n        // This might catch edge logic where GCD(i, j) = big numbers\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            seq[i] = limit;\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly generate each a_i in [1..min(n,m)]\n        // Because GCD(i,j) <= min(i,j), so it never exceeds min(n,m).\n        long long limit = min(n, m);\n        // In testlib, next(long long n) -> random in [0..n-1],\n        // so we use next(limit) + 1 to get [1..limit] (if limit>0).\n        // But if limit = 0 (possible if n=0 or m=0?), problem constraints do not allow n=0 or m=0.\n        // Anyway, per problem statement n, m >= 1, so limit >=1.\n        for (int i = 0; i < k; i++) {\n            // Generate in [1..limit]\n            long long val = rnd.next(limit) + 1;\n            seq[i] = val;\n        }\n    }\n    else {\n        // If \"type\" is unrecognized, just do the same as \"random\"\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            long long val = rnd.next(limit) + 1;\n            seq[i] = val;\n        }\n    }\n\n    // Output format:\n    // Line 1: n, m, k\n    // Line 2: k integers (the sequence)\n    cout << n << \" \" << m << \" \" << k << \"\\n\";\n    for (int i = 0; i < k; i++) {\n        cout << seq[i] << (i + 1 < k ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator outputs a single test case for the following problem:\n\n    We have a table G of size n × m such that G(i, j) = GCD(i, j).\n    We are given a sequence a1, a2, ..., ak.\n    We need to determine if this sequence a occurs consecutively in some row of G.\n\n    Input format:\n      1) A line with three space-separated integers n, m, and k.\n      2) A line with k space-separated integers a1, a2, ..., ak.\n\n    Constraints:\n      1 <= n, m <= 10^12\n      1 <= k <= 10000\n      1 <= a_i <= 10^12\n\n  USAGE:\n    Compile and run this generator with various parameters, e.g.:\n      ./gen -n 100 -m 200 -k 5 -type random\n    It will output exactly one test with the specified n, m, k, and an array\n    of length k (depending on the \"type\" parameter).\n\n  NOTE:\n    1. Do NOT set or pass any random seed. testlib does it automatically.\n    2. For large n, m (up to 10^12), we will still generate the output for a[] (which is feasible).\n    3. For certain \"type\"s we ignore user-provided n, m, k and produce a predefined test (e.g. \"sample1\").\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read arguments (with defaults).\n    long long n = opt<long long>(\"n\", 100LL);\n    long long m = opt<long long>(\"m\", 100LL);\n    int k       = opt<int>(\"k\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Container for the sequence\n    vector<long long> seq(k, 1LL);\n\n    // Handle special \"sample\" types from the problem statement\n    // These ignore user-provided n, m, k and produce exact data.\n    if (type == \"sample1\") {\n        // First example\n        // Input:\n        //  100 100 5\n        //  5 2 1 2 1\n        n = 100; m = 100; k = 5;\n        seq = {5, 2, 1, 2, 1};\n    }\n    else if (type == \"sample2\") {\n        // Second example\n        // Input:\n        //  100 8 5\n        //  5 2 1 2 1\n        n = 100; m = 8; k = 5;\n        seq = {5, 2, 1, 2, 1};\n    }\n    else if (type == \"sample3\") {\n        // Third example\n        // Input:\n        //  100 100 7\n        //  1 2 3 4 5 6 7\n        n = 100; m = 100; k = 7;\n        seq = {1, 2, 3, 4, 5, 6, 7};\n    }\n    // Otherwise, we generate data based on \"type\" and user-provided n, m, k.\n    else if (type == \"all-ones\") {\n        // All elements = 1\n        // Note: This often forms a \"YES\" case if m >= k and n >= 1.\n        for (int i = 0; i < k; i++) {\n            seq[i] = 1LL;\n        }\n    }\n    else if (type == \"inc\") {\n        // Increasing sequence from 1 to k, but clipped at min(n,m) if needed\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            // Each element does not exceed limit\n            seq[i] = min<long long>(limit, (long long)(i + 1));\n        }\n    }\n    else if (type == \"dec\") {\n        // Decreasing sequence from min(n,m) down\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            // Each element is: limit - i, but not less than 1\n            long long val = limit - i;\n            if (val < 1) val = 1; // clamp to 1\n            seq[i] = val;\n        }\n    }\n    else if (type == \"max\") {\n        // Entire sequence uses min(n,m)\n        // This might catch edge logic where GCD(i, j) = big numbers\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            seq[i] = limit;\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly generate each a_i in [1..min(n,m)]\n        // Because GCD(i,j) <= min(i,j), so it never exceeds min(n,m).\n        long long limit = min(n, m);\n        // In testlib, next(long long n) -> random in [0..n-1],\n        // so we use next(limit) + 1 to get [1..limit] (if limit>0).\n        // But if limit = 0 (possible if n=0 or m=0?), problem constraints do not allow n=0 or m=0.\n        // Anyway, per problem statement n, m >= 1, so limit >=1.\n        for (int i = 0; i < k; i++) {\n            // Generate in [1..limit]\n            long long val = rnd.next(limit) + 1;\n            seq[i] = val;\n        }\n    }\n    else {\n        // If \"type\" is unrecognized, just do the same as \"random\"\n        long long limit = min(n, m);\n        for (int i = 0; i < k; i++) {\n            long long val = rnd.next(limit) + 1;\n            seq[i] = val;\n        }\n    }\n\n    // Output format:\n    // Line 1: n, m, k\n    // Line 2: k integers (the sequence)\n    cout << n << \" \" << m << \" \" << k << \"\\n\";\n    for (int i = 0; i < k; i++) {\n        cout << seq[i] << (i + 1 < k ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands (20+) to run the generator. \n# Each command will print a single test case to stdout.\n# You do NOT need to redirect output here with '>', just run them.\n\n# 1) Problem's original samples (ignore user n, m, k, always output the fixed sample).\n./gen -type sample1\n./gen -type sample2\n./gen -type sample3\n\n# 2) Very small n, m => demonstration of special types.\n./gen -n 1 -m 1 -k 1 -type all-ones\n./gen -n 2 -m 2 -k 2 -type inc\n./gen -n 3 -m 3 -k 3 -type dec\n\n# 3) Slightly bigger, with random sequence in the range [1..min(n,m)].\n./gen -n 10 -m 10 -k 5 -type random\n./gen -n 10 -m 10 -k 5 -type max\n\n# 4) More varied sizes. \n./gen -n 50 -m 50 -k 10 -type random\n./gen -n 50 -m 50 -k 10 -type dec\n./gen -n 50 -m 50 -k 10 -type inc\n\n# 5) More subsets with bigger n, m for stress.\n./gen -n 1000 -m 1000 -k 20 -type random\n./gen -n 1000 -m 1000 -k 20 -type all-ones\n\n# 6) Even larger n, m but moderate k.\n./gen -n 999999999999 -m 999999999999 -k 5 -type random\n./gen -n 1000000000000 -m 500000000000 -k 5 -type inc\n\n# 7) Tests with k near 1 and near some bigger bound (but here we just pick 50).\n./gen -n 100 -m 200 -k 1 -type random\n./gen -n 200 -m 100 -k 50 -type random\n\n# 8) Another set with \"all-ones\" and \"max\" to see extremes.\n./gen -n 999999999999 -m 1 -k 1 -type all-ones\n./gen -n 123456789012 -m 123456789012 -k 10 -type max\n\n# 9) Some extra random tests.\n./gen -n 12345 -m 67890 -k 10 -type random\n./gen -n 999999999999 -m 888888888888 -k 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:29.039740",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "338/E",
      "title": "E. Optimize!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains space-separated integers n, len and h (1 ≤ len ≤ n ≤ 150000; 1 ≤ h ≤ 109). The second line contains len space-separated integers b1, b2, ..., blen (1 ≤ bi ≤ 109). The third line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint a single number — the answer to Manao's problem.",
      "sample_tests": "ExamplesInputCopy5 2 105 31 8 5 5 7OutputCopy2",
      "description": "E. Optimize!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains space-separated integers n, len and h (1 ≤ len ≤ n ≤ 150000; 1 ≤ h ≤ 109). The second line contains len space-separated integers b1, b2, ..., blen (1 ≤ bi ≤ 109). The third line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109).\n\nOutputPrint a single number — the answer to Manao's problem.\n\nInputCopy5 2 105 31 8 5 5 7OutputCopy2\n\nInputCopy5 2 105 31 8 5 5 7\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 - Codeforces",
          "content": "Hello everyone!Codeforces Round #196 will begin in several hours (August 16, 20:00MSK).You will mostly have to deal with Manao's problems, which this time range from watching movies and taking quizzes to treebuilding and battling evil undead.I'd like to thank the following people for their contribution to this round's preparation: the Codeforces problem coordinator Gerald; Seyaua, who tested the problems; Delinur, who translated the problem statements into English; and Aksenov239, who proof-read the statements.The points distribution in both divisons will be standard.By the way, Sammarize mentioned he was probably the eldest author of a Codeforces round in the Russian version of his latest round's announcement. Since I'm even older, now I am holding the title ;)The contest is over, I really hope that enjoyed it. The standings: Div1, Div2. Congratulations to top performers in Div1: tourist ilyakor al13n aa2985759 rng_58 Congratulations to the winner of Div2, Ruthles, too!The problem analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8615",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1014
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces",
          "content": "337A - PuzzlesFirst, let's sort the numbers f[i] in ascending order. Now assume that the smallest jigsaw puzzle which the teacher purchases consists of f[k] pieces. Obviously, she should buy the smallest n puzzles which are of size f[k] or greater to minimize the difference. These are the puzzles f[k], f[k+1], ..., f[k+n-1] (this is not correct when f[i] are not distinct and f[k]=f[k-1], but such cases can be skipped). The difference between the greatest and the least size of the puzzles in such set is f[k+n-1]-f[k].To choose the optimal f[k], we can test every k between 1 and m-n and pick the one producing the least difference. The full algorithm is as follows: read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n best = min(best, f[k+n-1] - f[k])\nprint best337B - Routine ProblemSuppose that the width and height of the screen are W and H correspondingly. Since W:H = a:b, we have H=W*b/a. Similarly, the width and height of the film frame w and h are related as h=w*d/c. Imagine that Manao stretches/constricts the frame until it fits the screen horizontally or vertically, whichever happens first. There are three cases to consider: the horizontal to vertical ratio of the screen is less, equal or more than the corresponding ratio of the frame.In the first case (a/b < c/d) the stretching process ends when the frame reaches the same width as the screen. That is, the frame will enlarge in W/w times and its new width will be W. Thus, its new height is h*W/w = w*c/d * W/w = W*d/c. We are interested in the ratio of unoccupied portion of the screen to its full size, which is (screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc.In the second case (a/b > c/d) the process ends when the frame reaches the same height as the screen. Its height will become H and its width will become w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d. The unoccupied portion of the screen's horizontal is (W - W*b/a * c/d)/W = (ad-bc)/ad.In the third case, the frame fills the screen entirely and the answer will be 0.All that's left is to print the answer as an irreducible fraction. We need to find the greatest common divisor of its nominator and denominator for this. It can be done using Euclidean algorithm or just through trial division by every number from 1 to q. Since q is no more than a product of two numbers from the input and these numbers are constrained by 1000, we need to try at most million numbers in the worst case.337C - QuizAssume that Manao has doubled his score (i.e. gave k consecutive correct answers) exactly X times. Then the least possible score is obtained when this doublings happen in the beginning of the game, i.e., when he answers the first X*k questions and never manages to answer k consecutive questions after that. The correctness of this statement follows from the following: for any other scenario with X doublings, all of these doublings can be moved into the beginning and the total score will not increase. Hence, for X=1 Manao's minimum score is k*2+m-k: he answers k consecutive questions, the score doubles, then he answers m-k questions. For X=2 the minimum possible score is (k*2+k)*2+m-2*k, for X=3 — ((k*2+k)*2+k)*2+m-3*k. For the general case, a formula (2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k is derived.The abovementioned observation shows that the minimum score grows monotonically when X is increased, so all we need is to find the minimum feasible X. It should satisfy the inequalities X*k <= n and X + (n - n mod k) / k * (k-1) + n mod k >= m. More on the second inequality: Manao answered the first X*k questions, thus there are n-X*k left. Now he can answer at most k-1 question from each k questions. If k divides n-X*k (which is the same as k divides n), the inequality becomes X*k + (n-X*k) / k * (k-1) >= m, but the remainder complicates it a bit: X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m. This formula can be simplified to the one written earlier. So, the minimum X is equal to max(0, m - (n - n mod k) / k * (k-1) - n mod k). You'll need exponentiation by squaring to compute the score corresponding to this value of X. Thus, the overall complexity of this solution is O(log(n)).337D - Book of EvilObviously, in graph theory language our problem is: given a tree with n vertices, m of which are marked, find the number of vertices which are at most distance d apart from each of the marked vertices.Let us hang the tree by some vertex r, that is, assume that it is a rooted tree with root in vertex r. Let us also rephrase the condition imposed on sought vertices: we need to count such vertices v that the maximum distance from v to a marked vertex is at most d.For any inner vertex v, the marked vertex which is the farthest from it is either in the subtree of v or outside it — in the latter case the path from v to the farthest marked vertex traverses the parent of v. Using this observation, we can recompute the distances to the farthest marked vertices when transiting from a vertex to its child.First, we will compute the distance from every vertex v to the farthest marked vertex within the subtree of v. Let us call this distance distDown[v]. The values of distDown[] can be computed in a single depth-first search: for each leaf of the tree this distance is either 0 (when the leaf is marked) or nominal negative infinity (when the leaf is not marked), and for each inner vertex v distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1, where childi are the children of v.Now we will compute the distances from each vertex to the farthest marked vertex outside its subtree. Let's denote this distance with distUp[v]. We will use DFS again to compute values of distUp[]. For the root, distUp[r] is equal to nominal negative infinity, and for any other vertex v there are two cases: either the farthest marked vertex is located in the subtree of v-s parent p, or it is even \"farther\", i.e., the path to it traverses vertex p-s parent. In the first case, the distance from v to such vertex is equal to max(distDown[sibling1], ..., distDown[siblingK])+2, where siblingi are the brothers (other children of the parent) of vertex v. In the second case, it is equal to distUp[p]+1. Thus, distUp[v] is equal to the maximum of these two values. Note that you need to be clever to perform the computations in the first case in overall linear time. For this, you can find the maximum max1 and second maximum max2 of values distDown[sibling1], ..., distDown[siblingK]. After that, when distDown[v] < max1, we have max(distDown[sibling1], ..., distDown[siblingK])=max1, otherwise we have distDown[v] = max1 and max(distDown[sibling1], ..., distDown[siblingK])=max2.After computing distDown[] и distUp[], it is easy to derive the answers: it is the count of such vertices v that distDown[v] <= d && distUp[v] <= d.You can check 4302127 for an implementation of the described approach.337E - Divisor TreeLet us first show that in an optimal divisor tree only the root or a leaf can hold a value other than one of a[i]. Suppose that we have an inner vertex different from the root which holds a number X not equal to any of a[i]. Then we can exclude this vertex from the tree and tie its children to its parent without violating any of the tree's properties.Hence, our tree consists of the root, vertices with numbers a[i] tied to each other or to the root, and leaves, which are tied to vertices with numbers a[i] and contain these numbers' prime factorizations. The exception is the case when one of a[i] is written in root itself, and the case when some a[i]-s are prime themselves. Also note that in general case it's easy to count how many leaves the tree will have. This count is equal to the sum of exponents of primes in prime factorizations of those a[i]-s which are the children of the root.Since N <= 8, we can build all divisor trees which satisfy the observations we made. Let's sort numbers a[i] in descending order and recursively choose a parent for each of them from the vertices already present in the tree. Of course, tying a number X to some vertex v is only possible if the product of X and the numbers in children of v divides the number in v itself. For a[1], we have a choice — we can make it the root of the tree or a child of the root (in this case the root will hold a nominal infinity which is divisible by any number). For every next a[i], the choice is whether to tie it to the root or a vertex containing one of the previous numbers. Therefore, we only consider O(N!) trees in total.You can check 4302171 for an implementation of this idea.338D - GCD TableObservation 1. If the sequence a occurs in table G, then it should occur in row i = LCM(a[1], ..., a[k]). The proof follows. It is clear that theoretically it may only occur in rows with numbers which are multiple to i, since the row number should divide by each of a[index]. Consider some a row with number i*x, where x>1. The rows i and i*x differ only in such elements j that i*x and j both divide by some p^q (where p is prime) which does not divide i (hence, G(i*x, j) is divisible by p^q). But none of the a[index] may divide by such p^q, since then i would be also divisible by it. Therefore, if a occurs in row i*x, then it does not intersect with index j. Since it can only reside on indices where i and i*x coincide, checking only the i-th row is enough. It also clear that if i > n, the answer is NO.Observation 2. The sought index j should satisfy the following modular linear equations system: j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}In other words, j + l must divide by a[l+1] for each l=0..k-1.According to Chinese Remainder Theorem, such a system has a solution iff for each pair of indices x, y (0 <= x, y <= k-1) we have -x = -y (mod GCD(a[x+1], a[y+1])). Let's denote L = LCM(a[1], ..., a[k]). If the system has a solution, then it is singular on interval [0, L) and all the other solutions are congruent to it modulo L. Suppose that we have found the minimum non-negative j which satisfies the given system. Then, if a occurs in G, it will start from the j-th element of the i-th row. Theoretically, it may begin at any index of form j+x*L, x>=0, but since i = L, we have G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j). So it is sufficient to check whether the k consecutive elements which begin at index j in row i coincide with sequence a. It is also clear that when j > m-k+1, the answer is NO.Finally, let's consider how to solve a system of modular linear equations. We can use an auxiliary method which, given r1, m1, r2, m2, finds minimum X such that X = r1 (mod m1) and X = r2 (mod m2), or determines that such number does not exist. Let X = m1*x + r1, then we have m1*x + r1 = r2 (mod m2). This can be represented as a Diophantine equation m1*x + m2*y = r2-r1 and solved using Extended Euclidean Algorithm. The least non-negative x, if it exists, yields the sought X = m1*x + r1. Now this method can be used to find the minimum X1 which satisfies the first two equations. After that, we can say that we have a system with k-1 equation, where the first two old equations are replaced with a new j = X1 (mod LCM(a[1], a[2])), and repeat the same procedure again. After using this method k-1 times, we obtain the solution to the whole system.Also note that the proposed solution does not require long arithmetics: — The computation of LCM(a[1], ..., a[k]) can be implemented with a check before each multiplication: if the result will become larger than n, the answer is NO; — When it comes to solving the system of equations, we already know that L <= n <= 10^12, thus all the intermediate moduli will also obide to this constraint; — The Extended Euclidean Algorithm can find a solution in the same bounds as its inputs, so it will also use numbers up to 10^12.The overall complexity of the algorithm is O(k logn).338E - Optimize!Decyphering Manao's pseudocode, we unearth the following problem: you are given arrays a[1..n] and b[1..len] and a number h. Consider each subarray of a of length L. Let us call it s. Count how many of them have the property that the elements of b can be shuffled in such a way that each sum s[i]+b[i] (1<=i<=L) is at least h.First, let's solve a problem for one subarray. That is, we need to determine whether the elements of two arrays s and b can be matched in such a way that each sum is h or more. We can do the following: for each element of s, find the least element of b such that the two's sum is at least h, and erase the corresponding element from b. If we managed to pair each of the elements from s, then the arrays hold the property. Note that the elements of s can be processed in any order. If both s and b are sorted, then the idea described can be implemented in linear time.We can not achieve better complexity when considering each subarray separately, so we will try to solve the problem for several subarrays at the same time. Suppose that b is already sorted. We choose some X < len and consider a subarray a[i..i+X-1]. Let's process all the numbers from this subarray, i.e., for each of them find the least b[j] which pairs up with this number and erase it from b. The whole processing can be done in time O(n) if we have a sorted version of a and the corresponding indices computed beforehand.Now we can find the answer for every subarray s of length len which begins in segment [i-Y, i] using O(YlogY) operations, where Y=len-X. For this, we just take the Y elements which are in s but not in a[i..i+X-1] and process them against the numbers left in b. If each of them has been paired, then subarray s holds the required property, otherwise it does not. Moreover, since the subarrays we consider are overlapping, we can optimize even further and obtain amortized O(Y) complexity per subarray. To understand this, note that for processing a subarray in O(Y) time we only need to obtain its sorted version (to be more specific, the sorted version of the portion which does not overlap with a[i..i+X-1]). For the leftmost subarray we consider, we can sort its elements in usual way. For every next subarray (which differs from its predecessor in exactly two elements) we only need O(Y) operations to obtain its sorted version by updating the information from the previous subarray. Thus we have complexity O(YlogY + Y^2) of processing Y segments in total, which gives O(Y) per segment on average.Now let us take a look at the full picture. To process all subarrays of length len, we need to use the method given above for each of the segments a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], .... Therefore, we have O(N/Y) iterations of algorithm with comlexity O(N+Y^2). We need to find a value of Y that minimizes N*N/Y + N*Y, which is Y=~sqrt(N). The overall complexity is O(Nsqrt(N)). However, we need to consider the case len < sqrt(N) separately, since then Y = len - X < len. In this case, the problem can be solved in time O(N*len) with ideas similar to those described above.You can check the implementation of this idea in 4302344.P.S. The statement of the \"problem\" that Manao is solving actually contains a Georgian fairy tale. You can copy almost the same text from here and try to guess what he tale is about :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 338\\s*E"
          },
          "content_length": 15337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 1",
          "code": "1000000000 1000000000 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 2",
          "code": "(2^(n + 1)-2)*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 3",
          "code": "res %= MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 - Codeforces - Code 4",
          "code": "res = (res%MOD+MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8615",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 1",
          "code": "f[k], f[k+1], ..., f[k+n-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 2",
          "code": "f[k]=f[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 3",
          "code": "f[k+n-1]-f[k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 4",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 5",
          "code": "read(n, m, f[1..m])\nsort(f[1..m])\nbest = INFINITY\nfor k = 1 to m-n\n  best = min(best, f[k+n-1] - f[k])\nprint best",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 6",
          "code": "h*W/w = w*c/d * W/w = W*d/c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 7",
          "code": "(screen height - frame height) / (screen height) = (W*b/a - W*d/c) / (W*b/a) = (bc-ad)/bc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 8",
          "code": "w*H/h = w * W*b/a / (w*d/c) = W*b/a * c/d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 9",
          "code": "(W - W*b/a * c/d)/W = (ad-bc)/ad",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 10",
          "code": "(k*2+k)*2+m-2*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 11",
          "code": "((k*2+k)*2+k)*2+m-3*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 12",
          "code": "(2^1+2^2+...+2^X)*k + m-X*k = (2^(X+1)-2)*k + m-X*k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 13",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 14",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 15",
          "code": "X*k + (n - X*k - (n - X*k) mod k) / k * (k-1) + (n - X*k) mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 16",
          "code": "max(0, m - (n - n mod k) / k * (k-1) - n mod k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 17",
          "code": "distDown[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 18",
          "code": "distDown[v]=max(distDown[child1], distDown[child2], ..., distDown[childK])+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 19",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])+2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 20",
          "code": "distUp[p]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 21",
          "code": "distDown[sibling1], ..., distDown[siblingK]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 22",
          "code": "distDown[v] < max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 23",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 24",
          "code": "distDown[v] = max1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 25",
          "code": "max(distDown[sibling1], ..., distDown[siblingK])=max2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 26",
          "code": "distDown[v] <= d && distUp[v] <= d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 27",
          "code": "i = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 28",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 29",
          "code": "j = 0 (mod a[1])\nj + 1 = 0 (mod a[2])\n...\nj + l = 0 (mod a[l + 1])\n...\nj + k - 1 = 0 (mod a[k])\n\n<=>\n\n{j = -l (mod a[l + 1])}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 30",
          "code": "x, y (0 <= x, y <= k-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 31",
          "code": "-x = -y (mod GCD(a[x+1], a[y+1]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 32",
          "code": "L = LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 33",
          "code": "j+x*L, x>=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 34",
          "code": "G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 35",
          "code": "r1, m1, r2, m2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 36",
          "code": "X = r1 (mod m1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 37",
          "code": "X = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 38",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 39",
          "code": "m1*x + r1 = r2 (mod m2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 40",
          "code": "m1*x + m2*y = r2-r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 41",
          "code": "X = m1*x + r1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 42",
          "code": "j = X1 (mod LCM(a[1], a[2]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 43",
          "code": "LCM(a[1], ..., a[k])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 44",
          "code": "L <= n <= 10^12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 45",
          "code": "s[i]+b[i] (1<=i<=L)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 46",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 47",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 48",
          "code": "a[i..i+X-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 49",
          "code": "O(YlogY + Y^2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 50",
          "code": "a[Y..Y+len-1], a[2Y+1..2Y+len], a[3Y+2..3Y+len+1], ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 51",
          "code": "N*N/Y + N*Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 52",
          "code": "O(Nsqrt(N))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 53",
          "code": "len < sqrt(N)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 54",
          "code": "Y = len - X < len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 55",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 56",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 57",
          "code": "dp[up_lsb][down_mask1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 58",
          "code": "dp[up_rest][down_mask2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 59",
          "code": "dp[up_mask][down_mask]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 60",
          "code": "X*k + (n-X*k) / k * (k-1) >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 61",
          "code": "X + (n - n mod k) / k * (k-1) + n mod k >= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #196 — Problems Analysis - Codeforces - Code 62",
          "code": "X+(n/k)*(k-1)>=m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8629",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int len = inf.readInt(1, n, \"len\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000000, \"h\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(len, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int len = inf.readInt(1, n, \"len\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000000, \"h\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(len, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150000, \"n\");\n    inf.readSpace();\n    int len = inf.readInt(1, n, \"len\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000000, \"h\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(len, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\");\n    long long h = opt<long long>(\"h\");\n    string typea = opt<string>(\"typea\", \"random\");\n    string typeb = opt<string>(\"typeb\", \"random\");\n\n    if (len > n) {\n        fprintf(stderr, \"Error: len should be less than or equal to n.\\n\");\n        return 1;\n    }\n\n    vector<long long> b(len);\n\n    // Generate b according to typeb\n    if (typeb == \"min\") {\n        for (int i = 0; i < len; ++i)\n            b[i] = 1;\n    } else if (typeb == \"max\") {\n        for (int i = 0; i < len; ++i)\n            b[i] = 1000000000LL; // 1e9\n    } else if (typeb == \"inc\") {\n        long long start = 1;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, len - 1LL));\n        for (int i = 0; i < len; ++i) {\n            b[i] = start + i * step;\n            if (b[i] > 1000000000LL) b[i] = 1000000000LL;\n        }\n    } else if (typeb == \"dec\") {\n        long long start = 1000000000LL;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, len - 1LL));\n        for (int i = 0; i < len; ++i) {\n            b[i] = start - i * step;\n            if (b[i] < 1LL) b[i] = 1LL;\n        }\n    } else if (typeb == \"same\") {\n        long long val = rnd.next(1LL, 1000000000LL);\n        for (int i = 0; i < len; ++i)\n            b[i] = val;\n    } else { // Random\n        for (int i = 0; i < len; ++i)\n            b[i] = rnd.next(1LL, 1000000000LL);\n    }\n\n    vector<long long> a(n);\n\n    // Generate a according to typea\n    if (typea == \"min\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (typea == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000000LL; // 1e9\n    } else if (typea == \"inc\") {\n        long long start = 1;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, n - 1LL));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n            if (a[i] > 1000000000LL) a[i] = 1000000000LL;\n        }\n    } else if (typea == \"dec\") {\n        long long start = 1000000000LL;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, n - 1LL));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i * step;\n            if (a[i] < 1LL) a[i] = 1LL;\n        }\n    } else if (typea == \"same\") {\n        long long val = rnd.next(1LL, 1000000000LL);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else { // Random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, 1000000000LL);\n    }\n\n    // Output\n    printf(\"%d %d %lld\\n\", n, len, h);\n\n    for (int i = 0; i < len; ++i) {\n        printf(\"%lld\", b[i]);\n        if (i + 1 < len) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\");\n    long long h = opt<long long>(\"h\");\n    string typea = opt<string>(\"typea\", \"random\");\n    string typeb = opt<string>(\"typeb\", \"random\");\n\n    if (len > n) {\n        fprintf(stderr, \"Error: len should be less than or equal to n.\\n\");\n        return 1;\n    }\n\n    vector<long long> b(len);\n\n    // Generate b according to typeb\n    if (typeb == \"min\") {\n        for (int i = 0; i < len; ++i)\n            b[i] = 1;\n    } else if (typeb == \"max\") {\n        for (int i = 0; i < len; ++i)\n            b[i] = 1000000000LL; // 1e9\n    } else if (typeb == \"inc\") {\n        long long start = 1;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, len - 1LL));\n        for (int i = 0; i < len; ++i) {\n            b[i] = start + i * step;\n            if (b[i] > 1000000000LL) b[i] = 1000000000LL;\n        }\n    } else if (typeb == \"dec\") {\n        long long start = 1000000000LL;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, len - 1LL));\n        for (int i = 0; i < len; ++i) {\n            b[i] = start - i * step;\n            if (b[i] < 1LL) b[i] = 1LL;\n        }\n    } else if (typeb == \"same\") {\n        long long val = rnd.next(1LL, 1000000000LL);\n        for (int i = 0; i < len; ++i)\n            b[i] = val;\n    } else { // Random\n        for (int i = 0; i < len; ++i)\n            b[i] = rnd.next(1LL, 1000000000LL);\n    }\n\n    vector<long long> a(n);\n\n    // Generate a according to typea\n    if (typea == \"min\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (typea == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000000LL; // 1e9\n    } else if (typea == \"inc\") {\n        long long start = 1;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, n - 1LL));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n            if (a[i] > 1000000000LL) a[i] = 1000000000LL;\n        }\n    } else if (typea == \"dec\") {\n        long long start = 1000000000LL;\n        long long step = max(1LL, (1000000000LL - 1LL) / max(1LL, n - 1LL));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i * step;\n            if (a[i] < 1LL) a[i] = 1LL;\n        }\n    } else if (typea == \"same\") {\n        long long val = rnd.next(1LL, 1000000000LL);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else { // Random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, 1000000000LL);\n    }\n\n    // Output\n    printf(\"%d %d %lld\\n\", n, len, h);\n\n    for (int i = 0; i < len; ++i) {\n        printf(\"%lld\", b[i]);\n        if (i + 1 < len) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -len 1 -h 1 -typea min -typeb min\n./gen -n 1 -len 1 -h 1000000000 -typea max -typeb max\n./gen -n 5 -len 2 -h 10 -typea random -typeb random\n./gen -n 100 -len 100 -h 1 -typea random -typeb random\n./gen -n 1000 -len 500 -h 500000000 -typea inc -typeb dec\n./gen -n 150000 -len 1 -h 1000000000 -typea dec -typeb inc\n./gen -n 150000 -len 150000 -h 1 -typea min -typeb max\n./gen -n 150000 -len 150000 -h 1000000000 -typea max -typeb min\n./gen -n 150000 -len 75000 -h 500000000 -typea random -typeb random\n./gen -n 150000 -len 1 -h 1 -typea min -typeb min\n./gen -n 150000 -len 50000 -h 1000000000 -typea same -typeb same\n./gen -n 1000 -len 1 -h 1 -typea random -typeb random\n./gen -n 1000 -len 500 -h 1000000000 -typea inc -typeb inc\n./gen -n 1000 -len 500 -h 1000000000 -typea dec -typeb dec\n./gen -n 1000 -len 1 -h 1000000000 -typea same -typeb same\n./gen -n 99999 -len 99999 -h 1000000000 -typea max -typeb inc\n./gen -n 100000 -len 100000 -h 1 -typea inc -typeb max\n./gen -n 100000 -len 1 -h 1000000000 -typea random -typeb random\n./gen -n 100000 -len 50000 -h 500000000 -typea inc -typeb dec\n./gen -n 50000 -len 25000 -h 1000000000 -typea dec -typeb inc\n./gen -n 1 -len 1 -h 1000000000 -typea same -typeb same\n./gen -n 20000 -len 10000 -h 500000000 -typea inc -typeb random\n./gen -n 30000 -len 15000 -h 1 -typea random -typeb max\n./gen -n 40000 -len 20000 -h 1000000000 -typea random -typeb min\n./gen -n 50000 -len 50000 -h 1 -typea min -typeb min\n./gen -n 50000 -len 50000 -h 1000000000 -typea max -typeb max\n./gen -n 150000 -len 100000 -h 1000000000 -typea random -typeb random\n./gen -n 150000 -len 100000 -h 1 -typea random -typeb random\n./gen -n 100000 -len 50000 -h 1 -typea random -typeb random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:30.818046",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "339/A",
      "title": "A. Helpful Maths",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2 and 3. String s is at most 100 characters long.",
      "output_spec": "OutputPrint the new sum that Xenia can count.",
      "sample_tests": "ExamplesInputCopy3+2+1OutputCopy1+2+3InputCopy1+1+3+1+3OutputCopy1+1+1+3+3InputCopy2OutputCopy2",
      "description": "A. Helpful Maths\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2 and 3. String s is at most 100 characters long.\n\nOutputPrint the new sum that Xenia can count.\n\nInputCopy3+2+1OutputCopy1+2+3InputCopy1+1+3+1+3OutputCopy1+1+1+3+3InputCopy2OutputCopy2\n\nInputCopy3+2+1\n\nOutputCopy1+2+3\n\nInputCopy1+1+3+1+3\n\nOutputCopy1+1+1+3+3\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #197 - Codeforces",
          "content": "Hello, Codeforces.Today at 19:30 moscow time, Codeforces Round #197 will take place. Authors of this round are me and Gerald. I'd like to thank the following people for their contribution: Delinur for translation of the statements and MikeMirzayanov for creation and supportion of Codeforces.The score for problems: 500 — 1000 — 1500 — 2000 — 3000.Good luck!UPD: To make the announcement more interestiong and thrilling we decided to add a horse joke and a photo, taken during the preparation of the round.Q: What did the teacher say when the horse walked into the class?A: Why the long face?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8721",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 592
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces",
          "content": "339A - Helpful MathsTutorial by Fefer_IvanTo solve this problem we can count the number of digits 1, 2 and 3 in the input. If there are c1 digits 1, c2 digits 2 and c3 digits 3. Then we must print the sequence of c1 digits 1, c2 digits 2 and c3 digits 3. Digits must be separated by + sign.339B - Xenia and RingroadTutorial by Fefer_IvanTo solve this problem we must learn how to calculate fast enought the time, needed to travel between houses a and b. Let's consider the case when a ≤ b. Than Xenia needs b - a seconds to get from a to b. Otherwise a > b, Xenia will have to go thought house number 1. So she will need n - a + b seconds.339C - Xenia and WeightsTutorial by Fefer_IvanLet's consider the definition of balance. Balance is the difference between sum of all weights on the left pan and sum of all weights on the right pan. At the beginning balance is equal to 0. Att each step Xenia puts one weight on the pan. It means she adds to or substracts from balance integer from 1 to 10. In each odd step, the integer is added and in each even step the integer is subtracted. From the statement we know, that after each step, balance must change it sign and must not be equal to 0. So if after some step the absolute value of balance is greater than 10, Xenia can not continue. Also, it is said in the statement that we can not use two equal weigths in a row. To solve the problem, let's consider a graph, where vertices are tuples of three numbers (i, j, k), where i is a current balance, j is a weight, used in the previous step, and k is the number of the current step. Arcs of the graph must correspond to Xenias actions, described in the statement. The solution of the problme is a path from vertex (0, 0, 1) to some vertex (x, y, m), where x, y are any numbers, and m is the requared number of steps.339D - Xenia and Bit OperationsTutorial by GeraldThe problem could be solved by using a typical data structure (segment tree).The leafs of the segment tree will store the values of ai. At the vertices, the distance from which to the leafs is 1, we will store OR of the numbers from the leafs, which are the sons of this node in the segment tree. Similarly, vertices, the distance from which to the leafs is 2, we will store Xor of the numbers stored in their immediate sons. And so on. Then, the root of the tree will contain the required value v.There is no need to rebuild all the tree to perform an update operation. To do update, we should find a path from the root to the corresponding leaf and recalculate the values only at the tree vertices that are lying on that path. If everything is done correctly, then each update query will be executed in O(n) time. Also we need O(2n) memory.339E - Three SwapsTutorial by GeraldWe will call the command l, r a reverse, also we will call the row of horses an array. Suddenly, right?The problem can be solved with clever bruteforcing all possible ways to reverse an array. To begin with, assume that the reverse with l = r is ok. Our solution can find an answer with such kind of reverses. It is clear that this thing doesn't affect the solution. Because such reverses can simply be erased from the answer.The key idea: reverses split an array into no more than seven segments of the original array. In other words, imagine that the array elements was originally glued together, and each reverse cuts a segment from the array. Then the array would be cut into not more than 7 pieces.Now you can come up with the wrong solution to the problem, and then come up with optimization that turns it into right. So, bruteforce all ways to cut array into 7 or less pieces. Then bruteforce reverse operations, but each reverse operation should contain only whole pieces. It is clear that this solution is correct, One thing it does not fit the TL.How to improve it? Note that the previous solution requires the exact partition of the array only at the very end of the bruteforce. It needed to check whether it is possible to get the given array a. So, let's assume that the array was originally somehow divided into 7 parts (we don't know the exact partition), the parts can be empty. Now try to bruteforce reverses as in naive solution. One thing, in the very end of bruteforce try to find such a partition of the array to get (with fixed reverses) the given array a.The search for such a partition can be done greedily (the reader has an opportunity to come up with it himself). Author's solution does this in time proportional to the number of parts, that is, 7 operations. However, this can be done for O(n) — this should fit in TL, if you write bruteforce carefully.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 339\\s*A"
          },
          "content_length": 4621
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #197 - Codeforces - Code 1",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 2",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 3",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 4",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 5",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 6",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 7",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 8",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 9",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 10",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 1",
          "code": "Weight used               Difference in weights",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 2",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 3",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 4",
          "code": "1110000000 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 5",
          "code": "totalLeftWeight = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 6",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 7",
          "code": "totalLeftWeight = 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 8",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 9",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 10",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 11",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 12",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 13",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 14",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-3](\\\\+[1-3])*\", \"s\");\n    ensuref(s.length() <= 100, \"s must be at most 100 characters long, but s.length()=%zu\", s.length());\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-3](\\\\+[1-3])*\", \"s\");\n    ensuref(s.length() <= 100, \"s must be at most 100 characters long, but s.length()=%zu\", s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-3](\\\\+[1-3])*\", \"s\");\n    ensuref(s.length() <= 100, \"s must be at most 100 characters long, but s.length()=%zu\", s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    string input_sum = inf.readString();\n\n    map<int,int> counts_input;\n    {\n        // parse input sum\n        int n = input_sum.length();\n        for (int i = 0; i < n; i += 2) { // numbers and '+' alternate\n            char c = input_sum[i];\n            if (c != '1' && c != '2' && c != '3')\n                quitf(_fail, \"Invalid character '%c' in input sum\", c);\n            int num = c - '0';\n            counts_input[num]++;\n            if (i + 1 < n) {\n                if (input_sum[i+1] != '+')\n                    quitf(_fail, \"Invalid character '%c' in input sum, expected '+'\", input_sum[i+1]);\n            }\n        }\n    }\n\n    string output_sum = ouf.readString();\n    map<int,int> counts_output;\n    vector<int> nums_output;\n\n    // parse contestant's output sum\n    int n = output_sum.length();\n    for (int i = 0; i < n; i += 2) {\n        if (i >= n)\n            quitf(_wa, \"Incomplete sum in output\");\n        char c = output_sum[i];\n        if (c != '1' && c != '2' && c != '3')\n            quitf(_wa, \"Invalid character '%c' in output sum\", c);\n        int num = c - '0';\n        nums_output.push_back(num);\n        counts_output[num]++;\n        if (i + 1 < n) {\n            if (output_sum[i+1] != '+')\n                quitf(_wa, \"Invalid character '%c' in output sum, expected '+'\", output_sum[i+1]);\n        }\n    }\n\n    // Verify counts\n    for (int num = 1; num <= 3; ++num) {\n        if (counts_input[num] != counts_output[num]) {\n            quitf(_wa, \"The counts of number %d don't match: expected %d, found %d\", num, counts_input[num], counts_output[num]);\n        }\n    }\n\n    // Verify that nums_output is non-decreasing\n    for (int i = 1; i < (int)nums_output.size(); ++i) {\n        if (nums_output[i] < nums_output[i-1]) {\n            quitf(_wa, \"Numbers are not in non-decreasing order at position %d: %d followed by %d\", i+1, nums_output[i-1], nums_output[i]);\n        }\n    }\n\n    // All checks passed\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register testlib generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters:\n    // n: number of terms (each term is 1, 2, or 3)\n    // type: pattern to generate (\"random\", \"ascending\", \"descending\", \"all1\", \"all2\", \"all3\")\n    int n = opt<int>(\"n\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within valid range so that the resulting string\n    // is at most 100 characters. The largest valid n must satisfy\n    // (2*n - 1) <= 100, thus n <= 50. We also need n >= 1 (non-empty).\n    n = max(1, min(n, 50));\n\n    vector<int> nums(n);\n\n    if (type == \"all1\") {\n        // All 1\n        fill(nums.begin(), nums.end(), 1);\n    }\n    else if (type == \"all2\") {\n        // All 2\n        fill(nums.begin(), nums.end(), 2);\n    }\n    else if (type == \"all3\") {\n        // All 3\n        fill(nums.begin(), nums.end(), 3);\n    }\n    else if (type == \"ascending\") {\n        for (int i = 0; i < n; i++) {\n            nums[i] = rnd.next(1, 3);\n        }\n        sort(nums.begin(), nums.end());\n    }\n    else if (type == \"descending\") {\n        for (int i = 0; i < n; i++) {\n            nums[i] = rnd.next(1, 3);\n        }\n        sort(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.end());\n    }\n    else {\n        // Fallback to random or unrecognized \"type\" -> random\n        for (int i = 0; i < n; i++) {\n            nums[i] = rnd.next(1, 3);\n        }\n    }\n\n    // Print the result as \"digit1+digit2+...+digitN\"\n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\"+\");\n        printf(\"%d\", nums[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register testlib generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters:\n    // n: number of terms (each term is 1, 2, or 3)\n    // type: pattern to generate (\"random\", \"ascending\", \"descending\", \"all1\", \"all2\", \"all3\")\n    int n = opt<int>(\"n\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within valid range so that the resulting string\n    // is at most 100 characters. The largest valid n must satisfy\n    // (2*n - 1) <= 100, thus n <= 50. We also need n >= 1 (non-empty).\n    n = max(1, min(n, 50));\n\n    vector<int> nums(n);\n\n    if (type == \"all1\") {\n        // All 1\n        fill(nums.begin(), nums.end(), 1);\n    }\n    else if (type == \"all2\") {\n        // All 2\n        fill(nums.begin(), nums.end(), 2);\n    }\n    else if (type == \"all3\") {\n        // All 3\n        fill(nums.begin(), nums.end(), 3);\n    }\n    else if (type == \"ascending\") {\n        for (int i = 0; i < n; i++) {\n            nums[i] = rnd.next(1, 3);\n        }\n        sort(nums.begin(), nums.end());\n    }\n    else if (type == \"descending\") {\n        for (int i = 0; i < n; i++) {\n            nums[i] = rnd.next(1, 3);\n        }\n        sort(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.end());\n    }\n    else {\n        // Fallback to random or unrecognized \"type\" -> random\n        for (int i = 0; i < n; i++) {\n            nums[i] = rnd.next(1, 3);\n        }\n    }\n\n    // Print the result as \"digit1+digit2+...+digitN\"\n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\"+\");\n        printf(\"%d\", nums[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all1\n./gen -n 1 -type all2\n./gen -n 1 -type all3\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type ascending\n./gen -n 5 -type descending\n./gen -n 5 -type random\n./gen -n 6 -type ascending\n./gen -n 7 -type descending\n./gen -n 8 -type all1\n./gen -n 8 -type all2\n./gen -n 8 -type all3\n./gen -n 9 -type random\n./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 10 -type random\n./gen -n 10 -type all1\n./gen -n 10 -type all2\n./gen -n 10 -type all3\n./gen -n 50 -type random\n./gen -n 50 -type ascending\n./gen -n 50 -type descending\n./gen -n 50 -type all1\n./gen -n 50 -type all2\n./gen -n 50 -type all3\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:32.499056",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "339/B",
      "title": "B. Xenia and Ringroad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105). The second line contains m integers a1, a2, ..., am (1 ≤ ai ≤ n). Note that Xenia can have multiple consecutive tasks in one house.",
      "output_spec": "OutputPrint a single integer — the time Xenia needs to complete all tasks.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy4 33 2 3OutputCopy6InputCopy4 32 3 3OutputCopy2",
      "description": "B. Xenia and Ringroad\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105). The second line contains m integers a1, a2, ..., am (1 ≤ ai ≤ n). Note that Xenia can have multiple consecutive tasks in one house.\n\nOutputPrint a single integer — the time Xenia needs to complete all tasks.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy4 33 2 3OutputCopy6InputCopy4 32 3 3OutputCopy2\n\nInputCopy4 33 2 3\n\nOutputCopy6\n\nInputCopy4 32 3 3\n\nOutputCopy2\n\nNoteIn the first test example the sequence of Xenia's moves along the ringroad looks as follows: 1 → 2 → 3 → 4 → 1 → 2 → 3. This is optimal sequence. So, she needs 6 time units.",
      "solutions": [
        {
          "title": "Codeforces Round #197 - Codeforces",
          "content": "Hello, Codeforces.Today at 19:30 moscow time, Codeforces Round #197 will take place. Authors of this round are me and Gerald. I'd like to thank the following people for their contribution: Delinur for translation of the statements and MikeMirzayanov for creation and supportion of Codeforces.The score for problems: 500 — 1000 — 1500 — 2000 — 3000.Good luck!UPD: To make the announcement more interestiong and thrilling we decided to add a horse joke and a photo, taken during the preparation of the round.Q: What did the teacher say when the horse walked into the class?A: Why the long face?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8721",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 592
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces",
          "content": "339A - Helpful MathsTutorial by Fefer_IvanTo solve this problem we can count the number of digits 1, 2 and 3 in the input. If there are c1 digits 1, c2 digits 2 and c3 digits 3. Then we must print the sequence of c1 digits 1, c2 digits 2 and c3 digits 3. Digits must be separated by + sign.339B - Xenia and RingroadTutorial by Fefer_IvanTo solve this problem we must learn how to calculate fast enought the time, needed to travel between houses a and b. Let's consider the case when a ≤ b. Than Xenia needs b - a seconds to get from a to b. Otherwise a > b, Xenia will have to go thought house number 1. So she will need n - a + b seconds.339C - Xenia and WeightsTutorial by Fefer_IvanLet's consider the definition of balance. Balance is the difference between sum of all weights on the left pan and sum of all weights on the right pan. At the beginning balance is equal to 0. Att each step Xenia puts one weight on the pan. It means she adds to or substracts from balance integer from 1 to 10. In each odd step, the integer is added and in each even step the integer is subtracted. From the statement we know, that after each step, balance must change it sign and must not be equal to 0. So if after some step the absolute value of balance is greater than 10, Xenia can not continue. Also, it is said in the statement that we can not use two equal weigths in a row. To solve the problem, let's consider a graph, where vertices are tuples of three numbers (i, j, k), where i is a current balance, j is a weight, used in the previous step, and k is the number of the current step. Arcs of the graph must correspond to Xenias actions, described in the statement. The solution of the problme is a path from vertex (0, 0, 1) to some vertex (x, y, m), where x, y are any numbers, and m is the requared number of steps.339D - Xenia and Bit OperationsTutorial by GeraldThe problem could be solved by using a typical data structure (segment tree).The leafs of the segment tree will store the values of ai. At the vertices, the distance from which to the leafs is 1, we will store OR of the numbers from the leafs, which are the sons of this node in the segment tree. Similarly, vertices, the distance from which to the leafs is 2, we will store Xor of the numbers stored in their immediate sons. And so on. Then, the root of the tree will contain the required value v.There is no need to rebuild all the tree to perform an update operation. To do update, we should find a path from the root to the corresponding leaf and recalculate the values only at the tree vertices that are lying on that path. If everything is done correctly, then each update query will be executed in O(n) time. Also we need O(2n) memory.339E - Three SwapsTutorial by GeraldWe will call the command l, r a reverse, also we will call the row of horses an array. Suddenly, right?The problem can be solved with clever bruteforcing all possible ways to reverse an array. To begin with, assume that the reverse with l = r is ok. Our solution can find an answer with such kind of reverses. It is clear that this thing doesn't affect the solution. Because such reverses can simply be erased from the answer.The key idea: reverses split an array into no more than seven segments of the original array. In other words, imagine that the array elements was originally glued together, and each reverse cuts a segment from the array. Then the array would be cut into not more than 7 pieces.Now you can come up with the wrong solution to the problem, and then come up with optimization that turns it into right. So, bruteforce all ways to cut array into 7 or less pieces. Then bruteforce reverse operations, but each reverse operation should contain only whole pieces. It is clear that this solution is correct, One thing it does not fit the TL.How to improve it? Note that the previous solution requires the exact partition of the array only at the very end of the bruteforce. It needed to check whether it is possible to get the given array a. So, let's assume that the array was originally somehow divided into 7 parts (we don't know the exact partition), the parts can be empty. Now try to bruteforce reverses as in naive solution. One thing, in the very end of bruteforce try to find such a partition of the array to get (with fixed reverses) the given array a.The search for such a partition can be done greedily (the reader has an opportunity to come up with it himself). Author's solution does this in time proportional to the number of parts, that is, 7 operations. However, this can be done for O(n) — this should fit in TL, if you write bruteforce carefully.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 339\\s*B"
          },
          "content_length": 4621
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #197 - Codeforces - Code 1",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 2",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 3",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 4",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 5",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 6",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 7",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 8",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 9",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 10",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 1",
          "code": "Weight used               Difference in weights",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 2",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 3",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 4",
          "code": "1110000000 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 5",
          "code": "totalLeftWeight = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 6",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 7",
          "code": "totalLeftWeight = 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 8",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 9",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 10",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 11",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 12",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 13",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 14",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, n);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, n);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, n);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n\n    if (type == \"same\") {\n        int x = opt<int>(\"x\", 1); // default to 1\n        ensuref(1 <= x && x <= n, \"Invalid x value for 'same' type\");\n        fill(a.begin(), a.end(), x);\n    } else if (type == \"increasing\") {\n        int start = opt<int>(\"start\", 1); // starting point\n        ensuref(1 <= start && start <= n, \"Invalid start value for 'increasing' type\");\n        int current = start;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = current % n + 1; // increment and wrap around\n        }\n    } else if (type == \"decreasing\") {\n        int start = opt<int>(\"start\", n);\n        ensuref(1 <= start && start <= n, \"Invalid start value for 'decreasing' type\");\n        int current = start;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = (current + n - 2) % n + 1; // decrement and wrap around\n        }\n    } else if (type == \"alternating\") {\n        int x = opt<int>(\"x\", 1);\n        int y = opt<int>(\"y\", n);\n        ensuref(1 <= x && x <= n && 1 <= y && y <= n, \"Invalid x or y value for 'alternating' type\");\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else if (type == \"wrap_around\") {\n        int start = opt<int>(\"start\", n);\n        ensuref(1 <= start && start <= n, \"Invalid start value for 'wrap_around' type\");\n        int current = start;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = (current + n - 2) % n + 1; // decrement and wrap around\n        }\n    } else if (type == \"big_move\") {\n        // Maximize movement per step\n        int current = 1;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = (current + n - 2) % n + 1;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == m ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n\n    if (type == \"same\") {\n        int x = opt<int>(\"x\", 1); // default to 1\n        ensuref(1 <= x && x <= n, \"Invalid x value for 'same' type\");\n        fill(a.begin(), a.end(), x);\n    } else if (type == \"increasing\") {\n        int start = opt<int>(\"start\", 1); // starting point\n        ensuref(1 <= start && start <= n, \"Invalid start value for 'increasing' type\");\n        int current = start;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = current % n + 1; // increment and wrap around\n        }\n    } else if (type == \"decreasing\") {\n        int start = opt<int>(\"start\", n);\n        ensuref(1 <= start && start <= n, \"Invalid start value for 'decreasing' type\");\n        int current = start;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = (current + n - 2) % n + 1; // decrement and wrap around\n        }\n    } else if (type == \"alternating\") {\n        int x = opt<int>(\"x\", 1);\n        int y = opt<int>(\"y\", n);\n        ensuref(1 <= x && x <= n && 1 <= y && y <= n, \"Invalid x or y value for 'alternating' type\");\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else if (type == \"wrap_around\") {\n        int start = opt<int>(\"start\", n);\n        ensuref(1 <= start && start <= n, \"Invalid start value for 'wrap_around' type\");\n        int current = start;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = (current + n - 2) % n + 1; // decrement and wrap around\n        }\n    } else if (type == \"big_move\") {\n        // Maximize movement per step\n        int current = 1;\n        for (int i = 0; i < m; ++i) {\n            a[i] = current;\n            current = (current + n - 2) % n + 1;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == m ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 10 -type same -x 5\n./gen -n 10 -m 10 -type increasing\n./gen -n 10 -m 10 -type decreasing\n./gen -n 10 -m 10 -type alternating -x 3 -y 7\n./gen -n 10 -m 10 -type wrap_around\n./gen -n 10 -m 10 -type big_move\n./gen -n 10 -m 10 -type random\n\n./gen -n 100 -m 100 -type same -x 1\n./gen -n 100 -m 100 -type increasing -start 50\n./gen -n 100 -m 100 -type decreasing -start 100\n./gen -n 100 -m 100 -type alternating -x 1 -y 100\n./gen -n 100 -m 100 -type wrap_around -start 100\n./gen -n 100 -m 100 -type big_move\n./gen -n 100 -m 100 -type random\n\n./gen -n 1000 -m 1000 -type same -x 500\n./gen -n 1000 -m 1000 -type increasing -start 999\n./gen -n 1000 -m 1000 -type decreasing -start 1000\n./gen -n 1000 -m 1000 -type alternating -x 1 -y 1000\n./gen -n 1000 -m 1000 -type wrap_around -start 1\n./gen -n 1000 -m 1000 -type big_move\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 100000 -m 100000 -type same -x 100000\n./gen -n 100000 -m 100000 -type increasing -start 1\n./gen -n 100000 -m 100000 -type decreasing -start 100000\n./gen -n 100000 -m 100000 -type alternating -x 1 -y 100000\n./gen -n 100000 -m 100000 -type wrap_around -start 50000\n./gen -n 100000 -m 100000 -type big_move\n./gen -n 100000 -m 100000 -type random\n\n# Test cases intended to test overflow possibilities\n./gen -n 100000 -m 100000 -type big_move\n\n# Test cases where there is no movement (all tasks at the same house)\n./gen -n 100000 -m 100000 -type same -x 1\n\n# Test cases that involve wrap-around movement\n./gen -n 100000 -m 100000 -type wrap_around -start 1\n\n# Random test cases with different n and m\n./gen -n 99999 -m 1 -type random\n./gen -n 2 -m 100000 -type random\n\n# Edge case test with minimal m\n./gen -n 2 -m 1 -type same -x 2\n./gen -n 100000 -m 1 -type same -x 100000\n\n# Stress test with maximum n and m values\n./gen -n 100000 -m 100000 -type random\n\n# Test case with maximum n and minimum m\n./gen -n 100000 -m 1 -type random\n\n# Test case with minimum n and maximum m\n./gen -n 2 -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:34.739429",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "339/C",
      "title": "C. Ксюша и гири",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записана строка, состоящая из ровно десяти нулей и единиц: i-тый (i ≥ 1) символ в этой строке равен «1», если у Ксюши имеются гирьки, которые весят i килограмм, и равен «0» иначе. Во второй строке записано целое число m (1 ≤ m ≤ 1000).",
      "output_spec": "Выходные данныеВ первой строке выведите «YES», если существует способ выложить m гирек на весы, соблюдая все правила, иначе в первой строке выведите «NO». Если выложить m гирек на весы возможно, то в следующей строке выведите m целых чисел — веса гирек в порядке их выкладывания на весы.Если существует несколько решений, разрешается вывести любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать00000001013Выходные данныеСкопироватьYES8 10 8Входные данныеСкопировать10000000002Выходные данныеСкопироватьNO",
      "description": "C. Ксюша и гири\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записана строка, состоящая из ровно десяти нулей и единиц: i-тый (i ≥ 1) символ в этой строке равен «1», если у Ксюши имеются гирьки, которые весят i килограмм, и равен «0» иначе. Во второй строке записано целое число m (1 ≤ m ≤ 1000).\n\nВходные данные\n\nВыходные данныеВ первой строке выведите «YES», если существует способ выложить m гирек на весы, соблюдая все правила, иначе в первой строке выведите «NO». Если выложить m гирек на весы возможно, то в следующей строке выведите m целых чисел — веса гирек в порядке их выкладывания на весы.Если существует несколько решений, разрешается вывести любое.\n\nВыходные данные\n\nВходные данныеСкопировать00000001013Выходные данныеСкопироватьYES8 10 8Входные данныеСкопировать10000000002Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать00000001013\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES8 10 8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10000000002\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #197 - Codeforces",
          "content": "Добрый день, Codeforces.Сегодня в 19:30 по московскому времени состоится Codeforces Round #197. Авторами этого раунда являются я и Gerald. Условия переводила Delinur, за что ей моя искренная благодарность. Так же спасибо MikeMirzayanov за созданиe и поддержку Codeforces.Стоимости задач: 500 — 1000 — 1500 — 2000 — 3000.Удачи!UPD: Чтобы сделать анонс более интересным и увлекательным мы считаем необходимым вставить в анонс шутку про коней и фотографию, на которой изображен процесс подготовки раунда.Воспитательница в детсаду:- Коновалов, ты зачем сломал Конюхову его игрушечного коня?!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8721",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 587
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces",
          "content": "339A - Математика спешит на помощьРазбор написан Fefer_IvanДля решения этой задачи можно посчитать количество цифр 1, 2 и 3 во входных данных. Пусть в данных c1 цифр 1, c2 цифр 2 и c3 цифр 3. Тогда необходимо вывести последовательность из c1 цифр 1, c2 цифр 2 и c3 цифр 3, разделяя соседние цифры знаком +.339B - Ксюша и кольцевая дорогаРазбор написан Fefer_IvanДля решения этой задачи необходимо быстро вычислять время на перемещение между зданиями a и b. Пусть a ≤ b, тогда Ксения попадет из a в b за b - a шагов. Иначе, т.е. если a > b, Ксении придется ехать через здание с номером 1. Таким образом ей потребуется совершить n - a + b шагов.339C - Ксюша и гириРазбор написан Fefer_IvanДля решения этой задачи введем понятия баланса. Баланс — это разность суммы весов гирь на левой чаше весов и суммы весов гирь на правой чаше. В самом начале, баланс равен нулю. На каждом шаге Ксения кладет одну гирю на одну из чаш весов, следовательно добавляет или вычитает из баланса число от 1 до 10. Причем на каждом нечетном шаге число добавляется, а на каждом четном — вычитается. При этом по условию после каждого шага баланс не должен быть равен нулю и знак баланса должен изменятся. Из этого следует, что если на каком-то этапе баланс стал больше 10, то продолжить последовательность будет невозможно. Так же по условию нельза использовать одно число два раза подряд. Для решения рассмотрим граф, в котором вершины — это тройки чисел (i, j, k), где i — это текущий баланс, j — это вес, использованный на предыдущем шаге, а k — это номер текущего шага. Дуги этого графа должны соответствовать тому, что Ксения на очередном шаге кладет очередную гирю по условию задачи. Тогда для решения задачи необходимо найти в этом графе путь из вершины (0, 0, 1) до любой вершины вида (x, y, m), где x, y — произвольные числа, а m — это необходимое количество шагов.339D - Ксюша и битовые операцииРазбор написан GeraldЗадачу можно было решить, используя структуру данных дерево отрезков. В листьях дерева отрезков будем хранить сами значения ai. В вершинах, расстояние от которой до листьев равно 1, будем хранить OR чисел в листьях, которые являются сыновьями этой вершины в дереве отрезков. Аналогично, в вершинах, расстояние от которых до листьев равно 2, будет хранить xor чисел, хранящихся в их непосредственных сыновьях. И так далее. Тогда в корне дерева и будет содержаться требуемое значение v.Для выполнения операции обновления элемента не нужно перестраивать все дерево. Нужно найти путь от корня до листа, который соотвествует позиции обновления, и пересчитать значения только в вершинах дерева отрезков, которые лежат на этом пути. Если все делать правильно, то каждый запрос обновления будет выполняться за O(n). Памяти при этом требуется O(2n).339E - Три переворотаРазбор написан GeraldБудем называть команды из условия операциями реверса, а ряд коней будем называть массив. Неожиданно, да?Задача решается перебором все возможных вариантов. Для начала предположим, что реверс l = r допустим. Найденное нами решение может содержать такие реверсы. Понятно, что решению задачи это никак не помешает. Посколько такие реверсы можно просто не выводить. Это ничего не ухудшит.Следующее ключевое утверждение: операции реверса разбивают массив на не более чем 7 отрезков первоначального массива. Другими словами, представим, что массив изначально склеен, а каждая операция реверса вырезает из массива отрезок и переворачивает его. Тогда массив в конце окажется разрезан не более чем на 7 кусочков.Теперь можно придумать неправильное решение задачи, а потом придумать оптимизацию, которая превращает его в правильное. Переберем как мы разобьем массив и на сколько кусочков. А теперь будет перебирать операции реверса, но при этом операции реверса должны захватывать кусочки только целиком. Понятно, что такое решение правильное, только оно не укладывается в TL.Как его улучшить? Заметим, что в предыдущем решении конкретное разбиение массива требуется нам только в самом конце перебора для проверки, можно ли с таким разбиением так пореверсить массив, чтобы получить то, что задано в input. Поэтому, давайте считать, что массив изначально как-то разделен на 7 частей, причем некоторые части будут, возможно, пустые. Теперь будет перебирать реверсы как и в наивном решении. Только теперь в том месте, где нужна проверка, мы не будем пользоваться конкретным разбиением, а будем искать такое разбиение на части, что зафиксированные перевороты на таком разбиении дадут наш массив.Поиск такого разбиения можно выполнить жадно (читателю предоставляется возможность самому подумать как). Авторское решение делает это за количество блоков в разбиении, то есть за 7 операций. Но, можно сделать это и за O(n) — это должно проходить в TL, если написать отсечения в переборе.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 339\\s*C"
          },
          "content_length": 4749
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #197 - Codeforces - Code 1",
          "code": "7\n  6 7 1 2 4 3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 2",
          "code": "7\n  6 7 1 2 4 3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 3",
          "code": "3\n  5 6\n  2 7\n  1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 4",
          "code": "3\n  5 6\n  2 7\n  1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 5",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 6",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 7",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 8",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 9",
          "code": "bool dp[n][prev][balance]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 10",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 11",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 12",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 13",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 14",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 15",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 1",
          "code": "f[abs(i — j)][f[i][j][k]][k — 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 2",
          "code": "Weight used               Difference in weights",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 3",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 4",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 5",
          "code": "1110000000 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 6",
          "code": "totalLeftWeight = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 7",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 8",
          "code": "totalLeftWeight = 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 9",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 10",
          "code": "0100010100\n6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 11",
          "code": "0100010100\n6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 12",
          "code": "YES\n6 8 6 8 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 13",
          "code": "YES\n6 8 6 8 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 14",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 15",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 16",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 17",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 18",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 19",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the string consisting of exactly 10 zeroes and ones\n    string weights = inf.readLine(\"[01]{10}\", \"weights\");\n    // Read m, ensuring it's an integer between 1 and 1000\n    int m = inf.readInt(1, 1000, \"m\");\n    // Ensure that after m there's nothing else on the line\n    inf.readEoln();\n    // Ensure there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the string consisting of exactly 10 zeroes and ones\n    string weights = inf.readLine(\"[01]{10}\", \"weights\");\n    // Read m, ensuring it's an integer between 1 and 1000\n    int m = inf.readInt(1, 1000, \"m\");\n    // Ensure that after m there's nothing else on the line\n    inf.readEoln();\n    // Ensure there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the string consisting of exactly 10 zeroes and ones\n    string weights = inf.readLine(\"[01]{10}\", \"weights\");\n    // Read m, ensuring it's an integer between 1 and 1000\n    int m = inf.readInt(1, 1000, \"m\");\n    // Ensure that after m there's nothing else on the line\n    inf.readEoln();\n    // Ensure there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This problem has multiple valid answers (if a solution exists). Therefore,\n  we provide a custom checker that verifies whether the contestant's output\n  is correct according to the rules:\n\n  1) The answer must be either \"YES\" or \"NO\".\n  2) If the answer is \"YES\", it must be followed by exactly m integers, each\n     in the range [1..10] and corresponding to a weight type that is available.\n     - No two consecutive chosen weights can be the same.\n     - After placing each weight, the chosen scalepan must strictly outweigh the other.\n       (1st weight on left, 2nd on right, 3rd on left, ...)\n  3) If the official solution says \"NO\", but the contestant finds a valid solution,\n     we judge the official solution as incorrect (quitf(_fail)).\n  4) If the official solution says \"YES\" but the contestant says \"NO\", the\n     contestant is wrong (quitf(_wa)).\n*/\n\nstatic bool readSolution(InStream &stream, bool isJury,\n                         const string &available, int m)\n{\n    // verdict must be either \"YES\" or \"NO\"\n    string verdict = stream.readToken();\n    if (verdict != \"YES\" && verdict != \"NO\")\n        stream.quitf(isJury ? _fail : _wa,\n                     \"First word of output must be YES or NO, found '%s'\",\n                     verdict.c_str());\n\n    // If \"NO\", then we expect no further meaningful tokens.\n    if (verdict == \"NO\")\n    {\n        // Ensure there are no extra tokens after \"NO\"\n        if (!stream.seekEof())\n        {\n            stream.quitf(isJury ? _fail : _wa,\n                         \"Extra data after NO in output\");\n        }\n        return false; // Means no solution claimed\n    }\n\n    // Otherwise, \"YES\" branch:\n    // Must read exactly m integers (each between 1..10), checking availability.\n    vector<int> weights(m);\n    for (int i = 0; i < m; i++)\n    {\n        weights[i] = stream.readInt(1, 10,\n                                    format(\"weight #%d\", i + 1).c_str());\n        if (available[weights[i] - 1] == '0')\n        {\n            stream.quitf(isJury ? _fail : _wa,\n                         \"weight %d (position %d) is not available\",\n                         weights[i], i + 1);\n        }\n    }\n\n    // Check that no two consecutive weights are the same\n    for (int i = 0; i + 1 < m; i++)\n    {\n        if (weights[i] == weights[i + 1])\n        {\n            stream.quitf(isJury ? _fail : _wa,\n                         \"two consecutive weights are identical at positions %d and %d\",\n                         i + 1, i + 2);\n        }\n    }\n\n    // Now verify the \"pan must outweigh the other\" constraint after each weight.\n    // i-th weight (0-based):\n    //   - if i is even => place on left, so sumLeft > sumRight\n    //   - if i is odd  => place on right, so sumRight > sumLeft\n    long long sumLeft = 0, sumRight = 0;\n    for (int i = 0; i < m; i++)\n    {\n        if (i % 2 == 0)\n        {\n            sumLeft += weights[i];\n            if (sumLeft <= sumRight)\n            {\n                stream.quitf(isJury ? _fail : _wa,\n                             \"after placing the %d-th weight (%d) on the left, sumLeft = %lld, sumRight = %lld (not strictly greater)\",\n                             i + 1, weights[i], sumLeft, sumRight);\n            }\n        }\n        else\n        {\n            sumRight += weights[i];\n            if (sumRight <= sumLeft)\n            {\n                stream.quitf(isJury ? _fail : _wa,\n                             \"after placing the %d-th weight (%d) on the right, sumRight = %lld, sumLeft = %lld (not strictly greater)\",\n                             i + 1, weights[i], sumRight, sumLeft);\n            }\n        }\n    }\n\n    return true; // Means solution claimed and it is valid\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read the problem input from inf\n    // 1) A 10-char string of '0'/'1' (available weights)\n    // 2) An integer m\n    string available = inf.readToken();  // exactly 10 chars\n    int m = inf.readInt(1, 1000, \"m\");\n\n    // Read jury's solution from ans\n    bool jurySolExists = readSolution(ans, /*isJury=*/true, available, m);\n\n    // Read participant's solution from ouf\n    bool partSolExists = readSolution(ouf, /*isJury=*/false, available, m);\n\n    // Compare official solution and participant's solution\n    if (jurySolExists)\n    {\n        // Official says \"YES\"\n        if (!partSolExists)\n            quitf(_wa, \"Jury has a valid solution but participant answers NO\");\n        else\n            // Both say YES, participant solution is valid\n            quitf(_ok, \"solution is correct\");\n    }\n    else\n    {\n        // Official says \"NO\"\n        if (partSolExists)\n            // Participant found a valid solution, jury says none => jury is wrong\n            quitf(_fail, \"Participant found a solution but jury says NO\");\n        else\n            // Both say NO\n            quitf(_ok, \"no solution claimed by participant and jury\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\", \"random\");\n    \n    int m;\n    string s;  // To store the zero-one string of available weights.\n\n    if (type == \"random\") {\n        // Generate random s with at least one '1'\n        do {\n            s = \"\";\n            for (int i = 0; i < 10; ++i) {\n                s += (rnd.next(2) ? '1' : '0');\n            }\n        } while (s.find('1') == string::npos);  // Ensure at least one '1'\n        \n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    } else if (type == \"impossible\") {\n        // Generate s such that it's impossible to find a sequence\n        // For example, only one weight is available\n        // And m >= 2\n        s = \"0000000001\";  // Only weight 10 is available\n        m = opt<int>(\"m\", rnd.next(2, 1000));  // m >=2\n    }\n    else if (type == \"one_weight_possible\") {\n        // Only one weight is available, m=1\n        s = \"0000000001\";  // Only weight 10 is available\n        m = opt<int>(\"m\", 1);\n    }\n    else if (type == \"one_weight_impossible\") {\n        // Only one weight is available, m>=2\n        s = \"0000000001\";  // Only weight 10 is available\n        m = opt<int>(\"m\", rnd.next(2, 1000)); // With m >=2, impossible\n    }\n    else if (type == \"two_weights\") {\n        // Only two weights are available\n        s = \"0100000100\";  // Let's say weights 2 and 7 are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"max_m\") {\n        // m = 1000\n        m = 1000;\n        // All weights are available\n        s = \"1111111111\";\n    }\n    else if (type == \"min_m\") {\n        // m=1\n        m = 1;\n        // Random s with at least one '1'\n        do {\n            s = \"\";\n            for (int i = 0; i < 10; ++i) {\n                s += (rnd.next(2) ? '1' : '0');\n            }\n        } while (s.find('1') == string::npos);\n    }\n    else if (type == \"small_weights\") {\n        // Only weights 1-5 are available\n        s = \"1111100000\"; // Weights 1-5 are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"large_weights\") {\n        // Only weights 6-10 are available\n        s = \"0000011111\"; // Weights 6-10 are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"max_weights\") {\n        // All weights are available\n        s = \"1111111111\"; // All weights are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"no_weights\") {\n        // No weights are available\n        s = \"0000000000\";\n        // m can be any value\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else {\n        // Default case, random s with at least one '1'\n        do {\n            s = \"\";\n            for (int i = 0; i < 10; ++i) {\n                s += (rnd.next(2) ? '1' : '0');\n            }\n        } while (s.find('1') == string::npos);\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n\n    // Output s and m\n    cout << s << endl;\n    cout << m << endl;\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\", \"random\");\n    \n    int m;\n    string s;  // To store the zero-one string of available weights.\n\n    if (type == \"random\") {\n        // Generate random s with at least one '1'\n        do {\n            s = \"\";\n            for (int i = 0; i < 10; ++i) {\n                s += (rnd.next(2) ? '1' : '0');\n            }\n        } while (s.find('1') == string::npos);  // Ensure at least one '1'\n        \n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    } else if (type == \"impossible\") {\n        // Generate s such that it's impossible to find a sequence\n        // For example, only one weight is available\n        // And m >= 2\n        s = \"0000000001\";  // Only weight 10 is available\n        m = opt<int>(\"m\", rnd.next(2, 1000));  // m >=2\n    }\n    else if (type == \"one_weight_possible\") {\n        // Only one weight is available, m=1\n        s = \"0000000001\";  // Only weight 10 is available\n        m = opt<int>(\"m\", 1);\n    }\n    else if (type == \"one_weight_impossible\") {\n        // Only one weight is available, m>=2\n        s = \"0000000001\";  // Only weight 10 is available\n        m = opt<int>(\"m\", rnd.next(2, 1000)); // With m >=2, impossible\n    }\n    else if (type == \"two_weights\") {\n        // Only two weights are available\n        s = \"0100000100\";  // Let's say weights 2 and 7 are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"max_m\") {\n        // m = 1000\n        m = 1000;\n        // All weights are available\n        s = \"1111111111\";\n    }\n    else if (type == \"min_m\") {\n        // m=1\n        m = 1;\n        // Random s with at least one '1'\n        do {\n            s = \"\";\n            for (int i = 0; i < 10; ++i) {\n                s += (rnd.next(2) ? '1' : '0');\n            }\n        } while (s.find('1') == string::npos);\n    }\n    else if (type == \"small_weights\") {\n        // Only weights 1-5 are available\n        s = \"1111100000\"; // Weights 1-5 are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"large_weights\") {\n        // Only weights 6-10 are available\n        s = \"0000011111\"; // Weights 6-10 are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"max_weights\") {\n        // All weights are available\n        s = \"1111111111\"; // All weights are available\n        // m can be from 1 to 1000\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else if (type == \"no_weights\") {\n        // No weights are available\n        s = \"0000000000\";\n        // m can be any value\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n    else {\n        // Default case, random s with at least one '1'\n        do {\n            s = \"\";\n            for (int i = 0; i < 10; ++i) {\n                s += (rnd.next(2) ? '1' : '0');\n            }\n        } while (s.find('1') == string::npos);\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n    }\n\n    // Output s and m\n    cout << s << endl;\n    cout << m << endl;\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -m 10\n./gen -type random -m 100\n./gen -type random -m 500\n./gen -type random -m 1000\n\n./gen -type impossible -m 2\n./gen -type impossible -m 500\n./gen -type impossible -m 1000\n\n./gen -type one_weight_possible -m 1\n\n./gen -type one_weight_impossible -m 2\n./gen -type one_weight_impossible -m 500\n\n./gen -type two_weights -m 1\n./gen -type two_weights -m 500\n./gen -type two_weights -m 1000\n\n./gen -type max_m\n\n./gen -type min_m\n\n./gen -type small_weights -m 10\n./gen -type small_weights -m 100\n\n./gen -type large_weights -m 10\n./gen -type large_weights -m 100\n\n./gen -type max_weights -m 500\n\n./gen -type no_weights\n\n./gen -type random -m 1\n./gen -type random -m 250\n./gen -type random -m 750\n./gen -type random -m 999\n\n./gen -type random\n./gen -type small_weights\n./gen -type large_weights\n./gen -type max_weights\n./gen -type min_m\n./gen -type max_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:36.883396",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "339/D",
      "title": "D. Ксюша и битовые операции",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n ≤ 17, 1 ≤ m ≤ 105). В следующей строке записаны 2n целых чисел a1, a2, ..., a2n (0 ≤ ai < 230). В каждой из следующих m строк записаны запросы. В i-ой строке записаны целые числа pi, bi (1 ≤ pi ≤ 2n, 0 ≤ bi < 230) — i-ый запрос.",
      "output_spec": "Выходные данныеВыведите m целых чисел — i-ое число обозначает значение v посчитанное для последовательности a после выполнения i-ого запроса.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 41 6 3 51 43 41 21 2Выходные данныеСкопировать1333",
      "description": "D. Ксюша и битовые операции\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n ≤ 17, 1 ≤ m ≤ 105). В следующей строке записаны 2n целых чисел a1, a2, ..., a2n (0 ≤ ai < 230). В каждой из следующих m строк записаны запросы. В i-ой строке записаны целые числа pi, bi (1 ≤ pi ≤ 2n, 0 ≤ bi < 230) — i-ый запрос.\n\nВходные данные\n\nВыходные данныеВыведите m целых чисел — i-ое число обозначает значение v посчитанное для последовательности a после выполнения i-ого запроса.\n\nВыходные данные\n\nВходные данныеСкопировать2 41 6 3 51 43 41 21 2Выходные данныеСкопировать1333\n\nВходные данныеСкопировать2 41 6 3 51 43 41 21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1333\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеДля справок по битовым операциям вы можете использовать информацию по ссылке: http://ru.wikipedia.org/wiki/Битовые_операции",
      "solutions": [
        {
          "title": "Codeforces Round #197 - Codeforces",
          "content": "Добрый день, Codeforces.Сегодня в 19:30 по московскому времени состоится Codeforces Round #197. Авторами этого раунда являются я и Gerald. Условия переводила Delinur, за что ей моя искренная благодарность. Так же спасибо MikeMirzayanov за созданиe и поддержку Codeforces.Стоимости задач: 500 — 1000 — 1500 — 2000 — 3000.Удачи!UPD: Чтобы сделать анонс более интересным и увлекательным мы считаем необходимым вставить в анонс шутку про коней и фотографию, на которой изображен процесс подготовки раунда.Воспитательница в детсаду:- Коновалов, ты зачем сломал Конюхову его игрушечного коня?!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8721",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 587
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces",
          "content": "339A - Математика спешит на помощьРазбор написан Fefer_IvanДля решения этой задачи можно посчитать количество цифр 1, 2 и 3 во входных данных. Пусть в данных c1 цифр 1, c2 цифр 2 и c3 цифр 3. Тогда необходимо вывести последовательность из c1 цифр 1, c2 цифр 2 и c3 цифр 3, разделяя соседние цифры знаком +.339B - Ксюша и кольцевая дорогаРазбор написан Fefer_IvanДля решения этой задачи необходимо быстро вычислять время на перемещение между зданиями a и b. Пусть a ≤ b, тогда Ксения попадет из a в b за b - a шагов. Иначе, т.е. если a > b, Ксении придется ехать через здание с номером 1. Таким образом ей потребуется совершить n - a + b шагов.339C - Ксюша и гириРазбор написан Fefer_IvanДля решения этой задачи введем понятия баланса. Баланс — это разность суммы весов гирь на левой чаше весов и суммы весов гирь на правой чаше. В самом начале, баланс равен нулю. На каждом шаге Ксения кладет одну гирю на одну из чаш весов, следовательно добавляет или вычитает из баланса число от 1 до 10. Причем на каждом нечетном шаге число добавляется, а на каждом четном — вычитается. При этом по условию после каждого шага баланс не должен быть равен нулю и знак баланса должен изменятся. Из этого следует, что если на каком-то этапе баланс стал больше 10, то продолжить последовательность будет невозможно. Так же по условию нельза использовать одно число два раза подряд. Для решения рассмотрим граф, в котором вершины — это тройки чисел (i, j, k), где i — это текущий баланс, j — это вес, использованный на предыдущем шаге, а k — это номер текущего шага. Дуги этого графа должны соответствовать тому, что Ксения на очередном шаге кладет очередную гирю по условию задачи. Тогда для решения задачи необходимо найти в этом графе путь из вершины (0, 0, 1) до любой вершины вида (x, y, m), где x, y — произвольные числа, а m — это необходимое количество шагов.339D - Ксюша и битовые операцииРазбор написан GeraldЗадачу можно было решить, используя структуру данных дерево отрезков. В листьях дерева отрезков будем хранить сами значения ai. В вершинах, расстояние от которой до листьев равно 1, будем хранить OR чисел в листьях, которые являются сыновьями этой вершины в дереве отрезков. Аналогично, в вершинах, расстояние от которых до листьев равно 2, будет хранить xor чисел, хранящихся в их непосредственных сыновьях. И так далее. Тогда в корне дерева и будет содержаться требуемое значение v.Для выполнения операции обновления элемента не нужно перестраивать все дерево. Нужно найти путь от корня до листа, который соотвествует позиции обновления, и пересчитать значения только в вершинах дерева отрезков, которые лежат на этом пути. Если все делать правильно, то каждый запрос обновления будет выполняться за O(n). Памяти при этом требуется O(2n).339E - Три переворотаРазбор написан GeraldБудем называть команды из условия операциями реверса, а ряд коней будем называть массив. Неожиданно, да?Задача решается перебором все возможных вариантов. Для начала предположим, что реверс l = r допустим. Найденное нами решение может содержать такие реверсы. Понятно, что решению задачи это никак не помешает. Посколько такие реверсы можно просто не выводить. Это ничего не ухудшит.Следующее ключевое утверждение: операции реверса разбивают массив на не более чем 7 отрезков первоначального массива. Другими словами, представим, что массив изначально склеен, а каждая операция реверса вырезает из массива отрезок и переворачивает его. Тогда массив в конце окажется разрезан не более чем на 7 кусочков.Теперь можно придумать неправильное решение задачи, а потом придумать оптимизацию, которая превращает его в правильное. Переберем как мы разобьем массив и на сколько кусочков. А теперь будет перебирать операции реверса, но при этом операции реверса должны захватывать кусочки только целиком. Понятно, что такое решение правильное, только оно не укладывается в TL.Как его улучшить? Заметим, что в предыдущем решении конкретное разбиение массива требуется нам только в самом конце перебора для проверки, можно ли с таким разбиением так пореверсить массив, чтобы получить то, что задано в input. Поэтому, давайте считать, что массив изначально как-то разделен на 7 частей, причем некоторые части будут, возможно, пустые. Теперь будет перебирать реверсы как и в наивном решении. Только теперь в том месте, где нужна проверка, мы не будем пользоваться конкретным разбиением, а будем искать такое разбиение на части, что зафиксированные перевороты на таком разбиении дадут наш массив.Поиск такого разбиения можно выполнить жадно (читателю предоставляется возможность самому подумать как). Авторское решение делает это за количество блоков в разбиении, то есть за 7 операций. Но, можно сделать это и за O(n) — это должно проходить в TL, если написать отсечения в переборе.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 339\\s*D"
          },
          "content_length": 4749
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #197 - Codeforces - Code 1",
          "code": "7\n  6 7 1 2 4 3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 2",
          "code": "7\n  6 7 1 2 4 3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 3",
          "code": "3\n  5 6\n  2 7\n  1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 4",
          "code": "3\n  5 6\n  2 7\n  1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 5",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 6",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 7",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 8",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 9",
          "code": "bool dp[n][prev][balance]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 10",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 11",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 12",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 13",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 14",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 15",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 1",
          "code": "f[abs(i — j)][f[i][j][k]][k — 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 2",
          "code": "Weight used               Difference in weights",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 3",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 4",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 5",
          "code": "1110000000 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 6",
          "code": "totalLeftWeight = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 7",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 8",
          "code": "totalLeftWeight = 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 9",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 10",
          "code": "0100010100\n6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 11",
          "code": "0100010100\n6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 12",
          "code": "YES\n6 8 6 8 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 13",
          "code": "YES\n6 8 6 8 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 14",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 15",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 16",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 17",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 18",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Разбор - Codeforces - Code 19",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 17, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int N = 1 << n;\n\n    for (int i = 0; i < N; ++i) {\n        if (i > 0) inf.readSpace();\n        inf.readInt(0, (1 << 30) - 1);\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int p = inf.readInt(1, N);\n        inf.readSpace();\n        int b = inf.readInt(0, (1 << 30) - 1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 17, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int N = 1 << n;\n\n    for (int i = 0; i < N; ++i) {\n        if (i > 0) inf.readSpace();\n        inf.readInt(0, (1 << 30) - 1);\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int p = inf.readInt(1, N);\n        inf.readSpace();\n        int b = inf.readInt(0, (1 << 30) - 1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 17, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    int N = 1 << n;\n\n    for (int i = 0; i < N; ++i) {\n        if (i > 0) inf.readSpace();\n        inf.readInt(0, (1 << 30) - 1);\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int p = inf.readInt(1, N);\n        inf.readSpace();\n        int b = inf.readInt(0, (1 << 30) - 1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    int N = 1 << n;\n\n    vector<unsigned int> a(N);\n\n    if (a_type == \"zeros\") {\n        /* All elements are zeros */\n        fill(a.begin(), a.end(), 0);\n    } else if (a_type == \"max\") {\n        /* All elements are max value (2^30 - 1) */\n        fill(a.begin(), a.end(), (1u << 30) - 1);\n    } else if (a_type == \"random\") {\n        /* Random elements between 0 and 2^30 - 1 */\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1u << 30);\n        }\n    } else if (a_type == \"alternation\") {\n        /* Elements alternate between 0 and max */\n        for (int i = 0; i < N; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : (1u << 30) -1;\n        }\n    } else if (a_type == \"ones\") {\n        /* All elements are ones */\n        fill(a.begin(), a.end(), 1);\n    } else if (a_type == \"increasing\") {\n        /* Elements are increasing from 0 */\n        for (int i = 0; i < N; ++i) {\n            a[i] = i;\n        }\n    } else if (a_type == \"decreasing\") {\n        /* Elements are decreasing from max value */\n        for (int i = 0; i < N; ++i) {\n            a[i] = ((1u << 30) - 1) - i;\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1u << 30);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output initial array a\n    for (int i = 0; i < N; ++i) {\n        printf(\"%u%c\", a[i], i + 1 == N ? '\\n' : ' ');\n    }\n\n    // Generate queries\n    for (int i = 0; i < m; ++i) {\n        unsigned int p, b;\n        if (q_type == \"random\") {\n            p = rnd.next(1, N);\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"same_pos\") {\n            p = 1;\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"first_pos\") {\n            p = (i % N) + 1;\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"last_pos\") {\n            p = N - (i % N);\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"edge_positions\") {\n            if (i % 2 == 0)\n                p = 1;\n            else\n                p = N;\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"max_bi\") {\n            p = rnd.next(1, N);\n            b = (1u << 30) -1;\n        } else if (q_type == \"zero_bi\") {\n            p = rnd.next(1, N);\n            b = 0;\n        } else {\n            /* Default to random */\n            p = rnd.next(1, N);\n            b = rnd.next(1u << 30);\n        }\n        printf(\"%u %u\\n\", p, b);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    int N = 1 << n;\n\n    vector<unsigned int> a(N);\n\n    if (a_type == \"zeros\") {\n        /* All elements are zeros */\n        fill(a.begin(), a.end(), 0);\n    } else if (a_type == \"max\") {\n        /* All elements are max value (2^30 - 1) */\n        fill(a.begin(), a.end(), (1u << 30) - 1);\n    } else if (a_type == \"random\") {\n        /* Random elements between 0 and 2^30 - 1 */\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1u << 30);\n        }\n    } else if (a_type == \"alternation\") {\n        /* Elements alternate between 0 and max */\n        for (int i = 0; i < N; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : (1u << 30) -1;\n        }\n    } else if (a_type == \"ones\") {\n        /* All elements are ones */\n        fill(a.begin(), a.end(), 1);\n    } else if (a_type == \"increasing\") {\n        /* Elements are increasing from 0 */\n        for (int i = 0; i < N; ++i) {\n            a[i] = i;\n        }\n    } else if (a_type == \"decreasing\") {\n        /* Elements are decreasing from max value */\n        for (int i = 0; i < N; ++i) {\n            a[i] = ((1u << 30) - 1) - i;\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1u << 30);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output initial array a\n    for (int i = 0; i < N; ++i) {\n        printf(\"%u%c\", a[i], i + 1 == N ? '\\n' : ' ');\n    }\n\n    // Generate queries\n    for (int i = 0; i < m; ++i) {\n        unsigned int p, b;\n        if (q_type == \"random\") {\n            p = rnd.next(1, N);\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"same_pos\") {\n            p = 1;\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"first_pos\") {\n            p = (i % N) + 1;\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"last_pos\") {\n            p = N - (i % N);\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"edge_positions\") {\n            if (i % 2 == 0)\n                p = 1;\n            else\n                p = N;\n            b = rnd.next(1u << 30);\n        } else if (q_type == \"max_bi\") {\n            p = rnd.next(1, N);\n            b = (1u << 30) -1;\n        } else if (q_type == \"zero_bi\") {\n            p = rnd.next(1, N);\n            b = 0;\n        } else {\n            /* Default to random */\n            p = rnd.next(1, N);\n            b = rnd.next(1u << 30);\n        }\n        printf(\"%u %u\\n\", p, b);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -a_type zeros -q_type random\n./gen -n 1 -m 1 -a_type max -q_type same_pos\n./gen -n 1 -m 1 -a_type random -q_type max_bi\n\n./gen -n 2 -m 4 -a_type random -q_type random\n\n./gen -n 3 -m 100 -a_type zeros -q_type same_pos\n./gen -n 3 -m 100 -a_type max -q_type zero_bi\n./gen -n 3 -m 100 -a_type ones -q_type first_pos\n\n./gen -n 4 -m 1000 -a_type alternation -q_type first_pos\n./gen -n 4 -m 1000 -a_type ones -q_type last_pos\n./gen -n 4 -m 1000 -a_type increasing -q_type edge_positions\n\n./gen -n 10 -m 10000 -a_type random -q_type random\n./gen -n 10 -m 10000 -a_type zeros -q_type random\n./gen -n 10 -m 10000 -a_type max -q_type random\n\n./gen -n 16 -m 100000 -a_type zeros -q_type same_pos\n./gen -n 16 -m 100000 -a_type max -q_type zero_bi\n./gen -n 16 -m 100000 -a_type random -q_type max_bi\n./gen -n 16 -m 100000 -a_type alternation -q_type first_pos\n./gen -n 16 -m 100000 -a_type ones -q_type last_pos\n./gen -n 16 -m 100000 -a_type increasing -q_type edge_positions\n./gen -n 16 -m 100000 -a_type decreasing -q_type random\n\n./gen -n 17 -m 100000 -a_type random -q_type random\n./gen -n 17 -m 100000 -a_type zeros -q_type zero_bi\n./gen -n 17 -m 100000 -a_type max -q_type max_bi\n./gen -n 17 -m 100000 -a_type alternation -q_type first_pos\n./gen -n 17 -m 100000 -a_type ones -q_type last_pos\n./gen -n 17 -m 100000 -a_type increasing -q_type edge_positions\n./gen -n 17 -m 100000 -a_type decreasing -q_type random\n\n./gen -n 15 -m 50000 -a_type random -q_type same_pos\n./gen -n 15 -m 50000 -a_type ones -q_type last_pos\n./gen -n 15 -m 50000 -a_type zeros -q_type first_pos\n./gen -n 15 -m 50000 -a_type max -q_type edge_positions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:38.831058",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "339/E",
      "title": "E. Three Swaps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (2 ≤ n ≤ 1000) — the number of horses in the row. The second line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ n), where ai is the number of the i-th left horse in the row after the practice.",
      "output_spec": "OutputThe first line should contain integer k (0 ≤ k ≤ 3) — the number of commads Xenia gave during the practice. In each of the next k lines print two integers. In the i-th line print numbers li, ri (1 ≤ li < ri ≤ n) — Xenia's i-th command during the practice.It is guaranteed that a solution exists. If there are several solutions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy51 4 3 2 5OutputCopy12 4InputCopy62 1 4 3 6 5OutputCopy31 23 45 6",
      "description": "E. Three Swaps\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (2 ≤ n ≤ 1000) — the number of horses in the row. The second line contains n distinct integers a1, a2, ..., an (1 ≤ ai ≤ n), where ai is the number of the i-th left horse in the row after the practice.\n\nOutputThe first line should contain integer k (0 ≤ k ≤ 3) — the number of commads Xenia gave during the practice. In each of the next k lines print two integers. In the i-th line print numbers li, ri (1 ≤ li < ri ≤ n) — Xenia's i-th command during the practice.It is guaranteed that a solution exists. If there are several solutions, you are allowed to print any of them.\n\nInputCopy51 4 3 2 5OutputCopy12 4InputCopy62 1 4 3 6 5OutputCopy31 23 45 6\n\nInputCopy51 4 3 2 5\n\nOutputCopy12 4\n\nInputCopy62 1 4 3 6 5\n\nOutputCopy31 23 45 6",
      "solutions": [
        {
          "title": "Codeforces Round #197 - Codeforces",
          "content": "Hello, Codeforces.Today at 19:30 moscow time, Codeforces Round #197 will take place. Authors of this round are me and Gerald. I'd like to thank the following people for their contribution: Delinur for translation of the statements and MikeMirzayanov for creation and supportion of Codeforces.The score for problems: 500 — 1000 — 1500 — 2000 — 3000.Good luck!UPD: To make the announcement more interestiong and thrilling we decided to add a horse joke and a photo, taken during the preparation of the round.Q: What did the teacher say when the horse walked into the class?A: Why the long face?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8721",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 592
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces",
          "content": "339A - Helpful MathsTutorial by Fefer_IvanTo solve this problem we can count the number of digits 1, 2 and 3 in the input. If there are c1 digits 1, c2 digits 2 and c3 digits 3. Then we must print the sequence of c1 digits 1, c2 digits 2 and c3 digits 3. Digits must be separated by + sign.339B - Xenia and RingroadTutorial by Fefer_IvanTo solve this problem we must learn how to calculate fast enought the time, needed to travel between houses a and b. Let's consider the case when a ≤ b. Than Xenia needs b - a seconds to get from a to b. Otherwise a > b, Xenia will have to go thought house number 1. So she will need n - a + b seconds.339C - Xenia and WeightsTutorial by Fefer_IvanLet's consider the definition of balance. Balance is the difference between sum of all weights on the left pan and sum of all weights on the right pan. At the beginning balance is equal to 0. Att each step Xenia puts one weight on the pan. It means she adds to or substracts from balance integer from 1 to 10. In each odd step, the integer is added and in each even step the integer is subtracted. From the statement we know, that after each step, balance must change it sign and must not be equal to 0. So if after some step the absolute value of balance is greater than 10, Xenia can not continue. Also, it is said in the statement that we can not use two equal weigths in a row. To solve the problem, let's consider a graph, where vertices are tuples of three numbers (i, j, k), where i is a current balance, j is a weight, used in the previous step, and k is the number of the current step. Arcs of the graph must correspond to Xenias actions, described in the statement. The solution of the problme is a path from vertex (0, 0, 1) to some vertex (x, y, m), where x, y are any numbers, and m is the requared number of steps.339D - Xenia and Bit OperationsTutorial by GeraldThe problem could be solved by using a typical data structure (segment tree).The leafs of the segment tree will store the values of ai. At the vertices, the distance from which to the leafs is 1, we will store OR of the numbers from the leafs, which are the sons of this node in the segment tree. Similarly, vertices, the distance from which to the leafs is 2, we will store Xor of the numbers stored in their immediate sons. And so on. Then, the root of the tree will contain the required value v.There is no need to rebuild all the tree to perform an update operation. To do update, we should find a path from the root to the corresponding leaf and recalculate the values only at the tree vertices that are lying on that path. If everything is done correctly, then each update query will be executed in O(n) time. Also we need O(2n) memory.339E - Three SwapsTutorial by GeraldWe will call the command l, r a reverse, also we will call the row of horses an array. Suddenly, right?The problem can be solved with clever bruteforcing all possible ways to reverse an array. To begin with, assume that the reverse with l = r is ok. Our solution can find an answer with such kind of reverses. It is clear that this thing doesn't affect the solution. Because such reverses can simply be erased from the answer.The key idea: reverses split an array into no more than seven segments of the original array. In other words, imagine that the array elements was originally glued together, and each reverse cuts a segment from the array. Then the array would be cut into not more than 7 pieces.Now you can come up with the wrong solution to the problem, and then come up with optimization that turns it into right. So, bruteforce all ways to cut array into 7 or less pieces. Then bruteforce reverse operations, but each reverse operation should contain only whole pieces. It is clear that this solution is correct, One thing it does not fit the TL.How to improve it? Note that the previous solution requires the exact partition of the array only at the very end of the bruteforce. It needed to check whether it is possible to get the given array a. So, let's assume that the array was originally somehow divided into 7 parts (we don't know the exact partition), the parts can be empty. Now try to bruteforce reverses as in naive solution. One thing, in the very end of bruteforce try to find such a partition of the array to get (with fixed reverses) the given array a.The search for such a partition can be done greedily (the reader has an opportunity to come up with it himself). Author's solution does this in time proportional to the number of parts, that is, 7 operations. However, this can be done for O(n) — this should fit in TL, if you write bruteforce carefully.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 339\\s*E"
          },
          "content_length": 4621
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #197 - Codeforces - Code 1",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 2",
          "code": "swap(problem C,problem D);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 3",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 4",
          "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n\nusing namespace std;\n\nchar s[15];\nint m,last,cnt;\nvector <int> v,ans;\nint l,r;\n\nint main()\n{\n    scanf(\"%s%d\",s,&m);\n    for(int i=0; i<10; i++)\n        if(s[i]=='1')\n            v.push_back(i+1);\n    while(1)\n    {\n        int i;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && l+v[i]>r)\n            {\n                last=v[i];\n                l+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n        for(i=0;i<v.size();i++)\n        {\n            if(v[i]!=last && r+v[i]>l)\n            {\n                last=v[i];\n                r+=last;\n                ans.push_back(last);\n                break;\n            }\n        }\n        if(i==v.size())\n            break;\n        cnt++;\n        if(cnt==m)\n            break;\n    }\n    if(cnt==m)\n    {\n        printf(\"YES\\n\");\n        for(int i=0;i<ans.size();i++)\n            printf(\"%d \",ans[i]);\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n\n\n\nTHIS IS QUESTION C\nSEND ME D",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 5",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 6",
          "code": "sum[0]=0;\n    sum[1]=w[i];\n    res[1]=w[i];\n    sl=1;\n    duyet(2);\n}\nelse \n{\n    break;\n}\nif (ok==false)\n{\n    printf(\"NO\");\n    return 0;\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 7",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 8",
          "code": "10\n5 4 3 2 10 1 9 8 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 9",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 - Codeforces - Code 10",
          "code": "--[-----first swap-----]--------------------------------------------\n---------------------------------[--------second swap------------]--\n-----------------[------------third swap-------------]--------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8721",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 1",
          "code": "Weight used               Difference in weights",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 2",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 3",
          "code": "0110010001\n9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 4",
          "code": "1110000000 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 5",
          "code": "totalLeftWeight = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 6",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 7",
          "code": "totalLeftWeight = 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 8",
          "code": "totalRightWeight = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 9",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 10",
          "code": "9\n5 6 7 8 1 2 3 9 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 11",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 12",
          "code": "3\n4 9\n1 4\n1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 13",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #197 — Tutorial - Codeforces - Code 14",
          "code": "bool dfs(int x,int y,int k){\n\tif(k>m)return 1;\n\tint f=0;\n\tFOR(i,1,10){\n\t\tif(c[i]&&x>=0&&y!=i&&x-i<0){\n\t\t\tf=dfs(x-i,i,k+1);\n\t\t}\n\t\telse if(c[i]&&x<0&&y!=i&&x+i>0){\n\t\t\tf=dfs(x+i,i,k+1);\n\t\t}\n\t\tif(f){\n\t\t\tv.PB(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements in a must be unique\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements in a must be unique\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements in a must be unique\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt(2, 1000, \"n\"); // Read n from input file\n    vector<int> finalSeq = inf.readInts(n, 1, n, \"finalSeq\"); // Read the final sequence from input file\n\n    // Check for uniqueness in the final sequence\n    set<int> uniqueCheck(finalSeq.begin(), finalSeq.end());\n    if (uniqueCheck.size() != n)\n        quitf(_fail, \"Final sequence in input contains duplicates.\");\n\n    // Initialize the initial sequence\n    vector<int> initialSeq(n);\n    for (int i = 0; i < n; i++)\n        initialSeq[i] = i + 1;\n\n    // Read contestant's output\n    int k = ouf.readInt(0, 3, \"k\"); // Read the number of commands\n    for (int i = 0; i < k; i++) {\n        int l_i = ouf.readInt(1, n, format(\"l_%d\", i + 1).c_str()); // Read l_i\n        int r_i = ouf.readInt(1, n, format(\"r_%d\", i + 1).c_str()); // Read r_i\n        if (l_i >= r_i)\n            quitf(_wa, \"Invalid command %d: l_i (%d) >= r_i (%d)\", i + 1, l_i, r_i);\n\n        // Apply the command by reversing the segment from l_i to r_i\n        reverse(initialSeq.begin() + l_i - 1, initialSeq.begin() + r_i);\n    }\n\n    // Check if the initial sequence after applying commands matches the final sequence\n    if (initialSeq == finalSeq)\n        quitf(_ok, \"Correct sequence of commands\");\n    else\n        quitf(_wa, \"After applying commands, the sequence does not match the final sequence\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        k = rnd.next(0, 3);\n    } else {\n        k = min(max(k, 0), 3);\n    }\n\n    vector<pair<int, int>> commands;\n\n    vector<int> seq(n);\n    iota(seq.begin(), seq.end(), 1);\n\n    if (type == \"reverse_all\") {\n        commands.push_back(make_pair(1, n));\n        k = 1;\n    } else if (type == \"reverse_ends\") {\n        if (k >= 2) {\n            commands.push_back(make_pair(1, n / 2));\n            commands.push_back(make_pair(n / 2 + 1, n));\n        } else if (k >= 1) {\n            commands.push_back(make_pair(1, n));\n        }\n        k = commands.size();\n    } else if (type == \"swap_pairs\") {\n        int num_pairs = min(n / 2, k);\n        for (int i = 0; i < num_pairs; i++) {\n            int l = i * 2 + 1;\n            int r = l + 1;\n            commands.push_back(make_pair(l, r));\n        }\n        k = num_pairs;\n    } else if (type == \"reverse_random_ranges\") {\n        for (int i = 0; i < k; i++) {\n            int l = rnd.next(1, n - 1);\n            int r = rnd.next(l + 1, n);\n            commands.push_back(make_pair(l, r));\n        }\n    } else if (type == \"reverse_prefixes\") {\n        for (int i = 0; i < k; i++) {\n            int r = rnd.next(2, n);\n            commands.push_back(make_pair(1, r));\n        }\n    } else { // Default is \"random\"\n        for (int i = 0; i < k; i++) {\n            int l = rnd.next(1, n - 1);\n            int r = rnd.next(l + 1, n);\n            commands.push_back(make_pair(l, r));\n        }\n    }\n\n    // Apply the commands\n    for (auto cmd : commands) {\n        int l = cmd.first - 1;\n        int r = cmd.second - 1;\n        reverse(seq.begin() + l, seq.begin() + r + 1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the final sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", seq[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        k = rnd.next(0, 3);\n    } else {\n        k = min(max(k, 0), 3);\n    }\n\n    vector<pair<int, int>> commands;\n\n    vector<int> seq(n);\n    iota(seq.begin(), seq.end(), 1);\n\n    if (type == \"reverse_all\") {\n        commands.push_back(make_pair(1, n));\n        k = 1;\n    } else if (type == \"reverse_ends\") {\n        if (k >= 2) {\n            commands.push_back(make_pair(1, n / 2));\n            commands.push_back(make_pair(n / 2 + 1, n));\n        } else if (k >= 1) {\n            commands.push_back(make_pair(1, n));\n        }\n        k = commands.size();\n    } else if (type == \"swap_pairs\") {\n        int num_pairs = min(n / 2, k);\n        for (int i = 0; i < num_pairs; i++) {\n            int l = i * 2 + 1;\n            int r = l + 1;\n            commands.push_back(make_pair(l, r));\n        }\n        k = num_pairs;\n    } else if (type == \"reverse_random_ranges\") {\n        for (int i = 0; i < k; i++) {\n            int l = rnd.next(1, n - 1);\n            int r = rnd.next(l + 1, n);\n            commands.push_back(make_pair(l, r));\n        }\n    } else if (type == \"reverse_prefixes\") {\n        for (int i = 0; i < k; i++) {\n            int r = rnd.next(2, n);\n            commands.push_back(make_pair(1, r));\n        }\n    } else { // Default is \"random\"\n        for (int i = 0; i < k; i++) {\n            int l = rnd.next(1, n - 1);\n            int r = rnd.next(l + 1, n);\n            commands.push_back(make_pair(l, r));\n        }\n    }\n\n    // Apply the commands\n    for (auto cmd : commands) {\n        int l = cmd.first - 1;\n        int r = cmd.second - 1;\n        reverse(seq.begin() + l, seq.begin() + r + 1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the final sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", seq[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, k=0 (no commands)\n./gen -n 2 -k 0\n./gen -n 5 -k 0\n\n# Small n, k=1\n./gen -n 2 -k 1 -type reverse_all\n./gen -n 5 -k 1 -type reverse_all\n\n# Small n, k=1, random reverse\n./gen -n 5 -k 1 -type random\n\n# Small n, k=3, random reverse\n./gen -n 5 -k 3 -type random\n\n# Moderate n, k=1\n./gen -n 50 -k 1 -type reverse_all\n\n# Moderate n, k=2, reverse_ends\n./gen -n 50 -k 2 -type reverse_ends\n\n# Moderate n, k=3, swap_pairs\n./gen -n 50 -k 3 -type swap_pairs\n\n# Moderate n, k=3, random\n./gen -n 50 -k 3 -type random\n\n# Large n, k=1, reverse_all\n./gen -n 1000 -k 1 -type reverse_all\n\n# Large n, k=2, reverse_ends\n./gen -n 1000 -k 2 -type reverse_ends\n\n# Large n, k=3, swap_pairs\n./gen -n 1000 -k 3 -type swap_pairs\n\n# Large n, k=3, random\n./gen -n 1000 -k 3 -type random\n\n# Random n and k\n./gen -n 100 -k 2 -type random\n\n./gen -n 200 -k 3 -type reverse_random_ranges\n\n./gen -n 300 -k 1 -type reverse_prefixes\n\n./gen -n 400 -k 3 -type random\n\n# Edge cases\n./gen -n 2 -k 1 -type reverse_all\n\n./gen -n 3 -k 3 -type random\n\n./gen -n 997 -k 1 -type reverse_all\n\n./gen -n 998 -k 2 -type reverse_ends\n\n./gen -n 999 -k 3 -type swap_pairs\n\n# Random test cases\n./gen -n 1000 -k 2 -type random\n\n./gen -n 1000 -type random\n./gen -n 1000\n\n# Testing with default k and type\n./gen -n 750\n\n./gen -n 500\n\n./gen -n 250 -k 0\n\n./gen -n 250 -k 3 -type reverse_prefixes\n\n./gen -n 100 -k 1 -type reverse_all\n\n./gen -n 100 -k 2 -type reverse_ends\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:40.695565",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "34/A",
      "title": "A. Reconnaissance 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 100) — amount of soldiers. Then follow the heights of the soldiers in their order in the circle — n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1000). The soldier heights are given in clockwise or counterclockwise direction.",
      "output_spec": "OutputOutput two integers — indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.",
      "sample_tests": "ExamplesInputCopy510 12 13 15 10OutputCopy5 1InputCopy410 20 30 40OutputCopy1 2",
      "description": "A. Reconnaissance 2\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 100) — amount of soldiers. Then follow the heights of the soldiers in their order in the circle — n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1000). The soldier heights are given in clockwise or counterclockwise direction.\n\nOutputOutput two integers — indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.\n\nInputCopy510 12 13 15 10OutputCopy5 1InputCopy410 20 30 40OutputCopy1 2\n\nInputCopy510 12 13 15 10\n\nOutputCopy5 1\n\nInputCopy410 20 30 40\n\nOutputCopy1 2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #34 (Div. 2) - Codeforces",
          "content": "Welcome all to the next Codeforces Format round!In this round I will replace Artem Rakhov in his usual role of contest administrator: Artem have set out to America to take part in TopCoder Open Algorithm onsite. Good luck, Artem!The contest has ended, results.User a4461497 has won the contest, while among first-division users - kuniavski was the first who solved all 5 problems. All tests to the contest problems:C, D, EThanks to Michael Mirzayanov and Julia Satushina who helped to prepare this round.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 504
        },
        {
          "title": "Codeforces Beta Round #34 (Div. 2) Разбор - Codeforces",
          "content": "Привет, мир! Это мой первый разбор, просьба сильно не пинать. =)A. Разведка 2Нахождение минимума в массиве, с одим дополнительным сравнением первого и последнего элементов.B. РаспродажаОтрицательные элементы складываем в массив, сортируем, находим сумму m наибольших по модулю.C. СписокРешается массивом булей, единственная заковыка - с выводом, но вполне преодолима.D. Карта дорогСоздаем динамическую матрицу смежности, например, массивом стеков, заполняем. Потом волновым алгоритмом из r2, пробегаясь по каждой вершине один раз, пролучаем результирующий массив.E. СтолкновенияЗаведем переменную времени ct, которая вначале равна 0.Начинаем моделировать:Пусть dt равен t - ct, просматриваем все пары шариков, по формуле x1 + v1 * dt = x2 + v2 * dtdt = (x1 - x2) / (v2 - v1)находим минимальную dt - промежуток времени, через который какие-нибудь шарики столкнуться, или время моделирования закончится.Сдвигаем шарики на этот промежуток времени, снова просматриваем все пары, если координаты двух совпадают, меняем их скорости по формуле из условия.Повторять, пока ct не сравняется с t.Особое внимание стоит уделить точности, наверное на этом и подловили RAVEman'а с ACRush'ем. =)В принятом решении я использовал double и точность сравнений 10-10.Удачи в контестах!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1264
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check whether two positions are neighbors in the circle\nbool areNeighbors(int i, int j, int n) {\n    int prev = ((i + n - 2) % n) + 1; // previous position\n    int next = (i % n) + 1; // next position\n    return (j == prev || j == next);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    vector<int> a = inf.readInts(n, 1, 1000, \"a\");\n\n    // Compute the minimal absolute difference among all neighboring soldiers\n    int min_diff = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        int ni = (i + 1) % n; // next index in the circle\n        int diff = abs(a[i] - a[ni]);\n        if (diff < min_diff) {\n            min_diff = diff;\n        }\n    }\n\n    // Read contestant's output\n    int p = ouf.readInt(1, n, \"p\");\n    int q = ouf.readInt(1, n, \"q\");\n\n    // Check if the provided soldiers are neighbors\n    if (!areNeighbors(p, q, n)) {\n        quitf(_wa, \"Soldiers %d and %d are not neighbors\", p, q);\n    }\n\n    // Check if the height difference is minimal\n    int contestant_diff = abs(a[p - 1] - a[q - 1]);\n    if (contestant_diff != min_diff) {\n        quitf(_wa, \"Height difference %d between soldiers %d and %d is not minimal (%d)\", contestant_diff, p, q, min_diff);\n    }\n\n    quitf(_ok, \"Correct answer: soldiers %d and %d with minimal height difference %d\", p, q, min_diff);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ensuref(n >= 2 && n <= 100, \"n must be between 2 and 100 inclusive\");\n    std::string type = opt<std::string>(\"type\", \"random\");\n\n    std::vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random heights between 1 and 1000\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_diff\") {\n        // Heights alternate between 1 and 1000\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = 1000;\n        }\n    } else if (type == \"min_diff_at_end\") {\n        // Generate heights such that minimal difference is between soldiers n and 1\n        a[0] = 500;\n        a[n - 1] = 501;\n        for (int i = 1; i < n - 1; ++i) {\n            // Heights not close to 500 or 501\n            a[i] = rnd.next(1, 1000);\n            while (abs(a[i] - 500) <= 1 || abs(a[i] - 501) <= 1) {\n                a[i] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"sorted_increasing\") {\n        // Heights increase in order\n        int height = 1;\n        int increment = std::max(1, 999 / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = height;\n            height += increment;\n            if (height > 1000) height = 1000;\n        }\n    } else if (type == \"sorted_decreasing\") {\n        // Heights decrease in order\n        int height = 1000;\n        int decrement = std::max(1, 999 / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = height;\n            height -= decrement;\n            if (height < 1) height = 1;\n        }\n    } else if (type == \"same_height\") {\n        // All soldiers have the same height\n        int h = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = h;\n        }\n    } else if (type == \"alternating\") {\n        // Heights alternate between two values\n        int h1 = rnd.next(1, 500);\n        int h2 = h1 + rnd.next(1, 500);\n        if (h2 > 1000) h2 = 1000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Ensure all heights are within bounds\n    for (int i = 0; i < n; ++i) {\n        ensuref(a[i] >= 1 && a[i] <= 1000, \"a[%d] = %d is out of bounds\", i + 1, a[i]);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ensuref(n >= 2 && n <= 100, \"n must be between 2 and 100 inclusive\");\n    std::string type = opt<std::string>(\"type\", \"random\");\n\n    std::vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random heights between 1 and 1000\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_diff\") {\n        // Heights alternate between 1 and 1000\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = 1000;\n        }\n    } else if (type == \"min_diff_at_end\") {\n        // Generate heights such that minimal difference is between soldiers n and 1\n        a[0] = 500;\n        a[n - 1] = 501;\n        for (int i = 1; i < n - 1; ++i) {\n            // Heights not close to 500 or 501\n            a[i] = rnd.next(1, 1000);\n            while (abs(a[i] - 500) <= 1 || abs(a[i] - 501) <= 1) {\n                a[i] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"sorted_increasing\") {\n        // Heights increase in order\n        int height = 1;\n        int increment = std::max(1, 999 / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = height;\n            height += increment;\n            if (height > 1000) height = 1000;\n        }\n    } else if (type == \"sorted_decreasing\") {\n        // Heights decrease in order\n        int height = 1000;\n        int decrement = std::max(1, 999 / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = height;\n            height -= decrement;\n            if (height < 1) height = 1;\n        }\n    } else if (type == \"same_height\") {\n        // All soldiers have the same height\n        int h = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = h;\n        }\n    } else if (type == \"alternating\") {\n        // Heights alternate between two values\n        int h1 = rnd.next(1, 500);\n        int h2 = h1 + rnd.next(1, 500);\n        if (h2 > 1000) h2 = 1000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Ensure all heights are within bounds\n    for (int i = 0; i < n; ++i) {\n        ensuref(a[i] >= 1 && a[i] <= 1000, \"a[%d] = %d is out of bounds\", i + 1, a[i]);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type max_diff\n./gen -n 2 -type min_diff_at_end\n./gen -n 2 -type sorted_increasing\n./gen -n 2 -type sorted_decreasing\n./gen -n 2 -type same_height\n./gen -n 2 -type alternating\n\n./gen -n 3 -type random\n./gen -n 3 -type max_diff\n./gen -n 3 -type min_diff_at_end\n./gen -n 3 -type sorted_increasing\n./gen -n 3 -type sorted_decreasing\n./gen -n 3 -type same_height\n./gen -n 3 -type alternating\n\n./gen -n 50 -type random\n./gen -n 50 -type max_diff\n./gen -n 50 -type min_diff_at_end\n./gen -n 50 -type sorted_increasing\n./gen -n 50 -type sorted_decreasing\n./gen -n 50 -type same_height\n./gen -n 50 -type alternating\n\n./gen -n 99 -type random\n./gen -n 99 -type max_diff\n./gen -n 99 -type min_diff_at_end\n./gen -n 99 -type sorted_increasing\n./gen -n 99 -type sorted_decreasing\n./gen -n 99 -type same_height\n./gen -n 99 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type max_diff\n./gen -n 100 -type min_diff_at_end\n./gen -n 100 -type sorted_increasing\n./gen -n 100 -type sorted_decreasing\n./gen -n 100 -type same_height\n./gen -n 100 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:42.753510",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "34/B",
      "title": "B. Sale",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ m ≤ n ≤ 100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai ( - 1000 ≤ ai ≤ 1000) — prices of the TV sets.",
      "output_spec": "OutputOutput the only number — the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.",
      "sample_tests": "ExamplesInputCopy5 3-6 0 35 -2 4OutputCopy8InputCopy4 27 0 0 -7OutputCopy7",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ m ≤ n ≤ 100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai ( - 1000 ≤ ai ≤ 1000) — prices of the TV sets.\n\nOutputOutput the only number — the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.\n\nInputCopy5 3-6 0 35 -2 4OutputCopy8InputCopy4 27 0 0 -7OutputCopy7\n\nInputCopy5 3-6 0 35 -2 4\n\nOutputCopy8\n\nInputCopy4 27 0 0 -7\n\nOutputCopy7",
      "solutions": [
        {
          "title": "Codeforces Beta Round #34 (Div. 2) - Codeforces",
          "content": "Welcome all to the next Codeforces Format round!In this round I will replace Artem Rakhov in his usual role of contest administrator: Artem have set out to America to take part in TopCoder Open Algorithm onsite. Good luck, Artem!The contest has ended, results.User a4461497 has won the contest, while among first-division users - kuniavski was the first who solved all 5 problems. All tests to the contest problems:C, D, EThanks to Michael Mirzayanov and Julia Satushina who helped to prepare this round.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 504
        },
        {
          "title": "Codeforces Beta Round #34 (Div. 2) Разбор - Codeforces",
          "content": "Привет, мир! Это мой первый разбор, просьба сильно не пинать. =)A. Разведка 2Нахождение минимума в массиве, с одим дополнительным сравнением первого и последнего элементов.B. РаспродажаОтрицательные элементы складываем в массив, сортируем, находим сумму m наибольших по модулю.C. СписокРешается массивом булей, единственная заковыка - с выводом, но вполне преодолима.D. Карта дорогСоздаем динамическую матрицу смежности, например, массивом стеков, заполняем. Потом волновым алгоритмом из r2, пробегаясь по каждой вершине один раз, пролучаем результирующий массив.E. СтолкновенияЗаведем переменную времени ct, которая вначале равна 0.Начинаем моделировать:Пусть dt равен t - ct, просматриваем все пары шариков, по формуле x1 + v1 * dt = x2 + v2 * dtdt = (x1 - x2) / (v2 - v1)находим минимальную dt - промежуток времени, через который какие-нибудь шарики столкнуться, или время моделирования закончится.Сдвигаем шарики на этот промежуток времени, снова просматриваем все пары, если координаты двух совпадают, меняем их скорости по формуле из условия.Повторять, пока ct не сравняется с t.Особое внимание стоит уделить точности, наверное на этом и подловили RAVEman'а с ACRush'ем. =)В принятом решении я использовал double и точность сравнений 10-10.Удачи в контестах!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1264
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, -1000, 1000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, -1000, 1000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, -1000, 1000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    assert(1 <= m && m <= n && n <= 100);\n\n    vector<int> ai(n);\n\n    if (type == \"all_negative\") {\n        // All prices are negative integers from -1 to -1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = -rnd.next(1, 1000);\n    } else if (type == \"all_positive\") {\n        // All prices are positive integers from 1 to 1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000);\n    } else if (type == \"max_negative\") {\n        // All prices are -1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = -1000;\n    } else if (type == \"max_positive\") {\n        // All prices are 1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1000;\n    } else if (type == \"zero\") {\n        // All prices are zero\n        fill(ai.begin(), ai.end(), 0);\n    } else if (type == \"mix\") {\n        // First half negative, second half positive\n        for(int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                ai[i] = -rnd.next(1, 1000);\n            else\n                ai[i] = rnd.next(1, 1000);\n        }\n        shuffle(ai.begin(), ai.end());\n    } else {\n        // Random prices between -1000 and 1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(-1000, 1000);\n    }\n\n    // Verify that ai[i] satisfies the constraints\n    for(int i = 0; i < n; ++i)\n        assert(-1000 <= ai[i] && ai[i] <= 1000);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the ai's\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], (i == n - 1 ? '\\n' : ' '));\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    assert(1 <= m && m <= n && n <= 100);\n\n    vector<int> ai(n);\n\n    if (type == \"all_negative\") {\n        // All prices are negative integers from -1 to -1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = -rnd.next(1, 1000);\n    } else if (type == \"all_positive\") {\n        // All prices are positive integers from 1 to 1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000);\n    } else if (type == \"max_negative\") {\n        // All prices are -1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = -1000;\n    } else if (type == \"max_positive\") {\n        // All prices are 1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1000;\n    } else if (type == \"zero\") {\n        // All prices are zero\n        fill(ai.begin(), ai.end(), 0);\n    } else if (type == \"mix\") {\n        // First half negative, second half positive\n        for(int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                ai[i] = -rnd.next(1, 1000);\n            else\n                ai[i] = rnd.next(1, 1000);\n        }\n        shuffle(ai.begin(), ai.end());\n    } else {\n        // Random prices between -1000 and 1000\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(-1000, 1000);\n    }\n\n    // Verify that ai[i] satisfies the constraints\n    for(int i = 0; i < n; ++i)\n        assert(-1000 <= ai[i] && ai[i] <= 1000);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the ai's\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], (i == n - 1 ? '\\n' : ' '));\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_negative\n./gen -n 1 -m 1 -type all_positive\n./gen -n 2 -m 1 -type all_negative\n./gen -n 2 -m 2 -type all_positive\n./gen -n 10 -m 5 -type mix\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 25 -type mix\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 1 -type max_negative\n./gen -n 50 -m 1 -type max_positive\n./gen -n 50 -m 49 -type zero\n./gen -n 50 -m 50 -type zero\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 50 -type random\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 100 -type all_negative\n./gen -n 100 -m 100 -type all_positive\n./gen -n 100 -m 100 -type max_negative\n./gen -n 100 -m 100 -type max_positive\n./gen -n 100 -m 100 -type zero\n./gen -n 100 -m 100 -type mix\n./gen -n 100 -m 1 -type max_negative\n./gen -n 100 -m 1 -type max_positive\n./gen -n 100 -m 1 -type zero\n./gen -n 100 -m 1 -type mix\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 50 -type max_negative\n./gen -n 100 -m 50 -type max_positive\n./gen -n 100 -m 50 -type zero\n./gen -n 100 -m 50 -type mix\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:44.487184",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "34/C",
      "title": "C. Page Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains the sequence, keyed by the user. The sequence contains at least one and at most 100 positive integer numbers. It's guaranteed, that this sequence consists of positive integer numbers, not exceeding 1000, separated with a comma, doesn't contain any other characters, apart from digits and commas, can't end with a comma, and the numbers don't contain leading zeroes. Also it doesn't start with a comma or contain more than one comma in a row.",
      "output_spec": "OutputOutput the sequence in the required format.",
      "sample_tests": "ExamplesInputCopy1,2,3,1,1,2,6,6,2OutputCopy1-3,6InputCopy3,2,1OutputCopy1-3InputCopy30,20,10OutputCopy10,20,30",
      "description": "C. Page Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line contains the sequence, keyed by the user. The sequence contains at least one and at most 100 positive integer numbers. It's guaranteed, that this sequence consists of positive integer numbers, not exceeding 1000, separated with a comma, doesn't contain any other characters, apart from digits and commas, can't end with a comma, and the numbers don't contain leading zeroes. Also it doesn't start with a comma or contain more than one comma in a row.\n\nOutputOutput the sequence in the required format.\n\nInputCopy1,2,3,1,1,2,6,6,2OutputCopy1-3,6InputCopy3,2,1OutputCopy1-3InputCopy30,20,10OutputCopy10,20,30\n\nInputCopy1,2,3,1,1,2,6,6,2\n\nOutputCopy1-3,6\n\nInputCopy3,2,1\n\nOutputCopy1-3\n\nInputCopy30,20,10\n\nOutputCopy10,20,30",
      "solutions": [
        {
          "title": "Codeforces Beta Round #34 (Div. 2) - Codeforces",
          "content": "Welcome all to the next Codeforces Format round!In this round I will replace Artem Rakhov in his usual role of contest administrator: Artem have set out to America to take part in TopCoder Open Algorithm onsite. Good luck, Artem!The contest has ended, results.User a4461497 has won the contest, while among first-division users - kuniavski was the first who solved all 5 problems. All tests to the contest problems:C, D, EThanks to Michael Mirzayanov and Julia Satushina who helped to prepare this round.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 504
        },
        {
          "title": "Codeforces Beta Round #34 (Div. 2) Разбор - Codeforces",
          "content": "Привет, мир! Это мой первый разбор, просьба сильно не пинать. =)A. Разведка 2Нахождение минимума в массиве, с одим дополнительным сравнением первого и последнего элементов.B. РаспродажаОтрицательные элементы складываем в массив, сортируем, находим сумму m наибольших по модулю.C. СписокРешается массивом булей, единственная заковыка - с выводом, но вполне преодолима.D. Карта дорогСоздаем динамическую матрицу смежности, например, массивом стеков, заполняем. Потом волновым алгоритмом из r2, пробегаясь по каждой вершине один раз, пролучаем результирующий массив.E. СтолкновенияЗаведем переменную времени ct, которая вначале равна 0.Начинаем моделировать:Пусть dt равен t - ct, просматриваем все пары шариков, по формуле x1 + v1 * dt = x2 + v2 * dtdt = (x1 - x2) / (v2 - v1)находим минимальную dt - промежуток времени, через который какие-нибудь шарики столкнуться, или время моделирования закончится.Сдвигаем шарики на этот промежуток времени, снова просматриваем все пары, если координаты двух совпадают, меняем их скорости по формуле из условия.Повторять, пока ct не сравняется с t.Особое внимание стоит уделить точности, наверное на этом и подловили RAVEman'а с ACRush'ем. =)В принятом решении я использовал double и точность сравнений 10-10.Удачи в контестах!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1264
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string pattern = \"^(1000|[1-9][0-9]{0,2})(,(1000|[1-9][0-9]{0,2})){0,99}$\";\n    string s = inf.readLine(pattern);\n    \n    // Split the line at commas\n    vector<string> tokens;\n    stringstream ss(s);\n    string token;\n    while (getline(ss, token, ',')) {\n        tokens.push_back(token);\n    }\n    int N = tokens.size();\n    ensuref(N >= 1 && N <= 100, \"Number of numbers N=%d is not in range [1,100]\", N);\n    for (string num_str : tokens) {\n        int num = stoi(num_str);\n        ensuref(num >= 1 && num <= 1000, \"Number %d is not in range [1,1000]\", num);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string pattern = \"^(1000|[1-9][0-9]{0,2})(,(1000|[1-9][0-9]{0,2})){0,99}$\";\n    string s = inf.readLine(pattern);\n    \n    // Split the line at commas\n    vector<string> tokens;\n    stringstream ss(s);\n    string token;\n    while (getline(ss, token, ',')) {\n        tokens.push_back(token);\n    }\n    int N = tokens.size();\n    ensuref(N >= 1 && N <= 100, \"Number of numbers N=%d is not in range [1,100]\", N);\n    for (string num_str : tokens) {\n        int num = stoi(num_str);\n        ensuref(num >= 1 && num <= 1000, \"Number %d is not in range [1,1000]\", num);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string pattern = \"^(1000|[1-9][0-9]{0,2})(,(1000|[1-9][0-9]{0,2})){0,99}$\";\n    string s = inf.readLine(pattern);\n    \n    // Split the line at commas\n    vector<string> tokens;\n    stringstream ss(s);\n    string token;\n    while (getline(ss, token, ',')) {\n        tokens.push_back(token);\n    }\n    int N = tokens.size();\n    ensuref(N >= 1 && N <= 100, \"Number of numbers N=%d is not in range [1,100]\", N);\n    for (string num_str : tokens) {\n        int num = stoi(num_str);\n        ensuref(num >= 1 && num <= 1000, \"Number %d is not in range [1,1000]\", num);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default is \"random\"\n    int max_num = opt<int>(\"max_num\", 1000); // default is 1000\n\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Parameter n should be between 1 and 100 (inclusive)\\n\");\n        return 1;\n    }\n    if (max_num < 1 || max_num > 1000) {\n        fprintf(stderr, \"Parameter max_num should be between 1 and 1000 (inclusive)\\n\");\n        return 1;\n    }\n\n    vector<int> seq; // the sequence of numbers\n\n    if (type == \"random\") {\n        // Generate n numbers between 1 and max_num, possible duplicates\n        for(int i = 0; i < n; i++) {\n            int num = rnd.next(1, max_num);\n            seq.push_back(num);\n        }\n    } else if (type == \"no_duplicates\") {\n        // Generate n unique numbers between 1 and max_num\n        if (n > max_num) {\n            // Not enough unique numbers\n            fprintf(stderr, \"Not enough unique numbers to generate sequence of length %d\\n\", n);\n            return 1;\n        }\n        set<int> used;\n        while ((int)seq.size() < n) {\n            int num = rnd.next(1, max_num);\n            if (used.count(num) == 0) {\n                used.insert(num);\n                seq.push_back(num);\n            }\n        }\n    } else if (type == \"ascending\") {\n        // Generate n numbers in increasing order, possible duplicates\n        int current = 1;\n        for(int i = 0; i < n; i++) {\n            int num = rnd.next(current, max_num);\n            seq.push_back(num);\n            current = num; // Could be same as previous (duplicates allowed)\n        }\n    } else if (type == \"descending\") {\n        // Generate n numbers in decreasing order, possible duplicates\n        int current = max_num;\n        for(int i = 0; i < n; i++) {\n            if (current < 1) current = 1; // Ensure current is at least 1\n            int num = rnd.next(1, current);\n            seq.push_back(num);\n            current = num; // Could be same as previous (duplicates allowed)\n        }\n    } else if (type == \"all_same\") {\n        // All numbers are the same between 1 and max_num\n        int num = rnd.next(1, max_num);\n        for(int i = 0; i < n; i++) {\n            seq.push_back(num);\n        }\n    } else if (type == \"extremes\") {\n        // Numbers are only 1 or max_num\n        for(int i = 0; i < n; i++) {\n            int num = rnd.next(1, 2) == 1 ? 1 : max_num;\n            seq.push_back(num);\n        }\n    } else if (type == \"min_values\") {\n        // All numbers are 1\n        for(int i = 0; i < n; i++) {\n            seq.push_back(1);\n        }\n    } else if (type == \"max_values\") {\n        // All numbers are max_num\n        for(int i = 0; i < n; i++) {\n            seq.push_back(max_num);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the sequence\n    for(int i = 0; i < (int)seq.size(); i++) {\n        if(i > 0) printf(\",\");\n        printf(\"%d\", seq[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default is \"random\"\n    int max_num = opt<int>(\"max_num\", 1000); // default is 1000\n\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Parameter n should be between 1 and 100 (inclusive)\\n\");\n        return 1;\n    }\n    if (max_num < 1 || max_num > 1000) {\n        fprintf(stderr, \"Parameter max_num should be between 1 and 1000 (inclusive)\\n\");\n        return 1;\n    }\n\n    vector<int> seq; // the sequence of numbers\n\n    if (type == \"random\") {\n        // Generate n numbers between 1 and max_num, possible duplicates\n        for(int i = 0; i < n; i++) {\n            int num = rnd.next(1, max_num);\n            seq.push_back(num);\n        }\n    } else if (type == \"no_duplicates\") {\n        // Generate n unique numbers between 1 and max_num\n        if (n > max_num) {\n            // Not enough unique numbers\n            fprintf(stderr, \"Not enough unique numbers to generate sequence of length %d\\n\", n);\n            return 1;\n        }\n        set<int> used;\n        while ((int)seq.size() < n) {\n            int num = rnd.next(1, max_num);\n            if (used.count(num) == 0) {\n                used.insert(num);\n                seq.push_back(num);\n            }\n        }\n    } else if (type == \"ascending\") {\n        // Generate n numbers in increasing order, possible duplicates\n        int current = 1;\n        for(int i = 0; i < n; i++) {\n            int num = rnd.next(current, max_num);\n            seq.push_back(num);\n            current = num; // Could be same as previous (duplicates allowed)\n        }\n    } else if (type == \"descending\") {\n        // Generate n numbers in decreasing order, possible duplicates\n        int current = max_num;\n        for(int i = 0; i < n; i++) {\n            if (current < 1) current = 1; // Ensure current is at least 1\n            int num = rnd.next(1, current);\n            seq.push_back(num);\n            current = num; // Could be same as previous (duplicates allowed)\n        }\n    } else if (type == \"all_same\") {\n        // All numbers are the same between 1 and max_num\n        int num = rnd.next(1, max_num);\n        for(int i = 0; i < n; i++) {\n            seq.push_back(num);\n        }\n    } else if (type == \"extremes\") {\n        // Numbers are only 1 or max_num\n        for(int i = 0; i < n; i++) {\n            int num = rnd.next(1, 2) == 1 ? 1 : max_num;\n            seq.push_back(num);\n        }\n    } else if (type == \"min_values\") {\n        // All numbers are 1\n        for(int i = 0; i < n; i++) {\n            seq.push_back(1);\n        }\n    } else if (type == \"max_values\") {\n        // All numbers are max_num\n        for(int i = 0; i < n; i++) {\n            seq.push_back(max_num);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the sequence\n    for(int i = 0; i < (int)seq.size(); i++) {\n        if(i > 0) printf(\",\");\n        printf(\"%d\", seq[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Minimum size, random sequence\n./gen -n 1 -type random\n\n# Test case 2: Maximum size, random sequence\n./gen -n 100 -type random\n\n# Test case 3: Sequence with all numbers the same\n./gen -n 10 -type all_same\n\n# Test case 4: Sequence with numbers in ascending order\n./gen -n 10 -type ascending\n\n# Test case 5: Sequence with numbers in descending order\n./gen -n 10 -type descending\n\n# Test case 6: Sequence with no duplicates\n./gen -n 10 -type no_duplicates\n\n# Test case 7: Sequence with numbers only 1 or 1000\n./gen -n 10 -type extremes -max_num 1000\n\n# Test case 8: Sequence with maximum value numbers\n./gen -n 10 -type max_values -max_num 1000\n\n# Test case 9: Sequence with minimum value numbers\n./gen -n 10 -type min_values\n\n# Test case 10: Random sequence with maximum numbers\n./gen -n 100 -type random -max_num 1000\n\n# Test case 11: Sequence with numbers between 1 and 2\n./gen -n 100 -type random -max_num 2\n\n# Test case 12: Random sequence with possible duplicates\n./gen -n 50 -type random\n\n# Test case 13: Random sequence with no duplicates\n./gen -n 50 -type no_duplicates\n\n# Test case 14: Sequence of length 100 with ascending numbers\n./gen -n 100 -type ascending\n\n# Test case 15: Sequence of length 100 with descending numbers\n./gen -n 100 -type descending\n\n# Test case 16: All numbers are 1\n./gen -n 100 -type min_values\n\n# Test case 17: All numbers are 1000\n./gen -n 100 -type max_values -max_num 1000\n\n# Test case 18: Random sequence with max_num=1 (all numbers 1)\n./gen -n 50 -type random -max_num 1\n\n# Test case 19: Random sequence with max_num=1000\n./gen -n 50 -type random -max_num 1000\n\n# Test case 20: Sequence with n=1, all_same type\n./gen -n 1 -type all_same\n\n# Test case 21: Sequence with n=1, no_duplicates type\n./gen -n 1 -type no_duplicates\n\n# Test case 22: Sequence with n=100, all_same type\n./gen -n 100 -type all_same\n\n# Test case 23: Sequence with n=100, extremes type\n./gen -n 100 -type extremes -max_num 1000\n\n# Test case 24: Sequence with n=50, descending order, max_num=1000\n./gen -n 50 -type descending -max_num 1000\n\n# Test case 25: Sequence with n=50, ascending order, max_num=1000\n./gen -n 50 -type ascending -max_num 1000\n\n# Test case 26: Random sequences with varying n\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 30 -type random\n./gen -n 40 -type random\n./gen -n 50 -type random\n./gen -n 60 -type random\n./gen -n 70 -type random\n./gen -n 80 -type random\n./gen -n 90 -type random\n./gen -n 100 -type random\n\n# Test case 27: Random sequences with varying max_num\n./gen -n 50 -type random -max_num 1\n./gen -n 50 -type random -max_num 10\n./gen -n 50 -type random -max_num 100\n./gen -n 50 -type random -max_num 500\n./gen -n 50 -type random -max_num 1000\n\n# Test case 28: Sequence with n=100, no_duplicates, max_num=1000\n./gen -n 100 -type no_duplicates -max_num 1000\n\n# Test case 29: Sequence with numbers between 1 and 100, n=100\n./gen -n 100 -type random -max_num 100\n\n# Test case 30: Random sequences with varying sizes\n./gen -n 17 -type random\n./gen -n 33 -type random\n./gen -n 41 -type random\n./gen -n 65 -type random\n./gen -n 89 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:46.123479",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "34/D",
      "title": "D. Карта дорог",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке через пробел записано три целых числа n, r1, r2 (2 ≤ n ≤ 5·104, 1 ≤ r1 ≠ r2 ≤ n) — количество городов в Берляндии, номер исходной столицы и номер новой столицы соответственно.На следующей строке через пробел записано n - 1 целых чисел — старое представление карты дорог. Для всех городов за исключением r1 задано целое число pi — номер последнего города на пути из столицы в город i. Все города описаны в порядке увеличения номеров.",
      "output_spec": "Выходные данныеВыведите n - 1 чисел — новое представление карты дорог в том же формате.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 2 32 2Выходные данныеСкопировать2 3 Входные данныеСкопировать6 2 46 1 2 4 2Выходные данныеСкопировать6 4 1 4 2",
      "description": "D. Карта дорог\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записано три целых числа n, r1, r2 (2 ≤ n ≤ 5·104, 1 ≤ r1 ≠ r2 ≤ n) — количество городов в Берляндии, номер исходной столицы и номер новой столицы соответственно.На следующей строке через пробел записано n - 1 целых чисел — старое представление карты дорог. Для всех городов за исключением r1 задано целое число pi — номер последнего города на пути из столицы в город i. Все города описаны в порядке увеличения номеров.\n\nВходные данные\n\nВыходные данныеВыведите n - 1 чисел — новое представление карты дорог в том же формате.\n\nВыходные данные\n\nВходные данныеСкопировать3 2 32 2Выходные данныеСкопировать2 3 Входные данныеСкопировать6 2 46 1 2 4 2Выходные данныеСкопировать6 4 1 4 2\n\nВходные данныеСкопировать3 2 32 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 2 46 1 2 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6 4 1 4 2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #34 (Div. 2) - Codeforces",
          "content": "Приглашаем всех на очередной раунд Codeforces Format!На этом раунде я буду заменять Артема Рахова в его ставшей уже привычной роли администратора контеста. Дело в том, что Артём отправился участвовать в онсайте соревнования TopCoder Open (Algorithm). Удачи, Артём! :)Я со своей стороны постараюсь провести раунд без заминок.Раунд окончен, результаты.Выиграл участник с ником a4461497, а среди участников первого дивизиона - kuniavski. Все тесты к задачам:C, D, EГотовить раунд помогали Михаил Мирзаянов и Юлия Сатушина.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 519
        },
        {
          "title": "Codeforces Beta Round #34 (Div. 2) Разбор - Codeforces",
          "content": "Привет, мир! Это мой первый разбор. =)A. Разведка 2Нахождение минимума в массиве, с одим дополнительным сравнением первого и последнего элементов.B. РаспродажаОтрицательные элементы складываем в массив, сортируем, находим сумму m наибольших по модулю.C. СписокРешается массивом булей, единственная заковыка - с выводом, но вполне преодолима.D. Карта дорогСоздаем динамическую матрицу смежности, например, массивом стеков, заполняем. Потом волновым алгоритмом из r2, пробегаясь по каждой вершине один раз, пролучаем результирующий массив.E. СтолкновенияЗаведем переменную времени ct, которая вначале равна 0.Начинаем моделировать:Пусть dt равен t - ct, просматриваем все пары шариков, по формуле x1 + v1 * dt = x2 + v2 * dtdt = (x1 - x2) / (v2 - v1)находим минимальную dt - промежуток времени, через который какие-нибудь шарики столкнуться, или время моделирования закончится.Сдвигаем шарики на этот промежуток времени, снова просматриваем все пары, если координаты двух совпадают, меняем их скорости по формуле из условия.Повторять, пока ct не сравняется с t.Особое внимание стоит уделить точности, наверное на этом и подловили RAVEman'а с ACRush'ем. =)В принятом решении я использовал double и точность сравнений 10-10.Удачи в контестах!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1238
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u, int par) {\n  visited[u] = true;\n  for (int v : adj[u]) {\n    if (v == par) continue;\n    if (visited[v]) {\n      ensuref(false, \"Graph contains a cycle\");\n    }\n    dfs(v, u);\n  }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int r1 = inf.readInt(1, n, \"r1\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, n, \"r2\");\n    inf.readEoln();\n    ensuref(r1 != r2, \"r1 (%d) should not be equal to r2 (%d)\", r1, r2);\n\n    vector<int> pi(n + 1); // Indexing from 1 to n\n    int cnt_pi = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (i == r1) continue;\n        if (cnt_pi > 0) inf.readSpace();\n        pi[i] = inf.readInt(1, n, \"pi_i\");\n        ensuref(pi[i] != i, \"pi[%d] cannot be equal to i=%d\", i, i);\n        cnt_pi++;\n    }\n    inf.readEoln();\n    ensuref(cnt_pi == n -1, \"The number of pi's read (%d) is not equal to n -1 (%d)\", cnt_pi, n -1);\n\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        if (i == r1) continue;\n        int p = pi[i];\n        adj[i].push_back(p);\n        adj[p].push_back(i);\n    }\n\n    // Initialize visited array\n    visited.resize(n + 1, false);\n\n    // Start DFS from r1\n    dfs(r1, -1);\n\n    // Check that all nodes are visited\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            ensuref(false, \"Graph is not connected, node %d is not reachable from node %d\", i, r1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u, int par) {\n  visited[u] = true;\n  for (int v : adj[u]) {\n    if (v == par) continue;\n    if (visited[v]) {\n      ensuref(false, \"Graph contains a cycle\");\n    }\n    dfs(v, u);\n  }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int r1 = inf.readInt(1, n, \"r1\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, n, \"r2\");\n    inf.readEoln();\n    ensuref(r1 != r2, \"r1 (%d) should not be equal to r2 (%d)\", r1, r2);\n\n    vector<int> pi(n + 1); // Indexing from 1 to n\n    int cnt_pi = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (i == r1) continue;\n        if (cnt_pi > 0) inf.readSpace();\n        pi[i] = inf.readInt(1, n, \"pi_i\");\n        ensuref(pi[i] != i, \"pi[%d] cannot be equal to i=%d\", i, i);\n        cnt_pi++;\n    }\n    inf.readEoln();\n    ensuref(cnt_pi == n -1, \"The number of pi's read (%d) is not equal to n -1 (%d)\", cnt_pi, n -1);\n\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        if (i == r1) continue;\n        int p = pi[i];\n        adj[i].push_back(p);\n        adj[p].push_back(i);\n    }\n\n    // Initialize visited array\n    visited.resize(n + 1, false);\n\n    // Start DFS from r1\n    dfs(r1, -1);\n\n    // Check that all nodes are visited\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            ensuref(false, \"Graph is not connected, node %d is not reachable from node %d\", i, r1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u, int par) {\n  visited[u] = true;\n  for (int v : adj[u]) {\n    if (v == par) continue;\n    if (visited[v]) {\n      ensuref(false, \"Graph contains a cycle\");\n    }\n    dfs(v, u);\n  }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int r1 = inf.readInt(1, n, \"r1\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, n, \"r2\");\n    inf.readEoln();\n    ensuref(r1 != r2, \"r1 (%d) should not be equal to r2 (%d)\", r1, r2);\n\n    vector<int> pi(n + 1); // Indexing from 1 to n\n    int cnt_pi = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (i == r1) continue;\n        if (cnt_pi > 0) inf.readSpace();\n        pi[i] = inf.readInt(1, n, \"pi_i\");\n        ensuref(pi[i] != i, \"pi[%d] cannot be equal to i=%d\", i, i);\n        cnt_pi++;\n    }\n    inf.readEoln();\n    ensuref(cnt_pi == n -1, \"The number of pi's read (%d) is not equal to n -1 (%d)\", cnt_pi, n -1);\n\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        if (i == r1) continue;\n        int p = pi[i];\n        adj[i].push_back(p);\n        adj[p].push_back(i);\n    }\n\n    // Initialize visited array\n    visited.resize(n + 1, false);\n\n    // Start DFS from r1\n    dfs(r1, -1);\n\n    // Check that all nodes are visited\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            ensuref(false, \"Graph is not connected, node %d is not reachable from node %d\", i, r1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int r1 = opt<int>(\"r1\", -1);\n    int r2 = opt<int>(\"r2\", -1);\n\n    // Ensure r1 and r2 are valid\n    if (r1 == -1) {\n        r1 = rnd.next(1, n);\n    }\n    if (r2 == -1) {\n        do {\n            r2 = rnd.next(1, n);\n        } while (r2 == r1);\n    }\n\n    assert(1 <= r1 && r1 <= n);\n    assert(1 <= r2 && r2 <= n);\n    assert(r1 != r2);\n\n    // Build the tree\n    vector<int> parent(n + 1, 0); // parent[i] is the parent of node i in the tree rooted at r1\n\n    if (type == \"chain\") {\n        // Build a chain from r1 to n nodes\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        int prev = r1;\n        for (int u : nodes) {\n            parent[u] = prev;\n            prev = u;\n        }\n\n    } else if (type == \"star\") {\n        // All nodes connected directly to r1\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                parent[i] = r1;\n            }\n        }\n    } else if (type == \"binary\") {\n        // Build a complete binary tree rooted at r1\n\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n\n        queue<int> q;\n        q.push(r1);\n\n        int idx = 0;\n        while (!q.empty() && idx < nodes.size()) {\n            int u = q.front(); q.pop();\n            for (int k = 0; k < 2 && idx < nodes.size(); ++k) {\n                int v = nodes[idx++];\n                parent[v] = u;\n                q.push(v);\n            }\n        }\n\n    } else if (type == \"skewed\") {\n        // Skewed tree (like a chain but branches off randomly)\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        parent[nodes[0]] = r1;\n        for (int i = 1; i < nodes.size(); ++i) {\n            int u = nodes[i];\n            // Connect to any previous node with some bias to create skewness\n            int v = rnd.wnext(i, -2);\n            parent[u] = nodes[v];\n        }\n\n    } else {\n        // Random tree\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        parent[nodes[0]] = r1;\n        for (int i = 1; i < nodes.size(); ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i - 1)];\n            parent[u] = v;\n        }\n    }\n\n    // Output first line\n    printf(\"%d %d %d\\n\", n, r1, r2);\n\n    // Prepare the list of cities excluding r1, in increasing order\n    vector<int> cities;\n    for (int i = 1; i <= n; ++i) {\n        if (i != r1) {\n            cities.push_back(i);\n        }\n    }\n\n    // Output pi's for cities in order, excluding r1\n    for (size_t i = 0; i < cities.size(); ++i) {\n        int u = cities[i];\n        printf(\"%d\", parent[u]);\n        if (i + 1 < cities.size()) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int r1 = opt<int>(\"r1\", -1);\n    int r2 = opt<int>(\"r2\", -1);\n\n    // Ensure r1 and r2 are valid\n    if (r1 == -1) {\n        r1 = rnd.next(1, n);\n    }\n    if (r2 == -1) {\n        do {\n            r2 = rnd.next(1, n);\n        } while (r2 == r1);\n    }\n\n    assert(1 <= r1 && r1 <= n);\n    assert(1 <= r2 && r2 <= n);\n    assert(r1 != r2);\n\n    // Build the tree\n    vector<int> parent(n + 1, 0); // parent[i] is the parent of node i in the tree rooted at r1\n\n    if (type == \"chain\") {\n        // Build a chain from r1 to n nodes\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        int prev = r1;\n        for (int u : nodes) {\n            parent[u] = prev;\n            prev = u;\n        }\n\n    } else if (type == \"star\") {\n        // All nodes connected directly to r1\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                parent[i] = r1;\n            }\n        }\n    } else if (type == \"binary\") {\n        // Build a complete binary tree rooted at r1\n\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n\n        queue<int> q;\n        q.push(r1);\n\n        int idx = 0;\n        while (!q.empty() && idx < nodes.size()) {\n            int u = q.front(); q.pop();\n            for (int k = 0; k < 2 && idx < nodes.size(); ++k) {\n                int v = nodes[idx++];\n                parent[v] = u;\n                q.push(v);\n            }\n        }\n\n    } else if (type == \"skewed\") {\n        // Skewed tree (like a chain but branches off randomly)\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        parent[nodes[0]] = r1;\n        for (int i = 1; i < nodes.size(); ++i) {\n            int u = nodes[i];\n            // Connect to any previous node with some bias to create skewness\n            int v = rnd.wnext(i, -2);\n            parent[u] = nodes[v];\n        }\n\n    } else {\n        // Random tree\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (i != r1) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        parent[nodes[0]] = r1;\n        for (int i = 1; i < nodes.size(); ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i - 1)];\n            parent[u] = v;\n        }\n    }\n\n    // Output first line\n    printf(\"%d %d %d\\n\", n, r1, r2);\n\n    // Prepare the list of cities excluding r1, in increasing order\n    vector<int> cities;\n    for (int i = 1; i <= n; ++i) {\n        if (i != r1) {\n            cities.push_back(i);\n        }\n    }\n\n    // Output pi's for cities in order, excluding r1\n    for (size_t i = 0; i < cities.size(); ++i) {\n        int u = cities[i];\n        printf(\"%d\", parent[u]);\n        if (i + 1 < cities.size()) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random\n\n./gen -n 50 -type random\n./gen -n 50 -type skewed\n./gen -n 50 -type binary\n\n./gen -n 1000 -type random\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n\n./gen -n 50000 -type random\n./gen -n 50000 -type chain\n./gen -n 50000 -type star\n\n./gen -n 50000 -type skewed\n./gen -n 50000 -type binary\n\n# Old and new capital are adjacent nodes\n./gen -n 1000 -type random -r1 1 -r2 2\n\n# Old capital is node 1, new capital is node n\n./gen -n 1000 -type chain -r1 1 -r2 1000\n\n# Old capital is leaf, new capital is leaf\n./gen -n 1000 -type chain -r1 1 -r2 1000\n\n# Old capital in the middle\n./gen -n 1000 -type chain -r1 500 -r2 1000\n\n# New capital in the middle\n./gen -n 1000 -type chain -r1 1 -r2 500\n\n# Random large tree with specific capitals\n./gen -n 50000 -type random -r1 1 -r2 50000\n\n# Binary tree with specific capitals\n./gen -n 1000 -type binary -r1 1 -r2 256\n\n# Skewed tree with specific capitals\n./gen -n 1000 -type skewed -r1 1 -r2 1000\n\n# Star tree with old capital at center\n./gen -n 50000 -type star -r1 1 -r2 50000\n\n# Star tree with new capital at center\n./gen -n 50000 -type star -r1 50000 -r2 1\n\n# Small tree with random capitals\n./gen -n 10 -type random\n\n# Medium tree with random capitals\n./gen -n 10000 -type random\n\n# Maximum n with random capitals\n./gen -n 50000 -type random\n\n# Tree with minimum possible depth\n./gen -n 50000 -type star\n\n# Tree with maximum possible depth\n./gen -n 50000 -type chain\n\n# Random tree with old and new capitals at random positions\n./gen -n 50000 -type random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:47.741370",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "34/E",
      "title": "E. Collisions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and t (1 ≤ n ≤ 10, 0 ≤ t ≤ 100) — amount of balls and duration of the process. Then follow n lines, each containing three integers: xi, vi, mi (1 ≤ |vi|, mi ≤ 100, |xi| ≤ 100) — coordinate, speed and weight of the ball with index i at time moment 0.It is guaranteed that no two balls have the same coordinate initially. Also each collision will be a collision of not more than two balls (that is, three or more balls never collide at the same point in all times from segment [0;t]).",
      "output_spec": "OutputOutput n numbers — coordinates of the balls t seconds after. Output the numbers accurate to at least 4 digits after the decimal point.",
      "sample_tests": "ExamplesInputCopy2 93 4 50 7 8OutputCopy68.53846153844.538461538InputCopy3 101 2 34 -5 67 -8 9OutputCopy-93.666666667-74.666666667-15.666666667",
      "description": "E. Collisions\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and t (1 ≤ n ≤ 10, 0 ≤ t ≤ 100) — amount of balls and duration of the process. Then follow n lines, each containing three integers: xi, vi, mi (1 ≤ |vi|, mi ≤ 100, |xi| ≤ 100) — coordinate, speed and weight of the ball with index i at time moment 0.It is guaranteed that no two balls have the same coordinate initially. Also each collision will be a collision of not more than two balls (that is, three or more balls never collide at the same point in all times from segment [0;t]).\n\nOutputOutput n numbers — coordinates of the balls t seconds after. Output the numbers accurate to at least 4 digits after the decimal point.\n\nInputCopy2 93 4 50 7 8OutputCopy68.53846153844.538461538InputCopy3 101 2 34 -5 67 -8 9OutputCopy-93.666666667-74.666666667-15.666666667\n\nInputCopy2 93 4 50 7 8\n\nOutputCopy68.53846153844.538461538\n\nInputCopy3 101 2 34 -5 67 -8 9\n\nOutputCopy-93.666666667-74.666666667-15.666666667",
      "solutions": [
        {
          "title": "Codeforces Beta Round #34 (Div. 2) - Codeforces",
          "content": "Welcome all to the next Codeforces Format round!In this round I will replace Artem Rakhov in his usual role of contest administrator: Artem have set out to America to take part in TopCoder Open Algorithm onsite. Good luck, Artem!The contest has ended, results.User a4461497 has won the contest, while among first-division users - kuniavski was the first who solved all 5 problems. All tests to the contest problems:C, D, EThanks to Michael Mirzayanov and Julia Satushina who helped to prepare this round.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 504
        },
        {
          "title": "Codeforces Beta Round #34 (Div. 2) Разбор - Codeforces",
          "content": "Привет, мир! Это мой первый разбор, просьба сильно не пинать. =)A. Разведка 2Нахождение минимума в массиве, с одим дополнительным сравнением первого и последнего элементов.B. РаспродажаОтрицательные элементы складываем в массив, сортируем, находим сумму m наибольших по модулю.C. СписокРешается массивом булей, единственная заковыка - с выводом, но вполне преодолима.D. Карта дорогСоздаем динамическую матрицу смежности, например, массивом стеков, заполняем. Потом волновым алгоритмом из r2, пробегаясь по каждой вершине один раз, пролучаем результирующий массив.E. СтолкновенияЗаведем переменную времени ct, которая вначале равна 0.Начинаем моделировать:Пусть dt равен t - ct, просматриваем все пары шариков, по формуле x1 + v1 * dt = x2 + v2 * dtdt = (x1 - x2) / (v2 - v1)находим минимальную dt - промежуток времени, через который какие-нибудь шарики столкнуться, или время моделирования закончится.Сдвигаем шарики на этот промежуток времени, снова просматриваем все пары, если координаты двух совпадают, меняем их скорости по формуле из условия.Повторять, пока ct не сравняется с t.Особое внимание стоит уделить точности, наверное на этом и подловили RAVEman'а с ACRush'ем. =)В принятом решении я использовал double и точность сравнений 10-10.Удачи в контестах!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1264
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int tmax = inf.readInt(0, 100, \"t\");\n    inf.readEoln();\n\n    vector<int> xi0(n), vi(n), mi(n);\n    for (int i = 0; i < n; ++i) {\n        xi0[i] = inf.readInt(-100, 100, \"xi\");\n        inf.readSpace();\n        vi[i] = inf.readInt(-100, 100, \"vi\");\n        ensuref(vi[i] != 0, \"vi[%d] should not be zero\", i+1);\n        ensuref(abs(vi[i]) >= 1, \"1 <= |vi[%d]| <= 100\", i+1);\n        inf.readSpace();\n        mi[i] = inf.readInt(1, 100, \"mi\");\n        inf.readEoln();\n    }\n\n    // Check xi are distinct\n    for (int i = 0; i < n; ++i)\n        for(int j = i + 1; j < n; ++j)\n            ensuref(abs(xi0[i] - xi0[j]) > 1e-8, \"xi[%d]=%d and xi[%d]=%d should be distinct\", i+1, xi0[i], j+1, xi0[j]);\n    \n    // Check that during [0, tmax], no collision of more than two balls occurs\n    vector<tuple<double, int, int>> collision_events; // (time, ball i, ball j)\n    for (int i = 0; i < n; ++i)\n        for (int j = i +1; j < n; ++j) {\n            if (vi[i] == vi[j]) continue; // No collision\n            double t_collide = (xi0[j] - xi0[i]) / double(vi[i] - vi[j]);\n            if (t_collide < 0 || t_collide > tmax) continue;\n            collision_events.emplace_back(t_collide, i, j);\n        }\n\n    // Sort collision events by time\n    sort(collision_events.begin(), collision_events.end());\n\n    for (const auto& event : collision_events) {\n        double t_collide = get<0>(event);\n        int i = get<1>(event);\n        int j = get<2>(event);\n        // Compute position at collision time\n        double xi = xi0[i] + vi[i] * t_collide;\n        double xj = xi0[j] + vi[j] * t_collide;\n        // Ensure positions are equal\n        ensuref(fabs(xi - xj) < 1e-8, \"Balls %d and %d do not collide at time %.10lf\", i+1, j+1, t_collide);\n\n        // Now check for other balls k != i,j\n        for (int k = 0; k < n; ++k) {\n            if (k == i || k == j) continue;\n            double xk = xi0[k] + vi[k] * t_collide;\n            if (fabs(xk - xi) < 1e-8) {\n                ensuref(false, \"At time %.10lf, balls %d, %d, and %d meet at position %.10lf\", t_collide, i+1, j+1, k+1, xi);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int tmax = inf.readInt(0, 100, \"t\");\n    inf.readEoln();\n\n    vector<int> xi0(n), vi(n), mi(n);\n    for (int i = 0; i < n; ++i) {\n        xi0[i] = inf.readInt(-100, 100, \"xi\");\n        inf.readSpace();\n        vi[i] = inf.readInt(-100, 100, \"vi\");\n        ensuref(vi[i] != 0, \"vi[%d] should not be zero\", i+1);\n        ensuref(abs(vi[i]) >= 1, \"1 <= |vi[%d]| <= 100\", i+1);\n        inf.readSpace();\n        mi[i] = inf.readInt(1, 100, \"mi\");\n        inf.readEoln();\n    }\n\n    // Check xi are distinct\n    for (int i = 0; i < n; ++i)\n        for(int j = i + 1; j < n; ++j)\n            ensuref(abs(xi0[i] - xi0[j]) > 1e-8, \"xi[%d]=%d and xi[%d]=%d should be distinct\", i+1, xi0[i], j+1, xi0[j]);\n    \n    // Check that during [0, tmax], no collision of more than two balls occurs\n    vector<tuple<double, int, int>> collision_events; // (time, ball i, ball j)\n    for (int i = 0; i < n; ++i)\n        for (int j = i +1; j < n; ++j) {\n            if (vi[i] == vi[j]) continue; // No collision\n            double t_collide = (xi0[j] - xi0[i]) / double(vi[i] - vi[j]);\n            if (t_collide < 0 || t_collide > tmax) continue;\n            collision_events.emplace_back(t_collide, i, j);\n        }\n\n    // Sort collision events by time\n    sort(collision_events.begin(), collision_events.end());\n\n    for (const auto& event : collision_events) {\n        double t_collide = get<0>(event);\n        int i = get<1>(event);\n        int j = get<2>(event);\n        // Compute position at collision time\n        double xi = xi0[i] + vi[i] * t_collide;\n        double xj = xi0[j] + vi[j] * t_collide;\n        // Ensure positions are equal\n        ensuref(fabs(xi - xj) < 1e-8, \"Balls %d and %d do not collide at time %.10lf\", i+1, j+1, t_collide);\n\n        // Now check for other balls k != i,j\n        for (int k = 0; k < n; ++k) {\n            if (k == i || k == j) continue;\n            double xk = xi0[k] + vi[k] * t_collide;\n            if (fabs(xk - xi) < 1e-8) {\n                ensuref(false, \"At time %.10lf, balls %d, %d, and %d meet at position %.10lf\", t_collide, i+1, j+1, k+1, xi);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int tmax = inf.readInt(0, 100, \"t\");\n    inf.readEoln();\n\n    vector<int> xi0(n), vi(n), mi(n);\n    for (int i = 0; i < n; ++i) {\n        xi0[i] = inf.readInt(-100, 100, \"xi\");\n        inf.readSpace();\n        vi[i] = inf.readInt(-100, 100, \"vi\");\n        ensuref(vi[i] != 0, \"vi[%d] should not be zero\", i+1);\n        ensuref(abs(vi[i]) >= 1, \"1 <= |vi[%d]| <= 100\", i+1);\n        inf.readSpace();\n        mi[i] = inf.readInt(1, 100, \"mi\");\n        inf.readEoln();\n    }\n\n    // Check xi are distinct\n    for (int i = 0; i < n; ++i)\n        for(int j = i + 1; j < n; ++j)\n            ensuref(abs(xi0[i] - xi0[j]) > 1e-8, \"xi[%d]=%d and xi[%d]=%d should be distinct\", i+1, xi0[i], j+1, xi0[j]);\n    \n    // Check that during [0, tmax], no collision of more than two balls occurs\n    vector<tuple<double, int, int>> collision_events; // (time, ball i, ball j)\n    for (int i = 0; i < n; ++i)\n        for (int j = i +1; j < n; ++j) {\n            if (vi[i] == vi[j]) continue; // No collision\n            double t_collide = (xi0[j] - xi0[i]) / double(vi[i] - vi[j]);\n            if (t_collide < 0 || t_collide > tmax) continue;\n            collision_events.emplace_back(t_collide, i, j);\n        }\n\n    // Sort collision events by time\n    sort(collision_events.begin(), collision_events.end());\n\n    for (const auto& event : collision_events) {\n        double t_collide = get<0>(event);\n        int i = get<1>(event);\n        int j = get<2>(event);\n        // Compute position at collision time\n        double xi = xi0[i] + vi[i] * t_collide;\n        double xj = xi0[j] + vi[j] * t_collide;\n        // Ensure positions are equal\n        ensuref(fabs(xi - xj) < 1e-8, \"Balls %d and %d do not collide at time %.10lf\", i+1, j+1, t_collide);\n\n        // Now check for other balls k != i,j\n        for (int k = 0; k < n; ++k) {\n            if (k == i || k == j) continue;\n            double xk = xi0[k] + vi[k] * t_collide;\n            if (fabs(xk - xi) < 1e-8) {\n                ensuref(false, \"At time %.10lf, balls %d, %d, and %d meet at position %.10lf\", t_collide, i+1, j+1, k+1, xi);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> vi(n);\n    vector<int> mi(n);\n\n    set<int> used_xi;\n\n    if (type == \"random\") {\n        /* Generate random positions, velocities, and masses */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = rnd.next(1, 100) * (rnd.next(0,1) ? 1 : -1);\n            mi[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"no_collision\") {\n        /* Generate balls moving in the same direction to avoid collisions */\n        vector<int> positions;\n        for (int x = -100; x <= 100; ++x) {\n            positions.push_back(x);\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(n);\n        sort(positions.begin(), positions.end());\n\n        bool positive_direction = rnd.next(0,1);\n        if (positive_direction) {\n            int v = rnd.next(1, 100);\n            for (int i = 0; i < n; ++i) {\n                xi[i] = positions[i];\n                vi[i] = v;\n                mi[i] = rnd.next(1, 100);\n                v = min(100, v + rnd.next(0,10));\n            }\n        } else {\n            int v = -rnd.next(1, 100);\n            for (int i = 0; i < n; ++i) {\n                xi[i] = positions[i];\n                vi[i] = v;\n                mi[i] = rnd.next(1, 100);\n                v = max(-100, v - rnd.next(0,10));\n            }\n        }\n    } else if (type == \"max_values\") {\n        /* Generate balls with maximum values */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = 100 * (rnd.next(0,1) ? 1 : -1);\n            mi[i] = 100;\n        }\n    } else if (type == \"min_values\") {\n        /* Generate balls with minimum values */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = (rnd.next(0,1) ? 1 : -1);\n            mi[i] = 1;\n        }\n    } else if (type == \"edge_case\") {\n        /* Generate a specific edge case for n = 3 */\n        if (n == 3) {\n            xi[0] = -10;\n            xi[1] = 0;\n            xi[2] = 10;\n            vi[0] = 2;\n            vi[1] = -1;\n            vi[2] = -3;\n            mi[0] = 2;\n            mi[1] = 2;\n            mi[2] = 2;\n        } else {\n            /* Fall back to random generation for other n */\n            for (int i = 0; i < n; ++i) {\n                int x;\n                do {\n                    x = rnd.next(-100, 100);\n                } while (used_xi.count(x));\n                xi[i] = x;\n                used_xi.insert(x);\n\n                vi[i] = rnd.next(1, 100) * (rnd.next(0,1) ? 1 : -1);\n                mi[i] = rnd.next(1, 100);\n            }\n        }\n    } else {\n        /* Default to random generation */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = rnd.next(1, 100) * (rnd.next(0,1) ? 1 : -1);\n            mi[i] = rnd.next(1, 100);\n        }\n    }\n\n    /* Output n and t */\n    cout << n << ' ' << t << endl;\n\n    /* Output xi, vi, mi for each ball */\n    for (int i = 0; i < n; ++i) {\n        cout << xi[i] << ' ' << vi[i] << ' ' << mi[i] << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> vi(n);\n    vector<int> mi(n);\n\n    set<int> used_xi;\n\n    if (type == \"random\") {\n        /* Generate random positions, velocities, and masses */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = rnd.next(1, 100) * (rnd.next(0,1) ? 1 : -1);\n            mi[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"no_collision\") {\n        /* Generate balls moving in the same direction to avoid collisions */\n        vector<int> positions;\n        for (int x = -100; x <= 100; ++x) {\n            positions.push_back(x);\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(n);\n        sort(positions.begin(), positions.end());\n\n        bool positive_direction = rnd.next(0,1);\n        if (positive_direction) {\n            int v = rnd.next(1, 100);\n            for (int i = 0; i < n; ++i) {\n                xi[i] = positions[i];\n                vi[i] = v;\n                mi[i] = rnd.next(1, 100);\n                v = min(100, v + rnd.next(0,10));\n            }\n        } else {\n            int v = -rnd.next(1, 100);\n            for (int i = 0; i < n; ++i) {\n                xi[i] = positions[i];\n                vi[i] = v;\n                mi[i] = rnd.next(1, 100);\n                v = max(-100, v - rnd.next(0,10));\n            }\n        }\n    } else if (type == \"max_values\") {\n        /* Generate balls with maximum values */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = 100 * (rnd.next(0,1) ? 1 : -1);\n            mi[i] = 100;\n        }\n    } else if (type == \"min_values\") {\n        /* Generate balls with minimum values */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = (rnd.next(0,1) ? 1 : -1);\n            mi[i] = 1;\n        }\n    } else if (type == \"edge_case\") {\n        /* Generate a specific edge case for n = 3 */\n        if (n == 3) {\n            xi[0] = -10;\n            xi[1] = 0;\n            xi[2] = 10;\n            vi[0] = 2;\n            vi[1] = -1;\n            vi[2] = -3;\n            mi[0] = 2;\n            mi[1] = 2;\n            mi[2] = 2;\n        } else {\n            /* Fall back to random generation for other n */\n            for (int i = 0; i < n; ++i) {\n                int x;\n                do {\n                    x = rnd.next(-100, 100);\n                } while (used_xi.count(x));\n                xi[i] = x;\n                used_xi.insert(x);\n\n                vi[i] = rnd.next(1, 100) * (rnd.next(0,1) ? 1 : -1);\n                mi[i] = rnd.next(1, 100);\n            }\n        }\n    } else {\n        /* Default to random generation */\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(-100, 100);\n            } while (used_xi.count(x));\n            xi[i] = x;\n            used_xi.insert(x);\n\n            vi[i] = rnd.next(1, 100) * (rnd.next(0,1) ? 1 : -1);\n            mi[i] = rnd.next(1, 100);\n        }\n    }\n\n    /* Output n and t */\n    cout << n << ' ' << t << endl;\n\n    /* Output xi, vi, mi for each ball */\n    for (int i = 0; i < n; ++i) {\n        cout << xi[i] << ' ' << vi[i] << ' ' << mi[i] << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -t 0 -type random\n./gen -n 1 -t 100 -type random\n./gen -n 2 -t 50 -type random\n./gen -n 5 -t 20 -type random\n./gen -n 10 -t 100 -type random\n\n./gen -n 2 -t 0 -type no_collision\n./gen -n 2 -t 100 -type no_collision\n./gen -n 5 -t 50 -type no_collision\n./gen -n 10 -t 100 -type no_collision\n\n./gen -n 2 -t 100 -type max_values\n./gen -n 5 -t 100 -type max_values\n./gen -n 10 -t 100 -type max_values\n\n./gen -n 2 -t 100 -type min_values\n./gen -n 5 -t 100 -type min_values\n./gen -n 10 -t 100 -type min_values\n\n./gen -n 3 -t 10 -type edge_case\n\n./gen -n 10 -t 0 -type random\n./gen -n 10 -t 0 -type max_values\n./gen -n 10 -t 0 -type min_values\n\n./gen -n 10 -t 100 -type random\n./gen -n 7 -t 70 -type random\n./gen -n 3 -t 30 -type random\n\n./gen -n 10 -t 1 -type random\n./gen -n 10 -t 99 -type random\n\n./gen -n 1 -t 50 -type max_values\n./gen -n 1 -t 50 -type min_values\n\n./gen -n 3 -t 30 -type no_collision\n./gen -n 5 -t 60 -type no_collision\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:50.156277",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "340/A",
      "title": "A. The Wall",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input will have a single line containing four integers in this order: x, y, a, b. (1 ≤ x, y ≤ 1000, 1 ≤ a, b ≤ 2·109, a ≤ b).",
      "output_spec": "OutputOutput a single integer — the number of bricks numbered no less than a and no greater than b that are painted both red and pink.",
      "sample_tests": "ExamplesInputCopy2 3 6 18OutputCopy3",
      "description": "A. The Wall\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input will have a single line containing four integers in this order: x, y, a, b. (1 ≤ x, y ≤ 1000, 1 ≤ a, b ≤ 2·109, a ≤ b).\n\nOutputOutput a single integer — the number of bricks numbered no less than a and no greater than b that are painted both red and pink.\n\nInputCopy2 3 6 18OutputCopy3\n\nInputCopy2 3 6 18\n\nOutputCopy3\n\nNoteLet's look at the bricks from a to b (a = 6, b = 18). The bricks colored in red are numbered 6, 8, 10, 12, 14, 16, 18. The bricks colored in pink are numbered 6, 9, 12, 15, 18. The bricks colored in both red and pink are numbered with 6, 12 and 18.",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 340\\s*A"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(1, 1000, \"x\"); inf.readSpace();\n    int y = inf.readInt(1, 1000, \"y\"); inf.readSpace();\n    int a = inf.readInt(1, 2000000000, \"a\"); inf.readSpace();\n    int b = inf.readInt(a, 2000000000, \"b\"); inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(1, 1000, \"x\"); inf.readSpace();\n    int y = inf.readInt(1, 1000, \"y\"); inf.readSpace();\n    int a = inf.readInt(1, 2000000000, \"a\"); inf.readSpace();\n    int b = inf.readInt(a, 2000000000, \"b\"); inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(1, 1000, \"x\"); inf.readSpace();\n    int y = inf.readInt(1, 1000, \"y\"); inf.readSpace();\n    int a = inf.readInt(1, 2000000000, \"a\"); inf.readSpace();\n    int b = inf.readInt(a, 2000000000, \"b\"); inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int x, y;\n    long long a, b;\n\n    if (type == \"random\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"xy_equal\") {\n        x = rnd.next(1, 1000);\n        y = x;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"x1\") {\n        x = 1;\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"y1\") {\n        x = rnd.next(1, 1000);\n        y = 1;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"x_divides_y\") {\n        x = rnd.next(1, 1000);\n        int k = rnd.next(1, 1000 / x);\n        y = x * k;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"y_divides_x\") {\n        y = rnd.next(1, 1000);\n        int k = rnd.next(1, 1000 / y);\n        x = y * k;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"co_prime\") {\n        vector<int> primes;\n        for (int i = 2; i <= 1000; i++) {\n            bool is_prime = true;\n            for (int j = 2; j*j <= i; j++) {\n                if (i % j == 0) is_prime = false;\n            }\n            if (is_prime) primes.push_back(i);\n        }\n        x = primes[rnd.next((int)primes.size())];\n        y = primes[rnd.next((int)primes.size())];\n        while (x == y) y = primes[rnd.next((int)primes.size())];\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"max_values\") {\n        x = 1000;\n        y = 1000;\n        a = 1LL;\n        b = 2000000000LL;\n    }\n    else if (type == \"small_range\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = a + rnd.next(0LL, 10LL);\n        if (b > 2000000000LL) b = 2000000000LL;\n    }\n    else if (type == \"a_equals_b\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = a;\n    }\n    else if (type == \"a_is_multiple\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        long long lcm = x / __gcd(x, y) * 1LL * y;\n        long long k = rnd.next(1LL, 2000000000LL / lcm) * lcm;\n        a = k;\n        b = a + rnd.next(0LL, 1000LL);\n        if (b > 2000000000LL) b = 2000000000LL;\n    }\n    else if (type == \"b_is_multiple\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        long long lcm = x / __gcd(x, y) * 1LL * y;\n        long long k = rnd.next(1LL, 2000000000LL / lcm) * lcm;\n        b = k;\n        a = b - rnd.next(0LL, 1000LL);\n        if (a < 1LL) a = 1LL;\n    }\n    else if (type == \"full_range\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = 1LL;\n        b = 2000000000LL;\n    }\n    else {\n        // Default to random\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n\n    printf(\"%d %d %lld %lld\\n\", x, y, a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int x, y;\n    long long a, b;\n\n    if (type == \"random\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"xy_equal\") {\n        x = rnd.next(1, 1000);\n        y = x;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"x1\") {\n        x = 1;\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"y1\") {\n        x = rnd.next(1, 1000);\n        y = 1;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"x_divides_y\") {\n        x = rnd.next(1, 1000);\n        int k = rnd.next(1, 1000 / x);\n        y = x * k;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"y_divides_x\") {\n        y = rnd.next(1, 1000);\n        int k = rnd.next(1, 1000 / y);\n        x = y * k;\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"co_prime\") {\n        vector<int> primes;\n        for (int i = 2; i <= 1000; i++) {\n            bool is_prime = true;\n            for (int j = 2; j*j <= i; j++) {\n                if (i % j == 0) is_prime = false;\n            }\n            if (is_prime) primes.push_back(i);\n        }\n        x = primes[rnd.next((int)primes.size())];\n        y = primes[rnd.next((int)primes.size())];\n        while (x == y) y = primes[rnd.next((int)primes.size())];\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n    else if (type == \"max_values\") {\n        x = 1000;\n        y = 1000;\n        a = 1LL;\n        b = 2000000000LL;\n    }\n    else if (type == \"small_range\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = a + rnd.next(0LL, 10LL);\n        if (b > 2000000000LL) b = 2000000000LL;\n    }\n    else if (type == \"a_equals_b\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = a;\n    }\n    else if (type == \"a_is_multiple\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        long long lcm = x / __gcd(x, y) * 1LL * y;\n        long long k = rnd.next(1LL, 2000000000LL / lcm) * lcm;\n        a = k;\n        b = a + rnd.next(0LL, 1000LL);\n        if (b > 2000000000LL) b = 2000000000LL;\n    }\n    else if (type == \"b_is_multiple\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        long long lcm = x / __gcd(x, y) * 1LL * y;\n        long long k = rnd.next(1LL, 2000000000LL / lcm) * lcm;\n        b = k;\n        a = b - rnd.next(0LL, 1000LL);\n        if (a < 1LL) a = 1LL;\n    }\n    else if (type == \"full_range\") {\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = 1LL;\n        b = 2000000000LL;\n    }\n    else {\n        // Default to random\n        x = rnd.next(1, 1000);\n        y = rnd.next(1, 1000);\n        a = rnd.next(1LL, 2000000000LL);\n        b = rnd.next(a, 2000000000LL);\n    }\n\n    printf(\"%d %d %lld %lld\\n\", x, y, a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type xy_equal\n./gen -type xy_equal\n\n./gen -type x1\n./gen -type y1\n\n./gen -type x_divides_y\n./gen -type y_divides_x\n\n./gen -type co_prime\n./gen -type co_prime\n\n./gen -type max_values\n\n./gen -type small_range\n./gen -type small_range\n./gen -type small_range\n\n./gen -type a_equals_b\n./gen -type a_equals_b\n\n./gen -type a_is_multiple\n./gen -type b_is_multiple\n\n./gen -type full_range\n./gen -type full_range\n\n./gen -type random\n./gen -type random\n\n./gen -type xy_equal\n./gen -type x1\n./gen -type y1\n\n./gen -type x_divides_y\n./gen -type y_divides_x\n\n./gen -type co_prime\n\n./gen -type small_range\n\n./gen -type a_equals_b\n\n./gen -type max_values\n\n./gen -type full_range\n\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:52.387869",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "340/B",
      "title": "B. Maximal Area Quadrilateral",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (4 ≤ n ≤ 300). Each of the next n lines contains two integers: xi, yi ( - 1000 ≤ xi, yi ≤ 1000) — the cartesian coordinates of ith special point. It is guaranteed that no three points are on the same line. It is guaranteed that no two points coincide.",
      "output_spec": "OutputOutput a single real number — the maximal area of a special quadrilateral. The answer will be considered correct if its absolute or relative error does't exceed 10 - 9.",
      "sample_tests": "ExamplesInputCopy50 00 44 04 42 3OutputCopy16.000000",
      "description": "B. Maximal Area Quadrilateral\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (4 ≤ n ≤ 300). Each of the next n lines contains two integers: xi, yi ( - 1000 ≤ xi, yi ≤ 1000) — the cartesian coordinates of ith special point. It is guaranteed that no three points are on the same line. It is guaranteed that no two points coincide.\n\nOutputOutput a single real number — the maximal area of a special quadrilateral. The answer will be considered correct if its absolute or relative error does't exceed 10 - 9.\n\nInputCopy50 00 44 04 42 3OutputCopy16.000000\n\nInputCopy50 00 44 04 42 3\n\nOutputCopy16.000000\n\nNoteIn the test example we can choose first 4 points to be the vertices of the quadrilateral. They form a square by side 4, so the area is 4·4 = 16.",
      "solutions": [
        {
          "title": "Codeforces Round #198 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #198, scheduled Friday, 30 August at 7:30 PM MSK. The authors of the problems are me and Linh (ll931110). We are also the authors of the Codeforces Round 191 (Div. 2). Last time, we received positive feedback for the round. We hope this round will be at least as good as the previous one. Linh brought to you D2-C/D1-A and D2-E/D1-C. I wrote the rest of the tasks. We hope you'll spend more time writing on the paper and thinking than typing on the PC. In addition, all tasks don't require too complicated algorithms. Instead, all require some creativity, hard working and patience. BTWs, the main character of the round will be Iahub, as in the previous one.I'd like to thank to DamianS, Gerald and Aksenov239 for testing the round. Without them, my job would have been certainly harder. Also, thanks to Delinur for translating the tasks and to MikeMirzayanov for the amazing Codeforces platform and Polygon system.We wish everyone high rating and to have fun!UPD1 The score distribution will be dynamic in both divisions. For more information please look here. The problems are sorted in our expected order of difficulty. UPD2 Thanks for everyone who participated. I hope you fount problems interesting. Also, I think my prevision that you'll think more than write was correct :)Congratulations to the winners.Division 1 yeputons KADR ftiasch Myth5 huzecong R_R_ Gabaum James ifsmirnov niyaznigmatul Special congratulations to Igor_Kudryashov, the only person who solved D1-E!Division 2 Azat_Yusupov angel_of_monkey molamola. iseriohn Mato_No1 silver__bullet TheDude Nero khuebeo uc-nuts UPD3 The editorial has been finished. I'm waiting for your feedback / questions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8748",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1734
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces",
          "content": "340A - The WallYou are given a range [A, B]. You're asked to compute fast how many numbers in the range are divisible by both x and y. I'll present here an O(log(max(x, y)) solution. We made tests low so other not optimal solutions to pass as well. The solution refers to the original problem, where x, y ≤ 109. Firstly, we can simplify the problem. Suppose we can calculate how many numbers are divisible in range [1, X] by both x and y. Can this solve our task? The answer is yes. All numbers in range [1, B] divisible by both numbers should be counted, except the numbers lower than A (1, 2, ..., A — 1). But, as you can see, numbers lower than A divisible by both numbers are actually numbers from range [1, A — 1]. So the answer of our task is f(B) — f(A — 1), where f(X) is how many numbers from 1, 2, ..., X are divisible by both x and y.For calculate in O(log(max(x, y)) the f(X) we need some math. If you don't know about it, please read firstly about least common multiple. Now, what will be the lowest number divisible by both x and y. The answer is least common multiple of x and y. Let's note it by M. The sequence of the numbers divisible by both x and y is M, 2 * M, 3 * M and so on. As a proof, suppose a number z is divisible by both x and y, but it is not in the above sequence. If a number is divisible by both x and y, it will be divisible by M also. If a number is divisible by M, it will be in the above sequence. Hence, the only way a number to be divisible by both x and y is to be in sequence M, 2 * M, 3 * M, ...The f(X) calculation reduces to finding the number of numbers from sequence M, 2 * M, 3 * M, ... lower or equal than X. It's obvious that if a number h * M is greater than X, so will be (h + 1) * M, (h + 2) * M and so on. We actually need to find the greatest integer number h such as h * M ≤ X. The numbers we're looking for will be 1 * M, 2 * M, ..., h * M (so their count will be h). The number h is actually [X / M], where [number] denotes the integer part of [number]. Take some examples on paper, you'll see why it's true.The only thing not discussed is how to calculate the number M given 2 number x and y. You can use this formula M = x * y / gcd(x, y). For calculate gcd(x, y) you can use Euclid's algorithm. Its complexity is O(log(max(x, y)), so this is the running time for the entire algorithm. Official solution: 4383403340B - Maximal Area QuadrilateralI want to apologize for not estimating the real difficulty of this task. It turns out that it was more complicated than we thought it might be. Let's start explanation.Before reading this, you need to know what is signed area of a triangle (also called cross product or ccw function). Without it, this explanation will make no sense. The first thing we note is that a quadrilateral self intersecting won't have maximum area. I'll show you this by an image made by my \"talents\" in Paint :) As you can see, if a quadrilateral self intersects, it can be transformed into one with greater area. Each quadrilateral has 2 diagonals: connecting 1st and 3rd point and connecting 2nd and 4th point. A diagonal divides a plane into 2 subplanes. Suppose diagonal is AB. A point X can be in one of those two subplanes: that making cross product positive and that making cross product negative. A point is in \"positive\" subplane if ccw(X, A, B) > 0 and in \"negative\" subplane ccw(X, A, B) < 0. Note that according to the constraints of the task, ccw(X, A, B) will never be 0.Let's make now the key observation of the task. We have a quadrilateral. Suppose AB is one of diagonals and C and D the other points from quadrilateral different by A and B. If the current quadrilateral could have maximal area, then one of points from C and D needs to be in \"positive subplane\" of AB and the other one in \"negative subplane\". What would happen if C and D will be in the same subplane of AB? The quadrilateral will self intersect. If it will self intersect, it won't have maximal area. \"A picture is worth a thousand words\" — this couldn't fit better in this case :) Note that the quadrilateral from the below image is A-C-B-D-A.Out task reduces to fix a diagonal (this taking O(N ^ 2) time) and then choose one point from the positive and the negative subplane of the diagonal. I'll say here how to choose the point from the positive subplane. That from negative subplane can be chosen identically. The diagonal and 3rd point chosen form a triangle. As we want quadrilateral to have maximal area, we need to choose 3rd point such as triangle makes the maximal area. As the positive and negative subplanes are disjoint, the choosing 3rd point from each of them can be made independently. Hence we get O(N ^ 3) complexity. A tricky case is when you choose a diagonal but one of the subplanes is empty. In this case you have to disregard the diagonal and move to the next one. Official solution: 4383413340C - Tourist ProblemDespite this is a math task, the only math formula we'll use is that number of permutations with n elements is n!. From this one, we can deduce the whole task.The average formula is sum_of_all_routes / number_of_routes. As each route is a permutation with n elements, number_of_routes is n!. Next suppose you have a permutation of a: p1, p2, …, pn. The sum for it will be p1 + |p2 – p1| + … + |pn – pn-1|. The sum of routes will be the sum for each possible permutation. We can calculate sum_of_all routes in two steps: first time we calculate sums like “p1” and then we calculate sums like “|p2 – p1| + … + |pn – pn-1|” for every existing permutation. First step Each element of a1, a2, …, an can appear on the first position on the routes and needs to be added as much as it appears. Suppose I fixed an element X for the first position. I can fill positions 2, 3, .., n – 1 in (n – 1)! ways. Why? It is equivalent to permuting n – 1 elements (all elements except X). So sum_of_all = a1 * (n – 1)! + a2 * (n – 1)! + … * an * (n – 1)! = (n – 1)! * (a1 + a2 + … + an).Second step For each permutation, for each position j between 1 and n – 1 we need to compute |pj — p(j + 1)|. Similarly to first step, we observe that only elements from a can appear on consecutive positions. We fix 2 indices i and j. We’re interested in how many permutations do ai appear before aj. We fix k such as on a permutation p, ai appears on position k and aj appears on a position k + 1. In how many ways can we fix this? n – 1 ways (1, 2, …, n – 1). What’s left? A sequence of (n – 2) elements which can be permuted independently. So the sum of second step is |ai - aj| * (n – 1) * (n – 2)!, for each i != j. If I note (a1 + a2 + … + an) by S1 and |ai - aj| for each i != j by S2, the answer is (N – 1)! * S1 + (N – 1)! * S2 / N!. By a simplification, the answer is (S1 + S2) / N.The only problem remained is how to calculate S2. Simple iteration won’t enter in time limit. Let’s think different. For each element, I need to make sum of differences between it and all smaller elements in the array a. As well, I need to make sum of all different between bigger elements than it and it. I’ll focus on the first part. I sort increasing array a. Suppose I’m at position i. I know that (i – 1) elements are smaller than ai. The difference is simply (i — 1) * ai — sum_of_elements_before_position_i. Sum of elements before position i can be computed when iterating i. Let’s call the obtained sum Sleft. I need to calculate now sum of all differences between an element and bigger elements than it. This sum is equal to Sleft. As a proof, for an element ai, calculating the difference aj — ai when aj > ai is equivalent to calculating differences between aj and a smaller element of it (in this case ai). That’s why Sleft = Sright.As a conclusion, the answer is (S1 + 2 * Sleft) / N. For make fraction irreducible, you can use Euclid's algorithm. The complexity of the presented algorithm is O(N * logN), necessary due of sorting. Sorting can be implemented by count sort as well, having a complexity of O(maximalValue), but this is not necessary.Official solution: 4383420340D - Bubble Sort GraphA good way to approach this problem is to notice that you can't build the graph. In worst case, the graph will be built in O(N2) complexity, which will time out. Also, notice that \"maximal independent set\" is a NP-Hard task, so even if you can build the graph you can't continue from there. So, the correct route to start is to think of graph's properties instead of building it. After sketching a little on the paper, you should find this property:Lemma 1 Suppose we choose 2 indices i and j, such as i < j. We'll have an edge on the graph between vertices ai and aj if and only if ai > aj. We'll call that i and j form an inversion in the permutation. Proof We assume we know the proof that bubble sort does sort correctly an array. To proof lemma 1, we need to show two things. Every inversion will be swapped by bubble sort. For each i < j when ai < aj, bubble sort will NOT swap this elements. To proof 1, if bubble sort wouldn't swap an inversion, the sequence wouldn't be sorted. But we know that bubble sort always sorts a sequence, so all inversions will be swapped. Proofing 2 is trivial, just by looking at the code.So far we've got how the graph G is constructed. Let's apply it in maximal independent set problem.Lemma 2 A maximal independent set of graph G is a longest increasing sequence for permutation a. Proof: Suppose we have a set of indices i1 < i2 < ... ik such as ai1, ai2, ..., aik form an independent set. Then, anyhow we'd choose d and e, there won't exist an edge between aid and aie. According to proof 1, this only happens when aid < aie. Hence, an independent set will be equivalent to an increasing sequence of permutation a. The maximal independent set is simply the maximal increasing sequence of permutation a.The task reduces to find longest increasing sequence for permutation a. This is a classical problem which can be solved in O(N * logN). Here is an interesting discussion about how to do it. 340E - Iahub and PermutationsIn this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.Dynamic programming solutionAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element. We observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.So from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.If k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.We want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.Case 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.Hence dp(n, k) += n * dp(n, k — 1).Case 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k — 1 of them. I choose an arbitrary number Y from those k — 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.Hence dp(n, k) += (k — 1) * dp(n + 1, k — 2).TL;DRdp[N][0]=N!dp[N][1]=N*dp[N][0]dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2This recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. LinkInclusion and exclusion principleI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points. We iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] = . Next, I have to fill tot - i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] = . Where is the problem to this formula?The problem is that it's possible, when permuting (tot — i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.Suppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does. To sum up in a \"LaTeX\" way, We can compute binomial coefficients using Pascal's triangle. Using inclusion and exclusion principle, we get O(N2). Please note that there exist an O(N) solution for this task, using inclusion and exclusion principle, but it's not necessary to get AC. I'll upload Gerald's source here.341D - Iahub and XorsThe motivation of the problem is that x ^ x = 0. x ^ x ^ x… ^ x (even times) = 0Update per range, query per elementWhen dealing with complicated problems, it's sometimes a good idea to try solving easier versions of them. Suppose you can query only one element each time (x0 = x1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I’ll do following operations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^= val. A[x1 + 1][y1 + 1] ^= val.To query about an element (X, Y), that element’s value will be the xor sum of submatrix A(1, 1, X, Y). Let’s take an example. I have a 6x6 matrix and I want to xor all elements from submatrix (2, 2, 3, 4) with a value. The below image should be explanatory how the method works:Next, by (1, 1, X, Y) I’ll denote xor sum for this submatrix.“White” cells are not influenced by (2, 2, 3, 4) matrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never intersect it. “Red” cells are from the submatrix, the ones that need to be xor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we need to xor (as it will contain (2, 2)). Next, “blue” cells. For this ones (1, 1, X, Y) will contain the value we xor with, despite they shouldn’t have it. This is why both (2, 5) and (4, 2) will be xor-ed again by that value, to cancel the xor of (2, 2). Now it’s okay, every “blue” cell do not contain the xor value in their (1, 1, X, Y). Finally, the “green” cells. These ones are intersection between the 2 blue rectangles. This means, in their (1, 1, X, Y) the value we xor with appears 3 times (this means it is contained 1 time). For cancel this, we xor (4, 5) with the value. Now for every green cell (1, 1, X, Y) contains 4 equal values, which cancel each other.You need a data structure do to the following 2 operations: Update an element (X, Y) (xor it with a value). Query about xor sum of (1, 1, X, Y). Both operations can be supported by a Fenwick tree 2D. If you don't know this data structure, learn it and come back to this problem after you do this. Coming back to our problemNow, instead of finding an element, I want xor sum of a submatrix. You can note that xor sum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 – 1, y1) ^ (1, 1, x1, y0 – 1) ^ (1, 1, x0 – 1, y0 – 1). This is a classical problem, the answer is (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1, x0 – 1, y1) and (1, 1, x1, y0 – 1). Right now I excluded (1, 1, x0 – 1, y0 – 1) 2 times, so I need to add it one more time.How to get the xor sum of submatrix (1, 1, X, Y)? In brute force approach, I’d take all elements (x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the definition of the previous problem, each element (x, y) is the xor sum of A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x, y), with 1 <= x <= X and 1 <= y <= Y.We can rewrite that long xor sum. A number A[x][y] appears in exactly (X – x + 1) * (Y – y + 1) terms of xor sum. If (X – x + 1) * (Y – y + 1) is odd, then the value A[x][y] should be xor-ed to the final result exactly once. If (X — x + 1) * (Y — y + 1) is even, it should be ignored.Below, you'll find 4 pictures. They are matrixes with X lines and Y columns. Each picture represents a case: (X odd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you observe a nice pattern? Elements colored represent those for which (X – x + 1) * (Y – y + 1) is odd. Yep, that's right! There are 4 cases, diving the matrix into 4 disjoint areas. When having a query of form (1, 1, X, Y) you only need specific elements sharing same parity with X and Y. This method works in O(4 * logN * logN) for each operation and is the indented solution. We keep 4 Fenwick trees 2D. We made tests such as solutions having complexity greater than O(4 * logN * logN) per operation to fail.Here is our official solution: 4383473341E - Candies GameKey observation Suppose you have 3 boxes containing A, B, C candies (A, B, C all greater than 0). Then, there will be always possible to empty one of boxes using some moves.Proof We can suppose that A <= B <= C. We need some moves such as the minimum from A, B, C will be zero. If we always keep the numbers in order A <= B <= C, it’s enough some moves such as A = 0. I’ll call this notation (A, B, C).How can we prove that always exist such moves? We can use reductio ad absurdum to prove it. Let’s suppose, starting from (A, B, C) we can go to a state (A2, B2, C2). We suppose A2 (A2 > 0) is minimal from every state we can obtain. Since A2 is minimal number of coins that can be obtained and A2 is not zero, the statement is equivalent with we can’t empty one chest from configuration (A, B, C). Then, we can prove that from (A2, B2, C2) we can go to a state (A3, B3, C3), where A3 < A2. Obviously, this contradicts our assumption that A2 is minimal of every possible states. If A2 would be minimal, then there won’t be any series of moves to empty one chest. But A2 isn’t minimal, hence there always exist some moves to empty one chest.Our algorithm so far:void emptyOneBox(int A, int B, int C) {if A is 0, then exit function.Make some moves such as to find another state (A2, B2, C2) with A2 < A.emptyOneBox (A2, B2, C2);}The only problem which needs to be proven now is: given a configuration (A, B, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A? The answer is always yes, below I’ll prove why.Firstly, let’s imagine we want to constantly move candies into a box. It doesn't matter yet from where come the candies, what matters is candies arrive into the box. The box has initially X candies. After 1 move, it will have 2 * X candies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X candies. Generally, after K moves, the box will contain 2^K * X candies.We have A < B < C (if 2 numbers are equal, we can make a move and empty 1 box). If we divide B by A, we get from math that B = A * q + r. (obviously, always r < A). What if we can move exactly A * q candies from B to A? Then, our new state would be (r, B2, C2). We have now a number A2 = r, such as A2 < A.How can we move exactly A * q coins? Let’s write q in base 2. Making that, q will be written as a sum of powers of 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get every number k from 0 to lim. For each k, I push into the first box (the box containing initially A candies) a certain number of candies. As proven before, I'll need to push (2 ^ k) * A candies. Let's take a look at the k-th bit from binary representation of q. If k-th bit is 1, B will be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^ (other_power_2) + ...) + r. Hence, I'll be able to move A * (2 ^ k) candies from \"B box\" to \"A box\". Otherwise, I'll move from \"C box\" to \"A box\". It will be always possible to do this move, as C > B and I could do that move from B, too.The proposed algorithm may look abstract, so let's take an example. Suppose A = 3, B = 905 and C = 1024. Can we get less than 3 for this state?B = 3 * 301 + 2. B = 3 * (100101101)2 + 2.K = 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we can move from B to A.A = 6, B = 3 * (100101100)2 + 2 C = 1024K = 1: we need to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0, we have to move from C.A = 12, B = 3 * (100101100)2 + 2 C = 1018K = 2: we need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can move from B.A = 24, B = 3 * (100101000)2 + 2 C = 1018K = 3: we need to move (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.A = 48, B = 3 * (100100000)2 + 2 C = 1018K = 4. we need to move (2 ^ 4) * 3 coins into A. 4th bit of q is 0, we need to move from C.A = 96, B = 3 * (100100000)2 + 2 C = 970K = 5. we need to move (2 ^ 5) * 3 coins into A. 5th bit of q is 1, so we need to move from B.A = 192, B = 3 * (100000000)2 + 2 C = 970K = 6 we need to move (2 ^ 6) * 3 coins into A. We mve them from C.A = 384 B = 3 * (100000000)2 + 2 C = 778K = 7 we need to move (2 ^ 7) * 3 coins into A. We move them from CA = 768 B = 3 * (100000000)2 + 2 C = 394K=8 Finally, we can move our last 1 bit from B to A.A = 1536 B = 3 * (000000000)2 + 2 C = 394A = 1536 B = (3 * 0 + 2) C = 394In the example, from (3, 905, 1024) we can arrive to (2, 394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0, X, Y), because 394 = 2 * 197 + 0.This is how you could write emptyOneBox() procedure. The remained problem is straight-forward: if initially there are zero or one boxes having candies, the answer is \"-1\". Otherwise, until there are more than 2 boxes having candies, pick 3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing the algorithm. 4383485BONUSInstead of a conclusion, I'll post here related problems to the ones used in the round. :) Please note that some of them might be more easier / complicated than level of difficulty used in the round. Feel free to think of them / ask help / discuss them in the comment section :)Div2 A Suppose x, y, A, B ≤ 109. Instead of being asked how many bricks are colored with both red and pink in range [A, B], you're asked how many bricks are colored with at least one color. After you solve this one, solve the same problem, but instead of having 2 persons painting, you have k persons (k ≤ 20). Solution by EnchomDiv2 B Given a very long list of special points, can you find quickly a convex special quadrilateral? Can you find very very quickly? :) Also, can you find maximal area of a special convex quadrilateral in time better than O(N4)? Solutions for first problem and second problem provided by Xellos and EnchomDiv2 D / Div1 B Suppose the reverse problem. You are given a bubble sort graph having N vertices and M edges. Find its independent maximal set. Can you achieve O(N2) to do this? Does a solution in O((N + M) + N * logN) exist? Solution by CountZeroDiv2 E / Div1 C Find a solution running in liniar time. Solution (dynamic programming) by ivan100sic . Solution (inclusion exclusion principle) by eduardischeDiv1 D Suppose the 3D version of this problem. You have a 3D matrix and you perform same QUERY/UPDATE operations, but using 6 parameters (a submatrix is defined now all elements a[i][j][k] for which x0 <= i <= x1, y0 <= j <= y1, z0 <= k <= z1). Can you get a solution using O(log3 * N) per query, having constant 8? But for d dimensions, does an O(2d * (logd)n) algorithm per query exist? :) Solution by Dwylkz.Div1 E In our algorithm, we pick arbitrary 3 boxes. Can you find some heuristics of picking 3 boxes to reduce number of moves?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 340\\s*B"
          },
          "content_length": 27282
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #198 - Codeforces - Code 1",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 2",
          "code": "fenwich tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 3",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 4",
          "code": "Output: 0\nAnswer: 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 5",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 6",
          "code": "typedef long long X;\n#define LL X",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 7",
          "code": "g++ -O2 main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 8",
          "code": "g++ main.cpp -S -fverbose-asm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 9",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 10",
          "code": "#include<stdio.h>\n\nlong long ar[3]={2,3,5};\nlong long ss,ans,num;\nint i;\n\nint main(){\n    for(i=0;i<3;i++){\n        ans += ((ar[i]*i) - ss);\n        ss += ar[i];\n    }\n    num = ss + 2*ans;\n    printf(\"%I64d\\n\",num);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 11",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 - Codeforces - Code 12",
          "code": "ar={2,3,5}\nss=ans=num=i=0\nss'=ss\nss+=ar[0]\nss+=ar[1]\nss+=ar[2]\nans-=ss'\nss'*=2\nans-=ss'\ni=3\ntmp=ans*2\ntmp+=ss\nnum=tmp\nprint num",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8748",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 1",
          "code": "+(i-1)*D[i-2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 2",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 3",
          "code": "D[i] = ends*D[i-1] + (i-1)*D[i-1];\nD[i] = (ends+i-1)*D[i-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 4",
          "code": "D[i] = (ends+i-1)*D[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #198 — Editorial - Codeforces - Code 5",
          "code": "if a[i] > a[i + 1] then                 add an undirected edge in G between a[i] and a[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 300);\n    inf.readEoln();\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000, 1000);\n        inf.readSpace();\n        int y = inf.readInt(-1000, 1000);\n        inf.readEoln();\n        points[i] = make_pair(x, y);\n    }\n    // Check for duplicate points\n    sort(points.begin(), points.end());\n    for (int i = 1; i < n; i++) {\n        ensuref(points[i] != points[i-1], \"Two points coincide at (%d, %d)\", points[i].first, points[i].second);\n    }\n    // Check for colinear triplets\n    for (int i = 0; i < n; i++) {\n        for (int j = i +1; j < n; j++) {\n            for (int k = j +1; k < n; k++) {\n                int x1 = points[i].first, y1 = points[i].second;\n                int x2 = points[j].first, y2 = points[j].second;\n                int x3 = points[k].first, y3 = points[k].second;\n                int dx1 = x2 - x1, dy1 = y2 - y1;\n                int dx2 = x3 - x1, dy2 = y3 - y1;\n                int cross = dx1 * dy2 - dy1 * dx2;\n                ensuref(cross != 0, \"Three points are colinear\");\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 300);\n    inf.readEoln();\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000, 1000);\n        inf.readSpace();\n        int y = inf.readInt(-1000, 1000);\n        inf.readEoln();\n        points[i] = make_pair(x, y);\n    }\n    // Check for duplicate points\n    sort(points.begin(), points.end());\n    for (int i = 1; i < n; i++) {\n        ensuref(points[i] != points[i-1], \"Two points coincide at (%d, %d)\", points[i].first, points[i].second);\n    }\n    // Check for colinear triplets\n    for (int i = 0; i < n; i++) {\n        for (int j = i +1; j < n; j++) {\n            for (int k = j +1; k < n; k++) {\n                int x1 = points[i].first, y1 = points[i].second;\n                int x2 = points[j].first, y2 = points[j].second;\n                int x3 = points[k].first, y3 = points[k].second;\n                int dx1 = x2 - x1, dy1 = y2 - y1;\n                int dx2 = x3 - x1, dy2 = y3 - y1;\n                int cross = dx1 * dy2 - dy1 * dx2;\n                ensuref(cross != 0, \"Three points are colinear\");\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 300);\n    inf.readEoln();\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(-1000, 1000);\n        inf.readSpace();\n        int y = inf.readInt(-1000, 1000);\n        inf.readEoln();\n        points[i] = make_pair(x, y);\n    }\n    // Check for duplicate points\n    sort(points.begin(), points.end());\n    for (int i = 1; i < n; i++) {\n        ensuref(points[i] != points[i-1], \"Two points coincide at (%d, %d)\", points[i].first, points[i].second);\n    }\n    // Check for colinear triplets\n    for (int i = 0; i < n; i++) {\n        for (int j = i +1; j < n; j++) {\n            for (int k = j +1; k < n; k++) {\n                int x1 = points[i].first, y1 = points[i].second;\n                int x2 = points[j].first, y2 = points[j].second;\n                int x3 = points[k].first, y3 = points[k].second;\n                int dx1 = x2 - x1, dy1 = y2 - y1;\n                int dx2 = x3 - x1, dy2 = y3 - y1;\n                int cross = dx1 * dy2 - dy1 * dx2;\n                ensuref(cross != 0, \"Three points are colinear\");\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    if (n < 4 || n > 300) {\n        cerr << \"Invalid n: \" << n << endl;\n        return 1;\n    }\n    if (type == \"random\") {\n        int maxAttempts = 10000;\n        vector<pair<int, int>> points;\n        set<pair<int, int>> pointSet;\n        while ((int)points.size() < n && maxAttempts--) {\n            int xi = rnd.next(-1000, 1000);\n            int yi = rnd.next(-1000, 1000);\n            if (pointSet.count({xi, yi})) continue;\n            bool colinear = false;\n            for (int i = 0; i < (int)points.size() && !colinear; ++i) {\n                for (int j = 0; j < i && !colinear; ++j) {\n                    int x1 = points[i].first, y1 = points[i].second;\n                    int x2 = points[j].first, y2 = points[j].second;\n                    long long area2 = (long long)(x1 - xi)*(y2 - yi) - (long long)(x2 - xi)*(y1 - yi);\n                    if (area2 == 0) {\n                        colinear = true;\n                    }\n                }\n            }\n            if (colinear) continue;\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n        }\n        if ((int)points.size() < n) {\n            cerr << \"Failed to generate enough points. Try increasing maxAttempts or lowering n.\\n\";\n            return 1;\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"non_colinear\") {\n        vector<pair<int, int>> points;\n        set<pair<int, int>> pointSet;\n        for (int i = 0; i < n; ++i) {\n            int xi = -1000 + i * (2000 / (n - 1));\n            int yi = (xi * xi) % 1997 - 998; // Quadratic function modulo to keep in range\n            if (pointSet.count({xi, yi})) continue; // Should not happen\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"square\") {\n        // Generate four corners of big square\n        vector<pair<int, int>> points;\n        points.push_back({-1000, -1000});\n        points.push_back({-1000, 1000});\n        points.push_back({1000, -1000});\n        points.push_back({1000, 1000});\n        set<pair<int, int>> pointSet(points.begin(), points.end());\n        int remaining = n - 4;\n        int maxAttempts = 10000;\n        while (remaining > 0 && maxAttempts--) {\n            int xi = rnd.next(-999, 999); // Avoid the corners\n            int yi = rnd.next(-999, 999);\n            if (pointSet.count({xi, yi})) continue;\n            bool colinear = false;\n            for (int i = 0; i < (int)points.size() && !colinear; ++i) {\n                for (int j = 0; j < i && !colinear; ++j) {\n                    int x1 = points[i].first, y1 = points[i].second;\n                    int x2 = points[j].first, y2 = points[j].second;\n                    long long area2 = (long long)(x1 - xi)*(y2 - yi) - (long long)(x2 - xi)*(y1 - yi);\n                    if (area2 == 0) {\n                        colinear = true;\n                    }\n                }\n            }\n            if (colinear) continue;\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n            --remaining;\n        }\n        if (remaining > 0) {\n            cerr << \"Failed to generate enough points. Try increasing maxAttempts or lowering n.\\n\";\n            return 1;\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"concave\") {\n        // Generate a set of points that includes a concave quadrilateral of maximal area\n        // Let's define four points in a 'kite' shape to make a concave quadrilateral\n        vector<pair<int, int>> points;\n        points.push_back({0, 0});\n        points.push_back({500, 0});\n        points.push_back({250, 1000});\n        points.push_back({250, -1000});\n        set<pair<int, int>> pointSet(points.begin(), points.end());\n        int remaining = n - 4;\n        int maxAttempts = 10000;\n        while (remaining > 0 && maxAttempts--) {\n            int xi = rnd.next(-999, 999);\n            int yi = rnd.next(-999, 999);\n            if (pointSet.count({xi, yi})) continue;\n            bool colinear = false;\n            for (int i = 0; i < (int)points.size() && !colinear; ++i) {\n                for (int j = 0; j < i && !colinear; ++j) {\n                    int x1 = points[i].first, y1 = points[i].second;\n                    int x2 = points[j].first, y2 = points[j].second;\n                    long long area2 = (long long)(x1 - xi)*(y2 - yi) - (long long)(x2 - xi)*(y1 - yi);\n                    if (area2 == 0) {\n                        colinear = true;\n                    }\n                }\n            }\n            if (colinear) continue;\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n            --remaining;\n        }\n        if (remaining > 0) {\n            cerr << \"Failed to generate enough points. Try increasing maxAttempts or lowering n.\\n\";\n            return 1;\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"precision\") {\n        // Generate points with large coordinates to test precision\n        vector<pair<int, int>> points;\n        int max_coord = 1000;\n        int min_coord = -1000;\n        int step = (max_coord - min_coord) / (n - 1);\n        for (int i = 0; i < n; ++i) {\n            int xi = min_coord + i * step;\n            int yi = xi * xi % 1997 - 998; // Quadratic function modulo\n            points.push_back({xi, yi});\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    if (n < 4 || n > 300) {\n        cerr << \"Invalid n: \" << n << endl;\n        return 1;\n    }\n    if (type == \"random\") {\n        int maxAttempts = 10000;\n        vector<pair<int, int>> points;\n        set<pair<int, int>> pointSet;\n        while ((int)points.size() < n && maxAttempts--) {\n            int xi = rnd.next(-1000, 1000);\n            int yi = rnd.next(-1000, 1000);\n            if (pointSet.count({xi, yi})) continue;\n            bool colinear = false;\n            for (int i = 0; i < (int)points.size() && !colinear; ++i) {\n                for (int j = 0; j < i && !colinear; ++j) {\n                    int x1 = points[i].first, y1 = points[i].second;\n                    int x2 = points[j].first, y2 = points[j].second;\n                    long long area2 = (long long)(x1 - xi)*(y2 - yi) - (long long)(x2 - xi)*(y1 - yi);\n                    if (area2 == 0) {\n                        colinear = true;\n                    }\n                }\n            }\n            if (colinear) continue;\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n        }\n        if ((int)points.size() < n) {\n            cerr << \"Failed to generate enough points. Try increasing maxAttempts or lowering n.\\n\";\n            return 1;\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"non_colinear\") {\n        vector<pair<int, int>> points;\n        set<pair<int, int>> pointSet;\n        for (int i = 0; i < n; ++i) {\n            int xi = -1000 + i * (2000 / (n - 1));\n            int yi = (xi * xi) % 1997 - 998; // Quadratic function modulo to keep in range\n            if (pointSet.count({xi, yi})) continue; // Should not happen\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"square\") {\n        // Generate four corners of big square\n        vector<pair<int, int>> points;\n        points.push_back({-1000, -1000});\n        points.push_back({-1000, 1000});\n        points.push_back({1000, -1000});\n        points.push_back({1000, 1000});\n        set<pair<int, int>> pointSet(points.begin(), points.end());\n        int remaining = n - 4;\n        int maxAttempts = 10000;\n        while (remaining > 0 && maxAttempts--) {\n            int xi = rnd.next(-999, 999); // Avoid the corners\n            int yi = rnd.next(-999, 999);\n            if (pointSet.count({xi, yi})) continue;\n            bool colinear = false;\n            for (int i = 0; i < (int)points.size() && !colinear; ++i) {\n                for (int j = 0; j < i && !colinear; ++j) {\n                    int x1 = points[i].first, y1 = points[i].second;\n                    int x2 = points[j].first, y2 = points[j].second;\n                    long long area2 = (long long)(x1 - xi)*(y2 - yi) - (long long)(x2 - xi)*(y1 - yi);\n                    if (area2 == 0) {\n                        colinear = true;\n                    }\n                }\n            }\n            if (colinear) continue;\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n            --remaining;\n        }\n        if (remaining > 0) {\n            cerr << \"Failed to generate enough points. Try increasing maxAttempts or lowering n.\\n\";\n            return 1;\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"concave\") {\n        // Generate a set of points that includes a concave quadrilateral of maximal area\n        // Let's define four points in a 'kite' shape to make a concave quadrilateral\n        vector<pair<int, int>> points;\n        points.push_back({0, 0});\n        points.push_back({500, 0});\n        points.push_back({250, 1000});\n        points.push_back({250, -1000});\n        set<pair<int, int>> pointSet(points.begin(), points.end());\n        int remaining = n - 4;\n        int maxAttempts = 10000;\n        while (remaining > 0 && maxAttempts--) {\n            int xi = rnd.next(-999, 999);\n            int yi = rnd.next(-999, 999);\n            if (pointSet.count({xi, yi})) continue;\n            bool colinear = false;\n            for (int i = 0; i < (int)points.size() && !colinear; ++i) {\n                for (int j = 0; j < i && !colinear; ++j) {\n                    int x1 = points[i].first, y1 = points[i].second;\n                    int x2 = points[j].first, y2 = points[j].second;\n                    long long area2 = (long long)(x1 - xi)*(y2 - yi) - (long long)(x2 - xi)*(y1 - yi);\n                    if (area2 == 0) {\n                        colinear = true;\n                    }\n                }\n            }\n            if (colinear) continue;\n            points.push_back({xi, yi});\n            pointSet.insert({xi, yi});\n            --remaining;\n        }\n        if (remaining > 0) {\n            cerr << \"Failed to generate enough points. Try increasing maxAttempts or lowering n.\\n\";\n            return 1;\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"precision\") {\n        // Generate points with large coordinates to test precision\n        vector<pair<int, int>> points;\n        int max_coord = 1000;\n        int min_coord = -1000;\n        int step = (max_coord - min_coord) / (n - 1);\n        for (int i = 0; i < n; ++i) {\n            int xi = min_coord + i * step;\n            int yi = xi * xi % 1997 - 998; // Quadratic function modulo\n            points.push_back({xi, yi});\n        }\n        printf(\"%d\\n\", n);\n        for (auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 75 -type random\n./gen -n 100 -type random\n\n./gen -n 4 -type square\n./gen -n 5 -type square\n./gen -n 50 -type square\n./gen -n 100 -type square\n./gen -n 200 -type square\n./gen -n 300 -type square\n\n./gen -n 4 -type concave\n./gen -n 5 -type concave\n./gen -n 50 -type concave\n./gen -n 100 -type concave\n./gen -n 200 -type concave\n./gen -n 300 -type concave\n\n./gen -n 4 -type non_colinear\n./gen -n 100 -type non_colinear\n./gen -n 200 -type non_colinear\n./gen -n 300 -type non_colinear\n\n./gen -n 4 -type precision\n./gen -n 100 -type precision\n./gen -n 200 -type precision\n./gen -n 300 -type precision\n\n# Random with larger n may take longer due to colinearity checks\n# So perhaps limit random type to n <= 100\n# Trying to generate maximum n with random type may be slow or fail\n\n# Additional test cases\n./gen -n 4 -type random\n./gen -n 6 -type random\n./gen -n 8 -type random\n\n./gen -n 4 -type square\n./gen -n 6 -type square\n./gen -n 8 -type square\n\n./gen -n 4 -type concave\n./gen -n 6 -type concave\n./gen -n 8 -type concave\n\n# More maximum size tests\n./gen -n 300 -type non_colinear\n./gen -n 300 -type precision\n./gen -n 300 -type square\n./gen -n 300 -type concave\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:10:54.218378",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}